/* do not edit automatically generated by mc from mcp5.  */
/* output from mc-5.bnf, automatically generated do not edit.

Copyright (C) 2016-2020 Free Software Foundation, Inc.
Contributed by Gaius Mulley <gaius.mulley@southwales.ac.uk>.

This file is part of GNU Modula-2.

GNU Modula-2 is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GNU Modula-2 is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with GNU Modula-2; see the file COPYING.  If not,
see <https://www.gnu.org/licenses/>.  */

#include "config.h"
#include "system.h"
#   if !defined (PROC_D)
#      define PROC_D
       typedef void (*PROC_t) (void);
       typedef struct { PROC_t proc; } PROC;
#   endif

#   if !defined (TRUE)
#      define TRUE (1==1)
#   endif

#   if !defined (FALSE)
#      define FALSE (1==0)
#   endif

#if defined(__cplusplus)
#   undef NULL
#   define NULL 0
#endif
#define _mcp5_H
#define _mcp5_C

#   include "GDynamicStrings.h"
#   include "GmcError.h"
#   include "GnameKey.h"
#   include "GmcPrintf.h"
#   include "GmcDebug.h"
#   include "GmcReserved.h"
#   include "GmcComment.h"
#   include "GmcMetaError.h"
#   include "GmcStack.h"
#   include "GmcLexBuf.h"
#   include "Gdecl.h"

#   define Pass1 FALSE
#   define Debugging FALSE
typedef unsigned int stop0;

typedef unsigned int SetOfStop0;

typedef unsigned int stop1;

typedef unsigned int SetOfStop1;

typedef unsigned int stop2;

typedef unsigned int SetOfStop2;

static unsigned int WasNoError;
static nameKey_Name curstring;
static nameKey_Name curident;
static decl_node curproc;
static decl_node frommodule;
static decl_node qualid;
static decl_node typeDes;
static decl_node typeExp;
static decl_node curmodule;
static unsigned int loopNo;
static mcStack_stack loopStk;
static mcStack_stack stmtStk;
static mcStack_stack withStk;
static mcStack_stack stk;

/*
   CompilationUnit - returns TRUE if the input was correct enough to parse
                     in future passes.
*/

unsigned int mcp5_CompilationUnit (void);

/*
   followNode -
*/

static void followNode (decl_node n);

/*
   push -
*/

static decl_node push (decl_node n);

/*
   pop -
*/

static decl_node pop (void);

/*
   replace -
*/

static decl_node replace (decl_node n);

/*
   peep - returns the top node on the stack without removing it.
*/

static decl_node peep (void);

/*
   depth - returns the depth of the stack.
*/

static unsigned int depth (void);

/*
   checkDuplicate -
*/

static void checkDuplicate (unsigned int b);

/*
   isQualident - returns TRUE if, n, is a qualident.
*/

static unsigned int isQualident (decl_node n);

/*
   startWith -
*/

static void startWith (decl_node n);

/*
   endWith -
*/

static void endWith (void);

/*
   lookupWithSym -
*/

static decl_node lookupWithSym (nameKey_Name i);

/*
   pushStmt - push a node, n, to the statement stack and return node, n.
*/

static decl_node pushStmt (decl_node n);

/*
   popStmt - pop the top node from the statement stack.
*/

static decl_node popStmt (void);

/*
   peepStmt - return the top node from the statement stack,
              but leave the stack unchanged.
*/

static decl_node peepStmt (void);

/*
   pushLoop - push a node, n, to the loop stack and return node, n.
*/

static decl_node pushLoop (decl_node n);

/*
   popLoop - pop the top node from the loop stack.
*/

static decl_node popLoop (void);

/*
   peepLoop - return the top node from the loop stack,
              but leave the stack unchanged.
*/

static decl_node peepLoop (void);

/*
   peepLoop - return the top node from the loop stack,
              but leave the stack unchanged.
*/

static void ErrorString (DynamicStrings_String s);

/*
   peepLoop - return the top node from the loop stack,
              but leave the stack unchanged.
*/

static void ErrorArray (char *a_, unsigned int _a_high);

/*
   pushNunbounded -
*/

static void pushNunbounded (unsigned int c);

/*
   makeIndexedArray - builds and returns an array of type, t, with, c, indices.
*/

static decl_node makeIndexedArray (unsigned int c, decl_node t);

/*
   importInto - from, m, import, name, into module, current.
                It checks to see if curident is an enumeration type
                and if so automatically includes all enumeration fields
                as well.
*/

static void importInto (decl_node m, nameKey_Name name, decl_node current);

/*
   checkEndName - if module does not have, name, then issue an error containing, desc.
*/

static void checkEndName (decl_node module, nameKey_Name name, char *desc_, unsigned int _desc_high);

/*
   DescribeStop - issues a message explaining what tokens were expected
*/

static DynamicStrings_String DescribeStop (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   DescribeError - issues a message explaining what tokens were expected
*/

static void DescribeError (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   SyntaxError - after a syntax error we skip all tokens up until we reach
                 a stop symbol.
*/

static void SyntaxError (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   SyntaxCheck -
*/

static void SyntaxCheck (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   WarnMissingToken - generates a warning message about a missing token, t.
*/

static void WarnMissingToken (mcReserved_toktype t);

/*
   MissingToken - generates a warning message about a missing token, t.
*/

static void MissingToken (mcReserved_toktype t);

/*
   CheckAndInsert -
*/

static unsigned int CheckAndInsert (mcReserved_toktype t, SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   InStopSet
*/

static unsigned int InStopSet (mcReserved_toktype t, SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   PeepToken - peep token checks to see whether the stopset is satisfied by currenttoken
               If it is not then it will insert a token providing the token
               is one of ; ] ) } . OF END ,

               if the stopset contains <identtok> then we do not insert a token
*/

static void PeepToken (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   Expect -
*/

static void Expect (mcReserved_toktype t, SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   Ident - error checking varient of Ident
*/

static void Ident (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   string -
*/

static void string (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   Integer -
*/

static void Integer (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   Real -
*/

static void Real (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   FileUnit := DefinitionModule  | ImplementationOrProgramModule 

   first  symbols:implementationtok, moduletok, definitiontok
   
   cannot reachend
*/

static void FileUnit (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   ProgramModule := 'MODULE' Ident 
                    % curmodule := lookupModule (curident)  %
                    
                    % addCommentBody (curmodule)  %
                    
                    % enterScope (curmodule)  %
                    
                    % resetConstExpPos (curmodule)  %
                    [ Priority  ] ';' { Import  } Block Ident 
                    
                    % checkEndName (curmodule, curident, 'program module')  %
                    
                    % leaveScope  %
                    '.' 

   first  symbols:moduletok
   
   cannot reachend
*/

static void ProgramModule (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   ImplementationModule := 'IMPLEMENTATION' 'MODULE' Ident 
                           % curmodule := lookupImp (curident)  %
                           
                           % addCommentBody (curmodule)  %
                           
                           % enterScope (lookupDef (curident))  %
                           
                           % enterScope (curmodule)  %
                           
                           % resetConstExpPos (curmodule)  %
                           [ Priority  ] ';' { Import  } Block 
                           Ident 
                           % checkEndName (curmodule, curident, 'implementation module')  %
                           
                           % leaveScope ; leaveScope  %
                           '.' 

   first  symbols:implementationtok
   
   cannot reachend
*/

static void ImplementationModule (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   ImplementationOrProgramModule := ImplementationModule  | 
                                    ProgramModule 

   first  symbols:moduletok, implementationtok
   
   cannot reachend
*/

static void ImplementationOrProgramModule (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   ConstInteger := Integer 
                   % VAR i: node ;  %
                   
                   % i := pop ()  %
                   

   first  symbols:integertok
   
   cannot reachend
*/

static void ConstInteger (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   ConstReal := Real 
                % VAR r: node ;  %
                
                % r := pop ()  %
                

   first  symbols:realtok
   
   cannot reachend
*/

static void ConstReal (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   ConstNumber := ConstInteger  | ConstReal 

   first  symbols:realtok, integertok
   
   cannot reachend
*/

static void ConstNumber (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   Number := Integer  | Real 

   first  symbols:realtok, integertok
   
   cannot reachend
*/

static void Number (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   Qualident := Ident { '.' Ident  } 

   first  symbols:identtok
   
   cannot reachend
*/

static void Qualident (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   ConstantDeclaration := Ident '=' ConstExpressionNop 

   first  symbols:identtok
   
   cannot reachend
*/

static void ConstantDeclaration (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   ConstExpressionNop := 
                         % VAR c: node ;  %
                         
                         % c := getNextConstExp ()  %
                         SimpleConstExpr [ Relation SimpleConstExpr  ] 

   first  symbols:attributetok, identtok, lcbratok, stringtok, nottok, lparatok, integertok, realtok, minustok, plustok
   
   cannot reachend
*/

static void ConstExpressionNop (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   ConstExpression := 
                      % VAR c: node ;  %
                      
                      % c := push (getNextConstExp ())  %
                      SimpleConstExpr [ Relation SimpleConstExpr  ] 

   first  symbols:attributetok, identtok, lcbratok, stringtok, nottok, lparatok, integertok, realtok, minustok, plustok
   
   cannot reachend
*/

static void ConstExpression (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   Relation := '='  | '#'  | '<>'  | '<'  | '<='  | '>'  | 
               '>='  | 'IN' 

   first  symbols:intok, greaterequaltok, greatertok, lessequaltok, lesstok, lessgreatertok, hashtok, equaltok
   
   cannot reachend
*/

static void Relation (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   SimpleConstExpr := UnaryOrConstTerm { AddOperator ConstTerm  } 

   first  symbols:stringtok, lcbratok, identtok, attributetok, realtok, integertok, lparatok, nottok, plustok, minustok
   
   cannot reachend
*/

static void SimpleConstExpr (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   UnaryOrConstTerm := '+' ConstTerm  | '-' ConstTerm  | 
                       ConstTerm 

   first  symbols:attributetok, identtok, lcbratok, stringtok, nottok, lparatok, integertok, realtok, minustok, plustok
   
   cannot reachend
*/

static void UnaryOrConstTerm (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   AddOperator := '+'  | '-'  | 'OR' 

   first  symbols:ortok, minustok, plustok
   
   cannot reachend
*/

static void AddOperator (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   ConstTerm := ConstFactor { MulOperator ConstFactor  } 

   first  symbols:stringtok, lcbratok, identtok, attributetok, realtok, integertok, lparatok, nottok
   
   cannot reachend
*/

static void ConstTerm (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   MulOperator := '*'  | '/'  | 'DIV'  | 'MOD'  | 'REM'  | 
                  'AND'  | '&' 

   first  symbols:ambersandtok, andtok, remtok, modtok, divtok, dividetok, timestok
   
   cannot reachend
*/

static void MulOperator (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   NotConstFactor := 'NOT' ConstFactor 
                     % VAR n: node ;  %
                     
                     % n := push (makeUnaryTok (nottok, pop ()))  %
                     

   first  symbols:nottok
   
   cannot reachend
*/

static void NotConstFactor (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   ConstFactor := ConstNumber  | ConstString  | ConstSetOrQualidentOrFunction  | 
                  '(' ConstExpressionNop ')'  | 
                  NotConstFactor  | ConstAttribute 

   first  symbols:attributetok, identtok, lcbratok, stringtok, nottok, lparatok, integertok, realtok
   
   cannot reachend
*/

static void ConstFactor (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   ConstString := string 

   first  symbols:stringtok
   
   cannot reachend
*/

static void ConstString (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   ConstComponentElement := ConstExpressionNop [ '..' ConstExpressionNop  ] 

   first  symbols:stringtok, lcbratok, identtok, attributetok, realtok, integertok, lparatok, nottok, plustok, minustok
   
   cannot reachend
*/

static void ConstComponentElement (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   ConstComponentValue := ConstComponentElement [ 'BY' ConstExpressionNop  ] 

   first  symbols:attributetok, identtok, lcbratok, stringtok, nottok, lparatok, integertok, realtok, minustok, plustok
   
   cannot reachend
*/

static void ConstComponentValue (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   ConstArraySetRecordValue := ConstComponentValue { ',' ConstComponentValue  } 

   first  symbols:stringtok, lcbratok, identtok, attributetok, realtok, integertok, lparatok, nottok, plustok, minustok
   
   cannot reachend
*/

static void ConstArraySetRecordValue (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   ConstConstructor := '{' [ ConstArraySetRecordValue  ] '}' 

   first  symbols:lcbratok
   
   cannot reachend
*/

static void ConstConstructor (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   ConstSetOrQualidentOrFunction := Qualident [ ConstConstructor  | 
                                                ConstActualParameters  ]  | 
                                    ConstConstructor 

   first  symbols:lcbratok, identtok
   
   cannot reachend
*/

static void ConstSetOrQualidentOrFunction (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   ConstActualParameters := '(' [ ConstExpList  ] ')' 

   first  symbols:lparatok
   
   cannot reachend
*/

static void ConstActualParameters (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   ConstExpList := ConstExpressionNop { ',' ConstExpressionNop  } 

   first  symbols:stringtok, lcbratok, identtok, attributetok, realtok, integertok, lparatok, nottok, plustok, minustok
   
   cannot reachend
*/

static void ConstExpList (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   ConstAttribute := '__ATTRIBUTE__' '__BUILTIN__' '(' '(' ConstAttributeExpression 
                     ')' ')' 

   first  symbols:attributetok
   
   cannot reachend
*/

static void ConstAttribute (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   ConstAttributeExpression := Ident  | '<' Qualident ',' Ident 
                               '>' 

   first  symbols:lesstok, identtok
   
   cannot reachend
*/

static void ConstAttributeExpression (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   ByteAlignment := '' 

   first  symbols:ldirectivetok
   
   cannot reachend
*/

static void ByteAlignment (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   OptAlignmentExpression := [ AlignmentExpression  ] 

   first  symbols:lparatok
   
   reachend
*/

static void OptAlignmentExpression (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   AlignmentExpression := '(' ConstExpressionNop ')' 

   first  symbols:lparatok
   
   cannot reachend
*/

static void AlignmentExpression (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   Alignment := [ ByteAlignment  ] 

   first  symbols:ldirectivetok
   
   reachend
*/

static void Alignment (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   IdentList := Ident { ',' Ident  } 

   first  symbols:identtok
   
   cannot reachend
*/

static void IdentList (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   SubrangeType := '[' ConstExpressionNop '..' ConstExpressionNop 
                   ']' 

   first  symbols:lsbratok
   
   cannot reachend
*/

static void SubrangeType (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   ArrayType := 'ARRAY' SimpleType { ',' SimpleType  } 'OF' Type 

   first  symbols:arraytok
   
   cannot reachend
*/

static void ArrayType (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   RecordType := 'RECORD' [ DefaultRecordAttributes  ] FieldListSequence 
                 'END' 

   first  symbols:recordtok
   
   cannot reachend
*/

static void RecordType (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   DefaultRecordAttributes := '' 

   first  symbols:ldirectivetok
   
   cannot reachend
*/

static void DefaultRecordAttributes (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   RecordFieldPragma := [ ''  ] 

   first  symbols:ldirectivetok
   
   reachend
*/

static void RecordFieldPragma (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   FieldPragmaExpression := Ident PragmaConstExpression 

   first  symbols:identtok
   
   cannot reachend
*/

static void FieldPragmaExpression (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   PragmaConstExpression := [ '(' ConstExpressionNop ')'  ] 

   first  symbols:lparatok
   
   reachend
*/

static void PragmaConstExpression (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   AttributeExpression := Ident '(' ConstExpressionNop ')' 

   first  symbols:identtok
   
   cannot reachend
*/

static void AttributeExpression (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   FieldListSequence := FieldListStatement { ';' FieldListStatement  } 

   first  symbols:casetok, identtok, semicolontok
   
   reachend
*/

static void FieldListSequence (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   FieldListStatement := [ FieldList  ] 

   first  symbols:identtok, casetok
   
   reachend
*/

static void FieldListStatement (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   FieldList := IdentList ':' Type RecordFieldPragma  | 
                'CASE' CaseTag 'OF' Varient { '|' Varient  } 
                [ 'ELSE' FieldListSequence  ] 'END' 

   first  symbols:casetok, identtok
   
   cannot reachend
*/

static void FieldList (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   TagIdent := Ident  | 
               % curident := NulName  %
               

   first  symbols:identtok
   
   reachend
*/

static void TagIdent (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   CaseTag := TagIdent [ ':' Qualident  ] 

   first  symbols:colontok, identtok
   
   reachend
*/

static void CaseTag (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   Varient := [ VarientCaseLabelList ':' FieldListSequence  ] 

   first  symbols:stringtok, lcbratok, identtok, attributetok, realtok, integertok, lparatok, nottok, plustok, minustok
   
   reachend
*/

static void Varient (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   VarientCaseLabelList := VarientCaseLabels { ',' VarientCaseLabels  } 

   first  symbols:attributetok, identtok, lcbratok, stringtok, nottok, lparatok, integertok, realtok, minustok, plustok
   
   cannot reachend
*/

static void VarientCaseLabelList (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   VarientCaseLabels := ConstExpressionNop [ '..' ConstExpressionNop  ] 

   first  symbols:stringtok, lcbratok, identtok, attributetok, realtok, integertok, lparatok, nottok, plustok, minustok
   
   cannot reachend
*/

static void VarientCaseLabels (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   SetType := ( 'SET'  | 'PACKEDSET'  ) 'OF' SimpleType 

   first  symbols:oftok, packedsettok, settok
   
   cannot reachend
*/

static void SetType (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   PointerType := 'POINTER' 'TO' Type 

   first  symbols:pointertok
   
   cannot reachend
*/

static void PointerType (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   ProcedureType := 'PROCEDURE' [ FormalTypeList  ] 

   first  symbols:proceduretok
   
   cannot reachend
*/

static void ProcedureType (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   FormalTypeList := '(' ( ')' FormalReturn  | 
                           ProcedureParameters ')' FormalReturn  ) 

   first  symbols:lparatok
   
   cannot reachend
*/

static void FormalTypeList (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   FormalReturn := [ ':' OptReturnType  ] 

   first  symbols:colontok
   
   reachend
*/

static void FormalReturn (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   OptReturnType := '[' Qualident ']'  | Qualident 

   first  symbols:identtok, lsbratok
   
   cannot reachend
*/

static void OptReturnType (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   ProcedureParameters := ProcedureParameter { ',' ProcedureParameter  } 

   first  symbols:identtok, arraytok, periodperiodperiodtok, vartok
   
   cannot reachend
*/

static void ProcedureParameters (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   ProcedureParameter := '...'  | 'VAR' FormalType  | 
                         FormalType 

   first  symbols:arraytok, identtok, vartok, periodperiodperiodtok
   
   cannot reachend
*/

static void ProcedureParameter (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   VarIdent := Ident [ '[' ConstExpressionNop ']'  ] 

   first  symbols:identtok
   
   cannot reachend
*/

static void VarIdent (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   VarIdentList := VarIdent { ',' VarIdent  } 

   first  symbols:identtok
   
   cannot reachend
*/

static void VarIdentList (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   VariableDeclaration := VarIdentList ':' Type Alignment 

   first  symbols:identtok
   
   cannot reachend
*/

static void VariableDeclaration (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   Designator := PushQualident { SubDesignator  } 

   first  symbols:identtok
   
   cannot reachend
*/

static void Designator (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   SubDesignator := 
                    % VAR n, field, type: node ;  %
                    
                    % n := peep ()  %
                    
                    % IF n = NIL
                      THEN
                      									     ErrorArray ('no expression found') ;
                         flushErrors ;
                         RETURN
                      END  %
                    
                    % type := skipType (getType (n))  %
                    ( '.' Ident 
                      % IF isRecord (type)
                        THEN
                           field := lookupInScope (type, curident) ;
                           IF field = NIL
                           THEN
                              metaError2 ('field {%1k} cannot be found in record {%2ad}', curident, type)
                           ELSE
                              n := replace (makeComponentRef (n, field))
                           END
                        ELSE
                           metaError2 ('attempting to access a field {%1k} from {%2ad} which does not have a record type', curident, type)
                        END  %
                       | '[' ArrayExpList 
                      % IF isArray (type)
                        THEN
                           n := replace (makeArrayRef (n, pop ()))
                        ELSE
                           metaError1 ('attempting to access an array but the expression is not an array but a {%1d}', type)
                        END  %
                      ']'  | SubPointer  ) 

   first  symbols:uparrowtok, lsbratok, periodtok
   
   cannot reachend
*/

static void SubDesignator (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   SubPointer := 
                 % VAR n, field, type: node ;  %
                 
                 % n := peep ()  %
                 
                 % type := skipType (getType (n))  %
                 '^' ( '.' Ident 
                       % IF isPointer (type)
                         THEN
                         									     type := skipType (getType (type)) ;
                         									     IF isRecord (type)
                            THEN
                               field := lookupInScope (type, curident) ;
                               IF field = NIL
                               THEN
                                  metaError2 ('field {%1k} cannot be found in record {%2ad}', curident, type)
                               ELSE
                                  n := replace (makePointerRef (n, field))
                               END
                            ELSE
                               metaError2 ('attempting to access a field {%1k} from {%2ad} which does not have a record type', curident, type)
                            END
                         ELSE
                            metaError2 ('trying to dereference {%1k} which was not declared as a pointer but a {%2tad}', n, n)
                         END  %
                        | 
                       % IF isPointer (type)
                         THEN
                            n := replace (makeDeRef (n))
                         ELSE
                            metaError1 ('attempting to dereference a pointer but the expression is not a pointer but a {%1d}', type)
                         END  %
                        ) 

   first  symbols:uparrowtok
   
   cannot reachend
*/

static void SubPointer (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   ArrayExpList := 
                   % VAR l: node ;  %
                   
                   % l := push (makeExpList ())  %
                   Expression 
                   % putExpList (l, pop ())  %
                   
                   % assert (isExpList (peep ()))  %
                   { ',' Expression 
                     % putExpList (l, pop ())  %
                     
                     % assert (isExpList (peep ()))  %
                      } 

   first  symbols:identtok, lcbratok, realtok, integertok, stringtok, lparatok, nottok, plustok, minustok
   
   cannot reachend
*/

static void ArrayExpList (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   ExpList := 
              % VAR p, n: node ;  %
              
              % p := peep ()  %
              
              % assert (isExpList (p))  %
              Expression 
              % putExpList (p, pop ())  %
              
              % assert (isExpList (peep ()))  %
              { ',' Expression 
                % putExpList (p, pop ())  %
                
                % assert (isExpList (peep ()))  %
                 } 

   first  symbols:identtok, lcbratok, realtok, integertok, stringtok, lparatok, nottok, plustok, minustok
   
   cannot reachend
*/

static void ExpList (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   Expression := 
                 % VAR c, l, r: node ; op: toktype ;  %
                 SimpleExpression 
                 % op := currenttoken  %
                 [ Relation 
                   % l := pop ()  %
                   SimpleExpression 
                   % r := pop ()  %
                   
                   % r := push (makeBinaryTok (op, l, r))  %
                    ] 

   first  symbols:identtok, lcbratok, nottok, lparatok, stringtok, integertok, realtok, minustok, plustok
   
   cannot reachend
*/

static void Expression (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   SimpleExpression := 
                       % VAR op: toktype ; n: node ;  %
                       UnaryOrTerm { 
                                     % op := currenttoken  %
                                     
                                     % n := pop ()  %
                                     AddOperator Term 
                                     % n := push (makeBinaryTok (op, n, pop ()))  %
                                      } 

   first  symbols:identtok, lcbratok, realtok, integertok, stringtok, lparatok, nottok, plustok, minustok
   
   cannot reachend
*/

static void SimpleExpression (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   UnaryOrTerm := 
                  % VAR n: node ;  %
                  '+' Term 
                  % n := push (makeUnaryTok (plustok, pop ()))  %
                   | '-' Term 
                  % n := push (makeUnaryTok (minustok, pop ()))  %
                   | Term 

   first  symbols:identtok, lcbratok, nottok, lparatok, stringtok, integertok, realtok, minustok, plustok
   
   cannot reachend
*/

static void UnaryOrTerm (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   Term := 
           % VAR op: toktype ; n: node ;  %
           Factor { 
                    % op := currenttoken  %
                    MulOperator 
                    % n := pop ()  %
                    Factor 
                    % n := push (makeBinaryTok (op, n, pop ()))  %
                     } 

   first  symbols:identtok, lcbratok, realtok, integertok, stringtok, lparatok, nottok
   
   cannot reachend
*/

static void Term (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   PushString := string 
                 % VAR n: node ;  %
                 
                 % n := push (makeString (curstring))  %
                 

   first  symbols:stringtok
   
   cannot reachend
*/

static void PushString (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   Factor := Number  | PushString  | SetOrDesignatorOrFunction  | 
             '(' Expression ')'  | 'NOT' ( Factor 
                                           % VAR n: node ;  %
                                           
                                           % n := push (makeUnaryTok (nottok, pop ()))  %
                                            | ConstAttribute 
                                           
                                           % n := push (makeUnaryTok (nottok, pop ()))  %
                                            ) 

   first  symbols:identtok, lcbratok, nottok, lparatok, stringtok, integertok, realtok
   
   cannot reachend
*/

static void Factor (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   ComponentElement := Expression 
                       % VAR l, h, n: node ;  %
                       
                       % l := pop ()  %
                       
                       % h := NIL  %
                       [ '..' Expression 
                         % h := pop ()  %
                         
                         % ErrorArray ('implementation restriction range is not allowed')  %
                          ] 
                       % n := push (includeSetValue (pop (), l, h))  %
                       

   first  symbols:identtok, lcbratok, realtok, integertok, stringtok, lparatok, nottok, plustok, minustok
   
   cannot reachend
*/

static void ComponentElement (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   ComponentValue := ComponentElement [ 'BY' 
                                        % ErrorArray ('implementation restriction BY not allowed')  %
                                        Expression  ] 

   first  symbols:identtok, lcbratok, nottok, lparatok, stringtok, integertok, realtok, minustok, plustok
   
   cannot reachend
*/

static void ComponentValue (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   ArraySetRecordValue := ComponentValue { ',' ComponentValue  } 

   first  symbols:identtok, lcbratok, realtok, integertok, stringtok, lparatok, nottok, plustok, minustok
   
   cannot reachend
*/

static void ArraySetRecordValue (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   Constructor := '{' 
                  % VAR n: node ;  %
                  
                  % n := push (makeSetValue ())  %
                  [ ArraySetRecordValue  ] '}' 

   first  symbols:lcbratok
   
   cannot reachend
*/

static void Constructor (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   SetOrDesignatorOrFunction := PushQualident 
                                % VAR q, p, n: node ;  %
                                [ Constructor 
                                  % p := pop ()  %
                                  
                                  % q := pop ()  %
                                  
                                  % n := push (putSetValue (p, q))  %
                                   | SimpleDes [ 
                                                 % q := pop ()  %
                                                 ActualParameters 
                                                 
                                                 % p := pop ()  %
                                                 
                                                 % p := push (makeFuncCall (q, p))  %
                                                  ]  ]  | 
                                Constructor 

   first  symbols:identtok, lcbratok
   
   cannot reachend
*/

static void SetOrDesignatorOrFunction (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   SimpleDes := { SubDesignator  } 

   first  symbols:uparrowtok, periodtok, lsbratok
   
   reachend
*/

static void SimpleDes (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   ActualParameters := '(' 
                       % VAR n: node ;  %
                       
                       % n := push (makeExpList ())  %
                       [ ExpList  ] ')' 
                       % assert (isExpList (peep ()))  %
                       

   first  symbols:lparatok
   
   cannot reachend
*/

static void ActualParameters (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   ExitStatement := 
                    % VAR n: node ;  %
                    'EXIT' 
                    % IF loopNo = 0
                      THEN
                         ErrorArray ('EXIT can only be used inside a LOOP statement')
                      ELSE
                         n := pushStmt (makeExit (peepLoop (), loopNo))
                      END  %
                    

   first  symbols:exittok
   
   cannot reachend
*/

static void ExitStatement (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   ReturnStatement := 
                      % VAR n: node ;  %
                      
                      % n := pushStmt (makeReturn ())  %
                      'RETURN' [ Expression 
                                 % putReturn (n, pop ())  %
                                  ] 
                      % addCommentBody (peepStmt ())  %
                      
                      % addCommentAfter (peepStmt ())  %
                      
                      % assert (isReturn (peepStmt ()))  %
                      

   first  symbols:returntok
   
   cannot reachend
*/

static void ReturnStatement (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   Statement := ( AssignmentOrProcedureCall  | 
                  IfStatement  | CaseStatement  | 
                  WhileStatement  | RepeatStatement  | 
                  LoopStatement  | ForStatement  | 
                  WithStatement  | AsmStatement  | 
                  ExitStatement  | ReturnStatement  | 
                  RetryStatement  | 
                  % VAR s: node ;  %
                  
                  % s := pushStmt (NIL)  %
                   ) 

   first  symbols:identtok, retrytok, asmtok, withtok, fortok, looptok, repeattok, whiletok, casetok, iftok, returntok, exittok
   
   reachend
*/

static void Statement (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   RetryStatement := 
                     % VAR s: node ;  %
                     
                     % s := pushStmt (makeComment ("retry"))  %
                     'RETRY' 

   first  symbols:retrytok
   
   cannot reachend
*/

static void RetryStatement (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   AssignmentOrProcedureCall := 
                                % VAR d, a, p: node ;  %
                                Designator 
                                % d := pop ()  %
                                ( ':=' Expression 
                                  % a := pushStmt (makeAssignment (d, pop ()))  %
                                   | ActualParameters 
                                  % a := pushStmt (makeFuncCall (d, pop ()))  %
                                   | 
                                  % a := pushStmt (makeFuncCall (d, NIL))  %
                                   ) 
                                % addCommentBody (peepStmt ())  %
                                
                                % addCommentAfter (peepStmt ())  %
                                

   first  symbols:identtok
   
   cannot reachend
*/

static void AssignmentOrProcedureCall (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   StatementSequence := 
                        % VAR s, t: node ;  %
                        
                        % s := pushStmt (makeStatementSequence ())  %
                        
                        % assert (isStatementSequence (peepStmt ()))  %
                        Statement 
                        % addStatement (s, popStmt ())  %
                        
                        % assert (isStatementSequence (peepStmt ()))  %
                        { ';' Statement 
                          % addStatement (s, popStmt ())  %
                          
                          % assert (isStatementSequence (peepStmt ()))  %
                           } 

   first  symbols:identtok, iftok, casetok, whiletok, repeattok, looptok, fortok, withtok, asmtok, retrytok, semicolontok, exittok, returntok
   
   reachend
*/

static void StatementSequence (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   IfStatement := 
                  % VAR i, a, b: node ;  %
                  'IF' 
                  % b := makeCommentS (getBodyComment ())  %
                  Expression 
                  % a := makeCommentS (getAfterComment ())  %
                  'THEN' StatementSequence 
                  % i := pushStmt (makeIf (pop (), popStmt ()))  %
                  
                  % addIfComments (i, b, a)  %
                  { 'ELSIF' 
                    % b := makeCommentS (getBodyComment ())  %
                    Expression 
                    % a := makeCommentS (getAfterComment ())  %
                    'THEN' 
                    % addElseComments (peepStmt (), b, a)  %
                    StatementSequence 
                    % i := makeElsif (i, pop (), popStmt ())  %
                     } [ 'ELSE' StatementSequence 
                         % putElse (i, popStmt ())  %
                          ] 'END' 
                  % b := makeCommentS (getBodyComment ())  %
                  
                  % a := makeCommentS (getAfterComment ())  %
                  
                  % assert (isIf (peepStmt ()))  %
                  
                  % addIfEndComments (peepStmt (), b, a)  %
                  

   first  symbols:iftok
   
   cannot reachend
*/

static void IfStatement (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   CaseStatement := 
                    % VAR s, e: node ;  %
                    
                    % s := pushStmt (makeCase ())  %
                    'CASE' Expression 
                    % s := putCaseExpression (s, pop ())  %
                    'OF' Case { '|' Case  } CaseEndStatement 

   first  symbols:casetok
   
   cannot reachend
*/

static void CaseStatement (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   CaseEndStatement := 
                       % VAR c: node ;  %
                       'END'  | 'ELSE' 
                       % c := peepStmt ()  %
                       StatementSequence 
                       % c := putCaseElse (c, popStmt ())  %
                       'END' 

   first  symbols:elsetok, endtok
   
   cannot reachend
*/

static void CaseEndStatement (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   Case := [ CaseLabelList ':' 
             % VAR l, c: node ;  %
             
             % l := pop ()  %
             
             % c := peepStmt ()  %
             StatementSequence 
             % c := putCaseStatement (c, l, popStmt ())  %
              ] 

   first  symbols:stringtok, lcbratok, identtok, attributetok, realtok, integertok, lparatok, nottok, plustok, minustok
   
   reachend
*/

static void Case (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   CaseLabelList := 
                    % VAR l: node ;  %
                    
                    % l := push (makeCaseList ())  %
                    CaseLabels { ',' CaseLabels  } 

   first  symbols:attributetok, identtok, lcbratok, stringtok, nottok, lparatok, integertok, realtok, minustok, plustok
   
   cannot reachend
*/

static void CaseLabelList (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   CaseLabels := 
                 % VAR lo, hi, l: node ;  %
                 
                 % lo := NIL ; hi := NIL  %
                 
                 % l := peep ()  %
                 ConstExpression 
                 % lo := pop ()  %
                 [ '..' ConstExpression 
                   % hi := pop ()  %
                    ] 
                 % l := putCaseRange (l, lo, hi)  %
                 

   first  symbols:stringtok, lcbratok, identtok, attributetok, realtok, integertok, lparatok, nottok, plustok, minustok
   
   cannot reachend
*/

static void CaseLabels (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   WhileStatement := 
                     % VAR s, w, e, a, b: node ;  %
                     
                     % w := pushStmt (makeWhile ())  %
                     'WHILE' Expression 'DO' 
                     % b := makeCommentS (getBodyComment ())  %
                     
                     % a := makeCommentS (getAfterComment ())  %
                     
                     % addWhileDoComment (w, b, a)  %
                     
                     % e := pop ()  %
                     StatementSequence 
                     % s := popStmt ()  %
                     'END' 
                     %  assert (isStatementSequence (peepStmt ()))   %
                     
                     % putWhile (w, e, s)  %
                     
                     % b := makeCommentS (getBodyComment ())  %
                     
                     % a := makeCommentS (getAfterComment ())  %
                     
                     % addWhileEndComment (w, b, a)  %
                     

   first  symbols:whiletok
   
   cannot reachend
*/

static void WhileStatement (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   RepeatStatement := 
                      % VAR r, s, a, b: node ;  %
                      
                      % r := pushStmt (makeRepeat ())  %
                      'REPEAT' 
                      % b := makeCommentS (getBodyComment ())  %
                      
                      % a := makeCommentS (getAfterComment ())  %
                      
                      % addRepeatComment (r, b, a)  %
                      StatementSequence 
                      % s := popStmt ()  %
                      'UNTIL' Expression 
                      % putRepeat (r, s, pop ())  %
                      
                      % b := makeCommentS (getBodyComment ())  %
                      
                      % a := makeCommentS (getAfterComment ())  %
                      
                      % addUntilComment (r, b, a)  %
                      

   first  symbols:repeattok
   
   cannot reachend
*/

static void RepeatStatement (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   ForStatement := 
                   % VAR f, i, s, e, b: node ;  %
                   
                   % b := NIL  %
                   
                   % f := pushStmt (makeFor ())  %
                   'FOR' Ident 
                   % i := lookupWithSym (curident)  %
                   ':=' Expression 
                   % s := pop ()  %
                   'TO' Expression 
                   % e := pop ()  %
                   [ 'BY' ConstExpression 
                     % b := pop ()  %
                      ] 'DO' StatementSequence 
                   % putFor (f, i, s, e, b, popStmt ())  %
                   'END' 

   first  symbols:fortok
   
   cannot reachend
*/

static void ForStatement (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   LoopStatement := 
                    % VAR l, s: node ;  %
                    'LOOP' 
                    % l := pushStmt (pushLoop (makeLoop ()))  %
                    
                    % INC (loopNo)  %
                    StatementSequence 
                    % s := popStmt ()  %
                    
                    % putLoop (l, s)  %
                    
                    % DEC (loopNo)  %
                    'END' 
                    % l := popLoop ()  %
                    
                    % assert (isLoop (peepStmt ()))  %
                    

   first  symbols:looptok
   
   cannot reachend
*/

static void LoopStatement (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   WithStatement := 'WITH' Designator 'DO' 
                    % startWith (pop ())  %
                    StatementSequence 'END' 
                    % endWith  %
                    

   first  symbols:withtok
   
   cannot reachend
*/

static void WithStatement (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   ProcedureDeclaration := ProcedureHeading ';' ProcedureBlock 
                           Ident 
                           % leaveScope  %
                           

   first  symbols:proceduretok
   
   cannot reachend
*/

static void ProcedureDeclaration (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   ProcedureIdent := Ident 
                     % curproc := lookupSym (curident)  %
                     
                     % enterScope (curproc)  %
                     
                     % setProcedureComment (lastcomment, curident)  %
                     

   first  symbols:identtok
   
   cannot reachend
*/

static void ProcedureIdent (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   DefProcedureIdent := Ident 
                        % curproc := lookupSym (curident)  %
                        

   first  symbols:identtok
   
   cannot reachend
*/

static void DefProcedureIdent (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   DefineBuiltinProcedure := [ '__ATTRIBUTE__' '__BUILTIN__' 
                               '(' '(' Ident ')' ')'  | 
                               '__INLINE__'  ] 

   first  symbols:inlinetok, attributetok
   
   reachend
*/

static void DefineBuiltinProcedure (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   ProcedureHeading := 'PROCEDURE' DefineBuiltinProcedure ( ProcedureIdent 
                                                            [ 
   FormalParameters  ] AttributeNoReturn  ) 

   first  symbols:proceduretok
   
   cannot reachend
*/

static void ProcedureHeading (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   Builtin := [ '__BUILTIN__'  | '__INLINE__'  ] 

   first  symbols:inlinetok, builtintok
   
   reachend
*/

static void Builtin (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   DefProcedureHeading := 'PROCEDURE' Builtin ( DefProcedureIdent 
                                                [ DefFormalParameters  ] 
                                                AttributeNoReturn  ) 

   first  symbols:proceduretok
   
   cannot reachend
*/

static void DefProcedureHeading (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   ProcedureBlock := { Declaration  } [ 'BEGIN' ProcedureBlockBody  ] 
                     'END' 

   first  symbols:proceduretok, moduletok, consttok, typetok, vartok, endtok, begintok
   
   cannot reachend
*/

static void ProcedureBlock (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   Block := { Declaration  } InitialBlock FinalBlock 'END' 

   first  symbols:proceduretok, moduletok, finallytok, begintok, consttok, typetok, vartok, endtok
   
   cannot reachend
*/

static void Block (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   InitialBlock := [ 'BEGIN' InitialBlockBody  ] 

   first  symbols:begintok
   
   reachend
*/

static void InitialBlock (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   FinalBlock := [ 'FINALLY' FinalBlockBody  ] 

   first  symbols:finallytok
   
   reachend
*/

static void FinalBlock (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   InitialBlockBody := NormalPart 
                       % putBegin (curmodule, popStmt ())  %
                       [ 'EXCEPT' ExceptionalPart  ] 

   first  symbols:identtok, iftok, casetok, whiletok, repeattok, looptok, fortok, withtok, asmtok, retrytok, semicolontok, exittok, returntok, excepttok
   
   reachend
*/

static void InitialBlockBody (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   FinalBlockBody := NormalPart 
                     % putFinally (curmodule, popStmt ())  %
                     [ 'EXCEPT' ExceptionalPart  ] 

   first  symbols:identtok, iftok, casetok, whiletok, repeattok, looptok, fortok, withtok, asmtok, retrytok, semicolontok, exittok, returntok, excepttok
   
   reachend
*/

static void FinalBlockBody (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   ProcedureBlockBody := ProcedureNormalPart [ 'EXCEPT' ExceptionalPart  ] 

   first  symbols:identtok, iftok, casetok, whiletok, repeattok, looptok, fortok, withtok, asmtok, retrytok, semicolontok, exittok, returntok, excepttok
   
   reachend
*/

static void ProcedureBlockBody (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   ProcedureNormalPart := StatementSequence 
                          % putBegin (curproc, popStmt ())  %
                          

   first  symbols:identtok, retrytok, asmtok, withtok, fortok, looptok, repeattok, whiletok, casetok, iftok, returntok, exittok, semicolontok
   
   reachend
*/

static void ProcedureNormalPart (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   NormalPart := StatementSequence 

   first  symbols:identtok, retrytok, asmtok, withtok, fortok, looptok, repeattok, whiletok, casetok, iftok, returntok, exittok, semicolontok
   
   reachend
*/

static void NormalPart (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   ExceptionalPart := StatementSequence 

   first  symbols:identtok, retrytok, asmtok, withtok, fortok, looptok, repeattok, whiletok, casetok, iftok, returntok, exittok, semicolontok
   
   reachend
*/

static void ExceptionalPart (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   Declaration := 'CONST' { ConstantDeclaration ';'  }  | 
                  'TYPE' { TypeDeclaration  }  | 
                  'VAR' { VariableDeclaration ';'  }  | 
                  ProcedureDeclaration ';'  | 
                  ModuleDeclaration ';' 

   first  symbols:moduletok, proceduretok, vartok, typetok, consttok
   
   cannot reachend
*/

static void Declaration (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   DefFormalParameters := '(' 
                          % paramEnter (curproc)  %
                          [ DefMultiFPSection  ] ')' 
                          % paramLeave (curproc)  %
                          FormalReturn 

   first  symbols:lparatok
   
   cannot reachend
*/

static void DefFormalParameters (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   AttributeNoReturn := [ ''  ] 

   first  symbols:ldirectivetok
   
   reachend
*/

static void AttributeNoReturn (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   DefMultiFPSection := DefExtendedFP  | FPSection [ ';' DefMultiFPSection  ] 

   first  symbols:identtok, vartok, lsbratok, periodperiodperiodtok
   
   cannot reachend
*/

static void DefMultiFPSection (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   FormalParameters := '(' 
                       % paramEnter (curproc)  %
                       [ MultiFPSection  ] ')' 
                       % paramLeave (curproc)  %
                       FormalReturn 

   first  symbols:lparatok
   
   cannot reachend
*/

static void FormalParameters (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   MultiFPSection := ExtendedFP  | FPSection [ ';' MultiFPSection  ] 

   first  symbols:identtok, vartok, lsbratok, periodperiodperiodtok
   
   cannot reachend
*/

static void MultiFPSection (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   FPSection := NonVarFPSection  | VarFPSection 

   first  symbols:vartok, identtok
   
   cannot reachend
*/

static void FPSection (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   DefExtendedFP := DefOptArg  | '...' 

   first  symbols:lsbratok, periodperiodperiodtok
   
   cannot reachend
*/

static void DefExtendedFP (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   ExtendedFP := OptArg  | '...' 

   first  symbols:lsbratok, periodperiodperiodtok
   
   cannot reachend
*/

static void ExtendedFP (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   VarFPSection := 'VAR' IdentList ':' FormalType 

   first  symbols:vartok
   
   cannot reachend
*/

static void VarFPSection (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   NonVarFPSection := IdentList ':' FormalType 

   first  symbols:identtok
   
   cannot reachend
*/

static void NonVarFPSection (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   OptArg := '[' Ident ':' FormalType [ '=' ConstExpressionNop  ] 
             ']' 

   first  symbols:lsbratok
   
   cannot reachend
*/

static void OptArg (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   DefOptArg := '[' Ident ':' FormalType '=' ConstExpressionNop 
                ']' 

   first  symbols:lsbratok
   
   cannot reachend
*/

static void DefOptArg (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   FormalType := { 'ARRAY' 'OF'  } Qualident 

   first  symbols:identtok, arraytok
   
   cannot reachend
*/

static void FormalType (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   ModuleDeclaration := 'MODULE' Ident [ Priority  ] ';' { Import  } 
                        [ Export  ] Block Ident 

   first  symbols:moduletok
   
   cannot reachend
*/

static void ModuleDeclaration (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   Priority := '[' ConstExpressionNop ']' 

   first  symbols:lsbratok
   
   cannot reachend
*/

static void Priority (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   Export := 'EXPORT' ( 'QUALIFIED' IdentList  | 
                        'UNQUALIFIED' IdentList  | 
                        IdentList  ) ';' 

   first  symbols:exporttok
   
   cannot reachend
*/

static void Export (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   FromIdentList := Ident { ',' Ident  } 

   first  symbols:identtok
   
   cannot reachend
*/

static void FromIdentList (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   FromImport := 'FROM' Ident 'IMPORT' FromIdentList ';' 

   first  symbols:fromtok
   
   cannot reachend
*/

static void FromImport (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   ImportModuleList := Ident { ',' Ident  } 

   first  symbols:identtok
   
   cannot reachend
*/

static void ImportModuleList (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   WithoutFromImport := 'IMPORT' ImportModuleList ';' 

   first  symbols:importtok
   
   cannot reachend
*/

static void WithoutFromImport (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   Import := FromImport  | WithoutFromImport 

   first  symbols:importtok, fromtok
   
   cannot reachend
*/

static void Import (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   DefinitionModule := 'DEFINITION' 'MODULE' [ 'FOR' string  ] 
                       Ident ';' 
                       % curmodule := lookupDef (curident)  %
                       
                       % enterScope (curmodule)  %
                       { Import  } [ Export  ] { Definition  } 
                       'END' Ident '.' 
                       % checkEndName (curmodule, curident, 'definition module')  %
                       
                       % leaveScope  %
                       

   first  symbols:definitiontok
   
   cannot reachend
*/

static void DefinitionModule (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   PushQualident := 
                    % VAR type, field: node ;  %
                    Ident 
                    % qualid := push (lookupWithSym (curident))  %
                    
                    % IF qualid = NIL
                                    THEN
                                       metaError1 ('the symbol {%1k} is not visible in this scope (or any other nested scope)', curident)
                                    END  %
                    [ '.' 
                      % IF NOT isQualident (qualid)
                                      THEN
                                         ErrorArray ('the first component of this qualident must be a definition module or a parameter/variable/constant which has record type')
                                      END  %
                      Ident 
                      % IF isDef (qualid)
                                      THEN
                                         qualid := replace (lookupInScope (qualid, curident))
                                      ELSE
                                         type := skipType (getType (qualid)) ;
                                         field := lookupInScope (type, curident) ;
                        									     IF field = NIL
                                         THEN
                                            metaError2 ('field {%1k} cannot be found in {%2ad}', curident, qualid)
                                         ELSE
                                            qualid := replace (makeComponentRef (qualid, field))
                                         END
                                      END ;
                                      IF qualid = NIL
                                      THEN
                                         metaError1 ('qualified component of the identifier {%1k} cannot be found', curident)
                                      END  %
                       ] 

   first  symbols:identtok
   
   cannot reachend
*/

static void PushQualident (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   OptSubrange := [ SubrangeType  ] 

   first  symbols:lsbratok
   
   reachend
*/

static void OptSubrange (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   TypeEquiv := Qualident OptSubrange 

   first  symbols:identtok
   
   cannot reachend
*/

static void TypeEquiv (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   EnumIdentList := Ident { ',' Ident  } 

   first  symbols:identtok
   
   cannot reachend
*/

static void EnumIdentList (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   Enumeration := '(' EnumIdentList ')' 

   first  symbols:lparatok
   
   cannot reachend
*/

static void Enumeration (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   SimpleType := TypeEquiv  | Enumeration  | SubrangeType 

   first  symbols:lsbratok, lparatok, identtok
   
   cannot reachend
*/

static void SimpleType (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   Type := SimpleType  | ArrayType  | RecordType  | 
           SetType  | PointerType  | ProcedureType 

   first  symbols:proceduretok, pointertok, settok, packedsettok, oftok, recordtok, arraytok, identtok, lparatok, lsbratok
   
   cannot reachend
*/

static void Type (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   TypeDeclaration := { Ident ( ';'  | '=' Type Alignment ';'  )  } 

   first  symbols:identtok
   
   reachend
*/

static void TypeDeclaration (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   Definition := 'CONST' { ConstantDeclaration ';'  }  | 
                 'TYPE' { TypeDeclaration  }  | 
                 'VAR' { VariableDeclaration ';'  }  | 
                 DefProcedureHeading ';' 

   first  symbols:proceduretok, vartok, typetok, consttok
   
   cannot reachend
*/

static void Definition (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   AsmStatement := 
                   % VAR s: node ;  %
                   
                   % s := pushStmt (makeComment ("asm"))  %
                   'ASM' [ 'VOLATILE'  ] '(' AsmOperands ')' 

   first  symbols:asmtok
   
   cannot reachend
*/

static void AsmStatement (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   AsmOperands := string [ AsmOperandSpec  ] 

   first  symbols:stringtok
   
   cannot reachend
*/

static void AsmOperands (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   AsmOperandSpec := [ ':' AsmList [ ':' AsmList [ ':' TrashList  ]  ]  ] 

   first  symbols:colontok
   
   reachend
*/

static void AsmOperandSpec (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   AsmList := [ AsmElement  ] { ',' AsmElement  } 

   first  symbols:lsbratok, stringtok, commatok
   
   reachend
*/

static void AsmList (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   NamedOperand := '[' Ident ']' 

   first  symbols:lsbratok
   
   cannot reachend
*/

static void NamedOperand (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   AsmOperandName := [ NamedOperand  ] 

   first  symbols:lsbratok
   
   reachend
*/

static void AsmOperandName (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   AsmElement := AsmOperandName string '(' Expression ')' 

   first  symbols:stringtok, lsbratok
   
   cannot reachend
*/

static void AsmElement (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);

/*
   TrashList := [ string  ] { ',' string  } 

   first  symbols:commatok, stringtok
   
   reachend
*/

static void TrashList (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2);


/*
   followNode -
*/

static void followNode (decl_node n)
{
  if (decl_isVar (n))
    {
      mcPrintf_printf0 ((char *) "variable: ", 10);
    }
  else if (decl_isParameter (n))
    {
      /* avoid dangling else.  */
      mcPrintf_printf0 ((char *) "parameter: ", 11);
    }
  n = decl_skipType (decl_getType (n));
  if (decl_isArray (n))
    {
      mcPrintf_printf0 ((char *) "array\\n", 7);
    }
  else if (decl_isPointer (n))
    {
      /* avoid dangling else.  */
      mcPrintf_printf0 ((char *) "pointer\\n", 9);
    }
  else if (decl_isRecord (n))
    {
      /* avoid dangling else.  */
      mcPrintf_printf0 ((char *) "record\\n", 8);
    }
  else
    {
      /* avoid dangling else.  */
      mcPrintf_printf0 ((char *) "other\\n", 7);
    }
}


/*
   push -
*/

static decl_node push (decl_node n)
{
  return mcStack_push (stk, (void *) n);
  /* static analysis guarentees a RETURN statement will be used before here.  */
  __builtin_unreachable ();
}


/*
   pop -
*/

static decl_node pop (void)
{
  return mcStack_pop (stk);
  /* static analysis guarentees a RETURN statement will be used before here.  */
  __builtin_unreachable ();
}


/*
   replace -
*/

static decl_node replace (decl_node n)
{
  return mcStack_replace (stk, (void *) n);
  /* static analysis guarentees a RETURN statement will be used before here.  */
  __builtin_unreachable ();
}


/*
   peep - returns the top node on the stack without removing it.
*/

static decl_node peep (void)
{
  return push (pop ());
  /* static analysis guarentees a RETURN statement will be used before here.  */
  __builtin_unreachable ();
}


/*
   depth - returns the depth of the stack.
*/

static unsigned int depth (void)
{
  return mcStack_depth (stk);
  /* static analysis guarentees a RETURN statement will be used before here.  */
  __builtin_unreachable ();
}


/*
   checkDuplicate -
*/

static void checkDuplicate (unsigned int b)
{
}


/*
   isQualident - returns TRUE if, n, is a qualident.
*/

static unsigned int isQualident (decl_node n)
{
  decl_node type;

  if (decl_isDef (n))
    {
      return TRUE;
    }
  else
    {
      type = decl_skipType (decl_getType (n));
      return (type != NULL) && (decl_isRecord (type));
    }
  return FALSE;
  /* static analysis guarentees a RETURN statement will be used before here.  */
  __builtin_unreachable ();
}


/*
   startWith -
*/

static void startWith (decl_node n)
{
  n = mcStack_push (withStk, (void *) n);
}


/*
   endWith -
*/

static void endWith (void)
{
  decl_node n;

  n = mcStack_pop (withStk);
}


/*
   lookupWithSym -
*/

static decl_node lookupWithSym (nameKey_Name i)
{
  unsigned int d;
  decl_node n;
  decl_node m;
  decl_node t;

  d = mcStack_depth (withStk);
  while (d != 0)
    {
      n = mcStack_access (withStk, d);
      t = decl_skipType (decl_getType (n));
      m = decl_lookupInScope (t, i);
      if (m != NULL)
        {
          n = decl_dupExpr (n);
          return decl_makeComponentRef (n, m);
        }
      d -= 1;
    }
  return decl_lookupSym (i);
  /* static analysis guarentees a RETURN statement will be used before here.  */
  __builtin_unreachable ();
}


/*
   pushStmt - push a node, n, to the statement stack and return node, n.
*/

static decl_node pushStmt (decl_node n)
{
  return mcStack_push (stmtStk, (void *) n);
  /* static analysis guarentees a RETURN statement will be used before here.  */
  __builtin_unreachable ();
}


/*
   popStmt - pop the top node from the statement stack.
*/

static decl_node popStmt (void)
{
  return mcStack_pop (stmtStk);
  /* static analysis guarentees a RETURN statement will be used before here.  */
  __builtin_unreachable ();
}


/*
   peepStmt - return the top node from the statement stack,
              but leave the stack unchanged.
*/

static decl_node peepStmt (void)
{
  return pushStmt (popStmt ());
  /* static analysis guarentees a RETURN statement will be used before here.  */
  __builtin_unreachable ();
}


/*
   pushLoop - push a node, n, to the loop stack and return node, n.
*/

static decl_node pushLoop (decl_node n)
{
  return mcStack_push (loopStk, (void *) n);
  /* static analysis guarentees a RETURN statement will be used before here.  */
  __builtin_unreachable ();
}


/*
   popLoop - pop the top node from the loop stack.
*/

static decl_node popLoop (void)
{
  return mcStack_pop (loopStk);
  /* static analysis guarentees a RETURN statement will be used before here.  */
  __builtin_unreachable ();
}


/*
   peepLoop - return the top node from the loop stack,
              but leave the stack unchanged.
*/

static decl_node peepLoop (void)
{
  return pushLoop (popLoop ());
  /* static analysis guarentees a RETURN statement will be used before here.  */
  __builtin_unreachable ();
}


/*
   peepLoop - return the top node from the loop stack,
              but leave the stack unchanged.
*/

static void ErrorString (DynamicStrings_String s)
{
  mcError_errorStringAt (s, mcLexBuf_getTokenNo ());
  WasNoError = FALSE;
}


/*
   peepLoop - return the top node from the loop stack,
              but leave the stack unchanged.
*/

static void ErrorArray (char *a_, unsigned int _a_high)
{
  char a[_a_high+1];

  /* make a local copy of each unbounded array.  */
  memcpy (a, a_, _a_high+1);

  ErrorString (DynamicStrings_InitString ((char *) a, _a_high));
}


/*
   pushNunbounded -
*/

static void pushNunbounded (unsigned int c)
{
  decl_node type;
  decl_node array;
  decl_node subrange;

  while (c != 0)
    {
      type = pop ();
      subrange = decl_makeSubrange ((decl_node) NULL, (decl_node) NULL);
      decl_putSubrangeType (subrange, decl_getCardinal ());
      array = decl_makeArray (subrange, type);
      decl_putUnbounded (array);
      type = push (array);
      c -= 1;
    }
}


/*
   makeIndexedArray - builds and returns an array of type, t, with, c, indices.
*/

static decl_node makeIndexedArray (unsigned int c, decl_node t)
{
  decl_node i;

  while (c > 0)
    {
      t = decl_makeArray (pop (), t);
      c -= 1;
    }
  return t;
  /* static analysis guarentees a RETURN statement will be used before here.  */
  __builtin_unreachable ();
}


/*
   importInto - from, m, import, name, into module, current.
                It checks to see if curident is an enumeration type
                and if so automatically includes all enumeration fields
                as well.
*/

static void importInto (decl_node m, nameKey_Name name, decl_node current)
{
  decl_node s;
  decl_node o;

  mcDebug_assert (decl_isDef (m));
  mcDebug_assert (((decl_isDef (current)) || (decl_isModule (current))) || (decl_isImp (current)));
  s = decl_lookupExported (m, name);
  if (s == NULL)
    {
      mcMetaError_metaError2 ((char *) "{%1k} was not exported from definition module {%2a}", 51, (unsigned char *) &name, (sizeof (name)-1), (unsigned char *) &m, (sizeof (m)-1));
    }
  else
    {
      o = decl_import (current, s);
      if (s != o)
        {
          mcMetaError_metaError2 ((char *) "{%1ad} cannot be imported into the current module as it causes a name clash with {%2ad}", 87, (unsigned char *) &s, (sizeof (s)-1), (unsigned char *) &o, (sizeof (o)-1));
        }
    }
}


/*
   checkEndName - if module does not have, name, then issue an error containing, desc.
*/

static void checkEndName (decl_node module, nameKey_Name name, char *desc_, unsigned int _desc_high)
{
  DynamicStrings_String s;
  char desc[_desc_high+1];

  /* make a local copy of each unbounded array.  */
  memcpy (desc, desc_, _desc_high+1);

  if ((decl_getSymName (module)) != name)
    {
      s = DynamicStrings_InitString ((char *) "inconsistent module name found with this ", 41);
      s = DynamicStrings_ConCat (s, DynamicStrings_Mark (DynamicStrings_InitString ((char *) desc, _desc_high)));
      ErrorString (s);
    }
}


/*
   DescribeStop - issues a message explaining what tokens were expected
*/

static DynamicStrings_String DescribeStop (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  unsigned int n;
  DynamicStrings_String str;
  DynamicStrings_String message;

  n = 0;
  message = DynamicStrings_InitString ((char *) "", 0);
  if ((((1 << (mcReserved_stringtok-mcReserved_recordtok)) & (stopset2)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) "string", 6)));
      n += 1;
    }
  if ((((1 << (mcReserved_realtok-mcReserved_recordtok)) & (stopset2)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) "real number", 11)));
      n += 1;
    }
  if ((((1 << (mcReserved_identtok-mcReserved_recordtok)) & (stopset2)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) "identifier", 10)));
      n += 1;
    }
  if ((((1 << (mcReserved_integertok-mcReserved_recordtok)) & (stopset2)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) "integer number", 14)));
      n += 1;
    }
  if ((((1 << (mcReserved_inlinetok-mcReserved_recordtok)) & (stopset2)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) "__INLINE__", 10)));
      n += 1;
    }
  if ((((1 << (mcReserved_builtintok-mcReserved_recordtok)) & (stopset2)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) "__BUILTIN__", 11)));
      n += 1;
    }
  if ((((1 << (mcReserved_attributetok-mcReserved_recordtok)) & (stopset2)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) "__ATTRIBUTE__", 13)));
      n += 1;
    }
  if ((((1 << (mcReserved_filetok-mcReserved_recordtok)) & (stopset2)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) "__FILE__", 8)));
      n += 1;
    }
  if ((((1 << (mcReserved_linetok-mcReserved_recordtok)) & (stopset2)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) "__LINE__", 8)));
      n += 1;
    }
  if ((((1 << (mcReserved_datetok-mcReserved_recordtok)) & (stopset2)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) "__DATE__", 8)));
      n += 1;
    }
  if ((((1 << (mcReserved_periodperiodperiodtok-mcReserved_recordtok)) & (stopset2)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) "...", 3)));
      n += 1;
    }
  if ((((1 << (mcReserved_volatiletok-mcReserved_recordtok)) & (stopset2)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) "VOLATILE", 8)));
      n += 1;
    }
  if ((((1 << (mcReserved_asmtok-mcReserved_recordtok)) & (stopset2)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) "ASM", 3)));
      n += 1;
    }
  if ((((1 << (mcReserved_withtok-mcReserved_recordtok)) & (stopset2)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) "WITH", 4)));
      n += 1;
    }
  if ((((1 << (mcReserved_whiletok-mcReserved_recordtok)) & (stopset2)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) "WHILE", 5)));
      n += 1;
    }
  if ((((1 << (mcReserved_vartok-mcReserved_recordtok)) & (stopset2)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) "VAR", 3)));
      n += 1;
    }
  if ((((1 << (mcReserved_untiltok-mcReserved_recordtok)) & (stopset2)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) "UNTIL", 5)));
      n += 1;
    }
  if ((((1 << (mcReserved_typetok-mcReserved_recordtok)) & (stopset2)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) "TYPE", 4)));
      n += 1;
    }
  if ((((1 << (mcReserved_totok-mcReserved_recordtok)) & (stopset2)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) "TO", 2)));
      n += 1;
    }
  if ((((1 << (mcReserved_thentok-mcReserved_recordtok)) & (stopset2)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) "THEN", 4)));
      n += 1;
    }
  if ((((1 << (mcReserved_settok-mcReserved_recordtok)) & (stopset2)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) "SET", 3)));
      n += 1;
    }
  if ((((1 << (mcReserved_returntok-mcReserved_recordtok)) & (stopset2)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) "RETURN", 6)));
      n += 1;
    }
  if ((((1 << (mcReserved_retrytok-mcReserved_recordtok)) & (stopset2)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) "RETRY", 5)));
      n += 1;
    }
  if ((((1 << (mcReserved_repeattok-mcReserved_recordtok)) & (stopset2)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) "REPEAT", 6)));
      n += 1;
    }
  if ((((1 << (mcReserved_remtok-mcReserved_recordtok)) & (stopset2)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) "REM", 3)));
      n += 1;
    }
  if ((((1 << (mcReserved_recordtok-mcReserved_recordtok)) & (stopset2)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) "RECORD", 6)));
      n += 1;
    }
  if ((((1 << (mcReserved_unqualifiedtok-mcReserved_arraytok)) & (stopset1)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) "UNQUALIFIED", 11)));
      n += 1;
    }
  if ((((1 << (mcReserved_qualifiedtok-mcReserved_arraytok)) & (stopset1)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) "QUALIFIED", 9)));
      n += 1;
    }
  if ((((1 << (mcReserved_proceduretok-mcReserved_arraytok)) & (stopset1)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) "PROCEDURE", 9)));
      n += 1;
    }
  if ((((1 << (mcReserved_pointertok-mcReserved_arraytok)) & (stopset1)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) "POINTER", 7)));
      n += 1;
    }
  if ((((1 << (mcReserved_packedsettok-mcReserved_arraytok)) & (stopset1)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) "PACKEDSET", 9)));
      n += 1;
    }
  if ((((1 << (mcReserved_ortok-mcReserved_arraytok)) & (stopset1)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) "OR", 2)));
      n += 1;
    }
  if ((((1 << (mcReserved_oftok-mcReserved_arraytok)) & (stopset1)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) "OF", 2)));
      n += 1;
    }
  if ((((1 << (mcReserved_nottok-mcReserved_arraytok)) & (stopset1)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) "NOT", 3)));
      n += 1;
    }
  if ((((1 << (mcReserved_moduletok-mcReserved_arraytok)) & (stopset1)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) "MODULE", 6)));
      n += 1;
    }
  if ((((1 << (mcReserved_modtok-mcReserved_arraytok)) & (stopset1)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) "MOD", 3)));
      n += 1;
    }
  if ((((1 << (mcReserved_looptok-mcReserved_arraytok)) & (stopset1)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) "LOOP", 4)));
      n += 1;
    }
  if ((((1 << (mcReserved_intok-mcReserved_arraytok)) & (stopset1)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) "IN", 2)));
      n += 1;
    }
  if ((((1 << (mcReserved_importtok-mcReserved_arraytok)) & (stopset1)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) "IMPORT", 6)));
      n += 1;
    }
  if ((((1 << (mcReserved_implementationtok-mcReserved_arraytok)) & (stopset1)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) "IMPLEMENTATION", 14)));
      n += 1;
    }
  if ((((1 << (mcReserved_iftok-mcReserved_arraytok)) & (stopset1)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) "IF", 2)));
      n += 1;
    }
  if ((((1 << (mcReserved_fromtok-mcReserved_arraytok)) & (stopset1)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) "FROM", 4)));
      n += 1;
    }
  if ((((1 << (mcReserved_fortok-mcReserved_arraytok)) & (stopset1)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) "FOR", 3)));
      n += 1;
    }
  if ((((1 << (mcReserved_finallytok-mcReserved_arraytok)) & (stopset1)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) "FINALLY", 7)));
      n += 1;
    }
  if ((((1 << (mcReserved_exporttok-mcReserved_arraytok)) & (stopset1)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) "EXPORT", 6)));
      n += 1;
    }
  if ((((1 << (mcReserved_exittok-mcReserved_arraytok)) & (stopset1)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) "EXIT", 4)));
      n += 1;
    }
  if ((((1 << (mcReserved_excepttok-mcReserved_arraytok)) & (stopset1)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) "EXCEPT", 6)));
      n += 1;
    }
  if ((((1 << (mcReserved_endtok-mcReserved_arraytok)) & (stopset1)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) "END", 3)));
      n += 1;
    }
  if ((((1 << (mcReserved_elsiftok-mcReserved_arraytok)) & (stopset1)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) "ELSIF", 5)));
      n += 1;
    }
  if ((((1 << (mcReserved_elsetok-mcReserved_arraytok)) & (stopset1)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) "ELSE", 4)));
      n += 1;
    }
  if ((((1 << (mcReserved_dotok-mcReserved_arraytok)) & (stopset1)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) "DO", 2)));
      n += 1;
    }
  if ((((1 << (mcReserved_divtok-mcReserved_arraytok)) & (stopset1)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) "DIV", 3)));
      n += 1;
    }
  if ((((1 << (mcReserved_definitiontok-mcReserved_arraytok)) & (stopset1)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) "DEFINITION", 10)));
      n += 1;
    }
  if ((((1 << (mcReserved_consttok-mcReserved_arraytok)) & (stopset1)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) "CONST", 5)));
      n += 1;
    }
  if ((((1 << (mcReserved_casetok-mcReserved_arraytok)) & (stopset1)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) "CASE", 4)));
      n += 1;
    }
  if ((((1 << (mcReserved_bytok-mcReserved_arraytok)) & (stopset1)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) "BY", 2)));
      n += 1;
    }
  if ((((1 << (mcReserved_begintok-mcReserved_arraytok)) & (stopset1)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) "BEGIN", 5)));
      n += 1;
    }
  if ((((1 << (mcReserved_arraytok-mcReserved_arraytok)) & (stopset1)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) "ARRAY", 5)));
      n += 1;
    }
  if ((((1 << (mcReserved_andtok-mcReserved_eoftok)) & (stopset0)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) "AND", 3)));
      n += 1;
    }
  if ((((1 << (mcReserved_colontok-mcReserved_eoftok)) & (stopset0)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) ":", 1)));
      n += 1;
    }
  if ((((1 << (mcReserved_periodperiodtok-mcReserved_eoftok)) & (stopset0)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) "..", 2)));
      n += 1;
    }
  if ((((1 << (mcReserved_rdirectivetok-mcReserved_eoftok)) & (stopset0)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) "*>", 2)));
      n += 1;
    }
  if ((((1 << (mcReserved_ldirectivetok-mcReserved_eoftok)) & (stopset0)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) "<*", 2)));
      n += 1;
    }
  if ((((1 << (mcReserved_greaterequaltok-mcReserved_eoftok)) & (stopset0)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) ">=", 2)));
      n += 1;
    }
  if ((((1 << (mcReserved_lessequaltok-mcReserved_eoftok)) & (stopset0)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) "<=", 2)));
      n += 1;
    }
  if ((((1 << (mcReserved_lessgreatertok-mcReserved_eoftok)) & (stopset0)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) "<>", 2)));
      n += 1;
    }
  if ((((1 << (mcReserved_hashtok-mcReserved_eoftok)) & (stopset0)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) "#", 1)));
      n += 1;
    }
  if ((((1 << (mcReserved_equaltok-mcReserved_eoftok)) & (stopset0)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) "=", 1)));
      n += 1;
    }
  if ((((1 << (mcReserved_uparrowtok-mcReserved_eoftok)) & (stopset0)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) "^", 1)));
      n += 1;
    }
  if ((((1 << (mcReserved_semicolontok-mcReserved_eoftok)) & (stopset0)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) ";", 1)));
      n += 1;
    }
  if ((((1 << (mcReserved_commatok-mcReserved_eoftok)) & (stopset0)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) ",", 1)));
      n += 1;
    }
  if ((((1 << (mcReserved_periodtok-mcReserved_eoftok)) & (stopset0)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) ".", 1)));
      n += 1;
    }
  if ((((1 << (mcReserved_ambersandtok-mcReserved_eoftok)) & (stopset0)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) "&", 1)));
      n += 1;
    }
  if ((((1 << (mcReserved_dividetok-mcReserved_eoftok)) & (stopset0)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) "/", 1)));
      n += 1;
    }
  if ((((1 << (mcReserved_timestok-mcReserved_eoftok)) & (stopset0)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) "*", 1)));
      n += 1;
    }
  if ((((1 << (mcReserved_minustok-mcReserved_eoftok)) & (stopset0)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) "-", 1)));
      n += 1;
    }
  if ((((1 << (mcReserved_plustok-mcReserved_eoftok)) & (stopset0)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) "+", 1)));
      n += 1;
    }
  if ((((1 << (mcReserved_doublequotestok-mcReserved_eoftok)) & (stopset0)) != 0))
    {
      message = DynamicStrings_ConCatChar (DynamicStrings_ConCatChar (DynamicStrings_ConCatChar (DynamicStrings_ConCatChar (DynamicStrings_ConCatChar (message, ' '), '`'), '"'), '\''), ',');
      n += 1;
    }
  if ((((1 << (mcReserved_singlequotetok-mcReserved_eoftok)) & (stopset0)) != 0))
    {
      message = DynamicStrings_ConCatChar (DynamicStrings_ConCatChar (DynamicStrings_ConCatChar (DynamicStrings_ConCatChar (DynamicStrings_ConCatChar (message, ' '), '"'), '\''), '"'), ',');
      n += 1;
    }
  if ((((1 << (mcReserved_greatertok-mcReserved_eoftok)) & (stopset0)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) ">", 1)));
      n += 1;
    }
  if ((((1 << (mcReserved_lesstok-mcReserved_eoftok)) & (stopset0)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) "<", 1)));
      n += 1;
    }
  if ((((1 << (mcReserved_rparatok-mcReserved_eoftok)) & (stopset0)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) ")", 1)));
      n += 1;
    }
  if ((((1 << (mcReserved_lparatok-mcReserved_eoftok)) & (stopset0)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) "(", 1)));
      n += 1;
    }
  if ((((1 << (mcReserved_rcbratok-mcReserved_eoftok)) & (stopset0)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) "}", 1)));
      n += 1;
    }
  if ((((1 << (mcReserved_lcbratok-mcReserved_eoftok)) & (stopset0)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) "{", 1)));
      n += 1;
    }
  if ((((1 << (mcReserved_rsbratok-mcReserved_eoftok)) & (stopset0)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) "]", 1)));
      n += 1;
    }
  if ((((1 << (mcReserved_lsbratok-mcReserved_eoftok)) & (stopset0)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) "[", 1)));
      n += 1;
    }
  if ((((1 << (mcReserved_bartok-mcReserved_eoftok)) & (stopset0)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) "|", 1)));
      n += 1;
    }
  if ((((1 << (mcReserved_becomestok-mcReserved_eoftok)) & (stopset0)) != 0))
    {
      message = DynamicStrings_ConCat (DynamicStrings_ConCatChar (message, ' '), DynamicStrings_Mark (DynamicStrings_InitString ((char *) ":=", 2)));
      n += 1;
    }
  if ((((1 << (mcReserved_eoftok-mcReserved_eoftok)) & (stopset0)) != 0))
    {}  /* empty.  */
  /* eoftok has no token name (needed to generate error messages)  */
  if (n == 0)
    {
      str = DynamicStrings_InitString ((char *) " syntax error", 13);
      message = DynamicStrings_KillString (message);
    }
  else if (n == 1)
    {
      /* avoid dangling else.  */
      str = DynamicStrings_ConCat (message, DynamicStrings_Mark (DynamicStrings_InitString ((char *) " missing ", 9)));
    }
  else
    {
      /* avoid dangling else.  */
      str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) " expecting one of", 17), message);
      message = DynamicStrings_KillString (message);
    }
  return str;
  /* static analysis guarentees a RETURN statement will be used before here.  */
  __builtin_unreachable ();
}


/*
   DescribeError - issues a message explaining what tokens were expected
*/

static void DescribeError (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  DynamicStrings_String str;

  str = DynamicStrings_InitString ((char *) "", 0);
  switch (mcLexBuf_currenttoken)
    {
      case mcReserved_stringtok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found string", 26), DynamicStrings_Mark (str));
        break;

      case mcReserved_realtok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found real number", 31), DynamicStrings_Mark (str));
        break;

      case mcReserved_identtok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found identifier", 30), DynamicStrings_Mark (str));
        break;

      case mcReserved_integertok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found integer number", 34), DynamicStrings_Mark (str));
        break;

      case mcReserved_inlinetok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found __INLINE__", 30), DynamicStrings_Mark (str));
        break;

      case mcReserved_builtintok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found __BUILTIN__", 31), DynamicStrings_Mark (str));
        break;

      case mcReserved_attributetok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found __ATTRIBUTE__", 33), DynamicStrings_Mark (str));
        break;

      case mcReserved_filetok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found __FILE__", 28), DynamicStrings_Mark (str));
        break;

      case mcReserved_linetok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found __LINE__", 28), DynamicStrings_Mark (str));
        break;

      case mcReserved_datetok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found __DATE__", 28), DynamicStrings_Mark (str));
        break;

      case mcReserved_periodperiodperiodtok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found ...", 23), DynamicStrings_Mark (str));
        break;

      case mcReserved_volatiletok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found VOLATILE", 28), DynamicStrings_Mark (str));
        break;

      case mcReserved_asmtok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found ASM", 23), DynamicStrings_Mark (str));
        break;

      case mcReserved_withtok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found WITH", 24), DynamicStrings_Mark (str));
        break;

      case mcReserved_whiletok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found WHILE", 25), DynamicStrings_Mark (str));
        break;

      case mcReserved_vartok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found VAR", 23), DynamicStrings_Mark (str));
        break;

      case mcReserved_untiltok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found UNTIL", 25), DynamicStrings_Mark (str));
        break;

      case mcReserved_typetok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found TYPE", 24), DynamicStrings_Mark (str));
        break;

      case mcReserved_totok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found TO", 22), DynamicStrings_Mark (str));
        break;

      case mcReserved_thentok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found THEN", 24), DynamicStrings_Mark (str));
        break;

      case mcReserved_settok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found SET", 23), DynamicStrings_Mark (str));
        break;

      case mcReserved_returntok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found RETURN", 26), DynamicStrings_Mark (str));
        break;

      case mcReserved_retrytok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found RETRY", 25), DynamicStrings_Mark (str));
        break;

      case mcReserved_repeattok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found REPEAT", 26), DynamicStrings_Mark (str));
        break;

      case mcReserved_remtok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found REM", 23), DynamicStrings_Mark (str));
        break;

      case mcReserved_recordtok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found RECORD", 26), DynamicStrings_Mark (str));
        break;

      case mcReserved_unqualifiedtok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found UNQUALIFIED", 31), DynamicStrings_Mark (str));
        break;

      case mcReserved_qualifiedtok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found QUALIFIED", 29), DynamicStrings_Mark (str));
        break;

      case mcReserved_proceduretok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found PROCEDURE", 29), DynamicStrings_Mark (str));
        break;

      case mcReserved_pointertok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found POINTER", 27), DynamicStrings_Mark (str));
        break;

      case mcReserved_packedsettok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found PACKEDSET", 29), DynamicStrings_Mark (str));
        break;

      case mcReserved_ortok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found OR", 22), DynamicStrings_Mark (str));
        break;

      case mcReserved_oftok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found OF", 22), DynamicStrings_Mark (str));
        break;

      case mcReserved_nottok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found NOT", 23), DynamicStrings_Mark (str));
        break;

      case mcReserved_moduletok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found MODULE", 26), DynamicStrings_Mark (str));
        break;

      case mcReserved_modtok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found MOD", 23), DynamicStrings_Mark (str));
        break;

      case mcReserved_looptok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found LOOP", 24), DynamicStrings_Mark (str));
        break;

      case mcReserved_intok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found IN", 22), DynamicStrings_Mark (str));
        break;

      case mcReserved_importtok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found IMPORT", 26), DynamicStrings_Mark (str));
        break;

      case mcReserved_implementationtok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found IMPLEMENTATION", 34), DynamicStrings_Mark (str));
        break;

      case mcReserved_iftok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found IF", 22), DynamicStrings_Mark (str));
        break;

      case mcReserved_fromtok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found FROM", 24), DynamicStrings_Mark (str));
        break;

      case mcReserved_fortok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found FOR", 23), DynamicStrings_Mark (str));
        break;

      case mcReserved_finallytok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found FINALLY", 27), DynamicStrings_Mark (str));
        break;

      case mcReserved_exporttok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found EXPORT", 26), DynamicStrings_Mark (str));
        break;

      case mcReserved_exittok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found EXIT", 24), DynamicStrings_Mark (str));
        break;

      case mcReserved_excepttok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found EXCEPT", 26), DynamicStrings_Mark (str));
        break;

      case mcReserved_endtok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found END", 23), DynamicStrings_Mark (str));
        break;

      case mcReserved_elsiftok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found ELSIF", 25), DynamicStrings_Mark (str));
        break;

      case mcReserved_elsetok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found ELSE", 24), DynamicStrings_Mark (str));
        break;

      case mcReserved_dotok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found DO", 22), DynamicStrings_Mark (str));
        break;

      case mcReserved_divtok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found DIV", 23), DynamicStrings_Mark (str));
        break;

      case mcReserved_definitiontok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found DEFINITION", 30), DynamicStrings_Mark (str));
        break;

      case mcReserved_consttok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found CONST", 25), DynamicStrings_Mark (str));
        break;

      case mcReserved_casetok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found CASE", 24), DynamicStrings_Mark (str));
        break;

      case mcReserved_bytok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found BY", 22), DynamicStrings_Mark (str));
        break;

      case mcReserved_begintok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found BEGIN", 25), DynamicStrings_Mark (str));
        break;

      case mcReserved_arraytok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found ARRAY", 25), DynamicStrings_Mark (str));
        break;

      case mcReserved_andtok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found AND", 23), DynamicStrings_Mark (str));
        break;

      case mcReserved_colontok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found :", 21), DynamicStrings_Mark (str));
        break;

      case mcReserved_periodperiodtok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found ..", 22), DynamicStrings_Mark (str));
        break;

      case mcReserved_rdirectivetok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found *>", 22), DynamicStrings_Mark (str));
        break;

      case mcReserved_ldirectivetok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found <*", 22), DynamicStrings_Mark (str));
        break;

      case mcReserved_greaterequaltok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found >=", 22), DynamicStrings_Mark (str));
        break;

      case mcReserved_lessequaltok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found <=", 22), DynamicStrings_Mark (str));
        break;

      case mcReserved_lessgreatertok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found <>", 22), DynamicStrings_Mark (str));
        break;

      case mcReserved_hashtok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found #", 21), DynamicStrings_Mark (str));
        break;

      case mcReserved_equaltok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found =", 21), DynamicStrings_Mark (str));
        break;

      case mcReserved_uparrowtok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found ^", 21), DynamicStrings_Mark (str));
        break;

      case mcReserved_semicolontok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found ;", 21), DynamicStrings_Mark (str));
        break;

      case mcReserved_commatok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found ,", 21), DynamicStrings_Mark (str));
        break;

      case mcReserved_periodtok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found .", 21), DynamicStrings_Mark (str));
        break;

      case mcReserved_ambersandtok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found &", 21), DynamicStrings_Mark (str));
        break;

      case mcReserved_dividetok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found /", 21), DynamicStrings_Mark (str));
        break;

      case mcReserved_timestok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found *", 21), DynamicStrings_Mark (str));
        break;

      case mcReserved_minustok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found -", 21), DynamicStrings_Mark (str));
        break;

      case mcReserved_plustok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found +", 21), DynamicStrings_Mark (str));
        break;

      case mcReserved_doublequotestok:
        str = DynamicStrings_ConCat (DynamicStrings_ConCatChar (DynamicStrings_ConCatChar (DynamicStrings_InitString ((char *) "syntax error, found '", 21), '"'), '\''), DynamicStrings_Mark (str));
        break;

      case mcReserved_singlequotetok:
        str = DynamicStrings_ConCat (DynamicStrings_ConCatChar (DynamicStrings_ConCatChar (DynamicStrings_InitString ((char *) "syntax error, found \"", 21), '\''), '"'), DynamicStrings_Mark (str));
        break;

      case mcReserved_greatertok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found >", 21), DynamicStrings_Mark (str));
        break;

      case mcReserved_lesstok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found <", 21), DynamicStrings_Mark (str));
        break;

      case mcReserved_rparatok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found )", 21), DynamicStrings_Mark (str));
        break;

      case mcReserved_lparatok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found (", 21), DynamicStrings_Mark (str));
        break;

      case mcReserved_rcbratok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found }", 21), DynamicStrings_Mark (str));
        break;

      case mcReserved_lcbratok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found {", 21), DynamicStrings_Mark (str));
        break;

      case mcReserved_rsbratok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found ]", 21), DynamicStrings_Mark (str));
        break;

      case mcReserved_lsbratok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found [", 21), DynamicStrings_Mark (str));
        break;

      case mcReserved_bartok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found |", 21), DynamicStrings_Mark (str));
        break;

      case mcReserved_becomestok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found :=", 22), DynamicStrings_Mark (str));
        break;

      case mcReserved_eoftok:
        str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error, found ", 20), DynamicStrings_Mark (str));
        break;


      default:
        break;
    }
  ErrorString (str);
}


/*
   SyntaxError - after a syntax error we skip all tokens up until we reach
                 a stop symbol.
*/

static void SyntaxError (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  DescribeError (stopset0, stopset1, stopset2);
  if (Debugging)
    {
      mcPrintf_printf0 ((char *) "\\nskipping token *** ", 21);
    }
  /* 
      yes the ORD(currenttoken) looks ugly, but it is *much* safer than
      using currenttoken<sometok as a change to the ordering of the
      token declarations below would cause this to break. Using ORD() we are
      immune from such changes
  */
  while (! (((( ((unsigned int) (mcLexBuf_currenttoken)) < 32) && ((((1 << (mcLexBuf_currenttoken-mcReserved_eoftok)) & (stopset0)) != 0))) || ((( ((unsigned int) (mcLexBuf_currenttoken)) >= 32) && ( ((unsigned int) (mcLexBuf_currenttoken)) < 64)) && ((((1 << (mcLexBuf_currenttoken-mcReserved_arraytok)) & (stopset1)) != 0)))) || (( ((unsigned int) (mcLexBuf_currenttoken)) >= 64) && ((((1 << (mcLexBuf_currenttoken-mcReserved_recordtok)) & (stopset2)) != 0)))))
    {
      mcLexBuf_getToken ();
    }
  if (Debugging)
    {
      mcPrintf_printf0 ((char *) " ***\\n", 6);
    }
}


/*
   SyntaxCheck -
*/

static void SyntaxCheck (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  /* and again (see above re: ORD)
  */
  if (! (((( ((unsigned int) (mcLexBuf_currenttoken)) < 32) && ((((1 << (mcLexBuf_currenttoken-mcReserved_eoftok)) & (stopset0)) != 0))) || ((( ((unsigned int) (mcLexBuf_currenttoken)) >= 32) && ( ((unsigned int) (mcLexBuf_currenttoken)) < 64)) && ((((1 << (mcLexBuf_currenttoken-mcReserved_arraytok)) & (stopset1)) != 0)))) || (( ((unsigned int) (mcLexBuf_currenttoken)) >= 64) && ((((1 << (mcLexBuf_currenttoken-mcReserved_recordtok)) & (stopset2)) != 0)))))
    {
      SyntaxError (stopset0, stopset1, stopset2);
    }
}


/*
   WarnMissingToken - generates a warning message about a missing token, t.
*/

static void WarnMissingToken (mcReserved_toktype t)
{
  SetOfStop0 s0;
  SetOfStop1 s1;
  SetOfStop2 s2;
  DynamicStrings_String str;

  s0 = (SetOfStop0) 0;
  s1 = (SetOfStop1) 0;
  s2 = (SetOfStop2) 0;
  if ( ((unsigned int) (t)) < 32)
    {
      s0 = (SetOfStop0) ((1 << (t-mcReserved_eoftok)));
    }
  else if ( ((unsigned int) (t)) < 64)
    {
      /* avoid dangling else.  */
      s1 = (SetOfStop1) ((1 << (t-mcReserved_arraytok)));
    }
  else
    {
      /* avoid dangling else.  */
      s2 = (SetOfStop2) ((1 << (t-mcReserved_recordtok)));
    }
  str = DescribeStop (s0, s1, s2);
  str = DynamicStrings_ConCat (DynamicStrings_InitString ((char *) "syntax error,", 13), DynamicStrings_Mark (str));
  mcError_errorStringAt (str, mcLexBuf_getTokenNo ());
}


/*
   MissingToken - generates a warning message about a missing token, t.
*/

static void MissingToken (mcReserved_toktype t)
{
  WarnMissingToken (t);
  if ((((t != mcReserved_identtok) && (t != mcReserved_integertok)) && (t != mcReserved_realtok)) && (t != mcReserved_stringtok))
    {
      if (Debugging)
        {
          mcPrintf_printf0 ((char *) "inserting token\\n", 17);
        }
      mcLexBuf_insertToken (t);
    }
}


/*
   CheckAndInsert -
*/

static unsigned int CheckAndInsert (mcReserved_toktype t, SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  if (((( ((unsigned int) (t)) < 32) && ((((1 << (t-mcReserved_eoftok)) & (stopset0)) != 0))) || ((( ((unsigned int) (t)) >= 32) && ( ((unsigned int) (t)) < 64)) && ((((1 << (t-mcReserved_arraytok)) & (stopset1)) != 0)))) || (( ((unsigned int) (t)) >= 64) && ((((1 << (t-mcReserved_recordtok)) & (stopset2)) != 0))))
    {
      WarnMissingToken (t);
      mcLexBuf_insertTokenAndRewind (t);
      return TRUE;
    }
  else
    {
      return FALSE;
    }
  /* static analysis guarentees a RETURN statement will be used before here.  */
  __builtin_unreachable ();
}


/*
   InStopSet
*/

static unsigned int InStopSet (mcReserved_toktype t, SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  if (((( ((unsigned int) (t)) < 32) && ((((1 << (t-mcReserved_eoftok)) & (stopset0)) != 0))) || ((( ((unsigned int) (t)) >= 32) && ( ((unsigned int) (t)) < 64)) && ((((1 << (t-mcReserved_arraytok)) & (stopset1)) != 0)))) || (( ((unsigned int) (t)) >= 64) && ((((1 << (t-mcReserved_recordtok)) & (stopset2)) != 0))))
    {
      return TRUE;
    }
  else
    {
      return FALSE;
    }
  /* static analysis guarentees a RETURN statement will be used before here.  */
  __builtin_unreachable ();
}


/*
   PeepToken - peep token checks to see whether the stopset is satisfied by currenttoken
               If it is not then it will insert a token providing the token
               is one of ; ] ) } . OF END ,

               if the stopset contains <identtok> then we do not insert a token
*/

static void PeepToken (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  /* and again (see above re: ORD)
  */
  if ((! (((( ((unsigned int) (mcLexBuf_currenttoken)) < 32) && ((((1 << (mcLexBuf_currenttoken-mcReserved_eoftok)) & (stopset0)) != 0))) || ((( ((unsigned int) (mcLexBuf_currenttoken)) >= 32) && ( ((unsigned int) (mcLexBuf_currenttoken)) < 64)) && ((((1 << (mcLexBuf_currenttoken-mcReserved_arraytok)) & (stopset1)) != 0)))) || (( ((unsigned int) (mcLexBuf_currenttoken)) >= 64) && ((((1 << (mcLexBuf_currenttoken-mcReserved_recordtok)) & (stopset2)) != 0))))) && (! (InStopSet ((mcReserved_toktype) mcReserved_identtok, stopset0, stopset1, stopset2))))
    {
      /* SyntaxCheck would fail since currentoken is not part of the stopset
         we check to see whether any of currenttoken might be a commonly omitted token  */
      if ((((((((CheckAndInsert ((mcReserved_toktype) mcReserved_semicolontok, stopset0, stopset1, stopset2)) || (CheckAndInsert ((mcReserved_toktype) mcReserved_rsbratok, stopset0, stopset1, stopset2))) || (CheckAndInsert ((mcReserved_toktype) mcReserved_rparatok, stopset0, stopset1, stopset2))) || (CheckAndInsert ((mcReserved_toktype) mcReserved_rcbratok, stopset0, stopset1, stopset2))) || (CheckAndInsert ((mcReserved_toktype) mcReserved_periodtok, stopset0, stopset1, stopset2))) || (CheckAndInsert ((mcReserved_toktype) mcReserved_oftok, stopset0, stopset1, stopset2))) || (CheckAndInsert ((mcReserved_toktype) mcReserved_endtok, stopset0, stopset1, stopset2))) || (CheckAndInsert ((mcReserved_toktype) mcReserved_commatok, stopset0, stopset1, stopset2)))
        {}  /* empty.  */
    }
}


/*
   Expect -
*/

static void Expect (mcReserved_toktype t, SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  if (mcLexBuf_currenttoken == t)
    {
      /* avoid dangling else.  */
      mcLexBuf_getToken ();
      if (Pass1)
        {
          PeepToken (stopset0, stopset1, stopset2);
        }
    }
  else
    {
      MissingToken (t);
    }
  SyntaxCheck (stopset0, stopset1, stopset2);
}


/*
   Ident - error checking varient of Ident
*/

static void Ident (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  curident = nameKey_makekey (mcLexBuf_currentstring);
  Expect ((mcReserved_toktype) mcReserved_identtok, stopset0, stopset1, stopset2);
}


/*
   string -
*/

static void string (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  curstring = nameKey_makekey (mcLexBuf_currentstring);
  Expect ((mcReserved_toktype) mcReserved_stringtok, stopset0, stopset1, stopset2);
}


/*
   Integer -
*/

static void Integer (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  decl_node n;

  n = push (decl_makeLiteralInt (nameKey_makekey (mcLexBuf_currentstring)));
  Expect ((mcReserved_toktype) mcReserved_integertok, stopset0, stopset1, stopset2);
}


/*
   Real -
*/

static void Real (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  decl_node n;

  n = push (decl_makeLiteralReal (nameKey_makekey (mcLexBuf_currentstring)));
  Expect ((mcReserved_toktype) mcReserved_realtok, stopset0, stopset1, stopset2);
}


/*
   FileUnit := DefinitionModule  | ImplementationOrProgramModule 

   first  symbols:implementationtok, moduletok, definitiontok
   
   cannot reachend
*/

static void FileUnit (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  if (mcLexBuf_currenttoken == mcReserved_definitiontok)
    {
      DefinitionModule (stopset0, stopset1, stopset2);
    }
  else if (((mcLexBuf_currenttoken >= mcReserved_arraytok) && (mcLexBuf_currenttoken < mcReserved_recordtok)) && ((((1 << (mcLexBuf_currenttoken-mcReserved_arraytok)) & ((SetOfStop1) ((1 << (mcReserved_implementationtok-mcReserved_arraytok)) | (1 << (mcReserved_moduletok-mcReserved_arraytok))))) != 0)))
    {
      /* avoid dangling else.  */
      ImplementationOrProgramModule (stopset0, stopset1, stopset2);
    }
  else
    {
      /* avoid dangling else.  */
      ErrorArray ((char *) "expecting one of: IMPLEMENTATION MODULE DEFINITION", 50);
    }
}


/*
   ProgramModule := 'MODULE' Ident 
                    % curmodule := lookupModule (curident)  %
                    
                    % addCommentBody (curmodule)  %
                    
                    % enterScope (curmodule)  %
                    
                    % resetConstExpPos (curmodule)  %
                    [ Priority  ] ';' { Import  } Block Ident 
                    
                    % checkEndName (curmodule, curident, 'program module')  %
                    
                    % leaveScope  %
                    '.' 

   first  symbols:moduletok
   
   cannot reachend
*/

static void ProgramModule (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  Expect ((mcReserved_toktype) mcReserved_moduletok, stopset0, stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_identtok-mcReserved_recordtok))));
  Ident (stopset0|(SetOfStop0) ((1 << (mcReserved_semicolontok-mcReserved_eoftok)) | (1 << (mcReserved_lsbratok-mcReserved_eoftok))), stopset1, stopset2);
  curmodule = decl_lookupModule (curident);
  decl_addCommentBody (curmodule);
  decl_enterScope (curmodule);
  decl_resetConstExpPos (curmodule);
  if (mcLexBuf_currenttoken == mcReserved_lsbratok)
    {
      Priority (stopset0|(SetOfStop0) ((1 << (mcReserved_semicolontok-mcReserved_eoftok))), stopset1, stopset2);
    }
  Expect ((mcReserved_toktype) mcReserved_semicolontok, stopset0, stopset1|(SetOfStop1) ((1 << (mcReserved_importtok-mcReserved_arraytok)) | (1 << (mcReserved_fromtok-mcReserved_arraytok)) | (1 << (mcReserved_endtok-mcReserved_arraytok)) | (1 << (mcReserved_finallytok-mcReserved_arraytok)) | (1 << (mcReserved_begintok-mcReserved_arraytok)) | (1 << (mcReserved_consttok-mcReserved_arraytok)) | (1 << (mcReserved_proceduretok-mcReserved_arraytok)) | (1 << (mcReserved_moduletok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_typetok-mcReserved_recordtok)) | (1 << (mcReserved_vartok-mcReserved_recordtok))));
  while (((mcLexBuf_currenttoken >= mcReserved_arraytok) && (mcLexBuf_currenttoken < mcReserved_recordtok)) && ((((1 << (mcLexBuf_currenttoken-mcReserved_arraytok)) & ((SetOfStop1) ((1 << (mcReserved_fromtok-mcReserved_arraytok)) | (1 << (mcReserved_importtok-mcReserved_arraytok))))) != 0)))
    {
      Import (stopset0, stopset1|(SetOfStop1) ((1 << (mcReserved_endtok-mcReserved_arraytok)) | (1 << (mcReserved_fromtok-mcReserved_arraytok)) | (1 << (mcReserved_importtok-mcReserved_arraytok)) | (1 << (mcReserved_consttok-mcReserved_arraytok)) | (1 << (mcReserved_begintok-mcReserved_arraytok)) | (1 << (mcReserved_finallytok-mcReserved_arraytok)) | (1 << (mcReserved_moduletok-mcReserved_arraytok)) | (1 << (mcReserved_proceduretok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_vartok-mcReserved_recordtok)) | (1 << (mcReserved_typetok-mcReserved_recordtok))));
    }
   /* while  */
  Block (stopset0, stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_identtok-mcReserved_recordtok))));
  Ident (stopset0|(SetOfStop0) ((1 << (mcReserved_periodtok-mcReserved_eoftok))), stopset1, stopset2);
  checkEndName (curmodule, curident, (char *) "program module", 14);
  decl_leaveScope ();
  Expect ((mcReserved_toktype) mcReserved_periodtok, stopset0, stopset1, stopset2);
}


/*
   ImplementationModule := 'IMPLEMENTATION' 'MODULE' Ident 
                           % curmodule := lookupImp (curident)  %
                           
                           % addCommentBody (curmodule)  %
                           
                           % enterScope (lookupDef (curident))  %
                           
                           % enterScope (curmodule)  %
                           
                           % resetConstExpPos (curmodule)  %
                           [ Priority  ] ';' { Import  } Block 
                           Ident 
                           % checkEndName (curmodule, curident, 'implementation module')  %
                           
                           % leaveScope ; leaveScope  %
                           '.' 

   first  symbols:implementationtok
   
   cannot reachend
*/

static void ImplementationModule (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  Expect ((mcReserved_toktype) mcReserved_implementationtok, stopset0, stopset1|(SetOfStop1) ((1 << (mcReserved_moduletok-mcReserved_arraytok))), stopset2);
  Expect ((mcReserved_toktype) mcReserved_moduletok, stopset0, stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_identtok-mcReserved_recordtok))));
  Ident (stopset0|(SetOfStop0) ((1 << (mcReserved_semicolontok-mcReserved_eoftok)) | (1 << (mcReserved_lsbratok-mcReserved_eoftok))), stopset1, stopset2);
  curmodule = decl_lookupImp (curident);
  decl_addCommentBody (curmodule);
  decl_enterScope (decl_lookupDef (curident));
  decl_enterScope (curmodule);
  decl_resetConstExpPos (curmodule);
  if (mcLexBuf_currenttoken == mcReserved_lsbratok)
    {
      Priority (stopset0|(SetOfStop0) ((1 << (mcReserved_semicolontok-mcReserved_eoftok))), stopset1, stopset2);
    }
  Expect ((mcReserved_toktype) mcReserved_semicolontok, stopset0, stopset1|(SetOfStop1) ((1 << (mcReserved_importtok-mcReserved_arraytok)) | (1 << (mcReserved_fromtok-mcReserved_arraytok)) | (1 << (mcReserved_endtok-mcReserved_arraytok)) | (1 << (mcReserved_finallytok-mcReserved_arraytok)) | (1 << (mcReserved_begintok-mcReserved_arraytok)) | (1 << (mcReserved_consttok-mcReserved_arraytok)) | (1 << (mcReserved_proceduretok-mcReserved_arraytok)) | (1 << (mcReserved_moduletok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_typetok-mcReserved_recordtok)) | (1 << (mcReserved_vartok-mcReserved_recordtok))));
  while (((mcLexBuf_currenttoken >= mcReserved_arraytok) && (mcLexBuf_currenttoken < mcReserved_recordtok)) && ((((1 << (mcLexBuf_currenttoken-mcReserved_arraytok)) & ((SetOfStop1) ((1 << (mcReserved_fromtok-mcReserved_arraytok)) | (1 << (mcReserved_importtok-mcReserved_arraytok))))) != 0)))
    {
      Import (stopset0, stopset1|(SetOfStop1) ((1 << (mcReserved_endtok-mcReserved_arraytok)) | (1 << (mcReserved_fromtok-mcReserved_arraytok)) | (1 << (mcReserved_importtok-mcReserved_arraytok)) | (1 << (mcReserved_consttok-mcReserved_arraytok)) | (1 << (mcReserved_begintok-mcReserved_arraytok)) | (1 << (mcReserved_finallytok-mcReserved_arraytok)) | (1 << (mcReserved_moduletok-mcReserved_arraytok)) | (1 << (mcReserved_proceduretok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_vartok-mcReserved_recordtok)) | (1 << (mcReserved_typetok-mcReserved_recordtok))));
    }
   /* while  */
  Block (stopset0, stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_identtok-mcReserved_recordtok))));
  Ident (stopset0|(SetOfStop0) ((1 << (mcReserved_periodtok-mcReserved_eoftok))), stopset1, stopset2);
  checkEndName (curmodule, curident, (char *) "implementation module", 21);
  decl_leaveScope ();
  decl_leaveScope ();
  Expect ((mcReserved_toktype) mcReserved_periodtok, stopset0, stopset1, stopset2);
}


/*
   ImplementationOrProgramModule := ImplementationModule  | 
                                    ProgramModule 

   first  symbols:moduletok, implementationtok
   
   cannot reachend
*/

static void ImplementationOrProgramModule (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  if (mcLexBuf_currenttoken == mcReserved_implementationtok)
    {
      ImplementationModule (stopset0, stopset1, stopset2);
    }
  else if (mcLexBuf_currenttoken == mcReserved_moduletok)
    {
      /* avoid dangling else.  */
      ProgramModule (stopset0, stopset1, stopset2);
    }
  else
    {
      /* avoid dangling else.  */
      ErrorArray ((char *) "expecting one of: MODULE IMPLEMENTATION", 39);
    }
}


/*
   ConstInteger := Integer 
                   % VAR i: node ;  %
                   
                   % i := pop ()  %
                   

   first  symbols:integertok
   
   cannot reachend
*/

static void ConstInteger (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  decl_node i;

  Integer (stopset0, stopset1, stopset2);
  i = pop ();
}


/*
   ConstReal := Real 
                % VAR r: node ;  %
                
                % r := pop ()  %
                

   first  symbols:realtok
   
   cannot reachend
*/

static void ConstReal (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  decl_node r;

  Real (stopset0, stopset1, stopset2);
  r = pop ();
}


/*
   ConstNumber := ConstInteger  | ConstReal 

   first  symbols:realtok, integertok
   
   cannot reachend
*/

static void ConstNumber (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  if (mcLexBuf_currenttoken == mcReserved_integertok)
    {
      ConstInteger (stopset0, stopset1, stopset2);
    }
  else if (mcLexBuf_currenttoken == mcReserved_realtok)
    {
      /* avoid dangling else.  */
      ConstReal (stopset0, stopset1, stopset2);
    }
  else
    {
      /* avoid dangling else.  */
      ErrorArray ((char *) "expecting one of: real number integer number", 44);
    }
}


/*
   Number := Integer  | Real 

   first  symbols:realtok, integertok
   
   cannot reachend
*/

static void Number (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  if (mcLexBuf_currenttoken == mcReserved_integertok)
    {
      Integer (stopset0, stopset1, stopset2);
    }
  else if (mcLexBuf_currenttoken == mcReserved_realtok)
    {
      /* avoid dangling else.  */
      Real (stopset0, stopset1, stopset2);
    }
  else
    {
      /* avoid dangling else.  */
      ErrorArray ((char *) "expecting one of: real number integer number", 44);
    }
}


/*
   Qualident := Ident { '.' Ident  } 

   first  symbols:identtok
   
   cannot reachend
*/

static void Qualident (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  Ident (stopset0|(SetOfStop0) ((1 << (mcReserved_periodtok-mcReserved_eoftok))), stopset1, stopset2);
  while (mcLexBuf_currenttoken == mcReserved_periodtok)
    {
      Expect ((mcReserved_toktype) mcReserved_periodtok, stopset0, stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_identtok-mcReserved_recordtok))));
      Ident (stopset0|(SetOfStop0) ((1 << (mcReserved_periodtok-mcReserved_eoftok))), stopset1, stopset2);
    }
   /* while  */
}


/*
   ConstantDeclaration := Ident '=' ConstExpressionNop 

   first  symbols:identtok
   
   cannot reachend
*/

static void ConstantDeclaration (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  Ident (stopset0|(SetOfStop0) ((1 << (mcReserved_equaltok-mcReserved_eoftok))), stopset1, stopset2);
  Expect ((mcReserved_toktype) mcReserved_equaltok, stopset0|(SetOfStop0) ((1 << (mcReserved_minustok-mcReserved_eoftok)) | (1 << (mcReserved_plustok-mcReserved_eoftok)) | (1 << (mcReserved_lparatok-mcReserved_eoftok)) | (1 << (mcReserved_lcbratok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_nottok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_integertok-mcReserved_recordtok)) | (1 << (mcReserved_realtok-mcReserved_recordtok)) | (1 << (mcReserved_attributetok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok)) | (1 << (mcReserved_stringtok-mcReserved_recordtok))));
  ConstExpressionNop (stopset0, stopset1, stopset2);
}


/*
   ConstExpressionNop := 
                         % VAR c: node ;  %
                         
                         % c := getNextConstExp ()  %
                         SimpleConstExpr [ Relation SimpleConstExpr  ] 

   first  symbols:attributetok, identtok, lcbratok, stringtok, nottok, lparatok, integertok, realtok, minustok, plustok
   
   cannot reachend
*/

static void ConstExpressionNop (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  decl_node c;

  c = decl_getNextConstExp ();
  SimpleConstExpr (stopset0|(SetOfStop0) ((1 << (mcReserved_greaterequaltok-mcReserved_eoftok)) | (1 << (mcReserved_greatertok-mcReserved_eoftok)) | (1 << (mcReserved_lessequaltok-mcReserved_eoftok)) | (1 << (mcReserved_lesstok-mcReserved_eoftok)) | (1 << (mcReserved_lessgreatertok-mcReserved_eoftok)) | (1 << (mcReserved_hashtok-mcReserved_eoftok)) | (1 << (mcReserved_equaltok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_intok-mcReserved_arraytok))), stopset2);
  if (((mcLexBuf_currenttoken < mcReserved_arraytok) && ((((1 << (mcLexBuf_currenttoken-mcReserved_eoftok)) & ((SetOfStop0) ((1 << (mcReserved_equaltok-mcReserved_eoftok)) | (1 << (mcReserved_hashtok-mcReserved_eoftok)) | (1 << (mcReserved_lessgreatertok-mcReserved_eoftok)) | (1 << (mcReserved_lesstok-mcReserved_eoftok)) | (1 << (mcReserved_lessequaltok-mcReserved_eoftok)) | (1 << (mcReserved_greatertok-mcReserved_eoftok)) | (1 << (mcReserved_greaterequaltok-mcReserved_eoftok))))) != 0))) || (mcLexBuf_currenttoken == mcReserved_intok))
    {
      Relation (stopset0|(SetOfStop0) ((1 << (mcReserved_plustok-mcReserved_eoftok)) | (1 << (mcReserved_minustok-mcReserved_eoftok)) | (1 << (mcReserved_lparatok-mcReserved_eoftok)) | (1 << (mcReserved_lcbratok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_nottok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_realtok-mcReserved_recordtok)) | (1 << (mcReserved_integertok-mcReserved_recordtok)) | (1 << (mcReserved_stringtok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok)) | (1 << (mcReserved_attributetok-mcReserved_recordtok))));
      SimpleConstExpr (stopset0, stopset1, stopset2);
    }
}


/*
   ConstExpression := 
                      % VAR c: node ;  %
                      
                      % c := push (getNextConstExp ())  %
                      SimpleConstExpr [ Relation SimpleConstExpr  ] 

   first  symbols:attributetok, identtok, lcbratok, stringtok, nottok, lparatok, integertok, realtok, minustok, plustok
   
   cannot reachend
*/

static void ConstExpression (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  decl_node c;

  c = push (decl_getNextConstExp ());
  SimpleConstExpr (stopset0|(SetOfStop0) ((1 << (mcReserved_greaterequaltok-mcReserved_eoftok)) | (1 << (mcReserved_greatertok-mcReserved_eoftok)) | (1 << (mcReserved_lessequaltok-mcReserved_eoftok)) | (1 << (mcReserved_lesstok-mcReserved_eoftok)) | (1 << (mcReserved_lessgreatertok-mcReserved_eoftok)) | (1 << (mcReserved_hashtok-mcReserved_eoftok)) | (1 << (mcReserved_equaltok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_intok-mcReserved_arraytok))), stopset2);
  if (((mcLexBuf_currenttoken < mcReserved_arraytok) && ((((1 << (mcLexBuf_currenttoken-mcReserved_eoftok)) & ((SetOfStop0) ((1 << (mcReserved_equaltok-mcReserved_eoftok)) | (1 << (mcReserved_hashtok-mcReserved_eoftok)) | (1 << (mcReserved_lessgreatertok-mcReserved_eoftok)) | (1 << (mcReserved_lesstok-mcReserved_eoftok)) | (1 << (mcReserved_lessequaltok-mcReserved_eoftok)) | (1 << (mcReserved_greatertok-mcReserved_eoftok)) | (1 << (mcReserved_greaterequaltok-mcReserved_eoftok))))) != 0))) || (mcLexBuf_currenttoken == mcReserved_intok))
    {
      Relation (stopset0|(SetOfStop0) ((1 << (mcReserved_plustok-mcReserved_eoftok)) | (1 << (mcReserved_minustok-mcReserved_eoftok)) | (1 << (mcReserved_lparatok-mcReserved_eoftok)) | (1 << (mcReserved_lcbratok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_nottok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_realtok-mcReserved_recordtok)) | (1 << (mcReserved_integertok-mcReserved_recordtok)) | (1 << (mcReserved_stringtok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok)) | (1 << (mcReserved_attributetok-mcReserved_recordtok))));
      SimpleConstExpr (stopset0, stopset1, stopset2);
    }
}


/*
   Relation := '='  | '#'  | '<>'  | '<'  | '<='  | '>'  | 
               '>='  | 'IN' 

   first  symbols:intok, greaterequaltok, greatertok, lessequaltok, lesstok, lessgreatertok, hashtok, equaltok
   
   cannot reachend
*/

static void Relation (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  if (mcLexBuf_currenttoken == mcReserved_equaltok)
    {
      Expect ((mcReserved_toktype) mcReserved_equaltok, stopset0, stopset1, stopset2);
    }
  else if (mcLexBuf_currenttoken == mcReserved_hashtok)
    {
      /* avoid dangling else.  */
      Expect ((mcReserved_toktype) mcReserved_hashtok, stopset0, stopset1, stopset2);
    }
  else if (mcLexBuf_currenttoken == mcReserved_lessgreatertok)
    {
      /* avoid dangling else.  */
      Expect ((mcReserved_toktype) mcReserved_lessgreatertok, stopset0, stopset1, stopset2);
    }
  else if (mcLexBuf_currenttoken == mcReserved_lesstok)
    {
      /* avoid dangling else.  */
      Expect ((mcReserved_toktype) mcReserved_lesstok, stopset0, stopset1, stopset2);
    }
  else if (mcLexBuf_currenttoken == mcReserved_lessequaltok)
    {
      /* avoid dangling else.  */
      Expect ((mcReserved_toktype) mcReserved_lessequaltok, stopset0, stopset1, stopset2);
    }
  else if (mcLexBuf_currenttoken == mcReserved_greatertok)
    {
      /* avoid dangling else.  */
      Expect ((mcReserved_toktype) mcReserved_greatertok, stopset0, stopset1, stopset2);
    }
  else if (mcLexBuf_currenttoken == mcReserved_greaterequaltok)
    {
      /* avoid dangling else.  */
      Expect ((mcReserved_toktype) mcReserved_greaterequaltok, stopset0, stopset1, stopset2);
    }
  else if (mcLexBuf_currenttoken == mcReserved_intok)
    {
      /* avoid dangling else.  */
      Expect ((mcReserved_toktype) mcReserved_intok, stopset0, stopset1, stopset2);
    }
  else
    {
      /* avoid dangling else.  */
      ErrorArray ((char *) "expecting one of: IN >= > <= < <> # =", 37);
    }
}


/*
   SimpleConstExpr := UnaryOrConstTerm { AddOperator ConstTerm  } 

   first  symbols:stringtok, lcbratok, identtok, attributetok, realtok, integertok, lparatok, nottok, plustok, minustok
   
   cannot reachend
*/

static void SimpleConstExpr (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  UnaryOrConstTerm (stopset0|(SetOfStop0) ((1 << (mcReserved_minustok-mcReserved_eoftok)) | (1 << (mcReserved_plustok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_ortok-mcReserved_arraytok))), stopset2);
  while (((mcLexBuf_currenttoken < mcReserved_arraytok) && ((((1 << (mcLexBuf_currenttoken-mcReserved_eoftok)) & ((SetOfStop0) ((1 << (mcReserved_plustok-mcReserved_eoftok)) | (1 << (mcReserved_minustok-mcReserved_eoftok))))) != 0))) || (mcLexBuf_currenttoken == mcReserved_ortok))
    {
      AddOperator (stopset0|(SetOfStop0) ((1 << (mcReserved_lparatok-mcReserved_eoftok)) | (1 << (mcReserved_lcbratok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_nottok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_realtok-mcReserved_recordtok)) | (1 << (mcReserved_integertok-mcReserved_recordtok)) | (1 << (mcReserved_stringtok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok)) | (1 << (mcReserved_attributetok-mcReserved_recordtok))));
      ConstTerm (stopset0|(SetOfStop0) ((1 << (mcReserved_plustok-mcReserved_eoftok)) | (1 << (mcReserved_minustok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_ortok-mcReserved_arraytok))), stopset2);
    }
   /* while  */
}


/*
   UnaryOrConstTerm := '+' ConstTerm  | '-' ConstTerm  | 
                       ConstTerm 

   first  symbols:attributetok, identtok, lcbratok, stringtok, nottok, lparatok, integertok, realtok, minustok, plustok
   
   cannot reachend
*/

static void UnaryOrConstTerm (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  if (mcLexBuf_currenttoken == mcReserved_plustok)
    {
      Expect ((mcReserved_toktype) mcReserved_plustok, stopset0|(SetOfStop0) ((1 << (mcReserved_lparatok-mcReserved_eoftok)) | (1 << (mcReserved_lcbratok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_nottok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_realtok-mcReserved_recordtok)) | (1 << (mcReserved_integertok-mcReserved_recordtok)) | (1 << (mcReserved_stringtok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok)) | (1 << (mcReserved_attributetok-mcReserved_recordtok))));
      ConstTerm (stopset0, stopset1, stopset2);
    }
  else if (mcLexBuf_currenttoken == mcReserved_minustok)
    {
      /* avoid dangling else.  */
      Expect ((mcReserved_toktype) mcReserved_minustok, stopset0|(SetOfStop0) ((1 << (mcReserved_lparatok-mcReserved_eoftok)) | (1 << (mcReserved_lcbratok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_nottok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_realtok-mcReserved_recordtok)) | (1 << (mcReserved_integertok-mcReserved_recordtok)) | (1 << (mcReserved_stringtok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok)) | (1 << (mcReserved_attributetok-mcReserved_recordtok))));
      ConstTerm (stopset0, stopset1, stopset2);
    }
  else if ((((mcLexBuf_currenttoken < mcReserved_arraytok) && ((((1 << (mcLexBuf_currenttoken-mcReserved_eoftok)) & ((SetOfStop0) ((1 << (mcReserved_lparatok-mcReserved_eoftok)) | (1 << (mcReserved_lcbratok-mcReserved_eoftok))))) != 0))) || (mcLexBuf_currenttoken == mcReserved_nottok)) || ((mcLexBuf_currenttoken >= mcReserved_recordtok) && ((((1 << (mcLexBuf_currenttoken-mcReserved_recordtok)) & ((SetOfStop2) ((1 << (mcReserved_integertok-mcReserved_recordtok)) | (1 << (mcReserved_realtok-mcReserved_recordtok)) | (1 << (mcReserved_attributetok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok)) | (1 << (mcReserved_stringtok-mcReserved_recordtok))))) != 0))))
    {
      /* avoid dangling else.  */
      ConstTerm (stopset0, stopset1, stopset2);
    }
  else
    {
      /* avoid dangling else.  */
      ErrorArray ((char *) "expecting one of: NOT ( integer number real number __ATTRIBUTE__ identifier { string - +", 88);
    }
}


/*
   AddOperator := '+'  | '-'  | 'OR' 

   first  symbols:ortok, minustok, plustok
   
   cannot reachend
*/

static void AddOperator (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  if (mcLexBuf_currenttoken == mcReserved_plustok)
    {
      Expect ((mcReserved_toktype) mcReserved_plustok, stopset0, stopset1, stopset2);
    }
  else if (mcLexBuf_currenttoken == mcReserved_minustok)
    {
      /* avoid dangling else.  */
      Expect ((mcReserved_toktype) mcReserved_minustok, stopset0, stopset1, stopset2);
    }
  else if (mcLexBuf_currenttoken == mcReserved_ortok)
    {
      /* avoid dangling else.  */
      Expect ((mcReserved_toktype) mcReserved_ortok, stopset0, stopset1, stopset2);
    }
  else
    {
      /* avoid dangling else.  */
      ErrorArray ((char *) "expecting one of: OR - +", 24);
    }
}


/*
   ConstTerm := ConstFactor { MulOperator ConstFactor  } 

   first  symbols:stringtok, lcbratok, identtok, attributetok, realtok, integertok, lparatok, nottok
   
   cannot reachend
*/

static void ConstTerm (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  ConstFactor (stopset0|(SetOfStop0) ((1 << (mcReserved_ambersandtok-mcReserved_eoftok)) | (1 << (mcReserved_andtok-mcReserved_eoftok)) | (1 << (mcReserved_dividetok-mcReserved_eoftok)) | (1 << (mcReserved_timestok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_modtok-mcReserved_arraytok)) | (1 << (mcReserved_divtok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_remtok-mcReserved_recordtok))));
  while ((((mcLexBuf_currenttoken < mcReserved_arraytok) && ((((1 << (mcLexBuf_currenttoken-mcReserved_eoftok)) & ((SetOfStop0) ((1 << (mcReserved_timestok-mcReserved_eoftok)) | (1 << (mcReserved_dividetok-mcReserved_eoftok)) | (1 << (mcReserved_andtok-mcReserved_eoftok)) | (1 << (mcReserved_ambersandtok-mcReserved_eoftok))))) != 0))) || (((mcLexBuf_currenttoken >= mcReserved_arraytok) && (mcLexBuf_currenttoken < mcReserved_recordtok)) && ((((1 << (mcLexBuf_currenttoken-mcReserved_arraytok)) & ((SetOfStop1) ((1 << (mcReserved_divtok-mcReserved_arraytok)) | (1 << (mcReserved_modtok-mcReserved_arraytok))))) != 0)))) || (mcLexBuf_currenttoken == mcReserved_remtok))
    {
      MulOperator (stopset0|(SetOfStop0) ((1 << (mcReserved_lparatok-mcReserved_eoftok)) | (1 << (mcReserved_lcbratok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_nottok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_integertok-mcReserved_recordtok)) | (1 << (mcReserved_realtok-mcReserved_recordtok)) | (1 << (mcReserved_attributetok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok)) | (1 << (mcReserved_stringtok-mcReserved_recordtok))));
      ConstFactor (stopset0|(SetOfStop0) ((1 << (mcReserved_timestok-mcReserved_eoftok)) | (1 << (mcReserved_dividetok-mcReserved_eoftok)) | (1 << (mcReserved_andtok-mcReserved_eoftok)) | (1 << (mcReserved_ambersandtok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_divtok-mcReserved_arraytok)) | (1 << (mcReserved_modtok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_remtok-mcReserved_recordtok))));
    }
   /* while  */
}


/*
   MulOperator := '*'  | '/'  | 'DIV'  | 'MOD'  | 'REM'  | 
                  'AND'  | '&' 

   first  symbols:ambersandtok, andtok, remtok, modtok, divtok, dividetok, timestok
   
   cannot reachend
*/

static void MulOperator (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  if (mcLexBuf_currenttoken == mcReserved_timestok)
    {
      Expect ((mcReserved_toktype) mcReserved_timestok, stopset0, stopset1, stopset2);
    }
  else if (mcLexBuf_currenttoken == mcReserved_dividetok)
    {
      /* avoid dangling else.  */
      Expect ((mcReserved_toktype) mcReserved_dividetok, stopset0, stopset1, stopset2);
    }
  else if (mcLexBuf_currenttoken == mcReserved_divtok)
    {
      /* avoid dangling else.  */
      Expect ((mcReserved_toktype) mcReserved_divtok, stopset0, stopset1, stopset2);
    }
  else if (mcLexBuf_currenttoken == mcReserved_modtok)
    {
      /* avoid dangling else.  */
      Expect ((mcReserved_toktype) mcReserved_modtok, stopset0, stopset1, stopset2);
    }
  else if (mcLexBuf_currenttoken == mcReserved_remtok)
    {
      /* avoid dangling else.  */
      Expect ((mcReserved_toktype) mcReserved_remtok, stopset0, stopset1, stopset2);
    }
  else if (mcLexBuf_currenttoken == mcReserved_andtok)
    {
      /* avoid dangling else.  */
      Expect ((mcReserved_toktype) mcReserved_andtok, stopset0, stopset1, stopset2);
    }
  else if (mcLexBuf_currenttoken == mcReserved_ambersandtok)
    {
      /* avoid dangling else.  */
      Expect ((mcReserved_toktype) mcReserved_ambersandtok, stopset0, stopset1, stopset2);
    }
  else
    {
      /* avoid dangling else.  */
      ErrorArray ((char *) "expecting one of: & AND REM MOD DIV / *", 39);
    }
}


/*
   NotConstFactor := 'NOT' ConstFactor 
                     % VAR n: node ;  %
                     
                     % n := push (makeUnaryTok (nottok, pop ()))  %
                     

   first  symbols:nottok
   
   cannot reachend
*/

static void NotConstFactor (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  decl_node n;

  Expect ((mcReserved_toktype) mcReserved_nottok, stopset0|(SetOfStop0) ((1 << (mcReserved_lparatok-mcReserved_eoftok)) | (1 << (mcReserved_lcbratok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_nottok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_integertok-mcReserved_recordtok)) | (1 << (mcReserved_realtok-mcReserved_recordtok)) | (1 << (mcReserved_attributetok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok)) | (1 << (mcReserved_stringtok-mcReserved_recordtok))));
  ConstFactor (stopset0, stopset1, stopset2);
  n = push (decl_makeUnaryTok ((mcReserved_toktype) mcReserved_nottok, pop ()));
}


/*
   ConstFactor := ConstNumber  | ConstString  | ConstSetOrQualidentOrFunction  | 
                  '(' ConstExpressionNop ')'  | 
                  NotConstFactor  | ConstAttribute 

   first  symbols:attributetok, identtok, lcbratok, stringtok, nottok, lparatok, integertok, realtok
   
   cannot reachend
*/

static void ConstFactor (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  if ((mcLexBuf_currenttoken >= mcReserved_recordtok) && ((((1 << (mcLexBuf_currenttoken-mcReserved_recordtok)) & ((SetOfStop2) ((1 << (mcReserved_integertok-mcReserved_recordtok)) | (1 << (mcReserved_realtok-mcReserved_recordtok))))) != 0)))
    {
      ConstNumber (stopset0, stopset1, stopset2);
    }
  else if (mcLexBuf_currenttoken == mcReserved_stringtok)
    {
      /* avoid dangling else.  */
      ConstString (stopset0, stopset1, stopset2);
    }
  else if ((mcLexBuf_currenttoken == mcReserved_lcbratok) || (mcLexBuf_currenttoken == mcReserved_identtok))
    {
      /* avoid dangling else.  */
      ConstSetOrQualidentOrFunction (stopset0, stopset1, stopset2);
    }
  else if (mcLexBuf_currenttoken == mcReserved_lparatok)
    {
      /* avoid dangling else.  */
      Expect ((mcReserved_toktype) mcReserved_lparatok, stopset0|(SetOfStop0) ((1 << (mcReserved_minustok-mcReserved_eoftok)) | (1 << (mcReserved_plustok-mcReserved_eoftok)) | (1 << (mcReserved_lparatok-mcReserved_eoftok)) | (1 << (mcReserved_lcbratok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_nottok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_integertok-mcReserved_recordtok)) | (1 << (mcReserved_realtok-mcReserved_recordtok)) | (1 << (mcReserved_attributetok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok)) | (1 << (mcReserved_stringtok-mcReserved_recordtok))));
      ConstExpressionNop (stopset0|(SetOfStop0) ((1 << (mcReserved_rparatok-mcReserved_eoftok))), stopset1, stopset2);
      Expect ((mcReserved_toktype) mcReserved_rparatok, stopset0, stopset1, stopset2);
    }
  else if (mcLexBuf_currenttoken == mcReserved_nottok)
    {
      /* avoid dangling else.  */
      NotConstFactor (stopset0, stopset1, stopset2);
    }
  else if (mcLexBuf_currenttoken == mcReserved_attributetok)
    {
      /* avoid dangling else.  */
      ConstAttribute (stopset0, stopset1, stopset2);
    }
  else
    {
      /* avoid dangling else.  */
      ErrorArray ((char *) "expecting one of: __ATTRIBUTE__ NOT ( identifier { string integer number real number", 84);
    }
}


/*
   ConstString := string 

   first  symbols:stringtok
   
   cannot reachend
*/

static void ConstString (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  string (stopset0, stopset1, stopset2);
}


/*
   ConstComponentElement := ConstExpressionNop [ '..' ConstExpressionNop  ] 

   first  symbols:stringtok, lcbratok, identtok, attributetok, realtok, integertok, lparatok, nottok, plustok, minustok
   
   cannot reachend
*/

static void ConstComponentElement (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  ConstExpressionNop (stopset0|(SetOfStop0) ((1 << (mcReserved_periodperiodtok-mcReserved_eoftok))), stopset1, stopset2);
  if (mcLexBuf_currenttoken == mcReserved_periodperiodtok)
    {
      Expect ((mcReserved_toktype) mcReserved_periodperiodtok, stopset0|(SetOfStop0) ((1 << (mcReserved_minustok-mcReserved_eoftok)) | (1 << (mcReserved_plustok-mcReserved_eoftok)) | (1 << (mcReserved_lparatok-mcReserved_eoftok)) | (1 << (mcReserved_lcbratok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_nottok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_integertok-mcReserved_recordtok)) | (1 << (mcReserved_realtok-mcReserved_recordtok)) | (1 << (mcReserved_attributetok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok)) | (1 << (mcReserved_stringtok-mcReserved_recordtok))));
      ConstExpressionNop (stopset0, stopset1, stopset2);
    }
}


/*
   ConstComponentValue := ConstComponentElement [ 'BY' ConstExpressionNop  ] 

   first  symbols:attributetok, identtok, lcbratok, stringtok, nottok, lparatok, integertok, realtok, minustok, plustok
   
   cannot reachend
*/

static void ConstComponentValue (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  ConstComponentElement (stopset0, stopset1|(SetOfStop1) ((1 << (mcReserved_bytok-mcReserved_arraytok))), stopset2);
  if (mcLexBuf_currenttoken == mcReserved_bytok)
    {
      Expect ((mcReserved_toktype) mcReserved_bytok, stopset0|(SetOfStop0) ((1 << (mcReserved_minustok-mcReserved_eoftok)) | (1 << (mcReserved_plustok-mcReserved_eoftok)) | (1 << (mcReserved_lparatok-mcReserved_eoftok)) | (1 << (mcReserved_lcbratok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_nottok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_integertok-mcReserved_recordtok)) | (1 << (mcReserved_realtok-mcReserved_recordtok)) | (1 << (mcReserved_attributetok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok)) | (1 << (mcReserved_stringtok-mcReserved_recordtok))));
      ConstExpressionNop (stopset0, stopset1, stopset2);
    }
}


/*
   ConstArraySetRecordValue := ConstComponentValue { ',' ConstComponentValue  } 

   first  symbols:stringtok, lcbratok, identtok, attributetok, realtok, integertok, lparatok, nottok, plustok, minustok
   
   cannot reachend
*/

static void ConstArraySetRecordValue (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  ConstComponentValue (stopset0|(SetOfStop0) ((1 << (mcReserved_commatok-mcReserved_eoftok))), stopset1, stopset2);
  while (mcLexBuf_currenttoken == mcReserved_commatok)
    {
      Expect ((mcReserved_toktype) mcReserved_commatok, stopset0|(SetOfStop0) ((1 << (mcReserved_minustok-mcReserved_eoftok)) | (1 << (mcReserved_plustok-mcReserved_eoftok)) | (1 << (mcReserved_lparatok-mcReserved_eoftok)) | (1 << (mcReserved_lcbratok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_nottok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_integertok-mcReserved_recordtok)) | (1 << (mcReserved_realtok-mcReserved_recordtok)) | (1 << (mcReserved_attributetok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok)) | (1 << (mcReserved_stringtok-mcReserved_recordtok))));
      ConstComponentValue (stopset0|(SetOfStop0) ((1 << (mcReserved_commatok-mcReserved_eoftok))), stopset1, stopset2);
    }
   /* while  */
}


/*
   ConstConstructor := '{' [ ConstArraySetRecordValue  ] '}' 

   first  symbols:lcbratok
   
   cannot reachend
*/

static void ConstConstructor (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  Expect ((mcReserved_toktype) mcReserved_lcbratok, stopset0|(SetOfStop0) ((1 << (mcReserved_rcbratok-mcReserved_eoftok)) | (1 << (mcReserved_plustok-mcReserved_eoftok)) | (1 << (mcReserved_minustok-mcReserved_eoftok)) | (1 << (mcReserved_lparatok-mcReserved_eoftok)) | (1 << (mcReserved_lcbratok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_nottok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_realtok-mcReserved_recordtok)) | (1 << (mcReserved_integertok-mcReserved_recordtok)) | (1 << (mcReserved_stringtok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok)) | (1 << (mcReserved_attributetok-mcReserved_recordtok))));
  if ((((mcLexBuf_currenttoken < mcReserved_arraytok) && ((((1 << (mcLexBuf_currenttoken-mcReserved_eoftok)) & ((SetOfStop0) ((1 << (mcReserved_minustok-mcReserved_eoftok)) | (1 << (mcReserved_plustok-mcReserved_eoftok)) | (1 << (mcReserved_lparatok-mcReserved_eoftok)) | (1 << (mcReserved_lcbratok-mcReserved_eoftok))))) != 0))) || (mcLexBuf_currenttoken == mcReserved_nottok)) || ((mcLexBuf_currenttoken >= mcReserved_recordtok) && ((((1 << (mcLexBuf_currenttoken-mcReserved_recordtok)) & ((SetOfStop2) ((1 << (mcReserved_integertok-mcReserved_recordtok)) | (1 << (mcReserved_realtok-mcReserved_recordtok)) | (1 << (mcReserved_attributetok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok)) | (1 << (mcReserved_stringtok-mcReserved_recordtok))))) != 0))))
    {
      ConstArraySetRecordValue (stopset0|(SetOfStop0) ((1 << (mcReserved_rcbratok-mcReserved_eoftok))), stopset1, stopset2);
    }
  Expect ((mcReserved_toktype) mcReserved_rcbratok, stopset0, stopset1, stopset2);
}


/*
   ConstSetOrQualidentOrFunction := Qualident [ ConstConstructor  | 
                                                ConstActualParameters  ]  | 
                                    ConstConstructor 

   first  symbols:lcbratok, identtok
   
   cannot reachend
*/

static void ConstSetOrQualidentOrFunction (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  if (mcLexBuf_currenttoken == mcReserved_identtok)
    {
      /* avoid dangling else.  */
      Qualident (stopset0|(SetOfStop0) ((1 << (mcReserved_lcbratok-mcReserved_eoftok)) | (1 << (mcReserved_lparatok-mcReserved_eoftok))), stopset1, stopset2);
      if ((mcLexBuf_currenttoken < mcReserved_arraytok) && ((((1 << (mcLexBuf_currenttoken-mcReserved_eoftok)) & ((SetOfStop0) ((1 << (mcReserved_lparatok-mcReserved_eoftok)) | (1 << (mcReserved_lcbratok-mcReserved_eoftok))))) != 0)))
        {
          /* avoid gcc warning by using compound statement even if not strictly necessary.  */
          /* seen optional [ | ] expression  */
          if (mcLexBuf_currenttoken == mcReserved_lcbratok)
            {
              ConstConstructor (stopset0, stopset1, stopset2);
            }
          else if (mcLexBuf_currenttoken == mcReserved_lparatok)
            {
              /* avoid dangling else.  */
              ConstActualParameters (stopset0, stopset1, stopset2);
            }
          else
            {
              /* avoid dangling else.  */
              ErrorArray ((char *) "expecting one of: ( {", 21);
            }
        }
      /* end of optional [ | ] expression  */
    }
  else if (mcLexBuf_currenttoken == mcReserved_lcbratok)
    {
      /* avoid dangling else.  */
      ConstConstructor (stopset0, stopset1, stopset2);
    }
  else
    {
      /* avoid dangling else.  */
      ErrorArray ((char *) "expecting one of: { identifier", 30);
    }
}


/*
   ConstActualParameters := '(' [ ConstExpList  ] ')' 

   first  symbols:lparatok
   
   cannot reachend
*/

static void ConstActualParameters (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  Expect ((mcReserved_toktype) mcReserved_lparatok, stopset0|(SetOfStop0) ((1 << (mcReserved_rparatok-mcReserved_eoftok)) | (1 << (mcReserved_plustok-mcReserved_eoftok)) | (1 << (mcReserved_minustok-mcReserved_eoftok)) | (1 << (mcReserved_lparatok-mcReserved_eoftok)) | (1 << (mcReserved_lcbratok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_nottok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_realtok-mcReserved_recordtok)) | (1 << (mcReserved_integertok-mcReserved_recordtok)) | (1 << (mcReserved_stringtok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok)) | (1 << (mcReserved_attributetok-mcReserved_recordtok))));
  if ((((mcLexBuf_currenttoken < mcReserved_arraytok) && ((((1 << (mcLexBuf_currenttoken-mcReserved_eoftok)) & ((SetOfStop0) ((1 << (mcReserved_minustok-mcReserved_eoftok)) | (1 << (mcReserved_plustok-mcReserved_eoftok)) | (1 << (mcReserved_lparatok-mcReserved_eoftok)) | (1 << (mcReserved_lcbratok-mcReserved_eoftok))))) != 0))) || (mcLexBuf_currenttoken == mcReserved_nottok)) || ((mcLexBuf_currenttoken >= mcReserved_recordtok) && ((((1 << (mcLexBuf_currenttoken-mcReserved_recordtok)) & ((SetOfStop2) ((1 << (mcReserved_integertok-mcReserved_recordtok)) | (1 << (mcReserved_realtok-mcReserved_recordtok)) | (1 << (mcReserved_attributetok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok)) | (1 << (mcReserved_stringtok-mcReserved_recordtok))))) != 0))))
    {
      ConstExpList (stopset0|(SetOfStop0) ((1 << (mcReserved_rparatok-mcReserved_eoftok))), stopset1, stopset2);
    }
  Expect ((mcReserved_toktype) mcReserved_rparatok, stopset0, stopset1, stopset2);
}


/*
   ConstExpList := ConstExpressionNop { ',' ConstExpressionNop  } 

   first  symbols:stringtok, lcbratok, identtok, attributetok, realtok, integertok, lparatok, nottok, plustok, minustok
   
   cannot reachend
*/

static void ConstExpList (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  ConstExpressionNop (stopset0|(SetOfStop0) ((1 << (mcReserved_commatok-mcReserved_eoftok))), stopset1, stopset2);
  while (mcLexBuf_currenttoken == mcReserved_commatok)
    {
      Expect ((mcReserved_toktype) mcReserved_commatok, stopset0|(SetOfStop0) ((1 << (mcReserved_minustok-mcReserved_eoftok)) | (1 << (mcReserved_plustok-mcReserved_eoftok)) | (1 << (mcReserved_lparatok-mcReserved_eoftok)) | (1 << (mcReserved_lcbratok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_nottok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_integertok-mcReserved_recordtok)) | (1 << (mcReserved_realtok-mcReserved_recordtok)) | (1 << (mcReserved_attributetok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok)) | (1 << (mcReserved_stringtok-mcReserved_recordtok))));
      ConstExpressionNop (stopset0|(SetOfStop0) ((1 << (mcReserved_commatok-mcReserved_eoftok))), stopset1, stopset2);
    }
   /* while  */
}


/*
   ConstAttribute := '__ATTRIBUTE__' '__BUILTIN__' '(' '(' ConstAttributeExpression 
                     ')' ')' 

   first  symbols:attributetok
   
   cannot reachend
*/

static void ConstAttribute (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  Expect ((mcReserved_toktype) mcReserved_attributetok, stopset0, stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_builtintok-mcReserved_recordtok))));
  Expect ((mcReserved_toktype) mcReserved_builtintok, stopset0|(SetOfStop0) ((1 << (mcReserved_lparatok-mcReserved_eoftok))), stopset1, stopset2);
  Expect ((mcReserved_toktype) mcReserved_lparatok, stopset0|(SetOfStop0) ((1 << (mcReserved_lparatok-mcReserved_eoftok))), stopset1, stopset2);
  Expect ((mcReserved_toktype) mcReserved_lparatok, stopset0|(SetOfStop0) ((1 << (mcReserved_lesstok-mcReserved_eoftok))), stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_identtok-mcReserved_recordtok))));
  ConstAttributeExpression (stopset0|(SetOfStop0) ((1 << (mcReserved_rparatok-mcReserved_eoftok))), stopset1, stopset2);
  Expect ((mcReserved_toktype) mcReserved_rparatok, stopset0|(SetOfStop0) ((1 << (mcReserved_rparatok-mcReserved_eoftok))), stopset1, stopset2);
  Expect ((mcReserved_toktype) mcReserved_rparatok, stopset0, stopset1, stopset2);
}


/*
   ConstAttributeExpression := Ident  | '<' Qualident ',' Ident 
                               '>' 

   first  symbols:lesstok, identtok
   
   cannot reachend
*/

static void ConstAttributeExpression (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  if (mcLexBuf_currenttoken == mcReserved_identtok)
    {
      Ident (stopset0, stopset1, stopset2);
    }
  else if (mcLexBuf_currenttoken == mcReserved_lesstok)
    {
      /* avoid dangling else.  */
      Expect ((mcReserved_toktype) mcReserved_lesstok, stopset0, stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_identtok-mcReserved_recordtok))));
      Qualident (stopset0|(SetOfStop0) ((1 << (mcReserved_commatok-mcReserved_eoftok))), stopset1, stopset2);
      Expect ((mcReserved_toktype) mcReserved_commatok, stopset0, stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_identtok-mcReserved_recordtok))));
      Ident (stopset0|(SetOfStop0) ((1 << (mcReserved_greatertok-mcReserved_eoftok))), stopset1, stopset2);
      Expect ((mcReserved_toktype) mcReserved_greatertok, stopset0, stopset1, stopset2);
    }
  else
    {
      /* avoid dangling else.  */
      ErrorArray ((char *) "expecting one of: < identifier", 30);
    }
}


/*
   ByteAlignment := '' 

   first  symbols:ldirectivetok
   
   cannot reachend
*/

static void ByteAlignment (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  Expect ((mcReserved_toktype) mcReserved_ldirectivetok, stopset0, stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_identtok-mcReserved_recordtok))));
  AttributeExpression (stopset0|(SetOfStop0) ((1 << (mcReserved_rdirectivetok-mcReserved_eoftok))), stopset1, stopset2);
  Expect ((mcReserved_toktype) mcReserved_rdirectivetok, stopset0, stopset1, stopset2);
}


/*
   OptAlignmentExpression := [ AlignmentExpression  ] 

   first  symbols:lparatok
   
   reachend
*/

static void OptAlignmentExpression (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  if (mcLexBuf_currenttoken == mcReserved_lparatok)
    {
      AlignmentExpression (stopset0, stopset1, stopset2);
    }
}


/*
   AlignmentExpression := '(' ConstExpressionNop ')' 

   first  symbols:lparatok
   
   cannot reachend
*/

static void AlignmentExpression (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  Expect ((mcReserved_toktype) mcReserved_lparatok, stopset0|(SetOfStop0) ((1 << (mcReserved_minustok-mcReserved_eoftok)) | (1 << (mcReserved_plustok-mcReserved_eoftok)) | (1 << (mcReserved_lparatok-mcReserved_eoftok)) | (1 << (mcReserved_lcbratok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_nottok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_integertok-mcReserved_recordtok)) | (1 << (mcReserved_realtok-mcReserved_recordtok)) | (1 << (mcReserved_attributetok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok)) | (1 << (mcReserved_stringtok-mcReserved_recordtok))));
  ConstExpressionNop (stopset0|(SetOfStop0) ((1 << (mcReserved_rparatok-mcReserved_eoftok))), stopset1, stopset2);
  Expect ((mcReserved_toktype) mcReserved_rparatok, stopset0, stopset1, stopset2);
}


/*
   Alignment := [ ByteAlignment  ] 

   first  symbols:ldirectivetok
   
   reachend
*/

static void Alignment (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  if (mcLexBuf_currenttoken == mcReserved_ldirectivetok)
    {
      ByteAlignment (stopset0, stopset1, stopset2);
    }
}


/*
   IdentList := Ident { ',' Ident  } 

   first  symbols:identtok
   
   cannot reachend
*/

static void IdentList (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  Ident (stopset0|(SetOfStop0) ((1 << (mcReserved_commatok-mcReserved_eoftok))), stopset1, stopset2);
  while (mcLexBuf_currenttoken == mcReserved_commatok)
    {
      Expect ((mcReserved_toktype) mcReserved_commatok, stopset0, stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_identtok-mcReserved_recordtok))));
      Ident (stopset0|(SetOfStop0) ((1 << (mcReserved_commatok-mcReserved_eoftok))), stopset1, stopset2);
    }
   /* while  */
}


/*
   SubrangeType := '[' ConstExpressionNop '..' ConstExpressionNop 
                   ']' 

   first  symbols:lsbratok
   
   cannot reachend
*/

static void SubrangeType (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  Expect ((mcReserved_toktype) mcReserved_lsbratok, stopset0|(SetOfStop0) ((1 << (mcReserved_minustok-mcReserved_eoftok)) | (1 << (mcReserved_plustok-mcReserved_eoftok)) | (1 << (mcReserved_lparatok-mcReserved_eoftok)) | (1 << (mcReserved_lcbratok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_nottok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_integertok-mcReserved_recordtok)) | (1 << (mcReserved_realtok-mcReserved_recordtok)) | (1 << (mcReserved_attributetok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok)) | (1 << (mcReserved_stringtok-mcReserved_recordtok))));
  ConstExpressionNop (stopset0|(SetOfStop0) ((1 << (mcReserved_periodperiodtok-mcReserved_eoftok))), stopset1, stopset2);
  Expect ((mcReserved_toktype) mcReserved_periodperiodtok, stopset0|(SetOfStop0) ((1 << (mcReserved_minustok-mcReserved_eoftok)) | (1 << (mcReserved_plustok-mcReserved_eoftok)) | (1 << (mcReserved_lparatok-mcReserved_eoftok)) | (1 << (mcReserved_lcbratok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_nottok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_integertok-mcReserved_recordtok)) | (1 << (mcReserved_realtok-mcReserved_recordtok)) | (1 << (mcReserved_attributetok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok)) | (1 << (mcReserved_stringtok-mcReserved_recordtok))));
  ConstExpressionNop (stopset0|(SetOfStop0) ((1 << (mcReserved_rsbratok-mcReserved_eoftok))), stopset1, stopset2);
  Expect ((mcReserved_toktype) mcReserved_rsbratok, stopset0, stopset1, stopset2);
}


/*
   ArrayType := 'ARRAY' SimpleType { ',' SimpleType  } 'OF' Type 

   first  symbols:arraytok
   
   cannot reachend
*/

static void ArrayType (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  Expect ((mcReserved_toktype) mcReserved_arraytok, stopset0|(SetOfStop0) ((1 << (mcReserved_lsbratok-mcReserved_eoftok)) | (1 << (mcReserved_lparatok-mcReserved_eoftok))), stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_identtok-mcReserved_recordtok))));
  SimpleType (stopset0|(SetOfStop0) ((1 << (mcReserved_commatok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_oftok-mcReserved_arraytok))), stopset2);
  while (mcLexBuf_currenttoken == mcReserved_commatok)
    {
      Expect ((mcReserved_toktype) mcReserved_commatok, stopset0|(SetOfStop0) ((1 << (mcReserved_lsbratok-mcReserved_eoftok)) | (1 << (mcReserved_lparatok-mcReserved_eoftok))), stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_identtok-mcReserved_recordtok))));
      SimpleType (stopset0|(SetOfStop0) ((1 << (mcReserved_commatok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_oftok-mcReserved_arraytok))), stopset2);
    }
   /* while  */
  Expect ((mcReserved_toktype) mcReserved_oftok, stopset0|(SetOfStop0) ((1 << (mcReserved_lparatok-mcReserved_eoftok)) | (1 << (mcReserved_lsbratok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_proceduretok-mcReserved_arraytok)) | (1 << (mcReserved_pointertok-mcReserved_arraytok)) | (1 << (mcReserved_packedsettok-mcReserved_arraytok)) | (1 << (mcReserved_oftok-mcReserved_arraytok)) | (1 << (mcReserved_arraytok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_settok-mcReserved_recordtok)) | (1 << (mcReserved_recordtok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok))));
  Type (stopset0, stopset1, stopset2);
}


/*
   RecordType := 'RECORD' [ DefaultRecordAttributes  ] FieldListSequence 
                 'END' 

   first  symbols:recordtok
   
   cannot reachend
*/

static void RecordType (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  Expect ((mcReserved_toktype) mcReserved_recordtok, stopset0|(SetOfStop0) ((1 << (mcReserved_ldirectivetok-mcReserved_eoftok)) | (1 << (mcReserved_semicolontok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_endtok-mcReserved_arraytok)) | (1 << (mcReserved_casetok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_identtok-mcReserved_recordtok))));
  if (mcLexBuf_currenttoken == mcReserved_ldirectivetok)
    {
      DefaultRecordAttributes (stopset0|(SetOfStop0) ((1 << (mcReserved_semicolontok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_endtok-mcReserved_arraytok)) | (1 << (mcReserved_casetok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_identtok-mcReserved_recordtok))));
    }
  FieldListSequence (stopset0, stopset1|(SetOfStop1) ((1 << (mcReserved_endtok-mcReserved_arraytok))), stopset2);
  Expect ((mcReserved_toktype) mcReserved_endtok, stopset0, stopset1, stopset2);
}


/*
   DefaultRecordAttributes := '' 

   first  symbols:ldirectivetok
   
   cannot reachend
*/

static void DefaultRecordAttributes (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  Expect ((mcReserved_toktype) mcReserved_ldirectivetok, stopset0, stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_identtok-mcReserved_recordtok))));
  AttributeExpression (stopset0|(SetOfStop0) ((1 << (mcReserved_rdirectivetok-mcReserved_eoftok))), stopset1, stopset2);
  Expect ((mcReserved_toktype) mcReserved_rdirectivetok, stopset0, stopset1, stopset2);
}


/*
   RecordFieldPragma := [ ''  ] 

   first  symbols:ldirectivetok
   
   reachend
*/

static void RecordFieldPragma (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  if (mcLexBuf_currenttoken == mcReserved_ldirectivetok)
    {
      Expect ((mcReserved_toktype) mcReserved_ldirectivetok, stopset0, stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_identtok-mcReserved_recordtok))));
      FieldPragmaExpression (stopset0|(SetOfStop0) ((1 << (mcReserved_commatok-mcReserved_eoftok)) | (1 << (mcReserved_rdirectivetok-mcReserved_eoftok))), stopset1, stopset2);
      while (mcLexBuf_currenttoken == mcReserved_commatok)
        {
          Expect ((mcReserved_toktype) mcReserved_commatok, stopset0, stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_identtok-mcReserved_recordtok))));
          FieldPragmaExpression (stopset0|(SetOfStop0) ((1 << (mcReserved_rdirectivetok-mcReserved_eoftok)) | (1 << (mcReserved_commatok-mcReserved_eoftok))), stopset1, stopset2);
        }
       /* while  */
      Expect ((mcReserved_toktype) mcReserved_rdirectivetok, stopset0, stopset1, stopset2);
    }
}


/*
   FieldPragmaExpression := Ident PragmaConstExpression 

   first  symbols:identtok
   
   cannot reachend
*/

static void FieldPragmaExpression (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  Ident (stopset0|(SetOfStop0) ((1 << (mcReserved_lparatok-mcReserved_eoftok))), stopset1, stopset2);
  PragmaConstExpression (stopset0, stopset1, stopset2);
}


/*
   PragmaConstExpression := [ '(' ConstExpressionNop ')'  ] 

   first  symbols:lparatok
   
   reachend
*/

static void PragmaConstExpression (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  if (mcLexBuf_currenttoken == mcReserved_lparatok)
    {
      Expect ((mcReserved_toktype) mcReserved_lparatok, stopset0|(SetOfStop0) ((1 << (mcReserved_minustok-mcReserved_eoftok)) | (1 << (mcReserved_plustok-mcReserved_eoftok)) | (1 << (mcReserved_lparatok-mcReserved_eoftok)) | (1 << (mcReserved_lcbratok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_nottok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_integertok-mcReserved_recordtok)) | (1 << (mcReserved_realtok-mcReserved_recordtok)) | (1 << (mcReserved_attributetok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok)) | (1 << (mcReserved_stringtok-mcReserved_recordtok))));
      ConstExpressionNop (stopset0|(SetOfStop0) ((1 << (mcReserved_rparatok-mcReserved_eoftok))), stopset1, stopset2);
      Expect ((mcReserved_toktype) mcReserved_rparatok, stopset0, stopset1, stopset2);
    }
}


/*
   AttributeExpression := Ident '(' ConstExpressionNop ')' 

   first  symbols:identtok
   
   cannot reachend
*/

static void AttributeExpression (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  Ident (stopset0|(SetOfStop0) ((1 << (mcReserved_lparatok-mcReserved_eoftok))), stopset1, stopset2);
  Expect ((mcReserved_toktype) mcReserved_lparatok, stopset0|(SetOfStop0) ((1 << (mcReserved_minustok-mcReserved_eoftok)) | (1 << (mcReserved_plustok-mcReserved_eoftok)) | (1 << (mcReserved_lparatok-mcReserved_eoftok)) | (1 << (mcReserved_lcbratok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_nottok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_integertok-mcReserved_recordtok)) | (1 << (mcReserved_realtok-mcReserved_recordtok)) | (1 << (mcReserved_attributetok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok)) | (1 << (mcReserved_stringtok-mcReserved_recordtok))));
  ConstExpressionNop (stopset0|(SetOfStop0) ((1 << (mcReserved_rparatok-mcReserved_eoftok))), stopset1, stopset2);
  Expect ((mcReserved_toktype) mcReserved_rparatok, stopset0, stopset1, stopset2);
}


/*
   FieldListSequence := FieldListStatement { ';' FieldListStatement  } 

   first  symbols:casetok, identtok, semicolontok
   
   reachend
*/

static void FieldListSequence (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  FieldListStatement (stopset0|(SetOfStop0) ((1 << (mcReserved_semicolontok-mcReserved_eoftok))), stopset1, stopset2);
  while (mcLexBuf_currenttoken == mcReserved_semicolontok)
    {
      Expect ((mcReserved_toktype) mcReserved_semicolontok, stopset0|(SetOfStop0) ((1 << (mcReserved_semicolontok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_casetok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_identtok-mcReserved_recordtok))));
      FieldListStatement (stopset0|(SetOfStop0) ((1 << (mcReserved_semicolontok-mcReserved_eoftok))), stopset1, stopset2);
    }
   /* while  */
}


/*
   FieldListStatement := [ FieldList  ] 

   first  symbols:identtok, casetok
   
   reachend
*/

static void FieldListStatement (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  if ((mcLexBuf_currenttoken == mcReserved_casetok) || (mcLexBuf_currenttoken == mcReserved_identtok))
    {
      FieldList (stopset0, stopset1, stopset2);
    }
}


/*
   FieldList := IdentList ':' Type RecordFieldPragma  | 
                'CASE' CaseTag 'OF' Varient { '|' Varient  } 
                [ 'ELSE' FieldListSequence  ] 'END' 

   first  symbols:casetok, identtok
   
   cannot reachend
*/

static void FieldList (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  if (mcLexBuf_currenttoken == mcReserved_identtok)
    {
      IdentList (stopset0|(SetOfStop0) ((1 << (mcReserved_colontok-mcReserved_eoftok))), stopset1, stopset2);
      Expect ((mcReserved_toktype) mcReserved_colontok, stopset0|(SetOfStop0) ((1 << (mcReserved_lparatok-mcReserved_eoftok)) | (1 << (mcReserved_lsbratok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_proceduretok-mcReserved_arraytok)) | (1 << (mcReserved_pointertok-mcReserved_arraytok)) | (1 << (mcReserved_packedsettok-mcReserved_arraytok)) | (1 << (mcReserved_oftok-mcReserved_arraytok)) | (1 << (mcReserved_arraytok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_settok-mcReserved_recordtok)) | (1 << (mcReserved_recordtok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok))));
      Type (stopset0|(SetOfStop0) ((1 << (mcReserved_ldirectivetok-mcReserved_eoftok))), stopset1, stopset2);
      RecordFieldPragma (stopset0, stopset1, stopset2);
    }
  else if (mcLexBuf_currenttoken == mcReserved_casetok)
    {
      /* avoid dangling else.  */
      Expect ((mcReserved_toktype) mcReserved_casetok, stopset0|(SetOfStop0) ((1 << (mcReserved_colontok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_oftok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_identtok-mcReserved_recordtok))));
      CaseTag (stopset0, stopset1|(SetOfStop1) ((1 << (mcReserved_oftok-mcReserved_arraytok))), stopset2);
      Expect ((mcReserved_toktype) mcReserved_oftok, stopset0|(SetOfStop0) ((1 << (mcReserved_bartok-mcReserved_eoftok)) | (1 << (mcReserved_plustok-mcReserved_eoftok)) | (1 << (mcReserved_minustok-mcReserved_eoftok)) | (1 << (mcReserved_lparatok-mcReserved_eoftok)) | (1 << (mcReserved_lcbratok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_elsetok-mcReserved_arraytok)) | (1 << (mcReserved_endtok-mcReserved_arraytok)) | (1 << (mcReserved_nottok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_realtok-mcReserved_recordtok)) | (1 << (mcReserved_integertok-mcReserved_recordtok)) | (1 << (mcReserved_stringtok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok)) | (1 << (mcReserved_attributetok-mcReserved_recordtok))));
      Varient (stopset0|(SetOfStop0) ((1 << (mcReserved_bartok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_elsetok-mcReserved_arraytok)) | (1 << (mcReserved_endtok-mcReserved_arraytok))), stopset2);
      while (mcLexBuf_currenttoken == mcReserved_bartok)
        {
          Expect ((mcReserved_toktype) mcReserved_bartok, stopset0|(SetOfStop0) ((1 << (mcReserved_bartok-mcReserved_eoftok)) | (1 << (mcReserved_plustok-mcReserved_eoftok)) | (1 << (mcReserved_minustok-mcReserved_eoftok)) | (1 << (mcReserved_lparatok-mcReserved_eoftok)) | (1 << (mcReserved_lcbratok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_endtok-mcReserved_arraytok)) | (1 << (mcReserved_elsetok-mcReserved_arraytok)) | (1 << (mcReserved_nottok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_realtok-mcReserved_recordtok)) | (1 << (mcReserved_integertok-mcReserved_recordtok)) | (1 << (mcReserved_stringtok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok)) | (1 << (mcReserved_attributetok-mcReserved_recordtok))));
          Varient (stopset0|(SetOfStop0) ((1 << (mcReserved_bartok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_endtok-mcReserved_arraytok)) | (1 << (mcReserved_elsetok-mcReserved_arraytok))), stopset2);
        }
       /* while  */
      if (mcLexBuf_currenttoken == mcReserved_elsetok)
        {
          Expect ((mcReserved_toktype) mcReserved_elsetok, stopset0|(SetOfStop0) ((1 << (mcReserved_semicolontok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_endtok-mcReserved_arraytok)) | (1 << (mcReserved_casetok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_identtok-mcReserved_recordtok))));
          FieldListSequence (stopset0, stopset1|(SetOfStop1) ((1 << (mcReserved_endtok-mcReserved_arraytok))), stopset2);
        }
      Expect ((mcReserved_toktype) mcReserved_endtok, stopset0, stopset1, stopset2);
    }
  else
    {
      /* avoid dangling else.  */
      ErrorArray ((char *) "expecting one of: CASE identifier", 33);
    }
}


/*
   TagIdent := Ident  | 
               % curident := NulName  %
               

   first  symbols:identtok
   
   reachend
*/

static void TagIdent (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  if (mcLexBuf_currenttoken == mcReserved_identtok)
    {
      Ident (stopset0, stopset1, stopset2);
    }
  else
    {
      curident = nameKey_NulName;
    }
}


/*
   CaseTag := TagIdent [ ':' Qualident  ] 

   first  symbols:colontok, identtok
   
   reachend
*/

static void CaseTag (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  TagIdent (stopset0|(SetOfStop0) ((1 << (mcReserved_colontok-mcReserved_eoftok))), stopset1, stopset2);
  if (mcLexBuf_currenttoken == mcReserved_colontok)
    {
      Expect ((mcReserved_toktype) mcReserved_colontok, stopset0, stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_identtok-mcReserved_recordtok))));
      Qualident (stopset0, stopset1, stopset2);
    }
}


/*
   Varient := [ VarientCaseLabelList ':' FieldListSequence  ] 

   first  symbols:stringtok, lcbratok, identtok, attributetok, realtok, integertok, lparatok, nottok, plustok, minustok
   
   reachend
*/

static void Varient (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  if ((((mcLexBuf_currenttoken < mcReserved_arraytok) && ((((1 << (mcLexBuf_currenttoken-mcReserved_eoftok)) & ((SetOfStop0) ((1 << (mcReserved_plustok-mcReserved_eoftok)) | (1 << (mcReserved_minustok-mcReserved_eoftok)) | (1 << (mcReserved_lparatok-mcReserved_eoftok)) | (1 << (mcReserved_lcbratok-mcReserved_eoftok))))) != 0))) || (mcLexBuf_currenttoken == mcReserved_nottok)) || ((mcLexBuf_currenttoken >= mcReserved_recordtok) && ((((1 << (mcLexBuf_currenttoken-mcReserved_recordtok)) & ((SetOfStop2) ((1 << (mcReserved_realtok-mcReserved_recordtok)) | (1 << (mcReserved_integertok-mcReserved_recordtok)) | (1 << (mcReserved_stringtok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok)) | (1 << (mcReserved_attributetok-mcReserved_recordtok))))) != 0))))
    {
      VarientCaseLabelList (stopset0|(SetOfStop0) ((1 << (mcReserved_colontok-mcReserved_eoftok))), stopset1, stopset2);
      Expect ((mcReserved_toktype) mcReserved_colontok, stopset0|(SetOfStop0) ((1 << (mcReserved_semicolontok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_casetok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_identtok-mcReserved_recordtok))));
      FieldListSequence (stopset0, stopset1, stopset2);
    }
}


/*
   VarientCaseLabelList := VarientCaseLabels { ',' VarientCaseLabels  } 

   first  symbols:attributetok, identtok, lcbratok, stringtok, nottok, lparatok, integertok, realtok, minustok, plustok
   
   cannot reachend
*/

static void VarientCaseLabelList (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  VarientCaseLabels (stopset0|(SetOfStop0) ((1 << (mcReserved_commatok-mcReserved_eoftok))), stopset1, stopset2);
  while (mcLexBuf_currenttoken == mcReserved_commatok)
    {
      Expect ((mcReserved_toktype) mcReserved_commatok, stopset0|(SetOfStop0) ((1 << (mcReserved_plustok-mcReserved_eoftok)) | (1 << (mcReserved_minustok-mcReserved_eoftok)) | (1 << (mcReserved_lparatok-mcReserved_eoftok)) | (1 << (mcReserved_lcbratok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_nottok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_realtok-mcReserved_recordtok)) | (1 << (mcReserved_integertok-mcReserved_recordtok)) | (1 << (mcReserved_stringtok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok)) | (1 << (mcReserved_attributetok-mcReserved_recordtok))));
      VarientCaseLabels (stopset0|(SetOfStop0) ((1 << (mcReserved_commatok-mcReserved_eoftok))), stopset1, stopset2);
    }
   /* while  */
}


/*
   VarientCaseLabels := ConstExpressionNop [ '..' ConstExpressionNop  ] 

   first  symbols:stringtok, lcbratok, identtok, attributetok, realtok, integertok, lparatok, nottok, plustok, minustok
   
   cannot reachend
*/

static void VarientCaseLabels (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  ConstExpressionNop (stopset0|(SetOfStop0) ((1 << (mcReserved_periodperiodtok-mcReserved_eoftok))), stopset1, stopset2);
  if (mcLexBuf_currenttoken == mcReserved_periodperiodtok)
    {
      Expect ((mcReserved_toktype) mcReserved_periodperiodtok, stopset0|(SetOfStop0) ((1 << (mcReserved_minustok-mcReserved_eoftok)) | (1 << (mcReserved_plustok-mcReserved_eoftok)) | (1 << (mcReserved_lparatok-mcReserved_eoftok)) | (1 << (mcReserved_lcbratok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_nottok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_integertok-mcReserved_recordtok)) | (1 << (mcReserved_realtok-mcReserved_recordtok)) | (1 << (mcReserved_attributetok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok)) | (1 << (mcReserved_stringtok-mcReserved_recordtok))));
      ConstExpressionNop (stopset0, stopset1, stopset2);
    }
}


/*
   SetType := ( 'SET'  | 'PACKEDSET'  ) 'OF' SimpleType 

   first  symbols:oftok, packedsettok, settok
   
   cannot reachend
*/

static void SetType (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  if (mcLexBuf_currenttoken == mcReserved_settok)
    {
      Expect ((mcReserved_toktype) mcReserved_settok, stopset0, stopset1|(SetOfStop1) ((1 << (mcReserved_oftok-mcReserved_arraytok))), stopset2);
    }
  else if (mcLexBuf_currenttoken == mcReserved_packedsettok)
    {
      /* avoid dangling else.  */
      Expect ((mcReserved_toktype) mcReserved_packedsettok, stopset0, stopset1|(SetOfStop1) ((1 << (mcReserved_oftok-mcReserved_arraytok))), stopset2);
    }
  else
    {
      /* avoid dangling else.  */
      ErrorArray ((char *) "expecting one of: PACKEDSET SET", 31);
    }
  Expect ((mcReserved_toktype) mcReserved_oftok, stopset0|(SetOfStop0) ((1 << (mcReserved_lsbratok-mcReserved_eoftok)) | (1 << (mcReserved_lparatok-mcReserved_eoftok))), stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_identtok-mcReserved_recordtok))));
  SimpleType (stopset0, stopset1, stopset2);
}


/*
   PointerType := 'POINTER' 'TO' Type 

   first  symbols:pointertok
   
   cannot reachend
*/

static void PointerType (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  Expect ((mcReserved_toktype) mcReserved_pointertok, stopset0, stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_totok-mcReserved_recordtok))));
  Expect ((mcReserved_toktype) mcReserved_totok, stopset0|(SetOfStop0) ((1 << (mcReserved_lparatok-mcReserved_eoftok)) | (1 << (mcReserved_lsbratok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_proceduretok-mcReserved_arraytok)) | (1 << (mcReserved_pointertok-mcReserved_arraytok)) | (1 << (mcReserved_packedsettok-mcReserved_arraytok)) | (1 << (mcReserved_oftok-mcReserved_arraytok)) | (1 << (mcReserved_arraytok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_settok-mcReserved_recordtok)) | (1 << (mcReserved_recordtok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok))));
  Type (stopset0, stopset1, stopset2);
}


/*
   ProcedureType := 'PROCEDURE' [ FormalTypeList  ] 

   first  symbols:proceduretok
   
   cannot reachend
*/

static void ProcedureType (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  Expect ((mcReserved_toktype) mcReserved_proceduretok, stopset0|(SetOfStop0) ((1 << (mcReserved_lparatok-mcReserved_eoftok))), stopset1, stopset2);
  if (mcLexBuf_currenttoken == mcReserved_lparatok)
    {
      FormalTypeList (stopset0, stopset1, stopset2);
    }
}


/*
   FormalTypeList := '(' ( ')' FormalReturn  | 
                           ProcedureParameters ')' FormalReturn  ) 

   first  symbols:lparatok
   
   cannot reachend
*/

static void FormalTypeList (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  Expect ((mcReserved_toktype) mcReserved_lparatok, stopset0|(SetOfStop0) ((1 << (mcReserved_rparatok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_arraytok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_periodperiodperiodtok-mcReserved_recordtok)) | (1 << (mcReserved_vartok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok))));
  if (mcLexBuf_currenttoken == mcReserved_rparatok)
    {
      Expect ((mcReserved_toktype) mcReserved_rparatok, stopset0|(SetOfStop0) ((1 << (mcReserved_colontok-mcReserved_eoftok))), stopset1, stopset2);
      FormalReturn (stopset0, stopset1, stopset2);
    }
  else if ((mcLexBuf_currenttoken == mcReserved_arraytok) || ((mcLexBuf_currenttoken >= mcReserved_recordtok) && ((((1 << (mcLexBuf_currenttoken-mcReserved_recordtok)) & ((SetOfStop2) ((1 << (mcReserved_vartok-mcReserved_recordtok)) | (1 << (mcReserved_periodperiodperiodtok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok))))) != 0))))
    {
      /* avoid dangling else.  */
      ProcedureParameters (stopset0|(SetOfStop0) ((1 << (mcReserved_rparatok-mcReserved_eoftok))), stopset1, stopset2);
      Expect ((mcReserved_toktype) mcReserved_rparatok, stopset0|(SetOfStop0) ((1 << (mcReserved_colontok-mcReserved_eoftok))), stopset1, stopset2);
      FormalReturn (stopset0, stopset1, stopset2);
    }
  else
    {
      /* avoid dangling else.  */
      ErrorArray ((char *) "expecting one of: VAR ... ARRAY identifier )", 44);
    }
}


/*
   FormalReturn := [ ':' OptReturnType  ] 

   first  symbols:colontok
   
   reachend
*/

static void FormalReturn (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  if (mcLexBuf_currenttoken == mcReserved_colontok)
    {
      Expect ((mcReserved_toktype) mcReserved_colontok, stopset0|(SetOfStop0) ((1 << (mcReserved_lsbratok-mcReserved_eoftok))), stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_identtok-mcReserved_recordtok))));
      OptReturnType (stopset0, stopset1, stopset2);
    }
}


/*
   OptReturnType := '[' Qualident ']'  | Qualident 

   first  symbols:identtok, lsbratok
   
   cannot reachend
*/

static void OptReturnType (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  if (mcLexBuf_currenttoken == mcReserved_lsbratok)
    {
      Expect ((mcReserved_toktype) mcReserved_lsbratok, stopset0, stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_identtok-mcReserved_recordtok))));
      Qualident (stopset0|(SetOfStop0) ((1 << (mcReserved_rsbratok-mcReserved_eoftok))), stopset1, stopset2);
      Expect ((mcReserved_toktype) mcReserved_rsbratok, stopset0, stopset1, stopset2);
    }
  else if (mcLexBuf_currenttoken == mcReserved_identtok)
    {
      /* avoid dangling else.  */
      Qualident (stopset0, stopset1, stopset2);
    }
  else
    {
      /* avoid dangling else.  */
      ErrorArray ((char *) "expecting one of: identifier [", 30);
    }
}


/*
   ProcedureParameters := ProcedureParameter { ',' ProcedureParameter  } 

   first  symbols:identtok, arraytok, periodperiodperiodtok, vartok
   
   cannot reachend
*/

static void ProcedureParameters (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  ProcedureParameter (stopset0|(SetOfStop0) ((1 << (mcReserved_commatok-mcReserved_eoftok))), stopset1, stopset2);
  while (mcLexBuf_currenttoken == mcReserved_commatok)
    {
      Expect ((mcReserved_toktype) mcReserved_commatok, stopset0, stopset1|(SetOfStop1) ((1 << (mcReserved_arraytok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_vartok-mcReserved_recordtok)) | (1 << (mcReserved_periodperiodperiodtok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok))));
      ProcedureParameter (stopset0|(SetOfStop0) ((1 << (mcReserved_commatok-mcReserved_eoftok))), stopset1, stopset2);
    }
   /* while  */
}


/*
   ProcedureParameter := '...'  | 'VAR' FormalType  | 
                         FormalType 

   first  symbols:arraytok, identtok, vartok, periodperiodperiodtok
   
   cannot reachend
*/

static void ProcedureParameter (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  if (mcLexBuf_currenttoken == mcReserved_periodperiodperiodtok)
    {
      Expect ((mcReserved_toktype) mcReserved_periodperiodperiodtok, stopset0, stopset1, stopset2);
    }
  else if (mcLexBuf_currenttoken == mcReserved_vartok)
    {
      /* avoid dangling else.  */
      Expect ((mcReserved_toktype) mcReserved_vartok, stopset0, stopset1|(SetOfStop1) ((1 << (mcReserved_arraytok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_identtok-mcReserved_recordtok))));
      FormalType (stopset0, stopset1, stopset2);
    }
  else if ((mcLexBuf_currenttoken == mcReserved_arraytok) || (mcLexBuf_currenttoken == mcReserved_identtok))
    {
      /* avoid dangling else.  */
      FormalType (stopset0, stopset1, stopset2);
    }
  else
    {
      /* avoid dangling else.  */
      ErrorArray ((char *) "expecting one of: ARRAY identifier VAR ...", 42);
    }
}


/*
   VarIdent := Ident [ '[' ConstExpressionNop ']'  ] 

   first  symbols:identtok
   
   cannot reachend
*/

static void VarIdent (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  Ident (stopset0|(SetOfStop0) ((1 << (mcReserved_lsbratok-mcReserved_eoftok))), stopset1, stopset2);
  if (mcLexBuf_currenttoken == mcReserved_lsbratok)
    {
      Expect ((mcReserved_toktype) mcReserved_lsbratok, stopset0|(SetOfStop0) ((1 << (mcReserved_minustok-mcReserved_eoftok)) | (1 << (mcReserved_plustok-mcReserved_eoftok)) | (1 << (mcReserved_lparatok-mcReserved_eoftok)) | (1 << (mcReserved_lcbratok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_nottok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_integertok-mcReserved_recordtok)) | (1 << (mcReserved_realtok-mcReserved_recordtok)) | (1 << (mcReserved_attributetok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok)) | (1 << (mcReserved_stringtok-mcReserved_recordtok))));
      ConstExpressionNop (stopset0|(SetOfStop0) ((1 << (mcReserved_rsbratok-mcReserved_eoftok))), stopset1, stopset2);
      Expect ((mcReserved_toktype) mcReserved_rsbratok, stopset0, stopset1, stopset2);
    }
}


/*
   VarIdentList := VarIdent { ',' VarIdent  } 

   first  symbols:identtok
   
   cannot reachend
*/

static void VarIdentList (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  VarIdent (stopset0|(SetOfStop0) ((1 << (mcReserved_commatok-mcReserved_eoftok))), stopset1, stopset2);
  while (mcLexBuf_currenttoken == mcReserved_commatok)
    {
      Expect ((mcReserved_toktype) mcReserved_commatok, stopset0, stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_identtok-mcReserved_recordtok))));
      VarIdent (stopset0|(SetOfStop0) ((1 << (mcReserved_commatok-mcReserved_eoftok))), stopset1, stopset2);
    }
   /* while  */
}


/*
   VariableDeclaration := VarIdentList ':' Type Alignment 

   first  symbols:identtok
   
   cannot reachend
*/

static void VariableDeclaration (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  VarIdentList (stopset0|(SetOfStop0) ((1 << (mcReserved_colontok-mcReserved_eoftok))), stopset1, stopset2);
  Expect ((mcReserved_toktype) mcReserved_colontok, stopset0|(SetOfStop0) ((1 << (mcReserved_lparatok-mcReserved_eoftok)) | (1 << (mcReserved_lsbratok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_proceduretok-mcReserved_arraytok)) | (1 << (mcReserved_pointertok-mcReserved_arraytok)) | (1 << (mcReserved_packedsettok-mcReserved_arraytok)) | (1 << (mcReserved_oftok-mcReserved_arraytok)) | (1 << (mcReserved_arraytok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_settok-mcReserved_recordtok)) | (1 << (mcReserved_recordtok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok))));
  Type (stopset0|(SetOfStop0) ((1 << (mcReserved_ldirectivetok-mcReserved_eoftok))), stopset1, stopset2);
  Alignment (stopset0, stopset1, stopset2);
}


/*
   Designator := PushQualident { SubDesignator  } 

   first  symbols:identtok
   
   cannot reachend
*/

static void Designator (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  PushQualident (stopset0|(SetOfStop0) ((1 << (mcReserved_lsbratok-mcReserved_eoftok)) | (1 << (mcReserved_periodtok-mcReserved_eoftok)) | (1 << (mcReserved_uparrowtok-mcReserved_eoftok))), stopset1, stopset2);
  while ((mcLexBuf_currenttoken < mcReserved_arraytok) && ((((1 << (mcLexBuf_currenttoken-mcReserved_eoftok)) & ((SetOfStop0) ((1 << (mcReserved_periodtok-mcReserved_eoftok)) | (1 << (mcReserved_lsbratok-mcReserved_eoftok)) | (1 << (mcReserved_uparrowtok-mcReserved_eoftok))))) != 0)))
    {
      SubDesignator (stopset0|(SetOfStop0) ((1 << (mcReserved_periodtok-mcReserved_eoftok)) | (1 << (mcReserved_lsbratok-mcReserved_eoftok)) | (1 << (mcReserved_uparrowtok-mcReserved_eoftok))), stopset1, stopset2);
    }
   /* while  */
}


/*
   SubDesignator := 
                    % VAR n, field, type: node ;  %
                    
                    % n := peep ()  %
                    
                    % IF n = NIL
                      THEN
                      									     ErrorArray ('no expression found') ;
                         flushErrors ;
                         RETURN
                      END  %
                    
                    % type := skipType (getType (n))  %
                    ( '.' Ident 
                      % IF isRecord (type)
                        THEN
                           field := lookupInScope (type, curident) ;
                           IF field = NIL
                           THEN
                              metaError2 ('field {%1k} cannot be found in record {%2ad}', curident, type)
                           ELSE
                              n := replace (makeComponentRef (n, field))
                           END
                        ELSE
                           metaError2 ('attempting to access a field {%1k} from {%2ad} which does not have a record type', curident, type)
                        END  %
                       | '[' ArrayExpList 
                      % IF isArray (type)
                        THEN
                           n := replace (makeArrayRef (n, pop ()))
                        ELSE
                           metaError1 ('attempting to access an array but the expression is not an array but a {%1d}', type)
                        END  %
                      ']'  | SubPointer  ) 

   first  symbols:uparrowtok, lsbratok, periodtok
   
   cannot reachend
*/

static void SubDesignator (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  decl_node n;
  decl_node field;
  decl_node type;

  n = peep ();
  if (n == NULL)
    {
      ErrorArray ((char *) "no expression found", 19);
      mcError_flushErrors ();
      return;
    }
  type = decl_skipType (decl_getType (n));
  if (mcLexBuf_currenttoken == mcReserved_periodtok)
    {
      Expect ((mcReserved_toktype) mcReserved_periodtok, stopset0, stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_identtok-mcReserved_recordtok))));
      Ident (stopset0, stopset1, stopset2);
      if (decl_isRecord (type))
        {
          field = decl_lookupInScope (type, curident);
          if (field == NULL)
            {
              mcMetaError_metaError2 ((char *) "field {%1k} cannot be found in record {%2ad}", 44, (unsigned char *) &curident, (sizeof (curident)-1), (unsigned char *) &type, (sizeof (type)-1));
            }
          else
            {
              n = replace (decl_makeComponentRef (n, field));
            }
        }
      else
        {
          mcMetaError_metaError2 ((char *) "attempting to access a field {%1k} from {%2ad} which does not have a record type", 80, (unsigned char *) &curident, (sizeof (curident)-1), (unsigned char *) &type, (sizeof (type)-1));
        }
    }
  else if (mcLexBuf_currenttoken == mcReserved_lsbratok)
    {
      /* avoid dangling else.  */
      Expect ((mcReserved_toktype) mcReserved_lsbratok, stopset0|(SetOfStop0) ((1 << (mcReserved_plustok-mcReserved_eoftok)) | (1 << (mcReserved_minustok-mcReserved_eoftok)) | (1 << (mcReserved_lparatok-mcReserved_eoftok)) | (1 << (mcReserved_lcbratok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_nottok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_realtok-mcReserved_recordtok)) | (1 << (mcReserved_integertok-mcReserved_recordtok)) | (1 << (mcReserved_stringtok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok))));
      ArrayExpList (stopset0|(SetOfStop0) ((1 << (mcReserved_rsbratok-mcReserved_eoftok))), stopset1, stopset2);
      if (decl_isArray (type))
        {
          n = replace (decl_makeArrayRef (n, pop ()));
        }
      else
        {
          mcMetaError_metaError1 ((char *) "attempting to access an array but the expression is not an array but a {%1d}", 76, (unsigned char *) &type, (sizeof (type)-1));
        }
      Expect ((mcReserved_toktype) mcReserved_rsbratok, stopset0, stopset1, stopset2);
    }
  else if (mcLexBuf_currenttoken == mcReserved_uparrowtok)
    {
      /* avoid dangling else.  */
      SubPointer (stopset0, stopset1, stopset2);
    }
  else
    {
      /* avoid dangling else.  */
      ErrorArray ((char *) "expecting one of: ^ [ .", 23);
    }
}


/*
   SubPointer := 
                 % VAR n, field, type: node ;  %
                 
                 % n := peep ()  %
                 
                 % type := skipType (getType (n))  %
                 '^' ( '.' Ident 
                       % IF isPointer (type)
                         THEN
                         									     type := skipType (getType (type)) ;
                         									     IF isRecord (type)
                            THEN
                               field := lookupInScope (type, curident) ;
                               IF field = NIL
                               THEN
                                  metaError2 ('field {%1k} cannot be found in record {%2ad}', curident, type)
                               ELSE
                                  n := replace (makePointerRef (n, field))
                               END
                            ELSE
                               metaError2 ('attempting to access a field {%1k} from {%2ad} which does not have a record type', curident, type)
                            END
                         ELSE
                            metaError2 ('trying to dereference {%1k} which was not declared as a pointer but a {%2tad}', n, n)
                         END  %
                        | 
                       % IF isPointer (type)
                         THEN
                            n := replace (makeDeRef (n))
                         ELSE
                            metaError1 ('attempting to dereference a pointer but the expression is not a pointer but a {%1d}', type)
                         END  %
                        ) 

   first  symbols:uparrowtok
   
   cannot reachend
*/

static void SubPointer (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  decl_node n;
  decl_node field;
  decl_node type;

  n = peep ();
  type = decl_skipType (decl_getType (n));
  Expect ((mcReserved_toktype) mcReserved_uparrowtok, stopset0|(SetOfStop0) ((1 << (mcReserved_periodtok-mcReserved_eoftok))), stopset1, stopset2);
  if (mcLexBuf_currenttoken == mcReserved_periodtok)
    {
      Expect ((mcReserved_toktype) mcReserved_periodtok, stopset0, stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_identtok-mcReserved_recordtok))));
      Ident (stopset0, stopset1, stopset2);
      if (decl_isPointer (type))
        {
          type = decl_skipType (decl_getType (type));
          if (decl_isRecord (type))
            {
              field = decl_lookupInScope (type, curident);
              if (field == NULL)
                {
                  mcMetaError_metaError2 ((char *) "field {%1k} cannot be found in record {%2ad}", 44, (unsigned char *) &curident, (sizeof (curident)-1), (unsigned char *) &type, (sizeof (type)-1));
                }
              else
                {
                  n = replace (decl_makePointerRef (n, field));
                }
            }
          else
            {
              mcMetaError_metaError2 ((char *) "attempting to access a field {%1k} from {%2ad} which does not have a record type", 80, (unsigned char *) &curident, (sizeof (curident)-1), (unsigned char *) &type, (sizeof (type)-1));
            }
        }
      else
        {
          mcMetaError_metaError2 ((char *) "trying to dereference {%1k} which was not declared as a pointer but a {%2tad}", 77, (unsigned char *) &n, (sizeof (n)-1), (unsigned char *) &n, (sizeof (n)-1));
        }
    }
  else
    {
      if (decl_isPointer (type))
        {
          n = replace (decl_makeDeRef (n));
        }
      else
        {
          mcMetaError_metaError1 ((char *) "attempting to dereference a pointer but the expression is not a pointer but a {%1d}", 83, (unsigned char *) &type, (sizeof (type)-1));
        }
    }
}


/*
   ArrayExpList := 
                   % VAR l: node ;  %
                   
                   % l := push (makeExpList ())  %
                   Expression 
                   % putExpList (l, pop ())  %
                   
                   % assert (isExpList (peep ()))  %
                   { ',' Expression 
                     % putExpList (l, pop ())  %
                     
                     % assert (isExpList (peep ()))  %
                      } 

   first  symbols:identtok, lcbratok, realtok, integertok, stringtok, lparatok, nottok, plustok, minustok
   
   cannot reachend
*/

static void ArrayExpList (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  decl_node l;

  l = push (decl_makeExpList ());
  Expression (stopset0|(SetOfStop0) ((1 << (mcReserved_commatok-mcReserved_eoftok))), stopset1, stopset2);
  decl_putExpList (l, pop ());
  mcDebug_assert (decl_isExpList (peep ()));
  while (mcLexBuf_currenttoken == mcReserved_commatok)
    {
      Expect ((mcReserved_toktype) mcReserved_commatok, stopset0|(SetOfStop0) ((1 << (mcReserved_minustok-mcReserved_eoftok)) | (1 << (mcReserved_plustok-mcReserved_eoftok)) | (1 << (mcReserved_lparatok-mcReserved_eoftok)) | (1 << (mcReserved_lcbratok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_nottok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_stringtok-mcReserved_recordtok)) | (1 << (mcReserved_integertok-mcReserved_recordtok)) | (1 << (mcReserved_realtok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok))));
      Expression (stopset0|(SetOfStop0) ((1 << (mcReserved_commatok-mcReserved_eoftok))), stopset1, stopset2);
      decl_putExpList (l, pop ());
      mcDebug_assert (decl_isExpList (peep ()));
    }
   /* while  */
}


/*
   ExpList := 
              % VAR p, n: node ;  %
              
              % p := peep ()  %
              
              % assert (isExpList (p))  %
              Expression 
              % putExpList (p, pop ())  %
              
              % assert (isExpList (peep ()))  %
              { ',' Expression 
                % putExpList (p, pop ())  %
                
                % assert (isExpList (peep ()))  %
                 } 

   first  symbols:identtok, lcbratok, realtok, integertok, stringtok, lparatok, nottok, plustok, minustok
   
   cannot reachend
*/

static void ExpList (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  decl_node p;
  decl_node n;

  p = peep ();
  mcDebug_assert (decl_isExpList (p));
  Expression (stopset0|(SetOfStop0) ((1 << (mcReserved_commatok-mcReserved_eoftok))), stopset1, stopset2);
  decl_putExpList (p, pop ());
  mcDebug_assert (decl_isExpList (peep ()));
  while (mcLexBuf_currenttoken == mcReserved_commatok)
    {
      Expect ((mcReserved_toktype) mcReserved_commatok, stopset0|(SetOfStop0) ((1 << (mcReserved_minustok-mcReserved_eoftok)) | (1 << (mcReserved_plustok-mcReserved_eoftok)) | (1 << (mcReserved_lparatok-mcReserved_eoftok)) | (1 << (mcReserved_lcbratok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_nottok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_stringtok-mcReserved_recordtok)) | (1 << (mcReserved_integertok-mcReserved_recordtok)) | (1 << (mcReserved_realtok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok))));
      Expression (stopset0|(SetOfStop0) ((1 << (mcReserved_commatok-mcReserved_eoftok))), stopset1, stopset2);
      decl_putExpList (p, pop ());
      mcDebug_assert (decl_isExpList (peep ()));
    }
   /* while  */
}


/*
   Expression := 
                 % VAR c, l, r: node ; op: toktype ;  %
                 SimpleExpression 
                 % op := currenttoken  %
                 [ Relation 
                   % l := pop ()  %
                   SimpleExpression 
                   % r := pop ()  %
                   
                   % r := push (makeBinaryTok (op, l, r))  %
                    ] 

   first  symbols:identtok, lcbratok, nottok, lparatok, stringtok, integertok, realtok, minustok, plustok
   
   cannot reachend
*/

static void Expression (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  decl_node c;
  decl_node l;
  decl_node r;
  mcReserved_toktype op;

  SimpleExpression (stopset0|(SetOfStop0) ((1 << (mcReserved_greaterequaltok-mcReserved_eoftok)) | (1 << (mcReserved_greatertok-mcReserved_eoftok)) | (1 << (mcReserved_lessequaltok-mcReserved_eoftok)) | (1 << (mcReserved_lesstok-mcReserved_eoftok)) | (1 << (mcReserved_lessgreatertok-mcReserved_eoftok)) | (1 << (mcReserved_hashtok-mcReserved_eoftok)) | (1 << (mcReserved_equaltok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_intok-mcReserved_arraytok))), stopset2);
  op = mcLexBuf_currenttoken;
  if (((mcLexBuf_currenttoken < mcReserved_arraytok) && ((((1 << (mcLexBuf_currenttoken-mcReserved_eoftok)) & ((SetOfStop0) ((1 << (mcReserved_equaltok-mcReserved_eoftok)) | (1 << (mcReserved_hashtok-mcReserved_eoftok)) | (1 << (mcReserved_lessgreatertok-mcReserved_eoftok)) | (1 << (mcReserved_lesstok-mcReserved_eoftok)) | (1 << (mcReserved_lessequaltok-mcReserved_eoftok)) | (1 << (mcReserved_greatertok-mcReserved_eoftok)) | (1 << (mcReserved_greaterequaltok-mcReserved_eoftok))))) != 0))) || (mcLexBuf_currenttoken == mcReserved_intok))
    {
      Relation (stopset0|(SetOfStop0) ((1 << (mcReserved_plustok-mcReserved_eoftok)) | (1 << (mcReserved_minustok-mcReserved_eoftok)) | (1 << (mcReserved_lparatok-mcReserved_eoftok)) | (1 << (mcReserved_lcbratok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_nottok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_realtok-mcReserved_recordtok)) | (1 << (mcReserved_integertok-mcReserved_recordtok)) | (1 << (mcReserved_stringtok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok))));
      l = pop ();
      SimpleExpression (stopset0, stopset1, stopset2);
      r = pop ();
      r = push (decl_makeBinaryTok (op, l, r));
    }
}


/*
   SimpleExpression := 
                       % VAR op: toktype ; n: node ;  %
                       UnaryOrTerm { 
                                     % op := currenttoken  %
                                     
                                     % n := pop ()  %
                                     AddOperator Term 
                                     % n := push (makeBinaryTok (op, n, pop ()))  %
                                      } 

   first  symbols:identtok, lcbratok, realtok, integertok, stringtok, lparatok, nottok, plustok, minustok
   
   cannot reachend
*/

static void SimpleExpression (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  mcReserved_toktype op;
  decl_node n;

  UnaryOrTerm (stopset0|(SetOfStop0) ((1 << (mcReserved_minustok-mcReserved_eoftok)) | (1 << (mcReserved_plustok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_ortok-mcReserved_arraytok))), stopset2);
  while (((mcLexBuf_currenttoken < mcReserved_arraytok) && ((((1 << (mcLexBuf_currenttoken-mcReserved_eoftok)) & ((SetOfStop0) ((1 << (mcReserved_plustok-mcReserved_eoftok)) | (1 << (mcReserved_minustok-mcReserved_eoftok))))) != 0))) || (mcLexBuf_currenttoken == mcReserved_ortok))
    {
      op = mcLexBuf_currenttoken;
      n = pop ();
      AddOperator (stopset0|(SetOfStop0) ((1 << (mcReserved_lparatok-mcReserved_eoftok)) | (1 << (mcReserved_lcbratok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_nottok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_realtok-mcReserved_recordtok)) | (1 << (mcReserved_integertok-mcReserved_recordtok)) | (1 << (mcReserved_stringtok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok))));
      Term (stopset0|(SetOfStop0) ((1 << (mcReserved_plustok-mcReserved_eoftok)) | (1 << (mcReserved_minustok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_ortok-mcReserved_arraytok))), stopset2);
      n = push (decl_makeBinaryTok (op, n, pop ()));
    }
   /* while  */
}


/*
   UnaryOrTerm := 
                  % VAR n: node ;  %
                  '+' Term 
                  % n := push (makeUnaryTok (plustok, pop ()))  %
                   | '-' Term 
                  % n := push (makeUnaryTok (minustok, pop ()))  %
                   | Term 

   first  symbols:identtok, lcbratok, nottok, lparatok, stringtok, integertok, realtok, minustok, plustok
   
   cannot reachend
*/

static void UnaryOrTerm (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  decl_node n;

  if (mcLexBuf_currenttoken == mcReserved_plustok)
    {
      Expect ((mcReserved_toktype) mcReserved_plustok, stopset0|(SetOfStop0) ((1 << (mcReserved_lparatok-mcReserved_eoftok)) | (1 << (mcReserved_lcbratok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_nottok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_realtok-mcReserved_recordtok)) | (1 << (mcReserved_integertok-mcReserved_recordtok)) | (1 << (mcReserved_stringtok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok))));
      Term (stopset0, stopset1, stopset2);
      n = push (decl_makeUnaryTok ((mcReserved_toktype) mcReserved_plustok, pop ()));
    }
  else if (mcLexBuf_currenttoken == mcReserved_minustok)
    {
      /* avoid dangling else.  */
      Expect ((mcReserved_toktype) mcReserved_minustok, stopset0|(SetOfStop0) ((1 << (mcReserved_lparatok-mcReserved_eoftok)) | (1 << (mcReserved_lcbratok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_nottok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_realtok-mcReserved_recordtok)) | (1 << (mcReserved_integertok-mcReserved_recordtok)) | (1 << (mcReserved_stringtok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok))));
      Term (stopset0, stopset1, stopset2);
      n = push (decl_makeUnaryTok ((mcReserved_toktype) mcReserved_minustok, pop ()));
    }
  else if ((((mcLexBuf_currenttoken < mcReserved_arraytok) && ((((1 << (mcLexBuf_currenttoken-mcReserved_eoftok)) & ((SetOfStop0) ((1 << (mcReserved_lparatok-mcReserved_eoftok)) | (1 << (mcReserved_lcbratok-mcReserved_eoftok))))) != 0))) || (mcLexBuf_currenttoken == mcReserved_nottok)) || ((mcLexBuf_currenttoken >= mcReserved_recordtok) && ((((1 << (mcLexBuf_currenttoken-mcReserved_recordtok)) & ((SetOfStop2) ((1 << (mcReserved_stringtok-mcReserved_recordtok)) | (1 << (mcReserved_integertok-mcReserved_recordtok)) | (1 << (mcReserved_realtok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok))))) != 0))))
    {
      /* avoid dangling else.  */
      Term (stopset0, stopset1, stopset2);
    }
  else
    {
      /* avoid dangling else.  */
      ErrorArray ((char *) "expecting one of: NOT ( string integer number real number { identifier - +", 74);
    }
}


/*
   Term := 
           % VAR op: toktype ; n: node ;  %
           Factor { 
                    % op := currenttoken  %
                    MulOperator 
                    % n := pop ()  %
                    Factor 
                    % n := push (makeBinaryTok (op, n, pop ()))  %
                     } 

   first  symbols:identtok, lcbratok, realtok, integertok, stringtok, lparatok, nottok
   
   cannot reachend
*/

static void Term (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  mcReserved_toktype op;
  decl_node n;

  Factor (stopset0|(SetOfStop0) ((1 << (mcReserved_ambersandtok-mcReserved_eoftok)) | (1 << (mcReserved_andtok-mcReserved_eoftok)) | (1 << (mcReserved_dividetok-mcReserved_eoftok)) | (1 << (mcReserved_timestok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_modtok-mcReserved_arraytok)) | (1 << (mcReserved_divtok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_remtok-mcReserved_recordtok))));
  while ((((mcLexBuf_currenttoken < mcReserved_arraytok) && ((((1 << (mcLexBuf_currenttoken-mcReserved_eoftok)) & ((SetOfStop0) ((1 << (mcReserved_timestok-mcReserved_eoftok)) | (1 << (mcReserved_dividetok-mcReserved_eoftok)) | (1 << (mcReserved_andtok-mcReserved_eoftok)) | (1 << (mcReserved_ambersandtok-mcReserved_eoftok))))) != 0))) || (((mcLexBuf_currenttoken >= mcReserved_arraytok) && (mcLexBuf_currenttoken < mcReserved_recordtok)) && ((((1 << (mcLexBuf_currenttoken-mcReserved_arraytok)) & ((SetOfStop1) ((1 << (mcReserved_divtok-mcReserved_arraytok)) | (1 << (mcReserved_modtok-mcReserved_arraytok))))) != 0)))) || (mcLexBuf_currenttoken == mcReserved_remtok))
    {
      op = mcLexBuf_currenttoken;
      MulOperator (stopset0|(SetOfStop0) ((1 << (mcReserved_lparatok-mcReserved_eoftok)) | (1 << (mcReserved_lcbratok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_nottok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_stringtok-mcReserved_recordtok)) | (1 << (mcReserved_integertok-mcReserved_recordtok)) | (1 << (mcReserved_realtok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok))));
      n = pop ();
      Factor (stopset0|(SetOfStop0) ((1 << (mcReserved_timestok-mcReserved_eoftok)) | (1 << (mcReserved_dividetok-mcReserved_eoftok)) | (1 << (mcReserved_andtok-mcReserved_eoftok)) | (1 << (mcReserved_ambersandtok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_divtok-mcReserved_arraytok)) | (1 << (mcReserved_modtok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_remtok-mcReserved_recordtok))));
      n = push (decl_makeBinaryTok (op, n, pop ()));
    }
   /* while  */
}


/*
   PushString := string 
                 % VAR n: node ;  %
                 
                 % n := push (makeString (curstring))  %
                 

   first  symbols:stringtok
   
   cannot reachend
*/

static void PushString (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  decl_node n;

  string (stopset0, stopset1, stopset2);
  n = push (decl_makeString (curstring));
}


/*
   Factor := Number  | PushString  | SetOrDesignatorOrFunction  | 
             '(' Expression ')'  | 'NOT' ( Factor 
                                           % VAR n: node ;  %
                                           
                                           % n := push (makeUnaryTok (nottok, pop ()))  %
                                            | ConstAttribute 
                                           
                                           % n := push (makeUnaryTok (nottok, pop ()))  %
                                            ) 

   first  symbols:identtok, lcbratok, nottok, lparatok, stringtok, integertok, realtok
   
   cannot reachend
*/

static void Factor (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  decl_node n;

  if ((mcLexBuf_currenttoken >= mcReserved_recordtok) && ((((1 << (mcLexBuf_currenttoken-mcReserved_recordtok)) & ((SetOfStop2) ((1 << (mcReserved_integertok-mcReserved_recordtok)) | (1 << (mcReserved_realtok-mcReserved_recordtok))))) != 0)))
    {
      Number (stopset0, stopset1, stopset2);
    }
  else if (mcLexBuf_currenttoken == mcReserved_stringtok)
    {
      /* avoid dangling else.  */
      PushString (stopset0, stopset1, stopset2);
    }
  else if ((mcLexBuf_currenttoken == mcReserved_lcbratok) || (mcLexBuf_currenttoken == mcReserved_identtok))
    {
      /* avoid dangling else.  */
      SetOrDesignatorOrFunction (stopset0, stopset1, stopset2);
    }
  else if (mcLexBuf_currenttoken == mcReserved_lparatok)
    {
      /* avoid dangling else.  */
      Expect ((mcReserved_toktype) mcReserved_lparatok, stopset0|(SetOfStop0) ((1 << (mcReserved_minustok-mcReserved_eoftok)) | (1 << (mcReserved_plustok-mcReserved_eoftok)) | (1 << (mcReserved_lparatok-mcReserved_eoftok)) | (1 << (mcReserved_lcbratok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_nottok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_stringtok-mcReserved_recordtok)) | (1 << (mcReserved_integertok-mcReserved_recordtok)) | (1 << (mcReserved_realtok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok))));
      Expression (stopset0|(SetOfStop0) ((1 << (mcReserved_rparatok-mcReserved_eoftok))), stopset1, stopset2);
      Expect ((mcReserved_toktype) mcReserved_rparatok, stopset0, stopset1, stopset2);
    }
  else if (mcLexBuf_currenttoken == mcReserved_nottok)
    {
      /* avoid dangling else.  */
      Expect ((mcReserved_toktype) mcReserved_nottok, stopset0|(SetOfStop0) ((1 << (mcReserved_lparatok-mcReserved_eoftok)) | (1 << (mcReserved_lcbratok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_nottok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_stringtok-mcReserved_recordtok)) | (1 << (mcReserved_integertok-mcReserved_recordtok)) | (1 << (mcReserved_realtok-mcReserved_recordtok)) | (1 << (mcReserved_attributetok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok))));
      if ((((mcLexBuf_currenttoken < mcReserved_arraytok) && ((((1 << (mcLexBuf_currenttoken-mcReserved_eoftok)) & ((SetOfStop0) ((1 << (mcReserved_lparatok-mcReserved_eoftok)) | (1 << (mcReserved_lcbratok-mcReserved_eoftok))))) != 0))) || (mcLexBuf_currenttoken == mcReserved_nottok)) || ((mcLexBuf_currenttoken >= mcReserved_recordtok) && ((((1 << (mcLexBuf_currenttoken-mcReserved_recordtok)) & ((SetOfStop2) ((1 << (mcReserved_realtok-mcReserved_recordtok)) | (1 << (mcReserved_integertok-mcReserved_recordtok)) | (1 << (mcReserved_stringtok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok))))) != 0))))
        {
          Factor (stopset0, stopset1, stopset2);
          n = push (decl_makeUnaryTok ((mcReserved_toktype) mcReserved_nottok, pop ()));
        }
      else if (mcLexBuf_currenttoken == mcReserved_attributetok)
        {
          /* avoid dangling else.  */
          ConstAttribute (stopset0, stopset1, stopset2);
          n = push (decl_makeUnaryTok ((mcReserved_toktype) mcReserved_nottok, pop ()));
        }
      else
        {
          /* avoid dangling else.  */
          ErrorArray ((char *) "expecting one of: __ATTRIBUTE__ real number integer number string ( NOT { identifier", 84);
        }
    }
  else
    {
      /* avoid dangling else.  */
      ErrorArray ((char *) "expecting one of: NOT ( { identifier string integer number real number", 70);
    }
}


/*
   ComponentElement := Expression 
                       % VAR l, h, n: node ;  %
                       
                       % l := pop ()  %
                       
                       % h := NIL  %
                       [ '..' Expression 
                         % h := pop ()  %
                         
                         % ErrorArray ('implementation restriction range is not allowed')  %
                          ] 
                       % n := push (includeSetValue (pop (), l, h))  %
                       

   first  symbols:identtok, lcbratok, realtok, integertok, stringtok, lparatok, nottok, plustok, minustok
   
   cannot reachend
*/

static void ComponentElement (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  decl_node l;
  decl_node h;
  decl_node n;

  Expression (stopset0|(SetOfStop0) ((1 << (mcReserved_periodperiodtok-mcReserved_eoftok))), stopset1, stopset2);
  l = pop ();
  h = NULL;
  if (mcLexBuf_currenttoken == mcReserved_periodperiodtok)
    {
      Expect ((mcReserved_toktype) mcReserved_periodperiodtok, stopset0|(SetOfStop0) ((1 << (mcReserved_minustok-mcReserved_eoftok)) | (1 << (mcReserved_plustok-mcReserved_eoftok)) | (1 << (mcReserved_lparatok-mcReserved_eoftok)) | (1 << (mcReserved_lcbratok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_nottok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_stringtok-mcReserved_recordtok)) | (1 << (mcReserved_integertok-mcReserved_recordtok)) | (1 << (mcReserved_realtok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok))));
      Expression (stopset0, stopset1, stopset2);
      h = pop ();
      ErrorArray ((char *) "implementation restriction range is not allowed", 47);
    }
  n = push (decl_includeSetValue (pop (), l, h));
}


/*
   ComponentValue := ComponentElement [ 'BY' 
                                        % ErrorArray ('implementation restriction BY not allowed')  %
                                        Expression  ] 

   first  symbols:identtok, lcbratok, nottok, lparatok, stringtok, integertok, realtok, minustok, plustok
   
   cannot reachend
*/

static void ComponentValue (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  ComponentElement (stopset0, stopset1|(SetOfStop1) ((1 << (mcReserved_bytok-mcReserved_arraytok))), stopset2);
  if (mcLexBuf_currenttoken == mcReserved_bytok)
    {
      Expect ((mcReserved_toktype) mcReserved_bytok, stopset0|(SetOfStop0) ((1 << (mcReserved_minustok-mcReserved_eoftok)) | (1 << (mcReserved_plustok-mcReserved_eoftok)) | (1 << (mcReserved_lparatok-mcReserved_eoftok)) | (1 << (mcReserved_lcbratok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_nottok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_stringtok-mcReserved_recordtok)) | (1 << (mcReserved_integertok-mcReserved_recordtok)) | (1 << (mcReserved_realtok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok))));
      ErrorArray ((char *) "implementation restriction BY not allowed", 41);
      Expression (stopset0, stopset1, stopset2);
    }
}


/*
   ArraySetRecordValue := ComponentValue { ',' ComponentValue  } 

   first  symbols:identtok, lcbratok, realtok, integertok, stringtok, lparatok, nottok, plustok, minustok
   
   cannot reachend
*/

static void ArraySetRecordValue (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  ComponentValue (stopset0|(SetOfStop0) ((1 << (mcReserved_commatok-mcReserved_eoftok))), stopset1, stopset2);
  while (mcLexBuf_currenttoken == mcReserved_commatok)
    {
      Expect ((mcReserved_toktype) mcReserved_commatok, stopset0|(SetOfStop0) ((1 << (mcReserved_minustok-mcReserved_eoftok)) | (1 << (mcReserved_plustok-mcReserved_eoftok)) | (1 << (mcReserved_lparatok-mcReserved_eoftok)) | (1 << (mcReserved_lcbratok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_nottok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_stringtok-mcReserved_recordtok)) | (1 << (mcReserved_integertok-mcReserved_recordtok)) | (1 << (mcReserved_realtok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok))));
      ComponentValue (stopset0|(SetOfStop0) ((1 << (mcReserved_commatok-mcReserved_eoftok))), stopset1, stopset2);
    }
   /* while  */
}


/*
   Constructor := '{' 
                  % VAR n: node ;  %
                  
                  % n := push (makeSetValue ())  %
                  [ ArraySetRecordValue  ] '}' 

   first  symbols:lcbratok
   
   cannot reachend
*/

static void Constructor (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  decl_node n;

  Expect ((mcReserved_toktype) mcReserved_lcbratok, stopset0|(SetOfStop0) ((1 << (mcReserved_rcbratok-mcReserved_eoftok)) | (1 << (mcReserved_plustok-mcReserved_eoftok)) | (1 << (mcReserved_minustok-mcReserved_eoftok)) | (1 << (mcReserved_lparatok-mcReserved_eoftok)) | (1 << (mcReserved_lcbratok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_nottok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_realtok-mcReserved_recordtok)) | (1 << (mcReserved_integertok-mcReserved_recordtok)) | (1 << (mcReserved_stringtok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok))));
  n = push (decl_makeSetValue ());
  if ((((mcLexBuf_currenttoken < mcReserved_arraytok) && ((((1 << (mcLexBuf_currenttoken-mcReserved_eoftok)) & ((SetOfStop0) ((1 << (mcReserved_minustok-mcReserved_eoftok)) | (1 << (mcReserved_plustok-mcReserved_eoftok)) | (1 << (mcReserved_lparatok-mcReserved_eoftok)) | (1 << (mcReserved_lcbratok-mcReserved_eoftok))))) != 0))) || (mcLexBuf_currenttoken == mcReserved_nottok)) || ((mcLexBuf_currenttoken >= mcReserved_recordtok) && ((((1 << (mcLexBuf_currenttoken-mcReserved_recordtok)) & ((SetOfStop2) ((1 << (mcReserved_stringtok-mcReserved_recordtok)) | (1 << (mcReserved_integertok-mcReserved_recordtok)) | (1 << (mcReserved_realtok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok))))) != 0))))
    {
      ArraySetRecordValue (stopset0|(SetOfStop0) ((1 << (mcReserved_rcbratok-mcReserved_eoftok))), stopset1, stopset2);
    }
  Expect ((mcReserved_toktype) mcReserved_rcbratok, stopset0, stopset1, stopset2);
}


/*
   SetOrDesignatorOrFunction := PushQualident 
                                % VAR q, p, n: node ;  %
                                [ Constructor 
                                  % p := pop ()  %
                                  
                                  % q := pop ()  %
                                  
                                  % n := push (putSetValue (p, q))  %
                                   | SimpleDes [ 
                                                 % q := pop ()  %
                                                 ActualParameters 
                                                 
                                                 % p := pop ()  %
                                                 
                                                 % p := push (makeFuncCall (q, p))  %
                                                  ]  ]  | 
                                Constructor 

   first  symbols:identtok, lcbratok
   
   cannot reachend
*/

static void SetOrDesignatorOrFunction (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  decl_node q;
  decl_node p;
  decl_node n;

  if (mcLexBuf_currenttoken == mcReserved_identtok)
    {
      /* avoid dangling else.  */
      PushQualident (stopset0|(SetOfStop0) ((1 << (mcReserved_lcbratok-mcReserved_eoftok)) | (1 << (mcReserved_periodtok-mcReserved_eoftok)) | (1 << (mcReserved_lsbratok-mcReserved_eoftok)) | (1 << (mcReserved_lparatok-mcReserved_eoftok)) | (1 << (mcReserved_uparrowtok-mcReserved_eoftok))), stopset1, stopset2);
      if ((mcLexBuf_currenttoken < mcReserved_arraytok) && ((((1 << (mcLexBuf_currenttoken-mcReserved_eoftok)) & ((SetOfStop0) ((1 << (mcReserved_lparatok-mcReserved_eoftok)) | (1 << (mcReserved_lsbratok-mcReserved_eoftok)) | (1 << (mcReserved_periodtok-mcReserved_eoftok)) | (1 << (mcReserved_uparrowtok-mcReserved_eoftok)) | (1 << (mcReserved_lcbratok-mcReserved_eoftok))))) != 0)))
        {
          /* avoid gcc warning by using compound statement even if not strictly necessary.  */
          /* seen optional [ | ] expression  */
          if (mcLexBuf_currenttoken == mcReserved_lcbratok)
            {
              Constructor (stopset0, stopset1, stopset2);
              p = pop ();
              q = pop ();
              n = push (decl_putSetValue (p, q));
            }
          else if ((mcLexBuf_currenttoken < mcReserved_arraytok) && ((((1 << (mcLexBuf_currenttoken-mcReserved_eoftok)) & ((SetOfStop0) ((1 << (mcReserved_lparatok-mcReserved_eoftok)) | (1 << (mcReserved_lsbratok-mcReserved_eoftok)) | (1 << (mcReserved_periodtok-mcReserved_eoftok)) | (1 << (mcReserved_uparrowtok-mcReserved_eoftok))))) != 0)))
            {
              /* avoid dangling else.  */
              SimpleDes (stopset0|(SetOfStop0) ((1 << (mcReserved_lparatok-mcReserved_eoftok))), stopset1, stopset2);
              if (mcLexBuf_currenttoken == mcReserved_lparatok)
                {
                  q = pop ();
                  ActualParameters (stopset0, stopset1, stopset2);
                  p = pop ();
                  p = push (decl_makeFuncCall (q, p));
                }
            }
          else
            {
              /* avoid dangling else.  */
              ErrorArray ((char *) "expecting one of: ( [ . ^ {", 27);
            }
        }
      /* end of optional [ | ] expression  */
    }
  else if (mcLexBuf_currenttoken == mcReserved_lcbratok)
    {
      /* avoid dangling else.  */
      Constructor (stopset0, stopset1, stopset2);
    }
  else
    {
      /* avoid dangling else.  */
      ErrorArray ((char *) "expecting one of: { identifier", 30);
    }
}


/*
   SimpleDes := { SubDesignator  } 

   first  symbols:uparrowtok, periodtok, lsbratok
   
   reachend
*/

static void SimpleDes (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  while ((mcLexBuf_currenttoken < mcReserved_arraytok) && ((((1 << (mcLexBuf_currenttoken-mcReserved_eoftok)) & ((SetOfStop0) ((1 << (mcReserved_periodtok-mcReserved_eoftok)) | (1 << (mcReserved_lsbratok-mcReserved_eoftok)) | (1 << (mcReserved_uparrowtok-mcReserved_eoftok))))) != 0)))
    {
      SubDesignator (stopset0|(SetOfStop0) ((1 << (mcReserved_periodtok-mcReserved_eoftok)) | (1 << (mcReserved_lsbratok-mcReserved_eoftok)) | (1 << (mcReserved_uparrowtok-mcReserved_eoftok))), stopset1, stopset2);
    }
   /* while  */
}


/*
   ActualParameters := '(' 
                       % VAR n: node ;  %
                       
                       % n := push (makeExpList ())  %
                       [ ExpList  ] ')' 
                       % assert (isExpList (peep ()))  %
                       

   first  symbols:lparatok
   
   cannot reachend
*/

static void ActualParameters (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  decl_node n;

  Expect ((mcReserved_toktype) mcReserved_lparatok, stopset0|(SetOfStop0) ((1 << (mcReserved_rparatok-mcReserved_eoftok)) | (1 << (mcReserved_plustok-mcReserved_eoftok)) | (1 << (mcReserved_minustok-mcReserved_eoftok)) | (1 << (mcReserved_lparatok-mcReserved_eoftok)) | (1 << (mcReserved_lcbratok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_nottok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_realtok-mcReserved_recordtok)) | (1 << (mcReserved_integertok-mcReserved_recordtok)) | (1 << (mcReserved_stringtok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok))));
  n = push (decl_makeExpList ());
  if ((((mcLexBuf_currenttoken < mcReserved_arraytok) && ((((1 << (mcLexBuf_currenttoken-mcReserved_eoftok)) & ((SetOfStop0) ((1 << (mcReserved_minustok-mcReserved_eoftok)) | (1 << (mcReserved_plustok-mcReserved_eoftok)) | (1 << (mcReserved_lparatok-mcReserved_eoftok)) | (1 << (mcReserved_lcbratok-mcReserved_eoftok))))) != 0))) || (mcLexBuf_currenttoken == mcReserved_nottok)) || ((mcLexBuf_currenttoken >= mcReserved_recordtok) && ((((1 << (mcLexBuf_currenttoken-mcReserved_recordtok)) & ((SetOfStop2) ((1 << (mcReserved_stringtok-mcReserved_recordtok)) | (1 << (mcReserved_integertok-mcReserved_recordtok)) | (1 << (mcReserved_realtok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok))))) != 0))))
    {
      ExpList (stopset0|(SetOfStop0) ((1 << (mcReserved_rparatok-mcReserved_eoftok))), stopset1, stopset2);
    }
  Expect ((mcReserved_toktype) mcReserved_rparatok, stopset0, stopset1, stopset2);
  mcDebug_assert (decl_isExpList (peep ()));
}


/*
   ExitStatement := 
                    % VAR n: node ;  %
                    'EXIT' 
                    % IF loopNo = 0
                      THEN
                         ErrorArray ('EXIT can only be used inside a LOOP statement')
                      ELSE
                         n := pushStmt (makeExit (peepLoop (), loopNo))
                      END  %
                    

   first  symbols:exittok
   
   cannot reachend
*/

static void ExitStatement (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  decl_node n;

  Expect ((mcReserved_toktype) mcReserved_exittok, stopset0, stopset1, stopset2);
  if (loopNo == 0)
    {
      ErrorArray ((char *) "EXIT can only be used inside a LOOP statement", 45);
    }
  else
    {
      n = pushStmt (decl_makeExit (peepLoop (), loopNo));
    }
}


/*
   ReturnStatement := 
                      % VAR n: node ;  %
                      
                      % n := pushStmt (makeReturn ())  %
                      'RETURN' [ Expression 
                                 % putReturn (n, pop ())  %
                                  ] 
                      % addCommentBody (peepStmt ())  %
                      
                      % addCommentAfter (peepStmt ())  %
                      
                      % assert (isReturn (peepStmt ()))  %
                      

   first  symbols:returntok
   
   cannot reachend
*/

static void ReturnStatement (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  decl_node n;

  n = pushStmt (decl_makeReturn ());
  Expect ((mcReserved_toktype) mcReserved_returntok, stopset0|(SetOfStop0) ((1 << (mcReserved_minustok-mcReserved_eoftok)) | (1 << (mcReserved_plustok-mcReserved_eoftok)) | (1 << (mcReserved_lparatok-mcReserved_eoftok)) | (1 << (mcReserved_lcbratok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_nottok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_stringtok-mcReserved_recordtok)) | (1 << (mcReserved_integertok-mcReserved_recordtok)) | (1 << (mcReserved_realtok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok))));
  if ((((mcLexBuf_currenttoken < mcReserved_arraytok) && ((((1 << (mcLexBuf_currenttoken-mcReserved_eoftok)) & ((SetOfStop0) ((1 << (mcReserved_plustok-mcReserved_eoftok)) | (1 << (mcReserved_minustok-mcReserved_eoftok)) | (1 << (mcReserved_lparatok-mcReserved_eoftok)) | (1 << (mcReserved_lcbratok-mcReserved_eoftok))))) != 0))) || (mcLexBuf_currenttoken == mcReserved_nottok)) || ((mcLexBuf_currenttoken >= mcReserved_recordtok) && ((((1 << (mcLexBuf_currenttoken-mcReserved_recordtok)) & ((SetOfStop2) ((1 << (mcReserved_realtok-mcReserved_recordtok)) | (1 << (mcReserved_integertok-mcReserved_recordtok)) | (1 << (mcReserved_stringtok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok))))) != 0))))
    {
      Expression (stopset0, stopset1, stopset2);
      decl_putReturn (n, pop ());
    }
  decl_addCommentBody (peepStmt ());
  decl_addCommentAfter (peepStmt ());
  mcDebug_assert (decl_isReturn (peepStmt ()));
}


/*
   Statement := ( AssignmentOrProcedureCall  | 
                  IfStatement  | CaseStatement  | 
                  WhileStatement  | RepeatStatement  | 
                  LoopStatement  | ForStatement  | 
                  WithStatement  | AsmStatement  | 
                  ExitStatement  | ReturnStatement  | 
                  RetryStatement  | 
                  % VAR s: node ;  %
                  
                  % s := pushStmt (NIL)  %
                   ) 

   first  symbols:identtok, retrytok, asmtok, withtok, fortok, looptok, repeattok, whiletok, casetok, iftok, returntok, exittok
   
   reachend
*/

static void Statement (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  decl_node s;

  if (mcLexBuf_currenttoken == mcReserved_identtok)
    {
      AssignmentOrProcedureCall (stopset0, stopset1, stopset2);
    }
  else if (mcLexBuf_currenttoken == mcReserved_iftok)
    {
      /* avoid dangling else.  */
      IfStatement (stopset0, stopset1, stopset2);
    }
  else if (mcLexBuf_currenttoken == mcReserved_casetok)
    {
      /* avoid dangling else.  */
      CaseStatement (stopset0, stopset1, stopset2);
    }
  else if (mcLexBuf_currenttoken == mcReserved_whiletok)
    {
      /* avoid dangling else.  */
      WhileStatement (stopset0, stopset1, stopset2);
    }
  else if (mcLexBuf_currenttoken == mcReserved_repeattok)
    {
      /* avoid dangling else.  */
      RepeatStatement (stopset0, stopset1, stopset2);
    }
  else if (mcLexBuf_currenttoken == mcReserved_looptok)
    {
      /* avoid dangling else.  */
      LoopStatement (stopset0, stopset1, stopset2);
    }
  else if (mcLexBuf_currenttoken == mcReserved_fortok)
    {
      /* avoid dangling else.  */
      ForStatement (stopset0, stopset1, stopset2);
    }
  else if (mcLexBuf_currenttoken == mcReserved_withtok)
    {
      /* avoid dangling else.  */
      WithStatement (stopset0, stopset1, stopset2);
    }
  else if (mcLexBuf_currenttoken == mcReserved_asmtok)
    {
      /* avoid dangling else.  */
      AsmStatement (stopset0, stopset1, stopset2);
    }
  else if (mcLexBuf_currenttoken == mcReserved_exittok)
    {
      /* avoid dangling else.  */
      ExitStatement (stopset0, stopset1, stopset2);
    }
  else if (mcLexBuf_currenttoken == mcReserved_returntok)
    {
      /* avoid dangling else.  */
      ReturnStatement (stopset0, stopset1, stopset2);
    }
  else if (mcLexBuf_currenttoken == mcReserved_retrytok)
    {
      /* avoid dangling else.  */
      RetryStatement (stopset0, stopset1, stopset2);
    }
  else
    {
      /* avoid dangling else.  */
      s = pushStmt ((decl_node) NULL);
    }
}


/*
   RetryStatement := 
                     % VAR s: node ;  %
                     
                     % s := pushStmt (makeComment ("retry"))  %
                     'RETRY' 

   first  symbols:retrytok
   
   cannot reachend
*/

static void RetryStatement (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  decl_node s;

  s = pushStmt (decl_makeComment ((char *) "retry", 5));
  Expect ((mcReserved_toktype) mcReserved_retrytok, stopset0, stopset1, stopset2);
}


/*
   AssignmentOrProcedureCall := 
                                % VAR d, a, p: node ;  %
                                Designator 
                                % d := pop ()  %
                                ( ':=' Expression 
                                  % a := pushStmt (makeAssignment (d, pop ()))  %
                                   | ActualParameters 
                                  % a := pushStmt (makeFuncCall (d, pop ()))  %
                                   | 
                                  % a := pushStmt (makeFuncCall (d, NIL))  %
                                   ) 
                                % addCommentBody (peepStmt ())  %
                                
                                % addCommentAfter (peepStmt ())  %
                                

   first  symbols:identtok
   
   cannot reachend
*/

static void AssignmentOrProcedureCall (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  decl_node d;
  decl_node a;
  decl_node p;

  Designator (stopset0|(SetOfStop0) ((1 << (mcReserved_becomestok-mcReserved_eoftok)) | (1 << (mcReserved_lparatok-mcReserved_eoftok))), stopset1, stopset2);
  d = pop ();
  if (mcLexBuf_currenttoken == mcReserved_becomestok)
    {
      Expect ((mcReserved_toktype) mcReserved_becomestok, stopset0|(SetOfStop0) ((1 << (mcReserved_minustok-mcReserved_eoftok)) | (1 << (mcReserved_plustok-mcReserved_eoftok)) | (1 << (mcReserved_lparatok-mcReserved_eoftok)) | (1 << (mcReserved_lcbratok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_nottok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_stringtok-mcReserved_recordtok)) | (1 << (mcReserved_integertok-mcReserved_recordtok)) | (1 << (mcReserved_realtok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok))));
      Expression (stopset0, stopset1, stopset2);
      a = pushStmt (decl_makeAssignment (d, pop ()));
    }
  else if (mcLexBuf_currenttoken == mcReserved_lparatok)
    {
      /* avoid dangling else.  */
      ActualParameters (stopset0, stopset1, stopset2);
      a = pushStmt (decl_makeFuncCall (d, pop ()));
    }
  else
    {
      /* avoid dangling else.  */
      a = pushStmt (decl_makeFuncCall (d, (decl_node) NULL));
    }
  decl_addCommentBody (peepStmt ());
  decl_addCommentAfter (peepStmt ());
}


/*
   StatementSequence := 
                        % VAR s, t: node ;  %
                        
                        % s := pushStmt (makeStatementSequence ())  %
                        
                        % assert (isStatementSequence (peepStmt ()))  %
                        Statement 
                        % addStatement (s, popStmt ())  %
                        
                        % assert (isStatementSequence (peepStmt ()))  %
                        { ';' Statement 
                          % addStatement (s, popStmt ())  %
                          
                          % assert (isStatementSequence (peepStmt ()))  %
                           } 

   first  symbols:identtok, iftok, casetok, whiletok, repeattok, looptok, fortok, withtok, asmtok, retrytok, semicolontok, exittok, returntok
   
   reachend
*/

static void StatementSequence (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  decl_node s;
  decl_node t;

  s = pushStmt (decl_makeStatementSequence ());
  mcDebug_assert (decl_isStatementSequence (peepStmt ()));
  Statement (stopset0|(SetOfStop0) ((1 << (mcReserved_semicolontok-mcReserved_eoftok))), stopset1, stopset2);
  decl_addStatement (s, popStmt ());
  mcDebug_assert (decl_isStatementSequence (peepStmt ()));
  while (mcLexBuf_currenttoken == mcReserved_semicolontok)
    {
      Expect ((mcReserved_toktype) mcReserved_semicolontok, stopset0|(SetOfStop0) ((1 << (mcReserved_semicolontok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_exittok-mcReserved_arraytok)) | (1 << (mcReserved_fortok-mcReserved_arraytok)) | (1 << (mcReserved_looptok-mcReserved_arraytok)) | (1 << (mcReserved_casetok-mcReserved_arraytok)) | (1 << (mcReserved_iftok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_returntok-mcReserved_recordtok)) | (1 << (mcReserved_retrytok-mcReserved_recordtok)) | (1 << (mcReserved_asmtok-mcReserved_recordtok)) | (1 << (mcReserved_withtok-mcReserved_recordtok)) | (1 << (mcReserved_repeattok-mcReserved_recordtok)) | (1 << (mcReserved_whiletok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok))));
      Statement (stopset0|(SetOfStop0) ((1 << (mcReserved_semicolontok-mcReserved_eoftok))), stopset1, stopset2);
      decl_addStatement (s, popStmt ());
      mcDebug_assert (decl_isStatementSequence (peepStmt ()));
    }
   /* while  */
}


/*
   IfStatement := 
                  % VAR i, a, b: node ;  %
                  'IF' 
                  % b := makeCommentS (getBodyComment ())  %
                  Expression 
                  % a := makeCommentS (getAfterComment ())  %
                  'THEN' StatementSequence 
                  % i := pushStmt (makeIf (pop (), popStmt ()))  %
                  
                  % addIfComments (i, b, a)  %
                  { 'ELSIF' 
                    % b := makeCommentS (getBodyComment ())  %
                    Expression 
                    % a := makeCommentS (getAfterComment ())  %
                    'THEN' 
                    % addElseComments (peepStmt (), b, a)  %
                    StatementSequence 
                    % i := makeElsif (i, pop (), popStmt ())  %
                     } [ 'ELSE' StatementSequence 
                         % putElse (i, popStmt ())  %
                          ] 'END' 
                  % b := makeCommentS (getBodyComment ())  %
                  
                  % a := makeCommentS (getAfterComment ())  %
                  
                  % assert (isIf (peepStmt ()))  %
                  
                  % addIfEndComments (peepStmt (), b, a)  %
                  

   first  symbols:iftok
   
   cannot reachend
*/

static void IfStatement (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  decl_node i;
  decl_node a;
  decl_node b;

  Expect ((mcReserved_toktype) mcReserved_iftok, stopset0|(SetOfStop0) ((1 << (mcReserved_minustok-mcReserved_eoftok)) | (1 << (mcReserved_plustok-mcReserved_eoftok)) | (1 << (mcReserved_lparatok-mcReserved_eoftok)) | (1 << (mcReserved_lcbratok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_nottok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_stringtok-mcReserved_recordtok)) | (1 << (mcReserved_integertok-mcReserved_recordtok)) | (1 << (mcReserved_realtok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok))));
  b = decl_makeCommentS (mcLexBuf_getBodyComment ());
  Expression (stopset0, stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_thentok-mcReserved_recordtok))));
  a = decl_makeCommentS (mcLexBuf_getAfterComment ());
  Expect ((mcReserved_toktype) mcReserved_thentok, stopset0|(SetOfStop0) ((1 << (mcReserved_semicolontok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_exittok-mcReserved_arraytok)) | (1 << (mcReserved_elsiftok-mcReserved_arraytok)) | (1 << (mcReserved_elsetok-mcReserved_arraytok)) | (1 << (mcReserved_endtok-mcReserved_arraytok)) | (1 << (mcReserved_iftok-mcReserved_arraytok)) | (1 << (mcReserved_casetok-mcReserved_arraytok)) | (1 << (mcReserved_looptok-mcReserved_arraytok)) | (1 << (mcReserved_fortok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_returntok-mcReserved_recordtok)) | (1 << (mcReserved_whiletok-mcReserved_recordtok)) | (1 << (mcReserved_repeattok-mcReserved_recordtok)) | (1 << (mcReserved_withtok-mcReserved_recordtok)) | (1 << (mcReserved_asmtok-mcReserved_recordtok)) | (1 << (mcReserved_retrytok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok))));
  StatementSequence (stopset0, stopset1|(SetOfStop1) ((1 << (mcReserved_elsiftok-mcReserved_arraytok)) | (1 << (mcReserved_elsetok-mcReserved_arraytok)) | (1 << (mcReserved_endtok-mcReserved_arraytok))), stopset2);
  i = pushStmt (decl_makeIf (pop (), popStmt ()));
  decl_addIfComments (i, b, a);
  while (mcLexBuf_currenttoken == mcReserved_elsiftok)
    {
      Expect ((mcReserved_toktype) mcReserved_elsiftok, stopset0|(SetOfStop0) ((1 << (mcReserved_minustok-mcReserved_eoftok)) | (1 << (mcReserved_plustok-mcReserved_eoftok)) | (1 << (mcReserved_lparatok-mcReserved_eoftok)) | (1 << (mcReserved_lcbratok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_nottok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_stringtok-mcReserved_recordtok)) | (1 << (mcReserved_integertok-mcReserved_recordtok)) | (1 << (mcReserved_realtok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok))));
      b = decl_makeCommentS (mcLexBuf_getBodyComment ());
      Expression (stopset0, stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_thentok-mcReserved_recordtok))));
      a = decl_makeCommentS (mcLexBuf_getAfterComment ());
      Expect ((mcReserved_toktype) mcReserved_thentok, stopset0|(SetOfStop0) ((1 << (mcReserved_semicolontok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_exittok-mcReserved_arraytok)) | (1 << (mcReserved_endtok-mcReserved_arraytok)) | (1 << (mcReserved_elsetok-mcReserved_arraytok)) | (1 << (mcReserved_elsiftok-mcReserved_arraytok)) | (1 << (mcReserved_iftok-mcReserved_arraytok)) | (1 << (mcReserved_casetok-mcReserved_arraytok)) | (1 << (mcReserved_looptok-mcReserved_arraytok)) | (1 << (mcReserved_fortok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_returntok-mcReserved_recordtok)) | (1 << (mcReserved_whiletok-mcReserved_recordtok)) | (1 << (mcReserved_repeattok-mcReserved_recordtok)) | (1 << (mcReserved_withtok-mcReserved_recordtok)) | (1 << (mcReserved_asmtok-mcReserved_recordtok)) | (1 << (mcReserved_retrytok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok))));
      decl_addElseComments (peepStmt (), b, a);
      StatementSequence (stopset0, stopset1|(SetOfStop1) ((1 << (mcReserved_endtok-mcReserved_arraytok)) | (1 << (mcReserved_elsetok-mcReserved_arraytok)) | (1 << (mcReserved_elsiftok-mcReserved_arraytok))), stopset2);
      i = decl_makeElsif (i, pop (), popStmt ());
    }
   /* while  */
  if (mcLexBuf_currenttoken == mcReserved_elsetok)
    {
      Expect ((mcReserved_toktype) mcReserved_elsetok, stopset0|(SetOfStop0) ((1 << (mcReserved_semicolontok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_exittok-mcReserved_arraytok)) | (1 << (mcReserved_endtok-mcReserved_arraytok)) | (1 << (mcReserved_iftok-mcReserved_arraytok)) | (1 << (mcReserved_casetok-mcReserved_arraytok)) | (1 << (mcReserved_looptok-mcReserved_arraytok)) | (1 << (mcReserved_fortok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_returntok-mcReserved_recordtok)) | (1 << (mcReserved_whiletok-mcReserved_recordtok)) | (1 << (mcReserved_repeattok-mcReserved_recordtok)) | (1 << (mcReserved_withtok-mcReserved_recordtok)) | (1 << (mcReserved_asmtok-mcReserved_recordtok)) | (1 << (mcReserved_retrytok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok))));
      StatementSequence (stopset0, stopset1|(SetOfStop1) ((1 << (mcReserved_endtok-mcReserved_arraytok))), stopset2);
      decl_putElse (i, popStmt ());
    }
  Expect ((mcReserved_toktype) mcReserved_endtok, stopset0, stopset1, stopset2);
  b = decl_makeCommentS (mcLexBuf_getBodyComment ());
  a = decl_makeCommentS (mcLexBuf_getAfterComment ());
  mcDebug_assert (decl_isIf (peepStmt ()));
  decl_addIfEndComments (peepStmt (), b, a);
}


/*
   CaseStatement := 
                    % VAR s, e: node ;  %
                    
                    % s := pushStmt (makeCase ())  %
                    'CASE' Expression 
                    % s := putCaseExpression (s, pop ())  %
                    'OF' Case { '|' Case  } CaseEndStatement 

   first  symbols:casetok
   
   cannot reachend
*/

static void CaseStatement (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  decl_node s;
  decl_node e;

  s = pushStmt (decl_makeCase ());
  Expect ((mcReserved_toktype) mcReserved_casetok, stopset0|(SetOfStop0) ((1 << (mcReserved_minustok-mcReserved_eoftok)) | (1 << (mcReserved_plustok-mcReserved_eoftok)) | (1 << (mcReserved_lparatok-mcReserved_eoftok)) | (1 << (mcReserved_lcbratok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_nottok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_stringtok-mcReserved_recordtok)) | (1 << (mcReserved_integertok-mcReserved_recordtok)) | (1 << (mcReserved_realtok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok))));
  Expression (stopset0, stopset1|(SetOfStop1) ((1 << (mcReserved_oftok-mcReserved_arraytok))), stopset2);
  s = decl_putCaseExpression (s, pop ());
  Expect ((mcReserved_toktype) mcReserved_oftok, stopset0|(SetOfStop0) ((1 << (mcReserved_bartok-mcReserved_eoftok)) | (1 << (mcReserved_plustok-mcReserved_eoftok)) | (1 << (mcReserved_minustok-mcReserved_eoftok)) | (1 << (mcReserved_lparatok-mcReserved_eoftok)) | (1 << (mcReserved_lcbratok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_elsetok-mcReserved_arraytok)) | (1 << (mcReserved_endtok-mcReserved_arraytok)) | (1 << (mcReserved_nottok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_realtok-mcReserved_recordtok)) | (1 << (mcReserved_integertok-mcReserved_recordtok)) | (1 << (mcReserved_stringtok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok)) | (1 << (mcReserved_attributetok-mcReserved_recordtok))));
  Case (stopset0|(SetOfStop0) ((1 << (mcReserved_bartok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_elsetok-mcReserved_arraytok)) | (1 << (mcReserved_endtok-mcReserved_arraytok))), stopset2);
  while (mcLexBuf_currenttoken == mcReserved_bartok)
    {
      Expect ((mcReserved_toktype) mcReserved_bartok, stopset0|(SetOfStop0) ((1 << (mcReserved_bartok-mcReserved_eoftok)) | (1 << (mcReserved_plustok-mcReserved_eoftok)) | (1 << (mcReserved_minustok-mcReserved_eoftok)) | (1 << (mcReserved_lparatok-mcReserved_eoftok)) | (1 << (mcReserved_lcbratok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_endtok-mcReserved_arraytok)) | (1 << (mcReserved_elsetok-mcReserved_arraytok)) | (1 << (mcReserved_nottok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_realtok-mcReserved_recordtok)) | (1 << (mcReserved_integertok-mcReserved_recordtok)) | (1 << (mcReserved_stringtok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok)) | (1 << (mcReserved_attributetok-mcReserved_recordtok))));
      Case (stopset0|(SetOfStop0) ((1 << (mcReserved_bartok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_endtok-mcReserved_arraytok)) | (1 << (mcReserved_elsetok-mcReserved_arraytok))), stopset2);
    }
   /* while  */
  CaseEndStatement (stopset0, stopset1, stopset2);
}


/*
   CaseEndStatement := 
                       % VAR c: node ;  %
                       'END'  | 'ELSE' 
                       % c := peepStmt ()  %
                       StatementSequence 
                       % c := putCaseElse (c, popStmt ())  %
                       'END' 

   first  symbols:elsetok, endtok
   
   cannot reachend
*/

static void CaseEndStatement (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  decl_node c;

  if (mcLexBuf_currenttoken == mcReserved_endtok)
    {
      Expect ((mcReserved_toktype) mcReserved_endtok, stopset0, stopset1, stopset2);
    }
  else if (mcLexBuf_currenttoken == mcReserved_elsetok)
    {
      /* avoid dangling else.  */
      Expect ((mcReserved_toktype) mcReserved_elsetok, stopset0|(SetOfStop0) ((1 << (mcReserved_semicolontok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_exittok-mcReserved_arraytok)) | (1 << (mcReserved_endtok-mcReserved_arraytok)) | (1 << (mcReserved_iftok-mcReserved_arraytok)) | (1 << (mcReserved_casetok-mcReserved_arraytok)) | (1 << (mcReserved_looptok-mcReserved_arraytok)) | (1 << (mcReserved_fortok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_returntok-mcReserved_recordtok)) | (1 << (mcReserved_whiletok-mcReserved_recordtok)) | (1 << (mcReserved_repeattok-mcReserved_recordtok)) | (1 << (mcReserved_withtok-mcReserved_recordtok)) | (1 << (mcReserved_asmtok-mcReserved_recordtok)) | (1 << (mcReserved_retrytok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok))));
      c = peepStmt ();
      StatementSequence (stopset0, stopset1|(SetOfStop1) ((1 << (mcReserved_endtok-mcReserved_arraytok))), stopset2);
      c = decl_putCaseElse (c, popStmt ());
      Expect ((mcReserved_toktype) mcReserved_endtok, stopset0, stopset1, stopset2);
    }
  else
    {
      /* avoid dangling else.  */
      ErrorArray ((char *) "expecting one of: ELSE END", 26);
    }
}


/*
   Case := [ CaseLabelList ':' 
             % VAR l, c: node ;  %
             
             % l := pop ()  %
             
             % c := peepStmt ()  %
             StatementSequence 
             % c := putCaseStatement (c, l, popStmt ())  %
              ] 

   first  symbols:stringtok, lcbratok, identtok, attributetok, realtok, integertok, lparatok, nottok, plustok, minustok
   
   reachend
*/

static void Case (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  decl_node l;
  decl_node c;

  if ((((mcLexBuf_currenttoken < mcReserved_arraytok) && ((((1 << (mcLexBuf_currenttoken-mcReserved_eoftok)) & ((SetOfStop0) ((1 << (mcReserved_plustok-mcReserved_eoftok)) | (1 << (mcReserved_minustok-mcReserved_eoftok)) | (1 << (mcReserved_lparatok-mcReserved_eoftok)) | (1 << (mcReserved_lcbratok-mcReserved_eoftok))))) != 0))) || (mcLexBuf_currenttoken == mcReserved_nottok)) || ((mcLexBuf_currenttoken >= mcReserved_recordtok) && ((((1 << (mcLexBuf_currenttoken-mcReserved_recordtok)) & ((SetOfStop2) ((1 << (mcReserved_realtok-mcReserved_recordtok)) | (1 << (mcReserved_integertok-mcReserved_recordtok)) | (1 << (mcReserved_stringtok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok)) | (1 << (mcReserved_attributetok-mcReserved_recordtok))))) != 0))))
    {
      CaseLabelList (stopset0|(SetOfStop0) ((1 << (mcReserved_colontok-mcReserved_eoftok))), stopset1, stopset2);
      Expect ((mcReserved_toktype) mcReserved_colontok, stopset0|(SetOfStop0) ((1 << (mcReserved_semicolontok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_exittok-mcReserved_arraytok)) | (1 << (mcReserved_iftok-mcReserved_arraytok)) | (1 << (mcReserved_casetok-mcReserved_arraytok)) | (1 << (mcReserved_looptok-mcReserved_arraytok)) | (1 << (mcReserved_fortok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_returntok-mcReserved_recordtok)) | (1 << (mcReserved_whiletok-mcReserved_recordtok)) | (1 << (mcReserved_repeattok-mcReserved_recordtok)) | (1 << (mcReserved_withtok-mcReserved_recordtok)) | (1 << (mcReserved_asmtok-mcReserved_recordtok)) | (1 << (mcReserved_retrytok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok))));
      l = pop ();
      c = peepStmt ();
      StatementSequence (stopset0, stopset1, stopset2);
      c = decl_putCaseStatement (c, l, popStmt ());
    }
}


/*
   CaseLabelList := 
                    % VAR l: node ;  %
                    
                    % l := push (makeCaseList ())  %
                    CaseLabels { ',' CaseLabels  } 

   first  symbols:attributetok, identtok, lcbratok, stringtok, nottok, lparatok, integertok, realtok, minustok, plustok
   
   cannot reachend
*/

static void CaseLabelList (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  decl_node l;

  l = push (decl_makeCaseList ());
  CaseLabels (stopset0|(SetOfStop0) ((1 << (mcReserved_commatok-mcReserved_eoftok))), stopset1, stopset2);
  while (mcLexBuf_currenttoken == mcReserved_commatok)
    {
      Expect ((mcReserved_toktype) mcReserved_commatok, stopset0|(SetOfStop0) ((1 << (mcReserved_plustok-mcReserved_eoftok)) | (1 << (mcReserved_minustok-mcReserved_eoftok)) | (1 << (mcReserved_lparatok-mcReserved_eoftok)) | (1 << (mcReserved_lcbratok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_nottok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_realtok-mcReserved_recordtok)) | (1 << (mcReserved_integertok-mcReserved_recordtok)) | (1 << (mcReserved_stringtok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok)) | (1 << (mcReserved_attributetok-mcReserved_recordtok))));
      CaseLabels (stopset0|(SetOfStop0) ((1 << (mcReserved_commatok-mcReserved_eoftok))), stopset1, stopset2);
    }
   /* while  */
}


/*
   CaseLabels := 
                 % VAR lo, hi, l: node ;  %
                 
                 % lo := NIL ; hi := NIL  %
                 
                 % l := peep ()  %
                 ConstExpression 
                 % lo := pop ()  %
                 [ '..' ConstExpression 
                   % hi := pop ()  %
                    ] 
                 % l := putCaseRange (l, lo, hi)  %
                 

   first  symbols:stringtok, lcbratok, identtok, attributetok, realtok, integertok, lparatok, nottok, plustok, minustok
   
   cannot reachend
*/

static void CaseLabels (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  decl_node lo;
  decl_node hi;
  decl_node l;

  lo = NULL;
  hi = NULL;
  l = peep ();
  ConstExpression (stopset0|(SetOfStop0) ((1 << (mcReserved_periodperiodtok-mcReserved_eoftok))), stopset1, stopset2);
  lo = pop ();
  if (mcLexBuf_currenttoken == mcReserved_periodperiodtok)
    {
      Expect ((mcReserved_toktype) mcReserved_periodperiodtok, stopset0|(SetOfStop0) ((1 << (mcReserved_minustok-mcReserved_eoftok)) | (1 << (mcReserved_plustok-mcReserved_eoftok)) | (1 << (mcReserved_lparatok-mcReserved_eoftok)) | (1 << (mcReserved_lcbratok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_nottok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_integertok-mcReserved_recordtok)) | (1 << (mcReserved_realtok-mcReserved_recordtok)) | (1 << (mcReserved_attributetok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok)) | (1 << (mcReserved_stringtok-mcReserved_recordtok))));
      ConstExpression (stopset0, stopset1, stopset2);
      hi = pop ();
    }
  l = decl_putCaseRange (l, lo, hi);
}


/*
   WhileStatement := 
                     % VAR s, w, e, a, b: node ;  %
                     
                     % w := pushStmt (makeWhile ())  %
                     'WHILE' Expression 'DO' 
                     % b := makeCommentS (getBodyComment ())  %
                     
                     % a := makeCommentS (getAfterComment ())  %
                     
                     % addWhileDoComment (w, b, a)  %
                     
                     % e := pop ()  %
                     StatementSequence 
                     % s := popStmt ()  %
                     'END' 
                     %  assert (isStatementSequence (peepStmt ()))   %
                     
                     % putWhile (w, e, s)  %
                     
                     % b := makeCommentS (getBodyComment ())  %
                     
                     % a := makeCommentS (getAfterComment ())  %
                     
                     % addWhileEndComment (w, b, a)  %
                     

   first  symbols:whiletok
   
   cannot reachend
*/

static void WhileStatement (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  decl_node s;
  decl_node w;
  decl_node e;
  decl_node a;
  decl_node b;

  w = pushStmt (decl_makeWhile ());
  Expect ((mcReserved_toktype) mcReserved_whiletok, stopset0|(SetOfStop0) ((1 << (mcReserved_minustok-mcReserved_eoftok)) | (1 << (mcReserved_plustok-mcReserved_eoftok)) | (1 << (mcReserved_lparatok-mcReserved_eoftok)) | (1 << (mcReserved_lcbratok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_nottok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_stringtok-mcReserved_recordtok)) | (1 << (mcReserved_integertok-mcReserved_recordtok)) | (1 << (mcReserved_realtok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok))));
  Expression (stopset0, stopset1|(SetOfStop1) ((1 << (mcReserved_dotok-mcReserved_arraytok))), stopset2);
  Expect ((mcReserved_toktype) mcReserved_dotok, stopset0|(SetOfStop0) ((1 << (mcReserved_semicolontok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_exittok-mcReserved_arraytok)) | (1 << (mcReserved_endtok-mcReserved_arraytok)) | (1 << (mcReserved_iftok-mcReserved_arraytok)) | (1 << (mcReserved_casetok-mcReserved_arraytok)) | (1 << (mcReserved_looptok-mcReserved_arraytok)) | (1 << (mcReserved_fortok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_returntok-mcReserved_recordtok)) | (1 << (mcReserved_whiletok-mcReserved_recordtok)) | (1 << (mcReserved_repeattok-mcReserved_recordtok)) | (1 << (mcReserved_withtok-mcReserved_recordtok)) | (1 << (mcReserved_asmtok-mcReserved_recordtok)) | (1 << (mcReserved_retrytok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok))));
  b = decl_makeCommentS (mcLexBuf_getBodyComment ());
  a = decl_makeCommentS (mcLexBuf_getAfterComment ());
  decl_addWhileDoComment (w, b, a);
  e = pop ();
  StatementSequence (stopset0, stopset1|(SetOfStop1) ((1 << (mcReserved_endtok-mcReserved_arraytok))), stopset2);
  s = popStmt ();
  Expect ((mcReserved_toktype) mcReserved_endtok, stopset0, stopset1, stopset2);
  /* assert (isStatementSequence (peepStmt ()))  */
  decl_putWhile (w, e, s);
  b = decl_makeCommentS (mcLexBuf_getBodyComment ());
  a = decl_makeCommentS (mcLexBuf_getAfterComment ());
  decl_addWhileEndComment (w, b, a);
}


/*
   RepeatStatement := 
                      % VAR r, s, a, b: node ;  %
                      
                      % r := pushStmt (makeRepeat ())  %
                      'REPEAT' 
                      % b := makeCommentS (getBodyComment ())  %
                      
                      % a := makeCommentS (getAfterComment ())  %
                      
                      % addRepeatComment (r, b, a)  %
                      StatementSequence 
                      % s := popStmt ()  %
                      'UNTIL' Expression 
                      % putRepeat (r, s, pop ())  %
                      
                      % b := makeCommentS (getBodyComment ())  %
                      
                      % a := makeCommentS (getAfterComment ())  %
                      
                      % addUntilComment (r, b, a)  %
                      

   first  symbols:repeattok
   
   cannot reachend
*/

static void RepeatStatement (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  decl_node r;
  decl_node s;
  decl_node a;
  decl_node b;

  r = pushStmt (decl_makeRepeat ());
  Expect ((mcReserved_toktype) mcReserved_repeattok, stopset0|(SetOfStop0) ((1 << (mcReserved_semicolontok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_exittok-mcReserved_arraytok)) | (1 << (mcReserved_iftok-mcReserved_arraytok)) | (1 << (mcReserved_casetok-mcReserved_arraytok)) | (1 << (mcReserved_looptok-mcReserved_arraytok)) | (1 << (mcReserved_fortok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_returntok-mcReserved_recordtok)) | (1 << (mcReserved_untiltok-mcReserved_recordtok)) | (1 << (mcReserved_whiletok-mcReserved_recordtok)) | (1 << (mcReserved_repeattok-mcReserved_recordtok)) | (1 << (mcReserved_withtok-mcReserved_recordtok)) | (1 << (mcReserved_asmtok-mcReserved_recordtok)) | (1 << (mcReserved_retrytok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok))));
  b = decl_makeCommentS (mcLexBuf_getBodyComment ());
  a = decl_makeCommentS (mcLexBuf_getAfterComment ());
  decl_addRepeatComment (r, b, a);
  StatementSequence (stopset0, stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_untiltok-mcReserved_recordtok))));
  s = popStmt ();
  Expect ((mcReserved_toktype) mcReserved_untiltok, stopset0|(SetOfStop0) ((1 << (mcReserved_minustok-mcReserved_eoftok)) | (1 << (mcReserved_plustok-mcReserved_eoftok)) | (1 << (mcReserved_lparatok-mcReserved_eoftok)) | (1 << (mcReserved_lcbratok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_nottok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_stringtok-mcReserved_recordtok)) | (1 << (mcReserved_integertok-mcReserved_recordtok)) | (1 << (mcReserved_realtok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok))));
  Expression (stopset0, stopset1, stopset2);
  decl_putRepeat (r, s, pop ());
  b = decl_makeCommentS (mcLexBuf_getBodyComment ());
  a = decl_makeCommentS (mcLexBuf_getAfterComment ());
  decl_addUntilComment (r, b, a);
}


/*
   ForStatement := 
                   % VAR f, i, s, e, b: node ;  %
                   
                   % b := NIL  %
                   
                   % f := pushStmt (makeFor ())  %
                   'FOR' Ident 
                   % i := lookupWithSym (curident)  %
                   ':=' Expression 
                   % s := pop ()  %
                   'TO' Expression 
                   % e := pop ()  %
                   [ 'BY' ConstExpression 
                     % b := pop ()  %
                      ] 'DO' StatementSequence 
                   % putFor (f, i, s, e, b, popStmt ())  %
                   'END' 

   first  symbols:fortok
   
   cannot reachend
*/

static void ForStatement (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  decl_node f;
  decl_node i;
  decl_node s;
  decl_node e;
  decl_node b;

  b = NULL;
  f = pushStmt (decl_makeFor ());
  Expect ((mcReserved_toktype) mcReserved_fortok, stopset0, stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_identtok-mcReserved_recordtok))));
  Ident (stopset0|(SetOfStop0) ((1 << (mcReserved_becomestok-mcReserved_eoftok))), stopset1, stopset2);
  i = lookupWithSym (curident);
  Expect ((mcReserved_toktype) mcReserved_becomestok, stopset0|(SetOfStop0) ((1 << (mcReserved_minustok-mcReserved_eoftok)) | (1 << (mcReserved_plustok-mcReserved_eoftok)) | (1 << (mcReserved_lparatok-mcReserved_eoftok)) | (1 << (mcReserved_lcbratok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_nottok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_stringtok-mcReserved_recordtok)) | (1 << (mcReserved_integertok-mcReserved_recordtok)) | (1 << (mcReserved_realtok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok))));
  Expression (stopset0, stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_totok-mcReserved_recordtok))));
  s = pop ();
  Expect ((mcReserved_toktype) mcReserved_totok, stopset0|(SetOfStop0) ((1 << (mcReserved_minustok-mcReserved_eoftok)) | (1 << (mcReserved_plustok-mcReserved_eoftok)) | (1 << (mcReserved_lparatok-mcReserved_eoftok)) | (1 << (mcReserved_lcbratok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_nottok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_stringtok-mcReserved_recordtok)) | (1 << (mcReserved_integertok-mcReserved_recordtok)) | (1 << (mcReserved_realtok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok))));
  Expression (stopset0, stopset1|(SetOfStop1) ((1 << (mcReserved_bytok-mcReserved_arraytok)) | (1 << (mcReserved_dotok-mcReserved_arraytok))), stopset2);
  e = pop ();
  if (mcLexBuf_currenttoken == mcReserved_bytok)
    {
      Expect ((mcReserved_toktype) mcReserved_bytok, stopset0|(SetOfStop0) ((1 << (mcReserved_minustok-mcReserved_eoftok)) | (1 << (mcReserved_plustok-mcReserved_eoftok)) | (1 << (mcReserved_lparatok-mcReserved_eoftok)) | (1 << (mcReserved_lcbratok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_nottok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_integertok-mcReserved_recordtok)) | (1 << (mcReserved_realtok-mcReserved_recordtok)) | (1 << (mcReserved_attributetok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok)) | (1 << (mcReserved_stringtok-mcReserved_recordtok))));
      ConstExpression (stopset0, stopset1|(SetOfStop1) ((1 << (mcReserved_dotok-mcReserved_arraytok))), stopset2);
      b = pop ();
    }
  Expect ((mcReserved_toktype) mcReserved_dotok, stopset0|(SetOfStop0) ((1 << (mcReserved_semicolontok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_exittok-mcReserved_arraytok)) | (1 << (mcReserved_endtok-mcReserved_arraytok)) | (1 << (mcReserved_iftok-mcReserved_arraytok)) | (1 << (mcReserved_casetok-mcReserved_arraytok)) | (1 << (mcReserved_looptok-mcReserved_arraytok)) | (1 << (mcReserved_fortok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_returntok-mcReserved_recordtok)) | (1 << (mcReserved_whiletok-mcReserved_recordtok)) | (1 << (mcReserved_repeattok-mcReserved_recordtok)) | (1 << (mcReserved_withtok-mcReserved_recordtok)) | (1 << (mcReserved_asmtok-mcReserved_recordtok)) | (1 << (mcReserved_retrytok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok))));
  StatementSequence (stopset0, stopset1|(SetOfStop1) ((1 << (mcReserved_endtok-mcReserved_arraytok))), stopset2);
  decl_putFor (f, i, s, e, b, popStmt ());
  Expect ((mcReserved_toktype) mcReserved_endtok, stopset0, stopset1, stopset2);
}


/*
   LoopStatement := 
                    % VAR l, s: node ;  %
                    'LOOP' 
                    % l := pushStmt (pushLoop (makeLoop ()))  %
                    
                    % INC (loopNo)  %
                    StatementSequence 
                    % s := popStmt ()  %
                    
                    % putLoop (l, s)  %
                    
                    % DEC (loopNo)  %
                    'END' 
                    % l := popLoop ()  %
                    
                    % assert (isLoop (peepStmt ()))  %
                    

   first  symbols:looptok
   
   cannot reachend
*/

static void LoopStatement (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  decl_node l;
  decl_node s;

  Expect ((mcReserved_toktype) mcReserved_looptok, stopset0|(SetOfStop0) ((1 << (mcReserved_semicolontok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_exittok-mcReserved_arraytok)) | (1 << (mcReserved_endtok-mcReserved_arraytok)) | (1 << (mcReserved_iftok-mcReserved_arraytok)) | (1 << (mcReserved_casetok-mcReserved_arraytok)) | (1 << (mcReserved_looptok-mcReserved_arraytok)) | (1 << (mcReserved_fortok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_returntok-mcReserved_recordtok)) | (1 << (mcReserved_whiletok-mcReserved_recordtok)) | (1 << (mcReserved_repeattok-mcReserved_recordtok)) | (1 << (mcReserved_withtok-mcReserved_recordtok)) | (1 << (mcReserved_asmtok-mcReserved_recordtok)) | (1 << (mcReserved_retrytok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok))));
  l = pushStmt (pushLoop (decl_makeLoop ()));
  loopNo += 1;
  StatementSequence (stopset0, stopset1|(SetOfStop1) ((1 << (mcReserved_endtok-mcReserved_arraytok))), stopset2);
  s = popStmt ();
  decl_putLoop (l, s);
  loopNo -= 1;
  Expect ((mcReserved_toktype) mcReserved_endtok, stopset0, stopset1, stopset2);
  l = popLoop ();
  mcDebug_assert (decl_isLoop (peepStmt ()));
}


/*
   WithStatement := 'WITH' Designator 'DO' 
                    % startWith (pop ())  %
                    StatementSequence 'END' 
                    % endWith  %
                    

   first  symbols:withtok
   
   cannot reachend
*/

static void WithStatement (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  Expect ((mcReserved_toktype) mcReserved_withtok, stopset0, stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_identtok-mcReserved_recordtok))));
  Designator (stopset0, stopset1|(SetOfStop1) ((1 << (mcReserved_dotok-mcReserved_arraytok))), stopset2);
  Expect ((mcReserved_toktype) mcReserved_dotok, stopset0|(SetOfStop0) ((1 << (mcReserved_semicolontok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_exittok-mcReserved_arraytok)) | (1 << (mcReserved_endtok-mcReserved_arraytok)) | (1 << (mcReserved_iftok-mcReserved_arraytok)) | (1 << (mcReserved_casetok-mcReserved_arraytok)) | (1 << (mcReserved_looptok-mcReserved_arraytok)) | (1 << (mcReserved_fortok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_returntok-mcReserved_recordtok)) | (1 << (mcReserved_whiletok-mcReserved_recordtok)) | (1 << (mcReserved_repeattok-mcReserved_recordtok)) | (1 << (mcReserved_withtok-mcReserved_recordtok)) | (1 << (mcReserved_asmtok-mcReserved_recordtok)) | (1 << (mcReserved_retrytok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok))));
  startWith (pop ());
  StatementSequence (stopset0, stopset1|(SetOfStop1) ((1 << (mcReserved_endtok-mcReserved_arraytok))), stopset2);
  Expect ((mcReserved_toktype) mcReserved_endtok, stopset0, stopset1, stopset2);
  endWith ();
}


/*
   ProcedureDeclaration := ProcedureHeading ';' ProcedureBlock 
                           Ident 
                           % leaveScope  %
                           

   first  symbols:proceduretok
   
   cannot reachend
*/

static void ProcedureDeclaration (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  ProcedureHeading (stopset0|(SetOfStop0) ((1 << (mcReserved_semicolontok-mcReserved_eoftok))), stopset1, stopset2);
  Expect ((mcReserved_toktype) mcReserved_semicolontok, stopset0, stopset1|(SetOfStop1) ((1 << (mcReserved_endtok-mcReserved_arraytok)) | (1 << (mcReserved_begintok-mcReserved_arraytok)) | (1 << (mcReserved_consttok-mcReserved_arraytok)) | (1 << (mcReserved_proceduretok-mcReserved_arraytok)) | (1 << (mcReserved_moduletok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_typetok-mcReserved_recordtok)) | (1 << (mcReserved_vartok-mcReserved_recordtok))));
  ProcedureBlock (stopset0, stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_identtok-mcReserved_recordtok))));
  Ident (stopset0, stopset1, stopset2);
  decl_leaveScope ();
}


/*
   ProcedureIdent := Ident 
                     % curproc := lookupSym (curident)  %
                     
                     % enterScope (curproc)  %
                     
                     % setProcedureComment (lastcomment, curident)  %
                     

   first  symbols:identtok
   
   cannot reachend
*/

static void ProcedureIdent (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  Ident (stopset0, stopset1, stopset2);
  curproc = decl_lookupSym (curident);
  decl_enterScope (curproc);
  mcComment_setProcedureComment (mcLexBuf_lastcomment, curident);
}


/*
   DefProcedureIdent := Ident 
                        % curproc := lookupSym (curident)  %
                        

   first  symbols:identtok
   
   cannot reachend
*/

static void DefProcedureIdent (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  Ident (stopset0, stopset1, stopset2);
  curproc = decl_lookupSym (curident);
}


/*
   DefineBuiltinProcedure := [ '__ATTRIBUTE__' '__BUILTIN__' 
                               '(' '(' Ident ')' ')'  | 
                               '__INLINE__'  ] 

   first  symbols:inlinetok, attributetok
   
   reachend
*/

static void DefineBuiltinProcedure (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  if ((mcLexBuf_currenttoken >= mcReserved_recordtok) && ((((1 << (mcLexBuf_currenttoken-mcReserved_recordtok)) & ((SetOfStop2) ((1 << (mcReserved_inlinetok-mcReserved_recordtok)) | (1 << (mcReserved_attributetok-mcReserved_recordtok))))) != 0)))
    {
      /* avoid gcc warning by using compound statement even if not strictly necessary.  */
      /* seen optional [ | ] expression  */
      if (mcLexBuf_currenttoken == mcReserved_attributetok)
        {
          Expect ((mcReserved_toktype) mcReserved_attributetok, stopset0, stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_builtintok-mcReserved_recordtok))));
          Expect ((mcReserved_toktype) mcReserved_builtintok, stopset0|(SetOfStop0) ((1 << (mcReserved_lparatok-mcReserved_eoftok))), stopset1, stopset2);
          Expect ((mcReserved_toktype) mcReserved_lparatok, stopset0|(SetOfStop0) ((1 << (mcReserved_lparatok-mcReserved_eoftok))), stopset1, stopset2);
          Expect ((mcReserved_toktype) mcReserved_lparatok, stopset0, stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_identtok-mcReserved_recordtok))));
          Ident (stopset0|(SetOfStop0) ((1 << (mcReserved_rparatok-mcReserved_eoftok))), stopset1, stopset2);
          Expect ((mcReserved_toktype) mcReserved_rparatok, stopset0|(SetOfStop0) ((1 << (mcReserved_rparatok-mcReserved_eoftok))), stopset1, stopset2);
          Expect ((mcReserved_toktype) mcReserved_rparatok, stopset0, stopset1, stopset2);
        }
      else if (mcLexBuf_currenttoken == mcReserved_inlinetok)
        {
          /* avoid dangling else.  */
          Expect ((mcReserved_toktype) mcReserved_inlinetok, stopset0, stopset1, stopset2);
        }
      else
        {
          /* avoid dangling else.  */
          ErrorArray ((char *) "expecting one of: __INLINE__ __ATTRIBUTE__", 42);
        }
    }
  /* end of optional [ | ] expression  */
}


/*
   ProcedureHeading := 'PROCEDURE' DefineBuiltinProcedure ( ProcedureIdent 
                                                            [ 
   FormalParameters  ] AttributeNoReturn  ) 

   first  symbols:proceduretok
   
   cannot reachend
*/

static void ProcedureHeading (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  Expect ((mcReserved_toktype) mcReserved_proceduretok, stopset0, stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_inlinetok-mcReserved_recordtok)) | (1 << (mcReserved_attributetok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok))));
  DefineBuiltinProcedure (stopset0, stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_identtok-mcReserved_recordtok))));
  ProcedureIdent (stopset0|(SetOfStop0) ((1 << (mcReserved_lparatok-mcReserved_eoftok)) | (1 << (mcReserved_ldirectivetok-mcReserved_eoftok))), stopset1, stopset2);
  if (mcLexBuf_currenttoken == mcReserved_lparatok)
    {
      FormalParameters (stopset0|(SetOfStop0) ((1 << (mcReserved_ldirectivetok-mcReserved_eoftok))), stopset1, stopset2);
    }
  AttributeNoReturn (stopset0, stopset1, stopset2);
}


/*
   Builtin := [ '__BUILTIN__'  | '__INLINE__'  ] 

   first  symbols:inlinetok, builtintok
   
   reachend
*/

static void Builtin (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  if ((mcLexBuf_currenttoken >= mcReserved_recordtok) && ((((1 << (mcLexBuf_currenttoken-mcReserved_recordtok)) & ((SetOfStop2) ((1 << (mcReserved_inlinetok-mcReserved_recordtok)) | (1 << (mcReserved_builtintok-mcReserved_recordtok))))) != 0)))
    {
      /* avoid gcc warning by using compound statement even if not strictly necessary.  */
      /* seen optional [ | ] expression  */
      if (mcLexBuf_currenttoken == mcReserved_builtintok)
        {
          Expect ((mcReserved_toktype) mcReserved_builtintok, stopset0, stopset1, stopset2);
        }
      else if (mcLexBuf_currenttoken == mcReserved_inlinetok)
        {
          /* avoid dangling else.  */
          Expect ((mcReserved_toktype) mcReserved_inlinetok, stopset0, stopset1, stopset2);
        }
      else
        {
          /* avoid dangling else.  */
          ErrorArray ((char *) "expecting one of: __INLINE__ __BUILTIN__", 40);
        }
    }
  /* end of optional [ | ] expression  */
}


/*
   DefProcedureHeading := 'PROCEDURE' Builtin ( DefProcedureIdent 
                                                [ DefFormalParameters  ] 
                                                AttributeNoReturn  ) 

   first  symbols:proceduretok
   
   cannot reachend
*/

static void DefProcedureHeading (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  Expect ((mcReserved_toktype) mcReserved_proceduretok, stopset0, stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_inlinetok-mcReserved_recordtok)) | (1 << (mcReserved_builtintok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok))));
  Builtin (stopset0, stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_identtok-mcReserved_recordtok))));
  DefProcedureIdent (stopset0|(SetOfStop0) ((1 << (mcReserved_lparatok-mcReserved_eoftok)) | (1 << (mcReserved_ldirectivetok-mcReserved_eoftok))), stopset1, stopset2);
  if (mcLexBuf_currenttoken == mcReserved_lparatok)
    {
      DefFormalParameters (stopset0|(SetOfStop0) ((1 << (mcReserved_ldirectivetok-mcReserved_eoftok))), stopset1, stopset2);
    }
  AttributeNoReturn (stopset0, stopset1, stopset2);
}


/*
   ProcedureBlock := { Declaration  } [ 'BEGIN' ProcedureBlockBody  ] 
                     'END' 

   first  symbols:proceduretok, moduletok, consttok, typetok, vartok, endtok, begintok
   
   cannot reachend
*/

static void ProcedureBlock (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  while ((((mcLexBuf_currenttoken >= mcReserved_arraytok) && (mcLexBuf_currenttoken < mcReserved_recordtok)) && ((((1 << (mcLexBuf_currenttoken-mcReserved_arraytok)) & ((SetOfStop1) ((1 << (mcReserved_consttok-mcReserved_arraytok)) | (1 << (mcReserved_proceduretok-mcReserved_arraytok)) | (1 << (mcReserved_moduletok-mcReserved_arraytok))))) != 0))) || ((mcLexBuf_currenttoken >= mcReserved_recordtok) && ((((1 << (mcLexBuf_currenttoken-mcReserved_recordtok)) & ((SetOfStop2) ((1 << (mcReserved_typetok-mcReserved_recordtok)) | (1 << (mcReserved_vartok-mcReserved_recordtok))))) != 0))))
    {
      Declaration (stopset0, stopset1|(SetOfStop1) ((1 << (mcReserved_endtok-mcReserved_arraytok)) | (1 << (mcReserved_begintok-mcReserved_arraytok)) | (1 << (mcReserved_consttok-mcReserved_arraytok)) | (1 << (mcReserved_proceduretok-mcReserved_arraytok)) | (1 << (mcReserved_moduletok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_typetok-mcReserved_recordtok)) | (1 << (mcReserved_vartok-mcReserved_recordtok))));
    }
   /* while  */
  if (mcLexBuf_currenttoken == mcReserved_begintok)
    {
      Expect ((mcReserved_toktype) mcReserved_begintok, stopset0|(SetOfStop0) ((1 << (mcReserved_semicolontok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_endtok-mcReserved_arraytok)) | (1 << (mcReserved_excepttok-mcReserved_arraytok)) | (1 << (mcReserved_exittok-mcReserved_arraytok)) | (1 << (mcReserved_iftok-mcReserved_arraytok)) | (1 << (mcReserved_casetok-mcReserved_arraytok)) | (1 << (mcReserved_looptok-mcReserved_arraytok)) | (1 << (mcReserved_fortok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_returntok-mcReserved_recordtok)) | (1 << (mcReserved_whiletok-mcReserved_recordtok)) | (1 << (mcReserved_repeattok-mcReserved_recordtok)) | (1 << (mcReserved_withtok-mcReserved_recordtok)) | (1 << (mcReserved_asmtok-mcReserved_recordtok)) | (1 << (mcReserved_retrytok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok))));
      ProcedureBlockBody (stopset0, stopset1|(SetOfStop1) ((1 << (mcReserved_endtok-mcReserved_arraytok))), stopset2);
    }
  Expect ((mcReserved_toktype) mcReserved_endtok, stopset0, stopset1, stopset2);
}


/*
   Block := { Declaration  } InitialBlock FinalBlock 'END' 

   first  symbols:proceduretok, moduletok, finallytok, begintok, consttok, typetok, vartok, endtok
   
   cannot reachend
*/

static void Block (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  while ((((mcLexBuf_currenttoken >= mcReserved_arraytok) && (mcLexBuf_currenttoken < mcReserved_recordtok)) && ((((1 << (mcLexBuf_currenttoken-mcReserved_arraytok)) & ((SetOfStop1) ((1 << (mcReserved_consttok-mcReserved_arraytok)) | (1 << (mcReserved_proceduretok-mcReserved_arraytok)) | (1 << (mcReserved_moduletok-mcReserved_arraytok))))) != 0))) || ((mcLexBuf_currenttoken >= mcReserved_recordtok) && ((((1 << (mcLexBuf_currenttoken-mcReserved_recordtok)) & ((SetOfStop2) ((1 << (mcReserved_typetok-mcReserved_recordtok)) | (1 << (mcReserved_vartok-mcReserved_recordtok))))) != 0))))
    {
      Declaration (stopset0, stopset1|(SetOfStop1) ((1 << (mcReserved_endtok-mcReserved_arraytok)) | (1 << (mcReserved_finallytok-mcReserved_arraytok)) | (1 << (mcReserved_begintok-mcReserved_arraytok)) | (1 << (mcReserved_consttok-mcReserved_arraytok)) | (1 << (mcReserved_proceduretok-mcReserved_arraytok)) | (1 << (mcReserved_moduletok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_typetok-mcReserved_recordtok)) | (1 << (mcReserved_vartok-mcReserved_recordtok))));
    }
   /* while  */
  InitialBlock (stopset0, stopset1|(SetOfStop1) ((1 << (mcReserved_endtok-mcReserved_arraytok)) | (1 << (mcReserved_finallytok-mcReserved_arraytok))), stopset2);
  FinalBlock (stopset0, stopset1|(SetOfStop1) ((1 << (mcReserved_endtok-mcReserved_arraytok))), stopset2);
  Expect ((mcReserved_toktype) mcReserved_endtok, stopset0, stopset1, stopset2);
}


/*
   InitialBlock := [ 'BEGIN' InitialBlockBody  ] 

   first  symbols:begintok
   
   reachend
*/

static void InitialBlock (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  if (mcLexBuf_currenttoken == mcReserved_begintok)
    {
      Expect ((mcReserved_toktype) mcReserved_begintok, stopset0|(SetOfStop0) ((1 << (mcReserved_semicolontok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_excepttok-mcReserved_arraytok)) | (1 << (mcReserved_exittok-mcReserved_arraytok)) | (1 << (mcReserved_iftok-mcReserved_arraytok)) | (1 << (mcReserved_casetok-mcReserved_arraytok)) | (1 << (mcReserved_looptok-mcReserved_arraytok)) | (1 << (mcReserved_fortok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_returntok-mcReserved_recordtok)) | (1 << (mcReserved_whiletok-mcReserved_recordtok)) | (1 << (mcReserved_repeattok-mcReserved_recordtok)) | (1 << (mcReserved_withtok-mcReserved_recordtok)) | (1 << (mcReserved_asmtok-mcReserved_recordtok)) | (1 << (mcReserved_retrytok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok))));
      InitialBlockBody (stopset0, stopset1, stopset2);
    }
}


/*
   FinalBlock := [ 'FINALLY' FinalBlockBody  ] 

   first  symbols:finallytok
   
   reachend
*/

static void FinalBlock (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  if (mcLexBuf_currenttoken == mcReserved_finallytok)
    {
      Expect ((mcReserved_toktype) mcReserved_finallytok, stopset0|(SetOfStop0) ((1 << (mcReserved_semicolontok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_excepttok-mcReserved_arraytok)) | (1 << (mcReserved_exittok-mcReserved_arraytok)) | (1 << (mcReserved_iftok-mcReserved_arraytok)) | (1 << (mcReserved_casetok-mcReserved_arraytok)) | (1 << (mcReserved_looptok-mcReserved_arraytok)) | (1 << (mcReserved_fortok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_returntok-mcReserved_recordtok)) | (1 << (mcReserved_whiletok-mcReserved_recordtok)) | (1 << (mcReserved_repeattok-mcReserved_recordtok)) | (1 << (mcReserved_withtok-mcReserved_recordtok)) | (1 << (mcReserved_asmtok-mcReserved_recordtok)) | (1 << (mcReserved_retrytok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok))));
      FinalBlockBody (stopset0, stopset1, stopset2);
    }
}


/*
   InitialBlockBody := NormalPart 
                       % putBegin (curmodule, popStmt ())  %
                       [ 'EXCEPT' ExceptionalPart  ] 

   first  symbols:identtok, iftok, casetok, whiletok, repeattok, looptok, fortok, withtok, asmtok, retrytok, semicolontok, exittok, returntok, excepttok
   
   reachend
*/

static void InitialBlockBody (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  NormalPart (stopset0, stopset1|(SetOfStop1) ((1 << (mcReserved_excepttok-mcReserved_arraytok))), stopset2);
  decl_putBegin (curmodule, popStmt ());
  if (mcLexBuf_currenttoken == mcReserved_excepttok)
    {
      Expect ((mcReserved_toktype) mcReserved_excepttok, stopset0|(SetOfStop0) ((1 << (mcReserved_semicolontok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_exittok-mcReserved_arraytok)) | (1 << (mcReserved_fortok-mcReserved_arraytok)) | (1 << (mcReserved_looptok-mcReserved_arraytok)) | (1 << (mcReserved_casetok-mcReserved_arraytok)) | (1 << (mcReserved_iftok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_returntok-mcReserved_recordtok)) | (1 << (mcReserved_retrytok-mcReserved_recordtok)) | (1 << (mcReserved_asmtok-mcReserved_recordtok)) | (1 << (mcReserved_withtok-mcReserved_recordtok)) | (1 << (mcReserved_repeattok-mcReserved_recordtok)) | (1 << (mcReserved_whiletok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok))));
      ExceptionalPart (stopset0, stopset1, stopset2);
    }
}


/*
   FinalBlockBody := NormalPart 
                     % putFinally (curmodule, popStmt ())  %
                     [ 'EXCEPT' ExceptionalPart  ] 

   first  symbols:identtok, iftok, casetok, whiletok, repeattok, looptok, fortok, withtok, asmtok, retrytok, semicolontok, exittok, returntok, excepttok
   
   reachend
*/

static void FinalBlockBody (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  NormalPart (stopset0, stopset1|(SetOfStop1) ((1 << (mcReserved_excepttok-mcReserved_arraytok))), stopset2);
  decl_putFinally (curmodule, popStmt ());
  if (mcLexBuf_currenttoken == mcReserved_excepttok)
    {
      Expect ((mcReserved_toktype) mcReserved_excepttok, stopset0|(SetOfStop0) ((1 << (mcReserved_semicolontok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_exittok-mcReserved_arraytok)) | (1 << (mcReserved_fortok-mcReserved_arraytok)) | (1 << (mcReserved_looptok-mcReserved_arraytok)) | (1 << (mcReserved_casetok-mcReserved_arraytok)) | (1 << (mcReserved_iftok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_returntok-mcReserved_recordtok)) | (1 << (mcReserved_retrytok-mcReserved_recordtok)) | (1 << (mcReserved_asmtok-mcReserved_recordtok)) | (1 << (mcReserved_withtok-mcReserved_recordtok)) | (1 << (mcReserved_repeattok-mcReserved_recordtok)) | (1 << (mcReserved_whiletok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok))));
      ExceptionalPart (stopset0, stopset1, stopset2);
    }
}


/*
   ProcedureBlockBody := ProcedureNormalPart [ 'EXCEPT' ExceptionalPart  ] 

   first  symbols:identtok, iftok, casetok, whiletok, repeattok, looptok, fortok, withtok, asmtok, retrytok, semicolontok, exittok, returntok, excepttok
   
   reachend
*/

static void ProcedureBlockBody (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  ProcedureNormalPart (stopset0, stopset1|(SetOfStop1) ((1 << (mcReserved_excepttok-mcReserved_arraytok))), stopset2);
  if (mcLexBuf_currenttoken == mcReserved_excepttok)
    {
      Expect ((mcReserved_toktype) mcReserved_excepttok, stopset0|(SetOfStop0) ((1 << (mcReserved_semicolontok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_exittok-mcReserved_arraytok)) | (1 << (mcReserved_fortok-mcReserved_arraytok)) | (1 << (mcReserved_looptok-mcReserved_arraytok)) | (1 << (mcReserved_casetok-mcReserved_arraytok)) | (1 << (mcReserved_iftok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_returntok-mcReserved_recordtok)) | (1 << (mcReserved_retrytok-mcReserved_recordtok)) | (1 << (mcReserved_asmtok-mcReserved_recordtok)) | (1 << (mcReserved_withtok-mcReserved_recordtok)) | (1 << (mcReserved_repeattok-mcReserved_recordtok)) | (1 << (mcReserved_whiletok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok))));
      ExceptionalPart (stopset0, stopset1, stopset2);
    }
}


/*
   ProcedureNormalPart := StatementSequence 
                          % putBegin (curproc, popStmt ())  %
                          

   first  symbols:identtok, retrytok, asmtok, withtok, fortok, looptok, repeattok, whiletok, casetok, iftok, returntok, exittok, semicolontok
   
   reachend
*/

static void ProcedureNormalPart (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  StatementSequence (stopset0, stopset1, stopset2);
  decl_putBegin (curproc, popStmt ());
}


/*
   NormalPart := StatementSequence 

   first  symbols:identtok, retrytok, asmtok, withtok, fortok, looptok, repeattok, whiletok, casetok, iftok, returntok, exittok, semicolontok
   
   reachend
*/

static void NormalPart (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  StatementSequence (stopset0, stopset1, stopset2);
}


/*
   ExceptionalPart := StatementSequence 

   first  symbols:identtok, retrytok, asmtok, withtok, fortok, looptok, repeattok, whiletok, casetok, iftok, returntok, exittok, semicolontok
   
   reachend
*/

static void ExceptionalPart (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  StatementSequence (stopset0, stopset1, stopset2);
}


/*
   Declaration := 'CONST' { ConstantDeclaration ';'  }  | 
                  'TYPE' { TypeDeclaration  }  | 
                  'VAR' { VariableDeclaration ';'  }  | 
                  ProcedureDeclaration ';'  | 
                  ModuleDeclaration ';' 

   first  symbols:moduletok, proceduretok, vartok, typetok, consttok
   
   cannot reachend
*/

static void Declaration (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  if (mcLexBuf_currenttoken == mcReserved_consttok)
    {
      Expect ((mcReserved_toktype) mcReserved_consttok, stopset0, stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_identtok-mcReserved_recordtok))));
      while (mcLexBuf_currenttoken == mcReserved_identtok)
        {
          ConstantDeclaration (stopset0|(SetOfStop0) ((1 << (mcReserved_semicolontok-mcReserved_eoftok))), stopset1, stopset2);
          Expect ((mcReserved_toktype) mcReserved_semicolontok, stopset0, stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_identtok-mcReserved_recordtok))));
        }
       /* while  */
    }
  else if (mcLexBuf_currenttoken == mcReserved_typetok)
    {
      /* avoid dangling else.  */
      Expect ((mcReserved_toktype) mcReserved_typetok, stopset0, stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_identtok-mcReserved_recordtok))));
      while (mcLexBuf_currenttoken == mcReserved_identtok)
        {
          TypeDeclaration (stopset0, stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_identtok-mcReserved_recordtok))));
        }
       /* while  */
    }
  else if (mcLexBuf_currenttoken == mcReserved_vartok)
    {
      /* avoid dangling else.  */
      Expect ((mcReserved_toktype) mcReserved_vartok, stopset0, stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_identtok-mcReserved_recordtok))));
      while (mcLexBuf_currenttoken == mcReserved_identtok)
        {
          VariableDeclaration (stopset0|(SetOfStop0) ((1 << (mcReserved_semicolontok-mcReserved_eoftok))), stopset1, stopset2);
          Expect ((mcReserved_toktype) mcReserved_semicolontok, stopset0, stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_identtok-mcReserved_recordtok))));
        }
       /* while  */
    }
  else if (mcLexBuf_currenttoken == mcReserved_proceduretok)
    {
      /* avoid dangling else.  */
      ProcedureDeclaration (stopset0|(SetOfStop0) ((1 << (mcReserved_semicolontok-mcReserved_eoftok))), stopset1, stopset2);
      Expect ((mcReserved_toktype) mcReserved_semicolontok, stopset0, stopset1, stopset2);
    }
  else if (mcLexBuf_currenttoken == mcReserved_moduletok)
    {
      /* avoid dangling else.  */
      ModuleDeclaration (stopset0|(SetOfStop0) ((1 << (mcReserved_semicolontok-mcReserved_eoftok))), stopset1, stopset2);
      Expect ((mcReserved_toktype) mcReserved_semicolontok, stopset0, stopset1, stopset2);
    }
  else
    {
      /* avoid dangling else.  */
      ErrorArray ((char *) "expecting one of: MODULE PROCEDURE VAR TYPE CONST", 49);
    }
}


/*
   DefFormalParameters := '(' 
                          % paramEnter (curproc)  %
                          [ DefMultiFPSection  ] ')' 
                          % paramLeave (curproc)  %
                          FormalReturn 

   first  symbols:lparatok
   
   cannot reachend
*/

static void DefFormalParameters (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  Expect ((mcReserved_toktype) mcReserved_lparatok, stopset0|(SetOfStop0) ((1 << (mcReserved_rparatok-mcReserved_eoftok)) | (1 << (mcReserved_lsbratok-mcReserved_eoftok))), stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_periodperiodperiodtok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok)) | (1 << (mcReserved_vartok-mcReserved_recordtok))));
  decl_paramEnter (curproc);
  if ((mcLexBuf_currenttoken == mcReserved_lsbratok) || ((mcLexBuf_currenttoken >= mcReserved_recordtok) && ((((1 << (mcLexBuf_currenttoken-mcReserved_recordtok)) & ((SetOfStop2) ((1 << (mcReserved_periodperiodperiodtok-mcReserved_recordtok)) | (1 << (mcReserved_vartok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok))))) != 0))))
    {
      DefMultiFPSection (stopset0|(SetOfStop0) ((1 << (mcReserved_rparatok-mcReserved_eoftok))), stopset1, stopset2);
    }
  Expect ((mcReserved_toktype) mcReserved_rparatok, stopset0|(SetOfStop0) ((1 << (mcReserved_colontok-mcReserved_eoftok))), stopset1, stopset2);
  decl_paramLeave (curproc);
  FormalReturn (stopset0, stopset1, stopset2);
}


/*
   AttributeNoReturn := [ ''  ] 

   first  symbols:ldirectivetok
   
   reachend
*/

static void AttributeNoReturn (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  if (mcLexBuf_currenttoken == mcReserved_ldirectivetok)
    {
      Expect ((mcReserved_toktype) mcReserved_ldirectivetok, stopset0, stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_identtok-mcReserved_recordtok))));
      Ident (stopset0|(SetOfStop0) ((1 << (mcReserved_rdirectivetok-mcReserved_eoftok))), stopset1, stopset2);
      Expect ((mcReserved_toktype) mcReserved_rdirectivetok, stopset0, stopset1, stopset2);
    }
}


/*
   DefMultiFPSection := DefExtendedFP  | FPSection [ ';' DefMultiFPSection  ] 

   first  symbols:identtok, vartok, lsbratok, periodperiodperiodtok
   
   cannot reachend
*/

static void DefMultiFPSection (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  if ((mcLexBuf_currenttoken == mcReserved_lsbratok) || (mcLexBuf_currenttoken == mcReserved_periodperiodperiodtok))
    {
      DefExtendedFP (stopset0, stopset1, stopset2);
    }
  else if ((mcLexBuf_currenttoken >= mcReserved_recordtok) && ((((1 << (mcLexBuf_currenttoken-mcReserved_recordtok)) & ((SetOfStop2) ((1 << (mcReserved_identtok-mcReserved_recordtok)) | (1 << (mcReserved_vartok-mcReserved_recordtok))))) != 0)))
    {
      /* avoid dangling else.  */
      FPSection (stopset0|(SetOfStop0) ((1 << (mcReserved_semicolontok-mcReserved_eoftok))), stopset1, stopset2);
      if (mcLexBuf_currenttoken == mcReserved_semicolontok)
        {
          Expect ((mcReserved_toktype) mcReserved_semicolontok, stopset0|(SetOfStop0) ((1 << (mcReserved_lsbratok-mcReserved_eoftok))), stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_periodperiodperiodtok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok)) | (1 << (mcReserved_vartok-mcReserved_recordtok))));
          DefMultiFPSection (stopset0, stopset1, stopset2);
        }
    }
  else
    {
      /* avoid dangling else.  */
      ErrorArray ((char *) "expecting one of: identifier VAR ... [", 38);
    }
}


/*
   FormalParameters := '(' 
                       % paramEnter (curproc)  %
                       [ MultiFPSection  ] ')' 
                       % paramLeave (curproc)  %
                       FormalReturn 

   first  symbols:lparatok
   
   cannot reachend
*/

static void FormalParameters (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  Expect ((mcReserved_toktype) mcReserved_lparatok, stopset0|(SetOfStop0) ((1 << (mcReserved_rparatok-mcReserved_eoftok)) | (1 << (mcReserved_lsbratok-mcReserved_eoftok))), stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_periodperiodperiodtok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok)) | (1 << (mcReserved_vartok-mcReserved_recordtok))));
  decl_paramEnter (curproc);
  if ((mcLexBuf_currenttoken == mcReserved_lsbratok) || ((mcLexBuf_currenttoken >= mcReserved_recordtok) && ((((1 << (mcLexBuf_currenttoken-mcReserved_recordtok)) & ((SetOfStop2) ((1 << (mcReserved_periodperiodperiodtok-mcReserved_recordtok)) | (1 << (mcReserved_vartok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok))))) != 0))))
    {
      MultiFPSection (stopset0|(SetOfStop0) ((1 << (mcReserved_rparatok-mcReserved_eoftok))), stopset1, stopset2);
    }
  Expect ((mcReserved_toktype) mcReserved_rparatok, stopset0|(SetOfStop0) ((1 << (mcReserved_colontok-mcReserved_eoftok))), stopset1, stopset2);
  decl_paramLeave (curproc);
  FormalReturn (stopset0, stopset1, stopset2);
}


/*
   MultiFPSection := ExtendedFP  | FPSection [ ';' MultiFPSection  ] 

   first  symbols:identtok, vartok, lsbratok, periodperiodperiodtok
   
   cannot reachend
*/

static void MultiFPSection (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  if ((mcLexBuf_currenttoken == mcReserved_lsbratok) || (mcLexBuf_currenttoken == mcReserved_periodperiodperiodtok))
    {
      ExtendedFP (stopset0, stopset1, stopset2);
    }
  else if ((mcLexBuf_currenttoken >= mcReserved_recordtok) && ((((1 << (mcLexBuf_currenttoken-mcReserved_recordtok)) & ((SetOfStop2) ((1 << (mcReserved_identtok-mcReserved_recordtok)) | (1 << (mcReserved_vartok-mcReserved_recordtok))))) != 0)))
    {
      /* avoid dangling else.  */
      FPSection (stopset0|(SetOfStop0) ((1 << (mcReserved_semicolontok-mcReserved_eoftok))), stopset1, stopset2);
      if (mcLexBuf_currenttoken == mcReserved_semicolontok)
        {
          Expect ((mcReserved_toktype) mcReserved_semicolontok, stopset0|(SetOfStop0) ((1 << (mcReserved_lsbratok-mcReserved_eoftok))), stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_periodperiodperiodtok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok)) | (1 << (mcReserved_vartok-mcReserved_recordtok))));
          MultiFPSection (stopset0, stopset1, stopset2);
        }
    }
  else
    {
      /* avoid dangling else.  */
      ErrorArray ((char *) "expecting one of: identifier VAR ... [", 38);
    }
}


/*
   FPSection := NonVarFPSection  | VarFPSection 

   first  symbols:vartok, identtok
   
   cannot reachend
*/

static void FPSection (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  if (mcLexBuf_currenttoken == mcReserved_identtok)
    {
      NonVarFPSection (stopset0, stopset1, stopset2);
    }
  else if (mcLexBuf_currenttoken == mcReserved_vartok)
    {
      /* avoid dangling else.  */
      VarFPSection (stopset0, stopset1, stopset2);
    }
  else
    {
      /* avoid dangling else.  */
      ErrorArray ((char *) "expecting one of: VAR identifier", 32);
    }
}


/*
   DefExtendedFP := DefOptArg  | '...' 

   first  symbols:lsbratok, periodperiodperiodtok
   
   cannot reachend
*/

static void DefExtendedFP (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  if (mcLexBuf_currenttoken == mcReserved_lsbratok)
    {
      DefOptArg (stopset0, stopset1, stopset2);
    }
  else if (mcLexBuf_currenttoken == mcReserved_periodperiodperiodtok)
    {
      /* avoid dangling else.  */
      Expect ((mcReserved_toktype) mcReserved_periodperiodperiodtok, stopset0, stopset1, stopset2);
    }
  else
    {
      /* avoid dangling else.  */
      ErrorArray ((char *) "expecting one of: ... [", 23);
    }
}


/*
   ExtendedFP := OptArg  | '...' 

   first  symbols:lsbratok, periodperiodperiodtok
   
   cannot reachend
*/

static void ExtendedFP (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  if (mcLexBuf_currenttoken == mcReserved_lsbratok)
    {
      OptArg (stopset0, stopset1, stopset2);
    }
  else if (mcLexBuf_currenttoken == mcReserved_periodperiodperiodtok)
    {
      /* avoid dangling else.  */
      Expect ((mcReserved_toktype) mcReserved_periodperiodperiodtok, stopset0, stopset1, stopset2);
    }
  else
    {
      /* avoid dangling else.  */
      ErrorArray ((char *) "expecting one of: ... [", 23);
    }
}


/*
   VarFPSection := 'VAR' IdentList ':' FormalType 

   first  symbols:vartok
   
   cannot reachend
*/

static void VarFPSection (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  Expect ((mcReserved_toktype) mcReserved_vartok, stopset0, stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_identtok-mcReserved_recordtok))));
  IdentList (stopset0|(SetOfStop0) ((1 << (mcReserved_colontok-mcReserved_eoftok))), stopset1, stopset2);
  Expect ((mcReserved_toktype) mcReserved_colontok, stopset0, stopset1|(SetOfStop1) ((1 << (mcReserved_arraytok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_identtok-mcReserved_recordtok))));
  FormalType (stopset0, stopset1, stopset2);
}


/*
   NonVarFPSection := IdentList ':' FormalType 

   first  symbols:identtok
   
   cannot reachend
*/

static void NonVarFPSection (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  IdentList (stopset0|(SetOfStop0) ((1 << (mcReserved_colontok-mcReserved_eoftok))), stopset1, stopset2);
  Expect ((mcReserved_toktype) mcReserved_colontok, stopset0, stopset1|(SetOfStop1) ((1 << (mcReserved_arraytok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_identtok-mcReserved_recordtok))));
  FormalType (stopset0, stopset1, stopset2);
}


/*
   OptArg := '[' Ident ':' FormalType [ '=' ConstExpressionNop  ] 
             ']' 

   first  symbols:lsbratok
   
   cannot reachend
*/

static void OptArg (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  Expect ((mcReserved_toktype) mcReserved_lsbratok, stopset0, stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_identtok-mcReserved_recordtok))));
  Ident (stopset0|(SetOfStop0) ((1 << (mcReserved_colontok-mcReserved_eoftok))), stopset1, stopset2);
  Expect ((mcReserved_toktype) mcReserved_colontok, stopset0, stopset1|(SetOfStop1) ((1 << (mcReserved_arraytok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_identtok-mcReserved_recordtok))));
  FormalType (stopset0|(SetOfStop0) ((1 << (mcReserved_equaltok-mcReserved_eoftok)) | (1 << (mcReserved_rsbratok-mcReserved_eoftok))), stopset1, stopset2);
  if (mcLexBuf_currenttoken == mcReserved_equaltok)
    {
      Expect ((mcReserved_toktype) mcReserved_equaltok, stopset0|(SetOfStop0) ((1 << (mcReserved_minustok-mcReserved_eoftok)) | (1 << (mcReserved_plustok-mcReserved_eoftok)) | (1 << (mcReserved_lparatok-mcReserved_eoftok)) | (1 << (mcReserved_lcbratok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_nottok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_integertok-mcReserved_recordtok)) | (1 << (mcReserved_realtok-mcReserved_recordtok)) | (1 << (mcReserved_attributetok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok)) | (1 << (mcReserved_stringtok-mcReserved_recordtok))));
      ConstExpressionNop (stopset0|(SetOfStop0) ((1 << (mcReserved_rsbratok-mcReserved_eoftok))), stopset1, stopset2);
    }
  Expect ((mcReserved_toktype) mcReserved_rsbratok, stopset0, stopset1, stopset2);
}


/*
   DefOptArg := '[' Ident ':' FormalType '=' ConstExpressionNop 
                ']' 

   first  symbols:lsbratok
   
   cannot reachend
*/

static void DefOptArg (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  Expect ((mcReserved_toktype) mcReserved_lsbratok, stopset0, stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_identtok-mcReserved_recordtok))));
  Ident (stopset0|(SetOfStop0) ((1 << (mcReserved_colontok-mcReserved_eoftok))), stopset1, stopset2);
  Expect ((mcReserved_toktype) mcReserved_colontok, stopset0, stopset1|(SetOfStop1) ((1 << (mcReserved_arraytok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_identtok-mcReserved_recordtok))));
  FormalType (stopset0|(SetOfStop0) ((1 << (mcReserved_equaltok-mcReserved_eoftok))), stopset1, stopset2);
  Expect ((mcReserved_toktype) mcReserved_equaltok, stopset0|(SetOfStop0) ((1 << (mcReserved_minustok-mcReserved_eoftok)) | (1 << (mcReserved_plustok-mcReserved_eoftok)) | (1 << (mcReserved_lparatok-mcReserved_eoftok)) | (1 << (mcReserved_lcbratok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_nottok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_integertok-mcReserved_recordtok)) | (1 << (mcReserved_realtok-mcReserved_recordtok)) | (1 << (mcReserved_attributetok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok)) | (1 << (mcReserved_stringtok-mcReserved_recordtok))));
  ConstExpressionNop (stopset0|(SetOfStop0) ((1 << (mcReserved_rsbratok-mcReserved_eoftok))), stopset1, stopset2);
  Expect ((mcReserved_toktype) mcReserved_rsbratok, stopset0, stopset1, stopset2);
}


/*
   FormalType := { 'ARRAY' 'OF'  } Qualident 

   first  symbols:identtok, arraytok
   
   cannot reachend
*/

static void FormalType (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  while (mcLexBuf_currenttoken == mcReserved_arraytok)
    {
      Expect ((mcReserved_toktype) mcReserved_arraytok, stopset0, stopset1|(SetOfStop1) ((1 << (mcReserved_oftok-mcReserved_arraytok))), stopset2);
      Expect ((mcReserved_toktype) mcReserved_oftok, stopset0, stopset1|(SetOfStop1) ((1 << (mcReserved_arraytok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_identtok-mcReserved_recordtok))));
    }
   /* while  */
  Qualident (stopset0, stopset1, stopset2);
}


/*
   ModuleDeclaration := 'MODULE' Ident [ Priority  ] ';' { Import  } 
                        [ Export  ] Block Ident 

   first  symbols:moduletok
   
   cannot reachend
*/

static void ModuleDeclaration (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  Expect ((mcReserved_toktype) mcReserved_moduletok, stopset0, stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_identtok-mcReserved_recordtok))));
  Ident (stopset0|(SetOfStop0) ((1 << (mcReserved_semicolontok-mcReserved_eoftok)) | (1 << (mcReserved_lsbratok-mcReserved_eoftok))), stopset1, stopset2);
  if (mcLexBuf_currenttoken == mcReserved_lsbratok)
    {
      Priority (stopset0|(SetOfStop0) ((1 << (mcReserved_semicolontok-mcReserved_eoftok))), stopset1, stopset2);
    }
  Expect ((mcReserved_toktype) mcReserved_semicolontok, stopset0, stopset1|(SetOfStop1) ((1 << (mcReserved_endtok-mcReserved_arraytok)) | (1 << (mcReserved_importtok-mcReserved_arraytok)) | (1 << (mcReserved_fromtok-mcReserved_arraytok)) | (1 << (mcReserved_exporttok-mcReserved_arraytok)) | (1 << (mcReserved_finallytok-mcReserved_arraytok)) | (1 << (mcReserved_begintok-mcReserved_arraytok)) | (1 << (mcReserved_consttok-mcReserved_arraytok)) | (1 << (mcReserved_proceduretok-mcReserved_arraytok)) | (1 << (mcReserved_moduletok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_typetok-mcReserved_recordtok)) | (1 << (mcReserved_vartok-mcReserved_recordtok))));
  while (((mcLexBuf_currenttoken >= mcReserved_arraytok) && (mcLexBuf_currenttoken < mcReserved_recordtok)) && ((((1 << (mcLexBuf_currenttoken-mcReserved_arraytok)) & ((SetOfStop1) ((1 << (mcReserved_fromtok-mcReserved_arraytok)) | (1 << (mcReserved_importtok-mcReserved_arraytok))))) != 0)))
    {
      Import (stopset0, stopset1|(SetOfStop1) ((1 << (mcReserved_endtok-mcReserved_arraytok)) | (1 << (mcReserved_consttok-mcReserved_arraytok)) | (1 << (mcReserved_begintok-mcReserved_arraytok)) | (1 << (mcReserved_finallytok-mcReserved_arraytok)) | (1 << (mcReserved_exporttok-mcReserved_arraytok)) | (1 << (mcReserved_fromtok-mcReserved_arraytok)) | (1 << (mcReserved_importtok-mcReserved_arraytok)) | (1 << (mcReserved_moduletok-mcReserved_arraytok)) | (1 << (mcReserved_proceduretok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_vartok-mcReserved_recordtok)) | (1 << (mcReserved_typetok-mcReserved_recordtok))));
    }
   /* while  */
  if (mcLexBuf_currenttoken == mcReserved_exporttok)
    {
      Export (stopset0, stopset1|(SetOfStop1) ((1 << (mcReserved_endtok-mcReserved_arraytok)) | (1 << (mcReserved_consttok-mcReserved_arraytok)) | (1 << (mcReserved_begintok-mcReserved_arraytok)) | (1 << (mcReserved_finallytok-mcReserved_arraytok)) | (1 << (mcReserved_moduletok-mcReserved_arraytok)) | (1 << (mcReserved_proceduretok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_vartok-mcReserved_recordtok)) | (1 << (mcReserved_typetok-mcReserved_recordtok))));
    }
  Block (stopset0, stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_identtok-mcReserved_recordtok))));
  Ident (stopset0, stopset1, stopset2);
}


/*
   Priority := '[' ConstExpressionNop ']' 

   first  symbols:lsbratok
   
   cannot reachend
*/

static void Priority (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  Expect ((mcReserved_toktype) mcReserved_lsbratok, stopset0|(SetOfStop0) ((1 << (mcReserved_minustok-mcReserved_eoftok)) | (1 << (mcReserved_plustok-mcReserved_eoftok)) | (1 << (mcReserved_lparatok-mcReserved_eoftok)) | (1 << (mcReserved_lcbratok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_nottok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_integertok-mcReserved_recordtok)) | (1 << (mcReserved_realtok-mcReserved_recordtok)) | (1 << (mcReserved_attributetok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok)) | (1 << (mcReserved_stringtok-mcReserved_recordtok))));
  ConstExpressionNop (stopset0|(SetOfStop0) ((1 << (mcReserved_rsbratok-mcReserved_eoftok))), stopset1, stopset2);
  Expect ((mcReserved_toktype) mcReserved_rsbratok, stopset0, stopset1, stopset2);
}


/*
   Export := 'EXPORT' ( 'QUALIFIED' IdentList  | 
                        'UNQUALIFIED' IdentList  | 
                        IdentList  ) ';' 

   first  symbols:exporttok
   
   cannot reachend
*/

static void Export (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  Expect ((mcReserved_toktype) mcReserved_exporttok, stopset0, stopset1|(SetOfStop1) ((1 << (mcReserved_qualifiedtok-mcReserved_arraytok)) | (1 << (mcReserved_unqualifiedtok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_identtok-mcReserved_recordtok))));
  if (mcLexBuf_currenttoken == mcReserved_qualifiedtok)
    {
      Expect ((mcReserved_toktype) mcReserved_qualifiedtok, stopset0, stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_identtok-mcReserved_recordtok))));
      IdentList (stopset0|(SetOfStop0) ((1 << (mcReserved_semicolontok-mcReserved_eoftok))), stopset1, stopset2);
    }
  else if (mcLexBuf_currenttoken == mcReserved_unqualifiedtok)
    {
      /* avoid dangling else.  */
      Expect ((mcReserved_toktype) mcReserved_unqualifiedtok, stopset0, stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_identtok-mcReserved_recordtok))));
      IdentList (stopset0|(SetOfStop0) ((1 << (mcReserved_semicolontok-mcReserved_eoftok))), stopset1, stopset2);
    }
  else if (mcLexBuf_currenttoken == mcReserved_identtok)
    {
      /* avoid dangling else.  */
      IdentList (stopset0|(SetOfStop0) ((1 << (mcReserved_semicolontok-mcReserved_eoftok))), stopset1, stopset2);
    }
  else
    {
      /* avoid dangling else.  */
      ErrorArray ((char *) "expecting one of: identifier UNQUALIFIED QUALIFIED", 50);
    }
  Expect ((mcReserved_toktype) mcReserved_semicolontok, stopset0, stopset1, stopset2);
}


/*
   FromIdentList := Ident { ',' Ident  } 

   first  symbols:identtok
   
   cannot reachend
*/

static void FromIdentList (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  Ident (stopset0|(SetOfStop0) ((1 << (mcReserved_commatok-mcReserved_eoftok))), stopset1, stopset2);
  while (mcLexBuf_currenttoken == mcReserved_commatok)
    {
      Expect ((mcReserved_toktype) mcReserved_commatok, stopset0, stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_identtok-mcReserved_recordtok))));
      Ident (stopset0|(SetOfStop0) ((1 << (mcReserved_commatok-mcReserved_eoftok))), stopset1, stopset2);
    }
   /* while  */
}


/*
   FromImport := 'FROM' Ident 'IMPORT' FromIdentList ';' 

   first  symbols:fromtok
   
   cannot reachend
*/

static void FromImport (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  Expect ((mcReserved_toktype) mcReserved_fromtok, stopset0, stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_identtok-mcReserved_recordtok))));
  Ident (stopset0, stopset1|(SetOfStop1) ((1 << (mcReserved_importtok-mcReserved_arraytok))), stopset2);
  Expect ((mcReserved_toktype) mcReserved_importtok, stopset0, stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_identtok-mcReserved_recordtok))));
  FromIdentList (stopset0|(SetOfStop0) ((1 << (mcReserved_semicolontok-mcReserved_eoftok))), stopset1, stopset2);
  Expect ((mcReserved_toktype) mcReserved_semicolontok, stopset0, stopset1, stopset2);
}


/*
   ImportModuleList := Ident { ',' Ident  } 

   first  symbols:identtok
   
   cannot reachend
*/

static void ImportModuleList (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  Ident (stopset0|(SetOfStop0) ((1 << (mcReserved_commatok-mcReserved_eoftok))), stopset1, stopset2);
  while (mcLexBuf_currenttoken == mcReserved_commatok)
    {
      Expect ((mcReserved_toktype) mcReserved_commatok, stopset0, stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_identtok-mcReserved_recordtok))));
      Ident (stopset0|(SetOfStop0) ((1 << (mcReserved_commatok-mcReserved_eoftok))), stopset1, stopset2);
    }
   /* while  */
}


/*
   WithoutFromImport := 'IMPORT' ImportModuleList ';' 

   first  symbols:importtok
   
   cannot reachend
*/

static void WithoutFromImport (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  Expect ((mcReserved_toktype) mcReserved_importtok, stopset0, stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_identtok-mcReserved_recordtok))));
  ImportModuleList (stopset0|(SetOfStop0) ((1 << (mcReserved_semicolontok-mcReserved_eoftok))), stopset1, stopset2);
  Expect ((mcReserved_toktype) mcReserved_semicolontok, stopset0, stopset1, stopset2);
}


/*
   Import := FromImport  | WithoutFromImport 

   first  symbols:importtok, fromtok
   
   cannot reachend
*/

static void Import (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  if (mcLexBuf_currenttoken == mcReserved_fromtok)
    {
      FromImport (stopset0, stopset1, stopset2);
    }
  else if (mcLexBuf_currenttoken == mcReserved_importtok)
    {
      /* avoid dangling else.  */
      WithoutFromImport (stopset0, stopset1, stopset2);
    }
  else
    {
      /* avoid dangling else.  */
      ErrorArray ((char *) "expecting one of: IMPORT FROM", 29);
    }
}


/*
   DefinitionModule := 'DEFINITION' 'MODULE' [ 'FOR' string  ] 
                       Ident ';' 
                       % curmodule := lookupDef (curident)  %
                       
                       % enterScope (curmodule)  %
                       { Import  } [ Export  ] { Definition  } 
                       'END' Ident '.' 
                       % checkEndName (curmodule, curident, 'definition module')  %
                       
                       % leaveScope  %
                       

   first  symbols:definitiontok
   
   cannot reachend
*/

static void DefinitionModule (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  Expect ((mcReserved_toktype) mcReserved_definitiontok, stopset0, stopset1|(SetOfStop1) ((1 << (mcReserved_moduletok-mcReserved_arraytok))), stopset2);
  Expect ((mcReserved_toktype) mcReserved_moduletok, stopset0, stopset1|(SetOfStop1) ((1 << (mcReserved_fortok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_identtok-mcReserved_recordtok))));
  if (mcLexBuf_currenttoken == mcReserved_fortok)
    {
      Expect ((mcReserved_toktype) mcReserved_fortok, stopset0, stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_stringtok-mcReserved_recordtok))));
      string (stopset0, stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_identtok-mcReserved_recordtok))));
    }
  Ident (stopset0|(SetOfStop0) ((1 << (mcReserved_semicolontok-mcReserved_eoftok))), stopset1, stopset2);
  Expect ((mcReserved_toktype) mcReserved_semicolontok, stopset0, stopset1|(SetOfStop1) ((1 << (mcReserved_importtok-mcReserved_arraytok)) | (1 << (mcReserved_fromtok-mcReserved_arraytok)) | (1 << (mcReserved_exporttok-mcReserved_arraytok)) | (1 << (mcReserved_endtok-mcReserved_arraytok)) | (1 << (mcReserved_proceduretok-mcReserved_arraytok)) | (1 << (mcReserved_consttok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_vartok-mcReserved_recordtok)) | (1 << (mcReserved_typetok-mcReserved_recordtok))));
  curmodule = decl_lookupDef (curident);
  decl_enterScope (curmodule);
  while (((mcLexBuf_currenttoken >= mcReserved_arraytok) && (mcLexBuf_currenttoken < mcReserved_recordtok)) && ((((1 << (mcLexBuf_currenttoken-mcReserved_arraytok)) & ((SetOfStop1) ((1 << (mcReserved_fromtok-mcReserved_arraytok)) | (1 << (mcReserved_importtok-mcReserved_arraytok))))) != 0)))
    {
      Import (stopset0, stopset1|(SetOfStop1) ((1 << (mcReserved_endtok-mcReserved_arraytok)) | (1 << (mcReserved_exporttok-mcReserved_arraytok)) | (1 << (mcReserved_fromtok-mcReserved_arraytok)) | (1 << (mcReserved_importtok-mcReserved_arraytok)) | (1 << (mcReserved_consttok-mcReserved_arraytok)) | (1 << (mcReserved_proceduretok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_typetok-mcReserved_recordtok)) | (1 << (mcReserved_vartok-mcReserved_recordtok))));
    }
   /* while  */
  if (mcLexBuf_currenttoken == mcReserved_exporttok)
    {
      Export (stopset0, stopset1|(SetOfStop1) ((1 << (mcReserved_endtok-mcReserved_arraytok)) | (1 << (mcReserved_consttok-mcReserved_arraytok)) | (1 << (mcReserved_proceduretok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_typetok-mcReserved_recordtok)) | (1 << (mcReserved_vartok-mcReserved_recordtok))));
    }
  while ((((mcLexBuf_currenttoken >= mcReserved_arraytok) && (mcLexBuf_currenttoken < mcReserved_recordtok)) && ((((1 << (mcLexBuf_currenttoken-mcReserved_arraytok)) & ((SetOfStop1) ((1 << (mcReserved_consttok-mcReserved_arraytok)) | (1 << (mcReserved_proceduretok-mcReserved_arraytok))))) != 0))) || ((mcLexBuf_currenttoken >= mcReserved_recordtok) && ((((1 << (mcLexBuf_currenttoken-mcReserved_recordtok)) & ((SetOfStop2) ((1 << (mcReserved_typetok-mcReserved_recordtok)) | (1 << (mcReserved_vartok-mcReserved_recordtok))))) != 0))))
    {
      Definition (stopset0, stopset1|(SetOfStop1) ((1 << (mcReserved_endtok-mcReserved_arraytok)) | (1 << (mcReserved_consttok-mcReserved_arraytok)) | (1 << (mcReserved_proceduretok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_typetok-mcReserved_recordtok)) | (1 << (mcReserved_vartok-mcReserved_recordtok))));
    }
   /* while  */
  Expect ((mcReserved_toktype) mcReserved_endtok, stopset0, stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_identtok-mcReserved_recordtok))));
  Ident (stopset0|(SetOfStop0) ((1 << (mcReserved_periodtok-mcReserved_eoftok))), stopset1, stopset2);
  Expect ((mcReserved_toktype) mcReserved_periodtok, stopset0, stopset1, stopset2);
  checkEndName (curmodule, curident, (char *) "definition module", 17);
  decl_leaveScope ();
}


/*
   PushQualident := 
                    % VAR type, field: node ;  %
                    Ident 
                    % qualid := push (lookupWithSym (curident))  %
                    
                    % IF qualid = NIL
                                    THEN
                                       metaError1 ('the symbol {%1k} is not visible in this scope (or any other nested scope)', curident)
                                    END  %
                    [ '.' 
                      % IF NOT isQualident (qualid)
                                      THEN
                                         ErrorArray ('the first component of this qualident must be a definition module or a parameter/variable/constant which has record type')
                                      END  %
                      Ident 
                      % IF isDef (qualid)
                                      THEN
                                         qualid := replace (lookupInScope (qualid, curident))
                                      ELSE
                                         type := skipType (getType (qualid)) ;
                                         field := lookupInScope (type, curident) ;
                        									     IF field = NIL
                                         THEN
                                            metaError2 ('field {%1k} cannot be found in {%2ad}', curident, qualid)
                                         ELSE
                                            qualid := replace (makeComponentRef (qualid, field))
                                         END
                                      END ;
                                      IF qualid = NIL
                                      THEN
                                         metaError1 ('qualified component of the identifier {%1k} cannot be found', curident)
                                      END  %
                       ] 

   first  symbols:identtok
   
   cannot reachend
*/

static void PushQualident (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  decl_node type;
  decl_node field;

  Ident (stopset0|(SetOfStop0) ((1 << (mcReserved_periodtok-mcReserved_eoftok))), stopset1, stopset2);
  qualid = push (lookupWithSym (curident));
  if (qualid == NULL)
    {
      mcMetaError_metaError1 ((char *) "the symbol {%1k} is not visible in this scope (or any other nested scope)", 73, (unsigned char *) &curident, (sizeof (curident)-1));
    }
  if (mcLexBuf_currenttoken == mcReserved_periodtok)
    {
      Expect ((mcReserved_toktype) mcReserved_periodtok, stopset0, stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_identtok-mcReserved_recordtok))));
      if (! (isQualident (qualid)))
        {
          ErrorArray ((char *) "the first component of this qualident must be a definition module or a parameter/variable/constant which has record type", 120);
        }
      Ident (stopset0, stopset1, stopset2);
      if (decl_isDef (qualid))
        {
          qualid = replace (decl_lookupInScope (qualid, curident));
        }
      else
        {
          type = decl_skipType (decl_getType (qualid));
          field = decl_lookupInScope (type, curident);
          if (field == NULL)
            {
              mcMetaError_metaError2 ((char *) "field {%1k} cannot be found in {%2ad}", 37, (unsigned char *) &curident, (sizeof (curident)-1), (unsigned char *) &qualid, (sizeof (qualid)-1));
            }
          else
            {
              qualid = replace (decl_makeComponentRef (qualid, field));
            }
        }
      if (qualid == NULL)
        {
          mcMetaError_metaError1 ((char *) "qualified component of the identifier {%1k} cannot be found", 59, (unsigned char *) &curident, (sizeof (curident)-1));
        }
    }
}


/*
   OptSubrange := [ SubrangeType  ] 

   first  symbols:lsbratok
   
   reachend
*/

static void OptSubrange (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  if (mcLexBuf_currenttoken == mcReserved_lsbratok)
    {
      SubrangeType (stopset0, stopset1, stopset2);
    }
}


/*
   TypeEquiv := Qualident OptSubrange 

   first  symbols:identtok
   
   cannot reachend
*/

static void TypeEquiv (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  Qualident (stopset0|(SetOfStop0) ((1 << (mcReserved_lsbratok-mcReserved_eoftok))), stopset1, stopset2);
  OptSubrange (stopset0, stopset1, stopset2);
}


/*
   EnumIdentList := Ident { ',' Ident  } 

   first  symbols:identtok
   
   cannot reachend
*/

static void EnumIdentList (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  Ident (stopset0|(SetOfStop0) ((1 << (mcReserved_commatok-mcReserved_eoftok))), stopset1, stopset2);
  while (mcLexBuf_currenttoken == mcReserved_commatok)
    {
      Expect ((mcReserved_toktype) mcReserved_commatok, stopset0, stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_identtok-mcReserved_recordtok))));
      Ident (stopset0|(SetOfStop0) ((1 << (mcReserved_commatok-mcReserved_eoftok))), stopset1, stopset2);
    }
   /* while  */
}


/*
   Enumeration := '(' EnumIdentList ')' 

   first  symbols:lparatok
   
   cannot reachend
*/

static void Enumeration (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  Expect ((mcReserved_toktype) mcReserved_lparatok, stopset0, stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_identtok-mcReserved_recordtok))));
  EnumIdentList (stopset0|(SetOfStop0) ((1 << (mcReserved_rparatok-mcReserved_eoftok))), stopset1, stopset2);
  Expect ((mcReserved_toktype) mcReserved_rparatok, stopset0, stopset1, stopset2);
}


/*
   SimpleType := TypeEquiv  | Enumeration  | SubrangeType 

   first  symbols:lsbratok, lparatok, identtok
   
   cannot reachend
*/

static void SimpleType (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  if (mcLexBuf_currenttoken == mcReserved_identtok)
    {
      TypeEquiv (stopset0, stopset1, stopset2);
    }
  else if (mcLexBuf_currenttoken == mcReserved_lparatok)
    {
      /* avoid dangling else.  */
      Enumeration (stopset0, stopset1, stopset2);
    }
  else if (mcLexBuf_currenttoken == mcReserved_lsbratok)
    {
      /* avoid dangling else.  */
      SubrangeType (stopset0, stopset1, stopset2);
    }
  else
    {
      /* avoid dangling else.  */
      ErrorArray ((char *) "expecting one of: [ ( identifier", 32);
    }
}


/*
   Type := SimpleType  | ArrayType  | RecordType  | 
           SetType  | PointerType  | ProcedureType 

   first  symbols:proceduretok, pointertok, settok, packedsettok, oftok, recordtok, arraytok, identtok, lparatok, lsbratok
   
   cannot reachend
*/

static void Type (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  if (((mcLexBuf_currenttoken < mcReserved_arraytok) && ((((1 << (mcLexBuf_currenttoken-mcReserved_eoftok)) & ((SetOfStop0) ((1 << (mcReserved_lparatok-mcReserved_eoftok)) | (1 << (mcReserved_lsbratok-mcReserved_eoftok))))) != 0))) || (mcLexBuf_currenttoken == mcReserved_identtok))
    {
      SimpleType (stopset0, stopset1, stopset2);
    }
  else if (mcLexBuf_currenttoken == mcReserved_arraytok)
    {
      /* avoid dangling else.  */
      ArrayType (stopset0, stopset1, stopset2);
    }
  else if (mcLexBuf_currenttoken == mcReserved_recordtok)
    {
      /* avoid dangling else.  */
      RecordType (stopset0, stopset1, stopset2);
    }
  else if ((((mcLexBuf_currenttoken >= mcReserved_arraytok) && (mcLexBuf_currenttoken < mcReserved_recordtok)) && ((((1 << (mcLexBuf_currenttoken-mcReserved_arraytok)) & ((SetOfStop1) ((1 << (mcReserved_packedsettok-mcReserved_arraytok)) | (1 << (mcReserved_oftok-mcReserved_arraytok))))) != 0))) || (mcLexBuf_currenttoken == mcReserved_settok))
    {
      /* avoid dangling else.  */
      SetType (stopset0, stopset1, stopset2);
    }
  else if (mcLexBuf_currenttoken == mcReserved_pointertok)
    {
      /* avoid dangling else.  */
      PointerType (stopset0, stopset1, stopset2);
    }
  else if (mcLexBuf_currenttoken == mcReserved_proceduretok)
    {
      /* avoid dangling else.  */
      ProcedureType (stopset0, stopset1, stopset2);
    }
  else
    {
      /* avoid dangling else.  */
      ErrorArray ((char *) "expecting one of: PROCEDURE POINTER SET PACKEDSET OF RECORD ARRAY identifier ( [", 80);
    }
}


/*
   TypeDeclaration := { Ident ( ';'  | '=' Type Alignment ';'  )  } 

   first  symbols:identtok
   
   reachend
*/

static void TypeDeclaration (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  while (mcLexBuf_currenttoken == mcReserved_identtok)
    {
      Ident (stopset0|(SetOfStop0) ((1 << (mcReserved_semicolontok-mcReserved_eoftok)) | (1 << (mcReserved_equaltok-mcReserved_eoftok))), stopset1, stopset2);
      if (mcLexBuf_currenttoken == mcReserved_semicolontok)
        {
          Expect ((mcReserved_toktype) mcReserved_semicolontok, stopset0, stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_identtok-mcReserved_recordtok))));
        }
      else if (mcLexBuf_currenttoken == mcReserved_equaltok)
        {
          /* avoid dangling else.  */
          Expect ((mcReserved_toktype) mcReserved_equaltok, stopset0|(SetOfStop0) ((1 << (mcReserved_lparatok-mcReserved_eoftok)) | (1 << (mcReserved_lsbratok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_proceduretok-mcReserved_arraytok)) | (1 << (mcReserved_pointertok-mcReserved_arraytok)) | (1 << (mcReserved_packedsettok-mcReserved_arraytok)) | (1 << (mcReserved_oftok-mcReserved_arraytok)) | (1 << (mcReserved_arraytok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_settok-mcReserved_recordtok)) | (1 << (mcReserved_recordtok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok))));
          Type (stopset0|(SetOfStop0) ((1 << (mcReserved_ldirectivetok-mcReserved_eoftok)) | (1 << (mcReserved_semicolontok-mcReserved_eoftok))), stopset1, stopset2);
          Alignment (stopset0|(SetOfStop0) ((1 << (mcReserved_semicolontok-mcReserved_eoftok))), stopset1, stopset2);
          Expect ((mcReserved_toktype) mcReserved_semicolontok, stopset0, stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_identtok-mcReserved_recordtok))));
        }
      else
        {
          /* avoid dangling else.  */
          ErrorArray ((char *) "expecting one of: = ;", 21);
        }
    }
   /* while  */
}


/*
   Definition := 'CONST' { ConstantDeclaration ';'  }  | 
                 'TYPE' { TypeDeclaration  }  | 
                 'VAR' { VariableDeclaration ';'  }  | 
                 DefProcedureHeading ';' 

   first  symbols:proceduretok, vartok, typetok, consttok
   
   cannot reachend
*/

static void Definition (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  if (mcLexBuf_currenttoken == mcReserved_consttok)
    {
      Expect ((mcReserved_toktype) mcReserved_consttok, stopset0, stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_identtok-mcReserved_recordtok))));
      while (mcLexBuf_currenttoken == mcReserved_identtok)
        {
          ConstantDeclaration (stopset0|(SetOfStop0) ((1 << (mcReserved_semicolontok-mcReserved_eoftok))), stopset1, stopset2);
          Expect ((mcReserved_toktype) mcReserved_semicolontok, stopset0, stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_identtok-mcReserved_recordtok))));
        }
       /* while  */
    }
  else if (mcLexBuf_currenttoken == mcReserved_typetok)
    {
      /* avoid dangling else.  */
      Expect ((mcReserved_toktype) mcReserved_typetok, stopset0, stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_identtok-mcReserved_recordtok))));
      while (mcLexBuf_currenttoken == mcReserved_identtok)
        {
          TypeDeclaration (stopset0, stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_identtok-mcReserved_recordtok))));
        }
       /* while  */
    }
  else if (mcLexBuf_currenttoken == mcReserved_vartok)
    {
      /* avoid dangling else.  */
      Expect ((mcReserved_toktype) mcReserved_vartok, stopset0, stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_identtok-mcReserved_recordtok))));
      while (mcLexBuf_currenttoken == mcReserved_identtok)
        {
          VariableDeclaration (stopset0|(SetOfStop0) ((1 << (mcReserved_semicolontok-mcReserved_eoftok))), stopset1, stopset2);
          Expect ((mcReserved_toktype) mcReserved_semicolontok, stopset0, stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_identtok-mcReserved_recordtok))));
        }
       /* while  */
    }
  else if (mcLexBuf_currenttoken == mcReserved_proceduretok)
    {
      /* avoid dangling else.  */
      DefProcedureHeading (stopset0|(SetOfStop0) ((1 << (mcReserved_semicolontok-mcReserved_eoftok))), stopset1, stopset2);
      Expect ((mcReserved_toktype) mcReserved_semicolontok, stopset0, stopset1, stopset2);
    }
  else
    {
      /* avoid dangling else.  */
      ErrorArray ((char *) "expecting one of: PROCEDURE VAR TYPE CONST", 42);
    }
}


/*
   AsmStatement := 
                   % VAR s: node ;  %
                   
                   % s := pushStmt (makeComment ("asm"))  %
                   'ASM' [ 'VOLATILE'  ] '(' AsmOperands ')' 

   first  symbols:asmtok
   
   cannot reachend
*/

static void AsmStatement (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  decl_node s;

  s = pushStmt (decl_makeComment ((char *) "asm", 3));
  Expect ((mcReserved_toktype) mcReserved_asmtok, stopset0|(SetOfStop0) ((1 << (mcReserved_lparatok-mcReserved_eoftok))), stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_volatiletok-mcReserved_recordtok))));
  if (mcLexBuf_currenttoken == mcReserved_volatiletok)
    {
      Expect ((mcReserved_toktype) mcReserved_volatiletok, stopset0|(SetOfStop0) ((1 << (mcReserved_lparatok-mcReserved_eoftok))), stopset1, stopset2);
    }
  Expect ((mcReserved_toktype) mcReserved_lparatok, stopset0, stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_stringtok-mcReserved_recordtok))));
  AsmOperands (stopset0|(SetOfStop0) ((1 << (mcReserved_rparatok-mcReserved_eoftok))), stopset1, stopset2);
  Expect ((mcReserved_toktype) mcReserved_rparatok, stopset0, stopset1, stopset2);
}


/*
   AsmOperands := string [ AsmOperandSpec  ] 

   first  symbols:stringtok
   
   cannot reachend
*/

static void AsmOperands (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  string (stopset0|(SetOfStop0) ((1 << (mcReserved_colontok-mcReserved_eoftok))), stopset1, stopset2);
  if (mcLexBuf_currenttoken == mcReserved_colontok)
    {
      AsmOperandSpec (stopset0, stopset1, stopset2);
    }
}


/*
   AsmOperandSpec := [ ':' AsmList [ ':' AsmList [ ':' TrashList  ]  ]  ] 

   first  symbols:colontok
   
   reachend
*/

static void AsmOperandSpec (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  if (mcLexBuf_currenttoken == mcReserved_colontok)
    {
      Expect ((mcReserved_toktype) mcReserved_colontok, stopset0|(SetOfStop0) ((1 << (mcReserved_colontok-mcReserved_eoftok)) | (1 << (mcReserved_commatok-mcReserved_eoftok)) | (1 << (mcReserved_lsbratok-mcReserved_eoftok))), stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_stringtok-mcReserved_recordtok))));
      AsmList (stopset0|(SetOfStop0) ((1 << (mcReserved_colontok-mcReserved_eoftok))), stopset1, stopset2);
      if (mcLexBuf_currenttoken == mcReserved_colontok)
        {
          Expect ((mcReserved_toktype) mcReserved_colontok, stopset0|(SetOfStop0) ((1 << (mcReserved_colontok-mcReserved_eoftok)) | (1 << (mcReserved_commatok-mcReserved_eoftok)) | (1 << (mcReserved_lsbratok-mcReserved_eoftok))), stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_stringtok-mcReserved_recordtok))));
          AsmList (stopset0|(SetOfStop0) ((1 << (mcReserved_colontok-mcReserved_eoftok))), stopset1, stopset2);
          if (mcLexBuf_currenttoken == mcReserved_colontok)
            {
              Expect ((mcReserved_toktype) mcReserved_colontok, stopset0|(SetOfStop0) ((1 << (mcReserved_commatok-mcReserved_eoftok))), stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_stringtok-mcReserved_recordtok))));
              TrashList (stopset0, stopset1, stopset2);
            }
        }
    }
}


/*
   AsmList := [ AsmElement  ] { ',' AsmElement  } 

   first  symbols:lsbratok, stringtok, commatok
   
   reachend
*/

static void AsmList (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  if ((mcLexBuf_currenttoken == mcReserved_lsbratok) || (mcLexBuf_currenttoken == mcReserved_stringtok))
    {
      AsmElement (stopset0|(SetOfStop0) ((1 << (mcReserved_commatok-mcReserved_eoftok))), stopset1, stopset2);
    }
  while (mcLexBuf_currenttoken == mcReserved_commatok)
    {
      Expect ((mcReserved_toktype) mcReserved_commatok, stopset0|(SetOfStop0) ((1 << (mcReserved_lsbratok-mcReserved_eoftok))), stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_stringtok-mcReserved_recordtok))));
      AsmElement (stopset0|(SetOfStop0) ((1 << (mcReserved_commatok-mcReserved_eoftok))), stopset1, stopset2);
    }
   /* while  */
}


/*
   NamedOperand := '[' Ident ']' 

   first  symbols:lsbratok
   
   cannot reachend
*/

static void NamedOperand (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  Expect ((mcReserved_toktype) mcReserved_lsbratok, stopset0, stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_identtok-mcReserved_recordtok))));
  Ident (stopset0|(SetOfStop0) ((1 << (mcReserved_rsbratok-mcReserved_eoftok))), stopset1, stopset2);
  Expect ((mcReserved_toktype) mcReserved_rsbratok, stopset0, stopset1, stopset2);
}


/*
   AsmOperandName := [ NamedOperand  ] 

   first  symbols:lsbratok
   
   reachend
*/

static void AsmOperandName (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  if (mcLexBuf_currenttoken == mcReserved_lsbratok)
    {
      NamedOperand (stopset0, stopset1, stopset2);
    }
}


/*
   AsmElement := AsmOperandName string '(' Expression ')' 

   first  symbols:stringtok, lsbratok
   
   cannot reachend
*/

static void AsmElement (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  AsmOperandName (stopset0, stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_stringtok-mcReserved_recordtok))));
  string (stopset0|(SetOfStop0) ((1 << (mcReserved_lparatok-mcReserved_eoftok))), stopset1, stopset2);
  Expect ((mcReserved_toktype) mcReserved_lparatok, stopset0|(SetOfStop0) ((1 << (mcReserved_minustok-mcReserved_eoftok)) | (1 << (mcReserved_plustok-mcReserved_eoftok)) | (1 << (mcReserved_lparatok-mcReserved_eoftok)) | (1 << (mcReserved_lcbratok-mcReserved_eoftok))), stopset1|(SetOfStop1) ((1 << (mcReserved_nottok-mcReserved_arraytok))), stopset2|(SetOfStop2) ((1 << (mcReserved_stringtok-mcReserved_recordtok)) | (1 << (mcReserved_integertok-mcReserved_recordtok)) | (1 << (mcReserved_realtok-mcReserved_recordtok)) | (1 << (mcReserved_identtok-mcReserved_recordtok))));
  Expression (stopset0|(SetOfStop0) ((1 << (mcReserved_rparatok-mcReserved_eoftok))), stopset1, stopset2);
  Expect ((mcReserved_toktype) mcReserved_rparatok, stopset0, stopset1, stopset2);
}


/*
   TrashList := [ string  ] { ',' string  } 

   first  symbols:commatok, stringtok
   
   reachend
*/

static void TrashList (SetOfStop0 stopset0, SetOfStop1 stopset1, SetOfStop2 stopset2)
{
  if (mcLexBuf_currenttoken == mcReserved_stringtok)
    {
      string (stopset0|(SetOfStop0) ((1 << (mcReserved_commatok-mcReserved_eoftok))), stopset1, stopset2);
    }
  while (mcLexBuf_currenttoken == mcReserved_commatok)
    {
      Expect ((mcReserved_toktype) mcReserved_commatok, stopset0, stopset1, stopset2|(SetOfStop2) ((1 << (mcReserved_stringtok-mcReserved_recordtok))));
      string (stopset0|(SetOfStop0) ((1 << (mcReserved_commatok-mcReserved_eoftok))), stopset1, stopset2);
    }
   /* while  */
}


/*
   CompilationUnit - returns TRUE if the input was correct enough to parse
                     in future passes.
*/

unsigned int mcp5_CompilationUnit (void)
{
  stk = mcStack_init ();
  withStk = mcStack_init ();
  stmtStk = mcStack_init ();
  loopStk = mcStack_init ();
  loopNo = 0;
  WasNoError = TRUE;
  FileUnit ((SetOfStop0) ((1 << (mcReserved_eoftok-mcReserved_eoftok))), (SetOfStop1) 0, (SetOfStop2) 0);
  mcStack_kill (&stk);
  mcStack_kill (&withStk);
  mcStack_kill (&stmtStk);
  mcStack_kill (&loopStk);
  return WasNoError;
  /* static analysis guarentees a RETURN statement will be used before here.  */
  __builtin_unreachable ();
}

void _M2_mcp5_init (__attribute__((unused)) int argc, __attribute__((unused)) char *argv[])
{
}

void _M2_mcp5_finish (__attribute__((unused)) int argc, __attribute__((unused)) char *argv[])
{
}
