/* Description of target passes for AVR.
   Copyright (C) 2016-2023 Free Software Foundation, Inc. */

/* This file is part of GCC.

   GCC is free software; you can redistribute it and/or modify it under
   the terms of the GNU General Public License as published by the Free
   Software Foundation; either version 3, or (at your option) any later
   version.

   GCC is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
   for more details.

   You should have received a copy of the GNU General Public License
   along with GCC; see the file COPYING3.  If not see
   <http://www.gnu.org/licenses/>.  */

/* An analysis pass that runs prior to prologue / epilogue generation.
   Computes cfun->machine->gasisr.maybe which is used in prologue and
   epilogue generation provided -mgas-isr-prologues is on.  */

INSERT_PASS_BEFORE (pass_thread_prologue_and_epilogue, 1, avr_pass_pre_proep);

/* This avr-specific pass (re)computes insn notes, in particular REG_DEAD
   notes which are used by `avr.cc::reg_unused_after' and branch offset
   computations.  These notes must be correct, i.e. there must be no
   dangling REG_DEAD notes; otherwise wrong code might result, cf. PR64331.

   DF needs (correct) CFG, hence right before free_cfg is the last
   opportunity to rectify notes.  */

INSERT_PASS_BEFORE (pass_free_cfg, 1, avr_pass_recompute_notes);

/* casesi uses a SImode switch index which is quite costly as most code will
   work on HImode or QImode.  The following pass runs right after .expand and
   tries to fix such situations by operating on the original mode.  This
   reduces code size and register pressure.

   The assertion is that the code generated by casesi is unaltered and a
   a sign-extend or zero-extend from QImode or HImode precedes the casesi
   insns withaout any insns in between.  */

INSERT_PASS_AFTER (pass_expand, 1, avr_pass_casesi);

/* If-else decision trees generated for switch / case may produce sequences
   like

      SREG = compare (reg, val);
	  if (SREG == 0)  goto label1;
      SREG = compare (reg, 1 + val);
	  if (SREG >= 0)  goto label2;

   which can be optimized to

      SREG = compare (reg, val);
	  if (SREG == 0)  goto label1;
	  if (SREG >= 0)  goto label2;

   The optimal place for such a pass would be directly after expand, but
   it's not possible for a jump insn to target more than one code label.
   Hence, run a mini pass right before split2 which introduces REG_CC.  */

INSERT_PASS_BEFORE (pass_split_after_reload, 1, avr_pass_ifelse);
