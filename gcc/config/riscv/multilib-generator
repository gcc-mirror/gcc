#!/usr/bin/env python

# RISC-V multilib list generator.
# Copyright (C) 2011-2020 Free Software Foundation, Inc.
# Contributed by Andrew Waterman (andrew@sifive.com).
# 
# This file is part of GCC.
# 
# GCC is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3, or (at your option)
# any later version.
# 
# GCC is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with GCC; see the file COPYING3.  If not see
# <http://www.gnu.org/licenses/>.

# Each argument to this script is of the form
#  <primary arch>-<abi>-<additional arches>-<extensions>
# For example,
#  rv32imafd-ilp32d-rv32g-c,v
# means that, in addition to rv32imafd, these configurations can also use the
# rv32imafd-ilp32d libraries: rv32imafdc, rv32imafdv, rv32g, rv32gc, rv32gv

from __future__ import print_function
import sys
import collections

arches = collections.OrderedDict()
abis = collections.OrderedDict()
required = []
reuse = []

canonical_order = "mafdgqlcbjtpvn"

def arch_canonicalize(arch):
  # TODO: Support implied extensions, e.g. D implied F in latest spec.
  # TODO: Support extension version.
  new_arch = ""
  if arch[:5] in ['rv32e', 'rv32i', 'rv32g', 'rv64i', 'rv64g']:
    # TODO: We should expand g to imadzifencei once we support newer spec.
    new_arch = arch[:5].replace("g", "imafd")
  else:
    raise Exception("Unexpected arch: `%s`" % arch[:5])

  # Find any Z, S, H or X
  long_ext_prefixes = ['z', 's', 'h', 'x']
  long_ext_prefixes_idx = map(lambda x: arch.find(x), long_ext_prefixes)

  # Filter out any non-existent index.
  long_ext_prefixes_idx = list(filter(lambda x: x != -1, long_ext_prefixes_idx))
  if long_ext_prefixes_idx:
    first_long_ext_idx = min(long_ext_prefixes_idx)
    long_exts = arch[first_long_ext_idx:].split("_")
    std_exts = arch[5:first_long_ext_idx]
  else:
    long_exts = []
    std_exts = arch[5:]

  # Single letter extension might appear in the long_exts list,
  # becasue we just append extensions list to the arch string.
  std_exts += "".join(filter(lambda x:len(x) == 1, long_exts))

  # Multi-letter extension must be in lexicographic order.
  long_exts = sorted(filter(lambda x:len(x) != 1, long_exts))

  # Put extensions in canonical order.
  for ext in canonical_order:
    if ext in std_exts:
      new_arch += ext

  # Check every extension is processed.
  for ext in std_exts:
    if ext == '_':
      continue
    if ext not in canonical_order:
      raise Exception("Unsupported extension `%s`" % ext)

  # Concat rest of the multi-char extensions.
  if long_exts:
    new_arch += "_" + "_".join(long_exts)
  return new_arch

for cfg in sys.argv[1:]:
  (arch, abi, extra, ext) = cfg.split('-')
  arch = arch_canonicalize (arch)
  arches[arch] = 1
  abis[abi] = 1
  extra = list(filter(None, extra.split(',')))
  ext = list(filter(None, ext.split(',')))
  alts = sum([[x] + [x + "_" + y for y in ext] for x in [arch] + extra], [])
  alts = list(map(arch_canonicalize, alts))
  for alt in alts[1:]:
    arches[alt] = 1
    reuse.append('march.%s/mabi.%s=march.%s/mabi.%s' % (arch, abi, alt, abi))
  required.append('march=%s/mabi=%s' % (arch, abi))

arch_options = '/'.join(['march=%s' % x for x in arches.keys()])
arch_dirnames = ' \\\n'.join(arches.keys())

abi_options = '/'.join(['mabi=%s' % x for x in abis.keys()])
abi_dirnames = ' \\\n'.join(abis.keys())

prog = sys.argv[0].split('/')[-1]
print('# This file was generated by %s with the command:' % prog)
print('#  %s' % ' '.join(sys.argv))

print('MULTILIB_OPTIONS = %s %s' % (arch_options, abi_options))
print('MULTILIB_DIRNAMES = %s %s' % (arch_dirnames, abi_dirnames))
print('MULTILIB_REQUIRED = %s' % ' \\\n'.join(required))
print('MULTILIB_REUSE = %s' % ' \\\n'.join(reuse))
