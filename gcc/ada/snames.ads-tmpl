------------------------------------------------------------------------------
--                                                                          --
--                         GNAT COMPILER COMPONENTS                         --
--                                                                          --
--                               S N A M E S                                --
--                                                                          --
--                                 S p e c                                  --
--                                                                          --
--          Copyright (C) 1992-2024, Free Software Foundation, Inc.         --
--                                                                          --
-- GNAT is free software;  you can  redistribute it  and/or modify it under --
-- terms of the  GNU General Public License as published  by the Free Soft- --
-- ware  Foundation;  either version 3,  or (at your option) any later ver- --
-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --
-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --
-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --
-- for  more details.  You should have  received  a copy of the GNU General --
-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --
-- http://www.gnu.org/licenses for a complete copy of the license.          --
--                                                                          --
-- GNAT was originally developed  by the GNAT team at  New York University. --
-- Extensive contributions were provided by Ada Core Technologies Inc.      --
--                                                                          --
------------------------------------------------------------------------------

with Namet; use Namet;

package Snames is

   --  This package contains definitions of standard names (i.e. entries in
   --  the Names table) that are used throughout the GNAT compiler. It also
   --  contains the definitions of some enumeration types whose definitions
   --  are tied to the order of these preset names.

   --  NOTE WELL: If you add names of attributes, the enumeration type
   --  Attribute_Id must be kept in synch (same names in same order, with
   --  some exceptions). See the body of Get_Attribute_Id for details. The
   --  same is true of other enumeration types declared in this package.

   --  ALSO NOTE: In the case of a name that corresponds to both an attribute
   --  and a pragma, the Name_Id must be defined in the attribute section
   --  (between First_Attribute_Name and Last_Attribute_Name). Also, please
   --  add a comment in the list of Name_Ids at the point where the name would
   --  normally appear alphabetically (for an example, see comment starting
   --  "Note: CPU ..."). The Pragma_Id with that name must be defined in the
   --  last section of literals for type Pragma_Id (see set of Pragma_Ids that
   --  require special processing due to matching an attribute name). Finally,
   --  the bodies of functions Get_Pragma_Id and Is_Pragma_Name must be updated
   --  to test for each such pragma that shares a name with an attribute.

   ------------------
   -- Preset Names --
   ------------------

   --  The following are preset entries in the names table, which are entered
   --  at the start of every compilation for easy access. Note that the order
   --  of initialization of these names in the body must be coordinated with
   --  the order of names in this table.

   --  Note: a name may not appear more than once in the following list. If
   --  additional pragmas or attributes are introduced which might otherwise
   --  cause a duplicate, then list it only once in this table, and adjust the
   --  definition of the functions for testing for pragma names and attribute
   --  names, and returning their ID values. Of course everything is simpler if
   --  no such duplications occur.

   --  First we have the one character names used to optimize the lookup
   --  process for one character identifiers (to avoid the hashing in this
   --  case) There are a full 256 of these, but only the entries for lower
   --  case and upper case letters have identifiers

   --  The lower case letter entries are used for one character identifiers
   --  appearing in the source, for example in pragma Interface (C).

   Name_A : constant Name_Id := First_Name_Id + Character'Pos ('a');
   Name_B : constant Name_Id := First_Name_Id + Character'Pos ('b');
   Name_C : constant Name_Id := First_Name_Id + Character'Pos ('c');
   Name_D : constant Name_Id := First_Name_Id + Character'Pos ('d');
   Name_E : constant Name_Id := First_Name_Id + Character'Pos ('e');
   Name_F : constant Name_Id := First_Name_Id + Character'Pos ('f');
   Name_G : constant Name_Id := First_Name_Id + Character'Pos ('g');
   Name_H : constant Name_Id := First_Name_Id + Character'Pos ('h');
   Name_I : constant Name_Id := First_Name_Id + Character'Pos ('i');
   Name_J : constant Name_Id := First_Name_Id + Character'Pos ('j');
   Name_K : constant Name_Id := First_Name_Id + Character'Pos ('k');
   Name_L : constant Name_Id := First_Name_Id + Character'Pos ('l');
   Name_M : constant Name_Id := First_Name_Id + Character'Pos ('m');
   Name_N : constant Name_Id := First_Name_Id + Character'Pos ('n');
   Name_O : constant Name_Id := First_Name_Id + Character'Pos ('o');
   Name_P : constant Name_Id := First_Name_Id + Character'Pos ('p');
   Name_Q : constant Name_Id := First_Name_Id + Character'Pos ('q');
   Name_R : constant Name_Id := First_Name_Id + Character'Pos ('r');
   Name_S : constant Name_Id := First_Name_Id + Character'Pos ('s');
   Name_T : constant Name_Id := First_Name_Id + Character'Pos ('t');
   Name_U : constant Name_Id := First_Name_Id + Character'Pos ('u');
   Name_V : constant Name_Id := First_Name_Id + Character'Pos ('v');
   Name_W : constant Name_Id := First_Name_Id + Character'Pos ('w');
   Name_X : constant Name_Id := First_Name_Id + Character'Pos ('x');
   Name_Y : constant Name_Id := First_Name_Id + Character'Pos ('y');
   Name_Z : constant Name_Id := First_Name_Id + Character'Pos ('z');

   --  The upper case letter entries are used by expander code for local
   --  variables that do not require unique names (e.g. formal parameter names
   --  in constructed procedures).

   Name_uA : constant Name_Id := First_Name_Id + Character'Pos ('A');
   Name_uB : constant Name_Id := First_Name_Id + Character'Pos ('B');
   Name_uC : constant Name_Id := First_Name_Id + Character'Pos ('C');
   Name_uD : constant Name_Id := First_Name_Id + Character'Pos ('D');
   Name_uE : constant Name_Id := First_Name_Id + Character'Pos ('E');
   Name_uF : constant Name_Id := First_Name_Id + Character'Pos ('F');
   Name_uG : constant Name_Id := First_Name_Id + Character'Pos ('G');
   Name_uH : constant Name_Id := First_Name_Id + Character'Pos ('H');
   Name_uI : constant Name_Id := First_Name_Id + Character'Pos ('I');
   Name_uJ : constant Name_Id := First_Name_Id + Character'Pos ('J');
   Name_uK : constant Name_Id := First_Name_Id + Character'Pos ('K');
   Name_uL : constant Name_Id := First_Name_Id + Character'Pos ('L');
   Name_uM : constant Name_Id := First_Name_Id + Character'Pos ('M');
   Name_uN : constant Name_Id := First_Name_Id + Character'Pos ('N');
   Name_uO : constant Name_Id := First_Name_Id + Character'Pos ('O');
   Name_uP : constant Name_Id := First_Name_Id + Character'Pos ('P');
   Name_uQ : constant Name_Id := First_Name_Id + Character'Pos ('Q');
   Name_uR : constant Name_Id := First_Name_Id + Character'Pos ('R');
   Name_uS : constant Name_Id := First_Name_Id + Character'Pos ('S');
   Name_uT : constant Name_Id := First_Name_Id + Character'Pos ('T');
   Name_uU : constant Name_Id := First_Name_Id + Character'Pos ('U');
   Name_uV : constant Name_Id := First_Name_Id + Character'Pos ('V');
   Name_uW : constant Name_Id := First_Name_Id + Character'Pos ('W');
   Name_uX : constant Name_Id := First_Name_Id + Character'Pos ('X');
   Name_uY : constant Name_Id := First_Name_Id + Character'Pos ('Y');
   Name_uZ : constant Name_Id := First_Name_Id + Character'Pos ('Z');

   --  Note: the following table is read by the utility program 'xsnamest', and
   --  its format should not be changed without coordinating with this program.

   N : constant Name_Id := First_Name_Id + 256;
   --  Synonym used in standard name definitions

   --  Names referenced in snames.h

   Name_uParent                        : constant Name_Id := N + $;
   Name_uTag                           : constant Name_Id := N + $;
   Name_Off                            : constant Name_Id := N + $;
   Name_Space                          : constant Name_Id := N + $;
   Name_Time                           : constant Name_Id := N + $;

   --  Names of aspects for which there are no matching pragmas or attributes
   --  so that they need to be included for aspect specification use.

   Name_Default_Value                  : constant Name_Id := N + $;
   Name_Default_Component_Value        : constant Name_Id := N + $;
   Name_Designated_Storage_Model       : constant Name_Id := N + $;
   Name_Dimension                      : constant Name_Id := N + $;
   Name_Dimension_System               : constant Name_Id := N + $;
   Name_Disable_Controlled             : constant Name_Id := N + $;
   Name_Dynamic_Predicate              : constant Name_Id := N + $;
   Name_Exclusive_Functions            : constant Name_Id := N + $;
   Name_Full_Access_Only               : constant Name_Id := N + $;
   Name_Ghost_Predicate                : constant Name_Id := N + $;
   Name_Integer_Literal                : constant Name_Id := N + $;
   Name_Local_Restrictions             : constant Name_Id := N + $;
   Name_No_Controlled_Parts            : constant Name_Id := N + $;
   Name_No_Task_Parts                  : constant Name_Id := N + $;
   Name_Real_Literal                   : constant Name_Id := N + $;
   Name_Relaxed_Initialization         : constant Name_Id := N + $;
   Name_Stable_Properties              : constant Name_Id := N + $;
   Name_Static_Predicate               : constant Name_Id := N + $;
   Name_Storage_Model                  : constant Name_Id := N + $;
   Name_Storage_Model_Type             : constant Name_Id := N + $;
   Name_String_Literal                 : constant Name_Id := N + $;
   Name_Synchronization                : constant Name_Id := N + $;
   Name_Unimplemented                  : constant Name_Id := N + $;
   Name_User_Aspect                    : constant Name_Id := N + $;

   --  Some special names used by the expander. Note that the lower case u's
   --  at the start of these names get translated to extra underscores. These
   --  names are only referenced internally by expander generated code.

   Name_uAbort_Signal                  : constant Name_Id := N + $;
   Name_uAlignment                     : constant Name_Id := N + $;
   Name_uAssign                        : constant Name_Id := N + $;
   Name_uATCB                          : constant Name_Id := N + $;
   Name_uChain                         : constant Name_Id := N + $;
   Name_uController                    : constant Name_Id := N + $;
   Name_uCPU                           : constant Name_Id := N + $;
   Name_uDispatching_Domain            : constant Name_Id := N + $;
   Name_uFinalizer                     : constant Name_Id := N + $;
   Name_uFinalizer_Old                 : constant Name_Id := N + $;
   Name_uFinalization_Controller       : constant Name_Id := N + $;
   Name_uInit                          : constant Name_Id := N + $;
   Name_uInit_Level                    : constant Name_Id := N + $;
   Name_uInvariant                     : constant Name_Id := N + $;
   Name_uMaster                        : constant Name_Id := N + $;
   Name_uObject                        : constant Name_Id := N + $;
   Name_uPost                          : constant Name_Id := N + $;
   Name_uPostcond_Enabled              : constant Name_Id := N + $;
   Name_uPre                           : constant Name_Id := N + $;
   Name_uPriority                      : constant Name_Id := N + $;
   Name_uRelative_Deadline             : constant Name_Id := N + $;
   Name_uResult                        : constant Name_Id := N + $;
   Name_uResult_Object_For_Postcond    : constant Name_Id := N + $;
   Name_uReturn_Success_For_Postcond   : constant Name_Id := N + $;
   Name_uSecondary_Stack               : constant Name_Id := N + $;
   Name_uSecondary_Stack_Size          : constant Name_Id := N + $;
   Name_uSize                          : constant Name_Id := N + $;
   Name_uStack                         : constant Name_Id := N + $;
   Name_uTask                          : constant Name_Id := N + $;
   Name_uTask_Id                       : constant Name_Id := N + $;
   Name_uTask_Info                     : constant Name_Id := N + $;
   Name_uTask_Name                     : constant Name_Id := N + $;
   Name_uType_Invariant                : constant Name_Id := N + $;
   Name_uVariants                      : constant Name_Id := N + $;
   Name_uWrapped_Statements            : constant Name_Id := N + $;

   --  Names of predefined primitives used in the expansion of dispatching
   --  requeue and select statements, Abort, 'Callable and 'Terminated.

   Name_uDisp_Asynchronous_Select      : constant Name_Id := N + $;
   Name_uDisp_Conditional_Select       : constant Name_Id := N + $;
   Name_uDisp_Get_Prim_Op_Kind         : constant Name_Id := N + $;
   Name_uDisp_Get_Task_Id              : constant Name_Id := N + $;
   Name_uDisp_Requeue                  : constant Name_Id := N + $;
   Name_uDisp_Timed_Select             : constant Name_Id := N + $;

   --  Names of routines and fields in Ada.Finalization, needed by expander

   Name_Initialize                     : constant Name_Id := N + $;
   Name_Adjust                         : constant Name_Id := N + $;
   Name_Finalize                       : constant Name_Id := N + $;
   Name_Finalize_Address               : constant Name_Id := N + $;
   Name_Next                           : constant Name_Id := N + $;
   Name_Prev                           : constant Name_Id := N + $;

   --  Names of allocation routines, also needed by expander

   Name_Allocate                       : constant Name_Id := N + $;
   Name_Deallocate                     : constant Name_Id := N + $;
   Name_Dereference                    : constant Name_Id := N + $;

   --  Text_IO generic subpackages (see Rtsfind.Check_Text_IO_Special_Unit)

   First_Text_IO_Package               : constant Name_Id := N + $;
   Name_Decimal_IO                     : constant Name_Id := N + $;
   Name_Enumeration_IO                 : constant Name_Id := N + $;
   Name_Fixed_IO                       : constant Name_Id := N + $;
   Name_Float_IO                       : constant Name_Id := N + $;
   Name_Integer_IO                     : constant Name_Id := N + $;
   Name_Modular_IO                     : constant Name_Id := N + $;
   Last_Text_IO_Package                : constant Name_Id := N + $;

   subtype Text_IO_Package_Name is Name_Id
     range First_Text_IO_Package .. Last_Text_IO_Package;

   --  Names used by the analyzer and expander for aspect Dimension and
   --  Dimension_System to deal with Sqrt and IO routines.

   Name_Dim_Symbol                     : constant Name_Id := N + $; -- Ada 12
   Name_Item                           : constant Name_Id := N + $; -- Ada 12
   Name_Put_Dim_Of                     : constant Name_Id := N + $; -- Ada 12
   Name_Sqrt                           : constant Name_Id := N + $; -- Ada 12
   Name_Symbol                         : constant Name_Id := N + $; -- Ada 12
   Name_Unit_Symbol                    : constant Name_Id := N + $; -- Ada 12

   --  Some miscellaneous names used for error detection/recovery

   Name_ASCII                          : constant Name_Id := N + $;
   Name_Const                          : constant Name_Id := N + $;
   Name_Error                          : constant Name_Id := N + $;
   Name_False                          : constant Name_Id := N + $;
   Name_Go                             : constant Name_Id := N + $;
   Name_Put                            : constant Name_Id := N + $;
   Name_Put_Line                       : constant Name_Id := N + $;
   Name_To                             : constant Name_Id := N + $;

   --  Name used by the integrated preprocessor

   Name_Defined                        : constant Name_Id := N + $;

   --  Names for packages that are treated specially by the compiler

   Name_Arith_64                       : constant Name_Id := N + $;
   Name_Arith_128                      : constant Name_Id := N + $;
   Name_Exception_Traces               : constant Name_Id := N + $;
   Name_Finalization                   : constant Name_Id := N + $;
   Name_Interfaces                     : constant Name_Id := N + $;
   Name_Memory                         : constant Name_Id := N + $;
   Name_Memory_Compare                 : constant Name_Id := N + $;
   Name_Memory_Copy                    : constant Name_Id := N + $;
   Name_Memory_Move                    : constant Name_Id := N + $;
   Name_Memory_Set                     : constant Name_Id := N + $;
   Name_Most_Recent_Exception          : constant Name_Id := N + $;
   Name_Stack_Checking                 : constant Name_Id := N + $;
   Name_Standard                       : constant Name_Id := N + $;
   Name_System                         : constant Name_Id := N + $;
   Name_Text_IO                        : constant Name_Id := N + $;
   Name_Wide_Text_IO                   : constant Name_Id := N + $;
   Name_Wide_Wide_Text_IO              : constant Name_Id := N + $;

   --  Names for detecting predefined potentially blocking subprograms

   Name_Abort_Task                     : constant Name_Id := N + $;
   Name_Bounded_IO                     : constant Name_Id := N + $;
   Name_C_Streams                      : constant Name_Id := N + $;
   Name_Complex_IO                     : constant Name_Id := N + $;
   Name_Directories                    : constant Name_Id := N + $;
   Name_Direct_IO                      : constant Name_Id := N + $;
   Name_Dispatching                    : constant Name_Id := N + $;
   Name_Editing                        : constant Name_Id := N + $;
   Name_EDF                            : constant Name_Id := N + $;
   Name_Reset_Standard_Files           : constant Name_Id := N + $;
   Name_Sequential_IO                  : constant Name_Id := N + $;
   Name_Strings                        : constant Name_Id := N + $;
   Name_Streams                        : constant Name_Id := N + $;
   Name_Suspend_Until_True             : constant Name_Id := N + $;
   Name_Suspend_Until_True_And_Set_Deadline : constant Name_Id := N + $;
   Name_Synchronous_Barriers           : constant Name_Id := N + $;
   Name_Task_Identification            : constant Name_Id := N + $;
   Name_Text_Streams                   : constant Name_Id := N + $;
   Name_Unbounded                      : constant Name_Id := N + $;
   Name_Unbounded_IO                   : constant Name_Id := N + $;
   Name_Wait_For_Release               : constant Name_Id := N + $;
   Name_Wide_Unbounded                 : constant Name_Id := N + $;
   Name_Wide_Wide_Unbounded            : constant Name_Id := N + $;
   Name_Yield                          : constant Name_Id := N + $;

   --  Names of implementations of the distributed systems annex

   First_PCS_Name                      : constant Name_Id := N + $;
   Name_No_DSA                         : constant Name_Id := N + $;
   Name_GARLIC_DSA                     : constant Name_Id := N + $;
   Name_PolyORB_DSA                    : constant Name_Id := N + $;
   Last_PCS_Name                       : constant Name_Id := N + $;

   subtype PCS_Names is Name_Id
     range First_PCS_Name .. Last_PCS_Name;

   --  Names of identifiers used in expanding distribution stubs

   Name_Addr                           : constant Name_Id := N + $;
   Name_Async                          : constant Name_Id := N + $;
   Name_Get_Active_Partition_ID        : constant Name_Id := N + $;
   Name_Get_RCI_Package_Receiver       : constant Name_Id := N + $;
   Name_Get_RCI_Package_Ref            : constant Name_Id := N + $;
   Name_Origin                         : constant Name_Id := N + $;
   Name_Params                         : constant Name_Id := N + $;
   Name_Partition                      : constant Name_Id := N + $;
   Name_Ras                            : constant Name_Id := N + $;
   Name_uCall                          : constant Name_Id := N + $;
   Name_RCI_Name                       : constant Name_Id := N + $;
   Name_Receiver                       : constant Name_Id := N + $;
   Name_Rpc                            : constant Name_Id := N + $;
   Name_Subp_Id                        : constant Name_Id := N + $;
   Name_Operation                      : constant Name_Id := N + $;
   Name_Argument                       : constant Name_Id := N + $;
   Name_Arg_Modes                      : constant Name_Id := N + $;
   Name_Target                         : constant Name_Id := N + $;
   Name_Req                            : constant Name_Id := N + $;
   Name_Obj_TypeCode                   : constant Name_Id := N + $;
   Name_Stub                           : constant Name_Id := N + $;

   --  Operator Symbol entries. The actual names have an upper case O at the
   --  start in place of the Op_ prefix (e.g. the actual name that corresponds
   --  to Name_Op_Abs is "Oabs").

   First_Operator_Name                 : constant Name_Id := N + $;
   Name_Op_Abs                         : constant Name_Id := N + $; -- "abs"
   Name_Op_And                         : constant Name_Id := N + $; -- "and"
   Name_Op_Mod                         : constant Name_Id := N + $; -- "mod"
   Name_Op_Not                         : constant Name_Id := N + $; -- "not"
   Name_Op_Or                          : constant Name_Id := N + $; -- "or"
   Name_Op_Rem                         : constant Name_Id := N + $; -- "rem"
   Name_Op_Xor                         : constant Name_Id := N + $; -- "xor"
   Name_Op_Eq                          : constant Name_Id := N + $; -- "="
   Name_Op_Ne                          : constant Name_Id := N + $; -- "/="
   Name_Op_Lt                          : constant Name_Id := N + $; -- "<"
   Name_Op_Le                          : constant Name_Id := N + $; -- "<="
   Name_Op_Gt                          : constant Name_Id := N + $; -- ">"
   Name_Op_Ge                          : constant Name_Id := N + $; -- ">="
   Name_Op_Add                         : constant Name_Id := N + $; -- "+"
   Name_Op_Subtract                    : constant Name_Id := N + $; -- "-"
   Name_Op_Concat                      : constant Name_Id := N + $; -- "&"
   Name_Op_Multiply                    : constant Name_Id := N + $; -- "*"
   Name_Op_Divide                      : constant Name_Id := N + $; -- "/"
   Name_Op_Expon                       : constant Name_Id := N + $; -- "**"
   Last_Operator_Name                  : constant Name_Id := N + $;

   --  Names for all pragmas recognized by GNAT. The entries with the comment
   --  "Ada 83" are pragmas that are defined in Ada 83, but not in Ada 95.
   --  These pragmas are fully implemented in all modes (Ada 83, Ada 95, and
   --  Ada 2005). In Ada 95 and Ada 2005 modes, they are technically considered
   --  to be implementation dependent pragmas.

   --  The entries marked GNAT are pragmas that are defined by GNAT and that
   --  are implemented in all modes (Ada 83, Ada 95, and Ada 2005). Complete
   --  descriptions of the syntax of these implementation dependent pragmas may
   --  be found in the appropriate section in unit Sem_Prag in file
   --  sem-prag.adb, and they are documented in the GNAT reference manual.

   --  The entries marked Ada 05 are Ada 2005 pragmas. They are implemented in
   --  Ada 83 and Ada 95 mode as well, where they are technically considered to
   --  be implementation dependent pragmas.

   --  The entries marked Ada 12 are Ada 2012 pragmas. They are implemented in
   --  Ada 83, Ada 95, and Ada 2005 mode as well, where they are technically
   --  considered to be implementation dependent pragmas.

   First_Pragma_Name                   : constant Name_Id := N + $;

   --  Configuration pragmas are grouped at start. Note that there is a list
   --  of them in the GNAT UG (doc/gnat_ugn/the_gnat_compilation_model.rst),
   --  be sure to update this list if a new configuration pragma is added.

   Name_Ada_83                         : constant Name_Id := N + $; -- GNAT
   Name_Ada_95                         : constant Name_Id := N + $; -- GNAT
   Name_Ada_05                         : constant Name_Id := N + $; -- GNAT
   Name_Ada_2005                       : constant Name_Id := N + $; -- GNAT
   Name_Ada_12                         : constant Name_Id := N + $; -- GNAT
   Name_Ada_2012                       : constant Name_Id := N + $; -- GNAT
   Name_Ada_2022                       : constant Name_Id := N + $; -- GNAT
   Name_Aggregate_Individually_Assign  : constant Name_Id := N + $; -- GNAT
   Name_Allow_Integer_Address          : constant Name_Id := N + $; -- GNAT
   Name_Annotate                       : constant Name_Id := N + $; -- GNAT
   Name_Assertion_Policy               : constant Name_Id := N + $; -- Ada 05
   Name_Assume_No_Invalid_Values       : constant Name_Id := N + $; -- GNAT
   Name_C_Pass_By_Copy                 : constant Name_Id := N + $; -- GNAT
   Name_Check_Float_Overflow           : constant Name_Id := N + $; -- GNAT
   Name_Check_Name                     : constant Name_Id := N + $; -- GNAT
   Name_Check_Policy                   : constant Name_Id := N + $; -- GNAT
   Name_Component_Alignment            : constant Name_Id := N + $; -- GNAT
   Name_Convention_Identifier          : constant Name_Id := N + $; -- GNAT
   Name_Debug_Policy                   : constant Name_Id := N + $; -- GNAT

   --  Note: Default_Scalar_Storage_Order is not in this list because its name
   --  matches the name of the corresponding attribute. However, it is included
   --  in the definition of the type Pragma_Id, and the functions Get_Pragma_Id
   --  and Is_Pragma_Name correctly recognize Default_Scalar_Storage_Order.

   Name_Default_Storage_Pool           : constant Name_Id := N + $; -- Ada 12
   Name_Detect_Blocking                : constant Name_Id := N + $; -- Ada 05
   Name_Disable_Atomic_Synchronization : constant Name_Id := N + $; -- GNAT
   Name_Discard_Names                  : constant Name_Id := N + $;
   Name_Elaboration_Checks             : constant Name_Id := N + $; -- GNAT
   Name_Eliminate                      : constant Name_Id := N + $; -- GNAT
   Name_Enable_Atomic_Synchronization  : constant Name_Id := N + $; -- GNAT
   Name_Extend_System                  : constant Name_Id := N + $; -- GNAT
   Name_Extensions_Allowed             : constant Name_Id := N + $; -- GNAT
   Name_External_Name_Casing           : constant Name_Id := N + $; -- GNAT

   --  Note: Fast_Math is not in this list because its name matches the name of
   --  the corresponding attribute. However, it is included in the definition
   --  of the type Pragma_Id and the functions Get_Pragma_Id and Is_Pragma_Name
   --  correctly recognize and process Fast_Math.

   Name_Favor_Top_Level                : constant Name_Id := N + $; -- GNAT
   Name_GNAT_Annotate                  : constant Name_Id := N + $; -- GNAT
   Name_Ignore_Pragma                  : constant Name_Id := N + $; -- GNAT
   Name_Implicit_Packing               : constant Name_Id := N + $; -- GNAT
   Name_Initialize_Scalars             : constant Name_Id := N + $; -- GNAT
   Name_Interrupt_State                : constant Name_Id := N + $; -- GNAT
   Name_License                        : constant Name_Id := N + $; -- GNAT
   Name_Locking_Policy                 : constant Name_Id := N + $;
   Name_No_Component_Reordering        : constant Name_Id := N + $; -- GNAT
   Name_No_Heap_Finalization           : constant Name_Id := N + $; -- GNAT
   Name_No_Run_Time                    : constant Name_Id := N + $; -- GNAT
   Name_No_Strict_Aliasing             : constant Name_Id := N + $; -- GNAT
   Name_Normalize_Scalars              : constant Name_Id := N + $;
   Name_Optimize_Alignment             : constant Name_Id := N + $; -- GNAT
   Name_Overflow_Mode                  : constant Name_Id := N + $; -- GNAT
   Name_Overriding_Renamings           : constant Name_Id := N + $; -- GNAT
   Name_Partition_Elaboration_Policy   : constant Name_Id := N + $; -- Ada 05
   Name_Persistent_BSS                 : constant Name_Id := N + $; -- GNAT
   Name_Prefix_Exception_Messages      : constant Name_Id := N + $; -- GNAT
   Name_Priority_Specific_Dispatching  : constant Name_Id := N + $; -- Ada 05
   Name_Profile                        : constant Name_Id := N + $; -- Ada 05
   Name_Profile_Warnings               : constant Name_Id := N + $; -- GNAT
   Name_Propagate_Exceptions           : constant Name_Id := N + $; -- GNAT
   Name_Queuing_Policy                 : constant Name_Id := N + $;
   Name_Rational                       : constant Name_Id := N + $; -- GNAT
   Name_Ravenscar                      : constant Name_Id := N + $; -- GNAT
   Name_Rename_Pragma                  : constant Name_Id := N + $; -- GNAT
   Name_Restricted_Run_Time            : constant Name_Id := N + $; -- GNAT
   Name_Restrictions                   : constant Name_Id := N + $;
   Name_Restriction_Warnings           : constant Name_Id := N + $; -- GNAT
   Name_Reviewable                     : constant Name_Id := N + $;
   Name_Short_Circuit_And_Or           : constant Name_Id := N + $; -- GNAT
   Name_Short_Descriptors              : constant Name_Id := N + $; -- GNAT
   Name_Source_File_Name               : constant Name_Id := N + $; -- GNAT
   Name_Source_File_Name_Project       : constant Name_Id := N + $; -- GNAT
   Name_SPARK_Mode                     : constant Name_Id := N + $; -- GNAT
   Name_Style_Checks                   : constant Name_Id := N + $; -- GNAT
   Name_Suppress                       : constant Name_Id := N + $;
   Name_Suppress_Exception_Locations   : constant Name_Id := N + $; -- GNAT
   Name_Task_Dispatching_Policy        : constant Name_Id := N + $;
   Name_Unevaluated_Use_Of_Old         : constant Name_Id := N + $; -- GNAT
   Name_Unsuppress                     : constant Name_Id := N + $; -- Ada 05
   Name_Use_VADS_Size                  : constant Name_Id := N + $; -- GNAT
   Name_User_Aspect_Definition         : constant Name_Id := N + $; -- GNAT
   Name_Validity_Checks                : constant Name_Id := N + $; -- GNAT
   Name_Warning_As_Error               : constant Name_Id := N + $; -- GNAT
   Name_Warnings                       : constant Name_Id := N + $; -- GNAT
   Name_Wide_Character_Encoding        : constant Name_Id := N + $; -- GNAT
   Last_Configuration_Pragma_Name      : constant Name_Id := N + $;

   --  Remaining pragma names (non-configuration pragmas)

   Name_Abort_Defer                    : constant Name_Id := N + $; -- GNAT
   Name_Abstract_State                 : constant Name_Id := N + $; -- GNAT
   Name_All_Calls_Remote               : constant Name_Id := N + $;
   Name_Always_Terminates              : constant Name_Id := N + $; -- GNAT
   Name_Assert                         : constant Name_Id := N + $; -- Ada 05
   Name_Assert_And_Cut                 : constant Name_Id := N + $; -- GNAT
   Name_Assume                         : constant Name_Id := N + $; -- GNAT
   Name_Async_Readers                  : constant Name_Id := N + $; -- GNAT
   Name_Async_Writers                  : constant Name_Id := N + $; -- GNAT
   Name_Asynchronous                   : constant Name_Id := N + $;
   Name_Atomic                         : constant Name_Id := N + $;
   Name_Atomic_Components              : constant Name_Id := N + $;
   Name_Attach_Handler                 : constant Name_Id := N + $;
   Name_Attribute_Definition           : constant Name_Id := N + $; -- GNAT
   Name_Check                          : constant Name_Id := N + $; -- GNAT
   Name_Comment                        : constant Name_Id := N + $; -- GNAT
   Name_Common_Object                  : constant Name_Id := N + $; -- GNAT
   Name_Compile_Time_Error             : constant Name_Id := N + $; -- GNAT
   Name_Compile_Time_Warning           : constant Name_Id := N + $; -- GNAT
   Name_Complete_Representation        : constant Name_Id := N + $; -- GNAT
   Name_Complex_Representation         : constant Name_Id := N + $; -- GNAT
   Name_Constant_After_Elaboration     : constant Name_Id := N + $; -- GNAT
   Name_Contract_Cases                 : constant Name_Id := N + $; -- GNAT
   Name_Controlled                     : constant Name_Id := N + $;
   Name_Convention                     : constant Name_Id := N + $;
   Name_CPP_Class                      : constant Name_Id := N + $; -- GNAT
   Name_CPP_Constructor                : constant Name_Id := N + $; -- GNAT
   Name_CPP_Virtual                    : constant Name_Id := N + $; -- GNAT
   Name_CPP_Vtable                     : constant Name_Id := N + $; -- GNAT
   Name_CUDA_Device                    : constant Name_Id := N + $; -- GNAT
   Name_CUDA_Execute                   : constant Name_Id := N + $; -- GNAT
   Name_CUDA_Global                    : constant Name_Id := N + $; -- GNAT

   --  Note: CPU is not in this list because its name matches the name of
   --  the corresponding attribute. However, it is included in the definition
   --  of the type Pragma_Id and the functions Get_Pragma_Id and Is_Pragma_Name
   --  correctly recognize and process CPU. CPU is a standard Ada 2012 pragma.

   Name_Deadline_Floor                 : constant Name_Id := N + $; -- GNAT
   Name_Debug                          : constant Name_Id := N + $; -- GNAT
   Name_Default_Initial_Condition      : constant Name_Id := N + $; -- GNAT
   Name_Depends                        : constant Name_Id := N + $; -- GNAT

   --  Note: Dispatching_Domain is not in this list because its name matches
   --  the name of the corresponding attribute. However, it is included in the
   --  definition of the type Pragma_Id, and the functions Get_Pragma_Id and
   --  Is_Pragma_Name correctly recognize and process Dispatching_Domain.
   --  Dispatching_Domain is a standard Ada 2012 pragma.

   Name_Effective_Reads                : constant Name_Id := N + $; -- GNAT
   Name_Effective_Writes               : constant Name_Id := N + $; -- GNAT
   Name_Elaborate                      : constant Name_Id := N + $; -- Ada 83
   Name_Elaborate_All                  : constant Name_Id := N + $;
   Name_Elaborate_Body                 : constant Name_Id := N + $;
   Name_Exceptional_Cases              : constant Name_Id := N + $; -- GNAT
   Name_Export                         : constant Name_Id := N + $;
   Name_Export_Function                : constant Name_Id := N + $; -- GNAT
   Name_Export_Object                  : constant Name_Id := N + $; -- GNAT
   Name_Export_Procedure               : constant Name_Id := N + $; -- GNAT
   Name_Export_Valued_Procedure        : constant Name_Id := N + $; -- GNAT
   Name_Extensions_Visible             : constant Name_Id := N + $; -- GNAT
   Name_External                       : constant Name_Id := N + $; -- GNAT
   Name_Finalize_Storage_Only          : constant Name_Id := N + $; -- GNAT
   Name_Ghost                          : constant Name_Id := N + $; -- GNAT
   Name_Global                         : constant Name_Id := N + $; -- GNAT
   Name_Ident                          : constant Name_Id := N + $; -- GNAT
   Name_Implementation_Defined         : constant Name_Id := N + $; -- GNAT
   Name_Implemented                    : constant Name_Id := N + $; -- Ada 12
   Name_Import                         : constant Name_Id := N + $;
   Name_Import_Function                : constant Name_Id := N + $; -- GNAT
   Name_Import_Object                  : constant Name_Id := N + $; -- GNAT
   Name_Import_Procedure               : constant Name_Id := N + $; -- GNAT
   Name_Import_Valued_Procedure        : constant Name_Id := N + $; -- GNAT
   Name_Independent                    : constant Name_Id := N + $; -- Ada 12
   Name_Independent_Components         : constant Name_Id := N + $; -- Ada 12
   Name_Initial_Condition              : constant Name_Id := N + $; -- GNAT
   Name_Initializes                    : constant Name_Id := N + $; -- GNAT
   Name_Inline                         : constant Name_Id := N + $;
   Name_Inline_Always                  : constant Name_Id := N + $; -- GNAT
   Name_Inline_Generic                 : constant Name_Id := N + $; -- GNAT
   Name_Inspection_Point               : constant Name_Id := N + $;

   --  Note: Interface is not in this list because its name matches an Ada 05
   --  keyword. However it is included in the definition of the type Pragma_Id,
   --  and the functions Get_Pragma_Id and Is_Pragma_Name correctly recognize
   --  and process Name_Interface.

   Name_Interface_Name                 : constant Name_Id := N + $; -- GNAT
   Name_Interrupt_Handler              : constant Name_Id := N + $;

   --  Note: Interrupt_Priority is not in this list because its name matches
   --  the name of the corresponding attribute. However, it is included in the
   --  definition of the type Pragma_Id, and the functions Get_Pragma_Id and
   --  Is_Pragma_Name correctly recognize and process Interrupt_Priority.

   Name_Invariant                      : constant Name_Id := N + $; -- GNAT
   Name_Keep_Names                     : constant Name_Id := N + $; -- GNAT
   Name_Link_With                      : constant Name_Id := N + $; -- GNAT
   Name_Linker_Alias                   : constant Name_Id := N + $; -- GNAT
   Name_Linker_Constructor             : constant Name_Id := N + $; -- GNAT
   Name_Linker_Destructor              : constant Name_Id := N + $; -- GNAT
   Name_Linker_Options                 : constant Name_Id := N + $;
   Name_Linker_Section                 : constant Name_Id := N + $; -- GNAT
   Name_List                           : constant Name_Id := N + $;
   Name_Lock_Free                      : constant Name_Id := N + $; -- GNAT
   Name_Loop_Invariant                 : constant Name_Id := N + $; -- GNAT
   Name_Loop_Optimize                  : constant Name_Id := N + $; -- GNAT
   Name_Loop_Variant                   : constant Name_Id := N + $; -- GNAT
   Name_Machine_Attribute              : constant Name_Id := N + $; -- GNAT
   Name_Main                           : constant Name_Id := N + $; -- GNAT
   Name_Main_Storage                   : constant Name_Id := N + $; -- GNAT
   Name_Max_Entry_Queue_Depth          : constant Name_Id := N + $; -- GNAT
   Name_Max_Entry_Queue_Length         : constant Name_Id := N + $; -- Ada 12
   Name_Max_Queue_Length               : constant Name_Id := N + $; -- GNAT
   Name_Memory_Size                    : constant Name_Id := N + $; -- Ada 83
   Name_No_Body                        : constant Name_Id := N + $; -- GNAT
   Name_No_Caching                     : constant Name_Id := N + $; -- GNAT
   Name_No_Elaboration_Code_All        : constant Name_Id := N + $; -- GNAT
   Name_No_Inline                      : constant Name_Id := N + $; -- GNAT
   Name_No_Return                      : constant Name_Id := N + $; -- Ada 05
   Name_No_Tagged_Streams              : constant Name_Id := N + $; -- GNAT
   Name_Obsolescent                    : constant Name_Id := N + $; -- GNAT
   Name_Optimize                       : constant Name_Id := N + $;
   Name_Ordered                        : constant Name_Id := N + $; -- GNAT
   Name_Pack                           : constant Name_Id := N + $;
   Name_Page                           : constant Name_Id := N + $;
   Name_Part_Of                        : constant Name_Id := N + $; -- GNAT
   Name_Passive                        : constant Name_Id := N + $; -- GNAT
   Name_Post                           : constant Name_Id := N + $; -- GNAT
   Name_Postcondition                  : constant Name_Id := N + $; -- GNAT
   Name_Post_Class                     : constant Name_Id := N + $; -- GNAT
   Name_Pre                            : constant Name_Id := N + $; -- GNAT
   Name_Precondition                   : constant Name_Id := N + $; -- GNAT
   Name_Predicate                      : constant Name_Id := N + $; -- GNAT
   Name_Predicate_Failure              : constant Name_Id := N + $; -- Ada 12

   --  Note: Preelaborable_Initialization is not in this list because its name
   --  matches the name of the corresponding attribute. However, it is included
   --  in the definition of the type Pragma_Id, and the functions Get_Pragma_Id
   --  and Is_Pragma_Name correctly recognize and process that pragma name.
   --  Preelaborable_Initialization is a standard Ada 2005 pragma.

   Name_Preelaborate                   : constant Name_Id := N + $;
   Name_Pre_Class                      : constant Name_Id := N + $; -- GNAT

   --  Note: Priority is not in this list because its name matches the name of
   --  the corresponding attribute. However, it is included in the definition
   --  of the type Pragma_Id and the functions Get_Pragma_Id and Is_Pragma_Name
   --  correctly recognize and process Priority. Priority is a standard Ada 95
   --  pragma.

   Name_Provide_Shift_Operators        : constant Name_Id := N + $; -- GNAT
   Name_Psect_Object                   : constant Name_Id := N + $; -- GNAT
   Name_Pure                           : constant Name_Id := N + $;
   Name_Pure_Function                  : constant Name_Id := N + $; -- GNAT
   Name_Refined_Depends                : constant Name_Id := N + $; -- GNAT
   Name_Refined_Global                 : constant Name_Id := N + $; -- GNAT
   Name_Refined_Post                   : constant Name_Id := N + $; -- GNAT
   Name_Refined_State                  : constant Name_Id := N + $; -- GNAT
   Name_Relative_Deadline              : constant Name_Id := N + $; -- Ada 05
   Name_Remote_Access_Type             : constant Name_Id := N + $; -- GNAT
   Name_Remote_Call_Interface          : constant Name_Id := N + $;
   Name_Remote_Types                   : constant Name_Id := N + $;

   --  Note: Secondary_Stack_Size is not in this list because its name matches
   --  the name of the corresponding attribute. However, it is included in the
   --  definition of the type Pragma_Id, and the functions Get_Pragma_Id and
   --  Is_Pragma_Name correctly recognize and process Secondary_Stack_Size.

   Name_Share_Generic                  : constant Name_Id := N + $; -- GNAT
   Name_Shared                         : constant Name_Id := N + $; -- Ada 83
   Name_Shared_Passive                 : constant Name_Id := N + $;
   Name_Side_Effects                   : constant Name_Id := N + $; -- GNAT
   Name_Simple_Storage_Pool_Type       : constant Name_Id := N + $; -- GNAT

   --  Note: Storage_Size is not in this list because its name matches the name
   --  of the corresponding attribute. However, it is included in the
   --  definition of the type Pragma_Id, and the functions Get_Pragma_Id and
   --  Is_Pragma_Name correctly recognize and process Name_Storage_Size.

   --  Note: Storage_Unit is also omitted from the list because of a clash with
   --  an attribute name, and is treated similarly.

   Name_Source_Reference               : constant Name_Id := N + $; -- GNAT
   Name_Static_Elaboration_Desired     : constant Name_Id := N + $; -- GNAT
   Name_Stream_Convert                 : constant Name_Id := N + $; -- GNAT
   Name_Subprogram_Variant             : constant Name_Id := N + $; -- GNAT
   Name_Subtitle                       : constant Name_Id := N + $; -- GNAT
   Name_Suppress_All                   : constant Name_Id := N + $; -- GNAT
   Name_Suppress_Debug_Info            : constant Name_Id := N + $; -- GNAT
   Name_Suppress_Initialization        : constant Name_Id := N + $; -- GNAT
   Name_System_Name                    : constant Name_Id := N + $; -- Ada 83
   Name_Task_Info                      : constant Name_Id := N + $; -- GNAT
   Name_Task_Name                      : constant Name_Id := N + $; -- GNAT
   Name_Task_Storage                   : constant Name_Id := N + $; -- GNAT
   Name_Test_Case                      : constant Name_Id := N + $; -- GNAT
   Name_Thread_Local_Storage           : constant Name_Id := N + $; -- GNAT
   Name_Time_Slice                     : constant Name_Id := N + $; -- GNAT
   Name_Title                          : constant Name_Id := N + $; -- GNAT
   Name_Type_Invariant                 : constant Name_Id := N + $; -- GNAT
   Name_Type_Invariant_Class           : constant Name_Id := N + $; -- GNAT
   Name_Unchecked_Union                : constant Name_Id := N + $; -- Ada 05
   Name_Unimplemented_Unit             : constant Name_Id := N + $; -- GNAT
   Name_Universal_Aliasing             : constant Name_Id := N + $; -- GNAT
   Name_Unmodified                     : constant Name_Id := N + $; -- GNAT
   Name_Unreferenced                   : constant Name_Id := N + $; -- GNAT
   Name_Unreferenced_Objects           : constant Name_Id := N + $; -- GNAT
   Name_Unreserve_All_Interrupts       : constant Name_Id := N + $; -- GNAT
   Name_Unused                         : constant Name_Id := N + $; -- GNAT
   Name_Volatile                       : constant Name_Id := N + $;
   Name_Volatile_Components            : constant Name_Id := N + $;
   Name_Volatile_Full_Access           : constant Name_Id := N + $; -- GNAT
   Name_Volatile_Function              : constant Name_Id := N + $; -- GNAT
   Name_Weak_External                  : constant Name_Id := N + $; -- GNAT
   Last_Pragma_Name                    : constant Name_Id := N + $;

   --  Language convention names for pragma Convention/Export/Import/Interface
   --  Note that Name_C is not included in this list, since it was already
   --  declared earlier in the context of one-character identifier names (where
   --  the order is critical to the fast look up process).

   --  Note: there are no convention names corresponding to the conventions
   --  Entry and Protected, this is because these conventions cannot be
   --  specified by a pragma.

   First_Convention_Name               : constant Name_Id := N + $;
   Name_Ada                            : constant Name_Id := N + $;
   Name_Ada_Pass_By_Copy               : constant Name_Id := N + $;
   Name_Ada_Pass_By_Reference          : constant Name_Id := N + $;
   Name_Assembler                      : constant Name_Id := N + $;
   Name_C_Variadic_0                   : constant Name_Id := N + $;
   Name_C_Variadic_1                   : constant Name_Id := N + $;
   Name_C_Variadic_2                   : constant Name_Id := N + $;
   Name_C_Variadic_3                   : constant Name_Id := N + $;
   Name_C_Variadic_4                   : constant Name_Id := N + $;
   Name_C_Variadic_5                   : constant Name_Id := N + $;
   Name_C_Variadic_6                   : constant Name_Id := N + $;
   Name_C_Variadic_7                   : constant Name_Id := N + $;
   Name_C_Variadic_8                   : constant Name_Id := N + $;
   Name_C_Variadic_9                   : constant Name_Id := N + $;
   Name_C_Variadic_10                  : constant Name_Id := N + $;
   Name_C_Variadic_11                  : constant Name_Id := N + $;
   Name_C_Variadic_12                  : constant Name_Id := N + $;
   Name_C_Variadic_13                  : constant Name_Id := N + $;
   Name_C_Variadic_14                  : constant Name_Id := N + $;
   Name_C_Variadic_15                  : constant Name_Id := N + $;
   Name_C_Variadic_16                  : constant Name_Id := N + $;
   Name_COBOL                          : constant Name_Id := N + $;
   Name_CPP                            : constant Name_Id := N + $;
   Name_Fortran                        : constant Name_Id := N + $;
   Name_Intrinsic                      : constant Name_Id := N + $;
   Name_Stdcall                        : constant Name_Id := N + $;
   Name_Stubbed                        : constant Name_Id := N + $;
   Last_Convention_Name                : constant Name_Id := N + $;

   subtype Name_C_Variadic is Name_Id
     range Name_C_Variadic_0 .. Name_C_Variadic_16;

   --  The following names are preset as synonyms for Assembler

   Name_Asm                            : constant Name_Id := N + $;
   Name_Assembly                       : constant Name_Id := N + $;

   --  The following names are preset as synonyms for C

   Name_Default                        : constant Name_Id := N + $;
   --  Name_External (previously defined as pragma)

   --  The following names are preset as synonyms for CPP

   Name_C_Plus_Plus                    : constant Name_Id := N + $;

   --  The following names are present as synonyms for Stdcall

   Name_DLL                            : constant Name_Id := N + $;
   Name_Win32                          : constant Name_Id := N + $;

   --  Other special names used in processing attributes, aspects, and pragmas

   Name_Address_Type                   : constant Name_Id := N + $;
   Name_Aggregate                      : constant Name_Id := N + $;
   Name_Allow                          : constant Name_Id := N + $;
   Name_Amount                         : constant Name_Id := N + $;
   Name_As_Is                          : constant Name_Id := N + $;
   Name_Assertion                      : constant Name_Id := N + $;
   Name_Assertions                     : constant Name_Id := N + $;
   Name_Attribute_Name                 : constant Name_Id := N + $;
   Name_Auto                           : constant Name_Id := N + $;
   Name_Body_File_Name                 : constant Name_Id := N + $;
   Name_Boolean_Entry_Barriers         : constant Name_Id := N + $;
   Name_By_Any                         : constant Name_Id := N + $;
   Name_By_Entry                       : constant Name_Id := N + $;
   Name_By_Protected_Procedure         : constant Name_Id := N + $;
   Name_Casing                         : constant Name_Id := N + $;
   Name_Code                           : constant Name_Id := N + $;
   Name_Component                      : constant Name_Id := N + $;
   Name_Component_Size_4               : constant Name_Id := N + $;
   Name_Copy                           : constant Name_Id := N + $;
   Name_Copy_From                      : constant Name_Id := N + $;
   Name_Copy_To                        : constant Name_Id := N + $;
   Name_Decreases                      : constant Name_Id := N + $;
   Name_Disable                        : constant Name_Id := N + $;
   Name_Dot_Replacement                : constant Name_Id := N + $;
   Name_Dynamic                        : constant Name_Id := N + $;
   Name_Eliminated                     : constant Name_Id := N + $;
   Name_Ensures                        : constant Name_Id := N + $;
   Name_Entity                         : constant Name_Id := N + $;
   Name_External_Name                  : constant Name_Id := N + $;
   Name_Form                           : constant Name_Id := N + $;
   Name_Gcc                            : constant Name_Id := N + $;
   Name_General                        : constant Name_Id := N + $;
   Name_Gnat                           : constant Name_Id := N + $;
   Name_Gnat_Extended_Ravenscar        : constant Name_Id := N + $;
   Name_Gnat_Ravenscar_EDF             : constant Name_Id := N + $;
   Name_Gnatprove                      : constant Name_Id := N + $;
   Name_GPL                            : constant Name_Id := N + $;
   Name_High_Order_First               : constant Name_Id := N + $;
   Name_Ignore                         : constant Name_Id := N + $;
   Name_In_Out                         : constant Name_Id := N + $;
   Name_Increases                      : constant Name_Id := N + $;
   Name_Info                           : constant Name_Id := N + $;
   Name_Internal                       : constant Name_Id := N + $;
   Name_Ivdep                          : constant Name_Id := N + $;
   Name_Jorvik                         : constant Name_Id := N + $;
   Name_Link_Name                      : constant Name_Id := N + $;
   Name_Low_Order_First                : constant Name_Id := N + $;
   Name_Lowercase                      : constant Name_Id := N + $;
   Name_Max_Size                       : constant Name_Id := N + $;
   Name_Mechanism                      : constant Name_Id := N + $;
   Name_Message                        : constant Name_Id := N + $;
   Name_Minimized                      : constant Name_Id := N + $;
   Name_Mixedcase                      : constant Name_Id := N + $;
   Name_Mode                           : constant Name_Id := N + $;
   Name_Modified_GPL                   : constant Name_Id := N + $;
   Name_Name                           : constant Name_Id := N + $;
   Name_New_Name                       : constant Name_Id := N + $;
   Name_No                             : constant Name_Id := N + $;
   Name_No_Dependence                  : constant Name_Id := N + $;
   Name_No_Dynamic_Attachment          : constant Name_Id := N + $;
   Name_No_Dynamic_Interrupts          : constant Name_Id := N + $;
   Name_No_Elaboration_Code            : constant Name_Id := N + $;
   Name_No_Implementation_Extensions   : constant Name_Id := N + $;
   Name_No_Obsolescent_Features        : constant Name_Id := N + $;
   Name_No_Requeue                     : constant Name_Id := N + $;
   Name_No_Requeue_Statements          : constant Name_Id := N + $;
   Name_No_Specification_Of_Aspect     : constant Name_Id := N + $;
   Name_No_Task_Attributes             : constant Name_Id := N + $;
   Name_No_Task_Attributes_Package     : constant Name_Id := N + $;
   Name_No_Use_Of_Attribute            : constant Name_Id := N + $;
   Name_No_Use_Of_Entity               : constant Name_Id := N + $;
   Name_No_Use_Of_Pragma               : constant Name_Id := N + $;
   Name_No_Unroll                      : constant Name_Id := N + $;
   Name_No_Unrecognized_Aspects        : constant Name_Id := N + $;
   Name_No_Vector                      : constant Name_Id := N + $;
   Name_Nominal                        : constant Name_Id := N + $;
   Name_None                           : constant Name_Id := N + $;
   Name_Null_Address                   : constant Name_Id := N + $;
   Name_On                             : constant Name_Id := N + $;
   Name_Optional                       : constant Name_Id := N + $;
   Name_Policy                         : constant Name_Id := N + $;
   Name_Parameter_Types                : constant Name_Id := N + $;
   Name_Proof_In                       : constant Name_Id := N + $;
   Name_Reason                         : constant Name_Id := N + $;
   Name_Reference                      : constant Name_Id := N + $;
   Name_Renamed                        : constant Name_Id := N + $;
   Name_Requires                       : constant Name_Id := N + $;
   Name_Restricted                     : constant Name_Id := N + $;
   Name_Result_Mechanism               : constant Name_Id := N + $;
   Name_Result_Type                    : constant Name_Id := N + $;
   Name_Robustness                     : constant Name_Id := N + $;
   Name_Runtime                        : constant Name_Id := N + $;
   Name_SB                             : constant Name_Id := N + $;
   Name_Section                        : constant Name_Id := N + $;
   Name_Semaphore                      : constant Name_Id := N + $;
   Name_Simple_Barriers                : constant Name_Id := N + $;
   Name_SPARK                          : constant Name_Id := N + $;
   Name_SPARK_05                       : constant Name_Id := N + $;
   Name_Spec_File_Name                 : constant Name_Id := N + $;
   Name_State                          : constant Name_Id := N + $;
   Name_Statement_Assertions           : constant Name_Id := N + $;
   Name_Static                         : constant Name_Id := N + $;
   Name_Stack_Size                     : constant Name_Id := N + $;
   Name_Strict                         : constant Name_Id := N + $;
   Name_Structural                     : constant Name_Id := N + $;
   Name_Subunit_File_Name              : constant Name_Id := N + $;
   Name_Suppressible                   : constant Name_Id := N + $;
   Name_Synchronous                    : constant Name_Id := N + $;
   Name_Task_Stack_Size_Default        : constant Name_Id := N + $;
   Name_Task_Type                      : constant Name_Id := N + $;
   Name_Time_Slicing_Enabled           : constant Name_Id := N + $;
   Name_Top_Guard                      : constant Name_Id := N + $;
   Name_Unit_Name                      : constant Name_Id := N + $;
   Name_Unrestricted                   : constant Name_Id := N + $;
   Name_Unroll                         : constant Name_Id := N + $;
   Name_Uppercase                      : constant Name_Id := N + $;
   Name_User                           : constant Name_Id := N + $;
   Name_Variant                        : constant Name_Id := N + $;
   Name_Vector                         : constant Name_Id := N + $;
   Name_Warn                           : constant Name_Id := N + $;
   Name_Working_Storage                : constant Name_Id := N + $;

   --  used by Repinfo JSON I/O

   Name_Present                        : constant Name_Id := N + $;

   --  Names of recognized attributes. The entries with the comment "Ada 83"
   --  are attributes that are defined in Ada 83, but not in Ada 95. These
   --  attributes are implemented in all Ada modes in GNAT.

   --  The entries marked GNAT are attributes that are defined by GNAT and
   --  implemented in all Ada modes. Full descriptions of these implementation
   --  dependent attributes may be found in the appropriate Sem_Attr section.

   First_Attribute_Name                : constant Name_Id := N + $;
   Name_Abort_Signal                   : constant Name_Id := N + $; -- GNAT
   Name_Access                         : constant Name_Id := N + $;
   Name_Address                        : constant Name_Id := N + $;
   Name_Address_Size                   : constant Name_Id := N + $; -- GNAT
   Name_Aft                            : constant Name_Id := N + $;
   Name_Alignment                      : constant Name_Id := N + $;
   Name_Asm_Input                      : constant Name_Id := N + $; -- GNAT
   Name_Asm_Output                     : constant Name_Id := N + $; -- GNAT
   Name_Atomic_Always_Lock_Free        : constant Name_Id := N + $; -- GNAT
   Name_Bit                            : constant Name_Id := N + $; -- GNAT
   Name_Bit_Order                      : constant Name_Id := N + $;
   Name_Bit_Position                   : constant Name_Id := N + $; -- GNAT
   Name_Body_Version                   : constant Name_Id := N + $;
   Name_Callable                       : constant Name_Id := N + $;
   Name_Caller                         : constant Name_Id := N + $;
   Name_Code_Address                   : constant Name_Id := N + $; -- GNAT
   Name_Compiler_Version               : constant Name_Id := N + $; -- GNAT
   Name_Component_Size                 : constant Name_Id := N + $;
   Name_Compose                        : constant Name_Id := N + $;
   Name_Constant_Indexing              : constant Name_Id := N + $; -- GNAT
   Name_Constrained                    : constant Name_Id := N + $;
   Name_Count                          : constant Name_Id := N + $;
   Name_Default_Bit_Order              : constant Name_Id := N + $; -- GNAT
   Name_Default_Scalar_Storage_Order   : constant Name_Id := N + $; -- GNAT
   Name_Default_Iterator               : constant Name_Id := N + $; -- GNAT
   Name_Definite                       : constant Name_Id := N + $;
   Name_Delta                          : constant Name_Id := N + $;
   Name_Denorm                         : constant Name_Id := N + $;
   Name_Deref                          : constant Name_Id := N + $; -- GNAT
   Name_Descriptor_Size                : constant Name_Id := N + $;
   Name_Digits                         : constant Name_Id := N + $;
   Name_Elaborated                     : constant Name_Id := N + $; -- GNAT
   Name_Emax                           : constant Name_Id := N + $; -- Ada 83
   Name_Enabled                        : constant Name_Id := N + $; -- GNAT
   Name_Enum_Rep                       : constant Name_Id := N + $; -- Ada 22
   Name_Enum_Val                       : constant Name_Id := N + $; -- Ada 22
   Name_Epsilon                        : constant Name_Id := N + $; -- Ada 83
   Name_Exponent                       : constant Name_Id := N + $;
   Name_External_Tag                   : constant Name_Id := N + $;
   Name_Fast_Math                      : constant Name_Id := N + $; -- GNAT
   Name_Finalization_Size              : constant Name_Id := N + $; -- GNAT
   Name_First                          : constant Name_Id := N + $;
   Name_First_Bit                      : constant Name_Id := N + $;
   Name_First_Valid                    : constant Name_Id := N + $; -- Ada 12
   Name_Fixed_Value                    : constant Name_Id := N + $; -- GNAT
   Name_Fore                           : constant Name_Id := N + $;
   Name_Has_Access_Values              : constant Name_Id := N + $; -- GNAT
   Name_Has_Discriminants              : constant Name_Id := N + $; -- GNAT
   Name_Has_Same_Storage               : constant Name_Id := N + $; -- Ada 12
   Name_Has_Tagged_Values              : constant Name_Id := N + $; -- GNAT
   Name_Identity                       : constant Name_Id := N + $;
   Name_Implicit_Dereference           : constant Name_Id := N + $; -- GNAT
   Name_Index                          : constant Name_Id := N + $; -- Ada 22
   Name_Initialized                    : constant Name_Id := N + $; -- GNAT
   Name_Integer_Value                  : constant Name_Id := N + $; -- GNAT
   Name_Invalid_Value                  : constant Name_Id := N + $; -- GNAT
   Name_Iterator_Element               : constant Name_Id := N + $; -- GNAT
   Name_Iterable                       : constant Name_Id := N + $; -- GNAT
   Name_Large                          : constant Name_Id := N + $; -- Ada 83
   Name_Last                           : constant Name_Id := N + $;
   Name_Last_Bit                       : constant Name_Id := N + $;
   Name_Last_Valid                     : constant Name_Id := N + $; -- Ada 12
   Name_Leading_Part                   : constant Name_Id := N + $;
   Name_Length                         : constant Name_Id := N + $;
   Name_Library_Level                  : constant Name_Id := N + $; -- GNAT
   Name_Loop_Entry                     : constant Name_Id := N + $; -- GNAT
   Name_Machine_Emax                   : constant Name_Id := N + $;
   Name_Machine_Emin                   : constant Name_Id := N + $;
   Name_Machine_Mantissa               : constant Name_Id := N + $;
   Name_Machine_Overflows              : constant Name_Id := N + $;
   Name_Machine_Radix                  : constant Name_Id := N + $;
   Name_Machine_Rounding               : constant Name_Id := N + $; -- Ada 05
   Name_Machine_Rounds                 : constant Name_Id := N + $;
   Name_Machine_Size                   : constant Name_Id := N + $; -- GNAT
   Name_Mantissa                       : constant Name_Id := N + $; -- Ada 83
   Name_Max_Alignment_For_Allocation   : constant Name_Id := N + $; -- Ada 12
   Name_Max_Integer_Size               : constant Name_Id := N + $; -- GNAT
   Name_Max_Size_In_Storage_Elements   : constant Name_Id := N + $;
   Name_Maximum_Alignment              : constant Name_Id := N + $; -- GNAT
   Name_Mechanism_Code                 : constant Name_Id := N + $; -- GNAT
   Name_Mod                            : constant Name_Id := N + $; -- Ada 05
   Name_Model_Emin                     : constant Name_Id := N + $;
   Name_Model_Epsilon                  : constant Name_Id := N + $;
   Name_Model_Mantissa                 : constant Name_Id := N + $;
   Name_Model_Small                    : constant Name_Id := N + $;
   Name_Modulus                        : constant Name_Id := N + $;
   Name_Null_Parameter                 : constant Name_Id := N + $; -- GNAT
   Name_Object_Size                    : constant Name_Id := N + $; -- GNAT
   Name_Old                            : constant Name_Id := N + $; -- Ada 12
   Name_Overlaps_Storage               : constant Name_Id := N + $; -- GNAT
   Name_Partition_ID                   : constant Name_Id := N + $;
   Name_Passed_By_Reference            : constant Name_Id := N + $; -- GNAT
   Name_Pool_Address                   : constant Name_Id := N + $; -- GNAT
   Name_Pos                            : constant Name_Id := N + $;
   Name_Position                       : constant Name_Id := N + $;
   Name_Preelaborable_Initialization   : constant Name_Id := N + $; -- Ada 22
   Name_Priority                       : constant Name_Id := N + $; -- Ada 05
   Name_Range                          : constant Name_Id := N + $;
   Name_Range_Length                   : constant Name_Id := N + $; -- GNAT
   Name_Reduce                         : constant Name_Id := N + $; -- Ada 22
   Name_Ref                            : constant Name_Id := N + $; -- GNAT
   Name_Restriction_Set                : constant Name_Id := N + $; -- GNAT
   Name_Result                         : constant Name_Id := N + $; -- GNAT
   Name_Round                          : constant Name_Id := N + $;
   Name_Safe_Emax                      : constant Name_Id := N + $; -- Ada 83
   Name_Safe_First                     : constant Name_Id := N + $;
   Name_Safe_Large                     : constant Name_Id := N + $; -- Ada 83
   Name_Safe_Last                      : constant Name_Id := N + $;
   Name_Safe_Small                     : constant Name_Id := N + $; -- Ada 83
   Name_Scalar_Storage_Order           : constant Name_Id := N + $; -- GNAT
   Name_Scale                          : constant Name_Id := N + $;
   Name_Scaling                        : constant Name_Id := N + $;
   Name_Signed_Zeros                   : constant Name_Id := N + $;
   Name_Size                           : constant Name_Id := N + $;
   Name_Small                          : constant Name_Id := N + $; -- Ada 83
   Name_Small_Denominator              : constant Name_Id := N + $; -- GNAT
   Name_Small_Numerator                : constant Name_Id := N + $; -- GNAT
   Name_Storage_Size                   : constant Name_Id := N + $;
   Name_Storage_Unit                   : constant Name_Id := N + $; -- GNAT
   Name_Stream_Size                    : constant Name_Id := N + $; -- Ada 05
   Name_System_Allocator_Alignment     : constant Name_Id := N + $; -- GNAT
   Name_Tag                            : constant Name_Id := N + $;
   Name_Target_Name                    : constant Name_Id := N + $; -- GNAT
   Name_Terminated                     : constant Name_Id := N + $;
   Name_To_Address                     : constant Name_Id := N + $; -- GNAT
   Name_Type_Class                     : constant Name_Id := N + $; -- GNAT
   Name_Type_Key                       : constant Name_Id := N + $; -- GNAT
   Name_Unbiased_Rounding              : constant Name_Id := N + $;
   Name_Unchecked_Access               : constant Name_Id := N + $;
   Name_Unconstrained_Array            : constant Name_Id := N + $; -- GNAT
   Name_Universal_Literal_String       : constant Name_Id := N + $; -- GNAT
   Name_Unrestricted_Access            : constant Name_Id := N + $; -- GNAT
   Name_Update                         : constant Name_Id := N + $; -- GNAT
   Name_VADS_Size                      : constant Name_Id := N + $; -- GNAT
   Name_Val                            : constant Name_Id := N + $;
   Name_Valid                          : constant Name_Id := N + $;
   Name_Valid_Scalars                  : constant Name_Id := N + $; -- GNAT
   Name_Value_Size                     : constant Name_Id := N + $; -- GNAT
   Name_Variable_Indexing              : constant Name_Id := N + $; -- GNAT
   Name_Version                        : constant Name_Id := N + $;
   Name_Wchar_T_Size                   : constant Name_Id := N + $; -- GNAT
   Name_Wide_Wide_Width                : constant Name_Id := N + $; -- Ada 05
   Name_Wide_Width                     : constant Name_Id := N + $;
   Name_Width                          : constant Name_Id := N + $;
   Name_Word_Size                      : constant Name_Id := N + $; -- GNAT

   --  Attributes that designate attributes returning renamable functions,
   --  i.e. functions that return other than a universal value and that
   --  have non-universal arguments.

   First_Renamable_Function_Attribute  : constant Name_Id := N + $;
   Name_Adjacent                       : constant Name_Id := N + $;
   Name_Ceiling                        : constant Name_Id := N + $;
   Name_Copy_Sign                      : constant Name_Id := N + $;
   Name_Floor                          : constant Name_Id := N + $;
   Name_Fraction                       : constant Name_Id := N + $;
   Name_From_Any                       : constant Name_Id := N + $; -- GNAT
   Name_Image                          : constant Name_Id := N + $;
   Name_Img                            : constant Name_Id := N + $; -- GNAT
   Name_Input                          : constant Name_Id := N + $;
   Name_Machine                        : constant Name_Id := N + $;
   Name_Max                            : constant Name_Id := N + $;
   Name_Min                            : constant Name_Id := N + $;
   Name_Model                          : constant Name_Id := N + $;
   Name_Pred                           : constant Name_Id := N + $;
   Name_Remainder                      : constant Name_Id := N + $;
   Name_Rounding                       : constant Name_Id := N + $;
   Name_Succ                           : constant Name_Id := N + $;
   Name_To_Any                         : constant Name_Id := N + $; -- GNAT
   Name_Truncation                     : constant Name_Id := N + $;
   Name_TypeCode                       : constant Name_Id := N + $; -- GNAT
   Name_Valid_Value                    : constant Name_Id := N + $; -- GNAT
   Name_Value                          : constant Name_Id := N + $;
   Name_Wide_Image                     : constant Name_Id := N + $;
   Name_Wide_Wide_Image                : constant Name_Id := N + $;
   Name_Wide_Value                     : constant Name_Id := N + $;
   Name_Wide_Wide_Value                : constant Name_Id := N + $;
   Last_Renamable_Function_Attribute   : constant Name_Id := N + $;

   --  Attributes that designate procedures

   First_Procedure_Attribute           : constant Name_Id := N + $;
   Name_Output                         : constant Name_Id := N + $;
   Name_Put_Image                      : constant Name_Id := N + $;
   Name_Read                           : constant Name_Id := N + $;
   Name_Write                          : constant Name_Id := N + $;
   Last_Procedure_Attribute            : constant Name_Id := N + $;

   --  Remaining attributes are ones that return entities

   --  Note that Elab_Subp_Body is not considered to be a valid attribute name
   --  unless we are operating in CodePeer mode.

   First_Entity_Attribute_Name         : constant Name_Id := N + $;
   Name_Elab_Body                      : constant Name_Id := N + $; -- GNAT
   Name_Elab_Spec                      : constant Name_Id := N + $; -- GNAT
   Name_Elab_Subp_Body                 : constant Name_Id := N + $; -- GNAT
   Name_Simple_Storage_Pool            : constant Name_Id := N + $; -- GNAT
   Name_Storage_Pool                   : constant Name_Id := N + $;

   --  These attributes are the ones that return types

   First_Type_Attribute_Name           : constant Name_Id := N + $;
   Name_Base                           : constant Name_Id := N + $;
   Name_Class                          : constant Name_Id := N + $;
   Name_Stub_Type                      : constant Name_Id := N + $; -- GNAT
   Last_Type_Attribute_Name            : constant Name_Id := N + $;
   Last_Entity_Attribute_Name          : constant Name_Id := N + $;
   Last_Attribute_Name                 : constant Name_Id := N + $;

   --  Names of internal attributes. They are not real attributes but special
   --  names used internally by GNAT in order to deal with delayed aspects
   --  (Aspect_CPU, Aspect_Dispatching_Domain, Aspect_Interrupt_Priority,
   --  Aspect_Secondary_Stack_Size) that don't have corresponding pragmas or
   --  user-referenceable attributes.

   --  It is convenient to have these internal attributes available for
   --  processing the aspects, since the normal approach is to convert an
   --  aspect into its corresponding pragma or attribute specification.

   --  These attributes do have Attribute_Id values so that case statements
   --  on Attribute_Id include these cases, but they are NOT included in the
   --  Attribute_Name subtype defined above, which is typically used in the
   --  front end for checking syntax of submitted programs (where the use of
   --  internal attributes is not permitted).

   First_Internal_Attribute_Name       : constant Name_Id := N + $;
   Name_CPU                            : constant Name_Id := N + $;
   Name_Dispatching_Domain             : constant Name_Id := N + $;
   Name_Interrupt_Priority             : constant Name_Id := N + $;
   Name_Secondary_Stack_Size           : constant Name_Id := N + $; -- GNAT
   Last_Internal_Attribute_Name        : constant Name_Id := N + $;

   --  Names of recognized locking policy identifiers

   First_Locking_Policy_Name           : constant Name_Id := N + $;
   Name_Ceiling_Locking                : constant Name_Id := N + $;
   Name_Inheritance_Locking            : constant Name_Id := N + $;
   Name_Concurrent_Readers_Locking     : constant Name_Id := N + $; -- GNAT
   Last_Locking_Policy_Name            : constant Name_Id := N + $;

   --  Names of recognized queuing policy identifiers

   --  Note: policies are identified by the first character of the name (e.g. F
   --  for FIFO_Queuing). If new policy names are added, the first character
   --  must be distinct.

   First_Queuing_Policy_Name           : constant Name_Id := N + $;
   Name_FIFO_Queuing                   : constant Name_Id := N + $;
   Name_Priority_Queuing               : constant Name_Id := N + $;
   Last_Queuing_Policy_Name            : constant Name_Id := N + $;

   --  Names of recognized task dispatching policy identifiers

   --  Note: policies are identified by the first character of the name (e.g. F
   --  for FIFO_Within_Priorities). If new policy names are added, the first
   --  character must be distinct.

   First_Task_Dispatching_Policy_Name         : constant Name_Id := N + $;
   Name_EDF_Across_Priorities                 : constant Name_Id := N + $;
   Name_FIFO_Within_Priorities                : constant Name_Id := N + $;
   Name_Non_Preemptive_FIFO_Within_Priorities : constant Name_Id := N + $;
   Name_Round_Robin_Within_Priorities         : constant Name_Id := N + $;
   Last_Task_Dispatching_Policy_Name          : constant Name_Id := N + $;

   --  Names of recognized partition elaboration policy identifiers

   --  Note: policies are identified by the first character of the name (e.g. S
   --  for Sequential). If new policy names are added, the first character must
   --  be distinct.

   First_Partition_Elaboration_Policy_Name : constant Name_Id := N + $;
   Name_Concurrent                         : constant Name_Id := N + $;
   Name_Sequential                         : constant Name_Id := N + $;
   Last_Partition_Elaboration_Policy_Name  : constant Name_Id := N + $;

   --  Names of recognized scalar families for pragma Initialize_Scalars

   Name_Short_Float                    : constant Name_Id := N + $; -- GNAT
   Name_Float                          : constant Name_Id := N + $; -- GNAT
   Name_Long_Float                     : constant Name_Id := N + $; -- GNAT
   Name_Long_Long_Float                : constant Name_Id := N + $; -- GNAT
   Name_Signed_8                       : constant Name_Id := N + $; -- GNAT
   Name_Signed_16                      : constant Name_Id := N + $; -- GNAT
   Name_Signed_32                      : constant Name_Id := N + $; -- GNAT
   Name_Signed_64                      : constant Name_Id := N + $; -- GNAT
   Name_Signed_128                     : constant Name_Id := N + $; -- GNAT
   Name_Unsigned_8                     : constant Name_Id := N + $; -- GNAT
   Name_Unsigned_16                    : constant Name_Id := N + $; -- GNAT
   Name_Unsigned_32                    : constant Name_Id := N + $; -- GNAT
   Name_Unsigned_64                    : constant Name_Id := N + $; -- GNAT
   Name_Unsigned_128                   : constant Name_Id := N + $; -- GNAT

   subtype Scalar_Id is Name_Id
     range Name_Short_Float .. Name_Unsigned_128;

   subtype Float_Scalar_Id is Name_Id
     range Name_Short_Float .. Name_Long_Long_Float;

   subtype Integer_Scalar_Id is Name_Id
     range Name_Signed_8 .. Name_Unsigned_128;

   --  Names of recognized checks for pragma Suppress

   --  Note: the name Atomic_Synchronization can only be specified internally
   --  as a result of using pragma Enable/Disable_Atomic_Synchronization.

   First_Check_Name                    : constant Name_Id := N + $;
   Name_Access_Check                   : constant Name_Id := N + $;
   Name_Accessibility_Check            : constant Name_Id := N + $;
   Name_Alignment_Check                : constant Name_Id := N + $; -- GNAT
   Name_Allocation_Check               : constant Name_Id := N + $;
   Name_Atomic_Synchronization         : constant Name_Id := N + $; -- GNAT
   Name_Characters_Assertion_Check     : constant Name_Id := N + $;
   Name_Containers_Assertion_Check     : constant Name_Id := N + $;
   Name_Discriminant_Check             : constant Name_Id := N + $;
   Name_Division_Check                 : constant Name_Id := N + $;
   Name_Duplicated_Tag_Check           : constant Name_Id := N + $; -- GNAT
   Name_Elaboration_Check              : constant Name_Id := N + $;
   Name_Index_Check                    : constant Name_Id := N + $;
   Name_Interfaces_Assertion_Check     : constant Name_Id := N + $;
   Name_IO_Assertion_Check             : constant Name_Id := N + $;
   Name_Length_Check                   : constant Name_Id := N + $;
   Name_Numerics_Assertion_Check       : constant Name_Id := N + $;
   Name_Overflow_Check                 : constant Name_Id := N + $;
   Name_Predicate_Check                : constant Name_Id := N + $; -- GNAT
   Name_Program_Error_Check            : constant Name_Id := N + $;
   Name_Range_Check                    : constant Name_Id := N + $;
   Name_Storage_Check                  : constant Name_Id := N + $;
   Name_Strings_Assertion_Check        : constant Name_Id := N + $;
   Name_System_Assertion_Check         : constant Name_Id := N + $;
   Name_Tag_Check                      : constant Name_Id := N + $;
   Name_Validity_Check                 : constant Name_Id := N + $; -- GNAT
   Name_Container_Checks               : constant Name_Id := N + $; -- GNAT
   Name_Tampering_Check                : constant Name_Id := N + $; -- GNAT
   Name_Tasking_Check                  : constant Name_Id := N + $;
   Name_All_Checks                     : constant Name_Id := N + $;
   Last_Check_Name                     : constant Name_Id := N + $;

   --  Ada 83 reserved words, excluding those already declared in the attribute
   --  list (Access, Delta, Digits, Mod, Range).

   Name_Abort                            : constant Name_Id := N + $;
   Name_Abs                              : constant Name_Id := N + $;
   Name_Accept                           : constant Name_Id := N + $;
   Name_And                              : constant Name_Id := N + $;
   Name_All                              : constant Name_Id := N + $;
   Name_Array                            : constant Name_Id := N + $;
   Name_At                               : constant Name_Id := N + $;
   Name_Begin                            : constant Name_Id := N + $;
   Name_Body                             : constant Name_Id := N + $;
   Name_Case                             : constant Name_Id := N + $;
   Name_Constant                         : constant Name_Id := N + $;
   Name_Declare                          : constant Name_Id := N + $;
   Name_Delay                            : constant Name_Id := N + $;
   Name_Do                               : constant Name_Id := N + $;
   Name_Else                             : constant Name_Id := N + $;
   Name_Elsif                            : constant Name_Id := N + $;
   Name_End                              : constant Name_Id := N + $;
   Name_Entry                            : constant Name_Id := N + $;
   Name_Exception                        : constant Name_Id := N + $;
   Name_Exit                             : constant Name_Id := N + $;
   Name_For                              : constant Name_Id := N + $;
   Name_Function                         : constant Name_Id := N + $;
   Name_Generic                          : constant Name_Id := N + $;
   Name_Goto                             : constant Name_Id := N + $;
   Name_If                               : constant Name_Id := N + $;
   Name_In                               : constant Name_Id := N + $;
   Name_Is                               : constant Name_Id := N + $;
   Name_Limited                          : constant Name_Id := N + $;
   Name_Loop                             : constant Name_Id := N + $;
   Name_New                              : constant Name_Id := N + $;
   Name_Not                              : constant Name_Id := N + $;
   Name_Null                             : constant Name_Id := N + $;
   Name_Of                               : constant Name_Id := N + $;
   Name_Or                               : constant Name_Id := N + $;
   Name_Others                           : constant Name_Id := N + $;
   Name_Out                              : constant Name_Id := N + $;
   Name_Package                          : constant Name_Id := N + $;
   Name_Pragma                           : constant Name_Id := N + $;
   Name_Private                          : constant Name_Id := N + $;
   Name_Procedure                        : constant Name_Id := N + $;
   Name_Raise                            : constant Name_Id := N + $;
   Name_Record                           : constant Name_Id := N + $;
   Name_Rem                              : constant Name_Id := N + $;
   Name_Renames                          : constant Name_Id := N + $;
   Name_Return                           : constant Name_Id := N + $;
   Name_Reverse                          : constant Name_Id := N + $;
   Name_Select                           : constant Name_Id := N + $;
   Name_Separate                         : constant Name_Id := N + $;
   Name_Subtype                          : constant Name_Id := N + $;
   Name_Task                             : constant Name_Id := N + $;
   Name_Terminate                        : constant Name_Id := N + $;
   Name_Then                             : constant Name_Id := N + $;
   Name_Type                             : constant Name_Id := N + $;
   Name_Use                              : constant Name_Id := N + $;
   Name_When                             : constant Name_Id := N + $;
   Name_While                            : constant Name_Id := N + $;
   Name_With                             : constant Name_Id := N + $;
   Name_Xor                              : constant Name_Id := N + $;

   --  Names of intrinsic subprograms

   --  Note: Asm is missing from this list, since Asm is a legitimate
   --  convention name. So is To_Address, which is a GNAT attribute.

   First_Intrinsic_Name                  : constant Name_Id := N + $;
   Name_Compilation_ISO_Date             : constant Name_Id := N + $;
   Name_Compilation_Date                 : constant Name_Id := N + $;
   Name_Compilation_Time                 : constant Name_Id := N + $;
   Name_Divide                           : constant Name_Id := N + $;
   Name_Enclosing_Entity                 : constant Name_Id := N + $;
   Name_Exception_Information            : constant Name_Id := N + $;
   Name_Exception_Message                : constant Name_Id := N + $;
   Name_Exception_Name                   : constant Name_Id := N + $;
   Name_File                             : constant Name_Id := N + $;
   Name_Generic_Dispatching_Constructor  : constant Name_Id := N + $;
   Name_Import_Address                   : constant Name_Id := N + $;
   Name_Import_Largest_Value             : constant Name_Id := N + $;
   Name_Import_Value                     : constant Name_Id := N + $;
   Name_Line                             : constant Name_Id := N + $;
   Name_Rotate_Left                      : constant Name_Id := N + $;
   Name_Rotate_Right                     : constant Name_Id := N + $;
   Name_Shift_Left                       : constant Name_Id := N + $;
   Name_Shift_Right                      : constant Name_Id := N + $;
   Name_Shift_Right_Arithmetic           : constant Name_Id := N + $;
   Name_Source_Location                  : constant Name_Id := N + $;
   Name_To_Integer                       : constant Name_Id := N + $;
   Name_To_Pointer                       : constant Name_Id := N + $;
   Name_Unchecked_Conversion             : constant Name_Id := N + $;
   Name_Unchecked_Deallocation           : constant Name_Id := N + $;
   Last_Intrinsic_Name                   : constant Name_Id := N + $;

   --  Names used in processing intrinsic calls

   Name_Free                             : constant Name_Id := N + $;

   --  Ada 95 reserved words

   First_95_Reserved_Word                : constant Name_Id := N + $;
   Name_Abstract                         : constant Name_Id := N + $;
   Name_Aliased                          : constant Name_Id := N + $;
   Name_Protected                        : constant Name_Id := N + $;
   Name_Until                            : constant Name_Id := N + $;
   Name_Requeue                          : constant Name_Id := N + $;
   Name_Tagged                           : constant Name_Id := N + $;
   Last_95_Reserved_Word                 : constant Name_Id := N + $;

   subtype Ada_95_Reserved_Words is Name_Id
     range First_95_Reserved_Word .. Last_95_Reserved_Word;

   --  Additional names used by the Repinfo unit

   Name_Discriminant                     : constant Name_Id := N + $;
   Name_Operands                         : constant Name_Id := N + $;

   --  Other miscellaneous names used in front end
   --  Note that the UP_ prefix means use the rest of the name in uppercase,
   --  e.g. Name_UP_RESULT corresponds to the name "RESULT".

   Name_UP_RESULT                        : constant Name_Id := N + $;
   Name_Synchronous_Task_Control         : constant Name_Id := N + $;

   --  Names used to implement iterators over predefined containers

   Name_Cursor                           : constant Name_Id := N + $;
   Name_Element                          : constant Name_Id := N + $;
   Name_Has_Element                      : constant Name_Id := N + $;
   Name_Forward_Iterator                 : constant Name_Id := N + $;
   Name_Reversible_Iterator              : constant Name_Id := N + $;
   Name_uNext                            : constant Name_Id := N + $;
   Name_Previous                         : constant Name_Id := N + $;
   Name_uPrevious                        : constant Name_Id := N + $;
   Name_Pseudo_Reference                 : constant Name_Id := N + $;
   Name_Reference_Control_Type           : constant Name_Id := N + $;
   Name_Get_Element_Access               : constant Name_Id := N + $;

   --  Names for Ada 202x Aggregate aspect. Name_Aggregate is already
   --  present for gprbuild.

   Name_Empty                            : constant Name_Id := N + $;
   Name_Add_Named                        : constant Name_Id := N + $;
   Name_Add_Unnamed                      : constant Name_Id := N + $;
   Name_New_Indexed                      : constant Name_Id := N + $;
   Name_Assign_Indexed                   : constant Name_Id := N + $;

   --  Ada 2005 reserved words

   First_2005_Reserved_Word              : constant Name_Id := N + $;
   Name_Interface                        : constant Name_Id := N + $;
   Name_Overriding                       : constant Name_Id := N + $;
   Name_Synchronized                     : constant Name_Id := N + $;
   Last_2005_Reserved_Word               : constant Name_Id := N + $;

   subtype Ada_2005_Reserved_Words is Name_Id
     range First_2005_Reserved_Word .. Last_2005_Reserved_Word;

   --  Ada 2012 reserved words

   First_2012_Reserved_Word              : constant Name_Id := N + $;
   Name_Some                             : constant Name_Id := N + $;
   Last_2012_Reserved_Word               : constant Name_Id := N + $;

   subtype Ada_2012_Reserved_Words is Name_Id
     range First_2012_Reserved_Word .. Last_2012_Reserved_Word;

   --  Mark last defined name for consistency check in Snames body

   Last_Predefined_Name                  : constant Name_Id := N + $;

   ---------------------------------------
   -- Subtypes Defining Name Categories --
   ---------------------------------------

   subtype Any_Operator_Name is Name_Id
     range First_Operator_Name .. Last_Operator_Name;

   subtype Configuration_Pragma_Names is Name_Id
     range First_Pragma_Name .. Last_Configuration_Pragma_Name;

   ------------------------------
   -- Attribute ID Definitions --
   ------------------------------

   type Attribute_Id is (
      Attribute_Abort_Signal,
      Attribute_Access,
      Attribute_Address,
      Attribute_Address_Size,
      Attribute_Aft,
      Attribute_Alignment,
      Attribute_Asm_Input,
      Attribute_Asm_Output,
      Attribute_Atomic_Always_Lock_Free,
      Attribute_Bit,
      Attribute_Bit_Order,
      Attribute_Bit_Position,
      Attribute_Body_Version,
      Attribute_Callable,
      Attribute_Caller,
      Attribute_Code_Address,
      Attribute_Compiler_Version,
      Attribute_Component_Size,
      Attribute_Compose,
      Attribute_Constant_Indexing,
      Attribute_Constrained,
      Attribute_Count,
      Attribute_Default_Bit_Order,
      Attribute_Default_Scalar_Storage_Order,
      Attribute_Default_Iterator,
      Attribute_Definite,
      Attribute_Delta,
      Attribute_Denorm,
      Attribute_Deref,
      Attribute_Descriptor_Size,
      Attribute_Digits,
      Attribute_Elaborated,
      Attribute_Emax,
      Attribute_Enabled,
      Attribute_Enum_Rep,
      Attribute_Enum_Val,
      Attribute_Epsilon,
      Attribute_Exponent,
      Attribute_External_Tag,
      Attribute_Fast_Math,
      Attribute_Finalization_Size,
      Attribute_First,
      Attribute_First_Bit,
      Attribute_First_Valid,
      Attribute_Fixed_Value,
      Attribute_Fore,
      Attribute_Has_Access_Values,
      Attribute_Has_Discriminants,
      Attribute_Has_Same_Storage,
      Attribute_Has_Tagged_Values,
      Attribute_Identity,
      Attribute_Implicit_Dereference,
      Attribute_Index,
      Attribute_Initialized,
      Attribute_Integer_Value,
      Attribute_Invalid_Value,
      Attribute_Iterator_Element,
      Attribute_Iterable,
      Attribute_Large,
      Attribute_Last,
      Attribute_Last_Bit,
      Attribute_Last_Valid,
      Attribute_Leading_Part,
      Attribute_Length,
      Attribute_Library_Level,
      Attribute_Loop_Entry,
      Attribute_Machine_Emax,
      Attribute_Machine_Emin,
      Attribute_Machine_Mantissa,
      Attribute_Machine_Overflows,
      Attribute_Machine_Radix,
      Attribute_Machine_Rounding,
      Attribute_Machine_Rounds,
      Attribute_Machine_Size,
      Attribute_Mantissa,
      Attribute_Max_Alignment_For_Allocation,
      Attribute_Max_Integer_Size,
      Attribute_Max_Size_In_Storage_Elements,
      Attribute_Maximum_Alignment,
      Attribute_Mechanism_Code,
      Attribute_Mod,
      Attribute_Model_Emin,
      Attribute_Model_Epsilon,
      Attribute_Model_Mantissa,
      Attribute_Model_Small,
      Attribute_Modulus,
      Attribute_Null_Parameter,
      Attribute_Object_Size,
      Attribute_Old,
      Attribute_Overlaps_Storage,
      Attribute_Partition_ID,
      Attribute_Passed_By_Reference,
      Attribute_Pool_Address,
      Attribute_Pos,
      Attribute_Position,
      Attribute_Preelaborable_Initialization,
      Attribute_Priority,
      Attribute_Range,
      Attribute_Range_Length,
      Attribute_Reduce,
      Attribute_Ref,
      Attribute_Restriction_Set,
      Attribute_Result,
      Attribute_Round,
      Attribute_Safe_Emax,
      Attribute_Safe_First,
      Attribute_Safe_Large,
      Attribute_Safe_Last,
      Attribute_Safe_Small,
      Attribute_Scalar_Storage_Order,
      Attribute_Scale,
      Attribute_Scaling,
      Attribute_Signed_Zeros,
      Attribute_Size,
      Attribute_Small,
      Attribute_Small_Denominator,
      Attribute_Small_Numerator,
      Attribute_Storage_Size,
      Attribute_Storage_Unit,
      Attribute_Stream_Size,
      Attribute_System_Allocator_Alignment,
      Attribute_Tag,
      Attribute_Target_Name,
      Attribute_Terminated,
      Attribute_To_Address,
      Attribute_Type_Class,
      Attribute_Type_Key,
      Attribute_Unbiased_Rounding,
      Attribute_Unchecked_Access,
      Attribute_Unconstrained_Array,
      Attribute_Universal_Literal_String,
      Attribute_Unrestricted_Access,
      Attribute_Update,
      Attribute_VADS_Size,
      Attribute_Val,
      Attribute_Valid,
      Attribute_Valid_Scalars,
      Attribute_Value_Size,
      Attribute_Variable_Indexing,
      Attribute_Version,
      Attribute_Wchar_T_Size,
      Attribute_Wide_Wide_Width,
      Attribute_Wide_Width,
      Attribute_Width,
      Attribute_Word_Size,

      --  Attributes designating renamable functions

      Attribute_Adjacent,
      Attribute_Ceiling,
      Attribute_Copy_Sign,
      Attribute_Floor,
      Attribute_Fraction,
      Attribute_From_Any,
      Attribute_Image,
      Attribute_Img,
      Attribute_Input,
      Attribute_Machine,
      Attribute_Max,
      Attribute_Min,
      Attribute_Model,
      Attribute_Pred,
      Attribute_Remainder,
      Attribute_Rounding,
      Attribute_Succ,
      Attribute_To_Any,
      Attribute_Truncation,
      Attribute_TypeCode,
      Attribute_Valid_Value,
      Attribute_Value,
      Attribute_Wide_Image,
      Attribute_Wide_Wide_Image,
      Attribute_Wide_Value,
      Attribute_Wide_Wide_Value,

      --  Attributes designating procedures

      Attribute_Output,
      Attribute_Put_Image,
      Attribute_Read,
      Attribute_Write,

      --  Entity attributes (includes type attributes)

      Attribute_Elab_Body,
      Attribute_Elab_Spec,
      Attribute_Elab_Subp_Body,
      Attribute_Simple_Storage_Pool,
      Attribute_Storage_Pool,

      --  Type attributes

      Attribute_Base,
      Attribute_Class,
      Attribute_Stub_Type,

      --  The internal attributes are on their own, out of order, because of
      --  the special processing required to deal with the fact that their
      --  names are not attribute names.

      Attribute_CPU,
      Attribute_Dispatching_Domain,
      Attribute_Interrupt_Priority);

   subtype Internal_Attribute_Id is Attribute_Id
     range Attribute_CPU .. Attribute_Interrupt_Priority;

   type Attribute_Set is array (Attribute_Id) of Boolean;
   --  Type used to build attribute classification flag arrays

   ------------------------------------
   -- Convention Name ID Definitions --
   ------------------------------------

   type Convention_Id is (

      --  The native-to-Ada (non-foreign) conventions come first. These include
      --  the ones defined in the RM, plus Stubbed.

      Convention_Ada,
      Convention_Intrinsic,
      Convention_Entry,
      Convention_Protected,
      Convention_Stubbed,

      --  The following conventions are equivalent to Ada for all purposes
      --  except controlling the way parameters are passed.

      Convention_Ada_Pass_By_Copy,
      Convention_Ada_Pass_By_Reference,

      --  The remaining conventions are foreign language conventions

      Convention_Assembler,      --  also Asm, Assembly
      Convention_C,              --  also Default, External
      Convention_C_Variadic_0,
      Convention_C_Variadic_1,
      Convention_C_Variadic_2,
      Convention_C_Variadic_3,
      Convention_C_Variadic_4,
      Convention_C_Variadic_5,
      Convention_C_Variadic_6,
      Convention_C_Variadic_7,
      Convention_C_Variadic_8,
      Convention_C_Variadic_9,
      Convention_C_Variadic_10,
      Convention_C_Variadic_11,
      Convention_C_Variadic_12,
      Convention_C_Variadic_13,
      Convention_C_Variadic_14,
      Convention_C_Variadic_15,
      Convention_C_Variadic_16,
      Convention_CPP,
      Convention_COBOL,
      Convention_Fortran,
      Convention_Stdcall);       --  also DLL, Win32

      --  Note: Convention C_Pass_By_Copy is allowed only for record types
      --  (where it is treated like C except that the appropriate flag is set
      --  in the record type). Recognizing this convention is specially handled
      --  in Sem_Prag.

   for Convention_Id'Size use 8;

   subtype Convention_C_Family is Convention_Id
     range Convention_C .. Convention_CPP;

   subtype Convention_C_Variadic is Convention_Id
     range Convention_C_Variadic_0 .. Convention_C_Variadic_16;

   subtype Foreign_Convention is Convention_Id
     range Convention_Assembler .. Convention_Stdcall;

   -----------------------------------
   -- Locking Policy ID Definitions --
   -----------------------------------

   type Locking_Policy_Id is (
      Locking_Policy_Inheritance_Locking,
      Locking_Policy_Ceiling_Locking,
      Locking_Policy_Concurrent_Readers_Locking);

   ---------------------------
   -- Pragma ID Definitions --
   ---------------------------

   type Pragma_Id is (

      --  Configuration pragmas are grouped at start. Note that there is a list
      --  of them in the GNAT UG (doc/gnat_ugn/the_gnat_compilation_model.rst),
      --  be sure to update this list if a new configuration pragma is added.

      Pragma_Ada_83,
      Pragma_Ada_95,
      Pragma_Ada_05,
      Pragma_Ada_2005,
      Pragma_Ada_12,
      Pragma_Ada_2012,
      Pragma_Ada_2022,
      --  Note that there is no Pragma_Ada_22. Pragma_Ada_05/12 are for
      --  compatibility reasons only; the full year names are preferred.
      Pragma_Aggregate_Individually_Assign,
      Pragma_Allow_Integer_Address,
      Pragma_Annotate,
      Pragma_Assertion_Policy,
      Pragma_Assume_No_Invalid_Values,
      Pragma_C_Pass_By_Copy,
      Pragma_Check_Float_Overflow,
      Pragma_Check_Name,
      Pragma_Check_Policy,
      Pragma_Component_Alignment,
      Pragma_Convention_Identifier,
      Pragma_Debug_Policy,
      Pragma_Default_Storage_Pool,
      Pragma_Detect_Blocking,
      Pragma_Disable_Atomic_Synchronization,
      Pragma_Discard_Names,
      Pragma_Elaboration_Checks,
      Pragma_Eliminate,
      Pragma_Enable_Atomic_Synchronization,
      Pragma_Extend_System,
      Pragma_Extensions_Allowed,
      Pragma_External_Name_Casing,
      Pragma_Favor_Top_Level,
      Pragma_GNAT_Annotate,
      Pragma_Ignore_Pragma,
      Pragma_Implicit_Packing,
      Pragma_Initialize_Scalars,
      Pragma_Interrupt_State,
      Pragma_License,
      Pragma_Locking_Policy,
      Pragma_No_Component_Reordering,
      Pragma_No_Heap_Finalization,
      Pragma_No_Run_Time,
      Pragma_No_Strict_Aliasing,
      Pragma_Normalize_Scalars,
      Pragma_Optimize_Alignment,
      Pragma_Overflow_Mode,
      Pragma_Overriding_Renamings,
      Pragma_Partition_Elaboration_Policy,
      Pragma_Persistent_BSS,
      Pragma_Prefix_Exception_Messages,
      Pragma_Priority_Specific_Dispatching,
      Pragma_Profile,
      Pragma_Profile_Warnings,
      Pragma_Propagate_Exceptions,
      Pragma_Queuing_Policy,
      Pragma_Rational,
      Pragma_Ravenscar,
      Pragma_Rename_Pragma,
      Pragma_Restricted_Run_Time,
      Pragma_Restrictions,
      Pragma_Restriction_Warnings,
      Pragma_Reviewable,
      Pragma_Short_Circuit_And_Or,
      Pragma_Short_Descriptors,
      Pragma_Source_File_Name,
      Pragma_Source_File_Name_Project,
      Pragma_SPARK_Mode,
      Pragma_Style_Checks,
      Pragma_Suppress,
      Pragma_Suppress_Exception_Locations,
      Pragma_Task_Dispatching_Policy,
      Pragma_Unevaluated_Use_Of_Old,
      Pragma_Unsuppress,
      Pragma_Use_VADS_Size,
      Pragma_User_Aspect_Definition,
      Pragma_Validity_Checks,
      Pragma_Warning_As_Error,
      Pragma_Warnings,
      Pragma_Wide_Character_Encoding,

      --  Remaining (non-configuration) pragmas

      Pragma_Abort_Defer,
      Pragma_Abstract_State,
      Pragma_All_Calls_Remote,
      Pragma_Always_Terminates,
      Pragma_Assert,
      Pragma_Assert_And_Cut,
      Pragma_Assume,
      Pragma_Async_Readers,
      Pragma_Async_Writers,
      Pragma_Asynchronous,
      Pragma_Atomic,
      Pragma_Atomic_Components,
      Pragma_Attach_Handler,
      Pragma_Attribute_Definition,
      Pragma_Check,
      Pragma_Comment,
      Pragma_Common_Object,
      Pragma_Compile_Time_Error,
      Pragma_Compile_Time_Warning,
      Pragma_Complete_Representation,
      Pragma_Complex_Representation,
      Pragma_Constant_After_Elaboration,
      Pragma_Contract_Cases,
      Pragma_Controlled,
      Pragma_Convention,
      Pragma_CPP_Class,
      Pragma_CPP_Constructor,
      Pragma_CPP_Virtual,
      Pragma_CPP_Vtable,
      Pragma_CUDA_Device,
      Pragma_CUDA_Execute,
      Pragma_CUDA_Global,
      Pragma_Deadline_Floor,
      Pragma_Debug,
      Pragma_Default_Initial_Condition,
      Pragma_Depends,
      Pragma_Effective_Reads,
      Pragma_Effective_Writes,
      Pragma_Elaborate,
      Pragma_Elaborate_All,
      Pragma_Elaborate_Body,
      Pragma_Exceptional_Cases,
      Pragma_Export,
      Pragma_Export_Function,
      Pragma_Export_Object,
      Pragma_Export_Procedure,
      Pragma_Export_Valued_Procedure,
      Pragma_Extensions_Visible,
      Pragma_External,
      Pragma_Finalize_Storage_Only,
      Pragma_Ghost,
      Pragma_Global,
      Pragma_Ident,
      Pragma_Implementation_Defined,
      Pragma_Implemented,
      Pragma_Import,
      Pragma_Import_Function,
      Pragma_Import_Object,
      Pragma_Import_Procedure,
      Pragma_Import_Valued_Procedure,
      Pragma_Independent,
      Pragma_Independent_Components,
      Pragma_Initial_Condition,
      Pragma_Initializes,
      Pragma_Inline,
      Pragma_Inline_Always,
      Pragma_Inline_Generic,
      Pragma_Inspection_Point,
      Pragma_Interface_Name,
      Pragma_Interrupt_Handler,
      Pragma_Invariant,
      Pragma_Keep_Names,
      Pragma_Link_With,
      Pragma_Linker_Alias,
      Pragma_Linker_Constructor,
      Pragma_Linker_Destructor,
      Pragma_Linker_Options,
      Pragma_Linker_Section,
      Pragma_List,
      Pragma_Lock_Free,
      Pragma_Loop_Invariant,
      Pragma_Loop_Optimize,
      Pragma_Loop_Variant,
      Pragma_Machine_Attribute,
      Pragma_Main,
      Pragma_Main_Storage,
      Pragma_Max_Entry_Queue_Depth,
      Pragma_Max_Entry_Queue_Length,
      Pragma_Max_Queue_Length,
      Pragma_Memory_Size,
      Pragma_No_Body,
      Pragma_No_Caching,
      Pragma_No_Elaboration_Code_All,
      Pragma_No_Inline,
      Pragma_No_Return,
      Pragma_No_Tagged_Streams,
      Pragma_Obsolescent,
      Pragma_Optimize,
      Pragma_Ordered,
      Pragma_Pack,
      Pragma_Page,
      Pragma_Part_Of,
      Pragma_Passive,
      Pragma_Post,
      Pragma_Postcondition,
      Pragma_Post_Class,
      Pragma_Pre,
      Pragma_Precondition,
      Pragma_Predicate,
      Pragma_Predicate_Failure,
      Pragma_Preelaborate,
      Pragma_Pre_Class,
      Pragma_Provide_Shift_Operators,
      Pragma_Psect_Object,
      Pragma_Pure,
      Pragma_Pure_Function,
      Pragma_Refined_Depends,
      Pragma_Refined_Global,
      Pragma_Refined_Post,
      Pragma_Refined_State,
      Pragma_Relative_Deadline,
      Pragma_Remote_Access_Type,
      Pragma_Remote_Call_Interface,
      Pragma_Remote_Types,
      Pragma_Share_Generic,
      Pragma_Shared,
      Pragma_Shared_Passive,
      Pragma_Side_Effects,
      Pragma_Simple_Storage_Pool_Type,
      Pragma_Source_Reference,
      Pragma_Static_Elaboration_Desired,
      Pragma_Stream_Convert,
      Pragma_Subprogram_Variant,
      Pragma_Subtitle,
      Pragma_Suppress_All,
      Pragma_Suppress_Debug_Info,
      Pragma_Suppress_Initialization,
      Pragma_System_Name,
      Pragma_Task_Info,
      Pragma_Task_Name,
      Pragma_Task_Storage,
      Pragma_Test_Case,
      Pragma_Thread_Local_Storage,
      Pragma_Time_Slice,
      Pragma_Title,
      Pragma_Type_Invariant,
      Pragma_Type_Invariant_Class,
      Pragma_Unchecked_Union,
      Pragma_Unimplemented_Unit,
      Pragma_Universal_Aliasing,
      Pragma_Unmodified,
      Pragma_Unreferenced,
      Pragma_Unreferenced_Objects,
      Pragma_Unreserve_All_Interrupts,
      Pragma_Unused,
      Pragma_Volatile,
      Pragma_Volatile_Components,
      Pragma_Volatile_Full_Access,
      Pragma_Volatile_Function,
      Pragma_Weak_External,

      --  The following pragmas are on their own, out of order, because of the
      --  special processing required to deal with the fact that their names
      --  match existing attribute names. Note that when a pragma is added in
      --  this section, functions Get_Pragma_Id and Is_Pragma_Name must be
      --  updated to account for the new pragma.

      Pragma_CPU,
      Pragma_Default_Scalar_Storage_Order,
      Pragma_Dispatching_Domain,
      Pragma_Fast_Math,
      Pragma_Interface,
      Pragma_Interrupt_Priority,
      Pragma_Preelaborable_Initialization,
      Pragma_Priority,
      Pragma_Secondary_Stack_Size,
      Pragma_Storage_Size,
      Pragma_Storage_Unit,

      --  The value to represent an unknown or unrecognized pragma

      Unknown_Pragma);

   -----------------------------------
   -- Queuing Policy ID definitions --
   -----------------------------------

   type Queuing_Policy_Id is (
      Queuing_Policy_FIFO_Queuing,
      Queuing_Policy_Priority_Queuing);

   --------------------------------------------
   -- Task Dispatching Policy ID definitions --
   --------------------------------------------

   type Task_Dispatching_Policy_Id is (
      Task_Dispatching_FIFO_Within_Priorities);
   --  Id values used to identify task dispatching policies

   -----------------
   -- Subprograms --
   -----------------

   procedure Initialize;
   --  Called to initialize the preset names in the names table

   function Is_Attribute_Name (N : Name_Id) return Boolean;
   --  Test to see if the name N is the name of a recognized attribute. Note
   --  that Name_Elab_Subp_Body returns False if not operating in CodePeer
   --  mode. This is the mechanism for considering this pragma illegal in
   --  normal GNAT programs.

   function Is_Entity_Attribute_Name (N : Name_Id) return Boolean;
   --  Test to see if the name N is the name of a recognized entity attribute,
   --  i.e. an attribute reference that returns an entity.

   function Is_Internal_Attribute_Name (N : Name_Id) return Boolean;
   --  Test to see if the name N is the name of an INT attribute (Name_CPU,
   --  Name_Dispatching_Domain, Name_Interrupt_Priority,
   --  Name_Secondary_Stack_Size).

   function Is_Procedure_Attribute_Name (N : Name_Id) return Boolean;
   --  Test to see if the name N is the name of a recognized attribute that
   --  designates a procedure (and can therefore appear as a statement).

   function Is_Function_Attribute_Name (N : Name_Id) return Boolean;
   --  Test to see if the name N is the name of a recognized attribute
   --  that designates a renameable function, and can therefore appear in
   --  a renaming statement. Note that not all attributes designating
   --  functions are renamable, in particular, those returning a universal
   --  value cannot be renamed.

   function Is_Type_Attribute_Name (N : Name_Id) return Boolean;
   --  Test to see if the name N is the name of a recognized type attribute,
   --  i.e. an attribute reference that returns a type

   function Is_Convention_Name (N : Name_Id) return Boolean;
   --  Test to see if the name N is the name of one of the recognized
   --  language conventions, as required by pragma Convention, Import,
   --  Export, Interface. Returns True if so. Also returns True for a
   --  name that has been specified by a Convention_Identifier pragma.
   --  If neither case holds, returns False.

   function Is_Keyword_Name (N : Name_Id) return Boolean;
   --  Test to see if the name N is one of the (reserved) keyword names. This
   --  includes all the keywords defined in the Ada standard (taking into
   --  effect the Ada version). It also includes additional keywords in
   --  contexts where additional keywords have been added. For example, in the
   --  context of parsing project files, keywords such as PROJECT are included.

   function Is_Locking_Policy_Name (N : Name_Id) return Boolean;
   --  Test to see if the name N is the name of a recognized locking policy

   function Is_Partition_Elaboration_Policy_Name
     (N : Name_Id) return Boolean;
   --  Test to see if the name N is the name of a recognized partition
   --  elaboration policy.

   function Is_Operator_Symbol_Name (N : Name_Id) return Boolean;
   --  Test to see if the name N is the name of an operator symbol

   function Is_Pragma_Name (N : Name_Id) return Boolean;
   --  Test to see if the name N is the name of a recognized pragma. Note
   --  that pragmas CPU, Dispatching_Domain, Fast_Math, Interrupt_Priority,
   --  Priority, Storage_Size, and Storage_Unit are recognized as pragmas by
   --  this function even though their names are separate from the other
   --  pragma names. For this reason, clients should always use this function,
   --  rather than do range tests on Name_Id values.

   function Is_Configuration_Pragma_Name (N : Name_Id) return Boolean;
   --  Test to see if the name N is the name of a recognized configuration
   --  pragma. Note that pragma Fast_Math is recognized as a configuration
   --  pragma by this function even though its name is separate from other
   --  configuration pragma names. For this reason, clients should always
   --  use this function, rather than do range tests on Name_Id values.

   function Is_Queuing_Policy_Name (N : Name_Id) return Boolean;
   --  Test to see if the name N is the name of a recognized queuing policy

   function Is_Task_Dispatching_Policy_Name (N : Name_Id) return Boolean;
   --  Test to see if the name N is the name of a recognized task
   --  dispatching policy.

   function Get_Attribute_Id (N : Name_Id) return Attribute_Id;
   --  Returns Id of attribute corresponding to given name. It is an error to
   --  call this function with a name that is not the name of a attribute. Note
   --  that the function also works correctly for internal attribute names even
   --  though there are not included in the main list of attribute Names.

   function Get_Convention_Id (N : Name_Id) return Convention_Id;
   --  Returns Id of language convention corresponding to given name. It is
   --  an error to call this function with a name that is not the name of a
   --  convention, or one that has been previously recorded using a call to
   --  Record_Convention_Identifier.

   function Get_Convention_Name (C : Convention_Id) return Name_Id;
   --  Returns the name of language convention corresponding to given
   --  convention id.

   function Get_Locking_Policy_Id (N : Name_Id) return Locking_Policy_Id;
   --  Returns Id of locking policy corresponding to given name. It is an error
   --  to call this function with a name that is not the name of a check.

   function Get_Pragma_Id (N : Name_Id) return Pragma_Id;
   --  Returns Id of pragma corresponding to given name. Returns Unknown_Pragma
   --  if N is not a name of a known (Ada defined or GNAT-specific) pragma.
   --  Note that the function also works correctly for names of pragmas that
   --  are not included in the main list of pragma Names (e.g. Name_CPU returns
   --  Pragma_CPU).

   function Get_Queuing_Policy_Id (N : Name_Id) return Queuing_Policy_Id;
   --  Returns Id of queuing policy corresponding to given name. It is an error
   --  to call this function with a name that is not the name of a check.

   function Get_Task_Dispatching_Policy_Id
     (N : Name_Id) return Task_Dispatching_Policy_Id;
   --  Returns Id of task dispatching policy corresponding to given name. It
   --  is an error to call this function with a name that is not the name of
   --  a defined check.

   procedure Record_Convention_Identifier
     (Id         : Name_Id;
      Convention : Convention_Id);
   --  A call to this procedure, resulting from an occurrence of a pragma
   --  Convention_Identifier, records that from now on an occurrence of Id
   --  will be recognized as a name for the specified convention.

private
   pragma Inline (Is_Attribute_Name);
   pragma Inline (Is_Configuration_Pragma_Name);
   pragma Inline (Is_Entity_Attribute_Name);
   pragma Inline (Is_Function_Attribute_Name);
   pragma Inline (Is_Internal_Attribute_Name);
   pragma Inline (Is_Locking_Policy_Name);
   pragma Inline (Is_Partition_Elaboration_Policy_Name);
   pragma Inline (Is_Operator_Symbol_Name);
   pragma Inline (Is_Pragma_Name);
   pragma Inline (Is_Procedure_Attribute_Name);
   pragma Inline (Is_Queuing_Policy_Name);
   pragma Inline (Is_Task_Dispatching_Policy_Name);
   pragma Inline (Is_Type_Attribute_Name);

end Snames;
