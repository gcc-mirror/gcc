.. _Example_of_Binder_Output_File:

*****************************
Example of Binder Output File
*****************************

.. index:: Binder output (example)

This Appendix displays the source code for the output file
generated by *gnatbind* for a simple 'Hello World' program.
Comments have been added for clarification purposes.


.. code-block:: ada

  --  The package is called Ada_Main unless this name is actually used
  --  as a unit name in the partition, in which case some other unique
  --  name is used.

  pragma Ada_95;
  with System;
  package ada_main is
     pragma Warnings (Off);

     --  The main program saves the parameters (argument count,
     --  argument values, environment pointer) in global variables
     --  for later access by other units including
     --  Ada.Command_Line.

     gnat_argc : Integer;
     gnat_argv : System.Address;
     gnat_envp : System.Address;

     --  The actual variables are stored in a library routine. This
     --  is useful for some shared library situations, where there
     --  are problems if variables are not in the library.

     pragma Import (C, gnat_argc);
     pragma Import (C, gnat_argv);
     pragma Import (C, gnat_envp);

     --  The exit status is similarly an external location

     gnat_exit_status : Integer;
     pragma Import (C, gnat_exit_status);

     GNAT_Version : constant String :=
                      "GNAT Version: Pro 7.4.0w (20141119-49)" & ASCII.NUL;
     pragma Export (C, GNAT_Version, "__gnat_version");

     Ada_Main_Program_Name : constant String := "_ada_hello" & ASCII.NUL;
     pragma Export (C, Ada_Main_Program_Name, "__gnat_ada_main_program_name");

     --  This is the generated adainit routine that performs
     --  initialization at the start of execution. In the case
     --  where Ada is the main program, this main program makes
     --  a call to adainit at program startup.

     procedure adainit;
     pragma Export (C, adainit, "adainit");

     --  This is the generated adafinal routine that performs
     --  finalization at the end of execution. In the case where
     --  Ada is the main program, this main program makes a call
     --  to adafinal at program termination.

     procedure adafinal;
     pragma Export (C, adafinal, "adafinal");

     --  This routine is called at the start of execution. It is
     --  a dummy routine that is used by the debugger to breakpoint
     --  at the start of execution.

     --  This is the actual generated main program (it would be
     --  suppressed if the no main program switch were used). As
     --  required by standard system conventions, this program has
     --  the external name main.

     function main
       (argc : Integer;
        argv : System.Address;
        envp : System.Address)
        return Integer;
     pragma Export (C, main, "main");

     --  The following set of constants give the version
     --  identification values for every unit in the bound
     --  partition. This identification is computed from all
     --  dependent semantic units, and corresponds to the
     --  string that would be returned by use of the
     --  Body_Version or Version attributes.

     --  The following Export pragmas export the version numbers
     --  with symbolic names ending in B (for body) or S
     --  (for spec) so that they can be located in a link. The
     --  information provided here is sufficient to track down
     --  the exact versions of units used in a given build.

     type Version_32 is mod 2 ** 32;
     u00001 : constant Version_32 := 16#8ad6e54a#;
     pragma Export (C, u00001, "helloB");
     u00002 : constant Version_32 := 16#fbff4c67#;
     pragma Export (C, u00002, "system__standard_libraryB");
     u00003 : constant Version_32 := 16#1ec6fd90#;
     pragma Export (C, u00003, "system__standard_libraryS");
     u00004 : constant Version_32 := 16#3ffc8e18#;
     pragma Export (C, u00004, "adaS");
     u00005 : constant Version_32 := 16#28f088c2#;
     pragma Export (C, u00005, "ada__text_ioB");
     u00006 : constant Version_32 := 16#f372c8ac#;
     pragma Export (C, u00006, "ada__text_ioS");
     u00007 : constant Version_32 := 16#2c143749#;
     pragma Export (C, u00007, "ada__exceptionsB");
     u00008 : constant Version_32 := 16#f4f0cce8#;
     pragma Export (C, u00008, "ada__exceptionsS");
     u00009 : constant Version_32 := 16#a46739c0#;
     pragma Export (C, u00009, "ada__exceptions__last_chance_handlerB");
     u00010 : constant Version_32 := 16#3aac8c92#;
     pragma Export (C, u00010, "ada__exceptions__last_chance_handlerS");
     u00011 : constant Version_32 := 16#1d274481#;
     pragma Export (C, u00011, "systemS");
     u00012 : constant Version_32 := 16#a207fefe#;
     pragma Export (C, u00012, "system__soft_linksB");
     u00013 : constant Version_32 := 16#467d9556#;
     pragma Export (C, u00013, "system__soft_linksS");
     u00014 : constant Version_32 := 16#b01dad17#;
     pragma Export (C, u00014, "system__parametersB");
     u00015 : constant Version_32 := 16#630d49fe#;
     pragma Export (C, u00015, "system__parametersS");
     u00016 : constant Version_32 := 16#b19b6653#;
     pragma Export (C, u00016, "system__secondary_stackB");
     u00017 : constant Version_32 := 16#b6468be8#;
     pragma Export (C, u00017, "system__secondary_stackS");
     u00018 : constant Version_32 := 16#39a03df9#;
     pragma Export (C, u00018, "system__storage_elementsB");
     u00019 : constant Version_32 := 16#30e40e85#;
     pragma Export (C, u00019, "system__storage_elementsS");
     u00020 : constant Version_32 := 16#41837d1e#;
     pragma Export (C, u00020, "system__stack_checkingB");
     u00021 : constant Version_32 := 16#93982f69#;
     pragma Export (C, u00021, "system__stack_checkingS");
     u00022 : constant Version_32 := 16#393398c1#;
     pragma Export (C, u00022, "system__exception_tableB");
     u00023 : constant Version_32 := 16#b33e2294#;
     pragma Export (C, u00023, "system__exception_tableS");
     u00024 : constant Version_32 := 16#ce4af020#;
     pragma Export (C, u00024, "system__exceptionsB");
     u00025 : constant Version_32 := 16#75442977#;
     pragma Export (C, u00025, "system__exceptionsS");
     u00026 : constant Version_32 := 16#37d758f1#;
     pragma Export (C, u00026, "system__exceptions__machineS");
     u00027 : constant Version_32 := 16#b895431d#;
     pragma Export (C, u00027, "system__exceptions_debugB");
     u00028 : constant Version_32 := 16#aec55d3f#;
     pragma Export (C, u00028, "system__exceptions_debugS");
     u00029 : constant Version_32 := 16#570325c8#;
     pragma Export (C, u00029, "system__img_intB");
     u00030 : constant Version_32 := 16#1ffca443#;
     pragma Export (C, u00030, "system__img_intS");
     u00031 : constant Version_32 := 16#b98c3e16#;
     pragma Export (C, u00031, "system__tracebackB");
     u00032 : constant Version_32 := 16#831a9d5a#;
     pragma Export (C, u00032, "system__tracebackS");
     u00033 : constant Version_32 := 16#9ed49525#;
     pragma Export (C, u00033, "system__traceback_entriesB");
     u00034 : constant Version_32 := 16#1d7cb2f1#;
     pragma Export (C, u00034, "system__traceback_entriesS");
     u00035 : constant Version_32 := 16#8c33a517#;
     pragma Export (C, u00035, "system__wch_conB");
     u00036 : constant Version_32 := 16#065a6653#;
     pragma Export (C, u00036, "system__wch_conS");
     u00037 : constant Version_32 := 16#9721e840#;
     pragma Export (C, u00037, "system__wch_stwB");
     u00038 : constant Version_32 := 16#2b4b4a52#;
     pragma Export (C, u00038, "system__wch_stwS");
     u00039 : constant Version_32 := 16#92b797cb#;
     pragma Export (C, u00039, "system__wch_cnvB");
     u00040 : constant Version_32 := 16#09eddca0#;
     pragma Export (C, u00040, "system__wch_cnvS");
     u00041 : constant Version_32 := 16#6033a23f#;
     pragma Export (C, u00041, "interfacesS");
     u00042 : constant Version_32 := 16#ece6fdb6#;
     pragma Export (C, u00042, "system__wch_jisB");
     u00043 : constant Version_32 := 16#899dc581#;
     pragma Export (C, u00043, "system__wch_jisS");
     u00044 : constant Version_32 := 16#10558b11#;
     pragma Export (C, u00044, "ada__streamsB");
     u00045 : constant Version_32 := 16#2e6701ab#;
     pragma Export (C, u00045, "ada__streamsS");
     u00046 : constant Version_32 := 16#db5c917c#;
     pragma Export (C, u00046, "ada__io_exceptionsS");
     u00047 : constant Version_32 := 16#12c8cd7d#;
     pragma Export (C, u00047, "ada__tagsB");
     u00048 : constant Version_32 := 16#ce72c228#;
     pragma Export (C, u00048, "ada__tagsS");
     u00049 : constant Version_32 := 16#c3335bfd#;
     pragma Export (C, u00049, "system__htableB");
     u00050 : constant Version_32 := 16#99e5f76b#;
     pragma Export (C, u00050, "system__htableS");
     u00051 : constant Version_32 := 16#089f5cd0#;
     pragma Export (C, u00051, "system__string_hashB");
     u00052 : constant Version_32 := 16#3bbb9c15#;
     pragma Export (C, u00052, "system__string_hashS");
     u00053 : constant Version_32 := 16#807fe041#;
     pragma Export (C, u00053, "system__unsigned_typesS");
     u00054 : constant Version_32 := 16#d27be59e#;
     pragma Export (C, u00054, "system__val_lluB");
     u00055 : constant Version_32 := 16#fa8db733#;
     pragma Export (C, u00055, "system__val_lluS");
     u00056 : constant Version_32 := 16#27b600b2#;
     pragma Export (C, u00056, "system__val_utilB");
     u00057 : constant Version_32 := 16#b187f27f#;
     pragma Export (C, u00057, "system__val_utilS");
     u00058 : constant Version_32 := 16#d1060688#;
     pragma Export (C, u00058, "system__case_utilB");
     u00059 : constant Version_32 := 16#392e2d56#;
     pragma Export (C, u00059, "system__case_utilS");
     u00060 : constant Version_32 := 16#84a27f0d#;
     pragma Export (C, u00060, "interfaces__c_streamsB");
     u00061 : constant Version_32 := 16#8bb5f2c0#;
     pragma Export (C, u00061, "interfaces__c_streamsS");
     u00062 : constant Version_32 := 16#6db6928f#;
     pragma Export (C, u00062, "system__crtlS");
     u00063 : constant Version_32 := 16#4e6a342b#;
     pragma Export (C, u00063, "system__file_ioB");
     u00064 : constant Version_32 := 16#ba56a5e4#;
     pragma Export (C, u00064, "system__file_ioS");
     u00065 : constant Version_32 := 16#b7ab275c#;
     pragma Export (C, u00065, "ada__finalizationB");
     u00066 : constant Version_32 := 16#19f764ca#;
     pragma Export (C, u00066, "ada__finalizationS");
     u00067 : constant Version_32 := 16#95817ed8#;
     pragma Export (C, u00067, "system__finalization_rootB");
     u00068 : constant Version_32 := 16#52d53711#;
     pragma Export (C, u00068, "system__finalization_rootS");
     u00069 : constant Version_32 := 16#769e25e6#;
     pragma Export (C, u00069, "interfaces__cB");
     u00070 : constant Version_32 := 16#4a38bedb#;
     pragma Export (C, u00070, "interfaces__cS");
     u00071 : constant Version_32 := 16#07e6ee66#;
     pragma Export (C, u00071, "system__os_libB");
     u00072 : constant Version_32 := 16#d7b69782#;
     pragma Export (C, u00072, "system__os_libS");
     u00073 : constant Version_32 := 16#1a817b8e#;
     pragma Export (C, u00073, "system__stringsB");
     u00074 : constant Version_32 := 16#639855e7#;
     pragma Export (C, u00074, "system__stringsS");
     u00075 : constant Version_32 := 16#e0b8de29#;
     pragma Export (C, u00075, "system__file_control_blockS");
     u00076 : constant Version_32 := 16#b5b2aca1#;
     pragma Export (C, u00076, "system__finalization_mastersB");
     u00077 : constant Version_32 := 16#69316dc1#;
     pragma Export (C, u00077, "system__finalization_mastersS");
     u00078 : constant Version_32 := 16#57a37a42#;
     pragma Export (C, u00078, "system__address_imageB");
     u00079 : constant Version_32 := 16#bccbd9bb#;
     pragma Export (C, u00079, "system__address_imageS");
     u00080 : constant Version_32 := 16#7268f812#;
     pragma Export (C, u00080, "system__img_boolB");
     u00081 : constant Version_32 := 16#e8fe356a#;
     pragma Export (C, u00081, "system__img_boolS");
     u00082 : constant Version_32 := 16#d7aac20c#;
     pragma Export (C, u00082, "system__ioB");
     u00083 : constant Version_32 := 16#8365b3ce#;
     pragma Export (C, u00083, "system__ioS");
     u00084 : constant Version_32 := 16#6d4d969a#;
     pragma Export (C, u00084, "system__storage_poolsB");
     u00085 : constant Version_32 := 16#e87cc305#;
     pragma Export (C, u00085, "system__storage_poolsS");
     u00086 : constant Version_32 := 16#e34550ca#;
     pragma Export (C, u00086, "system__pool_globalB");
     u00087 : constant Version_32 := 16#c88d2d16#;
     pragma Export (C, u00087, "system__pool_globalS");
     u00088 : constant Version_32 := 16#9d39c675#;
     pragma Export (C, u00088, "system__memoryB");
     u00089 : constant Version_32 := 16#445a22b5#;
     pragma Export (C, u00089, "system__memoryS");
     u00090 : constant Version_32 := 16#6a859064#;
     pragma Export (C, u00090, "system__storage_pools__subpoolsB");
     u00091 : constant Version_32 := 16#e3b008dc#;
     pragma Export (C, u00091, "system__storage_pools__subpoolsS");
     u00092 : constant Version_32 := 16#63f11652#;
     pragma Export (C, u00092, "system__storage_pools__subpools__finalizationB");
     u00093 : constant Version_32 := 16#fe2f4b3a#;
     pragma Export (C, u00093, "system__storage_pools__subpools__finalizationS");

     --  BEGIN ELABORATION ORDER
     --  ada%s
     --  interfaces%s
     --  system%s
     --  system.case_util%s
     --  system.case_util%b
     --  system.htable%s
     --  system.img_bool%s
     --  system.img_bool%b
     --  system.img_int%s
     --  system.img_int%b
     --  system.io%s
     --  system.io%b
     --  system.parameters%s
     --  system.parameters%b
     --  system.crtl%s
     --  interfaces.c_streams%s
     --  interfaces.c_streams%b
     --  system.standard_library%s
     --  system.exceptions_debug%s
     --  system.exceptions_debug%b
     --  system.storage_elements%s
     --  system.storage_elements%b
     --  system.stack_checking%s
     --  system.stack_checking%b
     --  system.string_hash%s
     --  system.string_hash%b
     --  system.htable%b
     --  system.strings%s
     --  system.strings%b
     --  system.os_lib%s
     --  system.traceback_entries%s
     --  system.traceback_entries%b
     --  ada.exceptions%s
     --  system.soft_links%s
     --  system.unsigned_types%s
     --  system.val_llu%s
     --  system.val_util%s
     --  system.val_util%b
     --  system.val_llu%b
     --  system.wch_con%s
     --  system.wch_con%b
     --  system.wch_cnv%s
     --  system.wch_jis%s
     --  system.wch_jis%b
     --  system.wch_cnv%b
     --  system.wch_stw%s
     --  system.wch_stw%b
     --  ada.exceptions.last_chance_handler%s
     --  ada.exceptions.last_chance_handler%b
     --  system.address_image%s
     --  system.exception_table%s
     --  system.exception_table%b
     --  ada.io_exceptions%s
     --  ada.tags%s
     --  ada.streams%s
     --  ada.streams%b
     --  interfaces.c%s
     --  system.exceptions%s
     --  system.exceptions%b
     --  system.exceptions.machine%s
     --  system.finalization_root%s
     --  system.finalization_root%b
     --  ada.finalization%s
     --  ada.finalization%b
     --  system.storage_pools%s
     --  system.storage_pools%b
     --  system.finalization_masters%s
     --  system.storage_pools.subpools%s
     --  system.storage_pools.subpools.finalization%s
     --  system.storage_pools.subpools.finalization%b
     --  system.memory%s
     --  system.memory%b
     --  system.standard_library%b
     --  system.pool_global%s
     --  system.pool_global%b
     --  system.file_control_block%s
     --  system.file_io%s
     --  system.secondary_stack%s
     --  system.file_io%b
     --  system.storage_pools.subpools%b
     --  system.finalization_masters%b
     --  interfaces.c%b
     --  ada.tags%b
     --  system.soft_links%b
     --  system.os_lib%b
     --  system.secondary_stack%b
     --  system.address_image%b
     --  system.traceback%s
     --  ada.exceptions%b
     --  system.traceback%b
     --  ada.text_io%s
     --  ada.text_io%b
     --  hello%b
     --  END ELABORATION ORDER

  end ada_main;

.. code-block:: ada

  pragma Ada_95;
  --  The following source file name pragmas allow the generated file
  --  names to be unique for different main programs. They are needed
  --  since the package name will always be Ada_Main.

  pragma Source_File_Name (ada_main, Spec_File_Name => "b~hello.ads");
  pragma Source_File_Name (ada_main, Body_File_Name => "b~hello.adb");

  pragma Suppress (Overflow_Check);
  with Ada.Exceptions;

  --  Generated package body for Ada_Main starts here

  package body ada_main is
     pragma Warnings (Off);

     --  These values are reference counter associated to units which have
     --  been elaborated. It is also used to avoid elaborating the
     --  same unit twice.

     E72 : Short_Integer; pragma Import (Ada, E72, "system__os_lib_E");
     E13 : Short_Integer; pragma Import (Ada, E13, "system__soft_links_E");
     E23 : Short_Integer; pragma Import (Ada, E23, "system__exception_table_E");
     E46 : Short_Integer; pragma Import (Ada, E46, "ada__io_exceptions_E");
     E48 : Short_Integer; pragma Import (Ada, E48, "ada__tags_E");
     E45 : Short_Integer; pragma Import (Ada, E45, "ada__streams_E");
     E70 : Short_Integer; pragma Import (Ada, E70, "interfaces__c_E");
     E25 : Short_Integer; pragma Import (Ada, E25, "system__exceptions_E");
     E68 : Short_Integer; pragma Import (Ada, E68, "system__finalization_root_E");
     E66 : Short_Integer; pragma Import (Ada, E66, "ada__finalization_E");
     E85 : Short_Integer; pragma Import (Ada, E85, "system__storage_pools_E");
     E77 : Short_Integer; pragma Import (Ada, E77, "system__finalization_masters_E");
     E91 : Short_Integer; pragma Import (Ada, E91, "system__storage_pools__subpools_E");
     E87 : Short_Integer; pragma Import (Ada, E87, "system__pool_global_E");
     E75 : Short_Integer; pragma Import (Ada, E75, "system__file_control_block_E");
     E64 : Short_Integer; pragma Import (Ada, E64, "system__file_io_E");
     E17 : Short_Integer; pragma Import (Ada, E17, "system__secondary_stack_E");
     E06 : Short_Integer; pragma Import (Ada, E06, "ada__text_io_E");

     Local_Priority_Specific_Dispatching : constant String := "";
     Local_Interrupt_States : constant String := "";

     Is_Elaborated : Boolean := False;

     procedure finalize_library is
     begin
        E06 := E06 - 1;
        declare
           procedure F1;
           pragma Import (Ada, F1, "ada__text_io__finalize_spec");
        begin
           F1;
        end;
        E77 := E77 - 1;
        E91 := E91 - 1;
        declare
           procedure F2;
           pragma Import (Ada, F2, "system__file_io__finalize_body");
        begin
           E64 := E64 - 1;
           F2;
        end;
        declare
           procedure F3;
           pragma Import (Ada, F3, "system__file_control_block__finalize_spec");
        begin
           E75 := E75 - 1;
           F3;
        end;
        E87 := E87 - 1;
        declare
           procedure F4;
           pragma Import (Ada, F4, "system__pool_global__finalize_spec");
        begin
           F4;
        end;
        declare
           procedure F5;
           pragma Import (Ada, F5, "system__storage_pools__subpools__finalize_spec");
        begin
           F5;
        end;
        declare
           procedure F6;
           pragma Import (Ada, F6, "system__finalization_masters__finalize_spec");
        begin
           F6;
        end;
        declare
           procedure Reraise_Library_Exception_If_Any;
           pragma Import (Ada, Reraise_Library_Exception_If_Any, "__gnat_reraise_library_exception_if_any");
        begin
           Reraise_Library_Exception_If_Any;
        end;
     end finalize_library;

     -------------
     -- adainit --
     -------------

     procedure adainit is

        Main_Priority : Integer;
        pragma Import (C, Main_Priority, "__gl_main_priority");
        Time_Slice_Value : Integer;
        pragma Import (C, Time_Slice_Value, "__gl_time_slice_val");
        WC_Encoding : Character;
        pragma Import (C, WC_Encoding, "__gl_wc_encoding");
        Locking_Policy : Character;
        pragma Import (C, Locking_Policy, "__gl_locking_policy");
        Queuing_Policy : Character;
        pragma Import (C, Queuing_Policy, "__gl_queuing_policy");
        Task_Dispatching_Policy : Character;
        pragma Import (C, Task_Dispatching_Policy, "__gl_task_dispatching_policy");
        Priority_Specific_Dispatching : System.Address;
        pragma Import (C, Priority_Specific_Dispatching, "__gl_priority_specific_dispatching");
        Num_Specific_Dispatching : Integer;
        pragma Import (C, Num_Specific_Dispatching, "__gl_num_specific_dispatching");
        Main_CPU : Integer;
        pragma Import (C, Main_CPU, "__gl_main_cpu");
        Interrupt_States : System.Address;
        pragma Import (C, Interrupt_States, "__gl_interrupt_states");
        Num_Interrupt_States : Integer;
        pragma Import (C, Num_Interrupt_States, "__gl_num_interrupt_states");
        Unreserve_All_Interrupts : Integer;
        pragma Import (C, Unreserve_All_Interrupts, "__gl_unreserve_all_interrupts");
        Detect_Blocking : Integer;
        pragma Import (C, Detect_Blocking, "__gl_detect_blocking");
        Default_Stack_Size : Integer;
        pragma Import (C, Default_Stack_Size, "__gl_default_stack_size");
        Leap_Seconds_Support : Integer;
        pragma Import (C, Leap_Seconds_Support, "__gl_leap_seconds_support");

        procedure Runtime_Initialize;
        pragma Import (C, Runtime_Initialize, "__gnat_runtime_initialize");

        Finalize_Library_Objects : No_Param_Proc;
        pragma Import (C, Finalize_Library_Objects, "__gnat_finalize_library_objects");

     --  Start of processing for adainit

     begin

        --  Record various information for this partition.  The values
        --  are derived by the binder from information stored in the ali
        --  files by the compiler.

        if Is_Elaborated then
           return;
        end if;
        Is_Elaborated := True;
        Main_Priority := -1;
        Time_Slice_Value := -1;
        WC_Encoding := 'b';
        Locking_Policy := ' ';
        Queuing_Policy := ' ';
        Task_Dispatching_Policy := ' ';
        Priority_Specific_Dispatching :=
          Local_Priority_Specific_Dispatching'Address;
        Num_Specific_Dispatching := 0;
        Main_CPU := -1;
        Interrupt_States := Local_Interrupt_States'Address;
        Num_Interrupt_States := 0;
        Unreserve_All_Interrupts := 0;
        Detect_Blocking := 0;
        Default_Stack_Size := -1;
        Leap_Seconds_Support := 0;

        Runtime_Initialize;

        Finalize_Library_Objects := finalize_library'access;

        --  Now we have the elaboration calls for all units in the partition.
        --  The Elab_Spec and Elab_Body attributes generate references to the
        --  implicit elaboration procedures generated by the compiler for
        --  each unit that requires elaboration. Increment a counter of
        --  reference for each unit.

        System.Soft_Links'Elab_Spec;
        System.Exception_Table'Elab_Body;
        E23 := E23 + 1;
        Ada.Io_Exceptions'Elab_Spec;
        E46 := E46 + 1;
        Ada.Tags'Elab_Spec;
        Ada.Streams'Elab_Spec;
        E45 := E45 + 1;
        Interfaces.C'Elab_Spec;
        System.Exceptions'Elab_Spec;
        E25 := E25 + 1;
        System.Finalization_Root'Elab_Spec;
        E68 := E68 + 1;
        Ada.Finalization'Elab_Spec;
        E66 := E66 + 1;
        System.Storage_Pools'Elab_Spec;
        E85 := E85 + 1;
        System.Finalization_Masters'Elab_Spec;
        System.Storage_Pools.Subpools'Elab_Spec;
        System.Pool_Global'Elab_Spec;
        E87 := E87 + 1;
        System.File_Control_Block'Elab_Spec;
        E75 := E75 + 1;
        System.File_Io'Elab_Body;
        E64 := E64 + 1;
        E91 := E91 + 1;
        System.Finalization_Masters'Elab_Body;
        E77 := E77 + 1;
        E70 := E70 + 1;
        Ada.Tags'Elab_Body;
        E48 := E48 + 1;
        System.Soft_Links'Elab_Body;
        E13 := E13 + 1;
        System.Os_Lib'Elab_Body;
        E72 := E72 + 1;
        System.Secondary_Stack'Elab_Body;
        E17 := E17 + 1;
        Ada.Text_Io'Elab_Spec;
        Ada.Text_Io'Elab_Body;
        E06 := E06 + 1;
     end adainit;

     --------------
     -- adafinal --
     --------------

     procedure adafinal is
        procedure s_stalib_adafinal;
        pragma Import (C, s_stalib_adafinal, "system__standard_library__adafinal");

        procedure Runtime_Finalize;
        pragma Import (C, Runtime_Finalize, "__gnat_runtime_finalize");

     begin
        if not Is_Elaborated then
           return;
        end if;
        Is_Elaborated := False;
        Runtime_Finalize;
        s_stalib_adafinal;
     end adafinal;

     --  We get to the main program of the partition by using
     --  pragma Import because if we try to with the unit and
     --  call it Ada style, then not only do we waste time
     --  recompiling it, but also, we don't really know the right
     --  switches (e.g.@: identifier character set) to be used
     --  to compile it.

     procedure Ada_Main_Program;
     pragma Import (Ada, Ada_Main_Program, "_ada_hello");

     ----------
     -- main --
     ----------

     --  main is actually a function, as in the ANSI C standard,
     --  defined to return the exit status. The three parameters
     --  are the argument count, argument values and environment
     --  pointer.

     function main
       (argc : Integer;
        argv : System.Address;
        envp : System.Address)
        return Integer
     is
        --  The initialize routine performs low level system
        --  initialization using a standard library routine which
        --  sets up signal handling and performs any other
        --  required setup. The routine can be found in file
        --  a-init.c.

        procedure initialize;
        pragma Import (C, initialize, "__gnat_initialize");

        --  The finalize routine performs low level system
        --  finalization using a standard library routine. The
        --  routine is found in file a-final.c and in the standard
        --  distribution is a dummy routine that does nothing, so
        --  really this is a hook for special user finalization.

        procedure finalize;
        pragma Import (C, finalize, "__gnat_finalize");

        --  The following is to initialize the SEH exceptions

        SEH : aliased array (1 .. 2) of Integer;

        Ensure_Reference : aliased System.Address := Ada_Main_Program_Name'Address;
        pragma Volatile (Ensure_Reference);

     --  Start of processing for main

     begin
        --  Save global variables

        gnat_argc := argc;
        gnat_argv := argv;
        gnat_envp := envp;

        --  Call low level system initialization

        Initialize (SEH'Address);

        --  Call our generated Ada initialization routine

        adainit;

        --  Now we call the main program of the partition

        Ada_Main_Program;

        --  Perform Ada finalization

        adafinal;

        --  Perform low level system finalization

        Finalize;

        --  Return the proper exit status
        return (gnat_exit_status);
     end;

  --  This section is entirely comments, so it has no effect on the
  --  compilation of the Ada_Main package. It provides the list of
  --  object files and linker options, as well as some standard
  --  libraries needed for the link. The gnatlink utility parses
  --  this b~hello.adb file to read these comment lines to generate
  --  the appropriate command line arguments for the call to the
  --  system linker. The BEGIN/END lines are used for sentinels for
  --  this parsing operation.

  --  The exact file names will of course depend on the environment,
  --  host/target and location of files on the host system.

  -- BEGIN Object file/option list
     --   ./hello.o
     --   -L./
     --   -L/usr/local/gnat/lib/gcc-lib/i686-pc-linux-gnu/2.8.1/adalib/
     --   /usr/local/gnat/lib/gcc-lib/i686-pc-linux-gnu/2.8.1/adalib/libgnat.a
  -- END Object file/option list

  end ada_main;


The Ada code in the above example is exactly what is generated by the
binder. We have added comments to more clearly indicate the function
of each part of the generated ``Ada_Main`` package.

The code is standard Ada in all respects, and can be processed by any
tools that handle Ada. In particular, it is possible to use the debugger
in Ada mode to debug the generated ``Ada_Main`` package. For example,
suppose that for reasons that you do not understand, your program is crashing
during elaboration of the body of ``Ada.Text_IO``. To locate this bug,
you can place a breakpoint on the call:

  .. code-block:: ada

     Ada.Text_Io'Elab_Body;

and trace the elaboration routine for this package to find out where
the problem might be (more usually of course you would be debugging
elaboration code in your own application).
