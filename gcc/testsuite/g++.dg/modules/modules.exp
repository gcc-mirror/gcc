# Copyright (C) 2017 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with GCC; see the file COPYING3.  If not see
# <http://www.gnu.org/licenses/>.
#
# Contributed by Nathan Sidwell <nathan@acm.org>


# Test C++ modules, which requires multiple TUs
#
# A test case might consist of multiple source files, each is compiled
# separately, in a well-defined order.  The resulting object files might
# be optionally linked and optionally executed.  Grouping is indicated by
# naming files '*_[a-z].C'

# { dg-module-if "[!]module-name" } # an interface file is (not) expected
# { dg-module-do [link|run] [xfail] } # link [and run]

load_lib g++-dg.exp
load_lib mpx-dg.exp

# If a testcase doesn't have special options, use these.
global DEFAULT_CXXFLAGS
if ![info exists DEFAULT_CXXFLAGS] then {
    set DEFAULT_CXXFLAGS " -pedantic-errors -Wno-long-long"
}
set DEFAULT_MODFLAGS $DEFAULT_CXXFLAGS
lappend DEFAULT_MODFLAGS "-std=c++14" "-fmodules"

dg-init

global module_do
global module_ifs

proc decode_mod_spec { spec } {
    set not 0
    if { [ string index $spec 0 ] == "!" } {
	set spec [string range $spec 1 end]
	set not 1
    }
    set file "[regsub -all {\.} $spec {-}].nms"
    return [list $not $file]
}

# Register a module interface leading '!' to expect it to NOT be present
# dg-module-if SPEC WHEN
proc dg-module-if { args } {
    if { [llength $args] > 3 } {
	error "[lindex $args 0]: too many arguments"
	return
    }

    set spec [lindex $args 1]
    set decode [decode_mod_spec $spec]
    if { ! [lindex $decode 0] } {
	# delete file, only if we expect to create it
	file_on_host delete [lindex $decode 1]
    }

    set res [list $spec]
    if { [llength $args] > 2 } {
	lappend res [lindex $args 2]
    }

    global module_ifs
    lappend module_ifs $res
}

# check the expected module files exist (or not)
# return list to delete
proc module_if_it { src ifs } {
    set res {}
    foreach if_arg $ifs {
	set spec [lindex $if_arg 0]
	if { [llength $if_arg] > 1 } {
	    switch [dg-process-target [lindex $if_arg 1]] {
		"S" { }
		"N" { continue }
		"F" { setup_xfail "*-*-*" }
		"P" { }
	    }
	}
	set decode [decode_mod_spec $spec]
	set absent [lindex $decode 0]
	if { $absent != [file_on_host exists [lindex $decode 1]] } {
	    pass "$src module $spec"
	} else {
	    fail "$src module $spec"
	    set absent [expr ! $absent ]
	}
	if { ! $absent } {
	    lappend res [lindex $decode 1]
	}
    }
    return $res
}

# link and maybe run a set of object files
# dg-module-do WHAT OPTIONS WHEN
proc dg-module-do { args } {
    if { [llength $args] > 3 } {
	error "[lindex $args 0]: too many arguments"
	return
    }

    global module_do
    set module_do $args
}

proc module_do_it { do_what testcase asm_list } {
    global tool

    set run 0
    switch [lindex $do_what 1] {
	"link" { }
	"run" { set run 1 }
	default { error "unknown module-do action [lindex $do_what 0]" }
    }

    set xfail {}
    if { [llength $do_what] > 2 } {
	switch [dg-process-target [lindex $do_what 2]] {
	    "S" { }
	    "N" { return 1 }
	    "F" { set xfail {setup_xfail "*-*-*"} }
	    "P" { }
	}
    }

    set ok 1
    # make sure all asms are around
    foreach asm $asm_list {
	if { ! [file_on_host exists $asm] } {
	    set ok 0
	}
    }

    set options {}
    if { [llength $do_what] > 2 } {
	set options [lindex $do_what 2]
    }

    set execname "./[file tail $testcase].exe"

    # link it
    verbose "Linking $asm_list" 1
    if { !$ok } {
	unresolved "$testcase link"
    } else {
	set out [${tool}_target_compile $asm_list \
		     $execname executable $options]
	eval $xfail
	if { $out == "" } {
	    pass "$testcase link"
	} else {
	    fail "$testcase link"
	    set ok 0
	}
    }

    # run it?
    if { !$run } {
    } elseif { !$ok } {
	unresolved "$testcase execute"
    } else {
	set out [${tool}_load $execname "" ""]
	set status [lindex $out 0]
	eval $xfail
	$status "$testcase execute"
	if { $status != "pass" } {
	    set $ok 0
	}
    }

    if { $ok } {
	file_on_host delete $execname
    }

    return $ok
}

# delete the specified set of module files
proc cleanup_module_files { files } {
    foreach file $files {
	file_on_host delete $file
    }
}

# not grouped tests, sadly tcl doesn't have negated glob
foreach src [prune [lsort [find $srcdir/$subdir "*.C"]] \
		 "$srcdir/$subdir/*_?.C"] {
    if [runtest_file_p $runtests $src] {
	set module_ifs {}
	# don't bother running these at each -std level
	dg-test $src "" $DEFAULT_MODFLAGS
	set testcase [string range $src [string length "$srcdir/"] end]
	cleanup_module_files [module_if_it $testcase $module_ifs]
    }
}

# grouped tests
foreach src [lsort [find $srcdir/$subdir "*_a.C"]] {
    # use the FOO_a.C name as the parallelization key
    if [runtest_file_p $runtests $src] {
	set mod_files {}
	set module_do {}
	set srcs [lsort [find [file dirname $src] \
			 [regsub {_a.C$} [file tail $src] {_[a-z].C}]]]
	set asm_list {}
	verbose "Modules $srcs" 1
	foreach test $srcs {
	    set module_ifs {}
	    dg-test -keep-output $test "" $DEFAULT_MODFLAGS
	    lappend asm_list [regsub {\.C$} [file tail $test] {.s}]
	    set testcase [string range $test [string length "$srcdir/"] end]
	    lappend mod_files [module_if_it $testcase $module_ifs]
	}
	set ok 1
	if { $module_do != "" } {
	    set testcase [regsub {_a.C} $src {}]
	    set testcase \
		[string range $testcase [string length "$srcdir/"] end]
	    set ok [module_do_it $module_do $testcase $asm_list]
	}
	if { $ok } {
	    foreach asm $asm_list {
		file_on_host delete $asm
	    }
	    cleanup_module_files $mod_files
	}
    }
}

dg-finish
