#   Copyright (C) 1999, 2001, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
#    Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with GCC; see the file COPYING3.  If not see
# <http://www.gnu.org/licenses/>.

# Please email any bugs, comments, and/or additions to this file to:
# gcc-patches@gcc.gnu.org

# This file defines procs for determining features supported by the target.

# Try to compile the code given by CONTENTS into an output file of
# type TYPE, where TYPE is as for target_compile.  Return a list
# whose first element contains the compiler messages and whose
# second element is the name of the output file.
#
# BASENAME is a prefix to use for source and output files.
# If ARGS is not empty, its first element is a string that
# should be added to the command line.
#
# Assume by default that CONTENTS is C code.  
# Otherwise, code should contain:
# "// C++" for c++,
# "! Fortran" for Fortran code,
# "/* ObjC", for ObjC
# and "// ObjC++" for ObjC++
# If the tool is ObjC/ObjC++ then we overide the extension to .m/.mm to 
# allow for ObjC/ObjC++ specific flags.
proc check_compile {basename type contents args} {
    global tool
    verbose "check_compile tool: $tool for $basename" 

    if { [llength $args] > 0 } {
	set options [list "additional_flags=[lindex $args 0]"]
    } else {
	set options ""
    }
    switch -glob -- $contents {
	"*! Fortran*" { set src ${basename}[pid].f90 }
	"*// C++*" { set src ${basename}[pid].cc }
	"*// ObjC++*" { set src ${basename}[pid].mm }
	"*/* ObjC*" { set src ${basename}[pid].m }
	default {
	    switch -- $tool {
		"objc" { set src ${basename}[pid].m }
		"obj-c++" { set src ${basename}[pid].mm }
		default { set src ${basename}[pid].c }
	    }
	}
    }

    set compile_type $type
    switch -glob $type {
	assembly { set output ${basename}[pid].s }
	object { set output ${basename}[pid].o }
	executable { set output ${basename}[pid].exe }
	"rtl-*" {
	    set output ${basename}[pid].s
	    lappend options "additional_flags=-fdump-$type"
	    set compile_type assembly
	}
    }
    set f [open $src "w"]
    puts $f $contents
    close $f
    set lines [${tool}_target_compile $src $output $compile_type "$options"]
    file delete $src

    set scan_output $output
    # Don't try folding this into the switch above; calling "glob" before the
    # file is created won't work.
    if [regexp "rtl-(.*)" $type dummy rtl_type] {
	set scan_output "[glob $src.\[0-9\]\[0-9\]\[0-9\]r.$rtl_type]"
	file delete $output
    }

    return [list $lines $scan_output]
}

proc current_target_name { } {
    global target_info
    if [info exists target_info(target,name)] {
	set answer $target_info(target,name)
    } else {
	set answer ""
    }
    return $answer
}

# Implement an effective-target check for property PROP by invoking
# the Tcl command ARGS and seeing if it returns true.

proc check_cached_effective_target { prop args } {
    global et_cache

    set target [current_target_name]
    if {![info exists et_cache($prop,target)]
	|| $et_cache($prop,target) != $target} {
	verbose "check_cached_effective_target $prop: checking $target" 2
	set et_cache($prop,target) $target
	set et_cache($prop,value) [uplevel eval $args]
    }
    set value $et_cache($prop,value)
    verbose "check_cached_effective_target $prop: returning $value for $target" 2
    return $value
}

# Like check_compile, but delete the output file and return true if the
# compiler printed no messages.
proc check_no_compiler_messages_nocache {args} {
    set result [eval check_compile $args]
    set lines [lindex $result 0]
    set output [lindex $result 1]
    remote_file build delete $output
    return [string match "" $lines]
}

# Like check_no_compiler_messages_nocache, but cache the result.
# PROP is the property we're checking, and doubles as a prefix for
# temporary filenames.
proc check_no_compiler_messages {prop args} {
    return [check_cached_effective_target $prop {
	eval [list check_no_compiler_messages_nocache $prop] $args
    }]
}

# Like check_compile, but return true if the compiler printed no
# messages and if the contents of the output file satisfy PATTERN.
# If PATTERN has the form "!REGEXP", the contents satisfy it if they
# don't match regular expression REGEXP, otherwise they satisfy it
# if they do match regular expression PATTERN.  (PATTERN can start
# with something like "[!]" if the regular expression needs to match
# "!" as the first character.)
#
# Delete the output file before returning.  The other arguments are
# as for check_compile.
proc check_no_messages_and_pattern_nocache {basename pattern args} {
    global tool

    set result [eval [list check_compile $basename] $args]
    set lines [lindex $result 0]
    set output [lindex $result 1]

    set ok 0
    if { [string match "" $lines] } {
	set chan [open "$output"]
	set invert [regexp {^!(.*)} $pattern dummy pattern]
	set ok [expr { [regexp $pattern [read $chan]] != $invert }]
	close $chan
    }

    remote_file build delete $output
    return $ok
}

# Like check_no_messages_and_pattern_nocache, but cache the result.
# PROP is the property we're checking, and doubles as a prefix for
# temporary filenames.
proc check_no_messages_and_pattern {prop pattern args} {
    return [check_cached_effective_target $prop {
	eval [list check_no_messages_and_pattern_nocache $prop $pattern] $args
    }]
}

# Try to compile and run an executable from code CONTENTS.  Return true
# if the compiler reports no messages and if execution "passes" in the
# usual DejaGNU sense.  The arguments are as for check_compile, with
# TYPE implicitly being "executable".
proc check_runtime_nocache {basename contents args} {
    global tool

    set result [eval [list check_compile $basename executable $contents] $args]
    set lines [lindex $result 0]
    set output [lindex $result 1]

    set ok 0
    if { [string match "" $lines] } {
	# No error messages, everything is OK.
	set result [remote_load target "./$output" "" ""]
	set status [lindex $result 0]
	verbose "check_runtime_nocache $basename: status is <$status>" 2
	if { $status == "pass" } {
	    set ok 1
	}
    }
    remote_file build delete $output
    return $ok
}

# Like check_runtime_nocache, but cache the result.  PROP is the
# property we're checking, and doubles as a prefix for temporary
# filenames.
proc check_runtime {prop args} {
    global tool

    return [check_cached_effective_target $prop {
	eval [list check_runtime_nocache $prop] $args
    }]
}

###############################
# proc check_weak_available { }
###############################

# weak symbols are only supported in some configs/object formats
# this proc returns 1 if they're supported, 0 if they're not, or -1 if unsure

proc check_weak_available { } {
    global target_triplet
    global target_cpu

    # All mips targets should support it

    if { [ string first "mips" $target_cpu ] >= 0 } {
        return 1
    }

    # All solaris2 targets should support it

    if { [regexp ".*-solaris2.*" $target_triplet] } {
        return 1
    }

    # DEC OSF/1/Digital UNIX/Tru64 UNIX supports it

    if { [regexp "alpha.*osf.*" $target_triplet] } {
	return 1
    }

    # Windows targets Cygwin and MingW32 support it

    if { [regexp ".*mingw32|.*cygwin" $target_triplet] } {
	return 1
    }

    # HP-UX 10.X doesn't support it

    if { [istarget "hppa*-*-hpux10*"] } {
	return 0
    }

    # ELF and ECOFF support it. a.out does with gas/gld but may also with
    # other linkers, so we should try it

    set objformat [gcc_target_object_format]

    switch $objformat {
        elf      { return 1 }
        ecoff    { return 1 }
        a.out    { return 1 }
	mach-o	 { return 1 }
	som	 { return 1 }
        unknown  { return -1 }
        default  { return 0 }
    }
}

###############################
# proc check_weak_override_available { }
###############################

# Like check_weak_available, but return 0 if weak symbol definitions
# cannot be overridden.

proc check_weak_override_available { } {
    if { [istarget "*-*-mingw*"] } {
	return 0
    }
    return [check_weak_available]
}

###############################
# proc check_visibility_available { what_kind }
###############################

# The visibility attribute is only support in some object formats
# This proc returns 1 if it is supported, 0 if not.
# The argument is the kind of visibility, default/protected/hidden/internal.

proc check_visibility_available { what_kind } {
    global tool
    global target_triplet

    # On NetWare, support makes no sense.
    if { [istarget *-*-netware*] } {
        return 0
    }

    if [string match "" $what_kind] { set what_kind "hidden" }

    return [check_no_compiler_messages visibility_available_$what_kind object "
	void f() __attribute__((visibility(\"$what_kind\")));
	void f() {}
    "]
}

###############################
# proc check_alias_available { }
###############################

# Determine if the target toolchain supports the alias attribute.

# Returns 2 if the target supports aliases.  Returns 1 if the target
# only supports weak aliased.  Returns 0 if the target does not
# support aliases at all.  Returns -1 if support for aliases could not
# be determined.

proc check_alias_available { } {
    global alias_available_saved
    global tool

    if [info exists alias_available_saved] {
        verbose "check_alias_available  returning saved $alias_available_saved" 2
    } else {
	set src alias[pid].c
	set obj alias[pid].o
        verbose "check_alias_available  compiling testfile $src" 2
	set f [open $src "w"]
	# Compile a small test program.  The definition of "g" is
	# necessary to keep the Solaris assembler from complaining
	# about the program.
	puts $f "#ifdef __cplusplus\nextern \"C\"\n#endif\n"
	puts $f "void g() {} void f() __attribute__((alias(\"g\")));"
	close $f
	set lines [${tool}_target_compile $src $obj object ""]
	file delete $src
	remote_file build delete $obj

	if [string match "" $lines] then {
	    # No error messages, everything is OK.
	    set alias_available_saved 2
	} else {
	    if [regexp "alias definitions not supported" $lines] {
		verbose "check_alias_available  target does not support aliases" 2

		set objformat [gcc_target_object_format]

		if { $objformat == "elf" } {
		    verbose "check_alias_available  but target uses ELF format, so it ought to" 2
		    set alias_available_saved -1
		} else {
		    set alias_available_saved 0
		}
	    } else {
		if [regexp "only weak aliases are supported" $lines] {
		verbose "check_alias_available  target supports only weak aliases" 2
		set alias_available_saved 1
		} else {
		    set alias_available_saved -1
		}
	    }
	}

	verbose "check_alias_available  returning $alias_available_saved" 2
    }

    return $alias_available_saved
}

###############################
# proc check_ifunc_available { }
###############################

# Determine if the target toolchain supports the alias attribute.

# Returns 2 if the target supports aliases.  Returns 1 if the target
# only supports weak aliased.  Returns 0 if the target does not
# support aliases at all.  Returns -1 if support for aliases could not
# be determined.

proc check_ifunc_available { } {
    global ifunc_available_saved
    global tool

    if [info exists ifunc_available_saved] {
        verbose "check_ifunc_available  returning saved $ifunc_available_saved" 2
    } else {
	set src ifunc[pid].c
	set obj ifunc[pid].o
        verbose "check_ifunc_available  compiling testfile $src" 2
	set f [open $src "w"]
	# Compile a small test program.  The definition of "g" is
	# necessary to keep the Solaris assembler from complaining
	# about the program.
	puts $f "#ifdef __cplusplus\nextern \"C\"\n#endif\n"
	puts $f "void g() {} void f() __attribute__((ifunc(\"g\")));"
	close $f
	set lines [${tool}_target_compile $src $obj object ""]
	file delete $src
	remote_file build delete $obj

	if [string match "" $lines] then {
	    # No error messages, everything is OK.
	    set ifunc_available_saved 2
	} else {
	    if [regexp "ifunc is not supported" $lines] {
		verbose "check_ifunc_available  target does not support ifunc" 2
		set ifunc_available_saved 0
	    } else {
		set ifunc_available_saved -1
	    }
	}

	verbose "check_ifunc_available  returning $ifunc_available_saved" 2
    }

    return $ifunc_available_saved
}

# Returns true if --gc-sections is supported on the target.

proc check_gc_sections_available { } {
    global gc_sections_available_saved
    global tool

    if {![info exists gc_sections_available_saved]} {
	# Some targets don't support gc-sections despite whatever's
	# advertised by ld's options.
	if { [istarget alpha*-*-*]
	     || [istarget ia64-*-*] } {
	    set gc_sections_available_saved 0
	    return 0
	}

	# elf2flt uses -q (--emit-relocs), which is incompatible with
	# --gc-sections.
	if { [board_info target exists ldflags]
	     && [regexp " -elf2flt\[ =\]" " [board_info target ldflags] "] } {
	    set gc_sections_available_saved 0
	    return 0
	}

	# VxWorks kernel modules are relocatable objects linked with -r,
	# while RTP executables are linked with -q (--emit-relocs).
	# Both of these options are incompatible with --gc-sections.
	if { [istarget *-*-vxworks*] } {
	    set gc_sections_available_saved 0
	    return 0
	}

	# Check if the ld used by gcc supports --gc-sections.
	set gcc_spec [${tool}_target_compile "-dumpspecs" "" "none" ""]
	regsub ".*\n\\*linker:\[ \t\]*\n(\[^ \t\n\]*).*" "$gcc_spec" {\1} linker
	set gcc_ld [lindex [${tool}_target_compile "-print-prog-name=$linker" "" "none" ""] 0]
	set ld_output [remote_exec host "$gcc_ld" "--help"]
	if { [ string first "--gc-sections" $ld_output ] >= 0 } {
	    set gc_sections_available_saved 1
	} else {
	    set gc_sections_available_saved 0
	}
    }
    return $gc_sections_available_saved
}

# Return 1 if according to target_info struct and explicit target list
# target is supposed to support trampolines.
 
proc check_effective_target_trampolines { } {
    if [target_info exists no_trampolines] {
      return 0
    }
    if { [istarget avr-*-*]
	 || [istarget hppa2.0w-hp-hpux11.23]
	|| [istarget hppa64-hp-hpux11.23] } {
	return 0;   
    }
    return 1
}

# Return 1 if according to target_info struct and explicit target list
# target is supposed to keep null pointer checks. This could be due to 
# use of option fno-delete-null-pointer-checks or hardwired in target.
 
proc check_effective_target_keeps_null_pointer_checks { } {
    if [target_info exists keeps_null_pointer_checks] {
      return 1
    }
    if { [istarget avr-*-*] } {
	return 1;   
    }
    return 0
}

# Return true if profiling is supported on the target.

proc check_profiling_available { test_what } {
    global profiling_available_saved

    verbose "Profiling argument is <$test_what>" 1

    # These conditions depend on the argument so examine them before
    # looking at the cache variable.

    # Support for -p on solaris2 relies on mcrt1.o which comes with the
    # vendor compiler.  We cannot reliably predict the directory where the
    # vendor compiler (and thus mcrt1.o) is installed so we can't
    # necessarily find mcrt1.o even if we have it.
    if { [istarget *-*-solaris2*] && [lindex $test_what 1] == "-p" } {
	return 0
    }

    # Support for -p on irix relies on libprof1.a which doesn't appear to
    # exist on any irix6 system currently posting testsuite results.
    # Support for -pg on irix relies on gcrt1.o which doesn't exist yet.
    # See: http://gcc.gnu.org/ml/gcc/2002-10/msg00169.html
    if { [istarget mips*-*-irix*]
    && ([lindex $test_what 1] == "-p" || [lindex $test_what 1] == "-pg") } {
	return 0
    }

    # We don't yet support profiling for MIPS16.
    if { [istarget mips*-*-*]
	 && ![check_effective_target_nomips16]
	 && ([lindex $test_what 1] == "-p"
	     || [lindex $test_what 1] == "-pg") } {
	return 0
    }

    # MinGW does not support -p.
    if { [istarget *-*-mingw*] && [lindex $test_what 1] == "-p" } {
	return 0
    }

    # cygwin does not support -p.
    if { [istarget *-*-cygwin*] && [lindex $test_what 1] == "-p" } {
	return 0
    }

    # uClibc does not have gcrt1.o.
    if { [check_effective_target_uclibc]
	 && ([lindex $test_what 1] == "-p"
	     || [lindex $test_what 1] == "-pg") } {
	return 0
    }

    # Now examine the cache variable.
    if {![info exists profiling_available_saved]} {
	# Some targets don't have any implementation of __bb_init_func or are
	# missing other needed machinery.
	if { [istarget mmix-*-*]
	     || [istarget arm*-*-eabi*]
	     || [istarget picochip-*-*]
	     || [istarget *-*-netware*]
	     || [istarget arm*-*-elf]
	     || [istarget arm*-*-symbianelf*]
	     || [istarget avr-*-*]
	     || [istarget bfin-*-*]
	     || [istarget powerpc-*-eabi*]
	     || [istarget powerpc-*-elf]
	     || [istarget cris-*-*]
	     || [istarget crisv32-*-*]
	     || [istarget fido-*-elf]
	     || [istarget h8300-*-*]
             || [istarget lm32-*-*]
             || [istarget m32c-*-elf]
	     || [istarget m68k-*-elf]
	     || [istarget m68k-*-uclinux*]
	     || [istarget mep-*-elf]
	     || [istarget mips*-*-elf*]
	     || [istarget moxie-*-elf*]
	     || [istarget rx-*-*]	
	     || [istarget xstormy16-*]
	     || [istarget xtensa*-*-elf]
	     || [istarget *-*-rtems*]
	     || [istarget *-*-vxworks*] } {
	    set profiling_available_saved 0
	} else {
	    set profiling_available_saved 1
	}
    }

    return $profiling_available_saved
}

# Check to see if a target is "freestanding". This is as per the definition
# in Section 4 of C99 standard. Effectively, it is a target which supports no
# extra headers or libraries other than what is considered essential.
proc check_effective_target_freestanding { } {
    if { [istarget picochip-*-*] } then {
        return 1
    } else {
        return 0
    }
}

# Return 1 if target has packed layout of structure members by
# default, 0 otherwise.  Note that this is slightly different than
# whether the target has "natural alignment": both attributes may be
# false.

proc check_effective_target_default_packed { } {
    return [check_no_compiler_messages default_packed assembly {
	struct x { char a; long b; } c;
	int s[sizeof (c) == sizeof (char) + sizeof (long) ? 1 : -1];
    }]
}

# Return 1 if target has PCC_BITFIELD_TYPE_MATTERS defined.  See
# documentation, where the test also comes from.

proc check_effective_target_pcc_bitfield_type_matters { } {
    # PCC_BITFIELD_TYPE_MATTERS isn't just about unnamed or empty
    # bitfields, but let's stick to the example code from the docs.
    return [check_no_compiler_messages pcc_bitfield_type_matters assembly {
	struct foo1 { char x; char :0; char y; };
	struct foo2 { char x; int :0; char y; };
	int s[sizeof (struct foo1) != sizeof (struct foo2) ? 1 : -1];
    }]
}

# Add to FLAGS all the target-specific flags needed to use thread-local storage.

proc add_options_for_tls { flags } {
    # On Solaris 8 and 9, __tls_get_addr/___tls_get_addr only lives in
    # libthread, so always pass -pthread for native TLS.
    # Need to duplicate native TLS check from
    # check_effective_target_tls_native to avoid recursion.
    if { [istarget *-*-solaris2.\[89\]*] &&
	 [check_no_messages_and_pattern tls_native "!emutls" assembly {
	     __thread int i;
	     int f (void) { return i; }
	     void g (int j) { i = j; }
	 }] } {
	return "$flags -pthread"
    }
    return $flags
}

# Return 1 if thread local storage (TLS) is supported, 0 otherwise.

proc check_effective_target_tls {} {
    return [check_no_compiler_messages tls assembly {
	__thread int i;
	int f (void) { return i; }
	void g (int j) { i = j; }
    }]
}

# Return 1 if *native* thread local storage (TLS) is supported, 0 otherwise.

proc check_effective_target_tls_native {} {
    # VxWorks uses emulated TLS machinery, but with non-standard helper
    # functions, so we fail to automatically detect it.
    global target_triplet
    if { [regexp ".*-.*-vxworks.*" $target_triplet] } {
	return 0
    }
    
    return [check_no_messages_and_pattern tls_native "!emutls" assembly {
	__thread int i;
	int f (void) { return i; }
	void g (int j) { i = j; }
    }]
}

# Return 1 if *emulated* thread local storage (TLS) is supported, 0 otherwise.

proc check_effective_target_tls_emulated {} {
    # VxWorks uses emulated TLS machinery, but with non-standard helper
    # functions, so we fail to automatically detect it.
    global target_triplet
    if { [regexp ".*-.*-vxworks.*" $target_triplet] } {
	return 1
    }
    
    return [check_no_messages_and_pattern tls_emulated "emutls" assembly {
	__thread int i;
	int f (void) { return i; }
	void g (int j) { i = j; }
    }]
}

# Return 1 if TLS executables can run correctly, 0 otherwise.

proc check_effective_target_tls_runtime {} {
    return [check_runtime tls_runtime {
	__thread int thr = 0;
	int main (void) { return thr; }
    }]
}

# Return 1 if -ffunction-sections is supported, 0 otherwise.

proc check_effective_target_function_sections {} {
    # Darwin has its own scheme and silently accepts -ffunction-sections.
    global target_triplet
    if { [regexp ".*-.*-darwin.*" $target_triplet] } {
	return 0
    }
    
    return [check_no_compiler_messages functionsections assembly {
 	void foo (void) { }
    } "-ffunction-sections"]
}

# Return 1 if compilation with -fgraphite is error-free for trivial 
# code, 0 otherwise.

proc check_effective_target_fgraphite {} {
    return [check_no_compiler_messages fgraphite object {
	void foo (void) { }
    } "-O1 -fgraphite"]
}

# Return 1 if compilation with -fopenmp is error-free for trivial
# code, 0 otherwise.

proc check_effective_target_fopenmp {} {
    return [check_no_compiler_messages fopenmp object {
	void foo (void) { }
    } "-fopenmp"]
}

# Return 1 if compilation with -pthread is error-free for trivial
# code, 0 otherwise.

proc check_effective_target_pthread {} {
    return [check_no_compiler_messages pthread object {
	void foo (void) { }
    } "-pthread"]
}

# Return 1 if compilation with -mpe-aligned-commons is error-free
# for trivial code, 0 otherwise.

proc check_effective_target_pe_aligned_commons {} {
    if { [istarget *-*-cygwin*] || [istarget *-*-mingw*] } {
	return [check_no_compiler_messages pe_aligned_commons object {
	    int foo;
	} "-mpe-aligned-commons"]
    }
    return 0
}

# Return 1 if the target supports -static
proc check_effective_target_static {} {
    return [check_no_compiler_messages static executable {
	int main (void) { return 0; }
    } "-static"]
}

# Return 1 if the target supports -fstack-protector
proc check_effective_target_fstack_protector {} {
    return [check_runtime fstack_protector {
	int main (void) { return 0; }
    } "-fstack-protector"]
}

# Return 1 if compilation with -freorder-blocks-and-partition is error-free
# for trivial code, 0 otherwise.

proc check_effective_target_freorder {} {
    return [check_no_compiler_messages freorder object {
	void foo (void) { }
    } "-freorder-blocks-and-partition"]
}

# Return 1 if -fpic and -fPIC are supported, as in no warnings or errors
# emitted, 0 otherwise.  Whether a shared library can actually be built is
# out of scope for this test.

proc check_effective_target_fpic { } {
    # Note that M68K has a multilib that supports -fpic but not
    # -fPIC, so we need to check both.  We test with a program that
    # requires GOT references.
    foreach arg {fpic fPIC} {
	if [check_no_compiler_messages $arg object {
	    extern int foo (void); extern int bar;
	    int baz (void) { return foo () + bar; }
	} "-$arg"] {
	    return 1
	}
    }
    return 0
}

# Return true if the target supports -mpaired-single (as used on MIPS).

proc check_effective_target_mpaired_single { } {
    return [check_no_compiler_messages mpaired_single object {
	void foo (void) { }
    } "-mpaired-single"]
}

# Return true if the target has access to FPU instructions.

proc check_effective_target_hard_float { } {
    if { [istarget mips*-*-*] } {
	return [check_no_compiler_messages hard_float assembly {
		#if (defined __mips_soft_float || defined __mips16)
		#error FOO
		#endif
	}]
    }

    # This proc is actually checking the availabilty of FPU
    # support for doubles, so on the RX we must fail if the
    # 64-bit double multilib has been selected.
    if { [istarget rx-*-*] } {
	return 0
	# return [check_no_compiler_messages hard_float assembly {
		#if defined __RX_64_BIT_DOUBLES__
		#error FOO
		#endif
	# }]
    }

    # The generic test equates hard_float with "no call for adding doubles".
    return [check_no_messages_and_pattern hard_float "!\\(call" rtl-expand {
	double a (double b, double c) { return b + c; }
    }]
}

# Return true if the target is a 64-bit MIPS target.

proc check_effective_target_mips64 { } {
    return [check_no_compiler_messages mips64 assembly {
	#ifndef __mips64
	#error FOO
	#endif
    }]
}

# Return true if the target is a MIPS target that does not produce
# MIPS16 code.

proc check_effective_target_nomips16 { } {
    return [check_no_compiler_messages nomips16 object {
	#ifndef __mips
	#error FOO
	#else
	/* A cheap way of testing for -mflip-mips16.  */
	void foo (void) { asm ("addiu $20,$20,1"); }
	void bar (void) { asm ("addiu $20,$20,1"); }
	#endif
    }]
}

# Add the options needed for MIPS16 function attributes.  At the moment,
# we don't support MIPS16 PIC.

proc add_options_for_mips16_attribute { flags } {
    return "$flags -mno-abicalls -fno-pic -DMIPS16=__attribute__((mips16))"
}

# Return true if we can force a mode that allows MIPS16 code generation.
# We don't support MIPS16 PIC, and only support MIPS16 -mhard-float
# for o32 and o64.

proc check_effective_target_mips16_attribute { } {
    return [check_no_compiler_messages mips16_attribute assembly {
	#ifdef PIC
	#error FOO
	#endif
	#if defined __mips_hard_float \
	    && (!defined _ABIO32 || _MIPS_SIM != _ABIO32) \
	    && (!defined _ABIO64 || _MIPS_SIM != _ABIO64)
	#error FOO
	#endif
    } [add_options_for_mips16_attribute ""]]
}

# Return 1 if the target supports long double larger than double when
# using the new ABI, 0 otherwise.

proc check_effective_target_mips_newabi_large_long_double { } {
    return [check_no_compiler_messages mips_newabi_large_long_double object {
	int dummy[sizeof(long double) > sizeof(double) ? 1 : -1];
    } "-mabi=64"]
}

# Return 1 if the current multilib does not generate PIC by default.

proc check_effective_target_nonpic { } {
    return [check_no_compiler_messages nonpic assembly {
	#if __PIC__
	#error FOO
	#endif
    }]
}

# Return 1 if the target does not use a status wrapper.

proc check_effective_target_unwrapped { } {
    if { [target_info needs_status_wrapper] != "" \
	     && [target_info needs_status_wrapper] != "0" } {
	return 0
    }
    return 1
}

# Return true if iconv is supported on the target. In particular IBM1047.

proc check_iconv_available { test_what } {
    global libiconv

    # If the tool configuration file has not set libiconv, try "-liconv"
    if { ![info exists libiconv] } {
	set libiconv "-liconv"
    }
    set test_what [lindex $test_what 1]
    return [check_runtime_nocache $test_what [subst {
	#include <iconv.h>
	int main (void)
	{
	  iconv_t cd;

	  cd = iconv_open ("$test_what", "UTF-8");
	  if (cd == (iconv_t) -1)
	    return 1;
	  return 0;
	}
    }] $libiconv]
}

# Return true if named sections are supported on this target.

proc check_named_sections_available { } {
    return [check_no_compiler_messages named_sections assembly {
	int __attribute__ ((section("whatever"))) foo;
    }]
}

# Return 1 if the target supports Fortran real kinds larger than real(8),
# 0 otherwise.
#
# When the target name changes, replace the cached result.

proc check_effective_target_fortran_large_real { } {
    return [check_no_compiler_messages fortran_large_real executable {
	! Fortran
	integer,parameter :: k = selected_real_kind (precision (0.0_8) + 1)
	real(kind=k) :: x
	x = cos (x)
	end
    }]
}

# Return 1 if the target supports Fortran integer kinds larger than
# integer(8), 0 otherwise.
#
# When the target name changes, replace the cached result.

proc check_effective_target_fortran_large_int { } {
    return [check_no_compiler_messages fortran_large_int executable {
	! Fortran
	integer,parameter :: k = selected_int_kind (range (0_8) + 1)
	integer(kind=k) :: i
	end
    }]
}

# Return 1 if the target supports Fortran integer(16), 0 otherwise.
#
# When the target name changes, replace the cached result.

proc check_effective_target_fortran_integer_16 { } {
    return [check_no_compiler_messages fortran_integer_16 executable {
        ! Fortran
        integer(16) :: i
        end
    }]
}

# Return 1 if we can statically link libgfortran, 0 otherwise.
#
# When the target name changes, replace the cached result.

proc check_effective_target_static_libgfortran { } {
    return [check_no_compiler_messages static_libgfortran executable {
	! Fortran
	print *, 'test'
	end
    } "-static"]
}

proc check_linker_plugin_available { } {
  return [check_no_compiler_messages_nocache linker_plugin executable {
     int main() { return 0; }
  } "-flto -fuse-linker-plugin"]
}

# Return 1 if the target supports executing 750CL paired-single instructions, 0
# otherwise.  Cache the result.

proc check_750cl_hw_available { } {
    return [check_cached_effective_target 750cl_hw_available {
	# If this is not the right target then we can skip the test.
	if { ![istarget powerpc-*paired*] } {
	    expr 0
	} else {
	    check_runtime_nocache 750cl_hw_available {
		 int main()
		 {
		 #ifdef __MACH__
		   asm volatile ("ps_mul v0,v0,v0");
		 #else
		   asm volatile ("ps_mul 0,0,0");
		 #endif
		   return 0;
		 }
	    } "-mpaired"
	}
    }]
}

# Return 1 if the target OS supports running SSE executables, 0
# otherwise.  Cache the result.

proc check_sse_os_support_available { } {
    return [check_cached_effective_target sse_os_support_available {
	# If this is not the right target then we can skip the test.
	if { !([istarget x86_64-*-*] || [istarget i?86-*-*]) } {
	    expr 0
	} elseif { [istarget i?86-*-solaris2*] } {
	    # The Solaris 2 kernel doesn't save and restore SSE registers
	    # before Solaris 9 4/04.  Before that, executables die with SIGILL.
	    check_runtime_nocache sse_os_support_available {
		int main ()
		{
		    __asm__ volatile ("movss %xmm2,%xmm1");
		    return 0;
		}
	    } "-msse"
	} else {
	    expr 1
	}
    }]
}

# Return 1 if the target supports executing SSE instructions, 0
# otherwise.  Cache the result.

proc check_sse_hw_available { } {
    return [check_cached_effective_target sse_hw_available {
	# If this is not the right target then we can skip the test.
	if { !([istarget x86_64-*-*] || [istarget i?86-*-*]) } {
	    expr 0
	} else {
	    check_runtime_nocache sse_hw_available {
		#include "cpuid.h"
		int main ()
		{
		  unsigned int eax, ebx, ecx, edx;
		  if (__get_cpuid (1, &eax, &ebx, &ecx, &edx))
		    return !(edx & bit_SSE);
		  return 1;
		}
	    } ""
	}
    }]
}

# Return 1 if the target supports executing SSE2 instructions, 0
# otherwise.  Cache the result.

proc check_sse2_hw_available { } {
    return [check_cached_effective_target sse2_hw_available {
	# If this is not the right target then we can skip the test.
	if { !([istarget x86_64-*-*] || [istarget i?86-*-*]) } {
	    expr 0
	} else {
	    check_runtime_nocache sse2_hw_available {
		#include "cpuid.h"
		int main ()
		{
		  unsigned int eax, ebx, ecx, edx;
		  if (__get_cpuid (1, &eax, &ebx, &ecx, &edx))
		    return !(edx & bit_SSE2);
		  return 1;
		}
	    } ""
	}
    }]
}

# Return 1 if the target supports executing AVX instructions, 0
# otherwise.  Cache the result.

proc check_avx_hw_available { } {
    return [check_cached_effective_target avx_hw_available {
	# If this is not the right target then we can skip the test.
	if { !([istarget x86_64-*-*] || [istarget i?86-*-*]) } {
	    expr 0
	} else {
	    check_runtime_nocache avx_hw_available {
		#include "cpuid.h"
		int main ()
		{
		  unsigned int eax, ebx, ecx, edx;
		  if (__get_cpuid (1, &eax, &ebx, &ecx, &edx))
		    return ((ecx & (bit_AVX | bit_OSXSAVE))
			    != (bit_AVX | bit_OSXSAVE));
		  return 1;
		}
	    } ""
	}
    }]
}

# Return 1 if the target supports running SSE executables, 0 otherwise.

proc check_effective_target_sse_runtime { } {
    if { [check_effective_target_sse]
	 && [check_sse_hw_available]
	 && [check_sse_os_support_available] } {
	return 1
    }
    return 0
}

# Return 1 if the target supports running SSE2 executables, 0 otherwise.

proc check_effective_target_sse2_runtime { } {
    if { [check_effective_target_sse2]
	 && [check_sse2_hw_available]
	 && [check_sse_os_support_available] } {
	return 1
    }
    return 0
}

# Return 1 if the target supports running AVX executables, 0 otherwise.

proc check_effective_target_avx_runtime { } {
    if { [check_effective_target_avx]
	 && [check_avx_hw_available] } {
	return 1
    }
    return 0
}

# Return 1 if the target supports executing VSX instructions, 0
# otherwise.  Cache the result.

proc check_vsx_hw_available { } {
    return [check_cached_effective_target vsx_hw_available {
	# Some simulators are known to not support VSX instructions.
	# For now, disable on Darwin
	if { [istarget powerpc-*-eabi] || [istarget powerpc*-*-eabispe] || [istarget *-*-darwin*]} {
	    expr 0
	} else {
	    set options "-mvsx"
	    check_runtime_nocache vsx_hw_available {
		int main()
		{
		#ifdef __MACH__
		  asm volatile ("xxlor vs0,vs0,vs0");
		#else
		  asm volatile ("xxlor 0,0,0");
	        #endif
		  return 0;
		}
	    } $options
	}
    }]
}

# Return 1 if the target supports executing AltiVec instructions, 0
# otherwise.  Cache the result.

proc check_vmx_hw_available { } {
    return [check_cached_effective_target vmx_hw_available {
	# Some simulators are known to not support VMX instructions.
	if { [istarget powerpc-*-eabi] || [istarget powerpc*-*-eabispe] } {
	    expr 0
	} else {
	    # Most targets don't require special flags for this test case, but
	    # Darwin does.  Just to be sure, make sure VSX is not enabled for
	    # the altivec tests.
	    if { [istarget *-*-darwin*]
		 || [istarget *-*-aix*] } {
		set options "-maltivec -mno-vsx"
	    } else {
		set options "-mno-vsx"
	    }
	    check_runtime_nocache vmx_hw_available {
		int main()
		{
		#ifdef __MACH__
		  asm volatile ("vor v0,v0,v0");
		#else
		  asm volatile ("vor 0,0,0");
	        #endif
		  return 0;
		}
	    } $options
	}
    }]
}

proc check_ppc_recip_hw_available { } {
    return [check_cached_effective_target ppc_recip_hw_available {
	# Some simulators may not support FRE/FRES/FRSQRTE/FRSQRTES
	# For now, disable on Darwin
	if { [istarget powerpc-*-eabi] || [istarget powerpc*-*-eabispe] || [istarget *-*-darwin*]} {
	    expr 0
	} else {
	    set options "-mpowerpc-gfxopt -mpowerpc-gpopt -mpopcntb"
	    check_runtime_nocache ppc_recip_hw_available {
		volatile double d_recip, d_rsqrt, d_four = 4.0;
		volatile float f_recip, f_rsqrt, f_four = 4.0f;
		int main()
		{
		  asm volatile ("fres %0,%1" : "=f" (f_recip) : "f" (f_four));
		  asm volatile ("fre %0,%1" : "=d" (d_recip) : "d" (d_four));
		  asm volatile ("frsqrtes %0,%1" : "=f" (f_rsqrt) : "f" (f_four));
		  asm volatile ("frsqrte %0,%1" : "=f" (d_rsqrt) : "d" (d_four));
		  return 0;
		}
	    } $options
	}
    }]
}

# Return 1 if the target supports executing AltiVec and Cell PPU
# instructions, 0 otherwise.  Cache the result.

proc check_effective_target_cell_hw { } {
    return [check_cached_effective_target cell_hw_available {
	# Some simulators are known to not support VMX and PPU instructions.
	if { [istarget powerpc-*-eabi*] } {
	    expr 0
	} else {
	    # Most targets don't require special flags for this test
	    # case, but Darwin and AIX do.
	    if { [istarget *-*-darwin*]
		 || [istarget *-*-aix*] } {
		set options "-maltivec -mcpu=cell"
	    } else {
		set options "-mcpu=cell"
	    }
	    check_runtime_nocache cell_hw_available {
		int main()
		{
		#ifdef __MACH__
		  asm volatile ("vor v0,v0,v0");
                  asm volatile ("lvlx v0,r0,r0");
		#else
		  asm volatile ("vor 0,0,0");
                  asm volatile ("lvlx 0,0,0");
	        #endif
		  return 0;
		}
	    } $options
	}
    }]
}

# Return 1 if the target supports executing 64-bit instructions, 0
# otherwise.  Cache the result.

proc check_effective_target_powerpc64 { } {
    global powerpc64_available_saved
    global tool

    if [info exists powerpc64_available_saved] {
	verbose "check_effective_target_powerpc64 returning saved $powerpc64_available_saved" 2
    } else {
	set powerpc64_available_saved 0

	# Some simulators are known to not support powerpc64 instructions.
	if { [istarget powerpc-*-eabi*] || [istarget powerpc-ibm-aix*] } {
	    verbose "check_effective_target_powerpc64 returning 0" 2
	    return $powerpc64_available_saved
	}

	# Set up, compile, and execute a test program containing a 64-bit
	# instruction.  Include the current process ID in the file
	# names to prevent conflicts with invocations for multiple
	# testsuites.
	set src ppc[pid].c
	set exe ppc[pid].x

	set f [open $src "w"]
	puts $f "int main() {"
	puts $f "#ifdef __MACH__"
	puts $f "  asm volatile (\"extsw r0,r0\");"
	puts $f "#else"
	puts $f "  asm volatile (\"extsw 0,0\");"
	puts $f "#endif"
	puts $f "  return 0; }"
	close $f

	set opts "additional_flags=-mcpu=G5"

	verbose "check_effective_target_powerpc64 compiling testfile $src" 2
	set lines [${tool}_target_compile $src $exe executable "$opts"]
	file delete $src

	if [string match "" $lines] then {
	    # No error message, compilation succeeded.
	    set result [${tool}_load "./$exe" "" ""]
	    set status [lindex $result 0]
	    remote_file build delete $exe
	    verbose "check_effective_target_powerpc64 testfile status is <$status>" 2

	    if { $status == "pass" } then {
		set powerpc64_available_saved 1
	    }
	} else {
	    verbose "check_effective_target_powerpc64 testfile compilation failed" 2
	}
    }

    return $powerpc64_available_saved
}

# GCC 3.4.0 for powerpc64-*-linux* included an ABI fix for passing
# complex float arguments.  This affects gfortran tests that call cabsf
# in libm built by an earlier compiler.  Return 1 if libm uses the same
# argument passing as the compiler under test, 0 otherwise.
#
# When the target name changes, replace the cached result.

proc check_effective_target_broken_cplxf_arg { } {
    return [check_cached_effective_target broken_cplxf_arg {
	# Skip the work for targets known not to be affected.
	if { ![istarget powerpc64-*-linux*] } {
	    expr 0
	} elseif { ![is-effective-target lp64] } {
	    expr 0
	} else {
	    check_runtime_nocache broken_cplxf_arg {
		#include <complex.h>
		extern void abort (void);
		float fabsf (float);
		float cabsf (_Complex float);
		int main ()
		{
		  _Complex float cf;
		  float f;
		  cf = 3 + 4.0fi;
		  f = cabsf (cf);
		  if (fabsf (f - 5.0) > 0.0001)
		    abort ();
		  return 0;
		}
	    } "-lm"
	}
    }]
}

proc check_alpha_max_hw_available { } {
    return [check_runtime alpha_max_hw_available {
	int main() { return __builtin_alpha_amask(1<<8) != 0; }
    }]
}

# Returns true iff the FUNCTION is available on the target system.
# (This is essentially a Tcl implementation of Autoconf's
# AC_CHECK_FUNC.)

proc check_function_available { function } {
    return [check_no_compiler_messages ${function}_available \
		executable [subst {
	#ifdef __cplusplus
	extern "C"
	#endif
	char $function ();
	int main () { $function (); }
    }]]
}

# Returns true iff "fork" is available on the target system.

proc check_fork_available {} {
    return [check_function_available "fork"]
}

# Returns true iff "mkfifo" is available on the target system.

proc check_mkfifo_available {} {
    if {[istarget *-*-cygwin*]} {
       # Cygwin has mkfifo, but support is incomplete.
       return 0
     }

    return [check_function_available "mkfifo"]
}

# Returns true iff "__cxa_atexit" is used on the target system.

proc check_cxa_atexit_available { } {
    return [check_cached_effective_target cxa_atexit_available {
	if { [istarget "hppa*-*-hpux10*"] } {
	    # HP-UX 10 doesn't have __cxa_atexit but subsequent test passes.
	    expr 0
	} elseif { [istarget "*-*-vxworks"] } {
	    # vxworks doesn't have __cxa_atexit but subsequent test passes.
	    expr 0
	} else {
	    check_runtime_nocache cxa_atexit_available {
		// C++
		#include <stdlib.h>
		static unsigned int count;
		struct X
		{
		  X() { count = 1; }
		  ~X()
		  {
		    if (count != 3)
		      exit(1);
		    count = 4;
		  }
		};
		void f()
		{
		  static X x;
		}
		struct Y
		{
		  Y() { f(); count = 2; }
		  ~Y()
		  {
		    if (count != 2)
		      exit(1);
		    count = 3;
		  }
		};
		Y y;
		int main() { return 0; }
	    }
	}
    }]
}

proc check_effective_target_objc2 { } {
    return [check_no_compiler_messages objc2 object {
	#ifdef __OBJC2__
	int dummy[1];
	#else
	#error
	#endif 
    }]
}

proc check_effective_target_next_runtime { } {
    return [check_no_compiler_messages objc2 object {
	#ifdef __NEXT_RUNTIME__
	int dummy[1];
	#else
	#error
	#endif 
    }]
}

# Return 1 if we're generating 32-bit code using default options, 0
# otherwise.

proc check_effective_target_ilp32 { } {
    return [check_no_compiler_messages ilp32 object {
	int dummy[sizeof (int) == 4
		  && sizeof (void *) == 4
		  && sizeof (long) == 4 ? 1 : -1];
    }]
}

# Return 1 if we're generating 32-bit or larger integers using default
# options, 0 otherwise.

proc check_effective_target_int32plus { } {
    return [check_no_compiler_messages int32plus object {
	int dummy[sizeof (int) >= 4 ? 1 : -1];
    }]
}

# Return 1 if we're generating 32-bit or larger pointers using default
# options, 0 otherwise.

proc check_effective_target_ptr32plus { } {
    return [check_no_compiler_messages ptr32plus object {
	int dummy[sizeof (void *) >= 4 ? 1 : -1];
    }]
}

# Return 1 if we support 32-bit or larger array and structure sizes
# using default options, 0 otherwise.

proc check_effective_target_size32plus { } {
    return [check_no_compiler_messages size32plus object {
	char dummy[65537];
    }]
}

# Returns 1 if we're generating 16-bit or smaller integers with the
# default options, 0 otherwise.

proc check_effective_target_int16 { } {
    return [check_no_compiler_messages int16 object {
	int dummy[sizeof (int) < 4 ? 1 : -1];
    }]
}

# Return 1 if we're generating 64-bit code using default options, 0
# otherwise.

proc check_effective_target_lp64 { } {
    return [check_no_compiler_messages lp64 object {
	int dummy[sizeof (int) == 4
		  && sizeof (void *) == 8
		  && sizeof (long) == 8 ? 1 : -1];
    }]
}

# Return 1 if we're generating 64-bit code using default llp64 options,
# 0 otherwise.

proc check_effective_target_llp64 { } {
    return [check_no_compiler_messages llp64 object {
	int dummy[sizeof (int) == 4
		  && sizeof (void *) == 8
		  && sizeof (long long) == 8
		  && sizeof (long) == 4 ? 1 : -1];
    }]
}

# Return 1 if the target supports long double larger than double,
# 0 otherwise.

proc check_effective_target_large_long_double { } {
    return [check_no_compiler_messages large_long_double object {
	int dummy[sizeof(long double) > sizeof(double) ? 1 : -1];
    }]
}

# Return 1 if the target supports double larger than float,
# 0 otherwise.

proc check_effective_target_large_double { } {
    return [check_no_compiler_messages large_double object {
	int dummy[sizeof(double) > sizeof(float) ? 1 : -1];
    }]
}

# Return 1 if the target supports double of 64 bits,
# 0 otherwise.

proc check_effective_target_double64 { } {
    return [check_no_compiler_messages double64 object {
	int dummy[sizeof(double) == 8 ? 1 : -1];
    }]
}

# Return 1 if the target supports double of at least 64 bits,
# 0 otherwise.

proc check_effective_target_double64plus { } {
    return [check_no_compiler_messages double64plus object {
	int dummy[sizeof(double) >= 8 ? 1 : -1];
    }]
}

# Return 1 if the target supports compiling fixed-point,
# 0 otherwise.

proc check_effective_target_fixed_point { } {
    return [check_no_compiler_messages fixed_point object {
        _Sat _Fract x; _Sat _Accum y;
    }]
}

# Return 1 if the target supports compiling decimal floating point,
# 0 otherwise.

proc check_effective_target_dfp_nocache { } {
    verbose "check_effective_target_dfp_nocache: compiling source" 2
    set ret [check_no_compiler_messages_nocache dfp object {
	float x __attribute__((mode(DD)));
    }]
    verbose "check_effective_target_dfp_nocache: returning $ret" 2
    return $ret
}

proc check_effective_target_dfprt_nocache { } {
    return [check_runtime_nocache dfprt {
	typedef float d64 __attribute__((mode(DD)));
	d64 x = 1.2df, y = 2.3dd, z;
	int main () { z = x + y; return 0; }
    }]
}

# Return 1 if the target supports compiling Decimal Floating Point,
# 0 otherwise.
#
# This won't change for different subtargets so cache the result.

proc check_effective_target_dfp { } {
    return [check_cached_effective_target dfp {
	check_effective_target_dfp_nocache
    }]
}

# Return 1 if the target supports linking and executing Decimal Floating
# Point, 0 otherwise.
#
# This won't change for different subtargets so cache the result.

proc check_effective_target_dfprt { } {
    return [check_cached_effective_target dfprt {
	check_effective_target_dfprt_nocache
    }]
}

# Return 1 if the target supports compiling and assembling UCN, 0 otherwise.

proc check_effective_target_ucn_nocache { } {
    # -std=c99 is only valid for C
    if [check_effective_target_c] {
	set ucnopts "-std=c99"
    }
    append ucnopts " -fextended-identifiers"
    verbose "check_effective_target_ucn_nocache: compiling source" 2
    set ret [check_no_compiler_messages_nocache ucn object {
	int \u00C0;
    } $ucnopts]
    verbose "check_effective_target_ucn_nocache: returning $ret" 2
    return $ret
}

# Return 1 if the target supports compiling and assembling UCN, 0 otherwise.
#
# This won't change for different subtargets, so cache the result.

proc check_effective_target_ucn { } {
    return [check_cached_effective_target ucn {
	check_effective_target_ucn_nocache
    }]
}

# Return 1 if the target needs a command line argument to enable a SIMD
# instruction set.

proc check_effective_target_vect_cmdline_needed { } {
    global et_vect_cmdline_needed_saved
    global et_vect_cmdline_needed_target_name

    if { ![info exists et_vect_cmdline_needed_target_name] } {
	set et_vect_cmdline_needed_target_name ""
    }

    # If the target has changed since we set the cached value, clear it.
    set current_target [current_target_name]
    if { $current_target != $et_vect_cmdline_needed_target_name } {
	verbose "check_effective_target_vect_cmdline_needed: `$et_vect_cmdline_needed_target_name' `$current_target'" 2
	set et_vect_cmdline_needed_target_name $current_target
	if { [info exists et_vect_cmdline_needed_saved] } {
	    verbose "check_effective_target_vect_cmdline_needed: removing cached result" 2
	    unset et_vect_cmdline_needed_saved
	}
    }

    if [info exists et_vect_cmdline_needed_saved] {
	verbose "check_effective_target_vect_cmdline_needed: using cached result" 2
    } else {
	set et_vect_cmdline_needed_saved 1
	if { [istarget alpha*-*-*]
	     || [istarget ia64-*-*]
	     || (([istarget x86_64-*-*] || [istarget i?86-*-*])
		 && [check_effective_target_lp64])
	     || ([istarget powerpc*-*-*]
		 && ([check_effective_target_powerpc_spe]
		     || [check_effective_target_powerpc_altivec]))
             || [istarget spu-*-*]
	     || ([istarget arm*-*-*] && [check_effective_target_arm_neon]) } {
	   set et_vect_cmdline_needed_saved 0
	}
    }

    verbose "check_effective_target_vect_cmdline_needed: returning $et_vect_cmdline_needed_saved" 2
    return $et_vect_cmdline_needed_saved
}

# Return 1 if the target supports hardware vectors of int, 0 otherwise.
#
# This won't change for different subtargets so cache the result.

proc check_effective_target_vect_int { } {
    global et_vect_int_saved

    if [info exists et_vect_int_saved] {
	verbose "check_effective_target_vect_int: using cached result" 2
    } else {
	set et_vect_int_saved 0
	if { [istarget i?86-*-*]
             || ([istarget powerpc*-*-*]
                  && ![istarget powerpc-*-linux*paired*])
	      || [istarget spu-*-*]
	      || [istarget x86_64-*-*]
	      || [istarget sparc*-*-*]
	      || [istarget alpha*-*-*]
	      || [istarget ia64-*-*] 
	      || [check_effective_target_arm32]
	      || ([istarget mips*-*-*]
		  && [check_effective_target_mips_loongson]) } {
	   set et_vect_int_saved 1
	}
    }

    verbose "check_effective_target_vect_int: returning $et_vect_int_saved" 2
    return $et_vect_int_saved
}

# Return 1 if the target supports signed int->float conversion 
#

proc check_effective_target_vect_intfloat_cvt { } {
    global et_vect_intfloat_cvt_saved

    if [info exists et_vect_intfloat_cvt_saved] {
        verbose "check_effective_target_vect_intfloat_cvt: using cached result" 2
    } else {
        set et_vect_intfloat_cvt_saved 0
        if { [istarget i?86-*-*]
              || ([istarget powerpc*-*-*]
                   && ![istarget powerpc-*-linux*paired*])
              || [istarget x86_64-*-*] } {
           set et_vect_intfloat_cvt_saved 1
        }
    }

    verbose "check_effective_target_vect_intfloat_cvt: returning $et_vect_intfloat_cvt_saved" 2
    return $et_vect_intfloat_cvt_saved
}

#Return 1 if we're supporting __int128 for target, 0 otherwise.

proc check_effective_target_int128 { } {
    return [check_no_compiler_messages int128 object {
	int dummy[
    	#ifndef __SIZEOF_INT128__
    	-1
    	#else
    	1
    	#endif
	];
    }]
}

# Return 1 if the target supports unsigned int->float conversion 
#

proc check_effective_target_vect_uintfloat_cvt { } {
    global et_vect_uintfloat_cvt_saved

    if [info exists et_vect_uintfloat_cvt_saved] {
        verbose "check_effective_target_vect_uintfloat_cvt: using cached result" 2
    } else {
        set et_vect_uintfloat_cvt_saved 0
        if { [istarget i?86-*-*]
	      || ([istarget powerpc*-*-*]
		  && ![istarget powerpc-*-linux*paired*])
	      || [istarget x86_64-*-*] } {
           set et_vect_uintfloat_cvt_saved 1
        }
    }

    verbose "check_effective_target_vect_uintfloat_cvt: returning $et_vect_uintfloat_cvt_saved" 2
    return $et_vect_uintfloat_cvt_saved
}


# Return 1 if the target supports signed float->int conversion
#

proc check_effective_target_vect_floatint_cvt { } {
    global et_vect_floatint_cvt_saved

    if [info exists et_vect_floatint_cvt_saved] {
        verbose "check_effective_target_vect_floatint_cvt: using cached result" 2
    } else {
        set et_vect_floatint_cvt_saved 0
        if { [istarget i?86-*-*]
              || ([istarget powerpc*-*-*]
                   && ![istarget powerpc-*-linux*paired*])
              || [istarget x86_64-*-*] } {
           set et_vect_floatint_cvt_saved 1
        }
    }

    verbose "check_effective_target_vect_floatint_cvt: returning $et_vect_floatint_cvt_saved" 2
    return $et_vect_floatint_cvt_saved
}

# Return 1 if the target supports unsigned float->int conversion
#

proc check_effective_target_vect_floatuint_cvt { } {
    global et_vect_floatuint_cvt_saved

    if [info exists et_vect_floatuint_cvt_saved] {
        verbose "check_effective_target_vect_floatuint_cvt: using cached result" 2
    } else {
        set et_vect_floatuint_cvt_saved 0
        if { ([istarget powerpc*-*-*]
	      && ![istarget powerpc-*-linux*paired*]) } {
           set et_vect_floatuint_cvt_saved 1
        }
    }

    verbose "check_effective_target_vect_floatuint_cvt: returning $et_vect_floatuint_cvt_saved" 2
    return $et_vect_floatuint_cvt_saved
}

# Return 1 is this is an arm target using 32-bit instructions
proc check_effective_target_arm32 { } {
    return [check_no_compiler_messages arm32 assembly {
	#if !defined(__arm__) || (defined(__thumb__) && !defined(__thumb2__))
	#error FOO
	#endif
    }]
}

# Return 1 if this is an ARM target supporting -mfpu=vfp
# -mfloat-abi=softfp.  Some multilibs may be incompatible with these
# options.

proc check_effective_target_arm_vfp_ok { } {
    if { [check_effective_target_arm32] } {
	return [check_no_compiler_messages arm_vfp_ok object {
	    int dummy;
	} "-mfpu=vfp -mfloat-abi=softfp"]
    } else {
	return 0
    }
}

# Return 1 if this is an ARM target supporting -mfpu=vfp
# -mfloat-abi=hard.  Some multilibs may be incompatible with these
# options.

proc check_effective_target_arm_hard_vfp_ok { } {
    if { [check_effective_target_arm32] } {
	return [check_no_compiler_messages arm_hard_vfp_ok executable {
	    int main() { return 0;}
	} "-mfpu=vfp -mfloat-abi=hard"]
    } else {
	return 0
    }
}

# Add the options needed for NEON.  We need either -mfloat-abi=softfp
# or -mfloat-abi=hard, but if one is already specified by the
# multilib, use it.  Similarly, if a -mfpu option already enables
# NEON, do not add -mfpu=neon.

proc add_options_for_arm_neon { flags } {
    if { ! [check_effective_target_arm_neon_ok] } {
	return "$flags"
    }
    global et_arm_neon_flags
    return "$flags $et_arm_neon_flags"
}

# Return 1 if this is an ARM target supporting -mfpu=neon
# -mfloat-abi=softfp or equivalent options.  Some multilibs may be
# incompatible with these options.  Also set et_arm_neon_flags to the
# best options to add.

proc check_effective_target_arm_neon_ok_nocache { } {
    global et_arm_neon_flags
    set et_arm_neon_flags ""
    if { [check_effective_target_arm32] } {
	foreach flags {"" "-mfloat-abi=softfp" "-mfpu=neon" "-mfpu=neon -mfloat-abi=softfp"} {
	    if { [check_no_compiler_messages_nocache arm_neon_ok object {
		#include "arm_neon.h"
		int dummy;
	    } "$flags"] } {
		set et_arm_neon_flags $flags
		return 1
	    }
	}
    }

    return 0
}

proc check_effective_target_arm_neon_ok { } {
    return [check_cached_effective_target arm_neon_ok \
		check_effective_target_arm_neon_ok_nocache]
}

# Add the options needed for NEON.  We need either -mfloat-abi=softfp
# or -mfloat-abi=hard, but if one is already specified by the
# multilib, use it.

proc add_options_for_arm_neon_fp16 { flags } {
    if { ! [check_effective_target_arm_neon_fp16_ok] } {
	return "$flags"
    }
    global et_arm_neon_fp16_flags
    return "$flags $et_arm_neon_fp16_flags"
}

# Return 1 if this is an ARM target supporting -mfpu=neon-fp16
# -mfloat-abi=softfp or equivalent options.  Some multilibs may be
# incompatible with these options.  Also set et_arm_neon_flags to the
# best options to add.

proc check_effective_target_arm_neon_fp16_ok_nocache { } {
    global et_arm_neon_fp16_flags
    set et_arm_neon_fp16_flags ""
    if { [check_effective_target_arm32] } {
	# Always add -mfpu=neon-fp16, since there is no preprocessor
	# macro for FP16 support.
	foreach flags {"-mfpu=neon-fp16" "-mfpu=neon-fp16 -mfloat-abi=softfp"} {
	    if { [check_no_compiler_messages_nocache arm_neon_fp16_ok object {
		#include "arm_neon.h"
		int dummy;
	    } "$flags"] } {
		set et_arm_neon_fp16_flags $flags
		return 1
	    }
	}
    }

    return 0
}

proc check_effective_target_arm_neon_fp16_ok { } {
    return [check_cached_effective_target arm_neon_fp16_ok \
		check_effective_target_arm_neon_fp16_ok_nocache]
}

# Return 1 is this is an ARM target where -mthumb causes Thumb-1 to be
# used.

proc check_effective_target_arm_thumb1_ok { } {
    return [check_no_compiler_messages arm_thumb1_ok assembly {
	#if !defined(__arm__) || !defined(__thumb__) || defined(__thumb2__)
	#error FOO
	#endif
    } "-mthumb"]
}

# Return 1 is this is an ARM target where -mthumb causes Thumb-2 to be
# used.

proc check_effective_target_arm_thumb2_ok { } {
    return [check_no_compiler_messages arm_thumb2_ok assembly {
	#if !defined(__thumb2__)
	#error FOO
	#endif
    } "-mthumb"]
}

# Return 1 if the target supports executing NEON instructions, 0
# otherwise.  Cache the result.

proc check_effective_target_arm_neon_hw { } {
    return [check_runtime arm_neon_hw_available {
	int
	main (void)
	{
	  long long a = 0, b = 1;
	  asm ("vorr %P0, %P1, %P2"
	       : "=w" (a)
	       : "0" (a), "w" (b));
	  return (a != 1);
	}
    } [add_options_for_arm_neon ""]]
}

# Return 1 if this is a ARM target with NEON enabled.

proc check_effective_target_arm_neon { } {
    if { [check_effective_target_arm32] } {
	return [check_no_compiler_messages arm_neon object {
	    #ifndef __ARM_NEON__
	    #error not NEON
	    #else
	    int dummy;
	    #endif
	}]
    } else {
	return 0
    }
}

# Return 1 if this a Loongson-2E or -2F target using an ABI that supports
# the Loongson vector modes.

proc check_effective_target_mips_loongson { } {
    return [check_no_compiler_messages loongson assembly {
	#if !defined(__mips_loongson_vector_rev)
	#error FOO
	#endif
    }]
}

# Return 1 if this is an ARM target that adheres to the ABI for the ARM
# Architecture.

proc check_effective_target_arm_eabi { } {
    return [check_no_compiler_messages arm_eabi object {
	#ifndef __ARM_EABI__
	#error not EABI
	#else
	int dummy;
	#endif
    }]
}

# Return 1 if this is an ARM target supporting -mcpu=iwmmxt.
# Some multilibs may be incompatible with this option.

proc check_effective_target_arm_iwmmxt_ok { } {
    if { [check_effective_target_arm32] } {
	return [check_no_compiler_messages arm_iwmmxt_ok object {
	    int dummy;
	} "-mcpu=iwmmxt"]
    } else {
	return 0
    }
}

# Return 1 if this is a PowerPC target with floating-point registers.

proc check_effective_target_powerpc_fprs { } {
    if { [istarget powerpc*-*-*]
	 || [istarget rs6000-*-*] } {
	return [check_no_compiler_messages powerpc_fprs object {
	    #ifdef __NO_FPRS__
	    #error no FPRs
	    #else
	    int dummy;
	    #endif
	}]
    } else {
	return 0
    }
}

# Return 1 if this is a PowerPC target with hardware double-precision
# floating point.

proc check_effective_target_powerpc_hard_double { } {
    if { [istarget powerpc*-*-*]
	 || [istarget rs6000-*-*] } {
	return [check_no_compiler_messages powerpc_hard_double object {
	    #ifdef _SOFT_DOUBLE
	    #error soft double
	    #else
	    int dummy;
	    #endif
	}]
    } else {
	return 0
    }
}

# Return 1 if this is a PowerPC target supporting -maltivec.

proc check_effective_target_powerpc_altivec_ok { } {
    if { ([istarget powerpc*-*-*]
         && ![istarget powerpc-*-linux*paired*])
	 || [istarget rs6000-*-*] } {
	# AltiVec is not supported on AIX before 5.3.
	if { [istarget powerpc*-*-aix4*]
	     || [istarget powerpc*-*-aix5.1*] 
	     || [istarget powerpc*-*-aix5.2*] } {
	    return 0
	}
	return [check_no_compiler_messages powerpc_altivec_ok object {
	    int dummy;
	} "-maltivec"]
    } else {
	return 0
    }
}

# Return 1 if this is a PowerPC target supporting -mvsx

proc check_effective_target_powerpc_vsx_ok { } {
    if { ([istarget powerpc*-*-*]
         && ![istarget powerpc-*-linux*paired*])
	 || [istarget rs6000-*-*] } {
	# AltiVec is not supported on AIX before 5.3.
	if { [istarget powerpc*-*-aix4*]
	     || [istarget powerpc*-*-aix5.1*] 
	     || [istarget powerpc*-*-aix5.2*] } {
	    return 0
	}
	return [check_no_compiler_messages powerpc_vsx_ok object {
	    int main (void) {
#ifdef __MACH__
		asm volatile ("xxlor vs0,vs0,vs0");
#else
		asm volatile ("xxlor 0,0,0");
#endif
		return 0;
	    }
	} "-mvsx"]
    } else {
	return 0
    }
}

# Return 1 if this is a PowerPC target supporting -mcpu=cell.

proc check_effective_target_powerpc_ppu_ok { } {
    if [check_effective_target_powerpc_altivec_ok] {
	return [check_no_compiler_messages cell_asm_available object {
	    int main (void) {
#ifdef __MACH__
		asm volatile ("lvlx v0,v0,v0");
#else
		asm volatile ("lvlx 0,0,0");
#endif
		return 0;
	    }
	}]
    } else {
	return 0
    }
}

# Return 1 if this is a PowerPC target that supports SPU.

proc check_effective_target_powerpc_spu { } {
    if [istarget powerpc*-*-linux*] {
	return [check_effective_target_powerpc_altivec_ok]
    } else {
	return 0
    }
}

# Return 1 if this is a PowerPC SPE target.  The check includes options
# specified by dg-options for this test, so don't cache the result.

proc check_effective_target_powerpc_spe_nocache { } {
    if { [istarget powerpc*-*-*] } {
	return [check_no_compiler_messages_nocache powerpc_spe object {
	    #ifndef __SPE__
	    #error not SPE
	    #else
	    int dummy;
	    #endif
	} [current_compiler_flags]]
    } else {
	return 0
    }
}

# Return 1 if this is a PowerPC target with SPE enabled.

proc check_effective_target_powerpc_spe { } {
    if { [istarget powerpc*-*-*] } {
	return [check_no_compiler_messages powerpc_spe object {
	    #ifndef __SPE__
	    #error not SPE
	    #else
	    int dummy;
	    #endif
	}]
    } else {
	return 0
    }
}

# Return 1 if this is a PowerPC target with Altivec enabled.

proc check_effective_target_powerpc_altivec { } {
    if { [istarget powerpc*-*-*] } {
	return [check_no_compiler_messages powerpc_altivec object {
	    #ifndef __ALTIVEC__
	    #error not Altivec
	    #else
	    int dummy;
	    #endif
	}]
    } else {
	return 0
    }
}

# Return 1 if this is a PowerPC 405 target.  The check includes options
# specified by dg-options for this test, so don't cache the result.

proc check_effective_target_powerpc_405_nocache { } {
    if { [istarget powerpc*-*-*] || [istarget rs6000-*-*] } {
	return [check_no_compiler_messages_nocache powerpc_405 object {
	    #ifdef __PPC405__
	    int dummy;
	    #else
	    #error not a PPC405
	    #endif
	} [current_compiler_flags]]
    } else {
	return 0
    }
}

# Return 1 if this is a SPU target with a toolchain that
# supports automatic overlay generation.

proc check_effective_target_spu_auto_overlay { } {
    if { [istarget spu*-*-elf*] } {
	return [check_no_compiler_messages spu_auto_overlay executable {
		int main (void) { }
		} "-Wl,--auto-overlay" ]
    } else {
	return 0
    }
}

# The VxWorks SPARC simulator accepts only EM_SPARC executables and
# chokes on EM_SPARC32PLUS or EM_SPARCV9 executables.  Return 1 if the
# test environment appears to run executables on such a simulator.

proc check_effective_target_ultrasparc_hw { } {
    return [check_runtime ultrasparc_hw {
	int main() { return 0; }
    } "-mcpu=ultrasparc"]
}

# Return 1 if the target supports hardware vector shift operation.

proc check_effective_target_vect_shift { } {
    global et_vect_shift_saved

    if [info exists et_vect_shift_saved] {
	verbose "check_effective_target_vect_shift: using cached result" 2
    } else {
	set et_vect_shift_saved 0
	if { ([istarget powerpc*-*-*]
             && ![istarget powerpc-*-linux*paired*])
	     || [istarget ia64-*-*]
	     || [istarget i?86-*-*]
	     || [istarget x86_64-*-*]
	     || [check_effective_target_arm32]
	     || ([istarget mips*-*-*]
		 && [check_effective_target_mips_loongson]) } {
	   set et_vect_shift_saved 1
	}
    }

    verbose "check_effective_target_vect_shift: returning $et_vect_shift_saved" 2
    return $et_vect_shift_saved
}

# Return 1 if the target supports hardware vectors of long, 0 otherwise.
#
# This can change for different subtargets so do not cache the result.

proc check_effective_target_vect_long { } {
    if { [istarget i?86-*-*]
	 || (([istarget powerpc*-*-*] 
              && ![istarget powerpc-*-linux*paired*]) 
              && [check_effective_target_ilp32])
	 || [istarget x86_64-*-*]
	 || [check_effective_target_arm32]
	 || ([istarget sparc*-*-*] && [check_effective_target_ilp32]) } {
	set answer 1
    } else {
	set answer 0
    }

    verbose "check_effective_target_vect_long: returning $answer" 2
    return $answer
}

# Return 1 if the target supports hardware vectors of float, 0 otherwise.
#
# This won't change for different subtargets so cache the result.

proc check_effective_target_vect_float { } {
    global et_vect_float_saved

    if [info exists et_vect_float_saved] {
	verbose "check_effective_target_vect_float: using cached result" 2
    } else {
	set et_vect_float_saved 0
	if { [istarget i?86-*-*]
	      || [istarget powerpc*-*-*]
	      || [istarget spu-*-*]
	      || [istarget mipsisa64*-*-*]
	      || [istarget x86_64-*-*]
	      || [istarget ia64-*-*]
	      || [check_effective_target_arm32] } {
	   set et_vect_float_saved 1
	}
    }

    verbose "check_effective_target_vect_float: returning $et_vect_float_saved" 2
    return $et_vect_float_saved
}

# Return 1 if the target supports hardware vectors of double, 0 otherwise.
#
# This won't change for different subtargets so cache the result.

proc check_effective_target_vect_double { } {
    global et_vect_double_saved

    if [info exists et_vect_double_saved] {
	verbose "check_effective_target_vect_double: using cached result" 2
    } else {
	set et_vect_double_saved 0
	if { [istarget i?86-*-*]
	      || [istarget x86_64-*-*] } {
	   if { [check_no_compiler_messages vect_double assembly {
		 #ifdef __tune_atom__
		 # error No double vectorizer support.
		 #endif
		}] } {
		set et_vect_double_saved 1
	    } else {
		set et_vect_double_saved 0
	    }
	} elseif { [istarget spu-*-*] } {
	   set et_vect_double_saved 1
	}
    }

    verbose "check_effective_target_vect_double: returning $et_vect_double_saved" 2
    return $et_vect_double_saved
}

# Return 1 if the target supports hardware vectors of long long, 0 otherwise.
#
# This won't change for different subtargets so cache the result.

proc check_effective_target_vect_long_long { } {
    global et_vect_long_long_saved

    if [info exists et_vect_long_long_saved] {
        verbose "check_effective_target_vect_long_long: using cached result" 2
    } else {
        set et_vect_long_long_saved 0
        if { [istarget i?86-*-*]
              || [istarget x86_64-*-*] } {
           set et_vect_long_long_saved 1
        }
    }

    verbose "check_effective_target_vect_long_long: returning $et_vect_long_long_saved" 2
    return $et_vect_long_long_saved
}


# Return 1 if the target plus current options does not support a vector
# max instruction on "int", 0 otherwise.
#
# This won't change for different subtargets so cache the result.

proc check_effective_target_vect_no_int_max { } {
    global et_vect_no_int_max_saved

    if [info exists et_vect_no_int_max_saved] {
	verbose "check_effective_target_vect_no_int_max: using cached result" 2
    } else {
	set et_vect_no_int_max_saved 0
	if { [istarget sparc*-*-*]
	     || [istarget spu-*-*]
	     || [istarget alpha*-*-*]
	     || ([istarget mips*-*-*]
		 && [check_effective_target_mips_loongson]) } {
	    set et_vect_no_int_max_saved 1
	}
    }
    verbose "check_effective_target_vect_no_int_max: returning $et_vect_no_int_max_saved" 2
    return $et_vect_no_int_max_saved
}

# Return 1 if the target plus current options does not support a vector
# add instruction on "int", 0 otherwise.
#
# This won't change for different subtargets so cache the result.

proc check_effective_target_vect_no_int_add { } {
    global et_vect_no_int_add_saved

    if [info exists et_vect_no_int_add_saved] {
	verbose "check_effective_target_vect_no_int_add: using cached result" 2
    } else {
	set et_vect_no_int_add_saved 0
	# Alpha only supports vector add on V8QI and V4HI.
	if { [istarget alpha*-*-*] } {
	    set et_vect_no_int_add_saved 1
	}
    }
    verbose "check_effective_target_vect_no_int_add: returning $et_vect_no_int_add_saved" 2
    return $et_vect_no_int_add_saved
}

# Return 1 if the target plus current options does not support vector
# bitwise instructions, 0 otherwise.
#
# This won't change for different subtargets so cache the result.

proc check_effective_target_vect_no_bitwise { } {
    global et_vect_no_bitwise_saved

    if [info exists et_vect_no_bitwise_saved] {
	verbose "check_effective_target_vect_no_bitwise: using cached result" 2
    } else {
	set et_vect_no_bitwise_saved 0
    }
    verbose "check_effective_target_vect_no_bitwise: returning $et_vect_no_bitwise_saved" 2
    return $et_vect_no_bitwise_saved
}

# Return 1 if the target plus current options supports vector permutation,
# 0 otherwise.
#
# This won't change for different subtargets so cache the result.

proc check_effective_target_vect_perm { } {
    global et_vect_perm

    if [info exists et_vect_perm_saved] {
        verbose "check_effective_target_vect_perm: using cached result" 2
    } else {
        set et_vect_perm_saved 0
        if { [istarget powerpc*-*-*]
             || [istarget spu-*-*]
	     || [istarget i?86-*-*]
	     || [istarget x86_64-*-*] } {
            set et_vect_perm_saved 1
        }
    }
    verbose "check_effective_target_vect_perm: returning $et_vect_perm_saved" 2
    return $et_vect_perm_saved
}

# Return 1 if the target plus current options supports vector permutation
# on byte-sized elements, 0 otherwise.
#
# This won't change for different subtargets so cache the result.

proc check_effective_target_vect_perm_byte { } {
    global et_vect_perm_byte

    if [info exists et_vect_perm_byte_saved] {
        verbose "check_effective_target_vect_perm_byte: using cached result" 2
    } else {
        set et_vect_perm_byte_saved 0
        if { [istarget powerpc*-*-*]
             || [istarget spu-*-*] } {
            set et_vect_perm_byte_saved 1
        }
    }
    verbose "check_effective_target_vect_perm_byte: returning $et_vect_perm_byte_saved" 2
    return $et_vect_perm_byte_saved
}

# Return 1 if the target plus current options supports vector permutation
# on short-sized elements, 0 otherwise.
#
# This won't change for different subtargets so cache the result.

proc check_effective_target_vect_perm_short { } {
    global et_vect_perm_short

    if [info exists et_vect_perm_short_saved] {
        verbose "check_effective_target_vect_perm_short: using cached result" 2
    } else {
        set et_vect_perm_short_saved 0
        if { [istarget powerpc*-*-*]
             || [istarget spu-*-*] } {
            set et_vect_perm_short_saved 1
        }
    }
    verbose "check_effective_target_vect_perm_short: returning $et_vect_perm_short_saved" 2
    return $et_vect_perm_short_saved
}

# Return 1 if the target plus current options supports a vector
# widening summation of *short* args into *int* result, 0 otherwise.
#
# This won't change for different subtargets so cache the result.

proc check_effective_target_vect_widen_sum_hi_to_si_pattern { } {
    global et_vect_widen_sum_hi_to_si_pattern

    if [info exists et_vect_widen_sum_hi_to_si_pattern_saved] {
        verbose "check_effective_target_vect_widen_sum_hi_to_si_pattern: using cached result" 2
    } else {
        set et_vect_widen_sum_hi_to_si_pattern_saved 0
        if { [istarget powerpc*-*-*] } {
            set et_vect_widen_sum_hi_to_si_pattern_saved 1
        }
    }
    verbose "check_effective_target_vect_widen_sum_hi_to_si_pattern: returning $et_vect_widen_sum_hi_to_si_pattern_saved" 2
    return $et_vect_widen_sum_hi_to_si_pattern_saved
}

# Return 1 if the target plus current options supports a vector
# widening summation of *short* args into *int* result, 0 otherwise.
# A target can also support this widening summation if it can support
# promotion (unpacking) from shorts to ints.
#
# This won't change for different subtargets so cache the result.
                                                                                                
proc check_effective_target_vect_widen_sum_hi_to_si { } {
    global et_vect_widen_sum_hi_to_si

    if [info exists et_vect_widen_sum_hi_to_si_saved] {
        verbose "check_effective_target_vect_widen_sum_hi_to_si: using cached result" 2
    } else {
        set et_vect_widen_sum_hi_to_si_saved [check_effective_target_vect_unpack]
        if { [istarget powerpc*-*-*] 
	     || [istarget ia64-*-*] } {
            set et_vect_widen_sum_hi_to_si_saved 1
        }
    }
    verbose "check_effective_target_vect_widen_sum_hi_to_si: returning $et_vect_widen_sum_hi_to_si_saved" 2
    return $et_vect_widen_sum_hi_to_si_saved
}

# Return 1 if the target plus current options supports a vector
# widening summation of *char* args into *short* result, 0 otherwise.
# A target can also support this widening summation if it can support
# promotion (unpacking) from chars to shorts.
#
# This won't change for different subtargets so cache the result.
                                                                                                
proc check_effective_target_vect_widen_sum_qi_to_hi { } {
    global et_vect_widen_sum_qi_to_hi

    if [info exists et_vect_widen_sum_qi_to_hi_saved] {
        verbose "check_effective_target_vect_widen_sum_qi_to_hi: using cached result" 2
    } else {
        set et_vect_widen_sum_qi_to_hi_saved 0
	if { [check_effective_target_vect_unpack] 
	     || [istarget ia64-*-*] } {
            set et_vect_widen_sum_qi_to_hi_saved 1
	}
    }
    verbose "check_effective_target_vect_widen_sum_qi_to_hi: returning $et_vect_widen_sum_qi_to_hi_saved" 2
    return $et_vect_widen_sum_qi_to_hi_saved
}

# Return 1 if the target plus current options supports a vector
# widening summation of *char* args into *int* result, 0 otherwise.
#
# This won't change for different subtargets so cache the result.
                                                                                                
proc check_effective_target_vect_widen_sum_qi_to_si { } {
    global et_vect_widen_sum_qi_to_si

    if [info exists et_vect_widen_sum_qi_to_si_saved] {
        verbose "check_effective_target_vect_widen_sum_qi_to_si: using cached result" 2
    } else {
        set et_vect_widen_sum_qi_to_si_saved 0
        if { [istarget powerpc*-*-*] } {
            set et_vect_widen_sum_qi_to_si_saved 1
        }
    }
    verbose "check_effective_target_vect_widen_sum_qi_to_si: returning $et_vect_widen_sum_qi_to_si_saved" 2
    return $et_vect_widen_sum_qi_to_si_saved
}

# Return 1 if the target plus current options supports a vector
# widening multiplication of *char* args into *short* result, 0 otherwise.
# A target can also support this widening multplication if it can support
# promotion (unpacking) from chars to shorts, and vect_short_mult (non-widening
# multiplication of shorts).
#
# This won't change for different subtargets so cache the result.


proc check_effective_target_vect_widen_mult_qi_to_hi { } {
    global et_vect_widen_mult_qi_to_hi

    if [info exists et_vect_widen_mult_qi_to_hi_saved] {
        verbose "check_effective_target_vect_widen_mult_qi_to_hi: using cached result" 2
    } else {
	if { [check_effective_target_vect_unpack]
	     && [check_effective_target_vect_short_mult] } {
	    set et_vect_widen_mult_qi_to_hi_saved 1
	} else {
	    set et_vect_widen_mult_qi_to_hi_saved 0
	}
        if { [istarget powerpc*-*-*] } {
            set et_vect_widen_mult_qi_to_hi_saved 1
        }
    }
    verbose "check_effective_target_vect_widen_mult_qi_to_hi: returning $et_vect_widen_mult_qi_to_hi_saved" 2
    return $et_vect_widen_mult_qi_to_hi_saved
}

# Return 1 if the target plus current options supports a vector
# widening multiplication of *short* args into *int* result, 0 otherwise.
# A target can also support this widening multplication if it can support
# promotion (unpacking) from shorts to ints, and vect_int_mult (non-widening
# multiplication of ints).
#
# This won't change for different subtargets so cache the result.


proc check_effective_target_vect_widen_mult_hi_to_si { } {
    global et_vect_widen_mult_hi_to_si

    if [info exists et_vect_widen_mult_hi_to_si_saved] {
        verbose "check_effective_target_vect_widen_mult_hi_to_si: using cached result" 2
    } else {
        if { [check_effective_target_vect_unpack]
             && [check_effective_target_vect_int_mult] } {
          set et_vect_widen_mult_hi_to_si_saved 1
        } else {
          set et_vect_widen_mult_hi_to_si_saved 0
        }
        if { [istarget powerpc*-*-*]
	      || [istarget spu-*-*]
	      || [istarget i?86-*-*]
	      || [istarget x86_64-*-*] } {
            set et_vect_widen_mult_hi_to_si_saved 1
        }
    }
    verbose "check_effective_target_vect_widen_mult_hi_to_si: returning $et_vect_widen_mult_hi_to_si_saved" 2
    return $et_vect_widen_mult_hi_to_si_saved
}

# Return 1 if the target plus current options supports a vector
# dot-product of signed chars, 0 otherwise.
#
# This won't change for different subtargets so cache the result.

proc check_effective_target_vect_sdot_qi { } {
    global et_vect_sdot_qi

    if [info exists et_vect_sdot_qi_saved] {
        verbose "check_effective_target_vect_sdot_qi: using cached result" 2
    } else {
        set et_vect_sdot_qi_saved 0
    }
    verbose "check_effective_target_vect_sdot_qi: returning $et_vect_sdot_qi_saved" 2
    return $et_vect_sdot_qi_saved
}

# Return 1 if the target plus current options supports a vector
# dot-product of unsigned chars, 0 otherwise.
#
# This won't change for different subtargets so cache the result.

proc check_effective_target_vect_udot_qi { } {
    global et_vect_udot_qi

    if [info exists et_vect_udot_qi_saved] {
        verbose "check_effective_target_vect_udot_qi: using cached result" 2
    } else {
        set et_vect_udot_qi_saved 0
        if { [istarget powerpc*-*-*] } {
            set et_vect_udot_qi_saved 1
        }
    }
    verbose "check_effective_target_vect_udot_qi: returning $et_vect_udot_qi_saved" 2
    return $et_vect_udot_qi_saved
}

# Return 1 if the target plus current options supports a vector
# dot-product of signed shorts, 0 otherwise.
#
# This won't change for different subtargets so cache the result.

proc check_effective_target_vect_sdot_hi { } {
    global et_vect_sdot_hi

    if [info exists et_vect_sdot_hi_saved] {
        verbose "check_effective_target_vect_sdot_hi: using cached result" 2
    } else {
        set et_vect_sdot_hi_saved 0
        if { ([istarget powerpc*-*-*] && ![istarget powerpc-*-linux*paired*])
	     || [istarget i?86-*-*]
             || [istarget x86_64-*-*] } {
            set et_vect_sdot_hi_saved 1
        }
    }
    verbose "check_effective_target_vect_sdot_hi: returning $et_vect_sdot_hi_saved" 2
    return $et_vect_sdot_hi_saved
}

# Return 1 if the target plus current options supports a vector
# dot-product of unsigned shorts, 0 otherwise.
#
# This won't change for different subtargets so cache the result.

proc check_effective_target_vect_udot_hi { } {
    global et_vect_udot_hi

    if [info exists et_vect_udot_hi_saved] {
        verbose "check_effective_target_vect_udot_hi: using cached result" 2
    } else {
        set et_vect_udot_hi_saved 0
        if { ([istarget powerpc*-*-*] && ![istarget powerpc-*-linux*paired*]) } {
            set et_vect_udot_hi_saved 1
        }
    }
    verbose "check_effective_target_vect_udot_hi: returning $et_vect_udot_hi_saved" 2
    return $et_vect_udot_hi_saved
}


# Return 1 if the target plus current options supports a vector
# demotion (packing) of shorts (to chars) and ints (to shorts) 
# using modulo arithmetic, 0 otherwise.
#
# This won't change for different subtargets so cache the result.
                                                                                
proc check_effective_target_vect_pack_trunc { } {
    global et_vect_pack_trunc
                                                                                
    if [info exists et_vect_pack_trunc_saved] {
        verbose "check_effective_target_vect_pack_trunc: using cached result" 2
    } else {
        set et_vect_pack_trunc_saved 0
        if { ([istarget powerpc*-*-*] && ![istarget powerpc-*-linux*paired*])
             || [istarget i?86-*-*]
             || [istarget x86_64-*-*]
             || [istarget spu-*-*]
             || ([istarget arm*-*-*] && [check_effective_target_arm_neon]) } {
            set et_vect_pack_trunc_saved 1
        }
    }
    verbose "check_effective_target_vect_pack_trunc: returning $et_vect_pack_trunc_saved" 2
    return $et_vect_pack_trunc_saved
}

# Return 1 if the target plus current options supports a vector
# promotion (unpacking) of chars (to shorts) and shorts (to ints), 0 otherwise.
#
# This won't change for different subtargets so cache the result.
                                   
proc check_effective_target_vect_unpack { } {
    global et_vect_unpack
                                        
    if [info exists et_vect_unpack_saved] {
        verbose "check_effective_target_vect_unpack: using cached result" 2
    } else {
        set et_vect_unpack_saved 0
        if { ([istarget powerpc*-*-*] && ![istarget powerpc-*paired*])
             || [istarget i?86-*-*]
             || [istarget x86_64-*-*] 
             || [istarget spu-*-*]
             || ([istarget arm*-*-*] && [check_effective_target_arm_neon]) } {
            set et_vect_unpack_saved 1
        }
    }
    verbose "check_effective_target_vect_unpack: returning $et_vect_unpack_saved" 2  
    return $et_vect_unpack_saved
}

# Return 1 if the target plus current options does not guarantee
# that its STACK_BOUNDARY is >= the reguired vector alignment.
#
# This won't change for different subtargets so cache the result.

proc check_effective_target_unaligned_stack { } {
    global et_unaligned_stack_saved

    if [info exists et_unaligned_stack_saved] {
        verbose "check_effective_target_unaligned_stack: using cached result" 2
    } else {
        set et_unaligned_stack_saved 0
    }
    verbose "check_effective_target_unaligned_stack: returning $et_unaligned_stack_saved" 2
    return $et_unaligned_stack_saved
}

# Return 1 if the target plus current options does not support a vector
# alignment mechanism, 0 otherwise.
#
# This won't change for different subtargets so cache the result.

proc check_effective_target_vect_no_align { } {
    global et_vect_no_align_saved

    if [info exists et_vect_no_align_saved] {
	verbose "check_effective_target_vect_no_align: using cached result" 2
    } else {
	set et_vect_no_align_saved 0
	if { [istarget mipsisa64*-*-*]
	     || [istarget sparc*-*-*]
	     || [istarget ia64-*-*]
	     || [check_effective_target_arm32]
	     || ([istarget mips*-*-*]
		 && [check_effective_target_mips_loongson]) } {
	    set et_vect_no_align_saved 1
	}
    }
    verbose "check_effective_target_vect_no_align: returning $et_vect_no_align_saved" 2
    return $et_vect_no_align_saved
}

# Return 1 if the target supports a vector misalign access, 0 otherwise.
#
# This won't change for different subtargets so cache the result.

proc check_effective_target_vect_hw_misalign { } {
    global et_vect_hw_misalign_saved

    if [info exists et_vect_hw_misalign_saved] {
        verbose "check_effective_target_vect_hw_misalign: using cached result" 2
    } else {
        set et_vect_hw_misalign_saved 0
       if { ([istarget x86_64-*-*] 
            || [istarget i?86-*-*]) } {
          set et_vect_hw_misalign_saved 1
       }
    }
    verbose "check_effective_target_vect_hw_misalign: returning $et_vect_hw_misalign_saved" 2
    return $et_vect_hw_misalign_saved
}


# Return 1 if arrays are aligned to the vector alignment
# boundary, 0 otherwise.
#
# This won't change for different subtargets so cache the result.

proc check_effective_target_vect_aligned_arrays { } {
    global et_vect_aligned_arrays

    if [info exists et_vect_aligned_arrays_saved] {
	verbose "check_effective_target_vect_aligned_arrays: using cached result" 2
    } else {
	set et_vect_aligned_arrays_saved 0
        if { (([istarget x86_64-*-*]
              || [istarget i?86-*-*]) && [is-effective-target lp64])
              || [istarget spu-*-*] } {
	    set et_vect_aligned_arrays_saved 1
	}
    }
    verbose "check_effective_target_vect_aligned_arrays: returning $et_vect_aligned_arrays_saved" 2
    return $et_vect_aligned_arrays_saved
}

# Return 1 if types of size 32 bit or less are naturally aligned
# (aligned to their type-size), 0 otherwise.
#
# This won't change for different subtargets so cache the result.

proc check_effective_target_natural_alignment_32 { } {
    global et_natural_alignment_32

    if [info exists et_natural_alignment_32_saved] {
        verbose "check_effective_target_natural_alignment_32: using cached result" 2
    } else {
        # FIXME: 32bit powerpc: guaranteed only if MASK_ALIGN_NATURAL/POWER.
        set et_natural_alignment_32_saved 1
        if { ([istarget *-*-darwin*] && [is-effective-target lp64]) } {
            set et_natural_alignment_32_saved 0
        }
    }
    verbose "check_effective_target_natural_alignment_32: returning $et_natural_alignment_32_saved" 2
    return $et_natural_alignment_32_saved
}

# Return 1 if types of size 64 bit or less are naturally aligned (aligned to their
# type-size), 0 otherwise.
#
# This won't change for different subtargets so cache the result.

proc check_effective_target_natural_alignment_64 { } {
    global et_natural_alignment_64

    if [info exists et_natural_alignment_64_saved] {
        verbose "check_effective_target_natural_alignment_64: using cached result" 2
    } else {
        set et_natural_alignment_64_saved 0
        if { ([is-effective-target lp64] && ![istarget *-*-darwin*])
             || [istarget spu-*-*] } {
            set et_natural_alignment_64_saved 1
        }
    }
    verbose "check_effective_target_natural_alignment_64: returning $et_natural_alignment_64_saved" 2
    return $et_natural_alignment_64_saved
}

# Return 1 if vector alignment (for types of size 32 bit or less) is reachable, 0 otherwise.
#
# This won't change for different subtargets so cache the result.

proc check_effective_target_vector_alignment_reachable { } {
    global et_vector_alignment_reachable

    if [info exists et_vector_alignment_reachable_saved] {
        verbose "check_effective_target_vector_alignment_reachable: using cached result" 2
    } else {
        if { [check_effective_target_vect_aligned_arrays]
             || [check_effective_target_natural_alignment_32] } {
            set et_vector_alignment_reachable_saved 1
        } else {
            set et_vector_alignment_reachable_saved 0
        }
    }
    verbose "check_effective_target_vector_alignment_reachable: returning $et_vector_alignment_reachable_saved" 2
    return $et_vector_alignment_reachable_saved
}

# Return 1 if vector alignment for 64 bit is reachable, 0 otherwise.
#
# This won't change for different subtargets so cache the result.

proc check_effective_target_vector_alignment_reachable_for_64bit { } {
    global et_vector_alignment_reachable_for_64bit

    if [info exists et_vector_alignment_reachable_for_64bit_saved] {
        verbose "check_effective_target_vector_alignment_reachable_for_64bit: using cached result" 2
    } else {
        if { [check_effective_target_vect_aligned_arrays] 
             || [check_effective_target_natural_alignment_64] } {
            set et_vector_alignment_reachable_for_64bit_saved 1
        } else {
            set et_vector_alignment_reachable_for_64bit_saved 0
        }
    }
    verbose "check_effective_target_vector_alignment_reachable_for_64bit: returning $et_vector_alignment_reachable_for_64bit_saved" 2
    return $et_vector_alignment_reachable_for_64bit_saved
}

# Return 1 if the target supports vector conditional operations, 0 otherwise.

proc check_effective_target_vect_condition { } {
    global et_vect_cond_saved

    if [info exists et_vect_cond_saved] {
	verbose "check_effective_target_vect_cond: using cached result" 2
    } else {
	set et_vect_cond_saved 0
	if { [istarget powerpc*-*-*]
	     || [istarget ia64-*-*]
	     || [istarget i?86-*-*]
	     || [istarget spu-*-*]
	     || [istarget x86_64-*-*] } {
	   set et_vect_cond_saved 1
	}
    }

    verbose "check_effective_target_vect_cond: returning $et_vect_cond_saved" 2
    return $et_vect_cond_saved
}

# Return 1 if the target supports vector char multiplication, 0 otherwise.

proc check_effective_target_vect_char_mult { } {
    global et_vect_char_mult_saved

    if [info exists et_vect_char_mult_saved] {
	verbose "check_effective_target_vect_char_mult: using cached result" 2
    } else {
	set et_vect_char_mult_saved 0
	if { [istarget ia64-*-*]
	     || [istarget i?86-*-*]
	     || [istarget x86_64-*-*] } {
	   set et_vect_char_mult_saved 1
	}
    }

    verbose "check_effective_target_vect_char_mult: returning $et_vect_char_mult_saved" 2
    return $et_vect_char_mult_saved
}

# Return 1 if the target supports vector short multiplication, 0 otherwise.

proc check_effective_target_vect_short_mult { } {
    global et_vect_short_mult_saved

    if [info exists et_vect_short_mult_saved] {
	verbose "check_effective_target_vect_short_mult: using cached result" 2
    } else {
	set et_vect_short_mult_saved 0
	if { [istarget ia64-*-*]
	     || [istarget spu-*-*]
	     || [istarget i?86-*-*]
	     || [istarget x86_64-*-*]
	     || [istarget powerpc*-*-*]
	     || [check_effective_target_arm32]
	     || ([istarget mips*-*-*]
		 && [check_effective_target_mips_loongson]) } {
	   set et_vect_short_mult_saved 1
	}
    }

    verbose "check_effective_target_vect_short_mult: returning $et_vect_short_mult_saved" 2
    return $et_vect_short_mult_saved
}

# Return 1 if the target supports vector int multiplication, 0 otherwise.

proc check_effective_target_vect_int_mult { } {
    global et_vect_int_mult_saved

    if [info exists et_vect_int_mult_saved] {
	verbose "check_effective_target_vect_int_mult: using cached result" 2
    } else {
	set et_vect_int_mult_saved 0
	if { ([istarget powerpc*-*-*] && ![istarget powerpc-*-linux*paired*])
	     || [istarget spu-*-*]
	     || [istarget i?86-*-*]
	     || [istarget x86_64-*-*]
	     || [check_effective_target_arm32] } {
	   set et_vect_int_mult_saved 1
	}
    }

    verbose "check_effective_target_vect_int_mult: returning $et_vect_int_mult_saved" 2
    return $et_vect_int_mult_saved
}

# Return 1 if the target supports vector even/odd elements extraction, 0 otherwise.

proc check_effective_target_vect_extract_even_odd { } {
    global et_vect_extract_even_odd_saved
    
    if [info exists et_vect_extract_even_odd_saved] {
        verbose "check_effective_target_vect_extract_even_odd: using cached result" 2
    } else {
        set et_vect_extract_even_odd_saved 0 
        if { [istarget powerpc*-*-*] 
             || [istarget i?86-*-*]
             || [istarget x86_64-*-*]
             || [istarget spu-*-*] } {
           set et_vect_extract_even_odd_saved 1
        }
    }

    verbose "check_effective_target_vect_extract_even_odd: returning $et_vect_extract_even_odd_saved" 2
    return $et_vect_extract_even_odd_saved
}

# Return 1 if the target supports vector even/odd elements extraction of
# vectors with SImode elements or larger, 0 otherwise.

proc check_effective_target_vect_extract_even_odd_wide { } {
    global et_vect_extract_even_odd_wide_saved
    
    if [info exists et_vect_extract_even_odd_wide_saved] {
        verbose "check_effective_target_vect_extract_even_odd_wide: using cached result" 2
    } else {
        set et_vect_extract_even_odd_wide_saved 0 
        if { [istarget powerpc*-*-*] 
             || [istarget i?86-*-*]
             || [istarget x86_64-*-*]
             || [istarget spu-*-*] } {
           set et_vect_extract_even_odd_wide_saved 1
        }
    }

    verbose "check_effective_target_vect_extract_even_wide_odd: returning $et_vect_extract_even_odd_wide_saved" 2
    return $et_vect_extract_even_odd_wide_saved
}

# Return 1 if the target supports vector interleaving, 0 otherwise.

proc check_effective_target_vect_interleave { } {
    global et_vect_interleave_saved
    
    if [info exists et_vect_interleave_saved] {
        verbose "check_effective_target_vect_interleave: using cached result" 2
    } else {
        set et_vect_interleave_saved 0
        if { [istarget powerpc*-*-*]
             || [istarget i?86-*-*]
             || [istarget x86_64-*-*]
             || [istarget spu-*-*] } {
           set et_vect_interleave_saved 1
        }
    }

    verbose "check_effective_target_vect_interleave: returning $et_vect_interleave_saved" 2
    return $et_vect_interleave_saved
}

# Return 1 if the target supports vector interleaving and extract even/odd, 0 otherwise.
proc check_effective_target_vect_strided { } {
    global et_vect_strided_saved

    if [info exists et_vect_strided_saved] {
        verbose "check_effective_target_vect_strided: using cached result" 2
    } else {
        set et_vect_strided_saved 0
        if { [check_effective_target_vect_interleave]
             && [check_effective_target_vect_extract_even_odd] } {
           set et_vect_strided_saved 1
        }
    }

    verbose "check_effective_target_vect_strided: returning $et_vect_strided_saved" 2
    return $et_vect_strided_saved
}

# Return 1 if the target supports vector interleaving and extract even/odd
# for wide element types, 0 otherwise.
proc check_effective_target_vect_strided_wide { } {
    global et_vect_strided_wide_saved

    if [info exists et_vect_strided_wide_saved] {
        verbose "check_effective_target_vect_strided_wide: using cached result" 2
    } else {
        set et_vect_strided_wide_saved 0
        if { [check_effective_target_vect_interleave]
             && [check_effective_target_vect_extract_even_odd_wide] } {
           set et_vect_strided_wide_saved 1
        }
    }

    verbose "check_effective_target_vect_strided_wide: returning $et_vect_strided_wide_saved" 2
    return $et_vect_strided_wide_saved
}

# Return 1 if the target supports section-anchors

proc check_effective_target_section_anchors { } {
    global et_section_anchors_saved

    if [info exists et_section_anchors_saved] {
        verbose "check_effective_target_section_anchors: using cached result" 2
    } else {
        set et_section_anchors_saved 0
        if { [istarget powerpc*-*-*]
	      || [istarget arm*-*-*] } {
           set et_section_anchors_saved 1
        }
    }

    verbose "check_effective_target_section_anchors: returning $et_section_anchors_saved" 2
    return $et_section_anchors_saved
}

# Return 1 if the target supports atomic operations on "int" and "long".

proc check_effective_target_sync_int_long { } {
    global et_sync_int_long_saved

    if [info exists et_sync_int_long_saved] {
        verbose "check_effective_target_sync_int_long: using cached result" 2
    } else {
        set et_sync_int_long_saved 0
# This is intentionally powerpc but not rs6000, rs6000 doesn't have the
# load-reserved/store-conditional instructions.
        if { [istarget ia64-*-*]
	     || [istarget i?86-*-*]
	     || [istarget x86_64-*-*]
	     || [istarget alpha*-*-*] 
	     || [istarget arm*-*-linux-gnueabi] 
	     || [istarget bfin*-*linux*]
	     || [istarget hppa*-*linux*]
	     || [istarget s390*-*-*] 
	     || [istarget powerpc*-*-*]
	     || [istarget sparc64-*-*]
	     || [istarget sparcv9-*-*]
	     || [istarget mips*-*-*] } {
           set et_sync_int_long_saved 1
        }
    }

    verbose "check_effective_target_sync_int_long: returning $et_sync_int_long_saved" 2
    return $et_sync_int_long_saved
}

# Return 1 if the target supports atomic operations on "char" and "short".

proc check_effective_target_sync_char_short { } {
    global et_sync_char_short_saved

    if [info exists et_sync_char_short_saved] {
        verbose "check_effective_target_sync_char_short: using cached result" 2
    } else {
        set et_sync_char_short_saved 0
# This is intentionally powerpc but not rs6000, rs6000 doesn't have the
# load-reserved/store-conditional instructions.
        if { [istarget ia64-*-*]
	     || [istarget i?86-*-*]
	     || [istarget x86_64-*-*]
	     || [istarget alpha*-*-*] 
	     || [istarget arm*-*-linux-gnueabi] 
	     || [istarget hppa*-*linux*]
	     || [istarget s390*-*-*] 
	     || [istarget powerpc*-*-*]
	     || [istarget sparc64-*-*]
	     || [istarget sparcv9-*-*]
	     || [istarget mips*-*-*] } {
           set et_sync_char_short_saved 1
        }
    }

    verbose "check_effective_target_sync_char_short: returning $et_sync_char_short_saved" 2
    return $et_sync_char_short_saved
}

# Return 1 if the target uses a ColdFire FPU.

proc check_effective_target_coldfire_fpu { } {
    return [check_no_compiler_messages coldfire_fpu assembly {
	#ifndef __mcffpu__
	#error FOO
	#endif
    }]
}

# Return true if this is a uClibc target.

proc check_effective_target_uclibc {} {
    return [check_no_compiler_messages uclibc object {
	#include <features.h>
	#if !defined (__UCLIBC__)
	#error FOO
	#endif
    }]
}

# Return true if this is a uclibc target and if the uclibc feature
# described by __$feature__ is not present.

proc check_missing_uclibc_feature {feature} {
    return [check_no_compiler_messages $feature object "
	#include <features.h>
	#if !defined (__UCLIBC) || defined (__${feature}__)
	#error FOO
	#endif
    "]
}

# Return true if this is a Newlib target.

proc check_effective_target_newlib {} {
    return [check_no_compiler_messages newlib object {
	#include <newlib.h>
    }]
}

# Return 1 if
#   (a) an error of a few ULP is expected in string to floating-point
#       conversion functions; and
#   (b) overflow is not always detected correctly by those functions.

proc check_effective_target_lax_strtofp {} {
    # By default, assume that all uClibc targets suffer from this.
    return [check_effective_target_uclibc]
}

# Return 1 if this is a target for which wcsftime is a dummy
# function that always returns 0.

proc check_effective_target_dummy_wcsftime {} {
    # By default, assume that all uClibc targets suffer from this.
    return [check_effective_target_uclibc]
}

# Return 1 if constructors with initialization priority arguments are
# supposed on this target.

proc check_effective_target_init_priority {} {
    return [check_no_compiler_messages init_priority assembly "
	void f() __attribute__((constructor (1000)));
	void f() \{\}
    "]
}

# Return 1 if the target matches the effective target 'arg', 0 otherwise.
# This can be used with any check_* proc that takes no argument and
# returns only 1 or 0.  It could be used with check_* procs that take
# arguments with keywords that pass particular arguments.

proc is-effective-target { arg } {
    set selected 0
    if { [info procs check_effective_target_${arg}] != [list] } {
	set selected [check_effective_target_${arg}]
    } else {
	switch $arg {
	  "vmx_hw"         { set selected [check_vmx_hw_available] }
	  "vsx_hw"         { set selected [check_vsx_hw_available] }
	  "ppc_recip_hw"   { set selected [check_ppc_recip_hw_available] }
	  "named_sections" { set selected [check_named_sections_available] }
	  "gc_sections"    { set selected [check_gc_sections_available] }
	  "cxa_atexit"     { set selected [check_cxa_atexit_available] }
	  default          { error "unknown effective target keyword `$arg'" }
	}
    }
    verbose "is-effective-target: $arg $selected" 2
    return $selected
}

# Return 1 if the argument is an effective-target keyword, 0 otherwise.

proc is-effective-target-keyword { arg } {
    if { [info procs check_effective_target_${arg}] != [list] } {
	return 1
    } else {
	# These have different names for their check_* procs.
	switch $arg {
	  "vmx_hw"         { return 1 }
	  "vsx_hw"         { return 1 }
	  "ppc_recip_hw"   { return 1 }
	  "named_sections" { return 1 }
	  "gc_sections"    { return 1 }
	  "cxa_atexit"     { return 1 }
	  default          { return 0 }
	}
    }
}

# Return 1 if target default to short enums

proc check_effective_target_short_enums { } {
    return [check_no_compiler_messages short_enums assembly {
	enum foo { bar };
	int s[sizeof (enum foo) == 1 ? 1 : -1];
    }]
}

# Return 1 if target supports merging string constants at link time.

proc check_effective_target_string_merging { } {
    return [check_no_messages_and_pattern string_merging \
		"rodata\\.str" assembly {
		    const char *var = "String";
		} {-O2}]
}

# Return 1 if target has the basic signed and unsigned types in
# <stdint.h>, 0 otherwise.  This will be obsolete when GCC ensures a
# working <stdint.h> for all targets.

proc check_effective_target_stdint_types { } {
    return [check_no_compiler_messages stdint_types assembly {
	#include <stdint.h>
	int8_t a; int16_t b; int32_t c; int64_t d;
	uint8_t e; uint16_t f; uint32_t g; uint64_t h;
    }]
}

# Return 1 if target has the basic signed and unsigned types in
# <inttypes.h>, 0 otherwise.  This is for tests that GCC's notions of
# these types agree with those in the header, as some systems have
# only <inttypes.h>.

proc check_effective_target_inttypes_types { } {
    return [check_no_compiler_messages inttypes_types assembly {
	#include <inttypes.h>
	int8_t a; int16_t b; int32_t c; int64_t d;
	uint8_t e; uint16_t f; uint32_t g; uint64_t h;
    }]
}

# Return 1 if programs are intended to be run on a simulator
# (i.e. slowly) rather than hardware (i.e. fast).

proc check_effective_target_simulator { } {

    # All "src/sim" simulators set this one.
    if [board_info target exists is_simulator] {
	return [board_info target is_simulator]
    }

    # The "sid" simulators don't set that one, but at least they set
    # this one.
    if [board_info target exists slow_simulator] {
	return [board_info target slow_simulator]
    }

    return 0
}

# Return 1 if the target is a VxWorks kernel.

proc check_effective_target_vxworks_kernel { } {
    return [check_no_compiler_messages vxworks_kernel assembly {
	#if !defined __vxworks || defined __RTP__
	#error NO
	#endif
    }]
}

# Return 1 if the target is a VxWorks RTP.

proc check_effective_target_vxworks_rtp { } {
    return [check_no_compiler_messages vxworks_rtp assembly {
	#if !defined __vxworks || !defined __RTP__
	#error NO
	#endif
    }]
}

# Return 1 if the target is expected to provide wide character support.

proc check_effective_target_wchar { } {
    if {[check_missing_uclibc_feature UCLIBC_HAS_WCHAR]} {
	return 0
    }
    return [check_no_compiler_messages wchar assembly {
	#include <wchar.h>
    }]
}

# Return 1 if the target has <pthread.h>.

proc check_effective_target_pthread_h { } {
    return [check_no_compiler_messages pthread_h assembly {
	#include <pthread.h>
    }]
}

# Return 1 if the target can truncate a file from a file-descriptor,
# as used by libgfortran/io/unix.c:fd_truncate; i.e. ftruncate or
# chsize.  We test for a trivially functional truncation; no stubs.
# As libgfortran uses _FILE_OFFSET_BITS 64, we do too; it'll cause a
# different function to be used.

proc check_effective_target_fd_truncate { } {
    set prog {
	#define _FILE_OFFSET_BITS 64
	#include <unistd.h>
	#include <stdio.h>
	#include <stdlib.h>
	int main ()
	{
	  FILE *f = fopen ("tst.tmp", "wb");
	  int fd;
	  const char t[] = "test writing more than ten characters";
	  char s[11];
	  fd =  fileno (f);
	  write (fd, t, sizeof (t) - 1);
	  lseek (fd, 0, 0);
	  if (ftruncate (fd, 10) != 0)
	    exit (1);
	  close (fd);
	  f = fopen ("tst.tmp", "rb");
	  if (fread (s, 1, sizeof (s), f) != 10 || strncmp (s, t, 10) != 0)
	    exit (1);
	  exit (0);
	}
    }

    if { [check_runtime ftruncate $prog] } {
      return 1;
    }

    regsub "ftruncate" $prog "chsize" prog
    return [check_runtime chsize $prog]
}

# Add to FLAGS all the target-specific flags needed to access the c99 runtime.

proc add_options_for_c99_runtime { flags } {
    if { [istarget *-*-solaris2*] } {
	return "$flags -std=c99"
    }
    if { [istarget powerpc-*-darwin*] } {
	return "$flags -mmacosx-version-min=10.3"
    }
    return $flags
}

# Add to FLAGS all the target-specific flags needed to enable
# full IEEE compliance mode.

proc add_options_for_ieee { flags } {
    if { [istarget "alpha*-*-*"]
         || [istarget "sh*-*-*"] } {
       return "$flags -mieee"
    }
    return $flags
}

# Add to FLAGS the flags needed to enable functions to bind locally
# when using pic/PIC passes in the testsuite.

proc add_options_for_bind_pic_locally { flags } {
    if {[check_no_compiler_messages using_pic2 assembly {
        #if __PIC__ != 2
        #error FOO
        #endif
    }]} {
	return "$flags -fPIE"
    }
    if {[check_no_compiler_messages using_pic1 assembly {
        #if __PIC__ != 1
        #error FOO
        #endif
    }]} {
	return "$flags -fpie"
    }

    return $flags
}

# Return 1 if the target provides a full C99 runtime.

proc check_effective_target_c99_runtime { } {
    return [check_cached_effective_target c99_runtime {
	global srcdir

	set file [open "$srcdir/gcc.dg/builtins-config.h"]
	set contents [read $file]
	close $file
	append contents {
	    #ifndef HAVE_C99_RUNTIME
	    #error FOO
	    #endif
	}
	check_no_compiler_messages_nocache c99_runtime assembly \
	    $contents [add_options_for_c99_runtime ""]
    }]
}

# Return 1 if  target wchar_t is at least 4 bytes.

proc check_effective_target_4byte_wchar_t { } {
    return [check_no_compiler_messages 4byte_wchar_t object {
	int dummy[sizeof (__WCHAR_TYPE__) >= 4 ? 1 : -1];
    }]
}

# Return 1 if the target supports automatic stack alignment.

proc check_effective_target_automatic_stack_alignment  { } {
    if { [istarget i?86*-*-*]
	 || [istarget x86_64-*-*] } then {
	return 1
    } else {
	return 0
    }
}

# Return 1 if avx instructions can be compiled.

proc check_effective_target_avx { } {
    return [check_no_compiler_messages avx object {
	void _mm256_zeroall (void)
	{
	   __builtin_ia32_vzeroall ();
	}
    } "-O2 -mavx" ]
}

# Return 1 if sse instructions can be compiled.
proc check_effective_target_sse { } {
    return [check_no_compiler_messages sse object {
	int main ()
	{
	    __builtin_ia32_stmxcsr ();
	    return 0;
	}
    } "-O2 -msse" ]
}

# Return 1 if sse2 instructions can be compiled.
proc check_effective_target_sse2 { } {
    return [check_no_compiler_messages sse2 object {
	typedef long long __m128i __attribute__ ((__vector_size__ (16)));
	
	__m128i _mm_srli_si128 (__m128i __A, int __N)
	{
	    return (__m128i)__builtin_ia32_psrldqi128 (__A, 8);
	}
    } "-O2 -msse2" ]
}

# Return 1 if F16C instructions can be compiled.

proc check_effective_target_f16c { } {
    return [check_no_compiler_messages f16c object {
	#include "immintrin.h"
	float
	foo (unsigned short val)
	{
	  return _cvtsh_ss (val);
	}
    } "-O2 -mf16c" ]
}

# Return 1 if C wchar_t type is compatible with char16_t.

proc check_effective_target_wchar_t_char16_t_compatible { } {
    return [check_no_compiler_messages wchar_t_char16_t object {
        __WCHAR_TYPE__ wc;
        __CHAR16_TYPE__ *p16 = &wc;
        char t[(((__CHAR16_TYPE__) -1) < 0 == ((__WCHAR_TYPE__) -1) < 0) ? 1 : -1];
    }]
}

# Return 1 if C wchar_t type is compatible with char32_t.

proc check_effective_target_wchar_t_char32_t_compatible { } {
    return [check_no_compiler_messages wchar_t_char32_t object {
        __WCHAR_TYPE__ wc;
        __CHAR32_TYPE__ *p32 = &wc;
        char t[(((__CHAR32_TYPE__) -1) < 0 == ((__WCHAR_TYPE__) -1) < 0) ? 1 : -1];
    }]
}

# Return 1 if pow10 function exists.

proc check_effective_target_pow10 { } {
    return [check_runtime pow10 {
	#include <math.h>
	int main () {
	double x;
	x = pow10 (1);
	return 0;
	}
    } "-lm" ]
}

# Return 1 if current options generate DFP instructions, 0 otherwise.

proc check_effective_target_hard_dfp {} {
    return [check_no_messages_and_pattern hard_dfp "!adddd3" assembly {
	typedef float d64 __attribute__((mode(DD)));
	d64 x, y, z;
	void foo (void) { z = x + y; }
    }]
}

# Return 1 if string.h and wchar.h headers provide C++ requires overloads
# for strchr etc. functions.

proc check_effective_target_correct_iso_cpp_string_wchar_protos { } {
    return [check_no_compiler_messages correct_iso_cpp_string_wchar_protos assembly {
	#include <string.h>
	#include <wchar.h>
	#if !defined(__cplusplus) \
	    || !defined(__CORRECT_ISO_CPP_STRING_H_PROTO) \
	    || !defined(__CORRECT_ISO_CPP_WCHAR_H_PROTO)
	ISO C++ correct string.h and wchar.h protos not supported.
	#else
	int i;
	#endif
    }]
}

# Return 1 if GNU as is used.

proc check_effective_target_gas { } {
    global use_gas_saved
    global tool

    if {![info exists use_gas_saved]} {
	# Check if the as used by gcc is GNU as.
	set gcc_as [lindex [${tool}_target_compile "-print-prog-name=as" "" "none" ""] 0]
	# Provide /dev/null as input, otherwise gas times out reading from
	# stdin.
	set status [remote_exec host "$gcc_as" "-v /dev/null"]
	set as_output [lindex $status 1]
	if { [ string first "GNU" $as_output ] >= 0 } {
	    set use_gas_saved 1
	} else {
	    set use_gas_saved 0
	}
    }
    return $use_gas_saved
}

# Return 1 if the compiler has been configure with link-time optimization
# (LTO) support.

proc check_effective_target_lto { } {
    global ENABLE_LTO
    return [info exists ENABLE_LTO]
}

# Return 1 if the language for the compiler under test is C.

proc check_effective_target_c { } {
 global tool
    if [string match $tool "gcc"] {
   return 1
    }
 return 0
}

# Return 1 if the language for the compiler under test is C++.

proc check_effective_target_c++ { } {
 global tool
    if [string match $tool "g++"] {
   return 1
    }
 return 0
}

# Return 1 if expensive testcases should be run.

proc check_effective_target_run_expensive_tests { } {
    if { [getenv GCC_TEST_RUN_EXPENSIVE] != "" } {
        return 1
    }
    return 0
}
