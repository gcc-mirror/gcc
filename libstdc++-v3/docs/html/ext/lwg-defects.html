<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head><title>C++ Standard Library Defect Report List</title></head>
<body bgcolor="#ffffff" text="#000000">
<table>
<tr>
<td align="left">Doc. no.</td>
<td align="left">J16/01-0032 = WG21 N1318</td>
</tr>
<tr>
<td align="left">Date:</td>
<td align="left">11 Sep 2001</td>
</tr>
<tr>
<td align="left">Project:</td>
<td align="left">Programming Language C++</td>
</tr>
<tr>
<td align="left">Reply to:</td>
<td align="left">Matt Austern &lt;austern@research.att.com&gt;</td>
</tr>
</table>
<h1>C++ Standard Library Defect Report List (Revision 19)</h1>
  <p>Reference ISO/IEC IS 14882:1998(E)</p>
  <p>Also see:</p>
    <ul>
      <li>
<a href="lwg-toc.html">Table of Contents</a> for all library issues.</li>
      <li>
<a href="lwg-index.html">Index by Section</a> for all library issues.</li>
      <li>
<a href="lwg-status.html">Index by Status</a> for all library issues.</li>
      <li><a href="lwg-active.html">Library Active Issues List</a></li>
      <li><a href="lwg-closed.html">Library Closed Issues List</a></li>
    </ul>
  <p>This document contains only library issues which have been closed
  by the Library Working Group (LWG) after being found to be defects
  in the standard.  That is, issues which have a status of <a href="lwg-active.html#DR">DR</a>, <a href="lwg-active.html#TC">TC</a>, or <a href="lwg-active.html#RR">RR</a>. See the
  <a href="lwg-closed.html">Library Closed Issues List</a> for issues closed as non-defects.  See the
  <a href="lwg-active.html">Library Active Issues List</a> for active issues and more information.  The
  introductory material in that document also applies to this
  document.</p>
<h2>Revision History</h2>
<ul>
<li>R19: 
Pre-Redmond mailing.  Added new issues 
<a href="lwg-active.html#323">323</a>-<a href="lwg-active.html#335">335</a>.
</li>
<li>R18: 
Post-Copenhagen mailing; reflects actions taken in Copenhagen.
Added new issues <a href="lwg-active.html#312">312</a>-<a href="lwg-active.html#317">317</a>, and discussed
new issues <a href="lwg-active.html#271">271</a>-<a href="lwg-closed.html#314">314</a>.

Changed status of issues
<a href="lwg-defects.html#103">103</a> <a href="lwg-defects.html#118">118</a> <a href="lwg-defects.html#136">136</a> <a href="lwg-defects.html#153">153</a>
<a href="lwg-defects.html#165">165</a> <a href="lwg-defects.html#171">171</a> <a href="lwg-defects.html#183">183</a> <a href="lwg-defects.html#184">184</a>
<a href="lwg-defects.html#185">185</a> <a href="lwg-defects.html#186">186</a> <a href="lwg-defects.html#214">214</a> <a href="lwg-defects.html#221">221</a>
<a href="lwg-defects.html#234">234</a> <a href="lwg-defects.html#237">237</a> <a href="lwg-defects.html#243">243</a> <a href="lwg-defects.html#248">248</a>
<a href="lwg-defects.html#251">251</a> <a href="lwg-defects.html#252">252</a> <a href="lwg-defects.html#256">256</a> <a href="lwg-defects.html#260">260</a>
<a href="lwg-defects.html#261">261</a> <a href="lwg-defects.html#262">262</a> <a href="lwg-defects.html#263">263</a> <a href="lwg-defects.html#265">265</a>
<a href="lwg-defects.html#268">268</a>
to DR.

Changed status of issues
<a href="lwg-active.html#49">49</a>  <a href="lwg-active.html#109">109</a> <a href="lwg-active.html#117">117</a> <a href="lwg-active.html#182">182</a>
<a href="lwg-active.html#228">228</a> <a href="lwg-active.html#230">230</a> <a href="lwg-active.html#232">232</a> <a href="lwg-active.html#235">235</a>
<a href="lwg-active.html#238">238</a> <a href="lwg-active.html#241">241</a> <a href="lwg-active.html#242">242</a> <a href="lwg-active.html#250">250</a>
<a href="lwg-active.html#259">259</a> <a href="lwg-active.html#264">264</a> <a href="lwg-active.html#266">266</a> <a href="lwg-active.html#267">267</a>
<a href="lwg-active.html#271">271</a> <a href="lwg-active.html#272">272</a> <a href="lwg-active.html#273">273</a> <a href="lwg-active.html#275">275</a>
<a href="lwg-active.html#281">281</a> <a href="lwg-active.html#284">284</a> <a href="lwg-active.html#285">285</a> <a href="lwg-active.html#286">286</a>
<a href="lwg-active.html#288">288</a> <a href="lwg-active.html#292">292</a> <a href="lwg-active.html#295">295</a> <a href="lwg-active.html#297">297</a>
<a href="lwg-active.html#298">298</a> <a href="lwg-active.html#301">301</a> <a href="lwg-active.html#303">303</a> <a href="lwg-active.html#306">306</a>
<a href="lwg-active.html#307">307</a> <a href="lwg-active.html#308">308</a> <a href="lwg-active.html#312">312</a>
to Ready.

Closed issues 
<a href="lwg-closed.html#111">111</a> <a href="lwg-closed.html#277">277</a> <a href="lwg-closed.html#279">279</a> <a href="lwg-closed.html#287">287</a>
<a href="lwg-closed.html#289">289</a> <a href="lwg-closed.html#293">293</a> <a href="lwg-closed.html#302">302</a> <a href="lwg-closed.html#313">313</a>
<a href="lwg-closed.html#314">314</a>
as NAD.

</li>
<li>R17: 
Pre-Copenhagen mailing.  Converted issues list to XML.  Added proposed
resolutions for issues <a href="lwg-active.html#49">49</a>, <a href="lwg-active.html#76">76</a>, <a href="lwg-active.html#91">91</a>, <a href="lwg-active.html#235">235</a>, <a href="lwg-active.html#250">250</a>, <a href="lwg-active.html#267">267</a>.
Added new issues <a href="lwg-active.html#278">278</a>-<a href="lwg-active.html#311">311</a>.
</li>
<li>R16:  
post-Toronto mailing; reflects actions taken in Toronto. Added new
issues <a href="lwg-defects.html#265">265</a>-<a href="lwg-closed.html#277">277</a>.  Changed status of issues
<a href="lwg-defects.html#3">3</a>, <a href="lwg-defects.html#8">8</a>, <a href="lwg-defects.html#9">9</a>, <a href="lwg-defects.html#19">19</a>,
<a href="lwg-defects.html#26">26</a>, <a href="lwg-defects.html#31">31</a>, <a href="lwg-defects.html#61">61</a>,
<a href="lwg-defects.html#63">63</a>, <a href="lwg-defects.html#86">86</a>, <a href="lwg-defects.html#108">108</a>,
<a href="lwg-defects.html#112">112</a>, <a href="lwg-defects.html#114">114</a>, <a href="lwg-defects.html#115">115</a>,
<a href="lwg-defects.html#122">122</a>, <a href="lwg-defects.html#127">127</a>, <a href="lwg-defects.html#129">129</a>,
<a href="lwg-defects.html#134">134</a>, <a href="lwg-defects.html#137">137</a>, <a href="lwg-defects.html#142">142</a>,
<a href="lwg-defects.html#144">144</a>, <a href="lwg-defects.html#146">146</a>, <a href="lwg-defects.html#147">147</a>,
<a href="lwg-defects.html#159">159</a>, <a href="lwg-defects.html#164">164</a>, <a href="lwg-defects.html#170">170</a>,
<a href="lwg-defects.html#181">181</a>, <a href="lwg-defects.html#199">199</a>, <a href="lwg-defects.html#208">208</a>,
<a href="lwg-defects.html#209">209</a>, <a href="lwg-defects.html#210">210</a>, <a href="lwg-defects.html#211">211</a>,
<a href="lwg-defects.html#212">212</a>, <a href="lwg-defects.html#217">217</a>, <a href="lwg-defects.html#220">220</a>,
<a href="lwg-defects.html#222">222</a>, <a href="lwg-defects.html#223">223</a>, <a href="lwg-defects.html#224">224</a>,
<a href="lwg-defects.html#227">227</a> to &quot;DR&quot;.  Reopened issue <a href="lwg-active.html#23">23</a>. Reopened
issue <a href="lwg-active.html#187">187</a>. Changed issues <a href="lwg-closed.html#2">2</a> and
<a href="lwg-closed.html#4">4</a> to NAD. Fixed a typo in issue <a href="lwg-defects.html#17">17</a>. Fixed
issue <a href="lwg-defects.html#70">70</a>: signature should be changed both places it
appears. Fixed issue <a href="lwg-defects.html#160">160</a>: previous version didn't fix
the bug in enough places.
</li>
<li>R15: 
pre-Toronto mailing. Added issues
<a href="lwg-active.html#233">233</a>-<a href="lwg-active.html#264">264</a>. Some small HTML formatting
changes so that we pass Weblint tests.
</li>
<li>R14: 
post-Tokyo II mailing; reflects committee actions taken in
Tokyo. Added issues <a href="lwg-active.html#228">228</a> to <a href="lwg-active.html#232">232</a>. (00-0019R1/N1242)
</li>
<li>R13: 
pre-Tokyo II updated: Added issues <a href="lwg-defects.html#212">212</a> to <a href="lwg-defects.html#227">227</a>.
</li>
<li>R12: 
pre-Tokyo II mailing: Added issues <a href="lwg-defects.html#199">199</a> to
<a href="lwg-defects.html#211">211</a>. Added &quot;and paragraph 5&quot; to the proposed resolution
of issue <a href="lwg-defects.html#29">29</a>.  Add further rationale to issue
<a href="lwg-closed.html#178">178</a>.
</li>
<li>R11: 
post-Kona mailing: Updated to reflect LWG and full committee actions
in Kona (99-0048/N1224). Note changed resolution of issues
<a href="lwg-closed.html#4">4</a> and <a href="lwg-defects.html#38">38</a>. Added issues <a href="lwg-closed.html#196">196</a>
to <a href="lwg-active.html#198">198</a>. Closed issues list split into &quot;defects&quot; and
&quot;closed&quot; documents.  Changed the proposed resolution of issue
<a href="lwg-closed.html#4">4</a> to NAD, and changed the wording of proposed resolution
of issue <a href="lwg-defects.html#38">38</a>.
</li>
<li>R10: 
pre-Kona updated.  Added proposed resolutions <a href="lwg-defects.html#83">83</a>,
<a href="lwg-defects.html#86">86</a>, <a href="lwg-active.html#91">91</a>, <a href="lwg-active.html#92">92</a>,
<a href="lwg-active.html#109">109</a>. Added issues <a href="lwg-closed.html#190">190</a> to
<a href="lwg-defects.html#195">195</a>. (99-0033/D1209, 14 Oct 99)
</li>
<li>R9: 
pre-Kona mailing.  Added issues <a href="lwg-closed.html#140">140</a> to
<a href="lwg-defects.html#189">189</a>. Issues list split into separate &quot;active&quot; and
&quot;closed&quot; documents. (99-0030/N1206, 25 Aug 99)
</li>
<li>R8: 
post-Dublin mailing. Updated to reflect LWG and full committee actions
in Dublin. (99-0016/N1193, 21 Apr 99)
</li>
<li>R7: 
pre-Dublin updated: Added issues <a href="lwg-closed.html#130">130</a>, <a href="lwg-closed.html#131">131</a>,
<a href="lwg-defects.html#132">132</a>, <a href="lwg-defects.html#133">133</a>, <a href="lwg-defects.html#134">134</a>,
<a href="lwg-closed.html#135">135</a>, <a href="lwg-defects.html#136">136</a>, <a href="lwg-defects.html#137">137</a>,
<a href="lwg-closed.html#138">138</a>, <a href="lwg-defects.html#139">139</a> (31 Mar 99)
</li>
<li>R6: 
pre-Dublin mailing. Added issues <a href="lwg-defects.html#127">127</a>, <a href="lwg-closed.html#128">128</a>,
and <a href="lwg-defects.html#129">129</a>.  (99-0007/N1194, 22 Feb 99)
</li>
<li>R5: 
update issues <a href="lwg-defects.html#103">103</a>, <a href="lwg-defects.html#112">112</a>; added issues
<a href="lwg-defects.html#114">114</a> to <a href="lwg-defects.html#126">126</a>. Format revisions to prepare
for making list public. (30 Dec 98)
</li>
<li>R4: 
post-Santa Cruz II updated: Issues <a href="lwg-defects.html#110">110</a>,
<a href="lwg-closed.html#111">111</a>, <a href="lwg-defects.html#112">112</a>, <a href="lwg-closed.html#113">113</a> added, several
issues corrected. (22 Oct 98)
</li>
<li>R3: 
post-Santa Cruz II: Issues <a href="lwg-closed.html#94">94</a> to <a href="lwg-active.html#109">109</a>
added, many issues updated to reflect LWG consensus (12 Oct 98)
</li>
<li>R2: 
pre-Santa Cruz II: Issues <a href="lwg-closed.html#73">73</a> to <a href="lwg-closed.html#93">93</a> added,
issue <a href="lwg-defects.html#17">17</a> updated. (29 Sep 98)
</li>
<li>R1: 
Correction to issue <a href="lwg-defects.html#55">55</a> resolution, <a href="lwg-defects.html#60">60</a> code
format, <a href="lwg-defects.html#64">64</a> title. (17 Sep 98)
</li>
</ul>
<h2>Defect Reports</h2>
<hr>
<a name="1"><h3>1.&nbsp;C library linkage editing oversight</h3></a><p>
<b>Section:</b>&nbsp;17.4.2.2 <a href="lib-intro.html#lib.using.linkage"> [lib.using.linkage]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Beman Dawes&nbsp; <b>Date:</b>&nbsp;16 Nov 1997</p>
<p>The change specified in the proposed resolution below did not make
it into the Standard. This change was accepted in principle at the
London meeting, and the exact wording below was accepted at the
Morristown meeting.</p>
<p><b>Proposed resolution:</b></p>
<p>Change 17.4.2.2  paragraph 2
from:</p>

<blockquote>
  <p>It is unspecified whether a name from the Standard C library
  declared with external linkage has either extern &quot;C&quot; or
  extern &quot;C++&quot; linkage.</p>
</blockquote>

<p>to:</p>

<blockquote>
  <p>Whether a name from the Standard C library declared with external
  linkage has extern &quot;C&quot; or extern &quot;C++&quot; linkage
  is implementation defined. It is recommended that an implementation
  use extern &quot;C++&quot; linkage for this purpose.</p>
</blockquote>
<hr>
<a name="3"><h3>3.&nbsp;Atexit registration during atexit() call is not described</h3></a><p>
<b>Section:</b>&nbsp;18.3 <a href="lib-support.html#lib.support.start.term"> [lib.support.start.term]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Steve Clamage&nbsp; <b>Date:</b>&nbsp;12 Dec 1997</p>
<p>We appear not to have covered all the possibilities of
 exit processing with respect to
atexit registration. <br>
<br>
Example 1: (C and C++)</p>

<pre>    #include &lt;stdlib.h&gt;
    void f1() { }
    void f2() { atexit(f1); }
    
    int main()
    {
        atexit(f2); // the only use of f2
        return 0; // for C compatibility
    }</pre>

<p>At program exit, f2 gets called due to its registration in
main. Running f2 causes f1 to be newly registered during the exit
processing. Is this a valid program? If so, what are its
semantics?</p>

<p>
Interestingly, neither the C standard, nor the C++ draft standard nor
the forthcoming C9X Committee Draft says directly whether you can
register a function with atexit during exit processing.</p>

<p>
All 3 standards say that functions are run in reverse order of their
registration. Since f1 is registered last, it ought to be run first,
but by the time it is registered, it is too late to be first.</p>

<p>If the program is valid, the standards are self-contradictory about
its semantics.</p>

<p>Example 2: (C++ only)</p>

<pre>    
    void F() { static T t; } // type T has a destructor

    int main()
    {
        atexit(F); // the only use of F
    }
</pre>

<p>Function F registered with atexit has a local static variable t,
and F is called for the first time during exit processing. A local
static object is initialized the first time control flow passes
through its definition, and all static objects are destroyed during
exit processing. Is the code valid? If so, what are its semantics?</p>

<p>
Section 18.3 &quot;Start and termination&quot; says that if a function
F is registered with atexit before a static object t is initialized, F
will not be called until after t's destructor completes.</p>

<p>
In example 2, function F is registered with atexit before its local
static object O could possibly be initialized. On that basis, it must
not be called by exit processing until after O's destructor
completes. But the destructor cannot be run until after F is called,
since otherwise the object could not be constructed in the first
place.</p>

<p>If the program is valid, the standard is self-contradictory about
its semantics.</p>

<p>I plan to submit Example 1 as a public comment on the C9X CD, with
a recommendation that the results be undefined. (Alternative: make it
unspecified. I don't think it is worthwhile to specify the case where
f1 itself registers additional functions, each of which registers
still more functions.)</p>

<p>I think we should resolve the situation in the whatever way the C
committee decides. </p>

<p>For Example 2, I recommend we declare the results undefined.</p>

<p><i>[See reflector message lib-6500 for further discussion.]</i></p>

<p><b>Proposed resolution:</b></p>
<p>Change section 18.3/8 from:</p>
<blockquote>
  First, objects with static storage duration are destroyed and
  functions registered by calling atexit are called. Objects with
  static storage duration are destroyed in the reverse order of the
  completion of their constructor.  (Automatic objects are not
  destroyed as a result of calling exit().) Functions registered with
  atexit are called in the reverse order of their registration.  A
  function registered with atexit before an object obj1 of static
  storage duration is initialized will not be called until obj1's
  destruction has completed. A function registered with atexit after
  an object obj2 of static storage duration is initialized will be
  called before obj2's destruction starts.
</blockquote>
<p>to:</p>
<blockquote>
  First, objects with static storage duration are destroyed and
  functions registered by calling atexit are called. Non-local objects
  with static storage duration are destroyed in the reverse order of
  the completion of their constructor. (Automatic objects are not
  destroyed as a result of calling exit().) Functions registered with
  atexit are called in the reverse order of their registration, except
  that a function is called after any previously registered functions
  that had already been called at the time it was registered. A
  function registered with atexit before a non-local object obj1 of
  static storage duration is initialized will not be called until
  obj1's destruction has completed. A function registered with atexit
  after a non-local object obj2 of static storage duration is
  initialized will be called before obj2's destruction starts. A local
  static object obj3 is destroyed at the same time it would be if a
  function calling the obj3 destructor were registered with atexit at
  the completion of the obj3 constructor.
</blockquote>
<p><b>Rationale:</b></p>
<p>See 99-0039/N1215, October 22, 1999, by Stephen D. Clamage for the analysis
supporting to the proposed resolution.</p>
<hr>
<a name="5"><h3>5.&nbsp;String::compare specification questionable</h3></a><p>
<b>Section:</b>&nbsp;21.3.6.8 <a href="lib-strings.html#lib.string::compare"> [lib.string::compare]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Jack Reeves&nbsp; <b>Date:</b>&nbsp;11 Dec 1997</p>
<p>At the very end of the basic_string class definition is the signature: int
compare(size_type pos1, size_type n1, const charT* s, size_type n2 = npos) const; In the
following text this is defined as: returns
basic_string&lt;charT,traits,Allocator&gt;(*this,pos1,n1).compare(
basic_string&lt;charT,traits,Allocator&gt;(s,n2); </p>

<p>Since the constructor basic_string(const charT* s, size_type n, const Allocator&amp; a
= Allocator()) clearly requires that s != NULL and n &lt; npos and further states that it
throws length_error if n == npos, it appears the compare() signature above should always
throw length error if invoked like so: str.compare(1, str.size()-1, s); where 's' is some
null terminated character array. </p>

<p>This appears to be a typo since the obvious intent is to allow either the call above or
something like: str.compare(1, str.size()-1, s, strlen(s)-1); </p>

<p>This would imply that what was really intended was two signatures int compare(size_type
pos1, size_type n1, const charT* s) const int compare(size_type pos1, size_type n1, const
charT* s, size_type n2) const; each defined in terms of the corresponding constructor. </p>
<p><b>Proposed resolution:</b></p>
<p>Replace the compare signature in 21.3 
(at the very end of the basic_string synopsis) which reads:</p>

<blockquote>
  <p><tt>int compare(size_type pos1, size_type n1,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const charT* s,
  size_type n2 = npos) const;</tt></p>
</blockquote>

<p>with:</p>

<blockquote>
  <p><tt>int compare(size_type pos1, size_type n1,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const charT* s) const;<br>
  int compare(size_type pos1, size_type n1,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const charT* s,
  size_type n2) const;</tt></p>
</blockquote>

<p>Replace the portion of 21.3.6.8 
paragraphs 5 and 6 which read:</p>

<blockquote>
  <p>
<tt>int compare(size_type pos, size_type n1,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; charT * s, size_type n2
  = npos) const;<br>
  </tt>Returns:<tt><br>
  basic_string&lt;charT,traits,Allocator&gt;(*this, pos, n1).compare(<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  basic_string&lt;charT,traits,Allocator&gt;( s, n2))</tt>
</p>
</blockquote>

<p>with:</p>

<blockquote>
  <p>
<tt>int compare(size_type pos, size_type n1,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const charT * s) const;<br>
  </tt>Returns:<tt><br>
  basic_string&lt;charT,traits,Allocator&gt;(*this, pos, n1).compare(<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  basic_string&lt;charT,traits,Allocator&gt;( s ))<br>
  <br>
  int compare(size_type pos, size_type n1,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const charT * s,
  size_type n2) const;<br>
  </tt>Returns:<tt><br>
  basic_string&lt;charT,traits,Allocator&gt;(*this, pos, n1).compare(<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  basic_string&lt;charT,traits,Allocator&gt;( s, n2))</tt>
</p>
</blockquote>

<p>Editors please note that in addition to splitting the signature, the third argument
becomes const, matching the existing synopsis.</p>
<p><b>Rationale:</b></p>
<p>While the LWG dislikes adding signatures, this is a clear defect in
the Standard which must be fixed.&nbsp; The same problem was also
identified in issues 7 (item 5) and 87.</p>
<hr>
<a name="7"><h3>7.&nbsp;String clause minor problems</h3></a><p>
<b>Section:</b>&nbsp;21 <a href="lib-strings.html#lib.strings"> [lib.strings]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Matt Austern&nbsp; <b>Date:</b>&nbsp;15 Dec 1997</p>
<p>(1) In 21.3.5.4 , the description of template
&lt;class InputIterator&gt; insert(iterator, InputIterator,
InputIterator) makes no sense. It refers to a member function that
doesn't exist. It also talks about the return value of a void
function. </p>

<p>(2) Several versions of basic_string::replace don't appear in the
class synopsis. </p>

<p>(3) basic_string::push_back appears in the synopsis, but is never
described elsewhere.  In the synopsis its argument is const charT,
which doesn't makes much sense; it should probably be charT, or
possible const charT&amp;. </p>

<p>(4) basic_string::pop_back is missing. </p>

<p>(5) int compare(size_type pos, size_type n1, charT* s, size_type n2
= npos) make no sense. First, it's const charT* in the synopsis and
charT* in the description. Second, given what it says in RETURNS,
leaving out the final argument will always result in an exception
getting thrown. This is paragraphs 5 and 6 of 
21.3.6.8 </p>

<p>(6) In table 37, in section 21.1.1 ,
there's a note for X::move(s, p, n). It says &quot;Copies correctly
even where p is in [s, s+n)&quot;. This is correct as far as it goes,
but it doesn't go far enough; it should also guarantee that the copy
is correct even where s in in [p, p+n). These are two orthogonal
guarantees, and neither one follows from the other. Both guarantees
are necessary if X::move is supposed to have the same sort of
semantics as memmove (which was clearly the intent), and both
guarantees are necessary if X::move is actually supposed to be
useful. </p>
<p><b>Proposed resolution:</b></p>
<p>ITEM 1: In 21.3.5.4 [lib.string::insert], change paragraph 16 to <br>
<br>
&nbsp;&nbsp;&nbsp; EFFECTS: Equivalent to insert(p - begin(), basic_string(first, last)).<br>
<br>
ITEM 2:&nbsp; Not a defect; the Standard is clear.. There are ten versions of replace() in
the synopsis, and ten versions in 21.3.5.6 [lib.string::replace].<br>
<br>
ITEM 3: Change the declaration of push_back in the string synopsis (21.3,
[lib.basic.string]) from:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp; void push_back(const charT)<br>
<br>
to<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp; void push_back(charT)<br>
<br>
Add the following text immediately after 21.3.5.2 [lib.string::append], paragraph 10.<br>
<br>
&nbsp;&nbsp;&nbsp; void basic_string::push_back(charT c);<br>
&nbsp;&nbsp;&nbsp; EFFECTS: Equivalent to append(static_cast&lt;size_type&gt;(1), c);<br>
<br>
ITEM 4: Not a defect. The omission appears to have been deliberate.<br>
<br>
ITEM 5: Duplicate; see issue 5 (and 87).<br>
<br>
ITEM 6: In table 37, Replace:<br>
<br>
&nbsp;&nbsp;&nbsp; &quot;Copies correctly even where p is in [s, s+n).&quot;<br>
<br>
with:<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp; &quot;Copies correctly even where the ranges [p, p+n) and [s,
s+n) overlap.&quot;</p>
<hr>
<a name="8"><h3>8.&nbsp;Locale::global lacks guarantee</h3></a><p>
<b>Section:</b>&nbsp;22.1.1.5 <a href="lib-locales.html#lib.locale.statics"> [lib.locale.statics]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Matt Austern&nbsp; <b>Date:</b>&nbsp;24 Dec 1997</p>
<p>It appears there's an important guarantee missing from clause
22. We're told that invoking locale::global(L) sets the C locale if L
has a name. However, we're not told whether or not invoking
setlocale(s) sets the global C++ locale. </p>

<p>The intent, I think, is that it should not, but I can't find any
such words anywhere. </p>
<p><b>Proposed resolution:</b></p>
<p>Add a sentence at the end of 22.1.1.5 ,
paragraph 2:&nbsp; </p>

<blockquote>
  <p>No library function other than <tt>locale::global()</tt> shall affect 
  the value returned by <tt>locale()</tt>. </p>

</blockquote>
<hr>
<a name="9"><h3>9.&nbsp;Operator new(0) calls should not yield the same pointer</h3></a><p>
<b>Section:</b>&nbsp;18.4.1 <a href="lib-support.html#lib.new.delete"> [lib.new.delete]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Steve Clamage&nbsp; <b>Date:</b>&nbsp;4 Jan 1998</p>
<p>Scott Meyers, in a comp.std.c++ posting: I just noticed that
section 3.7.3.1 of CD2 seems to allow for the possibility that all
calls to operator new(0) yield the same pointer, an implementation
technique specifically prohibited by ARM 5.3.3.Was this prohibition
really lifted? Does the FDIS agree with CD2 in the regard? [Issues
list maintainer's note: the IS is the same.]</p>
<p><b>Proposed resolution:</b></p>
<p>Change the last paragraph of 3.7.3 from:</p>
<blockquote>
  <p>Any allocation and/or deallocation functions defined in a C++ program shall
  conform to the semantics specified in 3.7.3.1 and 3.7.3.2.</p>
</blockquote>
<p>to:</p>
<blockquote>
  <p>Any allocation and/or deallocation functions defined in a C++ program,
  including the default versions in the library, shall conform to the semantics
  specified in 3.7.3.1 and 3.7.3.2.</p>
</blockquote>
<p>Change 3.7.3.1/2, next-to-last sentence, from :</p>
<blockquote>
  <p>If the size of the space requested is zero, the value returned shall not be
  a null pointer value (4.10).</p>
</blockquote>
<p>to:</p>
<blockquote>
  <p>Even if the size of the space requested is zero, the request can fail. If
  the request succeeds, the value returned shall be a non-null pointer value
  (4.10) p0 different from any previously returned value p1, unless that value
  p1 was since passed to an operator delete.</p>
</blockquote>
<p>5.3.4/7 currently reads:</p>
<blockquote>
  <p>When the value of the expression in a direct-new-declarator is zero, the
  allocation function is called to allocate an array with no elements. The
  pointer returned by the new-expression is non-null. [Note: If the library
  allocation function is called, the pointer returned is distinct from the
  pointer to any other object.]</p>
</blockquote>
<p>Retain the first sentence, and delete the remainder.</p>
<p>18.4.1 currently has no text. Add the following:</p>
<blockquote>
  <p>Except where otherwise specified, the provisions of 3.7.3 apply to the
  library versions of operator new and operator delete.</p>
</blockquote>
<p>To 18.4.1.3, add the following text:</p>
<blockquote>
  <p>The provisions of 3.7.3 do not apply to these reserved placement forms of
  operator new and operator delete.</p>
</blockquote>
<p><b>Rationale:</b></p>
<p>See 99-0040/N1216, October 22, 1999, by Stephen D. Clamage for the analysis
supporting to the proposed resolution.</p>
<hr>
<a name="11"><h3>11.&nbsp;Bitset minor problems</h3></a><p>
<b>Section:</b>&nbsp;23.3.5 <a href="lib-containers.html#lib.template.bitset"> [lib.template.bitset]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Matt Austern&nbsp; <b>Date:</b>&nbsp;22 Jan 1998</p>
<p>(1) bitset&lt;&gt;::operator[] is mentioned in the class synopsis (23.3.5), but it is
not documented in 23.3.5.2. </p>

<p>(2) The class synopsis only gives a single signature for bitset&lt;&gt;::operator[],
reference operator[](size_t pos). This doesn't make much sense. It ought to be overloaded
on const. reference operator[](size_t pos); bool operator[](size_t pos) const. </p>

<p>(3) Bitset's stream input function (23.3.5.3) ought to skip all whitespace before
trying to extract 0s and 1s. The standard doesn't explicitly say that, though. This should
go in the Effects clause.</p>
<p><b>Proposed resolution:</b></p>
<p>ITEMS 1 AND 2:<br>
<br>
In the bitset synopsis (23.3.5 ), 
replace the member function <br>
<br>
<tt>&nbsp;&nbsp;&nbsp; reference operator[](size_t pos);<br>
</tt><br>
with the two member functions<br>
<br>
<tt>&nbsp;&nbsp;&nbsp; bool operator[](size_t pos) const; <br>
&nbsp;&nbsp;&nbsp; reference operator[](size_t pos); <br>
</tt><br>
Add the following text at the end of 23.3.5.2 , 
immediately after paragraph 45:</p>

<blockquote>
  <p>
<tt>bool operator[](size_t pos) const;</tt><br>
  Requires: pos is valid<br>
  Throws: nothing<br>
  Returns: <tt>test(pos)</tt><br>
  <br>
  <tt>bitset&lt;N&gt;::reference operator[](size_t pos);</tt> <br>
  Requires: pos is valid<br>
  Throws: nothing<br>
  Returns: An object of type <tt>bitset&lt;N&gt;::reference</tt> such that <tt>(*this)[pos]
  == this-&gt;test(pos)</tt>, and such that <tt>(*this)[pos] = val</tt> is equivalent to <tt>this-&gt;set(pos,
  val);</tt>
</p>
</blockquote>
<p><b>Rationale:</b></p>
<p>The LWG believes Item 3 is not a defect. &quot;Formatted
input&quot; implies the desired semantics. See 27.6.1.2 .
</p>
<hr>
<a name="13"><h3>13.&nbsp;Eos refuses to die</h3></a><p>
<b>Section:</b>&nbsp;27.6.1.2.3 <a href="lib-iostreams.html#lib.istream::extractors"> [lib.istream::extractors]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;William M. Miller&nbsp; <b>Date:</b>&nbsp;3 Mar 1998</p>
<p>In 27.6.1.2.3, there is a reference to &quot;eos&quot;, which is
the only one in the whole draft (at least using Acrobat search), so
it's undefined. </p>
<p><b>Proposed resolution:</b></p>
<p>In 27.6.1.2.3 , replace &quot;eos&quot; with
&quot;charT()&quot;</p>
<hr>
<a name="14"><h3>14.&nbsp;Locale::combine should be const</h3></a><p>
<b>Section:</b>&nbsp;22.1.1.3 <a href="lib-locales.html#lib.locale.members"> [lib.locale.members]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Nathan Myers&nbsp; <b>Date:</b>&nbsp;6 Aug 1998</p>
<p>locale::combine is the only member function of locale (other than constructors and
destructor) that is not const. There is no reason for it not to be const, and good reasons
why it should have been const. Furthermore, leaving it non-const conflicts with 22.1.1
paragraph 6: &quot;An instance of a locale is immutable.&quot; </p>

<p>History: this member function originally was a constructor. it happened that the
interface it specified had no corresponding language syntax, so it was changed to a member
function. As constructors are never const, there was no &quot;const&quot; in the interface
which was transformed into member &quot;combine&quot;. It should have been added at that
time, but the omission was not noticed. </p>
<p><b>Proposed resolution:</b></p>
<p>In 22.1.1  and also in 22.1.1.3 , add 
&quot;const&quot; to the declaration of member combine: </p>
<blockquote>
  <pre>template &lt;class Facet&gt; locale combine(const locale&amp; other) const; </pre>
</blockquote>
<hr>
<a name="15"><h3>15.&nbsp;Locale::name requirement inconsistent</h3></a><p>
<b>Section:</b>&nbsp;22.1.1.3 <a href="lib-locales.html#lib.locale.members"> [lib.locale.members]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Nathan Myers&nbsp; <b>Date:</b>&nbsp;6 Aug 1998</p>
<p>locale::name() is described as returning a string that can be passed to a locale
constructor, but there is no matching constructor. </p>
<p><b>Proposed resolution:</b></p>
<p>In 22.1.1.3 , paragraph 5, replace
&quot;<tt>locale(name())</tt>&quot; with
&quot;<tt>locale(name().c_str())</tt>&quot;.
</p>
<hr>
<a name="16"><h3>16.&nbsp;Bad ctype_byname&lt;char&gt; decl</h3></a><p>
<b>Section:</b>&nbsp;22.2.1.4 <a href="lib-locales.html#lib.locale.ctype.byname.special"> [lib.locale.ctype.byname.special]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Nathan Myers&nbsp; <b>Date:</b>&nbsp;6 Aug 1998</p>
<p>The new virtual members ctype_byname&lt;char&gt;::do_widen and do_narrow did not get
edited in properly. Instead, the member do_widen appears four times, with wrong argument
lists. </p>
<p><b>Proposed resolution:</b></p>
<p>The correct declarations for the overloaded members
<tt>do_narrow</tt> and <tt>do_widen</tt> should be copied 
from 22.2.1.3 .</p>
<hr>
<a name="17"><h3>17.&nbsp;Bad bool parsing</h3></a><p>
<b>Section:</b>&nbsp;22.2.2.1.2 <a href="lib-locales.html#lib.facet.num.get.virtuals"> [lib.facet.num.get.virtuals]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Nathan Myers&nbsp; <b>Date:</b>&nbsp;6 Aug 1998</p>
<p>This section describes the process of parsing a text boolean value from the input
stream. It does not say it recognizes either of the sequences &quot;true&quot; or
&quot;false&quot; and returns the corresponding bool value; instead, it says it recognizes
only one of those sequences, and chooses which according to the received value of a
reference argument intended for returning the result, and reports an error if the other
sequence is found. (!) Furthermore, it claims to get the names from the ctype&lt;&gt;
facet rather than the numpunct&lt;&gt; facet, and it examines the &quot;boolalpha&quot;
flag wrongly; it doesn't define the value &quot;loc&quot;; and finally, it computes
wrongly whether to use numeric or &quot;alpha&quot; parsing.<br>
<br>
I believe the correct algorithm is &quot;as if&quot;: </p>

<pre>  // in, err, val, and str are arguments.
  err = 0;
  const numpunct&lt;charT&gt;&amp; np = use_facet&lt;numpunct&lt;charT&gt; &gt;(str.getloc());
  const string_type t = np.truename(), f = np.falsename();
  bool tm = true, fm = true;
  size_t pos = 0;
  while (tm &amp;&amp; pos &lt; t.size() || fm &amp;&amp; pos &lt; f.size()) {
    if (in == end) { err = str.eofbit; }
    bool matched = false;
    if (tm &amp;&amp; pos &lt; t.size()) {
      if (!err &amp;&amp; t[pos] == *in) matched = true;
      else tm = false;
    }
    if (fm &amp;&amp; pos &lt; f.size()) {
      if (!err &amp;&amp; f[pos] == *in) matched = true;
      else fm = false;
    }
    if (matched) { ++in; ++pos; }
    if (pos &gt; t.size()) tm = false;
    if (pos &gt; f.size()) fm = false;
  }
  if (tm == fm || pos == 0) { err |= str.failbit; }
  else                      { val = tm; }
  return in;</pre>

<p>Notice this works reasonably when the candidate strings are both empty, or equal, or
when one is a substring of the other. The proposed text below captures the logic of the
code above.</p>
<p><b>Proposed resolution:</b></p>
<p>In 22.2.2.1.2 , in the first line of paragraph 14,
change &quot;&amp;&amp;&quot; to &quot;&amp;&quot;.</p>

<p>Then, replace paragraphs 15 and 16 as follows:</p>

<blockquote>

  <p>Otherwise target sequences are determined &quot;as if&quot; by
  calling the members <tt>falsename()</tt> and
  <tt>truename()</tt> of the facet obtained by
  <tt>use_facet&lt;numpunct&lt;charT&gt;&nbsp;&gt;(str.getloc())</tt>.  
  Successive characters in the range <tt>[in,end)</tt> (see
  [lib.sequence.reqmts]) are obtained and matched against
  corresponding positions in the target sequences only as necessary to
  identify a unique match. The input iterator <tt>in</tt> is
  compared to <tt>end</tt> only when necessary to obtain a
  character. If and only if a target sequence is uniquely matched,
  <tt>val</tt> is set to the corresponding value.</p>

</blockquote>

<blockquote>
  <p>The <tt>in</tt> iterator is always left pointing one position beyond the last character
  successfully matched. If <tt>val</tt> is set, then err is set to <tt>str.goodbit</tt>; or to
  <tt>str.eofbit</tt> if, when seeking another character to match, it is found that
  <tt>(in==end)</tt>. If <tt>val</tt> is not set, then <i>err</i> is set to <tt>str.failbit</tt>; or to
  <tt>(str.failbit|str.eofbit)</tt>if
  the reason for the failure was that <tt>(in==end)</tt>. [Example: for targets
  <tt>true</tt>:&quot;a&quot; and <tt>false</tt>:&quot;abb&quot;, the input sequence &quot;a&quot; yields
  <tt>val==true</tt> and <tt>err==str.eofbit</tt>; the input sequence &quot;abc&quot; yields
  <tt>err=str.failbit</tt>, with <tt>in</tt> ending at the 'c' element. For targets
  <tt>true</tt>:&quot;1&quot;
  and <tt>false</tt>:&quot;0&quot;, the input sequence &quot;1&quot; yields <tt>val==true</tt>
  and <tt>err=str.goodbit</tt>. For empty targets (&quot;&quot;), any input sequence yields
  <tt>err==str.failbit</tt>. --end example]</p>
</blockquote>
<hr>
<a name="18"><h3>18.&nbsp;Get(...bool&amp;) omitted</h3></a><p>
<b>Section:</b>&nbsp;22.2.2.1.1 <a href="lib-locales.html#lib.facet.num.get.members"> [lib.facet.num.get.members]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Nathan Myers&nbsp; <b>Date:</b>&nbsp;6 Aug 1998</p>
<p>In the list of num_get&lt;&gt; non-virtual members on page 22-23, the member
that parses bool values was omitted from the list of definitions of non-virtual
members, though it is listed in the class definition and the corresponding
virtual is listed everywhere appropriate. </p>
<p><b>Proposed resolution:</b></p>
<p>Add at the beginning of 22.2.2.1.1 
another get member for bool&amp;, copied from the entry in 
22.2.2.1 .</p>
<hr>
<a name="19"><h3>19.&nbsp;&quot;Noconv&quot; definition too vague</h3></a><p>
<b>Section:</b>&nbsp;22.2.1.5.2 <a href="lib-locales.html#lib.locale.codecvt.virtuals"> [lib.locale.codecvt.virtuals]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Nathan Myers&nbsp; <b>Date:</b>&nbsp;6 Aug 1998</p>
<p>
In the definitions of codecvt&lt;&gt;::do_out and do_in, they are
specified to return noconv if &quot;no conversion is
needed&quot;. This definition is too vague, and does not say
normatively what is done with the buffers.
</p>
<p><b>Proposed resolution:</b></p>
<p>
Change the entry for noconv in the table under paragraph 4 in section 
22.2.1.5.2  to read:
</p>
<blockquote>
  <p>
<tt>noconv</tt>: <tt>internT</tt> and <tt>externT</tt> are the same type,
  and input sequence is identical to converted sequence.</p>
</blockquote>
<p>Change the Note in paragraph 2 to normative text as follows:</p>
<blockquote>
  <p>If returns <tt>noconv</tt>, <tt>internT</tt> and <tt>externT</tt> are the
  same type and the converted sequence is identical to the input sequence <tt>[from,from_next)</tt>.
  <tt>to_next</tt> is set equal to <tt>to</tt>, the value of <tt>state</tt> is
  unchanged, and there are no changes to the values in <tt>[to, to_limit)</tt>.</p>
</blockquote>
<hr>
<a name="20"><h3>20.&nbsp;Thousands_sep returns wrong type</h3></a><p>
<b>Section:</b>&nbsp;22.2.3.1.2 <a href="lib-locales.html#lib.facet.numpunct.virtuals"> [lib.facet.numpunct.virtuals]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Nathan Myers&nbsp; <b>Date:</b>&nbsp;6 Aug 1998</p>
<p>The synopsis for numpunct&lt;&gt;::do_thousands_sep, and the
definition of numpunct&lt;&gt;::thousands_sep which calls it, specify
that it returns a value of type char_type. Here it is erroneously
described as returning a &quot;string_type&quot;. </p>
<p><b>Proposed resolution:</b></p>
<p>In 22.2.3.1.2 , above paragraph 2, change 
&quot;string_type&quot; to &quot;char_type&quot;. </p>
<hr>
<a name="21"><h3>21.&nbsp;Codecvt_byname&lt;&gt; instantiations</h3></a><p>
<b>Section:</b>&nbsp;22.1.1.1.1 <a href="lib-locales.html#lib.locale.category"> [lib.locale.category]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Nathan Myers&nbsp; <b>Date:</b>&nbsp;6 Aug 1998</p>
<p>In the second table in the section, captioned &quot;Required
instantiations&quot;, the instantiations for codecvt_byname&lt;&gt;
have been omitted. These are necessary to allow users to construct a
locale by name from facets. </p>
<p><b>Proposed resolution:</b></p>
<p>Add in 22.1.1.1.1  to the table captioned
&quot;Required instantiations&quot;, in the category &quot;ctype&quot;
the lines </p>

<blockquote>
  <pre>codecvt_byname&lt;char,char,mbstate_t&gt;,
codecvt_byname&lt;wchar_t,char,mbstate_t&gt; </pre>
</blockquote>
<hr>
<a name="22"><h3>22.&nbsp;Member open vs. flags</h3></a><p>
<b>Section:</b>&nbsp;27.8.1.7 <a href="lib-iostreams.html#lib.ifstream.members"> [lib.ifstream.members]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Nathan Myers&nbsp; <b>Date:</b>&nbsp;6 Aug 1998</p>
<p>The description of basic_istream&lt;&gt;::open leaves unanswered questions about how it
responds to or changes flags in the error status for the stream. A strict reading
indicates that it ignores the bits and does not change them, which confuses users who do
not expect eofbit and failbit to remain set after a successful open. There are three
reasonable resolutions: 1) status quo 2) fail if fail(), ignore eofbit 3) clear failbit
and eofbit on call to open(). </p>
<p><b>Proposed resolution:</b></p>
<p>In 27.8.1.7  paragraph 3, <i>and</i> in 27.8.1.10  paragraph 3, under open() effects, add a footnote:
</p>

<blockquote>
  <p>A successful open does not change the error state.</p>
</blockquote>
<hr>
<a name="24"><h3>24.&nbsp;&quot;do_convert&quot; doesn't exist</h3></a><p>
<b>Section:</b>&nbsp;22.2.1.5.2 <a href="lib-locales.html#lib.locale.codecvt.virtuals"> [lib.locale.codecvt.virtuals]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Nathan Myers&nbsp; <b>Date:</b>&nbsp;6 Aug 1998</p>
<p>The description of codecvt&lt;&gt;::do_out and do_in mentions a
symbol &quot;do_convert&quot; which is not defined in the
standard. This is a leftover from an edit, and should be &quot;do_in
and do_out&quot;. </p>
<p><b>Proposed resolution:</b></p>
<p>In 22.2.1.5 , paragraph 3, change
&quot;do_convert&quot; to &quot;do_in or do_out&quot;. Also, in 22.2.1.5.2 , change &quot;do_convert()&quot; to &quot;do_in
or do_out&quot;. </p>
<hr>
<a name="25"><h3>25.&nbsp;String operator&lt;&lt; uses width() value wrong</h3></a><p>
<b>Section:</b>&nbsp;21.3.7.9 <a href="lib-strings.html#lib.string.io"> [lib.string.io]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Nathan Myers&nbsp; <b>Date:</b>&nbsp;6 Aug 1998</p>
<p>In the description of operator&lt;&lt; applied to strings, the standard says that uses
the smaller of os.width() and str.size(), to pad &quot;as described in stage 3&quot;
elsewhere; but this is inconsistent, as this allows no possibility of space for padding. </p>
<p><b>Proposed resolution:</b></p>
<p>Change 21.3.7.9   paragraph 4 from:<br>
<br>
&nbsp;&nbsp;&nbsp; &quot;... where <tt>n</tt> is the smaller of <tt>os.width()</tt> and <tt>str.size()</tt>;
...&quot;<br>
<br>
to: <br>
<br>
&nbsp;&nbsp;&nbsp; &quot;... where <tt>n</tt> is the larger of <tt>os.width()</tt> and <tt>str.size()</tt>;
...&quot;</p>
<hr>
<a name="26"><h3>26.&nbsp;Bad sentry example</h3></a><p>
<b>Section:</b>&nbsp;27.6.1.1.2 <a href="lib-iostreams.html#lib.istream::sentry"> [lib.istream::sentry]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Nathan Myers&nbsp; <b>Date:</b>&nbsp;6 Aug 1998</p>
<p>In paragraph 6, the code in the example: </p>

<pre>  template &lt;class charT, class traits = char_traits&lt;charT&gt; &gt;
  basic_istream&lt;charT,traits&gt;::sentry(
           basic_istream&lt;charT,traits&gt;&amp; is, bool noskipws = false) {
      ...
      int_type c;
      typedef ctype&lt;charT&gt; ctype_type;
      const ctype_type&amp; ctype = use_facet&lt;ctype_type&gt;(is.getloc());
      while ((c = is.rdbuf()-&gt;snextc()) != traits::eof()) {
        if (ctype.is(ctype.space,c)==0) {
          is.rdbuf()-&gt;sputbackc (c);
          break;
        }
      }
      ...
   }</pre>

<p>fails to demonstrate correct use of the facilities described. In
particular, it fails to use traits operators, and specifies incorrect
semantics. (E.g. it specifies skipping over the first character in the
sequence without examining it.) </p>
<p><b>Proposed resolution:</b></p>
<p>Remove the example above from 27.6.1.1.2 
paragraph 6.</p>
<p><b>Rationale:</b></p>
<p>The originally proposed replacement code for the example was not
correct. The LWG tried in Kona and again in Tokyo to correct it
without success. In Tokyo, an implementor reported that actual working
code ran over one page in length and was quite complicated. The LWG
decided that it would be counter-productive to include such a lengthy
example, which might well still contain errors.</p>
<hr>
<a name="27"><h3>27.&nbsp;String::erase(range) yields wrong iterator</h3></a><p>
<b>Section:</b>&nbsp;21.3.5.5 <a href="lib-strings.html#lib.string::erase"> [lib.string::erase]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Nathan Myers&nbsp; <b>Date:</b>&nbsp;6 Aug 1998</p>
<p>The string::erase(iterator first, iterator last) is specified to return an element one
place beyond the next element after the last one erased. E.g. for the string
&quot;abcde&quot;, erasing the range ['b'..'d') would yield an iterator for element 'e',
while 'd' has not been erased. </p>
<p><b>Proposed resolution:</b></p>
<p>In 21.3.5.5 , paragraph 10, change: </p>

<blockquote>
  <p>Returns: an iterator which points to the element immediately following _last_ prior to
  the element being erased. </p>
</blockquote>

<p>to read </p>

<blockquote>
  <p>Returns: an iterator which points to the element pointed to by _last_ prior to the
  other elements being erased. </p>
</blockquote>
<hr>
<a name="28"><h3>28.&nbsp;Ctype&lt;char&gt;is ambiguous</h3></a><p>
<b>Section:</b>&nbsp;22.2.1.3.2 <a href="lib-locales.html#lib.facet.ctype.char.members"> [lib.facet.ctype.char.members]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Nathan Myers&nbsp; <b>Date:</b>&nbsp;6 Aug 1998</p>
<p>The description of the vector form of ctype&lt;char&gt;::is can be interpreted to mean
something very different from what was intended. Paragraph 4 says </p>

<blockquote>
  <p>Effects: The second form, for all *p in the range [low, high), assigns vec[p-low] to
  table()[(unsigned char)*p]. </p>
</blockquote>

<p>This is intended to copy the value indexed from table()[] into the place identified in
vec[]. </p>
<p><b>Proposed resolution:</b></p>
<p>Change 22.2.1.3.2 , paragraph 4, to read </p>

<blockquote>
  <p>Effects: The second form, for all *p in the range [low, high), assigns into vec[p-low]
  the value table()[(unsigned char)*p]. </p>
</blockquote>
<hr>
<a name="29"><h3>29.&nbsp;Ios_base::init doesn't exist</h3></a><p>
<b>Section:</b>&nbsp;27.3.1 <a href="lib-iostreams.html#lib.narrow.stream.objects"> [lib.narrow.stream.objects]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Nathan Myers&nbsp; <b>Date:</b>&nbsp;6 Aug 1998</p>
<p>Sections 27.3.1  and 27.3.2  mention
a function ios_base::init, which is not defined. Probably they mean
basic_ios&lt;&gt;::init, defined in 27.4.4.1 ,
paragraph 3. </p>
<p><b>Proposed resolution:</b></p>
<p>[R12: modified to include paragraph 5.]</p>

<p>In 27.3.1  paragraph 2 and 5, change </p>

<blockquote>
  <p>ios_base::init </p>
</blockquote>

<p>to </p>

<blockquote>
  <p>basic_ios&lt;char&gt;::init </p>
</blockquote>

<p>Also, make a similar change in 27.3.2  except it
should read </p>

<blockquote>
  <p>basic_ios&lt;wchar_t&gt;::init </p>
</blockquote>
<hr>
<a name="30"><h3>30.&nbsp;Wrong header for LC_*</h3></a><p>
<b>Section:</b>&nbsp;22.1.1.1.1 <a href="lib-locales.html#lib.locale.category"> [lib.locale.category]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Nathan Myers&nbsp; <b>Date:</b>&nbsp;6 Aug 1998</p>
<p>Paragraph 2 implies that the C macros LC_CTYPE etc. are defined in &lt;cctype&gt;,
where they are in fact defined elsewhere to appear in &lt;clocale&gt;. </p>
<p><b>Proposed resolution:</b></p>
<p>In 22.1.1.1.1 , paragraph 2, change
&quot;&lt;cctype&gt;&quot; to read &quot;&lt;clocale&gt;&quot;. </p>
<hr>
<a name="31"><h3>31.&nbsp;Immutable locale values</h3></a><p>
<b>Section:</b>&nbsp;22.1.1 <a href="lib-locales.html#lib.locale"> [lib.locale]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Nathan Myers&nbsp; <b>Date:</b>&nbsp;6 Aug 1998</p>
<p>Paragraph 6, says &quot;An instance of <tt>locale</tt> is
<i>immutable</i>; once a facet reference is obtained from it,
...&quot;. This has caused some confusion, because locale variables
are manifestly assignable. </p>
<p><b>Proposed resolution:</b></p>
<p>In 22.1.1  replace paragraph 6</p>

<blockquote>
  <p>An instance of <tt>locale</tt> is immutable; once a facet
  reference is obtained from it, that reference remains usable as long
  as the locale value itself exists.</p>
</blockquote>

<p>with</p>

<blockquote>
  <p>Once a facet reference is obtained from a locale object by
  calling use_facet&lt;&gt;, that reference remains usable, and the
  results from member functions of it may be cached and re-used, as
  long as some locale object refers to that facet.</p>
</blockquote>
<hr>
<a name="32"><h3>32.&nbsp;Pbackfail description inconsistent</h3></a><p>
<b>Section:</b>&nbsp;27.5.2.4.4 <a href="lib-iostreams.html#lib.streambuf.virt.pback"> [lib.streambuf.virt.pback]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Nathan Myers&nbsp; <b>Date:</b>&nbsp;6 Aug 1998</p>
<p>The description of the required state before calling virtual member
basic_streambuf&lt;&gt;::pbackfail requirements is inconsistent with the conditions
described in 27.5.2.2.4 [lib.streambuf.pub.pback] where member sputbackc calls it.
Specifically, the latter says it calls pbackfail if: </p>

<p>&nbsp;&nbsp;&nbsp; traits::eq(c,gptr()[-1]) is false </p>

<p>where pbackfail claims to require: </p>

<p>&nbsp;&nbsp;&nbsp; traits::eq(*gptr(),traits::to_char_type(c)) returns false </p>

<p>It appears that the pbackfail description is wrong. </p>
<p><b>Proposed resolution:</b></p>
<p>In 27.5.2.4.4 , paragraph 1, change:</p>

<blockquote>
  <p>&quot;<tt>traits::eq(*gptr(),traits::to_char_type( c))</tt>&quot;</p>
</blockquote>

<p>to </p>

<blockquote>
  <p>&quot;<tt>traits::eq(traits::to_char_type(c),gptr()[-1])</tt>&quot;
  </p>
</blockquote>
<p><b>Rationale:</b></p>
<p>Note deliberate reordering of arguments for clarity in addition to the correction of
the argument value.</p>
<hr>
<a name="33"><h3>33.&nbsp;Codecvt&lt;&gt; mentions from_type</h3></a><p>
<b>Section:</b>&nbsp;22.2.1.5.2 <a href="lib-locales.html#lib.locale.codecvt.virtuals"> [lib.locale.codecvt.virtuals]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Nathan Myers&nbsp; <b>Date:</b>&nbsp;6 Aug 1998</p>
<p>In the table defining the results from do_out and do_in, the specification for the
result <i>error</i> says </p>

<blockquote>
  <p>encountered a from_type character it could not convert </p>
</blockquote>

<p>but from_type is not defined. This clearly is intended to be an externT for do_in, or
an internT for do_out. </p>
<p><b>Proposed resolution:</b></p>
<p>In 22.2.1.5.2  paragraph 4, replace the definition
in the table for the case of _error_ with </p>

<blockquote>
  <p>encountered a character in <tt>[from,from_end)</tt> that it could not convert. </p>
</blockquote>
<hr>
<a name="34"><h3>34.&nbsp;True/falsename() not in ctype&lt;&gt;</h3></a><p>
<b>Section:</b>&nbsp;22.2.2.2.2 <a href="lib-locales.html#lib.facet.num.put.virtuals"> [lib.facet.num.put.virtuals]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Nathan Myers&nbsp; <b>Date:</b>&nbsp;6 Aug 1998</p>
<p>In paragraph 19, Effects:, members truename() and falsename are used from facet
ctype&lt;charT&gt;, but it has no such members. Note that this is also a problem in
22.2.2.1.2, addressed in (4). </p>
<p><b>Proposed resolution:</b></p>
<p>In 22.2.2.2.2 , paragraph 19, in the Effects:
clause for member put(...., bool), replace the initialization of the
string_type value s as follows: </p>

<blockquote>
  <pre>const numpunct&amp; np = use_facet&lt;numpunct&lt;charT&gt; &gt;(loc);
string_type s = val ? np.truename() : np.falsename(); </pre>
</blockquote>
<hr>
<a name="35"><h3>35.&nbsp;No manipulator unitbuf in synopsis</h3></a><p>
<b>Section:</b>&nbsp;27.4 <a href="lib-iostreams.html#lib.iostreams.base"> [lib.iostreams.base]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Nathan Myers&nbsp; <b>Date:</b>&nbsp;6 Aug 1998</p>
<p>In 27.4.5.1 , we have a definition for a manipulator
named &quot;unitbuf&quot;. Unlike other manipulators, it's not listed
in synopsis. Similarly for &quot;nounitbuf&quot;. </p>
<p><b>Proposed resolution:</b></p>
<p>Add to the synopsis for &lt;ios&gt; in 27.4 , after
the entry for &quot;nouppercase&quot;, the prototypes: </p>

<blockquote>
  <pre>ios_base&amp; unitbuf(ios_base&amp; str);
ios_base&amp; nounitbuf(ios_base&amp; str); </pre>
</blockquote>
<hr>
<a name="36"><h3>36.&nbsp;Iword &amp; pword storage lifetime omitted</h3></a><p>
<b>Section:</b>&nbsp;27.4.2.5 <a href="lib-iostreams.html#lib.ios.base.storage"> [lib.ios.base.storage]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Nathan Myers&nbsp; <b>Date:</b>&nbsp;6 Aug 1998</p>
<p>In the definitions for ios_base::iword and pword, the lifetime of the storage is
specified badly, so that an implementation which only keeps the last value stored appears
to conform. In particular, it says: </p>

<p>The reference returned may become invalid after another call to the object's iword
member with a different index ... </p>

<p>This is not idle speculation; at least one implementation was done this way. </p>
<p><b>Proposed resolution:</b></p>
<p>Add in 27.4.2.5 , in both paragraph 2 and also in
paragraph 4, replace the sentence: </p>

<blockquote>
  <p>The reference returned may become invalid after another call to the object's iword
  [pword] member with a different index, after a call to its copyfmt member, or when the
  object is destroyed. </p>
</blockquote>

<p>with: </p>

<blockquote>
  <p>The reference returned is invalid after any other operations on the object. However,
  the value of the storage referred to is retained, so that until the next call to copyfmt,
  calling iword [pword] with the same index yields another reference to the same value. </p>
</blockquote>

<p>substituting &quot;iword&quot; or &quot;pword&quot; as appropriate. </p>
<hr>
<a name="37"><h3>37.&nbsp;Leftover &quot;global&quot; reference</h3></a><p>
<b>Section:</b>&nbsp;22.1.1 <a href="lib-locales.html#lib.locale"> [lib.locale]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Nathan Myers&nbsp; <b>Date:</b>&nbsp;6 Aug 1998</p>
<p>In the overview of locale semantics, paragraph 4, is the sentence </p>

<blockquote>
  <p>If Facet is not present in a locale (or, failing that, in the global locale), it throws
  the standard exception bad_cast. </p>
</blockquote>

<p>This is not supported by the definition of use_facet&lt;&gt;, and represents semantics
from an old draft. </p>
<p><b>Proposed resolution:</b></p>
<p>In 22.1.1 , paragraph 4, delete the parenthesized
expression </p>

<blockquote>
  <p>(or, failing that, in the global locale) </p>
</blockquote>
<hr>
<a name="38"><h3>38.&nbsp;Facet definition incomplete</h3></a><p>
<b>Section:</b>&nbsp;22.1.2 <a href="lib-locales.html#lib.locale.global.templates"> [lib.locale.global.templates]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Nathan Myers&nbsp; <b>Date:</b>&nbsp;6 Aug 1998</p>
<p>It has been noticed by Esa Pulkkinen that the definition of
&quot;facet&quot; is incomplete. In particular, a class derived from
another facet, but which does not define a member <i>id</i>, cannot
safely serve as the argument <i>F</i> to use_facet&lt;F&gt;(loc),
because there is no guarantee that a reference to the facet instance
stored in <i>loc</i> is safely convertible to <i>F</i>. </p>
<p><b>Proposed resolution:</b></p>
<p>In the definition of std::use_facet&lt;&gt;(), replace the text in paragraph 1 which
reads: </p>

<blockquote>
  <p>Get a reference to a facet of a locale. </p>
</blockquote>

<p>with: </p>

<blockquote>
  <p>Requires: <tt>Facet</tt> is a facet class whose definition
  contains the public static member <tt>id</tt> as defined in 22.1.1.1.2 . </p>
</blockquote>

<p><i>[
Kona: strike as overspecification the text &quot;(not inherits)&quot;
from the original resolution, which read &quot;... whose definition
contains (not inherits) the public static member
<tt>id</tt>...&quot;
]</i></p>

<hr>
<a name="39"><h3>39.&nbsp;istreambuf_iterator&lt;&gt;::operator++(int) definition garbled</h3></a><p>
<b>Section:</b>&nbsp;24.5.3.4 <a href="lib-iterators.html#lib.istreambuf.iterator::op++"> [lib.istreambuf.iterator::op++]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Nathan Myers&nbsp; <b>Date:</b>&nbsp;6 Aug 1998</p>
<p>Following the definition of istreambuf_iterator&lt;&gt;::operator++(int) in paragraph
3, the standard contains three lines of garbage text left over from a previous edit. </p>

<blockquote>
  <pre>istreambuf_iterator&lt;charT,traits&gt; tmp = *this;
sbuf_-&gt;sbumpc();
return(tmp); </pre>
</blockquote>
<p><b>Proposed resolution:</b></p>
<p>In 24.5.3.4 , delete the three lines of code at the
end of paragraph 3. </p>
<hr>
<a name="40"><h3>40.&nbsp;Meaningless normative paragraph in examples</h3></a><p>
<b>Section:</b>&nbsp;22.2.8 <a href="lib-locales.html#lib.facets.examples"> [lib.facets.examples]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Nathan Myers&nbsp; <b>Date:</b>&nbsp;6 Aug 1998</p>
<p>Paragraph 3 of the locale examples is a description of part of an
implementation technique that has lost its referent, and doesn't mean
anything. </p>
<p><b>Proposed resolution:</b></p>
<p>Delete 22.2.8  paragraph 3 which begins &quot;This
initialization/identification system depends...&quot;, or (at the
editor's option) replace it with a place-holder to keep the paragraph
numbering the same. </p>
<hr>
<a name="41"><h3>41.&nbsp;Ios_base needs clear(), exceptions()</h3></a><p>
<b>Section:</b>&nbsp;27.4.2 <a href="lib-iostreams.html#lib.ios.base"> [lib.ios.base]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Nathan Myers&nbsp; <b>Date:</b>&nbsp;6 Aug 1998</p>
<p>The description of ios_base::iword() and pword() in 27.4.2.4 , say that if they fail, they &quot;set badbit,
which may throw an exception&quot;. However, ios_base offers no
interface to set or to test badbit; those interfaces are defined in
basic_ios&lt;&gt;. </p>
<p><b>Proposed resolution:</b></p>
<p>Change the description in 27.4.2.5  in
paragraph 2, and also in paragraph 4, as follows. Replace</p>

<blockquote>
  <p>If the function fails it sets badbit, which may throw an exception.</p>
</blockquote>

<p>with</p>

<blockquote>
  <p>If the function fails, and <tt>*this</tt> is a base sub-object of
  a <tt>basic_ios&lt;&gt;</tt> object or sub-object, the effect is
  equivalent to calling <tt>basic_ios&lt;&gt;::setstate(badbit)</tt>
  on the derived object (which may throw <tt>failure</tt>).</p>
</blockquote>

<p><i>[Kona: LWG reviewed wording; setstate(failbit) changed to
setstate(badbit).]</i></p>

<hr>
<a name="42"><h3>42.&nbsp;String ctors specify wrong default allocator</h3></a><p>
<b>Section:</b>&nbsp;21.3 <a href="lib-strings.html#lib.basic.string"> [lib.basic.string]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Nathan Myers&nbsp; <b>Date:</b>&nbsp;6 Aug 1998</p>
<p>The basic_string&lt;&gt; copy constructor: </p>

<pre>basic_string(const basic_string&amp; str, size_type pos = 0,
             size_type n = npos, const Allocator&amp; a = Allocator()); </pre>

<p>specifies an Allocator argument default value that is
counter-intuitive. The natural choice for a the allocator to copy from
is str.get_allocator(). Though this cannot be expressed in
default-argument notation, overloading suffices. </p>

<p>Alternatively, the other containers in Clause 23 (deque, list,
vector) do not have this form of constructor, so it is inconsistent,
and an evident source of confusion, for basic_string&lt;&gt; to have
it, so it might better be removed. </p>
<p><b>Proposed resolution:</b></p>
<p> In 21.3 , replace the declaration of the copy
constructor as follows: </p>

<blockquote>
  <pre>basic_string(const basic_string&amp; str);
basic_string(const basic_string&amp; str, size_type pos, size_type n = npos,
             const Allocator&amp; a = Allocator());</pre>
</blockquote>

<p>In 21.3.1 , replace the copy constructor declaration
as above. Add to paragraph 5, Effects:</p>

<blockquote>
  <p>In the first form, the Allocator value used is copied from
  <tt>str.get_allocator()</tt>.</p>
</blockquote>
<p><b>Rationale:</b></p>
<p>The LWG believes the constructor is actually broken, rather than
just an unfortunate design choice.</p>

<p>The LWG considered two other possible resolutions:</p>

<p>A. In 21.3 , replace the declaration of the copy
constructor as follows:</p>

<blockquote>
  <pre>basic_string(const basic_string&amp; str, size_type pos = 0,
             size_type n = npos);
basic_string(const basic_string&amp; str, size_type pos,
             size_type n, const Allocator&amp; a); </pre>
</blockquote>

<p>In 21.3.1 , replace the copy constructor declaration
as above. Add to paragraph 5, Effects: </p>

<blockquote>
  <p>When no <tt>Allocator</tt> argument is provided, the string is constructed using the
  value <tt>str.get_allocator()</tt>. </p>
</blockquote>

<p>B. In 21.3 , and also in 21.3.1 , replace
the declaration of the copy constructor as follows: </p>

<blockquote>
  <pre>basic_string(const basic_string&amp; str, size_type pos = 0,
             size_type n = npos); </pre>
</blockquote>

<p>The proposed resolution reflects the original intent of the LWG. It
was also noted by Pete Becker that this fix &quot;will cause
a small amount of existing code to now work correctly.&quot;</p>

<p><i>[
Kona: issue editing snafu fixed - the proposed resolution now correctly
reflects the LWG consensus.
]</i></p>
<hr>
<a name="46"><h3>46.&nbsp;Minor Annex D errors</h3></a><p>
<b>Section:</b>&nbsp;D.7 <a href="future.html#depr.str.strstreams"> [depr.str.strstreams]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Brendan Kehoe&nbsp; <b>Date:</b>&nbsp; 1 Jun 1998</p>
<p>See lib-6522 and edit-814.</p>
<p><b>Proposed resolution:</b></p>
<p>Change D.7.1  (since streambuf is a typedef of
basic_streambuf&lt;char&gt;) from:</p>

<pre>         virtual streambuf&lt;char&gt;* setbuf(char* s, streamsize n);</pre>

<p>to:</p>

<pre>         virtual streambuf* setbuf(char* s, streamsize n);</pre>

<p>In D.7.4  insert the semicolon now missing after
int_type:</p>

<pre>     namespace std {
       class strstream
         : public basic_iostream&lt;char&gt; {
       public:
         // Types
         typedef char                                char_type;
         typedef typename char_traits&lt;char&gt;::int_type int_type
         typedef typename char_traits&lt;char&gt;::pos_type pos_type;</pre>
<hr>
<a name="47"><h3>47.&nbsp;Imbue() and getloc() Returns clauses swapped</h3></a><p>
<b>Section:</b>&nbsp;27.4.2.3 <a href="lib-iostreams.html#lib.ios.base.locales"> [lib.ios.base.locales]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Matt Austern&nbsp; <b>Date:</b>&nbsp;21 Jun 1998</p>
<p>Section 27.4.2.3 specifies how imbue() and getloc() work. That
section has two RETURNS clauses, and they make no sense as
stated. They make perfect sense, though, if you swap them. Am I
correct in thinking that paragraphs 2 and 4 just got mixed up by
accident?</p>
<p><b>Proposed resolution:</b></p>
<p>In 27.4.2.3  swap paragraphs 2 and 4.</p>
<hr>
<a name="48"><h3>48.&nbsp;Use of non-existent exception constructor</h3></a><p>
<b>Section:</b>&nbsp;27.4.2.1.1 <a href="lib-iostreams.html#lib.ios::failure"> [lib.ios::failure]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Matt Austern&nbsp; <b>Date:</b>&nbsp;21 Jun 1998</p>
<p>27.4.2.1.1, paragraph 2, says that class failure initializes the
base class, exception, with exception(msg). Class exception (see
18.6.1) has no such constructor.</p>
<p><b>Proposed resolution:</b></p>
<p>Replace 27.4.2.1.1 , paragraph 2, with</p>

<blockquote>
  <p>EFFECTS: Constructs an object of class <tt>failure</tt>.</p>
</blockquote>
<hr>
<a name="50"><h3>50.&nbsp;Copy constructor and assignment operator of ios_base</h3></a><p>
<b>Section:</b>&nbsp;27.4.2 <a href="lib-iostreams.html#lib.ios.base"> [lib.ios.base]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Matt Austern&nbsp; <b>Date:</b>&nbsp;21 Jun 1998</p>
<p>As written, ios_base has a copy constructor and an assignment
operator. (Nothing in the standard says it doesn't have one, and all
classes have copy constructors and assignment operators unless you
take specific steps to avoid them.) However, nothing in 27.4.2 says
what the copy constructor and assignment operator do. </p>

<p>My guess is that this was an oversight, that ios_base is, like
basic_ios, not supposed to have a copy constructor or an assignment
operator.</p>

<p>
Jerry Schwarz comments: Yes, its an oversight, but in the opposite
sense to what you're suggesting. At one point there was a definite
intention that you could copy ios_base. It's an easy way to save the
entire state of a stream for future use. As you note, to carry out
that intention would have required a explicit description of the
semantics (e.g. what happens to the iarray and parray stuff).
</p>
<p><b>Proposed resolution:</b></p>
<p>In 27.4.2 , class ios_base, specify the copy
constructor and operator= members as being private.</p>
<p><b>Rationale:</b></p>
<p>The LWG believes the difficulty of specifying correct semantics
outweighs any benefit of allowing ios_base objects to be copyable.</p>
<hr>
<a name="51"><h3>51.&nbsp;Requirement to not invalidate iterators missing</h3></a><p>
<b>Section:</b>&nbsp;23.1 <a href="lib-containers.html#lib.container.requirements"> [lib.container.requirements]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;David Vandevoorde&nbsp; <b>Date:</b>&nbsp;23 Jun 1998</p>
<p>The std::sort algorithm can in general only sort a given sequence
by moving around values. The list&lt;&gt;::sort() member on the other
hand could move around values or just update internal pointers. Either
method can leave iterators into the list&lt;&gt; dereferencable, but
they would point to different things. </p>

<p>Does the FDIS mandate anywhere which method should be used for
list&lt;&gt;::sort()?</p>

<p>Matt Austern comments:</p>

<p>I think you've found an omission in the standard. </p>

<p>The library working group discussed this point, and there was
supposed to be a general requirement saying that list, set, map,
multiset, and multimap may not invalidate iterators, or change the
values that iterators point to, except when an operation does it
explicitly. So, for example, insert() doesn't invalidate any iterators
and erase() and remove() only invalidate iterators pointing to the
elements that are being erased. </p>

<p>I looked for that general requirement in the FDIS, and, while I
found a limited form of it for the sorted associative containers, I
didn't find it for list. It looks like it just got omitted. </p>

<p>The intention, though, is that list&lt;&gt;::sort does not
invalidate any iterators and does not change the values that any
iterator points to. There would be no reason to have the member
function otherwise.</p>
<p><b>Proposed resolution:</b></p>
<p>Add a new paragraph at the end of 23.1:</p>

<blockquote>
  <p>Unless otherwise specified (either explicitly or by defining a function in terms of
  other functions), invoking a container member function or passing a container as an
  argument to a library function shall not invalidate iterators to, or change the values of,
  objects within that container. </p>
</blockquote>
<p><b>Rationale:</b></p>
<p>This was US issue CD2-23-011; it was accepted in London but the
change was not made due to an editing oversight. The wording in the
proposed resolution below is somewhat updated from CD2-23-011,
particularly the addition of the phrase &quot;or change the values
of&quot;</p>
<hr>
<a name="52"><h3>52.&nbsp;Small I/O problems</h3></a><p>
<b>Section:</b>&nbsp;27.4.3.2 <a href="lib-iostreams.html#lib.fpos.operations"> [lib.fpos.operations]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Matt Austern&nbsp; <b>Date:</b>&nbsp;23 Jun 1998</p>
<p>First, 27.4.4.1 , table 89. This is pretty obvious:
it should be titled &quot;basic_ios&lt;&gt;() effects&quot;, not
&quot;ios_base() effects&quot;. </p>

<p>[The second item is a duplicate; see issue <a href="lwg-closed.html#6">6</a> for
resolution.]</p>

<p>Second, 27.4.3.2  table 88 . There are a couple
different things wrong with it, some of which I've already discussed
with Jerry, but the most obvious mechanical sort of error is that it
uses expressions like P(i) and p(i), without ever defining what sort
of thing &quot;i&quot; is.
</p>

<p>(The other problem is that it requires support for streampos
arithmetic. This is impossible on some systems, i.e. ones where file
position is a complicated structure rather than just a number. Jerry
tells me that the intention was to require syntactic support for
streampos arithmetic, but that it wasn't actually supposed to do
anything meaningful except on platforms, like Unix, where genuine
arithmetic is possible.) </p>
<p><b>Proposed resolution:</b></p>
<p>Change 27.4.4.1  table 89 title from
&quot;ios_base() effects&quot; to &quot;basic_ios&lt;&gt;()
effects&quot;. </p>
<hr>
<a name="53"><h3>53.&nbsp;Basic_ios destructor unspecified</h3></a><p>
<b>Section:</b>&nbsp;27.4.4.1 <a href="lib-iostreams.html#lib.basic.ios.cons"> [lib.basic.ios.cons]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Matt Austern&nbsp; <b>Date:</b>&nbsp;23 Jun 1998</p>
<p>There's nothing in 27.4.4 saying what basic_ios's destructor does.
The important question is whether basic_ios::~basic_ios() destroys
rdbuf().</p>
<p><b>Proposed resolution:</b></p>
<p>Add after 27.4.4.1  paragraph 2:</p>

<blockquote>
  <p><tt>virtual ~basic_ios();</tt></p>
  <p>
<b>Notes</b>: The destructor does not destroy <tt>rdbuf()</tt>.</p>
</blockquote>
<p><b>Rationale:</b></p> 
<p>The LWG reviewed the additional question of whether or not
<tt>rdbuf(0)</tt> may set <tt>badbit</tt>.  The answer is
clearly yes; it may be set via <tt>clear()</tt>.  See 27.4.4.2 , paragraph 6.  This issue was reviewed at length
by the LWG, which removed from the original proposed resolution a
footnote which incorrectly said &quot;<tt>rdbuf(0)</tt> does not set
<tt>badbit</tt>&quot;.</p>
<hr>
<a name="54"><h3>54.&nbsp;Basic_streambuf's destructor</h3></a><p>
<b>Section:</b>&nbsp;27.5.2.1 <a href="lib-iostreams.html#lib.streambuf.cons"> [lib.streambuf.cons]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Matt Austern&nbsp; <b>Date:</b>&nbsp;25 Jun 1998</p>
<p>The class synopsis for basic_streambuf shows a (virtual)
destructor, but the standard doesn't say what that destructor does. My
assumption is that it does nothing, but the standard should say so
explicitly. </p>
<p><b>Proposed resolution:</b></p>
<p>Add after 27.5.2.1  paragraph 2:</p>

<blockquote>
  <p><tt>virtual&nbsp; ~basic_streambuf();</tt></p>
  <p>
<b>Effects</b>: None.</p>
</blockquote>
<hr>
<a name="55"><h3>55.&nbsp;Invalid stream position is undefined</h3></a><p>
<b>Section:</b>&nbsp;27 <a href="lib-iostreams.html#lib.input.output"> [lib.input.output]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Matt Austern&nbsp; <b>Date:</b>&nbsp;26 Jun 1998</p>
<p>Several member functions in clause 27 are defined in certain
circumstances to return an &quot;invalid stream position&quot;, a term
that is defined nowhere in the standard. Two places (27.5.2.4.2,
paragraph 4, and 27.8.1.4, paragraph 15) contain a cross-reference to
a definition in _lib.iostreams.definitions_, a nonexistent
section. </p>

<p>I suspect that the invalid stream position is just supposed to be
pos_type(-1).  Probably best to say explicitly in (for example)
27.5.2.4.2 that the return value is pos_type(-1), rather than to use
the term &quot;invalid stream position&quot;, define that term
somewhere, and then put in a cross-reference. </p>

<p>The phrase &quot;invalid stream position&quot; appears ten times in
the C++ Standard.  In seven places it refers to a return value, and it
should be changed. In three places it refers to an argument, and it
should not be changed. Here are the three places where &quot;invalid
stream position&quot; should not be changed:</p>

<blockquote>
  <p>27.7.1.3 , paragraph 14<br>
  27.8.1.4 , paragraph 14<br>
  D.7.1.3 , paragraph 17
  <a href="lib-iostreams.html#lib.stringbuf.virtuals"> [lib.stringbuf.virtuals]</a>
</p>
</blockquote>
<p><b>Proposed resolution:</b></p>
<p>In 27.5.2.4.2 , paragraph 4, change &quot;Returns an
object of class pos_type that stores an invalid stream position
(_lib.iostreams.definitions_)&quot; to &quot;Returns
<tt>pos_type(off_type(-1))</tt>&quot;.
</p>

<p>In 27.5.2.4.2 , paragraph 6, change &quot;Returns
an object of class pos_type that stores an invalid stream
position&quot; to &quot;Returns <tt>pos_type(off_type(-1))</tt>&quot;.</p>

<p>In 27.7.1.3 , paragraph 13, change &quot;the object
stores an invalid stream position&quot; to &quot;the return value is
<tt>pos_type(off_type(-1))</tt>&quot;. </p>

<p>In 27.8.1.4 , paragraph 13, change &quot;returns an
invalid stream position (27.4.3)&quot; to &quot;returns
<tt>pos_type(off_type(-1))</tt>&quot; </p>

<p>In 27.8.1.4 , paragraph 15, change &quot;Otherwise
returns an invalid stream position (_lib.iostreams.definitions_)&quot;
to &quot;Otherwise returns <tt>pos_type(off_type(-1))</tt>&quot;
</p>

<p>In D.7.1.3 , paragraph 15, change &quot;the object
stores an invalid stream position&quot; to &quot;the return value is
<tt>pos_type(off_type(-1))</tt>&quot; </p>

<p>In D.7.1.3 , paragraph 18, change &quot;the object
stores an invalid stream position&quot; to &quot;the return value is
<tt>pos_type(off_type(-1))</tt>&quot;</p>
<hr>
<a name="56"><h3>56.&nbsp;Showmanyc's return type</h3></a><p>
<b>Section:</b>&nbsp;27.5.2 <a href="lib-iostreams.html#lib.streambuf"> [lib.streambuf]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Matt Austern&nbsp; <b>Date:</b>&nbsp;29 Jun 1998</p>
<p>The class summary for basic_streambuf&lt;&gt;, in 27.5.2, says that
showmanyc has return type int. However, 27.5.2.4.3 says that its
return type is streamsize. </p>
<p><b>Proposed resolution:</b></p>
<p>Change <tt>showmanyc</tt>'s return type in the
27.5.2  class summary to <tt>streamsize</tt>.</p>
<hr>
<a name="57"><h3>57.&nbsp;Mistake in char_traits</h3></a><p>
<b>Section:</b>&nbsp;21.1.3.2 <a href="lib-strings.html#lib.char.traits.specializations.wchar.t"> [lib.char.traits.specializations.wchar.t]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Matt Austern&nbsp; <b>Date:</b>&nbsp;1 Jul 1998</p>
<p>21.1.3.2, paragraph 3, says &quot;The types streampos and
wstreampos may be different if the implementation supports no shift
encoding in narrow-oriented iostreams but supports one or more shift
encodings in wide-oriented streams&quot;. </p>

<p>That's wrong: the two are the same type. The &lt;iosfwd&gt; summary
in 27.2 says that streampos and wstreampos are, respectively, synonyms
for fpos&lt;char_traits&lt;char&gt;::state_type&gt; and
fpos&lt;char_traits&lt;wchar_t&gt;::state_type&gt;, and, flipping back
to clause 21, we see in 21.1.3.1 and 21.1.3.2 that
char_traits&lt;char&gt;::state_type and
char_traits&lt;wchar_t&gt;::state_type must both be mbstate_t. </p>
<p><b>Proposed resolution:</b></p>
<p>Remove the sentence in 21.1.3.2  paragraph 3 which
begins &quot;The types streampos and wstreampos may be
different...&quot; . </p>
<hr>
<a name="59"><h3>59.&nbsp;Ambiguity in specification of gbump</h3></a><p>
<b>Section:</b>&nbsp;27.5.2.3.1 <a href="lib-iostreams.html#lib.streambuf.get.area"> [lib.streambuf.get.area]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Matt Austern&nbsp; <b>Date:</b>&nbsp;28 Jul 1998</p>
<p>27.5.2.3.1 says that basic_streambuf::gbump() &quot;Advances the
next pointer for the input sequence by n.&quot; </p>

<p>The straightforward interpretation is that it is just gptr() +=
n. An alternative interpretation, though, is that it behaves as if it
calls sbumpc n times. (The issue, of course, is whether it might ever
call underflow.) There is a similar ambiguity in the case of
pbump. </p>

<p>(The &quot;classic&quot; AT&amp;T implementation used the
former interpretation.)</p>
<p><b>Proposed resolution:</b></p>
<p>Change 27.5.2.3.1  paragraph 4 gbump effects from:</p>

<blockquote>
  <p>Effects: Advances the next pointer for the input sequence by n.</p>
</blockquote>

<p>to:</p>

<blockquote>
  <p>Effects: Adds <tt>n</tt> to the next pointer for the input sequence.</p>
</blockquote>

<p>Make the same change to 27.5.2.3.2  paragraph 4 pbump
effects.</p>
<hr>
<a name="60"><h3>60.&nbsp;What is a formatted input function?</h3></a><p>
<b>Section:</b>&nbsp;27.6.1.2.1 <a href="lib-iostreams.html#lib.istream.formatted.reqmts"> [lib.istream.formatted.reqmts]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Matt Austern&nbsp; <b>Date:</b>&nbsp;3 Aug 1998</p>
<p>Paragraph 1 of 27.6.1.2.1 contains general requirements for all
formatted input functions. Some of the functions defined in section
27.6.1.2 explicitly say that those requirements apply (&quot;Behaves
like a formatted input member (as described in 27.6.1.2.1)&quot;), but
others don't. The question: is 27.6.1.2.1 supposed to apply to
everything in 27.6.1.2, or only to those member functions that
explicitly say &quot;behaves like a formatted input member&quot;? Or
to put it differently: are we to assume that everything that appears
in a section called &quot;Formatted input functions&quot; really is a
formatted input function? I assume that 27.6.1.2.1 is intended to
apply to the arithmetic extractors (27.6.1.2.2), but I assume that it
is not intended to apply to extractors like </p>

<pre>    basic_istream&amp; operator&gt;&gt;(basic_istream&amp; (*pf)(basic_istream&amp;));</pre>

<p>and </p>

<pre>    basic_istream&amp; operator&gt;&gt;(basic_streammbuf*);</pre>

<p>There is a similar ambiguity for unformatted input, formatted output, and unformatted
output. </p>

<p>Comments from Judy Ward: It seems like the problem is that the
basic_istream and basic_ostream operator &lt;&lt;()'s that are used
for the manipulators and streambuf* are in the wrong section and
should have their own separate section or be modified to make it clear
that the &quot;Common requirements&quot; listed in section 27.6.1.2.1
(for basic_istream) and section 27.6.2.5.1 (for basic_ostream) do not
apply to them. </p>

<p>Additional comments from Dietmar K&uuml;hl: It appears to be somewhat
nonsensical to consider the functions defined in 27.6.1.2.3  paragraphs 1 to 5 to be &quot;Formatted input
function&quot; but since these functions are defined in a section
labeled &quot;Formatted input functions&quot; it is unclear to me
whether these operators are considered formatted input functions which
have to conform to the &quot;common requirements&quot; from 27.6.1.2.1 : If this is the case, all manipulators, not
just <tt>ws</tt>, would skip whitespace unless <tt>noskipws</tt> is
set (... but setting <tt>noskipws</tt> using the manipulator syntax
would also skip whitespace :-)</p> <p>It is not clear which functions
are to be considered unformatted input functions. As written, it seems
that all functions in 27.6.1.3  are unformatted input
functions. However, it does not really make much sense to construct a
sentry object for <tt>gcount()</tt>, <tt>sync()</tt>, ... Also it is
unclear what happens to the <tt>gcount()</tt> if
eg. <tt>gcount()</tt>, <tt>putback()</tt>, <tt>unget()</tt>, or
<tt>sync()</tt> is called: These functions don't extract characters,
some of them even &quot;unextract&quot; a character. Should this still
be reflected in <tt>gcount()</tt>? Of course, it could be read as if
after a call to <tt>gcount()</tt> <tt>gcount()</tt> return <tt>0</tt>
(the last unformatted input function, <tt>gcount()</tt>, didn't
extract any character) and after a call to <tt>putback()</tt>
<tt>gcount()</tt> returns <tt>-1</tt> (the last unformatted input
function <tt>putback()</tt> did &quot;extract&quot; back into the
stream). Correspondingly for <tt>unget()</tt>. Is this what is
intended?  If so, this should be clarified. Otherwise, a corresponding
clarification should be used.</p>
<p><b>Proposed resolution:</b></p>
<p>
In 27.6.1.2.2 [lib.istream.formatted.arithmetic], paragraph 1.
Change the beginning of the second sentence from &quot;The conversion
occurs&quot; to &quot;These extractors behave as formatted input functions (as
described in 27.6.1.2.1).  After a sentry object is constructed,
the conversion occurs&quot;
</p>

<p>
In 27.6.1.2.3, [lib.istream::extractors], before paragraph 1.
Add an effects clause.  &quot;Effects: None.  This extractor does
not behave as a formatted input function (as described in
27.6.1.2.1).
</p>

<p>
In 27.6.1.2.3, [lib.istream::extractors], paragraph 2.  Change the
effects clause to &quot;Effects: Calls pf(*this).  This extractor does not
behave as a formatted input function (as described in 27.6.1.2.1).
</p>

<p>
In 27.6.1.2.3, [lib.istream::extractors], paragraph 4.  Change the
effects clause to &quot;Effects: Calls pf(*this).  This extractor does not
behave as a formatted input function (as described in 27.6.1.2.1).
</p>

<p>
In 27.6.1.2.3, [lib.istream::extractors], paragraph 12.  Change the
first two sentences from &quot;If sb is null, calls setstate(failbit),
which may throw ios_base::failure (27.4.4.3).  Extracts characters
from *this...&quot; to &quot;Behaves as a formatted input function (as described
in 27.6.1.2.1).  If sb is null, calls setstate(failbit), which may
throw ios_base::failure (27.4.4.3).  After a sentry object is
constructed, extracts characters from *this...&quot;.
</p>

<p>
In 27.6.1.3, [lib.istream.unformatted], before paragraph 2.  Add an
effects clause.  &quot;Effects: none. This member function does not behave
as an unformatted input function (as described in 27.6.1.3, paragraph 1).&quot;
</p>

<p>
In 27.6.1.3, [lib.istream.unformatted], paragraph 3.  Change the
beginning of the first sentence of the effects clause from &quot;Extracts a
character&quot; to &quot;Behaves as an unformatted input function (as described
in 27.6.1.3, paragraph 1).  After constructing a sentry object, extracts a
character&quot;
</p>

<p>
In 27.6.1.3, [lib.istream.unformatted], paragraph 5.  Change the
beginning of the first sentence of the effects clause from &quot;Extracts a
character&quot; to &quot;Behaves as an unformatted input function (as described
in 27.6.1.3, paragraph 1).  After constructing a sentry object, extracts a
character&quot;
</p>

<p>
In 27.6.1.3, [lib.istream.unformatted], paragraph 5.  Change the
beginning of the first sentence of the effects clause from &quot;Extracts
characters&quot; to &quot;Behaves as an unformatted input function (as described
in 27.6.1.3, paragraph 1).  After constructing a sentry object, extracts
characters&quot;
</p>

<p>
[No change needed in paragraph 10, because it refers to paragraph 7.]
</p>

<p>
In 27.6.1.3, [lib.istream.unformatted], paragraph 12.  Change the
beginning of the first sentence of the effects clause from &quot;Extracts
characters&quot; to &quot;Behaves as an unformatted input function (as described
in 27.6.1.3, paragraph 1).  After constructing a sentry object, extracts
characters&quot;
</p>

<p>
[No change needed in paragraph 15.]
</p>

<p>
In 27.6.1.3, [lib.istream.unformatted], paragraph 17.  Change the
beginning of the first sentence of the effects clause from &quot;Extracts
characters&quot; to &quot;Behaves as an unformatted input function (as described
in 27.6.1.3, paragraph 1).  After constructing a sentry object, extracts
characters&quot;
</p>

<p>
[No change needed in paragraph 23.]
</p>

<p>
In 27.6.1.3, [lib.istream.unformatted], paragraph 24.  Change the
beginning of the first sentence of the effects clause from &quot;Extracts
characters&quot; to &quot;Behaves as an unformatted input function (as described
in 27.6.1.3, paragraph 1).  After constructing a sentry object, extracts
characters&quot;
</p>

<p>
In 27.6.1.3, [lib.istream.unformatted], before paragraph 27.  Add an
Effects clause: &quot;Effects: Behaves as an unformatted input function (as
described in 27.6.1.3, paragraph 1).  After constructing a sentry
object, reads but does not extract the current input character.&quot;
</p>

<p>
In 27.6.1.3, [lib.istream.unformatted], paragraph 28.  Change the
first sentence of the Effects clause from &quot;If !good() calls&quot; to
Behaves as an unformatted input function (as described in 27.6.1.3,
paragraph 1).  After constructing a sentry object, if !good() calls&quot;
</p>

<p>
In 27.6.1.3, [lib.istream.unformatted], paragraph 30.  Change the
first sentence of the Effects clause from &quot;If !good() calls&quot; to
&quot;Behaves as an unformatted input function (as described in 27.6.1.3,
paragraph 1).  After constructing a sentry object, if !good() calls&quot;
</p>

<p>
In 27.6.1.3, [lib.istream.unformatted], paragraph 32.  Change the
first sentence of the Effects clause from &quot;If !good() calls...&quot; to
&quot;Behaves as an unformatted input function (as described in 27.6.1.3,
paragraph 1).  After constructing a sentry object, if !good()
calls...&quot;  Add a new sentence to the end of the Effects clause:
&quot;[Note: this function extracts no characters, so the value returned
by the next call to gcount() is 0.]&quot;
</p>

<p>
In 27.6.1.3, [lib.istream.unformatted], paragraph 34.  Change the
first sentence of the Effects clause from &quot;If !good() calls&quot; to
&quot;Behaves as an unformatted input function (as described in 27.6.1.3,
paragraph 1).  After constructing a sentry object, if !good() calls&quot;.
Add a new sentence to the end of the Effects clause: &quot;[Note: this
function extracts no characters, so the value returned by the next
call to gcount() is 0.]&quot;
</p>

<p>
In 27.6.1.3, [lib.istream.unformatted], paragraph 36.  Change the
first sentence of the Effects clause from &quot;If !rdbuf() is&quot; to &quot;Behaves
as an unformatted input function (as described in 27.6.1.3, paragraph
1), except that it does not count the number of characters extracted
and does not affect the value returned by subsequent calls to
gcount().  After constructing a sentry object, if rdbuf() is&quot;
</p>

<p>
In 27.6.1.3, [lib.istream.unformatted], before paragraph 37.  Add an
Effects clause: &quot;Effects: Behaves as an unformatted input function (as
described in 27.6.1.3, paragraph 1), except that it does not count the
number of characters extracted and does not affect the value returned
by subsequent calls to gcount().&quot;  Change the first sentence of
paragraph 37 from &quot;if fail()&quot; to &quot;after constructing a sentry object,
if fail()&quot;.
</p>

<p>
In 27.6.1.3, [lib.istream.unformatted], paragraph 38.  Change the
first sentence of the Effects clause from &quot;If fail()&quot; to &quot;Behaves
as an unformatted input function (as described in 27.6.1.3, paragraph
1), except that it does not count the number of characters extracted
and does not affect the value returned by subsequent calls to
gcount().  After constructing a sentry object, if fail()
</p>

<p>
In 27.6.1.3, [lib.istream.unformatted], paragraph 40.  Change the
first sentence of the Effects clause from &quot;If fail()&quot; to &quot;Behaves
as an unformatted input function (as described in 27.6.1.3, paragraph
1), except that it does not count the number of characters extracted
and does not affect the value returned by subsequent calls to
gcount().  After constructing a sentry object, if fail()
</p>

<p>
In 27.6.2.5.2 [lib.ostream.inserters.arithmetic], paragraph 1.  Change
the beginning of the third sentence from &quot;The formatting conversion&quot;
to &quot;These extractors behave as formatted output functions (as
described in 27.6.2.5.1).  After the sentry object is constructed, the
conversion occurs&quot;.
</p>

<p>
In 27.6.2.5.3 [lib.ostream.inserters], before paragraph 1.  Add an
effects clause: &quot;Effects: None. Does not behave as a formatted output
function (as described in 27.6.2.5.1).&quot;.
</p>

<p>
In 27.6.2.5.3 [lib.ostream.inserters], paragraph 2.  Change the
effects clause to &quot;Effects: calls pf(*this).  This extractor does not
behave as a formatted output function (as described in 27.6.2.5.1).&quot;.
</p>

<p>
In 27.6.2.5.3 [lib.ostream.inserters], paragraph 4.  Change the
effects clause to &quot;Effects: calls pf(*this).  This extractor does not
behave as a formatted output function (as described in 27.6.2.5.1).&quot;.
</p>

<p>
In 27.6.2.5.3 [lib.ostream.inserters], paragraph 6.  Change the first
sentence from &quot;If sb&quot; to &quot;Behaves as a formatted output function (as
described in 27.6.2.5.1).  After the sentry object is constructed, if
sb&quot;.
</p>

<p>
In 27.6.2.6 [lib.ostream.unformatted], paragraph 2.  Change the first
sentence from &quot;Inserts the character&quot; to &quot;Behaves as an unformatted
output function (as described in 27.6.2.6, paragraph 1).  After
constructing a sentry object, inserts the character&quot;.
</p>

<p>
In 27.6.2.6 [lib.ostream.unformatted], paragraph 5.  Change the first
sentence from &quot;Obtains characters&quot; to &quot;Behaves as an unformatted
output function (as described in 27.6.2.6, paragraph 1).  After
constructing a sentry object, obtains characters&quot;.
</p>

<p>
In 27.6.2.6 [lib.ostream.unformatted], paragraph 7.  Add a new
sentence at the end of the paragraph: &quot;Does not behave as an
unformatted output function (as described in 27.6.2.6, paragraph 1).&quot;
</p>
<p><b>Rationale:</b></p>
<p>See J16/99-0043==WG21/N1219, Proposed Resolution to Library Issue 60,
by Judy Ward and Matt Austern.  This proposed resolution is section
VI of that paper.</p>
<hr>
<a name="61"><h3>61.&nbsp;Ambiguity in iostreams exception policy</h3></a><p>
<b>Section:</b>&nbsp;27.6.1.3 <a href="lib-iostreams.html#lib.istream.unformatted"> [lib.istream.unformatted]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Matt Austern&nbsp; <b>Date:</b>&nbsp;6 Aug 1998</p>
<p>The introduction to the section on unformatted input (27.6.1.3)
says that every unformatted input function catches all exceptions that
were thrown during input, sets badbit, and then conditionally rethrows
the exception. That seems clear enough. Several of the specific
functions, however, such as get() and read(), are documented in some
circumstances as setting eofbit and/or failbit. (The standard notes,
correctly, that setting eofbit or failbit can sometimes result in an
exception being thrown.) The question: if one of these functions
throws an exception triggered by setting failbit, is this an exception
&quot;thrown during input&quot; and hence covered by 27.6.1.3, or does
27.6.1.3 only refer to a limited class of exceptions? Just to make
this concrete, suppose you have the following snippet. </p>

<pre>  
  char buffer[N];
  istream is;
  ...
  is.exceptions(istream::failbit); // Throw on failbit but not on badbit.
  is.read(buffer, N);</pre>

<p>Now suppose we reach EOF before we've read N characters. What
iostate bits can we expect to be set, and what exception (if any) will
be thrown? </p>
<p><b>Proposed resolution:</b></p>
<p>
In 27.6.1.3, paragraph 1, after the sentence that begins
&quot;If an exception is thrown...&quot;, add the following
parenthetical comment: &quot;(Exceptions thrown from 
<tt>basic_ios&lt;&gt;::clear()</tt> are not caught or rethrown.)&quot;
</p>
<p><b>Rationale:</b></p>
<p>The LWG looked to two alternative wordings, and choose the proposed
resolution as better standardese.</p>
<hr>
<a name="62"><h3>62.&nbsp;<tt>Sync</tt>'s return value</h3></a><p>
<b>Section:</b>&nbsp;27.6.1.3 <a href="lib-iostreams.html#lib.istream.unformatted"> [lib.istream.unformatted]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Matt Austern&nbsp; <b>Date:</b>&nbsp;6 Aug 1998</p>
<p>The Effects clause for sync() (27.6.1.3, paragraph 36) says that it
&quot;calls rdbuf()-&gt;pubsync() and, if that function returns -1
... returns traits::eof().&quot; </p>

<p>That looks suspicious, because traits::eof() is of type
traits::int_type while the return type of sync() is int. </p>
<p><b>Proposed resolution:</b></p>
<p>In 27.6.1.3 , paragraph 36, change &quot;returns
<tt>traits::eof()</tt>&quot; to &quot;returns <tt>-1</tt>&quot;.
</p>
<hr>
<a name="63"><h3>63.&nbsp;Exception-handling policy for unformatted output</h3></a><p>
<b>Section:</b>&nbsp;27.6.2.6 <a href="lib-iostreams.html#lib.ostream.unformatted"> [lib.ostream.unformatted]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Matt Austern&nbsp; <b>Date:</b>&nbsp;11 Aug 1998</p>
<p>Clause 27 details an exception-handling policy for formatted input,
unformatted input, and formatted output. It says nothing for
unformatted output (27.6.2.6). 27.6.2.6 should either include the same
kind of exception-handling policy as in the other three places, or
else it should have a footnote saying that the omission is
deliberate. </p>
<p><b>Proposed resolution:</b></p>
<p>
In 27.6.2.6, paragraph 1, replace the last sentence (&quot;In any
case, the unformatted output function ends by destroying the sentry
object, then returning the value specified for the formatted output
function.&quot;) with the following text:
</p>
<blockquote>
If an exception is thrown during output, then <tt>ios::badbit</tt> is
turned on [Footnote: without causing an <tt>ios::failure</tt> to be
thrown.] in <tt>*this</tt>'s error state. If <tt>(exceptions() &amp;
badbit) != 0</tt> then the exception is rethrown.  In any case, the
unformatted output function ends by destroying the sentry object,
then, if no exception was thrown, returning the value specified for
the formatted output function.
</blockquote>
<p><b>Rationale:</b></p>
<p>
This exception-handling policy is consistent with that of formatted
input, unformatted input, and formatted output.
</p>
<hr>
<a name="64"><h3>64.&nbsp;Exception handling in <tt>basic_istream::operator&gt;&gt;(basic_streambuf*)</tt>
</h3></a><p>
<b>Section:</b>&nbsp;27.6.1.2.3 <a href="lib-iostreams.html#lib.istream::extractors"> [lib.istream::extractors]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Matt Austern&nbsp; <b>Date:</b>&nbsp;11 Aug 1998 </p>
<p>27.6.1.2.3, paragraph 13, is ambiguous. It can be interpreted two
different ways, depending on whether the second sentence is read as an
elaboration of the first. </p>
<p><b>Proposed resolution:</b></p>
<p>Replace 27.6.1.2.3 , paragraph 13, which begins
&quot;If the function inserts no characters ...&quot; with:</p>

<blockquote>
  <p>If the function inserts no characters, it calls
  <tt>setstate(failbit)</tt>, which may throw
  <tt>ios_base::failure</tt> (27.4.4.3). If it inserted no characters
  because it caught an exception thrown while extracting characters
  from <tt>sb</tt> and <tt>failbit</tt> is on in <tt>exceptions()</tt>
  (27.4.4.3), then the caught exception is rethrown. </p>
</blockquote>
<hr>
<a name="66"><h3>66.&nbsp;Strstreambuf::setbuf</h3></a><p>
<b>Section:</b>&nbsp;D.7.1.3 <a href="future.html#depr.strstreambuf.virtuals"> [depr.strstreambuf.virtuals]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Matt Austern&nbsp; <b>Date:</b>&nbsp;18 Aug 1998</p>
<p>D.7.1.3, paragraph 19, says that strstreambuf::setbuf
&quot;Performs an operation that is defined separately for each class
derived from strstreambuf&quot;. This is obviously an incorrect
cut-and-paste from basic_streambuf. There are no classes derived from
strstreambuf. </p>
<p><b>Proposed resolution:</b></p>
<p>D.7.1.3 , paragraph 19, replace the setbuf effects
clause which currently says &quot;Performs an operation that is
defined separately for each class derived from strstreambuf&quot;
with:<a href="future.html#depr.strstreambuf.virtuals"> [depr.strstreambuf.virtuals]</a>
</p>

<blockquote>
  <p>
<b>Effects</b>: implementation defined, except that
  <tt>setbuf(0,0)</tt> has no effect.</p>
</blockquote>
<hr>
<a name="68"><h3>68.&nbsp;Extractors for char* should store null at end</h3></a><p>
<b>Section:</b>&nbsp;27.6.1.2.3 <a href="lib-iostreams.html#lib.istream::extractors"> [lib.istream::extractors]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Angelika Langer&nbsp; <b>Date:</b>&nbsp;14 Jul 1998</p>
<p>Extractors for char* (27.6.1.2.3) do not store a null character
after the extracted character sequence whereas the unformatted
functions like get() do. Why is this?</p>

<p>Comment from Jerry Schwarz: There is apparently an editing
glitch. You'll notice that the last item of the list of what stops
extraction doesn't make any sense. It was supposed to be the line that
said a null is stored.</p>
<p><b>Proposed resolution:</b></p>
<p>27.6.1.2.3 , paragraph 7, change the last list
item from:<a href="lib-iostreams.html#lib.istream::extractors"> [lib.istream::extractors]</a>
</p>

<blockquote>
  A null byte (<tt>charT()</tt>) in the next position, which may be
  the first position if no characters were extracted.
</blockquote>

<p>to become a new paragraph which reads:</p>

<blockquote>
  Operator&gt;&gt; then stores a null byte (<tt>charT()</tt>) in the
  next position, which may be the first position if no characters were
  extracted.
</blockquote>
<hr>
<a name="69"><h3>69.&nbsp;Must elements of a vector be contiguous?</h3></a><p>
<b>Section:</b>&nbsp;23.2.4 <a href="lib-containers.html#lib.vector"> [lib.vector]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Andrew Koenig&nbsp; <b>Date:</b>&nbsp;29 Jul 1998</p>
<p>The issue is this: Must the elements of a vector be in contiguous memory?</p>

<p>(Please note that this is entirely separate from the question of
whether a vector iterator is required to be a pointer; the answer to
that question is clearly &quot;no,&quot; as it would rule out
debugging implementations)</p>
<p><b>Proposed resolution:</b></p>
<p>Add the following text to the end of 23.2.4 ,
paragraph 1. </p>

<blockquote>
  <p>The elements of a vector are stored contiguously, meaning that if
  v is a <tt>vector&lt;T, Allocator&gt;</tt> where T is some type
  other than <tt>bool</tt>, then it obeys the identity <tt>&amp;v[n]
  == &amp;v[0] + n</tt> for all <tt>0 &lt;= n &lt; v.size()</tt>.</p>
</blockquote>
<p><b>Rationale:</b></p>
<p>The LWG feels that as a practical matter the answer is clearly
&quot;yes&quot;.  There was considerable discussion as to the best way
to express the concept of &quot;contiguous&quot;, which is not
directly defined in the standard.  Discussion included:</p>

<ul>
  <li>An operational definition similar to the above proposed resolution is 
    already used for valarray (26.3.2.3 ).</li>
  <li>There is no need to explicitly consider a user-defined operator&amp; 
    because elements must be copyconstructible (23.1  para 3) 
    and copyconstructible (20.1.3 ) specifies
    requirements for operator&amp;.</li>
  <li>There is no issue of one-past-the-end because of language rules.</li>
</ul>
<hr>
<a name="70"><h3>70.&nbsp;Uncaught_exception() missing throw() specification</h3></a><p>
<b>Section:</b>&nbsp;18.6 <a href="lib-support.html#lib.support.exception"> [lib.support.exception]</a>, 18.6.4 <a href="lib-support.html#lib.uncaught"> [lib.uncaught]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Steve Clamage&nbsp; <b>Date:</b>&nbsp;Unknown</p>
<p>In article 3E04@pratique.fr, Valentin Bonnard writes: </p>

<p>uncaught_exception() doesn't have a throw specification.</p>

<p>It is intentional ? Does it means that one should be prepared to
handle exceptions thrown from uncaught_exception() ?</p>

<p>uncaught_exception() is called in exception handling contexts where
exception safety is very important.</p>
<p><b>Proposed resolution:</b></p>
<p>In 15.5.3 , paragraph 1, 18.6 , and 18.6.4 , add &quot;throw()&quot; to uncaught_exception().</p>
<hr>
<a name="71"><h3>71.&nbsp;Do_get_monthname synopsis missing argument</h3></a><p>
<b>Section:</b>&nbsp;22.2.5.1 <a href="lib-locales.html#lib.locale.time.get"> [lib.locale.time.get]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Nathan Myers&nbsp; <b>Date:</b>&nbsp;13 Aug 1998</p>
<p>The locale facet member <tt>time_get&lt;&gt;::do_get_monthname</tt>
is described in 22.2.5.1.2  with five arguments,
consistent with do_get_weekday and with its specified use by member
get_monthname. However, in the synopsis, it is specified instead with
four arguments. The missing argument is the &quot;end&quot; iterator
value.</p>
<p><b>Proposed resolution:</b></p>
<p>In 22.2.5.1 , add an &quot;end&quot; argument to
the declaration of member do_monthname as follows:</p>

<pre>  virtual iter_type do_get_monthname(iter_type s, iter_type end, ios_base&amp;,
                                     ios_base::iostate&amp; err, tm* t) const;</pre>
<hr>
<a name="74"><h3>74.&nbsp;Garbled text for <tt>codecvt::do_max_length</tt>
</h3></a><p>
<b>Section:</b>&nbsp;22.2.1.5.2 <a href="lib-locales.html#lib.locale.codecvt.virtuals"> [lib.locale.codecvt.virtuals]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Matt Austern&nbsp; <b>Date:</b>&nbsp;8 Sep 1998</p>
<p>The text of <tt>codecvt::do_max_length</tt>'s &quot;Returns&quot;
clause (22.2.1.5.2, paragraph 11) is garbled. It has unbalanced
parentheses and a spurious <b>n</b>.</p>
<p><b>Proposed resolution:</b></p>
<p>Replace 22.2.1.5.2  paragraph 11 with the
following:</p>

<blockquote>
  <b>Returns</b>: The maximum value that
  <tt>do_length(state, from, from_end, 1)</tt> can return for any
  valid range <tt>[from, from_end)</tt> and <tt>stateT</tt> value
  <tt>state</tt>. The specialization <tt>codecvt&lt;char, char,
  mbstate_t&gt;::do_max_length()</tt> returns 1.
</blockquote>
<hr>
<a name="75"><h3>75.&nbsp;Contradiction in <tt>codecvt::length</tt>'s argument types</h3></a><p>
<b>Section:</b>&nbsp;22.2.1.5 <a href="lib-locales.html#lib.locale.codecvt"> [lib.locale.codecvt]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp; Matt
Austern&nbsp; <b>Date:</b>&nbsp; 18 Sep 1998</p>
<p>The class synopses for classes <tt>codecvt&lt;&gt;</tt> (22.2.1.5)
and <tt>codecvt_byname&lt;&gt;</tt> (22.2.1.6) say that the first
parameter of the member functions <tt>length</tt> and
<tt>do_length</tt> is of type <tt>const stateT&amp;</tt>. The member
function descriptions, however (22.2.1.5.1, paragraph 6; 22.2.1.5.2,
paragraph 9) say that the type is <tt>stateT&amp;</tt>.  Either the
synopsis or the summary must be changed. </p>

<p>If (as I believe) the member function descriptions are correct,
then we must also add text saying how <tt>do_length</tt> changes its
<tt>stateT</tt> argument. </p>
<p><b>Proposed resolution:</b></p>
<p>In 22.2.1.5 , and also in 22.2.1.6 ,
change the <tt>stateT</tt> argument type on both member
<tt>length()</tt> and member <tt>do_length()</tt> from </p>

<blockquote>
  <p><tt>const stateT&amp;</tt></p>
</blockquote>

<p>to</p>

<blockquote>
  <p><tt>stateT&amp;</tt></p>
</blockquote>

<p>In 22.2.1.5.2 , add to the definition for member
<tt>do_length</tt> a paragraph:</p>

<blockquote>
  <p>Effects: The effect on the <tt>state</tt> argument is ``as if''
  it called <tt>do_in(state, from, from_end, from, to, to+max,
  to)</tt> for <tt>to</tt> pointing to a buffer of at least
  <tt>max</tt> elements.</p>
</blockquote>
<hr>
<a name="78"><h3>78.&nbsp;Typo: event_call_back</h3></a><p>
<b>Section:</b>&nbsp;27.4.2 <a href="lib-iostreams.html#lib.ios.base"> [lib.ios.base]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Nico Josuttis&nbsp; <b>Date:</b>&nbsp;29 Sep 1998</p>
<p>typo: event_call_back should be event_callback &nbsp; </p>
<p><b>Proposed resolution:</b></p>
<p>In the 27.4.2  synopsis change
&quot;event_call_back&quot; to &quot;event_callback&quot;. </p>
<hr>
<a name="79"><h3>79.&nbsp;Inconsistent declaration of polar()</h3></a><p>
<b>Section:</b>&nbsp;26.2.1 <a href="lib-numerics.html#lib.complex.synopsis"> [lib.complex.synopsis]</a>, 26.2.7 <a href="lib-numerics.html#lib.complex.value.ops"> [lib.complex.value.ops]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Nico Josuttis&nbsp; <b>Date:</b>&nbsp;29 Sep 1998</p>
<p>In 26.2.1  polar is declared as follows:</p>
<pre>   template&lt;class T&gt; complex&lt;T&gt; polar(const T&amp;, const T&amp;); </pre>

<p>In 26.2.7  it is declared as follows:</p>
<pre>   template&lt;class T&gt; complex&lt;T&gt; polar(const T&amp; rho, const T&amp; theta = 0); </pre>

<p>Thus whether the second parameter is optional is not clear. </p>
<p><b>Proposed resolution:</b></p>
<p>In 26.2.1  change:</p>
<pre>   template&lt;class T&gt; complex&lt;T&gt; polar(const T&amp;, const T&amp;);</pre>

<p>to:</p>
<pre>   template&lt;class T&gt; complex&lt;T&gt; polar(const T&amp; rho, const T&amp; theta = 0); </pre>
<hr>
<a name="80"><h3>80.&nbsp;Global Operators of complex declared twice</h3></a><p>
<b>Section:</b>&nbsp;26.2.1 <a href="lib-numerics.html#lib.complex.synopsis"> [lib.complex.synopsis]</a>, 26.2.2 <a href="lib-numerics.html#lib.complex"> [lib.complex]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Nico Josuttis&nbsp; <b>Date:</b>&nbsp;29 Sep 1998</p>
<p>Both 26.2.1 and 26.2.2 contain declarations of global operators for
class complex. This redundancy should be removed.</p>
<p><b>Proposed resolution:</b></p>
<p>Reduce redundancy according to the general style of the standard. </p>
<hr>
<a name="83"><h3>83.&nbsp;String::npos vs. string::max_size()</h3></a><p>
<b>Section:</b>&nbsp;21.3 <a href="lib-strings.html#lib.basic.string"> [lib.basic.string]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Nico Josuttis&nbsp; <b>Date:</b>&nbsp;29 Sep 1998</p>
<p>Many string member functions throw if size is getting or exceeding
npos. However, I wonder why they don't throw if size is getting or
exceeding max_size() instead of npos.  May be npos is known at compile
time, while max_size() is known at runtime. However, what happens if
size exceeds max_size() but not npos, then? It seems the standard
lacks some clarifications here.</p>
<p><b>Proposed resolution:</b></p>
<p>After 21.3  paragraph 4 (&quot;The functions
described in this clause...&quot;) add a new paragraph:</p>

<blockquote>
  <p>For any string operation, if as a result of the operation, <tt> size()</tt> would exceed
  <tt> max_size()</tt> then
  the operation throws <tt>length_error</tt>.</p>
</blockquote>
<p><b>Rationale:</b></p>
<p>The LWG believes length_error is the correct exception to throw.</p>
<hr>
<a name="86"><h3>86.&nbsp;String constructors don't describe exceptions</h3></a><p>
<b>Section:</b>&nbsp;21.3.1 <a href="lib-strings.html#lib.string.cons"> [lib.string.cons]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Nico Josuttis&nbsp; <b>Date:</b>&nbsp;29 Sep 1998</p>
<p>The constructor from a range:</p>

<pre>template&lt;class InputIterator&gt; 
         basic_string(InputIterator begin, InputIterator end, 
                      const Allocator&amp; a = Allocator());</pre>

<p>lacks a throws clause. However, I would expect that it throws
according to the other constructors if the numbers of characters in
the range equals npos (or exceeds max_size(), see above). </p>
<p><b>Proposed resolution:</b></p>
<p>In 21.3.1 , Strike throws paragraphs for
constructors which say &quot;Throws: length_error if n ==
npos.&quot;</p>
<p><b>Rationale:</b></p>
<p>Throws clauses for length_error if n == npos are no longer needed
because they are subsumed by the general wording added by the
resolution for issue <a href="lwg-defects.html#83">83</a>.</p>
<hr>
<a name="90"><h3>90.&nbsp;Incorrect description of operator &gt;&gt; for strings</h3></a><p>
<b>Section:</b>&nbsp;21.3.7.9 <a href="lib-strings.html#lib.string.io"> [lib.string.io]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Nico Josuttis&nbsp; <b>Date:</b>&nbsp;29 Sep 1998</p>
<p>The effect of operator &gt;&gt; for strings contain the following item:</p>

<p>&nbsp;&nbsp;&nbsp; <tt>isspace(c,getloc())</tt> is true for the next available input
character c.</p>

<p>Here <tt>getloc()</tt> has to be replaced by <tt>is.getloc()</tt>. </p>
<p><b>Proposed resolution:</b></p>
<p>In 21.3.7.9  paragraph 1 Effects clause replace:</p>

<blockquote>
  <p>
<tt>isspace(c,getloc())</tt> is true for the next available input character c.</p>
</blockquote>

<p>with:</p>

<blockquote>
  <p>
<tt>isspace(c,is.getloc())</tt> is true for the next available input character c.</p>
</blockquote>
<hr>
<a name="103"><h3>103.&nbsp;set::iterator is required to be modifiable, but this allows modification of keys</h3></a><p>
<b>Section:</b>&nbsp;23.1.2 <a href="lib-containers.html#lib.associative.reqmts"> [lib.associative.reqmts]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;AFNOR&nbsp; <b>Date:</b>&nbsp;7 Oct 1998</p>
<p>Set::iterator is described as implementation-defined with a
reference to the container requirement; the container requirement says
that const_iterator is an iterator pointing to const T and iterator an
iterator pointing to T.</p>

<p>23.1.2 paragraph 2 implies that the keys should not be modified to
break the ordering of elements. But that is not clearly
specified. Especially considering that the current standard requires
that iterator for associative containers be different from
const_iterator. Set, for example, has the following: </p>

<p><tt>typedef implementation defined iterator;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // See _lib.container.requirements_</tt></p>

<p>23.1  actually requires that iterator type pointing
to T (table 65). Disallowing user modification of keys by changing the
standard to require an iterator for associative container to be the
same as const_iterator would be overkill since that will unnecessarily
significantly restrict the usage of associative container. A class to
be used as elements of set, for example, can no longer be modified
easily without either redesigning the class (using mutable on fields
that have nothing to do with ordering), or using const_cast, which
defeats requiring iterator to be const_iterator. The proposed solution
goes in line with trusting user knows what he is doing. <a href="lib-containers.html#lib.container.requirements"> [lib.container.requirements]</a>
</p>

<p>
<b>Other Options Evaluated:</b> </p>

<p>Option A.&nbsp;&nbsp; In 23.1.2 , paragraph 2, after
first sentence, and before &quot;In addition,...&quot;, add one line:
</p>

<blockquote>
  <p>Modification of keys shall not change their strict weak ordering. </p>
</blockquote>

<p>Option B.&nbsp;Add three new sentences to 23.1.2 :</p>

<blockquote>
  <p>At the end of paragraph 5: &quot;Keys in an associative container
  are immutable.&quot; At the end of paragraph 6: &quot;For
  associative containers where the value type is the same as the key
  type, both <tt>iterator</tt> and <tt>const_iterator</tt> are
  constant iterators. It is unspecified whether or not
  <tt>iterator</tt> and <tt>const_iterator</tt> are the same
  type.&quot;</p>
</blockquote>

<p>Option C.&nbsp;To 23.1.2 , paragraph 3, which
currently reads:</p>

<blockquote>
  <p>The phrase ``equivalence of keys'' means the equivalence relation imposed by the
  comparison and not the operator== on keys. That is, two keys k1 and k2 in the same
  container are considered to be equivalent if for the comparison object comp, comp(k1, k2)
  == false &amp;&amp; comp(k2, k1) == false.</p>
</blockquote>

<p>&nbsp; add the following:</p>

<blockquote>
  <p>For any two keys k1 and k2 in the same container, comp(k1, k2) shall return the same
  value whenever it is evaluated. [Note: If k2 is removed from the container and later
  reinserted, comp(k1, k2) must still return a consistent value but this value may be
  different than it was the first time k1 and k2 were in the same container. This is
  intended to allow usage like a string key that contains a filename, where comp compares
  file contents; if k2 is removed, the file is changed, and the same k2 (filename) is
  reinserted, comp(k1, k2) must again return a consistent value but this value may be
  different than it was the previous time k2 was in the container.]</p>
</blockquote>
<p><b>Proposed resolution:</b></p>
<p>Add the following to 23.1.2  at
the indicated location:</p>

<blockquote>
  <p>At the end of paragraph 3: &quot;For any two keys k1 and k2 in the same container,
  calling comp(k1, k2) shall always return the same
  value.&quot;</p>
  <p>At the end of paragraph 5: &quot;Keys in an associative container are immutable.&quot;</p>
  <p>At the end of paragraph 6: &quot;For associative containers where the value type is the
  same as the key type, both <tt>iterator</tt> and <tt>const_iterator</tt> are constant
  iterators. It is unspecified whether or not <tt>iterator</tt> and <tt>const_iterator</tt>
  are the same type.&quot;</p>
</blockquote>
<p><b>Rationale:</b></p>
<p>Several arguments were advanced for and against allowing set elements to be
mutable as long as the ordering was not effected. The argument which swayed the
LWG was one of safety; if elements were mutable, there would be no compile-time
way to detect of a simple user oversight which caused ordering to be
modified.  There was a report that this had actually happened in practice,
and had been painful to diagnose.  If users need to modify elements,
it is possible to use mutable members or const_cast.</p>

<p>Simply requiring that keys be immutable is not sufficient, because the comparison
object may indirectly (via pointers) operate on values outside of the keys.</p>

<p>
The types <tt>iterator</tt> and <tt>const_iterator</tt> are permitted
to be different types to allow for potential future work in which some
member functions might be overloaded between the two types.  No such
member functions exist now, and the LWG believes that user functionality
will not be impaired by permitting the two types to be the same.  A
function that operates on both iterator types can be defined for 
<tt>const_iterator</tt> alone, and can rely on the automatic
conversion from <tt>iterator</tt> to <tt>const_iterator</tt>.
</p>

<p><i>[Tokyo: The LWG crafted the proposed resolution and rationale.]</i></p>
<hr>
<a name="106"><h3>106.&nbsp;Numeric library private members are implementation defined</h3></a><p>
<b>Section:</b>&nbsp;26.3.5 <a href="lib-numerics.html#lib.template.slice.array"> [lib.template.slice.array]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;AFNOR&nbsp; <b>Date:</b>&nbsp;7 Oct 1998</p>
<p>This is the only place in the whole standard where the implementation has to document
something private.</p>
<p><b>Proposed resolution:</b></p>
<p>
Remove the comment which says &quot;// remainder implementation defined&quot; from:
</p>

<ul>
  <li>26.3.5 <a href="lib-numerics.html#lib.template.slice.array"> [lib.template.slice.array]</a>
</li>
  <li>26.3.7 <a href="lib-numerics.html#lib.template.gslice.array"> [lib.template.gslice.array]</a>
</li>
  <li>26.3.8 <a href="lib-numerics.html#lib.template.mask.array"> [lib.template.mask.array]</a>
</li>
  <li>26.3.9 <a href="lib-numerics.html#lib.template.indirect.array"> [lib.template.indirect.array]</a>
</li>
</ul>
<hr>
<a name="108"><h3>108.&nbsp;Lifetime of exception::what() return unspecified</h3></a><p>
<b>Section:</b>&nbsp;18.6.1 <a href="lib-support.html#lib.exception"> [lib.exception]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;AFNOR&nbsp; <b>Date:</b>&nbsp;7 Oct 1998</p>
<p>In 18.6.1, paragraphs 8-9, the lifetime of the return value of
exception::what() is left unspecified. This issue has implications
with exception safety of exception handling: some exceptions should
not throw bad_alloc.</p>
<p><b>Proposed resolution:</b></p>
<p>Add to 18.6.1  paragraph 9 (exception::what notes
clause) the sentence:</p>

<blockquote>
  <p>The return value remains valid until the exception object from which it is obtained is
  destroyed or a non-const member function of the exception object is called.</p>
</blockquote>
<p><b>Rationale:</b></p>
<p>If an exception object has non-const members, they may be used
to set internal state that should affect the contents of the string
returned by <tt>what()</tt>.
</p>
<hr>
<a name="110"><h3>110.&nbsp;istreambuf_iterator::equal not const</h3></a><p>
<b>Section:</b>&nbsp;24.5.3 <a href="lib-iterators.html#lib.istreambuf.iterator"> [lib.istreambuf.iterator]</a>, 24.5.3.5 <a href="lib-iterators.html#lib.istreambuf.iterator::equal"> [lib.istreambuf.iterator::equal]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Nathan Myers&nbsp; <b>Date:</b>&nbsp;15 Oct 1998</p>
<p>Member istreambuf_iterator&lt;&gt;::equal is not declared
&quot;const&quot;, yet 24.5.3.6  says that operator==,
which is const, calls it. This is contradictory. </p>
<p><b>Proposed resolution:</b></p>
<p>In 24.5.3  and also in 24.5.3.5 ,
replace:</p>

<blockquote>
  <pre>bool equal(istreambuf_iterator&amp; b);</pre>
</blockquote>

<p>with:</p>

<blockquote>
  <pre>bool equal(const istreambuf_iterator&amp; b) const;</pre>
</blockquote>
<hr>
<a name="112"><h3>112.&nbsp;Minor typo in <tt>ostreambuf_iterator</tt> constructor</h3></a><p>
<b>Section:</b>&nbsp;24.5.4.1 <a href="lib-iterators.html#lib.ostreambuf.iter.cons"> [lib.ostreambuf.iter.cons]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Matt Austern&nbsp; <b>Date:</b>&nbsp;20 Oct 1998</p>
<p>The <b>requires</b> clause for <tt>ostreambuf_iterator</tt>'s
constructor from an <tt>ostream_type</tt> (24.5.4.1, paragraph 1)
reads &quot;<i>s</i> is not null&quot;. However, <i>s</i> is a
reference, and references can't be null. </p>
<p><b>Proposed resolution:</b></p>
<p>In 24.5.4.1 :</p>

<p>Move the current paragraph 1, which reads &quot;Requires: s is not
null.&quot;, from the first constructor to the second constructor.</p>

<p>Insert a new paragraph 1 Requires clause for the first constructor
reading:</p>

<blockquote>
  <p>
<b>Requires</b>: <tt>s.rdbuf()</tt> is not null.</p>
</blockquote>
<hr>
<a name="114"><h3>114.&nbsp;Placement forms example in error twice</h3></a><p>
<b>Section:</b>&nbsp;18.4.1.3 <a href="lib-support.html#lib.new.delete.placement"> [lib.new.delete.placement]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Steve Clamage&nbsp; <b>Date:</b>&nbsp;28 Oct 1998</p>
<p>Section 18.4.1.3 contains the following example: </p>

<pre>[Example: This can be useful for constructing an object at a known address:
        char place[sizeof(Something)];
        Something* p = new (place) Something();
 -end example]</pre>

<p>First code line: &quot;place&quot; need not have any special alignment, and the
following constructor could fail due to misaligned data.</p>

<p>Second code line: Aren't the parens on Something() incorrect?&nbsp; [Dublin: the LWG
believes the () are correct.]</p>

<p>Examples are not normative, but nevertheless should not show code that is invalid or
likely to fail.</p>
<p><b>Proposed resolution:</b></p>
<p>Replace the <u> first line of code</u> in the example in 
18.4.1.3  with:
</p>

<blockquote>
  <pre>void* place = operator new(sizeof(Something));</pre>
</blockquote>
<hr>
<a name="115"><h3>115.&nbsp;Typo in strstream constructors</h3></a><p>
<b>Section:</b>&nbsp;D.7.4.1 <a href="future.html#depr.strstream.cons"> [depr.strstream.cons]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Steve Clamage&nbsp; <b>Date:</b>&nbsp;2 Nov 1998</p>
<p>D.7.4.1 strstream constructors paragraph 2 says: </p>

<blockquote>
  <p>Effects: Constructs an object of class strstream, initializing the base class with
  iostream(&amp; sb) and initializing sb with one of the two constructors: </p>
  <p>- If mode&amp;app==0, then s shall designate the first element of an array of n
  elements. The constructor is strstreambuf(s, n, s). </p>
  <p>- If mode&amp;app==0, then s shall designate the first element of an array of n
  elements that contains an NTBS whose first element is designated by s. The constructor is
  strstreambuf(s, n, s+std::strlen(s)).</p>
</blockquote>

<p>Notice the second condition is the same as the first. I think the second condition
should be &quot;If mode&amp;app==app&quot;, or &quot;mode&amp;app!=0&quot;, meaning that
the append bit is set.</p>
<p><b>Proposed resolution:</b></p>
<p>In D.7.3.1  paragraph 2 and D.7.4.1 
paragraph 2, change the first condition to <tt>(mode&amp;app)==0</tt>
and the second condition to <tt>(mode&amp;app)!=0</tt>.</p>
<hr>
<a name="118"><h3>118.&nbsp;<tt>basic_istream</tt> uses nonexistent <tt>num_get</tt> member functions</h3></a><p>
<b>Section:</b>&nbsp;27.6.1.2.2 <a href="lib-iostreams.html#lib.istream.formatted.arithmetic"> [lib.istream.formatted.arithmetic]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Matt Austern&nbsp; <b>Date:</b>&nbsp;20 Nov 1998</p>
<p>Formatted input is defined for the types <tt>short</tt>, <tt>unsigned short</tt>, <tt>int</tt>,
<tt>unsigned int</tt>, <tt>long</tt>, <tt>unsigned long</tt>, <tt>float</tt>, <tt>double</tt>,
<tt>long double</tt>, <tt>bool</tt>, and <tt>void*</tt>. According to section 27.6.1.2.2,
formatted input of a value <tt>x</tt> is done as if by the following code fragment: </p>

<pre>typedef num_get&lt; charT,istreambuf_iterator&lt;charT,traits&gt; &gt; numget; 
iostate err = 0; 
use_facet&lt; numget &gt;(loc).get(*this, 0, *this, err, val); 
setstate(err);</pre>

<p>According to section 22.2.2.1.1 , however,
<tt>num_get&lt;&gt;::get()</tt> is only overloaded for the types
<tt>bool</tt>, <tt>long</tt>, <tt>unsigned short</tt>, <tt>unsigned
int</tt>, <tt>unsigned long</tt>, <tt>unsigned long</tt>,
<tt>float</tt>, <tt>double</tt>, <tt>long double</tt>, and
<tt>void*</tt>. Comparing the lists from the two sections, we find
that 27.6.1.2.2 is using a nonexistent function for types
<tt>short</tt> and <tt>int</tt>. </p>
<p><b>Proposed resolution:</b></p>
<p>In 27.6.1.2.2  Arithmetic Extractors, remove the
two lines (1st and 3rd) which read:</p>
<blockquote>
  <pre>operator&gt;&gt;(short&amp; val);
...
operator&gt;&gt;(int&amp; val);</pre>
</blockquote>

<p>And add the following at the end of that section (27.6.1.2.2) :</p>

<blockquote>
  <pre>operator&gt;&gt;(short&amp; val);</pre>
  <p>The conversion occurs as if performed by the following code fragment (using
  the same notation as for the preceding code fragment):</p>
  <pre>  typedef num_get&lt; charT,istreambuf_iterator&lt;charT,traits&gt; &gt; numget;
  iostate err = 0;
  long lval;
  use_facet&lt; numget &gt;(loc).get(*this, 0, *this, err, lval);
        if (err == 0
                &amp;&amp; (lval &lt; numeric_limits&lt;short&gt;::min() || numeric_limits&lt;short&gt;::max() &lt; lval))
                err = ios_base::failbit;
  setstate(err);</pre>
  <pre>operator&gt;&gt;(int&amp; val);</pre>
  <p>The conversion occurs as if performed by the following code fragment (using
  the same notation as for the preceding code fragment):</p>
  <pre>  typedef num_get&lt; charT,istreambuf_iterator&lt;charT,traits&gt; &gt; numget;
  iostate err = 0;
  long lval;
  use_facet&lt; numget &gt;(loc).get(*this, 0, *this, err, lval);
        if (err == 0
                &amp;&amp; (lval &lt; numeric_limits&lt;int&gt;::min() || numeric_limits&lt;int&gt;::max() &lt; lval))
                err = ios_base::failbit;
  setstate(err);</pre>
</blockquote>

<p><i>[Post-Tokyo: PJP provided the above wording.]</i></p>
<hr>
<a name="119"><h3>119.&nbsp;Should virtual functions be allowed to strengthen the exception specification?</h3></a><p>
<b>Section:</b>&nbsp;17.4.4.8 <a href="lib-intro.html#lib.res.on.exception.handling"> [lib.res.on.exception.handling]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Judy Ward&nbsp; <b>Date:</b>&nbsp;15 Dec 1998</p>
<p>Section 17.4.4.8  states: </p>

<p>&quot;An implementation may strengthen the exception-specification
for a function by removing listed exceptions.&quot; </p>

<p>The problem is that if an implementation is allowed to do this for
virtual functions, then a library user cannot write a class that
portably derives from that class. </p>

<p>For example, this would not compile if ios_base::failure::~failure
had an empty exception specification: </p>

<pre>#include &lt;ios&gt;
#include &lt;string&gt;

class D : public std::ios_base::failure {
public:
        D(const std::string&amp;);
        ~D(); // error - exception specification must be compatible with 
              // overridden virtual function ios_base::failure::~failure()
};</pre>
<p><b>Proposed resolution:</b></p>
<p>Change Section 17.4.4.8  from:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp; &quot;may strengthen the
exception-specification for a function&quot;</p>

<p>to:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp; &quot;may strengthen the
exception-specification for a non-virtual function&quot;. </p>
<hr>
<a name="122"><h3>122.&nbsp;streambuf/wstreambuf description should not say they are specializations</h3></a><p>
<b>Section:</b>&nbsp;27.5.2 <a href="lib-iostreams.html#lib.streambuf"> [lib.streambuf]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Judy Ward&nbsp; <b>Date:</b>&nbsp;15 Dec 1998</p>
<p>Section 27.5.2 describes the streambuf classes this way: </p>

<blockquote>

<p>The class streambuf is a specialization of the template class basic_streambuf
specialized for the type char. </p>

<p>The class wstreambuf is a specialization of the template class basic_streambuf
specialized for the type wchar_t. </p>

</blockquote>

<p>This implies that these classes must be template specializations, not typedefs. </p>

<p>It doesn't seem this was intended, since Section 27.5 has them declared as typedefs. </p>
<p><b>Proposed resolution:</b></p>
<p>Remove 27.5.2  paragraphs 2 and 3 (the above two
sentences). </p>
<p><b>Rationale:</b></p>
<p>The <tt>streambuf</tt>  synopsis already has a declaration for the
typedefs and that is sufficient. </p>
<hr>
<a name="124"><h3>124.&nbsp;ctype_byname&lt;charT&gt;::do_scan_is &amp; do_scan_not return type should be const charT*</h3></a><p>
<b>Section:</b>&nbsp;22.2.1.2 <a href="lib-locales.html#lib.locale.ctype.byname"> [lib.locale.ctype.byname]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Judy Ward&nbsp; <b>Date:</b>&nbsp;15 Dec 1998</p>
<p>In Section 22.2.1.2 
ctype_byname&lt;charT&gt;::do_scan_is() and do_scan_not() are declared
to return a const char* not a const charT*. </p>
<p><b>Proposed resolution:</b></p>
<p>Change Section 22.2.1.2  <tt>do_scan_is()</tt> and
<tt>do_scan_not()</tt> to return a <tt> const
charT*</tt>. </p>
<hr>
<a name="125"><h3>125.&nbsp;valarray&lt;T&gt;::operator!() return type is inconsistent</h3></a><p>
<b>Section:</b>&nbsp;26.3.2 <a href="lib-numerics.html#lib.template.valarray"> [lib.template.valarray]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Judy Ward&nbsp; <b>Date:</b>&nbsp;15 Dec 1998</p>
<p>In Section 26.3.2  valarray&lt;T&gt;::operator!() is
declared to return a valarray&lt;T&gt;, but in Section 26.3.2.5  it is declared to return a valarray&lt;bool&gt;. The
latter appears to be correct. </p>
<p><b>Proposed resolution:</b></p>
<p>Change in Section 26.3.2  the declaration of
<tt>operator!()</tt> so that the return type is
<tt>valarray&lt;bool&gt;</tt>. </p>
<hr>
<a name="126"><h3>126.&nbsp;typos in Effects clause of ctype::do_narrow()</h3></a><p>
<b>Section:</b>&nbsp;22.2.1.1.2 <a href="lib-locales.html#lib.locale.ctype.virtuals"> [lib.locale.ctype.virtuals]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Judy Ward&nbsp; <b>Date:</b>&nbsp;15 Dec 1998</p>
<p>Typos in 22.2.1.1.2 need to be fixed.</p>
<p><b>Proposed resolution:</b></p>
<p>In Section 22.2.1.1.2  change: </p>

<pre>   do_widen(do_narrow(c),0) == c</pre>

<p>to:</p>

<pre>   do_widen(do_narrow(c,0)) == c</pre>

<p>and change:</p>

<pre>   (is(M,c) || !ctc.is(M, do_narrow(c),dfault) )</pre>

<p>to:</p>

<pre>   (is(M,c) || !ctc.is(M, do_narrow(c,dfault)) )</pre>
<hr>
<a name="127"><h3>127.&nbsp;auto_ptr&lt;&gt; conversion issues</h3></a><p>
<b>Section:</b>&nbsp;20.4.5 <a href="lib-utilities.html#lib.auto.ptr"> [lib.auto.ptr]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Greg Colvin&nbsp; <b>Date:</b>&nbsp;17 Feb 1999</p>
<p>There are two problems with the current <tt>auto_ptr</tt> wording
in the standard: </p>

<p>First, the <tt>auto_ptr_ref</tt> definition cannot be nested
because <tt>auto_ptr&lt;Derived&gt;::auto_ptr_ref</tt> is unrelated to
<tt>auto_ptr&lt;Base&gt;::auto_ptr_ref</tt>.  <i>Also submitted by
Nathan Myers, with the same proposed resolution.</i>
</p>

<p>Second, there is no <tt>auto_ptr</tt> assignment operator taking an
<tt>auto_ptr_ref</tt> argument. </p>

<p>I have discussed these problems with my proposal coauthor, Bill
Gibbons, and with some compiler and library implementors, and we
believe that these problems are not desired or desirable implications
of the standard. </p>

<p>25 Aug 1999: The proposed resolution now reflects changes suggested
by Dave Abrahams, with Greg Colvin's concurrence; 1) changed
&quot;assignment operator&quot; to &quot;public assignment
operator&quot;, 2) changed effects to specify use of release(), 3)
made the conversion to auto_ptr_ref const. </p>

<p>2 Feb 2000: Lisa Lippincott comments: [The resolution of] this issue
states that the conversion from auto_ptr to auto_ptr_ref should
be const.  This is not acceptable, because it would allow
initialization and assignment from _any_ const auto_ptr!  It also
introduces an implementation difficulty in writing this conversion
function -- namely, somewhere along the line, a const_cast will be
necessary to remove that const so that release() may be called.  This
may result in undefined behavior [7.1.5.1/4]. The conversion
operator does not have to be const, because a non-const implicit
object parameter may be bound to an rvalue [13.3.3.1.4/3]
[13.3.1/5]. </p>

  <p>Tokyo: The LWG removed the following from the proposed resolution:</p>

  <p>In 20.4.5 , paragraph 2, and 20.4.5.3 , 
  paragraph 2, make the conversion to auto_ptr_ref const:</p>
  <blockquote>
    <pre>template&lt;class Y&gt; operator auto_ptr_ref&lt;Y&gt;() const throw();</pre>
  </blockquote>
<p><b>Proposed resolution:</b></p>
<p>In 20.4.5 , paragraph 2, move
the <tt>auto_ptr_ref</tt> definition to namespace scope.</p>

<p>In 20.4.5 , paragraph 2, add
a public assignment operator to the <tt>auto_ptr</tt> definition: </p>

<blockquote>
  <pre>auto_ptr&amp; operator=(auto_ptr_ref&lt;X&gt; r) throw();</pre>
</blockquote>

<p>Also add the assignment operator to 20.4.5.3 : </p>

<blockquote>
  <pre>auto_ptr&amp; operator=(auto_ptr_ref&lt;X&gt; r) throw()</pre>

  <b>Effects:</b> Calls <tt>reset(p.release())</tt> for the <tt>auto_ptr
  p</tt> that <tt>r</tt> holds a reference to.<br>
  <b>Returns: </b><tt>*this</tt>.

</blockquote>
<hr>
<a name="129"><h3>129.&nbsp;Need error indication from seekp() and seekg()</h3></a><p>
<b>Section:</b>&nbsp;27.6.1.3 <a href="lib-iostreams.html#lib.istream.unformatted"> [lib.istream.unformatted]</a>, 27.6.2.4 <a href="lib-iostreams.html#lib.ostream.seeks"> [lib.ostream.seeks]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Angelika Langer&nbsp; <b>Date:</b>&nbsp;22 Feb 1999</p>
<p>Currently, the standard does not specify how seekg() and seekp()
indicate failure. They are not required to set failbit, and they can't
return an error indication because they must return *this, i.e. the
stream. Hence, it is undefined what happens if they fail. And they
<i>can</i> fail, for instance, when a file stream is disconnected from the
underlying file (is_open()==false) or when a wide character file
stream must perform a state-dependent code conversion, etc. </p>

<p>The stream functions seekg() and seekp() should set failbit in the
stream state in case of failure.</p>
<p><b>Proposed resolution:</b></p>
<p>Add to the Effects: clause of&nbsp; seekg() in 
27.6.1.3  and to the Effects: clause of seekp() in
27.6.2.4 : </p>

<blockquote>
  <p>In case of failure, the function calls <tt>setstate(failbit)</tt> (which may throw <tt>ios_base::failure</tt>).
  </p>
</blockquote>
<p><b>Rationale:</b></p>
<p>Setting failbit is the usual error reporting mechanism for streams</p>
<hr>
<a name="132"><h3>132.&nbsp;list::resize description uses random access iterators</h3></a><p>
<b>Section:</b>&nbsp;23.2.2.2 <a href="lib-containers.html#lib.list.capacity"> [lib.list.capacity]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Howard Hinnant&nbsp; <b>Date:</b>&nbsp;6 Mar 1999</p>
<p>The description reads:</p>

<p>-1- Effects:</p>

<pre>         if (sz &gt; size())
           insert(end(), sz-size(), c);
         else if (sz &lt; size())
           erase(begin()+sz, end());
         else
           ;                           //  do nothing</pre>

<p>Obviously list::resize should not be specified in terms of random access iterators.</p>
<p><b>Proposed resolution:</b></p>
<p>Change 23.2.2.2 paragraph 1 to:</p>

<p>Effects:</p>

<pre>         if (sz &gt; size())
           insert(end(), sz-size(), c);
         else if (sz &lt; size())
         {
           iterator i = begin();
           advance(i, sz);
           erase(i, end());
         }</pre>

<p><i>[Dublin: The LWG asked Howard to discuss exception safety offline
with David Abrahams. They had a discussion and believe there is
no issue of exception safety with the proposed resolution.]</i></p>
<hr>
<a name="133"><h3>133.&nbsp;map missing get_allocator()</h3></a><p>
<b>Section:</b>&nbsp;23.3.1 <a href="lib-containers.html#lib.map"> [lib.map]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Howard Hinnant&nbsp; <b>Date:</b>&nbsp;6 Mar 1999</p>
<p>The title says it all.</p>
<p><b>Proposed resolution:</b></p>
<p>Insert in 23.3.1 , paragraph 2,
after operator= in the map declaration:</p>

<pre>    allocator_type get_allocator() const;</pre>
<hr>
<a name="134"><h3>134.&nbsp;vector constructors over specified</h3></a><p>
<b>Section:</b>&nbsp;23.2.4.1 <a href="lib-containers.html#lib.vector.cons"> [lib.vector.cons]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Howard Hinnant&nbsp; <b>Date:</b>&nbsp;6 Mar 1999</p>
<p>The complexity description says: &quot;It does at most 2N calls to the copy constructor
of T and logN reallocations if they are just input iterators ...&quot;.</p>

<p>This appears to be overly restrictive, dictating the precise memory/performance
tradeoff for the implementor.</p>
<p><b>Proposed resolution:</b></p>
<p>Change 23.2.4.1 , paragraph 1 to:</p>

<p>-1- Complexity: The constructor template &lt;class
InputIterator&gt; vector(InputIterator first, InputIterator last)
makes only N calls to the copy constructor of T (where N is the
distance between first and last) and no reallocations if iterators
first and last are of forward, bidirectional, or random access
categories. It makes order N calls to the copy constructor of T and
order logN reallocations if they are just input iterators.
</p>
<p><b>Rationale:</b></p>
<p>&quot;at most 2N calls&quot; is correct only if the growth factor
is greater than or equal to 2.
</p>
<hr>
<a name="136"><h3>136.&nbsp;seekp, seekg setting wrong streams?</h3></a><p>
<b>Section:</b>&nbsp;27.6.1.3 <a href="lib-iostreams.html#lib.istream.unformatted"> [lib.istream.unformatted]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Howard Hinnant&nbsp; <b>Date:</b>&nbsp;6 Mar 1999</p>
<p>I may be misunderstanding the intent, but should not seekg set only
the input stream and seekp set only the output stream? The description
seems to say that each should set both input and output streams. If
that's really the intent, I withdraw this proposal.</p>
<p><b>Proposed resolution:</b></p>
<p>In section 27.6.1.3 change:</p>

<pre>basic_istream&lt;charT,traits&gt;&amp; seekg(pos_type pos);
Effects: If fail() != true, executes rdbuf()-&gt;pubseekpos(pos). </pre>

<p>To:</p>

<pre>basic_istream&lt;charT,traits&gt;&amp; seekg(pos_type pos);
Effects: If fail() != true, executes rdbuf()-&gt;pubseekpos(pos, ios_base::in). </pre>

<p>In section 27.6.1.3 change:</p>

<pre>basic_istream&lt;charT,traits&gt;&amp; seekg(off_type&amp; off, ios_base::seekdir dir);
Effects: If fail() != true, executes rdbuf()-&gt;pubseekoff(off, dir). </pre>

<p>To:</p>

<pre>basic_istream&lt;charT,traits&gt;&amp; seekg(off_type&amp; off, ios_base::seekdir dir);
Effects: If fail() != true, executes rdbuf()-&gt;pubseekoff(off, dir, ios_base::in). </pre>

<p>In section 27.6.2.4, paragraph 2 change:</p>

<pre>-2- Effects: If fail() != true, executes rdbuf()-&gt;pubseekpos(pos). </pre>

<p>To:</p>

<pre>-2- Effects: If fail() != true, executes rdbuf()-&gt;pubseekpos(pos, ios_base::out). </pre>

<p>In section 27.6.2.4, paragraph 4 change:</p>

<pre>-4- Effects: If fail() != true, executes rdbuf()-&gt;pubseekoff(off, dir). </pre>

<p>To:</p>

<pre>-4- Effects: If fail() != true, executes rdbuf()-&gt;pubseekoff(off, dir, ios_base::out). </pre>

<p><i>[Dublin: Dietmar K&uuml;hl thinks this is probably correct, but would
like the opinion of more iostream experts before taking action.]</i></p>

<p><i>[Tokyo: Reviewed by the LWG. PJP noted that although his docs are
incorrect, his implementation already implements the Proposed
Resolution.]</i></p>

<p><i>[Post-Tokyo: Matt Austern comments:<br>
Is it a problem with basic_istream and basic_ostream, or is it a problem
with basic_stringbuf?
We could resolve the issue either by changing basic_istream and
basic_ostream, or by changing basic_stringbuf. I prefer the latter
change (or maybe both changes): I don't see any reason for the standard to
require that std::stringbuf s(std::string(&quot;foo&quot;), std::ios_base::in);
s.pubseekoff(0, std::ios_base::beg); must fail.<br>
This requirement is a bit weird. There's no similar requirement
for basic_streambuf&lt;&gt;::seekpos, or for basic_filebuf&lt;&gt;::seekoff or
basic_filebuf&lt;&gt;::seekpos.]</i></p>
<hr>
<a name="137"><h3>137.&nbsp;Do use_facet and has_facet look in the global locale?</h3></a><p>
<b>Section:</b>&nbsp;22.1.1 <a href="lib-locales.html#lib.locale"> [lib.locale]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Angelika Langer&nbsp; <b>Date:</b>&nbsp;17 Mar 1999</p>
<p>Section 22.1.1  says:</p>

<p>-4- In the call to use_facet&lt;Facet&gt;(loc), the type argument
chooses a facet, making available all members of the named type. If
Facet is not present in a locale (or, failing that, in the global
locale), it throws the standard exception bad_cast. A C++ program can
check if a locale implements a particular facet with the template
function has_facet&lt;Facet&gt;(). </p>

<p>This contradicts the specification given in section 
22.1.2 :
<br><br>
template &lt;class&nbsp; Facet&gt; const&nbsp; Facet&amp; use_facet(const
locale&amp;&nbsp; loc); <br>
<br>
-1- Get a reference to a facet of a locale. <br>
-2- Returns: a reference to the corresponding facet of loc, if present. <br>
-3- Throws: bad_cast if has_facet&lt;Facet&gt;(loc) is false. <br>
-4- Notes: The reference returned remains valid at least as long as any copy of loc exists
</p>
<p><b>Proposed resolution:</b></p>
<p>Remove the phrase &quot;(or, failing that, in the global locale)&quot;
from section 22.1.1. </p>
<p><b>Rationale:</b></p>
<p>Needed for consistency with the way locales are handled elsewhere
in the standard.</p>
<hr>
<a name="139"><h3>139.&nbsp;Optional sequence operation table description unclear</h3></a><p>
<b>Section:</b>&nbsp;23.1.1 <a href="lib-containers.html#lib.sequence.reqmts"> [lib.sequence.reqmts]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Andrew Koenig&nbsp; <b>Date:</b>&nbsp;30 Mar 1999</p>
<p>The sentence introducing the Optional sequence operation table
(23.1.1 paragraph 12) has two problems:</p>

<p>A. It says ``The operations in table 68 are provided only for the containers for which
they take constant time.''<br>
<br>
That could be interpreted in two ways, one of them being ``Even though table 68 shows
particular operations as being provided, implementations are free to omit them if they
cannot implement them in constant time.''<br>
<br>
B. That paragraph says nothing about amortized constant time, and it should.&nbsp;</p>
<p><b>Proposed resolution:</b></p>
<p>Replace the wording in 23.1.1 paragraph 12&nbsp; which begins ``The operations in table 68 are provided only...&quot;
with:</p>

<blockquote>
  <p>Table 68 lists sequence operations that are provided for some types of sequential
  containers but not others. An implementation shall provide these operations for all
  container types shown in the ``container'' column, and shall implement them so as to take
  amortized constant time.</p>
</blockquote>
<hr>
<a name="141"><h3>141.&nbsp;basic_string::find_last_of, find_last_not_of say pos instead of xpos</h3></a><p>
<b>Section:</b>&nbsp;21.3.6.4 <a href="lib-strings.html#lib.string::find.last.of"> [lib.string::find.last.of]</a>, 21.3.6.6 <a href="lib-strings.html#lib.string::find.last.not.of"> [lib.string::find.last.not.of]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Arch Robison&nbsp; <b>Date:</b>&nbsp;28 Apr 1999</p>
<p>Sections 21.3.6.4 paragraph 1 and 21.3.6.6 paragraph 1 surely have misprints where they
say:<br>
<br>
&#x97; <tt>xpos &lt;= pos</tt> and <tt>pos &lt; size();</tt>
</p>

<p>Surely the document meant to say ``<tt>xpos &lt; size()</tt>'' in both places.</p>

<p><i>[Judy Ward also sent in this issue for 21.3.6.4 with the same
proposed resolution.]</i></p>
<p><b>Proposed resolution:</b></p>
<p>Change Sections 21.3.6.4 paragraph 1 and 21.3.6.6 paragraph 1, the line which says:<br>
<br>
&#x97; <tt>xpos &lt;= pos</tt> and <tt>pos &lt; size();<br>
<br>
</tt>to:<br>
<tt><br>
</tt>&#x97; <tt>xpos &lt;= pos</tt> and <tt>xpos &lt; size();</tt>
</p>
<hr>
<a name="142"><h3>142.&nbsp;lexicographical_compare complexity wrong</h3></a><p>
<b>Section:</b>&nbsp;25.3.8 <a href="lib-algorithms.html#lib.alg.lex.comparison"> [lib.alg.lex.comparison]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Howard Hinnant&nbsp; <b>Date:</b>&nbsp;20 Jun 1999</p>
<p>The lexicographical_compare complexity is specified as:<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp; &quot;At most min((last1 - first1), (last2 - first2))
applications of the corresponding comparison.&quot;<br>
<br>
The best I can do is twice that expensive.</p>

<p>Nicolai Josuttis comments in lib-6862: You mean, to check for
equality you have to check both &lt; and &gt;? Yes, IMO you are
right! (and Matt states this complexity in his book)</p>

<p><b>Proposed resolution:</b></p>
<p>Change 25.3.8  complexity to:</p>
    <blockquote>
    At most <tt>2*min((last1 - first1), (last2 - first2))</tt>
    applications of the corresponding comparison.
    </blockquote>

<p>Change the example at the end of paragraph 3 to read:</p>
    <blockquote>
    [Example:<br>
    <br>
    &nbsp;&nbsp;&nbsp; for ( ; first1 != last1 &amp;&amp; first2 != last2 ;
    ++first1, ++first2) {<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (*first1 &lt; *first2) return true;<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (*first2 &lt; *first1) return false;<br>
    &nbsp;&nbsp;&nbsp; }<br>
    &nbsp;&nbsp;&nbsp; return first1 == last1 &amp;&amp; first2 != last2;<br>
    &nbsp;&nbsp;&nbsp;<br>
    --end example]
    </blockquote>
<hr>
<a name="144"><h3>144.&nbsp;Deque constructor complexity wrong </h3></a><p>
<b>Section:</b>&nbsp;23.2.1.1 <a href="lib-containers.html#lib.deque.cons"> [lib.deque.cons]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Herb Sutter&nbsp; <b>Date:</b>&nbsp;9 May 1999</p>
<p>In 23.2.1.1 paragraph 6, the deque ctor that takes an iterator range appears
to have complexity requirements which are incorrect, and which contradict the
complexity requirements for insert(). I suspect that the text in question,
below, was taken from vector:</p>
<blockquote>
  <p>Complexity: If the iterators first and last are forward iterators,
  bidirectional iterators, or random access iterators the constructor makes only
  N calls to the copy constructor, and performs no reallocations, where N is
  last - first.</p>
</blockquote>
<p>The word &quot;reallocations&quot; does not really apply to deque. Further,
all of the following appears to be spurious:</p>
<blockquote>
  <p>It makes at most 2N calls to the copy constructor of T and log N
  reallocations if they are input iterators.1)</p>
  <p>1) The complexity is greater in the case of input iterators because each
  element must be added individually: it is impossible to determine the distance
  between first abd last before doing the copying.</p>
</blockquote>
<p>This makes perfect sense for vector, but not for deque. Why should deque gain
an efficiency advantage from knowing in advance the number of elements to
insert?</p>
<p><b>Proposed resolution:</b></p>
<p>In 23.2.1.1 paragraph 6, replace the Complexity description, including the
footnote, with the following text (which also corrects the &quot;abd&quot;
typo):</p>
<blockquote>
  <p>Complexity: Makes last - first calls to the copy constructor of T.</p>
</blockquote>
<hr>
<a name="146"><h3>146.&nbsp;complex&lt;T&gt; Inserter and Extractor need sentries</h3></a><p>
<b>Section:</b>&nbsp;26.2.6 <a href="lib-numerics.html#lib.complex.ops"> [lib.complex.ops]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Angelika Langer&nbsp; <b>Date:</b>&nbsp;12 May 1999</p>
<p>The <u> extractor</u> for complex numbers is specified as:&nbsp;</p>

<blockquote>

<p>     template&lt;class T, class charT, class traits&gt;&nbsp;<br>
     basic_istream&lt;charT, traits&gt;&amp;&nbsp;<br>
     operator&gt;&gt;(basic_istream&lt;charT, traits&gt;&amp;  is, complex&lt;T&gt;&amp;  x);<br>
&nbsp;<br>
Effects: Extracts a complex number x of the form: u, (u), or (u,v),
where u is the real part and v is the imaginary part
(lib.istream.formatted).&nbsp;<br>
Requires: The input values be convertible to T. If bad input is
encountered, calls is.setstate(ios::failbit) (which may throw
ios::failure (lib.iostate.flags).&nbsp;<br>
Returns: is .</p>

</blockquote>
<p>Is it intended that the extractor for complex numbers does not skip
whitespace, unlike all other extractors in the standard library do?
Shouldn't a sentry be used?&nbsp;<br>
<br>
The <u>inserter</u> for complex numbers is specified as:</p>

<blockquote>

<p>     template&lt;class T, class charT, class traits&gt;&nbsp;<br>
     basic_ostream&lt;charT, traits&gt;&amp;&nbsp;<br>
     operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp;  o, const complex&lt;T&gt;&amp;  x);<br>
<br>
Effects: inserts the complex number x onto the stream o as if it were implemented as follows:<br>
<br>
     template&lt;class T, class charT, class traits&gt;&nbsp;<br>
     basic_ostream&lt;charT, traits&gt;&amp;&nbsp;<br>
     operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp; o, const complex&lt;T&gt;&amp; x)&nbsp;<br>
     {&nbsp;<br>
             basic_ostringstream&lt;charT, traits&gt; s;&nbsp;<br>
             s.flags(o.flags());&nbsp;<br>
             s.imbue(o.getloc());&nbsp;<br>
             s.precision(o.precision());&nbsp;<br>
             s &lt;&lt; '(' &lt;&lt; x.real() &lt;&lt; &quot;,&quot; &lt;&lt; x.imag() &lt;&lt; ')';&nbsp;<br>
             return o &lt;&lt; s.str();&nbsp;<br>
     }</p>

</blockquote>

<p>Is it intended that the inserter for complex numbers ignores the
field width and does not do any padding? If, with the suggested
implementation above, the field width were set in the stream then the
opening parentheses would be adjusted, but the rest not, because the
field width is reset to zero after each insertion.</p>

<p>I think that both operations should use sentries, for sake of
consistency with the other inserters and extractors in the
library. Regarding the issue of padding in the inserter, I don't know
what the intent was.&nbsp;</p>
<p><b>Proposed resolution:</b></p>
<p>After 26.2.6  paragraph 14 (operator&gt;&gt;), add a
Notes clause:</p>

<blockquote>

<p>Notes: This extraction is performed as a series of simpler
extractions. Therefore, the skipping of whitespace is specified to be the
same for each of the simpler extractions.</p>

</blockquote>
<p><b>Rationale:</b></p>
<p>For extractors, the note is added to make it clear that skipping whitespace
follows an &quot;all-or-none&quot; rule.</p>

<p>For inserters, the LWG believes there is no defect; the standard is correct
as written.</p>
<hr>
<a name="147"><h3>147.&nbsp;Library Intro refers to global functions that aren't global</h3></a><p>
<b>Section:</b>&nbsp;17.4.4.3 <a href="lib-intro.html#lib.global.functions"> [lib.global.functions]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Lois Goldthwaite&nbsp; <b>Date:</b>&nbsp;4 Jun 1999</p>
<p>The library had many global functions until 17.4.1.1 [lib.contents]
paragraph 2 was added: </p>

<blockquote>

<p>All library entities except macros, operator new and operator
delete are defined within the namespace std or namespaces nested
within namespace std. </p>

</blockquote>

<p>It appears &quot;global function&quot; was never updated in the following: </p>

<blockquote>

<p>17.4.4.3 - Global functions [lib.global.functions]<br>
<br>
-1- It is unspecified whether any global functions in the C++ Standard
Library are defined as inline (dcl.fct.spec).<br>
<br>
-2- A call to a global function signature described in Clauses
lib.language.support through lib.input.output behaves the same as if
the implementation declares no additional global function
signatures.*<br>
<br>
    [Footnote: A valid C++ program always calls the expected library
    global function. An implementation may also define additional
    global functions that would otherwise not be called by a valid C++
    program. --- end footnote]<br>
<br>
-3- A global function cannot be declared by the implementation as
taking additional default arguments.&nbsp;<br>
<br>
17.4.4.4 - Member functions [lib.member.functions]<br>
<br>
-2- An implementation can declare additional non-virtual member
function signatures within a class: </p>

  <blockquote>

<p>-- by adding arguments with default values to a member function
signature; The same latitude does not extend to the implementation of
virtual or global functions, however. </p>

  </blockquote>
</blockquote>
<p><b>Proposed resolution:</b></p>
<p>     Change &quot;global&quot; to &quot;global or non-member&quot; in:</p>
<blockquote>
  <p>17.4.4.3 [lib.global.functions] section title,<br>
  17.4.4.3 [lib.global.functions] para 1,<br>
  17.4.4.3 [lib.global.functions] para 2 in 2 places plus 2 
           places in the footnote,<br>
  17.4.4.3 [lib.global.functions] para 3,<br>
  17.4.4.4 [lib.member.functions] para 2</p>
</blockquote>
<p><b>Rationale:</b></p>
<p>
Because operator new and delete are global, the proposed resolution
was changed from &quot;non-member&quot; to &quot;global or non-member.
</p>
<hr>
<a name="148"><h3>148.&nbsp;Functions in the example facet BoolNames should be const</h3></a><p>
<b>Section:</b>&nbsp;22.2.8 <a href="lib-locales.html#lib.facets.examples"> [lib.facets.examples]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Jeremy Siek&nbsp; <b>Date:</b>&nbsp;3 Jun 1999</p>
<p>In 22.2.8  paragraph 13, the do_truename() and
do_falsename() functions in the example facet BoolNames should be
const. The functions they are overriding in
numpunct_byname&lt;char&gt; are const. </p>
<p><b>Proposed resolution:</b></p>
<p>In 22.2.8  paragraph 13, insert &quot;const&quot; in
two places:</p>
<blockquote>
  <p><tt>string do_truename() const { return &quot;Oui Oui!&quot;; }<br>
  string do_falsename() const { return &quot;Mais Non!&quot;; }</tt></p>
</blockquote>
<hr>
<a name="150"><h3>150.&nbsp;Find_first_of says integer instead of iterator </h3></a><p>
<b>Section:</b>&nbsp;25.1.4 <a href="lib-algorithms.html#lib.alg.find.first.of"> [lib.alg.find.first.of]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Matt McClure&nbsp; <b>Date:</b>&nbsp;30 Jun 1999</p>
<p><b>Proposed resolution:</b></p>
<p>Change 25.1.4  paragraph 2 from:</p>

<blockquote>
<p>Returns: The first iterator i in the range [first1, last1) such
that for some <u>integer</u> j in the range [first2, last2) ...</p>
</blockquote>

<p>to:</p>

<blockquote>
<p>Returns: The first iterator i in the range [first1, last1) such
that for some iterator j in the range [first2, last2) ...</p>
</blockquote>
<hr>
<a name="151"><h3>151.&nbsp;Can't currently clear() empty container</h3></a><p>
<b>Section:</b>&nbsp;23.1.1 <a href="lib-containers.html#lib.sequence.reqmts"> [lib.sequence.reqmts]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Ed Brey&nbsp; <b>Date:</b>&nbsp;21 Jun 1999</p>
<p>For both sequences and associative containers, a.clear() has the
semantics of erase(a.begin(),a.end()), which is undefined for an empty
container since erase(q1,q2) requires that q1 be dereferenceable
(23.1.1,3 and 23.1.2,7).  When the container is empty, a.begin() is
not dereferenceable.<br>
<br>
The requirement that q1 be unconditionally dereferenceable causes many
operations to be intuitively undefined, of which clearing an empty
container is probably the most dire.<br>
<br>
Since q1 and q2 are only referenced in the range [q1, q2), and [q1,
q2) is required to be a valid range, stating that q1 and q2 must be
iterators or certain kinds of iterators is unnecessary.
</p>
<p><b>Proposed resolution:</b></p>
<p>In 23.1.1, paragraph 3, change:</p>
<blockquote>
  <p>p and q2 denote valid iterators to a, q <u> and q1</u> denote valid dereferenceable iterators to a, [q1, q2) denotes a valid range</p>
</blockquote>
<p>to:</p>
<blockquote>
  <p>p denotes a valid iterator to a, q denotes a valid dereferenceable iterator to a, [q1, q2) denotes a valid range<u>
  in a</u>
</p>
</blockquote>
<p>In 23.1.2, paragraph 7, change:</p>
<blockquote>
  <p>p and q2 are valid iterators to a, q <u> and q1</u> are valid dereferenceable
  iterators to a, [q1, q2) is a valid range</p>
</blockquote>
<p>to</p>
<blockquote>
  <p>p is a valid iterator to a, q is a valid dereferenceable iterator to a, [q1, q2) is a valid range
  <u>into a</u>
</p>
</blockquote>
<hr>
<a name="152"><h3>152.&nbsp;Typo in <tt>scan_is()</tt> semantics</h3></a><p>
<b>Section:</b>&nbsp;22.2.1.1.2 <a href="lib-locales.html#lib.locale.ctype.virtuals"> [lib.locale.ctype.virtuals]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Dietmar K&uuml;hl&nbsp; <b>Date:</b>&nbsp;20 Jul 1999</p>
<p>The semantics of <tt>scan_is()</tt> (paragraphs 4 and 6) is not exactly described
because there is no function <tt>is()</tt> which only takes a character as
argument. Also, in the effects clause (paragraph 3), the semantic is also kept
vague.</p>
<p><b>Proposed resolution:</b></p>
<p>In 22.2.1.1.2  paragraphs 4 and 6, change the returns
clause from:</p>
<blockquote>
  <p>&quot;... such that <tt>is(*p)</tt>
would...&quot;</p>
</blockquote>
<p>to:&nbsp; &quot;... such that <tt>is(m, *p)</tt>
 would....&quot;</p>
<hr>
<a name="153"><h3>153.&nbsp;Typo in <tt>narrow()</tt> semantics</h3></a><p>
<b>Section:</b>&nbsp;22.2.1.3.2 <a href="lib-locales.html#lib.facet.ctype.char.members"> [lib.facet.ctype.char.members]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Dietmar K&uuml;hl&nbsp; <b>Date:</b>&nbsp;20 Jul 1999</p>
<p>The description of the array version of <tt>narrow()</tt> (in
paragraph 11) is flawed: There is no member <tt>do_narrow()</tt> which
takes only three arguments because in addition to the range a default
character is needed.</p>

<p>Additionally, for both <tt>widen</tt> and <tt>narrow</tt> we have
two signatures followed by a <b>Returns</b> clause that only addresses
one of them.</p>

<p><b>Proposed resolution:</b></p>
<p>Change the returns clause in 22.2.1.3.2 
paragraph 10 from:</p>
<p>&nbsp;&nbsp;&nbsp; Returns: do_widen(low, high, to).</p>

<p>to:</p>
<p>&nbsp;&nbsp;&nbsp; Returns: do_widen(c) or do_widen(low, high, to), 
respectively.</p>

<p>Change 22.2.1.3.2  paragraph 10 and 11 from:</p>
<pre>        char        narrow(char c, char /*dfault*/) const;
        const char* narrow(const char* low, const char* high,
                           char /*dfault*/, char* to) const;</pre>
<pre>        Returns: do_narrow(low, high, to).</pre>
<p>to:</p>
<pre>        char        narrow(char c, char dfault) const;
        const char* narrow(const char* low, const char* high,
                           char dfault, char* to) const;</pre>
<pre>        Returns: do_narrow(c, dfault) or
                 do_narrow(low, high, dfault, to), respectively.</pre>

<p><i>[Kona: 1) the problem occurs in additional places, 2) a user
defined version could be different.]</i></p>

<p><i>[Post-Tokyo: Dietmar provided the above wording at the request of
the LWG. He could find no other places the problem occurred. He
asks for clarification of the Kona &quot;a user defined
version...&quot; comment above.  Perhaps it was a circuitous way of
saying &quot;dfault&quot; needed to be uncommented?]</i></p>

<p><i>[Post-Toronto: the issues list maintainer has merged in the
proposed resolution from issue <a href="lwg-closed.html#207">207</a>, which addresses the
same paragraphs.]</i></p>
<hr>
<a name="154"><h3>154.&nbsp;Missing <tt>double</tt> specifier for <tt>do_get()</tt>
</h3></a><p>
<b>Section:</b>&nbsp;22.2.2.1.2 <a href="lib-locales.html#lib.facet.num.get.virtuals"> [lib.facet.num.get.virtuals]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Dietmar K&uuml;hl&nbsp; <b>Date:</b>&nbsp;20 Jul 1999</p>
<p>The table in paragraph 7 for the length modifier does not list the length
modifier <tt>l</tt> to be applied if the type is <tt>double</tt>. Thus, the
standard asks the implementation to do undefined things when using <tt>scanf()</tt>
(the missing length modifier for <tt>scanf()</tt> when scanning <tt>double</tt>s
is actually a problem I found quite often in production code, too).</p>
<p><b>Proposed resolution:</b></p>
<p>In 22.2.2.1.2 , paragraph 7, add a row in the Length
Modifier table to say that for <tt>double</tt> a length modifier
<tt>l</tt> is to be used.</p>
<p><b>Rationale:</b></p>
<p>The standard makes an embarrassing beginner's mistake.</p>
<hr>
<a name="155"><h3>155.&nbsp;Typo in naming the class defining the class <tt>Init</tt>
</h3></a><p>
<b>Section:</b>&nbsp;27.3 <a href="lib-iostreams.html#lib.iostream.objects"> [lib.iostream.objects]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Dietmar K&uuml;hl&nbsp; <b>Date:</b>&nbsp;20 Jul 1999</p>
<p>There are conflicting statements about where the class
<tt>Init</tt> is defined. According to 27.3  paragraph 2
it is defined as <tt>basic_ios::Init</tt>, according to 27.4.2  it is defined as <tt>ios_base::Init</tt>.</p>
<p><b>Proposed resolution:</b></p>
<p>Change 27.3  paragraph 2 from
&quot;<tt>basic_ios::Init&quot;</tt> to
&quot;<tt>ios_base::Init&quot;</tt>.</p>
<p><b>Rationale:</b></p>
<p>Although not strictly wrong, the standard was misleading enough to warrant
the change.</p>
<hr>
<a name="156"><h3>156.&nbsp;Typo in <tt>imbue()</tt> description</h3></a><p>
<b>Section:</b>&nbsp;27.4.2.3 <a href="lib-iostreams.html#lib.ios.base.locales"> [lib.ios.base.locales]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Dietmar K&uuml;hl&nbsp; <b>Date:</b>&nbsp;20 Jul 1999</p>
<p>There is a small discrepancy between the declarations of
<tt>imbue()</tt>: in 27.4.2  the argument is passed as
<tt>locale const&amp;</tt> (correct), in 27.4.2.3  it
is passed as <tt>locale const</tt> (wrong).</p>
<p><b>Proposed resolution:</b></p>
<p>In 27.4.2.3  change the <tt>imbue</tt> argument
from &quot;<tt>locale const&quot; to &quot;locale
const&amp;&quot;.</tt>
</p>
<hr>
<a name="158"><h3>158.&nbsp;Underspecified semantics for <tt>setbuf()</tt>
</h3></a><p>
<b>Section:</b>&nbsp;27.5.2.4.2 <a href="lib-iostreams.html#lib.streambuf.virt.buffer"> [lib.streambuf.virt.buffer]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Dietmar K&uuml;hl&nbsp; <b>Date:</b>&nbsp;20 Jul 1999</p>
<p>The default behavior of <tt>setbuf()</tt> is described only for the
situation that <tt>gptr() != 0 &amp;&amp; gptr() != egptr()</tt>:
namely to do nothing.  What has to be done in other situations&nbsp;
is not described although there is actually only one reasonable
approach, namely to do nothing, too.</p> 

<p>Since changing the buffer would almost certainly mess up most
buffer management of derived classes unless these classes do it
themselves, the default behavior of <tt>setbuf()</tt> should always be
to do nothing.</p>
<p><b>Proposed resolution:</b></p>
<p>Change 27.5.2.4.2 , paragraph 3, Default behavior,
to: &quot;Default behavior: Does nothing. Returns this.&quot;</p>
<hr>
<a name="159"><h3>159.&nbsp;Strange use of <tt>underflow()</tt>
</h3></a><p>
<b>Section:</b>&nbsp;27.5.2.4.3 <a href="lib-iostreams.html#lib.streambuf.virt.get"> [lib.streambuf.virt.get]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Dietmar K&uuml;hl&nbsp; <b>Date:</b>&nbsp;20 Jul 1999</p>
<p>The description of the meaning of the result of
<tt>showmanyc()</tt> seems to be rather strange: It uses calls to
<tt>underflow()</tt>. Using <tt>underflow()</tt> is strange because
this function only reads the current character but does not extract
it, <tt>uflow()</tt> would extract the current character. This should
be fixed to use <tt>sbumpc()</tt> instead.</p>
<p><b>Proposed resolution:</b></p>
<p>Change 27.5.2.4.3  paragraph 1,
<tt>showmanyc()</tt>returns clause, by replacing the word
&quot;supplied&quot; with the words &quot;extracted from the
stream&quot;.</p>
<hr>
<a name="160"><h3>160.&nbsp;Typo: Use of non-existing function <tt>exception()</tt>
</h3></a><p>
<b>Section:</b>&nbsp;27.6.1.1 <a href="lib-iostreams.html#lib.istream"> [lib.istream]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Dietmar K&uuml;hl&nbsp; <b>Date:</b>&nbsp;20 Jul 1999</p>
<p>The paragraph 4 refers to the function <tt>exception()</tt> which
is not defined. Probably, the referred function is
<tt>basic_ios&lt;&gt;::exceptions()</tt>.</p>
<p><b>Proposed resolution:</b></p>
<p>In 27.6.1.1 , 27.6.1.3 , paragraph 1,
27.6.2.1 , paragraph 3, and 27.6.2.5.1 ,
paragraph 1, change &quot;<tt>exception()&quot; to
&quot;exceptions()&quot;</tt>.</p>

<p><i>[Note to Editor: &quot;exceptions&quot; with an &quot;s&quot;
is the correct spelling.]</i></p>
<hr>
<a name="161"><h3>161.&nbsp;Typo: <tt>istream_iterator</tt> vs. <tt>istreambuf_iterator</tt>
</h3></a><p>
<b>Section:</b>&nbsp;27.6.1.2.2 <a href="lib-iostreams.html#lib.istream.formatted.arithmetic"> [lib.istream.formatted.arithmetic]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Dietmar K&uuml;hl&nbsp; <b>Date:</b>&nbsp;20 Jul 1999</p>
<p>The note in the second paragraph pretends that the first argument
is an object of type <tt>istream_iterator</tt>. This is wrong: It is
an object of type <tt>istreambuf_iterator</tt>.</p>
<p><b>Proposed resolution:</b></p>
<p>Change 27.6.1.2.2  from:</p>
<blockquote>
  <p>The first argument provides an object of the istream_iterator class...</p>
</blockquote>
<p>to</p>
<blockquote>
  <p>The first argument provides an object of the istreambuf_iterator class...</p>
</blockquote>
<hr>
<a name="164"><h3>164.&nbsp;do_put() has apparently unused fill argument</h3></a><p>
<b>Section:</b>&nbsp;22.2.5.3.2 <a href="lib-locales.html#lib.locale.time.put.virtuals"> [lib.locale.time.put.virtuals]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Angelika Langer&nbsp; <b>Date:</b>&nbsp;23 Jul 1999</p>
<p>In 22.2.5.3.2  the do_put() function is specified
as taking a fill character as an argument, but the description of the
function does not say whether the character is used at all and, if so,
in which way. The same holds for any format control parameters that
are accessible through the ios_base&amp; argument, such as the
adjustment or the field width. Is strftime() supposed to use the fill
character in any way? In any case, the specification of
time_put.do_put() looks inconsistent to me.<br> <br> Is the
signature of do_put() wrong, or is the effects clause incomplete?</p>
<p><b>Proposed resolution:</b></p>
<p>Add the following note after 22.2.5.3.2 
paragraph 2:</p>
<blockquote>
  <p>  [Note: the <tt>fill</tt> argument may be used in the implementation-defined  formats, or by derivations.  A space character is a reasonable default
  for this argument. --end Note]</p>
</blockquote>
<p><b>Rationale:</b></p>
<p>The LWG felt that while the normative text was correct,
users need some guidance on what to pass for the <tt>fill</tt>
argument since the standard doesn't say how it's used.</p>
<hr>
<a name="165"><h3>165.&nbsp;<tt>xsputn()</tt>, <tt>pubsync()</tt> never called by <tt>basic_ostream</tt> members?</h3></a><p>
<b>Section:</b>&nbsp;27.6.2.1 <a href="lib-iostreams.html#lib.ostream"> [lib.ostream]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Dietmar K&uuml;hl&nbsp; <b>Date:</b>&nbsp;20 Jul 1999</p>
<p>Paragraph 2 explicitly states that none of the <tt>basic_ostream</tt>
functions falling into one of the groups &quot;formatted output functions&quot;
and &quot;unformatted output functions&quot; calls any stream buffer function
which might call a virtual function other than <tt>overflow()</tt>. Basically
this is fine but this implies that <tt>sputn()</tt> (this function would call
the virtual function <tt>xsputn()</tt>) is never called by any of the standard
output functions. Is this really intended? At minimum it would be convenient to
call <tt>xsputn()</tt> for strings... Also, the statement that <tt>overflow()</tt>
is the only virtual member of <tt>basic_streambuf</tt> called is in conflict
with the definition of <tt>flush()</tt> which calls <tt>rdbuf()-&gt;pubsync()</tt>
and thereby the virtual function <tt>sync()</tt> (<tt>flush()</tt> is listed
under &quot;unformatted output functions&quot;).</p>
<p>In addition, I guess that the sentence starting with &quot;They may use other
public members of <tt>basic_ostream</tt> ...&quot; probably was intended to
start with &quot;They may use other public members of <tt>basic_streamuf</tt>...&quot;
although the problem with the virtual members exists in both cases.</p>
<p>I see two obvious resolutions:</p>
<ol>
  <li>state in a footnote that this means that <tt>xsputn()</tt> will never be
    called by any ostream member and that this is intended.</li>
  <li>relax the restriction and allow calling <tt>overflow()</tt> and <tt>xsputn()</tt>.
    Of course, the problem with <tt>flush()</tt> has to be resolved in some way.</li>
</ol>
<p><b>Proposed resolution:</b></p>
<p>Change the last sentence of 27.6.2.1 (lib.ostream) paragraph 2 from:</p>
<blockquote>
  <p>They may use other public members of basic_ostream except that they do not
  invoke any virtual members of rdbuf() except overflow().</p>
</blockquote>
<p>to:</p>
<blockquote>
  <p>They may use other public members of basic_ostream except that they shall
  not invoke any virtual members of rdbuf() except overflow(), xsputn(), and
  sync().</p>
</blockquote>

<p><i>[Kona: the LWG believes this is a problem. Wish to ask Jerry or
PJP why the standard is written this way.]</i></p>

<p><i>[Post-Tokyo: Dietmar supplied wording at the request of the
LWG. He comments: The rules can be made a little bit more specific if
necessary be explicitly spelling out what virtuals are allowed to be
called from what functions and eg to state specifically that flush()
is allowed to call sync() while other functions are not.]</i></p>
<hr>
<a name="168"><h3>168.&nbsp;Typo: formatted vs. unformatted</h3></a><p>
<b>Section:</b>&nbsp;27.6.2.6 <a href="lib-iostreams.html#lib.ostream.unformatted"> [lib.ostream.unformatted]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Dietmar K&uuml;hl&nbsp; <b>Date:</b>&nbsp;20 Jul 1999</p>
<p>The first paragraph begins with a descriptions what has to be done
in <i>formatted</i> output functions. Probably this is a typo and the
paragraph really want to describe unformatted output functions...</p>
<p><b>Proposed resolution:</b></p>
<p>In 27.6.2.6  paragraph 1, the first and last
sentences, change the word &quot;formatted&quot; to
&quot;unformatted&quot;:</p>
<blockquote>
  <p>&quot;Each <b>unformatted </b> output function begins ...&quot;<br>
  &quot;... value specified for the <b>unformatted </b>  output 
  function.&quot;</p>
</blockquote>
<hr>
<a name="169"><h3>169.&nbsp;Bad efficiency of <tt>overflow()</tt> mandated</h3></a><p>
<b>Section:</b>&nbsp;27.7.1.3 <a href="lib-iostreams.html#lib.stringbuf.virtuals"> [lib.stringbuf.virtuals]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Dietmar K&uuml;hl&nbsp; <b>Date:</b>&nbsp;20 Jul 1999</p>
<p>Paragraph 8, Notes, of this section seems to mandate an extremely
inefficient way of buffer handling for <tt>basic_stringbuf</tt>,
especially in view of the restriction that <tt>basic_ostream</tt>
member functions are not allowed to use <tt>xsputn()</tt> (see 27.6.2.1 ): For each character to be inserted, a new buffer
is to be created.</p> 
<p>Of course, the resolution below requires some handling of
simultaneous input and output since it is no longer possible to update
<tt>egptr()</tt> whenever <tt>epptr()</tt> is changed. A possible
solution is to handle this in <tt>underflow()</tt>.</p>
<p><b>Proposed resolution:</b></p>
<p>In 27.7.1.3  paragraph 8, Notes, insert the words
&quot;at least&quot; as in the following:</p>
<blockquote>
  <p>To make a write position available, the function reallocates (or initially
  allocates) an array object with a sufficient number of elements to hold the
  current array object (if any), plus <b>at least</b> one additional write
  position.</p>
</blockquote>
<hr>
<a name="170"><h3>170.&nbsp;Inconsistent definition of <tt>traits_type</tt>
</h3></a><p>
<b>Section:</b>&nbsp;27.7.4 <a href="lib-iostreams.html#lib.stringstream"> [lib.stringstream]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Dietmar K&uuml;hl&nbsp; <b>Date:</b>&nbsp;20 Jul 1999</p>
<p>The classes <tt>basic_stringstream</tt> (27.7.4 ),
<tt>basic_istringstream</tt> (27.7.2 ), and
<tt>basic_ostringstream</tt> (27.7.3 ) are inconsistent
in their definition of the type <tt>traits_type</tt>: For
<tt>istringstream</tt>, this type is defined, for the other two it is
not. This should be consistent.</p>
<p><b>Proposed resolution:</b></p>
<p><b>Proposed resolution:</b></p> <p>To the declarations of
<tt>basic_ostringstream</tt> (27.7.3 ) and
<tt>basic_stringstream</tt> (27.7.4 ) add:</p>
<blockquote>
<pre>typedef traits traits_type;</pre>
</blockquote>
<hr>
<a name="171"><h3>171.&nbsp;Strange <tt>seekpos()</tt> semantics due to joint position</h3></a><p>
<b>Section:</b>&nbsp;27.8.1.4 <a href="lib-iostreams.html#lib.filebuf.virtuals"> [lib.filebuf.virtuals]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Dietmar K&uuml;hl&nbsp; <b>Date:</b>&nbsp;20 Jul 1999</p>
<p>Overridden virtual functions, seekpos()</p> <p>In 27.8.1.1  paragraph 3, it is stated that a joint input and
output position is maintained by <tt>basic_filebuf</tt>. Still, the
description of <tt>seekpos()</tt> seems to talk about different file
positions. In particular, it is unclear (at least to me) what is
supposed to happen to the output buffer (if there is one) if only the
input position is changed. The standard seems to mandate that the
output buffer is kept and processed as if there was no positioning of
the output position (by changing the input position). Of course, this
can be exactly what you want if the flag <tt>ios_base::ate</tt> is
set. However, I think, the standard should say something like
this:</p>
<ul>
  <li>If <tt>(which &amp; mode) == 0</tt> neither read nor write position is
    changed and the call fails. Otherwise, the joint read and write position is
    altered to correspond to <tt>sp</tt>.</li>
  <li>If there is an output buffer, the output sequences is updated and any
    unshift sequence is written before the position is altered.</li>
  <li>If there is an input buffer, the input sequence is updated after the
    position is altered.</li>
</ul>
<p>Plus the appropriate error handling, that is...</p>
<p><b>Proposed resolution:</b></p>
<p>Change the unnumbered paragraph in 27.8.1.4 (lib.filebuf.virtuals) before
paragraph 14 from:</p>
<blockquote>
  <p>pos_type seekpos(pos_type sp, ios_base::openmode = ios_base::in |
  ios_base::out);</p>
  <p>Alters the file position, if possible, to correspond to the position stored
  in sp (as described below).</p>
  <p>- if (which&amp;ios_base::in)!=0, set the file position to sp, then update
  the input sequence</p>
  <p>- if (which&amp;ios_base::out)!=0, then update the output sequence, write
  any unshift sequence, and set the file position to sp.</p>
</blockquote>
<p>to:</p>
<blockquote>
  <p>pos_type seekpos(pos_type sp, ios_base::openmode = ios_base::in |
  ios_base::out);</p>
  <p>Alters the file position, if possible, to correspond to the position stored
  in sp (as described below). Altering the file position performs as follows:</p>
  <p>1. if (om &amp; ios_base::out)!=0, then update the output sequence and
  write any unshift sequence;</p>
  <p>2. set the file position to sp;</p>
  <p>3. if (om &amp; ios_base::in)!=0, then update the input sequence;</p>
  <p>where om is the open mode passed to the last call to open(). The operation
  fails if is_open() returns false.</p>
</blockquote>

<p><i>[Kona: Dietmar is working on a proposed resolution.]</i></p>
<p><i>[Post-Tokyo: Dietmar supplied the above wording.]</i></p>
<hr>
<a name="172"><h3>172.&nbsp;Inconsistent types for <tt>basic_istream::ignore()</tt>
</h3></a><p>
<b>Section:</b>&nbsp;27.6.1.3 <a href="lib-iostreams.html#lib.istream.unformatted"> [lib.istream.unformatted]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Greg Comeau, Dietmar K&uuml;hl&nbsp; <b>Date:</b>&nbsp;23 Jul 1999</p>
<p>In 27.6.1.1  the function
<tt>ignore()</tt> gets an object of type <tt>streamsize</tt> as first
argument. However, in 27.6.1.3 
paragraph 23 the first argument is of type <tt>int.</tt>
</p>

<p>As far as I can see this is not really a contradiction because
everything is consistent if <tt>streamsize</tt> is typedef to be
<tt>int</tt>. However, this is almost certainly not what was
intended. The same thing happened to <tt>basic_filebuf::setbuf()</tt>,
as described in issue <a href="lwg-defects.html#173">173</a>.</p>

<p>Darin Adler also
submitted this issue, commenting: Either 27.6.1.1 should be modified
to show a first parameter of type int, or 27.6.1.3 should be modified
to show a first parameter of type streamsize and use
numeric_limits&lt;streamsize&gt;::max.</p>
<p><b>Proposed resolution:</b></p>
<p>In 27.6.1.3  paragraph 23 and 24, change both uses
of <tt>int</tt> in the description of <tt>ignore()</tt> to
<tt>streamsize</tt>.</p>
<hr>
<a name="173"><h3>173.&nbsp;Inconsistent types for <tt>basic_filebuf::setbuf()</tt>
</h3></a><p>
<b>Section:</b>&nbsp;27.8.1.4 <a href="lib-iostreams.html#lib.filebuf.virtuals"> [lib.filebuf.virtuals]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Greg Comeau, Dietmar K&uuml;hl&nbsp; <b>Date:</b>&nbsp;23 Jul 1999</p>

<p>
In 27.8.1.1  the function <tt>setbuf()</tt> gets an
object of type <tt>streamsize</tt> as second argument. However, in
27.8.1.4  paragraph 9 the second argument is of type
<tt>int</tt>.
</p>

<p>
As far as I can see this is not really a contradiction because
everything is consistent if <tt>streamsize</tt> is typedef to be
<tt>int</tt>. However, this is almost certainly not what was
intended. The same thing happened to <tt>basic_istream::ignore()</tt>,
as described in issue <a href="lwg-defects.html#172">172</a>.
</p>

<p><b>Proposed resolution:</b></p>
<p>In 27.8.1.4  paragraph 9, change all uses of
<tt>int</tt> in the description of <tt>setbuf()</tt> to
<tt>streamsize</tt>.</p>
<hr>
<a name="174"><h3>174.&nbsp;Typo: <tt>OFF_T</tt> vs. <tt>POS_T</tt>
</h3></a><p>
<b>Section:</b>&nbsp;D.6 <a href="future.html#depr.ios.members"> [depr.ios.members]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Dietmar K&uuml;hl&nbsp; <b>Date:</b>&nbsp;23 Jul 1999</p>
<p>According to paragraph 1 of this section, <tt>streampos</tt> is the
type <tt>OFF_T</tt>, the same type as <tt>streamoff</tt>. However, in
paragraph 6 the <tt>streampos</tt> gets the type <tt>POS_T</tt>
</p>
<p><b>Proposed resolution:</b></p>
<p>Change D.6  paragraph 1 from &quot;<tt>typedef
OFF_T streampos;</tt>&quot; to &quot;<tt>typedef POS_T
streampos;</tt>&quot;</p>
<hr>
<a name="175"><h3>175.&nbsp;Ambiguity for <tt>basic_streambuf::pubseekpos()</tt> and a few other functions.</h3></a><p>
<b>Section:</b>&nbsp;D.6 <a href="future.html#depr.ios.members"> [depr.ios.members]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Dietmar K&uuml;hl&nbsp; <b>Date:</b>&nbsp;23 Jul 1999</p>
<p>According to paragraph 8 of this section, the methods
<tt>basic_streambuf::pubseekpos()</tt>,
<tt>basic_ifstream::open()</tt>, and <tt>basic_ofstream::open</tt>
&quot;may&quot; be overloaded by a version of this function taking the
type <tt>ios_base::open_mode</tt> as last argument argument instead of
<tt>ios_base::openmode</tt> (<tt>ios_base::open_mode</tt> is defined
in this section to be an alias for one of the integral types). The
clause specifies, that the last argument has a default argument in
three cases.  However, this generates an ambiguity with the overloaded
version because now the arguments are absolutely identical if the last
argument is not specified.</p>
<p><b>Proposed resolution:</b></p>
<p>In D.6  paragraph 8, remove the default arguments for
<tt>basic_streambuf::pubseekpos()</tt>,
<tt>basic_ifstream::open()</tt>, and
<tt>basic_ofstream::open().</tt>
</p>
<hr>
<a name="176"><h3>176.&nbsp;<tt>exceptions()</tt> in <tt>ios_base</tt>...?</h3></a><p>
<b>Section:</b>&nbsp;D.6 <a href="future.html#depr.ios.members"> [depr.ios.members]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Dietmar K&uuml;hl&nbsp; <b>Date:</b>&nbsp;23 Jul 1999</p>
<p>The &quot;overload&quot; for the function <tt>exceptions()</tt> in
paragraph 8 gives the impression that there is another function of
this function defined in class <tt>ios_base</tt>. However, this is not
the case. Thus, it is hard to tell how the semantics (paragraph 9) can
be implemented: &quot;Call the corresponding member function specified
in clause 27 .&quot;</p>
<p><b>Proposed resolution:</b></p>
<p>In D.6  paragraph 8, move the declaration of the
function <tt>exceptions()</tt>into class <tt>basic_ios</tt>.</p>
<hr>
<a name="181"><h3>181.&nbsp;make_pair() unintended behavior</h3></a><p>
<b>Section:</b>&nbsp;20.2.2 <a href="lib-utilities.html#lib.pairs"> [lib.pairs]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Andrew Koenig&nbsp; <b>Date:</b>&nbsp;3 Aug 1999</p>
<p>The claim has surfaced in Usenet that expressions such as<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <tt>make_pair(&quot;abc&quot;, 3)</tt><br>
<br>
are illegal, notwithstanding their use in examples, because template instantiation tries to bind the first template
parameter to <tt> const char (&amp;)[4]</tt>, which type is uncopyable.<br>
<br>
I doubt anyone intended that behavior...
</p>
<p><b>Proposed resolution:</b></p>
<p>In 20.2 , paragraph 1 change the following
declaration of make_pair():</p>
<blockquote>
  <pre>template &lt;class T1, class T2&gt; pair&lt;T1,T2&gt; make_pair(const T1&amp;, const T2&amp;);</pre>
</blockquote>
<p>to:</p>
<blockquote>
  <pre>template &lt;class T1, class T2&gt; pair&lt;T1,T2&gt; make_pair(T1, T2);</pre>
</blockquote>
<p>  In 20.2.2  paragraph 7 and the line before, change:</p>
<blockquote>
<pre>template &lt;class T1, class T2&gt;
pair&lt;T1, T2&gt; make_pair(const T1&amp; x, const T2&amp; y);</pre>
</blockquote>
<p>to:</p>
<blockquote>
<pre>template &lt;class T1, class T2&gt;
pair&lt;T1, T2&gt; make_pair(T1 x, T2 y);</pre>
</blockquote>
<p>and add the following footnote to the effects clause:</p>
<blockquote>
  <p> According to 12.8 [class.copy], an implementation is permitted
  to not perform a copy of an argument, thus avoiding unnecessary
  copies.</p>
</blockquote>
<p><b>Rationale:</b></p>
<p>Two potential fixes were suggested by Matt Austern and Dietmar
K&uuml;hl, respectively, 1) overloading with array arguments, and 2) use of
a reference_traits class with a specialization for arrays.  Andy
Koenig suggested changing to pass by value. In discussion, it appeared
that this was a much smaller change to the standard that the other two
suggestions, and any efficiency concerns were more than offset by the
advantages of the solution. Two implementors reported that the
proposed resolution passed their test suites.</p>
<hr>
<a name="183"><h3>183.&nbsp;I/O stream manipulators don't work for wide character streams</h3></a><p>
<b>Section:</b>&nbsp;27.6.3 <a href="lib-iostreams.html#lib.std.manip"> [lib.std.manip]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Andy Sawyer&nbsp; <b>Date:</b>&nbsp;7 Jul 1999</p>
<p>27.6.3  paragraph 3 says (clause numbering added for
exposition):<a href="lib-iostreams.html#lib.std.manip"> [lib.std.manip]</a>
</p>
<blockquote>
<p>Returns: An object s of unspecified type such that if [1] out is an (instance
of) basic_ostream then the expression out&lt;&lt;s behaves as if f(s) were
called, and if [2] in is an (instance of) basic_istream then the expression
in&gt;&gt;s behaves as if f(s) were called. Where f can be defined as: ios_base&amp;
f(ios_base&amp; str, ios_base::fmtflags mask) { // reset specified flags
str.setf(ios_base::fmtflags(0), mask); return str; } [3] The expression
out&lt;&lt;s has type ostream&amp; and value out. [4] The expression in&gt;&gt;s
has type istream&amp; and value in.</p>
</blockquote>
<p>Given the definitions [1] and [2] for out and in, surely [3] should read:
&quot;The expression out &lt;&lt; s has type basic_ostream&amp; ...&quot; and
[4] should read: &quot;The expression in &gt;&gt; s has type basic_istream&amp;
...&quot;</p>
<p>If the wording in the standard is correct, I can see no way of implementing
any of the manipulators so that they will work with wide character streams.</p>
<p>e.g. wcout &lt;&lt; setbase( 16 );</p>
<p>Must have value 'wcout' (which makes sense) and type 'ostream&amp;' (which
doesn't).</p>
<p>The same &quot;cut'n'paste&quot; type also seems to occur in Paras 4,5,7 and
8. In addition, Para 6 [setfill] has a similar error, but relates only to
ostreams.</p>
<p>I'd be happier if there was a better way of saying this, to make it clear
that the value of the expression is &quot;the same specialization of
basic_ostream as out&quot;&amp;</p>
<p><b>Proposed resolution:</b></p>
<p>Replace section 27.6.3  except paragraph 1 with the
following:</p>
<blockquote>
<p>2- The type designated smanip in each of the following function descriptions is implementation-specified and may be different for each
function.<br>
<br>
<tt>smanip resetiosflags(ios_base::fmtflags mask);</tt><br>
<br>
-3- Returns: An object s of unspecified type such that if out is an instance of basic_ostream&lt;charT,traits&gt; then the expression out&lt;&lt;s behaves
as if f(s, mask) were called, or if in is an instance of basic_istream&lt;charT,traits&gt; then the expression in&gt;&gt;s behaves as if
f(s, mask) were called. The function f can be defined as:*<br>
<br>
[Footnote: The expression cin &gt;&gt; resetiosflags(ios_base::skipws) clears ios_base::skipws in the format flags stored in the
basic_istream&lt;charT,traits&gt; object cin (the same as cin &gt;&gt; noskipws), and the expression cout &lt;&lt; resetiosflags(ios_base::showbase) clears
ios_base::showbase in the format flags stored in the basic_ostream&lt;charT,traits&gt; object cout (the same as cout &lt;&lt;
noshowbase). --- end footnote]<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp; <tt>ios_base&amp; f(ios_base&amp; str, ios_base::fmtflags mask)<br>
&nbsp;&nbsp; {<br>
&nbsp;&nbsp; //  reset specified flags<br>
&nbsp;&nbsp; str.setf(ios_base::fmtflags(0), mask);<br>
&nbsp;&nbsp; return str;<br>
&nbsp;&nbsp; }<br>
</tt><br>
The expression out&lt;&lt;s has type basic_ostream&lt;charT,traits&gt;&amp; and value out.
The expression in&gt;&gt;s has type basic_istream&lt;charT,traits&gt;&amp; and value in.<br>
<br>
&nbsp;<tt>smanip setiosflags(ios_base::fmtflags mask);</tt><br>
<br>
-4- Returns: An object s of unspecified type such that if out is an instance of basic_ostream&lt;charT,traits&gt; then the expression out&lt;&lt;s behaves
as if f(s, mask) were called, or if in is an instance of basic_istream&lt;charT,traits&gt; then the expression in&gt;&gt;s behaves as if f(s,
mask) were called. The function f can be defined as:<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp; <tt>ios_base&amp; f(ios_base&amp; str, ios_base::fmtflags mask)<br>
&nbsp;&nbsp; {<br>
&nbsp;&nbsp; //  set specified flags<br>
&nbsp;&nbsp; str.setf(mask);<br>
&nbsp;&nbsp; return str;<br>
&nbsp;&nbsp; }<br>
</tt><br>
The expression out&lt;&lt;s has type basic_ostream&lt;charT,traits&gt;&amp; and value out.
The expression in&gt;&gt;s has type basic_istream&lt;charT,traits&gt;&amp; and value in.<br>
<br>
<tt>smanip setbase(int base);</tt><br>
<br>
-5- Returns: An object s of unspecified type such that if out is an instance of basic_ostream&lt;charT,traits&gt; then the expression out&lt;&lt;s behaves
as if f(s, base) were called, or if in is an instance of basic_istream&lt;charT,traits&gt; then the expression in&gt;&gt;s behaves as if f(s,
base) were called. The function f can be defined as:<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp; <tt>ios_base&amp; f(ios_base&amp; str, int base)<br>
&nbsp;&nbsp; {<br>
&nbsp;&nbsp; //  set  basefield<br>
&nbsp;&nbsp; str.setf(base ==  8 ? ios_base::oct :<br>
&nbsp;&nbsp; base == 10 ? ios_base::dec :<br>
&nbsp;&nbsp; base == 16 ? ios_base::hex :<br>
&nbsp;&nbsp; ios_base::fmtflags(0), ios_base::basefield);<br>
&nbsp;&nbsp; return str;<br>
&nbsp;&nbsp; }<br>
</tt><br>
The expression out&lt;&lt;s has type basic_ostream&lt;charT,traits&gt;&amp; and value out.
The expression in&gt;&gt;s has type basic_istream&lt;charT,traits&gt;&amp; and value in.<br>
<br>
<tt>smanip setfill(char_type c);<br>
</tt><br>
-6- Returns: An object s of unspecified type such that if out is (or is derived from) basic_ostream&lt;charT,traits&gt; and c has type charT then the
expression out&lt;&lt;s behaves as if f(s, c) were called. The function f can be
defined as:<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <tt>template&lt;class charT, class traits&gt;<br>
&nbsp;&nbsp; basic_ios&lt;charT,traits&gt;&amp; f(basic_ios&lt;charT,traits&gt;&amp; str, charT c)<br>
&nbsp;&nbsp; {<br>
&nbsp;&nbsp; //  set fill character<br>
&nbsp;&nbsp; str.fill(c);<br>
&nbsp;&nbsp; return str;<br>
&nbsp;&nbsp; }<br>
</tt><br>
The expression out&lt;&lt;s has type basic_ostream&lt;charT,traits&gt;&amp; and value out.<br>
<br>
<tt>smanip setprecision(int n);</tt><br>
<br>
-7- Returns: An object s of unspecified type such that if out is an instance of basic_ostream&lt;charT,traits&gt; then the expression out&lt;&lt;s behaves
as if f(s, n) were called, or if in is an instance of basic_istream&lt;charT,traits&gt; then the expression in&gt;&gt;s behaves as if f(s, n)
were called. The function f can be defined as:<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <tt>ios_base&amp; f(ios_base&amp; str, int n)<br>
&nbsp;&nbsp; {<br>
&nbsp;&nbsp; //  set precision<br>
&nbsp;&nbsp; str.precision(n);<br>
&nbsp;&nbsp; return str;<br>
&nbsp;&nbsp; }<br>
</tt><br>
The expression out&lt;&lt;s has type basic_ostream&lt;charT,traits&gt;&amp; and value out.
The expression in&gt;&gt;s has type basic_istream&lt;charT,traits&gt;&amp; and value in<br>
.<br>
<tt>smanip setw(int n);<br>
</tt><br>
-8- Returns: An object s of unspecified type such that if out is an instance of basic_ostream&lt;charT,traits&gt; then the expression out&lt;&lt;s behaves
as if f(s, n) were called, or if in is an instance of basic_istream&lt;charT,traits&gt; then the expression in&gt;&gt;s behaves as if f(s, n)
were called. The function f can be defined as:<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <tt>ios_base&amp; f(ios_base&amp; str, int n)<br>
&nbsp;&nbsp; {<br>
&nbsp;&nbsp; //  set width<br>
&nbsp;&nbsp; str.width(n);<br>
&nbsp;&nbsp; return str;<br>
&nbsp;&nbsp; }<br>
</tt><br>
The expression out&lt;&lt;s has type
basic_ostream&lt;charT,traits&gt;&amp; and value out.  The expression
in&gt;&gt;s has type basic_istream&lt;charT,traits&gt;&amp; and value
in.
</p>
</blockquote>

<p><i>[Kona: Andy Sawyer and Beman Dawes will work to improve the wording of
the proposed resolution.]</i></p>

<p><i>[Tokyo - The LWG noted that issue <a href="lwg-closed.html#216">216</a> involves
the same paragraphs.]</i></p>

<p><i>[Post-Tokyo: The issues list maintainer combined the proposed
resolution of this issue with the proposed resolution for issue <a href="lwg-closed.html#216">216</a> as they both involved the same paragraphs, and were so
intertwined that dealing with them separately appear fraught with
error.  The full text was supplied by Bill Plauger; it was cross
checked against changes supplied by Andy Sawyer. It should be further
checked by the LWG.]</i></p>
<hr>
<a name="184"><h3>184.&nbsp;numeric_limits&lt;bool&gt; wording problems</h3></a><p>
<b>Section:</b>&nbsp;18.2.1.5 <a href="lib-support.html#lib.numeric.special"> [lib.numeric.special]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Gabriel Dos Reis&nbsp; <b>Date:</b>&nbsp;21 Jul 1999</p>
<p>bools are defined by the standard to be of integer types, as per
3.9.1  paragraph 7.  However &quot;integer types&quot;
seems to have a special meaning for the author of 18.2. The net effect
is an unclear and confusing specification for
numeric_limits&lt;bool&gt; as evidenced below.</p>

<p>18.2.1.2/7 says numeric_limits&lt;&gt;::digits is, for built-in integer
types, the number of non-sign bits in the representation.</p>

<p>4.5/4 states that a bool promotes to int ; whereas 4.12/1 says any non zero
arithmetical value converts to true.</p>

<p>I don't think it makes sense at all to require
numeric_limits&lt;bool&gt;::digits and numeric_limits&lt;bool&gt;::digits10 to
be meaningful.</p>

<p>The standard defines what constitutes a signed (resp. unsigned) integer
types. It doesn't categorize bool as being signed or unsigned. And the set of
values of bool type has only two elements.</p>

<p>I don't think it makes sense to require numeric_limits&lt;bool&gt;::is_signed
to be meaningful.</p>

<p>18.2.1.2/18 for numeric_limits&lt;integer_type&gt;::radix&nbsp; says:</p>
<blockquote>
  <p>For integer types, specifies the base of the representation.186)</p>
</blockquote>

<p>This disposition is at best misleading and confusing for the standard
requires a &quot;pure binary numeration system&quot; for integer types as per
3.9.1/7</p>

<p>The footnote 186) says: &quot;Distinguishes types with base other than 2 (e.g
BCD).&quot;&nbsp; This also erroneous as the standard never defines any integer
types with base representation other than 2.</p>

<p>Furthermore, numeric_limits&lt;bool&gt;::is_modulo and
numeric_limits&lt;bool&gt;::is_signed have similar problems.</p>
<p><b>Proposed resolution:</b></p>
<p>Append to the end of 18.2.1.5 :</p>
<blockquote>
  <p>The specialization for bool shall be provided as follows:</p>
  <pre>    namespace std {
       template&lt;&gt; class numeric_limits&lt;bool&gt; {
       public:
         static const bool is_specialized = true;
         static bool min() throw() { return false; }
         static bool max() throw() { return true; }

         static const int  digits = 1;
         static const int  digits10 = 0;
         static const bool is_signed = false;
         static const bool is_integer = true;
         static const bool is_exact = true;
         static const int  radix = 2;
         static bool epsilon() throw() { return 0; }
         static bool round_error() throw() { return 0; }

         static const int  min_exponent = 0;
         static const int  min_exponent10 = 0;
         static const int  max_exponent = 0;
         static const int  max_exponent10 = 0;

         static const bool has_infinity = false;
         static const bool has_quiet_NaN = false;
         static const bool has_signaling_NaN = false;
         static const float_denorm_style has_denorm = denorm_absent;
         static const bool has_denorm_loss = false;
         static bool infinity() throw() { return 0; }
         static bool quiet_NaN() throw() { return 0; }
         static bool signaling_NaN() throw() { return 0; }
         static bool denorm_min() throw() { return 0; }

         static const bool is_iec559 = false;
         static const bool is_bounded = true;
         static const bool is_modulo = false;

         static const bool traps = false;
         static const bool tinyness_before = false;
         static const float_round_style round_style = round_toward_zero;
       };
     }</pre>
</blockquote>

<p><i>[Tokyo:&nbsp; The LWG desires wording that specifies exact values
rather than more general wording in the original proposed
resolution.]</i></p>

<p><i>[Post-Tokyo:&nbsp; At the request of the LWG in Tokyo, Nico
Josuttis provided the above wording.]</i></p>
<hr>
<a name="185"><h3>185.&nbsp;Questionable use of term &quot;inline&quot;</h3></a><p>
<b>Section:</b>&nbsp;20.3 <a href="lib-utilities.html#lib.function.objects"> [lib.function.objects]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;UK Panel&nbsp; <b>Date:</b>&nbsp;26 Jul 1999</p>
<p>Paragraph 4 of 20.3  says:</p>
<blockquote>
  <p>&nbsp;[Example: To negate every element of a: transform(a.begin(), a.end(),
  a.begin(), negate&lt;double&gt;()); The corresponding functions will inline
  the addition and the negation. end example]</p>
</blockquote>
<p>(Note: The &quot;addition&quot; referred to in the above is in para 3) we can
find no other wording, except this (non-normative) example which suggests that
any &quot;inlining&quot; will take place in this case.</p>
<p>Indeed both:</p>
<blockquote>
  <p>17.4.4.3 Global Functions [lib.global.functions] 1 It is
  unspecified whether any global functions in the C++ Standard Library
  are defined as inline (7.1.2).</p>
</blockquote>
<p>and</p>
<blockquote>
  <p>17.4.4.4 Member Functions [lib.member.functions] 1 It is
  unspecified whether any member functions in the C++ Standard Library
  are defined as inline (7.1.2).</p>
</blockquote>
<p>take care to state that this may indeed NOT be the case.</p>
<p>Thus the example &quot;mandates&quot; behavior that is explicitly
not required elsewhere.</p>
<p><b>Proposed resolution:</b></p>
<p>In 20.3  paragraph 1, remove the sentence:</p>
<blockquote>
<p>They are important for the effective use of the library.</p>
</blockquote>
<p>Remove 20.3  paragraph 2, which reads:</p>
<blockquote>
  <p> Using function objects together with function templates
  increases the expressive power of the library as well as making the
  resulting code much more efficient.</p>
</blockquote>
<p>In 20.3  paragraph 4, remove the sentence:</p>
<blockquote>
  <p>The corresponding functions will inline the addition and the
  negation.</p>
</blockquote>

<p><i>[Kona: The LWG agreed there was a defect.]</i></p>
<p><i>[Tokyo: The LWG crafted the proposed resolution.]</i></p>
<hr>
<a name="186"><h3>186.&nbsp;bitset::set() second parameter should be bool</h3></a><p>
<b>Section:</b>&nbsp;23.3.5.2 <a href="lib-containers.html#lib.bitset.members"> [lib.bitset.members]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Darin Adler&nbsp; <b>Date:</b>&nbsp;13 Aug 1999</p>
<p>In section 23.3.5.2 , paragraph 13 defines the
bitset::set operation to take a second parameter of type int. The
function tests whether this value is non-zero to determine whether to
set the bit to true or false. The type of this second parameter should
be bool. For one thing, the intent is to specify a Boolean value. For
another, the result type from test() is bool. In addition, it's
possible to slice an integer that's larger than an int. This can't
happen with bool, since conversion to bool has the semantic of
translating 0 to false and any non-zero value to true.</p>
<p><b>Proposed resolution:</b></p>
<p>In 23.3.5  Para 1 Replace:</p>
<blockquote>
<pre>bitset&lt;N&gt;&amp; set(size_t pos, int val = true ); </pre>
</blockquote>
<p>With:</p>
<blockquote>
  <pre>bitset&lt;N&gt;&amp; set(size_t pos, bool val = true );</pre>
</blockquote>
<p>In 23.3.5.2  Para 12(.5) Replace:</p>
<blockquote>
  <pre>bitset&lt;N&gt;&amp; set(size_t pos, int val = 1 );</pre>
</blockquote>
<p>With:</p>
<blockquote>
  <pre>bitset&lt;N&gt;&amp; set(size_t pos, bool val = true );</pre>
</blockquote>

<p><i>[Kona: The LWG agrees with the description.&nbsp; Andy Sawyer will work
on better P/R wording.]</i></p>
<p><i>[Post-Tokyo: Andy provided the above wording.]</i></p>
<p><b>Rationale:</b></p>
<p>
<tt>bool</tt> is a better choice.  It is believed that binary
compatibility is not an issue, because this member function is
usually implemented as <tt>inline</tt>, and because it is already
the case that users cannot rely on the type of a pointer to a
nonvirtual member of a standard library class.</p>
<hr>
<a name="189"><h3>189.&nbsp;setprecision() not specified correctly</h3></a><p>
<b>Section:</b>&nbsp;27.4.2.2 <a href="lib-iostreams.html#lib.fmtflags.state"> [lib.fmtflags.state]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Andrew Koenig&nbsp; <b>Date:</b>&nbsp;25 Aug 1999</p>
<p>27.4.2.2 paragraph 9 claims that setprecision() sets the precision,
and includes a parenthetical note saying that it is the number of
digits after the decimal point.<br>
<br>
This claim is not strictly correct.  For example, in the default
floating-point output format, setprecision sets the number of
significant digits printed, not the number of digits after the decimal
point.<br>
<br>
I would like the committee to look at the definition carefully and
correct the statement in 27.4.2.2</p>
<p><b>Proposed resolution:</b></p>
<p>Remove from 27.4.2.2 , paragraph 9, the text
&quot;(number of digits after the decimal point)&quot;.</p>
<hr>
<a name="193"><h3>193.&nbsp;Heap operations description incorrect</h3></a><p>
<b>Section:</b>&nbsp;25.3.6 <a href="lib-algorithms.html#lib.alg.heap.operations"> [lib.alg.heap.operations]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Markus Mauhart&nbsp; <b>Date:</b>&nbsp;24 Sep 1999</p>
<p>25.3.6 [lib.alg.heap.operations] states two key properties of a heap [a,b), the first of them
is<br>
<br>
&nbsp;&nbsp;&nbsp; `&quot;(1) *a is the largest element&quot;<br>
<br>
I think this is incorrect and should be changed to the wording in the proposed
resolution.</p>
<p>Actually there are two independent changes:</p>
<blockquote>
  <p>A-&quot;part of largest equivalence class&quot; instead of &quot;largest&quot;, cause 25.3
  [lib.alg.sorting] asserts &quot;strict weak ordering&quot; for all its sub clauses.</p>
  <p>B-Take 'an oldest' from that equivalence class, otherwise the heap functions  could not be used for a
  priority queue as explained in 23.2.3.2.2 [lib.priqueue.members] (where I assume that a &quot;priority queue&quot; respects  priority AND time).</p>
</blockquote>
<p><b>Proposed resolution:</b></p>
<p>Change 25.3.6  property (1) from:</p>
<blockquote>
  <p>(1) *a is the largest element</p>
</blockquote>
<p>to:</p>
<blockquote>
  <p>(1) There is no element greater than <tt>*a</tt>
</p>
</blockquote>
<hr>
<a name="195"><h3>195.&nbsp;Should <tt>basic_istream::sentry</tt>'s constructor ever set eofbit?</h3></a><p>
<b>Section:</b>&nbsp;27.6.1.1.2 <a href="lib-iostreams.html#lib.istream::sentry"> [lib.istream::sentry]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Matt Austern&nbsp; <b>Date:</b>&nbsp;13 Oct 1999</p>
<p>Suppose that <tt>is.flags() &amp; ios_base::skipws</tt> is nonzero.
What should <tt>basic_istream&lt;&gt;::sentry</tt>'s constructor do if it
reaches eof while skipping whitespace?  27.6.1.1.2/5 suggests it
should set failbit. Should it set eofbit as well?  The standard
doesn't seem to answer that question.</p>

<p>On the one hand, nothing in 27.6.1.1.2  says that
<tt>basic_istream&lt;&gt;::sentry</tt> should ever set eofbit.  On the
other hand, 27.6.1.1  paragraph 4 says that if
extraction from a <tt>streambuf</tt> &quot;returns
<tt>traits::eof()</tt>, then the input function, except as explicitly
noted otherwise, completes its actions and does
<tt>setstate(eofbit)&quot;</tt>.  So the question comes down to
whether <tt>basic_istream&lt;&gt;::sentry</tt>'s constructor is an
input function.</p>

<p>Comments from Jerry Schwarz:</p>
<blockquote>
<p>It was always my intention that eofbit should be set any time that a
virtual returned something to indicate eof, no matter what reason
iostream code had for calling the virtual.</p>
<p>
The motivation for this is that I did not want to require streambufs
to behave consistently if their virtuals are called after they have
signaled eof.</p>
<p>
The classic case is a streambuf reading from a UNIX file.  EOF isn't
really a state for UNIX file descriptors.  The convention is that a
read on UNIX returns 0 bytes to indicate &quot;EOF&quot;, but the file
descriptor isn't shut down in any way and future reads do not
necessarily also return 0 bytes.  In particular, you can read from
tty's on UNIX even after they have signaled &quot;EOF&quot;.  (It
isn't always understood that a ^D on UNIX is not an EOF indicator, but
an EOL indicator.  By typing a &quot;line&quot; consisting solely of
^D you cause a read to return 0 bytes, and by convention this is
interpreted as end of file.)</p>
</blockquote>
<p><b>Proposed resolution:</b></p>
<p>Add a sentence to the end of 27.6.1.1.2 paragraph 2:</p>
<blockquote>
<p>If <tt>is.rdbuf()-&gt;sbumpc()</tt> or <tt>is.rdbuf()-&gt;sgetc()</tt>
returns <tt>traits::eof()</tt>, the function calls
<tt>setstate(failbit | eofbit)</tt> (which may throw
<tt>ios_base::failure</tt>).
</p>
</blockquote>
<hr>
<a name="199"><h3>199.&nbsp;What does <tt>allocate(0)</tt> return?</h3></a><p>
<b>Section:</b>&nbsp;20.1.5 <a href="lib-utilities.html#lib.allocator.requirements"> [lib.allocator.requirements]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Matt Austern&nbsp; <b>Date:</b>&nbsp;19 Nov 1999</p>
<p>
Suppose that <tt>A</tt> is a class that conforms to the
Allocator requirements of Table 32, and <tt>a</tt> is an
object of class <tt>A</tt>  What should be the return
value of <tt>a.allocate(0)</tt>?  Three reasonable
possibilities: forbid the argument <tt>0</tt>, return
a null pointer, or require that the return value be a
unique non-null pointer.
</p>
<p><b>Proposed resolution:</b></p>
<p>
Add a note to the <tt>allocate</tt> row of Table 32:
&quot;[<i>Note:</i> If <tt>n == 0</tt>, the return value is unspecified. <i>--end note</i>]&quot;</p>
<p><b>Rationale:</b></p>
<p>A key to understanding this issue is that the ultimate use of
allocate() is to construct an iterator, and that iterator for zero
length sequences must be the container's past-the-end
representation.  Since this already implies special case code, it
would be over-specification to mandate the return value.
</p>
<hr>
<a name="208"><h3>208.&nbsp;Unnecessary restriction on past-the-end iterators</h3></a><p>
<b>Section:</b>&nbsp;24.1 <a href="lib-iterators.html#lib.iterator.requirements"> [lib.iterator.requirements]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Stephen Cleary&nbsp; <b>Date:</b>&nbsp;02 Feb 2000</p>
<p>In 24.1 paragraph 5, it is stated &quot;. . . Dereferenceable and
past-the-end values are always non-singular.&quot;</p>
<p>This places an unnecessary restriction on past-the-end iterators for
containers with forward iterators (for example, a singly-linked list). If the
past-the-end value on such a container was a well-known singular value, it would
still satisfy all forward iterator requirements.</p>
<p>Removing this restriction would allow, for example, a singly-linked list
without a &quot;footer&quot; node.</p>
<p>This would have an impact on existing code that expects past-the-end
iterators obtained from different (generic) containers being not equal.</p>
<p><b>Proposed resolution:</b></p>
<p>Change 24.1  paragraph 5, the last sentence, from:</p>
<blockquote>
<p>Dereferenceable and past-the-end values are always non-singular.</p>
</blockquote>
<p>to:</p>
<blockquote>
<p>Dereferenceable values are always non-singular.&nbsp;</p>
</blockquote>
<p><b>Rationale:</b></p>
<p>For some kinds of containers, including singly linked lists and
zero-length vectors, null pointers are perfectly reasonable past-the-end
iterators.  Null pointers are singular.
</p>
<hr>
<a name="209"><h3>209.&nbsp;basic_string declarations inconsistent</h3></a><p>
<b>Section:</b>&nbsp;21.3 <a href="lib-strings.html#lib.basic.string"> [lib.basic.string]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Igor Stauder&nbsp; <b>Date:</b>&nbsp;11 Feb 2000</p>
<p>In Section 21.3  the basic_string member function
declarations use a consistent style except for the following functions:</p>
<blockquote>
  <pre>void push_back(const charT);
basic_string&amp; assign(const basic_string&amp;);
void swap(basic_string&lt;charT,traits,Allocator&gt;&amp;);</pre>
</blockquote>
<p>- push_back, assign, swap: missing argument name&nbsp;<br>
- push_back: use of const with charT (i.e. POD type passed by value
not by reference - should be charT or const charT&amp; )<br>
- swap: redundant use of template parameters in argument
basic_string&lt;charT,traits,Allocator&gt;&amp;</p>
<p><b>Proposed resolution:</b></p>
<p>In Section 21.3  change the basic_string member
function declarations push_back, assign, and swap to:</p>
<blockquote>
  <pre>void push_back(charT c); 

basic_string&amp; assign(const basic_string&amp; str);
void swap(basic_string&amp; str);</pre>
</blockquote>
<p><b>Rationale:</b></p>
<p>Although the standard is in general not consistent in declaration
style, the basic_string declarations are consistent other than the
above.  The LWG felt that this was sufficient reason to merit the
change.
</p>
<hr>
<a name="210"><h3>210.&nbsp;distance first and last confused</h3></a><p>
<b>Section:</b>&nbsp;25 <a href="lib-algorithms.html#lib.algorithms"> [lib.algorithms]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Lisa Lippincott&nbsp; <b>Date:</b>&nbsp;15 Feb 2000</p>
<p>In paragraph 9 of section 25 , it is written:</p>
<blockquote>
  <p>      In the description of the algorithms operators + and - are used
           for some of the iterator categories for which they do not have to
           be defined. In these cases the semantics of [...] a-b is the same
           as of<br>
  <br>
  &nbsp;&nbsp;&nbsp;&nbsp; <tt>return distance(a, b);</tt>
</p>
</blockquote>
<p><b>Proposed resolution:</b></p>
<p>On the last line of paragraph 9 of section 25  change
<tt>&quot;a-b&quot;</tt> to <tt>&quot;b-a&quot;.</tt>
</p>
<p><b>Rationale:</b></p>
<p>There are two ways to fix the defect; change the description to b-a
or change the return to distance(b,a).  The LWG preferred the
former for consistency.</p>
<hr>
<a name="211"><h3>211.&nbsp;operator&gt;&gt;(istream&amp;, string&amp;) doesn't set failbit</h3></a><p>
<b>Section:</b>&nbsp;21.3.7.9 <a href="lib-strings.html#lib.string.io"> [lib.string.io]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Scott Snyder&nbsp; <b>Date:</b>&nbsp;4 Feb 2000</p>
<p>The description of the stream extraction operator for std::string (section
21.3.7.9 [lib.string.io]) does not contain a requirement that failbit be set in
the case that the operator fails to extract any characters from the input
stream.</p>
<p>This implies that the typical construction</p>
<blockquote>
  <pre>std::istream is;
std::string str;
...
while (is &gt;&gt; str) ... ;</pre>
</blockquote>
<p>(which tests failbit) is not required to terminate at EOF.</p>
<p>Furthermore, this is inconsistent with other extraction operators,
which do include this requirement. (See sections 27.6.1.2  and 27.6.1.3 ), where this
requirement is present, either explicitly or implicitly, for the
extraction operators. It is also present explicitly in the description
of getline (istream&amp;, string&amp;, charT) in section 21.3.7.9  paragraph 8.)</p>
<p><b>Proposed resolution:</b></p>
<p>Insert new paragraph after paragraph 2 in section 21.3.7.9 :</p>
<blockquote>

<p>If the function extracts no characters, it calls
is.setstate(ios::failbit) which may throw ios_base::failure
(27.4.4.3).</p>
</blockquote>
<hr>
<a name="212"><h3>212.&nbsp;Empty range behavior unclear for several algorithms</h3></a><p>
<b>Section:</b>&nbsp;25.3.7 <a href="lib-algorithms.html#lib.alg.min.max"> [lib.alg.min.max]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Nico Josuttis&nbsp; <b>Date:</b>&nbsp;26 Feb 2000</p>
<p>The standard doesn't specify what min_element() and max_element() shall
return if the range is empty (first equals last). The usual implementations
return last. This problem seems also apply to partition(), stable_partition(),
next_permutation(), and prev_permutation().</p>
<p><b>Proposed resolution:</b></p>
<p>In 25.3.7  - Minimum and maximum, paragraphs 7 and
9, append: Returns last if first==last.</p>
<p><b>Rationale:</b></p>
<p>The LWG looked in some detail at all of the above mentioned
algorithms, but believes that except for min_element() and
max_element() it is already clear that last is returned if first ==
last.</p>
<hr>
<a name="214"><h3>214.&nbsp;set::find() missing const overload</h3></a><p>
<b>Section:</b>&nbsp;23.3.3 <a href="lib-containers.html#lib.set"> [lib.set]</a>, 23.3.4 <a href="lib-containers.html#lib.multiset"> [lib.multiset]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Judy Ward&nbsp; <b>Date:</b>&nbsp;28 Feb 2000</p>
<p>The specification for the associative container requirements in
Table 69 state that the find member function should &quot;return
iterator; const_iterator for constant a&quot;. The map and multimap
container descriptions have two overloaded versions of find, but set
and multiset do not, all they have is:</p>
<blockquote>
  <pre>iterator find(const key_type &amp; x) const;</pre>
</blockquote>
<p><b>Proposed resolution:</b></p>
<p>Change the prototypes for find(), lower_bound(), upper_bound(), and
equal_range() in section 23.3.3  and section 23.3.4  to each have two overloads:</p>
<blockquote>
  <pre>iterator find(const key_type &amp; x);
const_iterator find(const key_type &amp; x) const;</pre>
  <pre>iterator lower_bound(const key_type &amp; x);
const_iterator lower_bound(const key_type &amp; x) const;</pre>
  <pre>iterator upper_bound(const key_type &amp; x);
const_iterator upper_bound(const key_type &amp; x) const;</pre>
  <pre>pair&lt;iterator, iterator&gt; equal_range(const key_type &amp; x);
pair&lt;const_iterator, const_iterator&gt; equal_range(const key_type &amp; x) const;</pre>
</blockquote>

<p><i>[Tokyo: At the request of the LWG, Judy Ward provided wording
extending the proposed resolution to lower_bound, upper_bound, and
equal_range.]</i></p>
<hr>
<a name="217"><h3>217.&nbsp;Facets example (Classifying Japanese characters) contains errors</h3></a><p>
<b>Section:</b>&nbsp;22.2.8 <a href="lib-locales.html#lib.facets.examples"> [lib.facets.examples]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Martin Sebor&nbsp; <b>Date:</b>&nbsp;29 Feb 2000</p>
<p>The example in 22.2.8, paragraph 11 contains the following errors:</p>
<p>1) The member function `My::JCtype::is_kanji()' is non-const; the function
must be const in order for it to be callable on a const object (a reference to
which which is what std::use_facet&lt;&gt;() returns).</p>
<p>2) In file filt.C, the definition of `JCtype::id' must be qualified with the
name of the namespace `My'.</p>
<p>3) In the definition of `loc' and subsequently in the call to use_facet&lt;&gt;()
in main(), the name of the facet is misspelled: it should read `My::JCtype'
rather than `My::JCType'.</p>
<p><b>Proposed resolution:</b></p>
<p>Replace the &quot;Classifying Japanese characters&quot; example in 22.2.8,
paragraph 11 with the following:</p>
<pre>#include &lt;locale&gt;</pre>
<pre>namespace My {
    using namespace std;
    class JCtype : public locale::facet {
    public:
        static locale::id id;     //  required for use as a new locale facet
        bool is_kanji (wchar_t c) const;
        JCtype() {}
    protected:
        ~JCtype() {}
    };
}</pre>
<pre>//  file:  filt.C
#include &lt;iostream&gt;
#include &lt;locale&gt;
#include &quot;jctype&quot;                 //  above
std::locale::id My::JCtype::id;   //  the static  JCtype  member
declared above.</pre>
<pre>int main()
{
    using namespace std;
    typedef ctype&lt;wchar_t&gt; wctype;
    locale loc(locale(&quot;&quot;),              //  the user's preferred locale...
               new My::JCtype);         //  and a new feature ...
    wchar_t c = use_facet&lt;wctype&gt;(loc).widen('!');
    if (!use_facet&lt;My::JCtype&gt;(loc).is_kanji(c))
        cout &lt;&lt; &quot;no it isn't!&quot; &lt;&lt; endl;
    return 0;
}</pre>
<hr>
<a name="220"><h3>220.&nbsp;~ios_base() usage valid?</h3></a><p>
<b>Section:</b>&nbsp;27.4.2.7 <a href="lib-iostreams.html#lib.ios.base.cons"> [lib.ios.base.cons]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Jonathan Schilling, Howard Hinnant&nbsp; <b>Date:</b>&nbsp;13 Mar 2000</p>
<p>The pre-conditions for the ios_base destructor are described in 27.4.2.7
paragraph 2:</p>
<blockquote>
  <p>Effects: Destroys an object of class ios_base. Calls each registered
  callback pair (fn,index) (27.4.2.6) as (*fn)(erase_event,*this,index) at such
  time that any ios_base member function called from within fn has well defined
  results.</p>
</blockquote>
<p>But what is not clear is: If no callback functions were ever registered, does
it matter whether the ios_base members were ever initialized?</p>
<p>For instance, does this program have defined behavior:</p>
<blockquote>
  <pre>#include &lt;ios&gt;</pre>
  <pre>class D : public std::ios_base { };</pre>
  <pre>int main() { D d; }</pre>
</blockquote>
<p>It seems that registration of a callback function would surely affect the
state of an ios_base. That is, when you register a callback function with an
ios_base, the ios_base must record that fact somehow.</p>
<p>But if after construction the ios_base is in an indeterminate state, and that
state is not made determinate before the destructor is called, then how would
the destructor know if any callbacks had indeed been registered? And if the
number of callbacks that had been registered is indeterminate, then is not the
behavior of the destructor undefined?</p>
<p>By comparison, the basic_ios class description in 27.4.4.1 paragraph 2 makes
it explicit that destruction before initialization results in undefined
behavior.</p>
<p><b>Proposed resolution:</b></p>
<p>Modify 27.4.2.7 paragraph 1 from</p>
<blockquote>
  <p>Effects: Each ios_base member has an indeterminate value after
  construction.</p>
</blockquote>
<p>to</p>
<blockquote>
  <p>Effects: Each ios_base member has an indeterminate value after
  construction. These members must be initialized by calling basic_ios::init. If an ios_base object is destroyed before these initializations
  have taken place, the behavior is undefined.</p>
</blockquote>
<hr>
<a name="221"><h3>221.&nbsp;num_get&lt;&gt;::do_get stage 2 processing broken</h3></a><p>
<b>Section:</b>&nbsp;22.2.2.1.2 <a href="lib-locales.html#lib.facet.num.get.virtuals"> [lib.facet.num.get.virtuals]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Matt Austern&nbsp; <b>Date:</b>&nbsp;14 Mar 2000</p>
<p>Stage 2 processing of numeric conversion is broken.</p>

<p>Table 55 in 22.2.2.1.2 says that when basefield is 0 the integral
conversion specifier is %i. A %i specifier determines a number's base
by its prefix (0 for octal, 0x for hex), so the intention is clearly
that a 0x prefix is allowed.  Paragraph 8 in the same section,
however, describes very precisely how characters are processed. (It
must be done &quot;as if&quot; by a specified code fragment.) That
description does not allow a 0x prefix to be recognized.</p>

<p>Very roughly, stage 2 processing reads a char_type ct. It converts
ct to a char, not by using narrow but by looking it up in a
translation table that was created by widening the string literal
&quot;0123456789abcdefABCDEF+-&quot;. The character &quot;x&quot; is
not found in that table, so it can't be recognized by stage 2
processing.</p>
<p><b>Proposed resolution:</b></p>
<p>In 22.2.2.1.2 paragraph 8, replace the line:</p>
<blockquote>
  <pre>static const char src[] = &quot;0123456789abcdefABCDEF+-&quot;;</pre>
</blockquote>
<p>with the line:</p>
<blockquote>
  <pre>static const char src[] = &quot;0123456789abcdefxABCDEFX+-&quot;;</pre>
</blockquote>
<p><b>Rationale:</b></p>
<p>If we're using the technique of widening a string literal, the
string literal must contain every character we wish to recognize.
This technique has the consequence that alternate representations
of digits will not be recognized.  This design decision was made
deliberately, with full knowledge of that limitation.</p>
<hr>
<a name="222"><h3>222.&nbsp;Are throw clauses necessary if a throw is already implied by the effects clause?</h3></a><p>
<b>Section:</b>&nbsp;17.3.1.3 <a href="lib-intro.html#lib.structure.specifications"> [lib.structure.specifications]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Judy Ward&nbsp; <b>Date:</b>&nbsp;17 Mar 2000</p>
<p>Section 21.3.6.8 describes the basic_string::compare function this way:</p>
<blockquote>
  <pre>21.3.6.8 - basic_string::compare [lib.string::compare]

int compare(size_type pos1, size_type n1,
                const basic_string&lt;charT,traits,Allocator&gt;&amp;  str ,
                size_type  pos2 , size_type  n2 ) const;

-4- Returns: 

    basic_string&lt;charT,traits,Allocator&gt;(*this,pos1,n1).compare(
                 basic_string&lt;charT,traits,Allocator&gt;(str,pos2,n2)) .</pre>
</blockquote>
<p>and the constructor that's implicitly called by the above is
defined to throw an out-of-range exception if pos &gt; str.size(). See
section 21.3.1  paragraph 4.</p>

<p>On the other hand, the compare function descriptions themselves don't have
&quot;Throws: &quot; clauses and according to 17.3.1.3, paragraph 3, elements
that do not apply to a function are omitted.</p>
<p>So it seems there is an inconsistency in the standard -- are the
&quot;Effects&quot; clauses correct, or are the &quot;Throws&quot; clauses
missing?</p>
<p><b>Proposed resolution:</b></p>
<p>In 17.3.1.3  paragraph 3, the footnote 148 attached to
the sentence &quot;Descriptions of function semantics contain the
following elements (as appropriate):&quot;, insert the word
&quot;further&quot; so that the foot note reads:</p>
<blockquote>
  <p>To save space, items that do not apply to a function are
  omitted. For example, if a function does not specify any further
  preconditions, there will be no &quot;Requires&quot; paragraph.</p>
</blockquote>
<p><b>Rationale:</b></p>
<p>The standard is somewhat inconsistent, but a failure to note a
throw condition in a throws clause does not grant permission not to
throw.  The inconsistent wording is in a footnote, and thus
non-normative. The proposed resolution from the LWG clarifies the
footnote.</p>
<hr>
<a name="223"><h3>223.&nbsp;reverse algorithm should use iter_swap rather than swap</h3></a><p>
<b>Section:</b>&nbsp;25.2.9 <a href="lib-algorithms.html#lib.alg.reverse"> [lib.alg.reverse]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Dave Abrahams&nbsp; <b>Date:</b>&nbsp;21 Mar 2000</p>
<p>Shouldn't the effects say &quot;applies iter_swap to all pairs...&quot;?</p>
<p><b>Proposed resolution:</b></p>
<p>In 25.2.9 , replace:</p>
  <blockquote>
  Effects: For each non-negative integer i &lt;= (last - first)/2, 
  applies swap to all pairs of iterators first + i, (last - i) - 1.
  </blockquote>
<p>with:</p>
  <blockquote>
  Effects: For each non-negative integer i &lt;= (last - first)/2, 
  applies iter_swap to all pairs of iterators first + i, (last - i) - 1.
  </blockquote>
<hr>
<a name="224"><h3>224.&nbsp;clear() complexity for associative containers refers to undefined N</h3></a><p>
<b>Section:</b>&nbsp;23.1.2 <a href="lib-containers.html#lib.associative.reqmts"> [lib.associative.reqmts]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Ed Brey&nbsp; <b>Date:</b>&nbsp;23 Mar 2000</p>
<p>In the associative container requirements table in 23.1.2 paragraph 7,
a.clear() has complexity &quot;log(size()) + N&quot;. However, the meaning of N
is not defined.</p>
<p><b>Proposed resolution:</b></p>
<p>In the associative container requirements table in 23.1.2 paragraph
7, the complexity of a.clear(), change &quot;log(size()) + N&quot; to
&quot;linear in <tt>size()</tt>&quot;.</p>
<p><b>Rationale:</b></p>
<p>It's the &quot;log(size())&quot;, not the &quot;N&quot;, that is in
error: there's no difference between <i>O(N)</i> and <i>O(N +
log(N))</i>.  The text in the standard is probably an incorrect
cut-and-paste from the range version of <tt>erase</tt>.</p>
<hr>
<a name="227"><h3>227.&nbsp;std::swap() should require CopyConstructible or DefaultConstructible arguments</h3></a><p>
<b>Section:</b>&nbsp;25.2.2 <a href="lib-algorithms.html#lib.alg.swap"> [lib.alg.swap]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Dave Abrahams&nbsp; <b>Date:</b>&nbsp;09 Apr 2000</p>
<p>25.2.2 reads:</p>
<blockquote>
  <p>
<tt>  template&lt;class T&gt; void swap(T&amp; a, T&amp; b);</tt><br>
  <br>
  Requires:    Type T is Assignable (_lib.container.requirements_).<br>
  Effects:    Exchanges values stored in two locations.</p>
</blockquote>
<p>The only reasonable** generic implementation of swap requires construction of a 
   new temporary copy of one of its arguments:</p>
<blockquote>
<pre>template&lt;class T&gt; void swap(T&amp; a, T&amp; b);
  {
      T tmp(a);
      a = b;
      b = tmp;
  }</pre>
</blockquote>
<p>But a type which is only Assignable cannot be swapped by this implementation.</p>
<p>**Yes, there's also an unreasonable implementation which would require T to be 
   DefaultConstructible instead of CopyConstructible. I don't think this is worthy 
   of consideration:</p>
<blockquote>
<pre>template&lt;class T&gt; void swap(T&amp; a, T&amp; b);
{
    T tmp;
    tmp = a;
    a = b;
    b = tmp;
}</pre>
</blockquote>
<p><b>Proposed resolution:</b></p>
<p>Change 25.2.2 paragraph 1 from:</p>
<blockquote>
<p>  Requires: Type T is Assignable (23.1).</p>
</blockquote>
<p>to:</p>
<blockquote>
<p>  Requires: Type T is CopyConstructible (20.1.3) and Assignable (23.1)</p>
</blockquote>
<hr>
<a name="234"><h3>234.&nbsp;Typos in allocator definition</h3></a><p>
<b>Section:</b>&nbsp;20.4.1.1 <a href="lib-utilities.html#lib.allocator.members"> [lib.allocator.members]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Dietmar K&uuml;hl&nbsp; <b>Date:</b>&nbsp;24 Apr 2000</p>
<p>In paragraphs 12 and 13 the effects of <tt>construct()</tt> and
<tt>destruct()</tt> are described as returns but the functions actually
return <tt>void</tt>.</p>
<p><b>Proposed resolution:</b></p>
<p>Substitute &quot;Returns&quot; by &quot;Effect&quot;.</p>
<hr>
<a name="237"><h3>237.&nbsp;Undefined expression in complexity specification</h3></a><p>
<b>Section:</b>&nbsp;23.2.2.1 <a href="lib-containers.html#lib.list.cons"> [lib.list.cons]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Dietmar K&uuml;hl&nbsp; <b>Date:</b>&nbsp;24 Apr 2000</p>
<p>The complexity specification in paragraph 6 says that the complexity
is linear in <tt>first - last</tt>. Even if <tt>operator-()</tt> is
defined on iterators this term is in general undefined because it
would have to be <tt>last - first</tt>.</p>
<p><b>Proposed resolution:</b></p>
  <p>Change paragraph 6 from</p>
     <blockquote>Linear in <i>first - last</i>.</blockquote>
  <p>to become</p>
     <blockquote>Linear in <i>distance(first, last)</i>.</blockquote>
<hr>
<a name="243"><h3>243.&nbsp;<tt>get</tt> and <tt>getline</tt> when sentry reports failure</h3></a><p>
<b>Section:</b>&nbsp;27.6.1.3 <a href="lib-iostreams.html#lib.istream.unformatted"> [lib.istream.unformatted]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Martin Sebor&nbsp; <b>Date:</b>&nbsp;May 15 2000</p>
<p>basic_istream&lt;&gt;::get(), and basic_istream&lt;&gt;::getline(),
are unclear with respect to the behavior and side-effects of the named
functions in case of an error.</p>

<p>27.6.1.3, p1 states that &quot;... If the sentry object returns
true, when converted to a value of type bool, the function endeavors
to obtain the requested input...&quot; It is not clear from this (or
the rest of the paragraph) what precisely the behavior should be when
the sentry ctor exits by throwing an exception or when the sentry
object returns false.  In particular, what is the number of characters
extracted that gcount() returns supposed to be?</p>

<p>27.6.1.3 p8 and p19 say about the effects of get() and getline():
&quot;...  In any case, it then stores a null character (using
charT()) into the next successive location of the array.&quot; Is not
clear whether this sentence applies if either of the conditions above
holds (i.e., when sentry fails).</p>
<p><b>Proposed resolution:</b></p>
<p>Add to 27.6.1.3, p1 after the sentence</p>

<blockquote>
&quot;... If the sentry object returns true, when converted to a value of
type bool, the function endeavors to obtain the requested input.&quot;
</blockquote>

<p>the following</p>


<blockquote>
&quot;Otherwise, if the sentry constructor exits by throwing an exception or
if the sentry object returns false, when converted to a value of type
bool, the function returns without attempting to obtain any input. In
either case the number of extracted characters is set to 0; unformatted
input functions taking a character array of non-zero size as an argument
shall also store a null character (using charT()) in the first location
of the array.&quot;
</blockquote>
<p><b>Rationale:</b></p>
<p>Although the general philosophy of the input functions is that the
argument should not be modified upon failure, <tt>getline</tt>
historically added a terminating null unconditionally.  Most
implementations still do that.  Earlier versions of the draft standard
had language that made this an unambiguous requirement; those words
were moved to a place where their context made them less clear.  See
Jerry Schwarz's message c++std-lib-7618.</p>
<hr>
<a name="248"><h3>248.&nbsp;time_get fails to set eofbit</h3></a><p>
<b>Section:</b>&nbsp;22.2.5 <a href="lib-locales.html#lib.category.time"> [lib.category.time]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Martin Sebor&nbsp; <b>Date:</b>&nbsp;22 June 2000</p>
<p>There is no requirement that any of time_get member functions set
ios::eofbit when they reach the end iterator while parsing their input.
Since members of both the num_get and money_get facets are required to
do so (22.2.2.1.2, and 22.2.6.1.2, respectively), time_get members
should follow the same requirement for consistency.</p>
<p><b>Proposed resolution:</b></p>
<p>Add paragraph 2 to section 22.2.5.1 with the following text:</p>

<blockquote>
If the end iterator is reached during parsing by any of the get()
member functions, the member sets ios_base::eofbit in err.
</blockquote>
<p><b>Rationale:</b></p>
<p>Two alternative resolutions were proposed.  The LWG chose this one
because it was more consistent with the way eof is described for other
input facets.</p>
<hr>
<a name="251"><h3>251.&nbsp;basic_stringbuf missing allocator_type</h3></a><p>
<b>Section:</b>&nbsp;27.7.1 <a href="lib-iostreams.html#lib.stringbuf"> [lib.stringbuf]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Martin Sebor&nbsp; <b>Date:</b>&nbsp;28 Jul 2000</p>
<p>The synopsis for the template class <tt>basic_stringbuf</tt>
doesn't list a typedef for the template parameter
<tt>Allocator</tt>. This makes it impossible to determine the type of
the allocator at compile time. It's also inconsistent with all other
template classes in the library that do provide a typedef for the
<tt>Allocator</tt> parameter.</p>
<p><b>Proposed resolution:</b></p>
<p>Add to the synopses of the class templates basic_stringbuf (27.7.1),
basic_istringstream (27.7.2), basic_ostringstream (27.7.3), and 
basic_stringstream (27.7.4) the typedef:</p>
<pre>
  typedef Allocator allocator_type;
</pre>
<hr>
<a name="252"><h3>252.&nbsp;missing casts/C-style casts used in iostreams</h3></a><p>
<b>Section:</b>&nbsp;27.7 <a href="lib-iostreams.html#lib.string.streams"> [lib.string.streams]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Martin Sebor&nbsp; <b>Date:</b>&nbsp;28 Jul 2000</p>
<p>27.7.2.2, p1 uses a C-style cast rather than the more appropriate
const_cast&lt;&gt; in the Returns clause for basic_istringstream&lt;&gt;::rdbuf().
The same C-style cast is being used in 27.7.3.2, p1, D.7.2.2, p1, and
D.7.3.2, p1, and perhaps elsewhere. 27.7.6, p1 and D.7.2.2, p1 are missing
the cast altogether.</p>

<p>C-style casts have not been deprecated, so the first part of this
issue is stylistic rather than a matter of correctness.</p>
<p><b>Proposed resolution:</b></p>
<p>In 27.7.2.2, p1 replace </p>
<pre>  -1- Returns: (basic_stringbuf&lt;charT,traits,Allocator&gt;*)&amp;sb.</pre>

<p>with</p>
<pre>  -1- Returns: const_cast&lt;basic_stringbuf&lt;charT,traits,Allocator&gt;*&gt;(&amp;sb).</pre>


<p>In 27.7.3.2, p1 replace</p>
<pre>  -1- Returns: (basic_stringbuf&lt;charT,traits,Allocator&gt;*)&amp;sb.</pre>

<p>with</p>
<pre>  -1- Returns: const_cast&lt;basic_stringbuf&lt;charT,traits,Allocator&gt;*&gt;(&amp;sb).</pre>

<p>In 27.7.6, p1, replace</p>
<pre>  -1- Returns: &amp;sb</pre>

<p>with</p>
<pre>  -1- Returns: const_cast&lt;basic_stringbuf&lt;charT,traits,Allocator&gt;*&gt;(&amp;sb).</pre>

<p>In D.7.2.2, p1 replace</p>
<pre>  -2- Returns: &amp;sb. </pre>

<p>with</p>
<pre>  -2- Returns: const_cast&lt;strstreambuf*&gt;(&amp;sb).</pre>
<hr>
<a name="256"><h3>256.&nbsp;typo in 27.4.4.2, p17: copy_event does not exist</h3></a><p>
<b>Section:</b>&nbsp;27.4.4.2 <a href="lib-iostreams.html#lib.basic.ios.members"> [lib.basic.ios.members]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Martin Sebor&nbsp; <b>Date:</b>&nbsp;21 Aug 2000</p>
<p>
27.4.4.2, p17 says
</p>

<blockquote>
-17- Before copying any parts of rhs, calls each registered callback
pair (fn,index) as (*fn)(erase_event,*this,index). After all parts but
exceptions() have been replaced, calls each callback pair that was
copied from rhs as (*fn)(copy_event,*this,index). 
</blockquote>

<p>
The name copy_event isn't defined anywhere. The intended name was
copyfmt_event.
</p>
<p><b>Proposed resolution:</b></p>
<p>Replace copy_event with copyfmt_event in the named paragraph.</p>
<hr>
<a name="260"><h3>260.&nbsp;Inconsistent return type of <tt>istream_iterator::operator++(int)</tt>
</h3></a><p>
<b>Section:</b>&nbsp;24.5.1.2 <a href="lib-iterators.html#lib.istream.iterator.ops"> [lib.istream.iterator.ops]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Martin Sebor&nbsp; <b>Date:</b>&nbsp;27 Aug 2000</p>
<p>The synopsis of istream_iterator::operator++(int) in 24.5.1 shows
it as returning the iterator by value. 24.5.1.2, p5 shows the same
operator as returning the iterator by reference. That's incorrect
given the Effects clause below (since a temporary is returned). The
`&amp;' is probably just a typo.</p>
<p><b>Proposed resolution:</b></p>
<p>Change the declaration in 24.5.1.2, p5 from</p>
 <pre>
 istream_iterator&lt;T,charT,traits,Distance&gt;&amp; operator++(int);
 </pre>
<p>to</p>
 <pre>
 istream_iterator&lt;T,charT,traits,Distance&gt; operator++(int);
 </pre>
<p>(that is, remove the `&amp;').</p>
<hr>
<a name="261"><h3>261.&nbsp;Missing description of <tt>istream_iterator::operator!=</tt>
</h3></a><p>
<b>Section:</b>&nbsp;24.5.1.2 <a href="lib-iterators.html#lib.istream.iterator.ops"> [lib.istream.iterator.ops]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Martin Sebor&nbsp; <b>Date:</b>&nbsp;27 Aug 2000</p>
<p>
24.5.1, p3 lists the synopsis for
</p>

<pre>
   template &lt;class T, class charT, class traits, class Distance&gt;
        bool operator!=(const istream_iterator&lt;T,charT,traits,Distance&gt;&amp; x,
                        const istream_iterator&lt;T,charT,traits,Distance&gt;&amp; y);
</pre>

<p>
but there is no description of what the operator does (i.e., no Effects
or Returns clause) in 24.5.1.2.
</p>
<p><b>Proposed resolution:</b></p>
<p>
Add paragraph 7 to the end of section 24.5.1.2 with the following text:
</p>

<pre>
   template &lt;class T, class charT, class traits, class Distance&gt;
        bool operator!=(const istream_iterator&lt;T,charT,traits,Distance&gt;&amp; x,
                        const istream_iterator&lt;T,charT,traits,Distance&gt;&amp; y);
</pre>

<p>-7- Returns: !(x == y).</p>
<hr>
<a name="262"><h3>262.&nbsp;Bitmask operator ~ specified incorrectly</h3></a><p>
<b>Section:</b>&nbsp;17.3.2.1.2 <a href="lib-intro.html#lib.bitmask.types"> [lib.bitmask.types]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Beman Dawes&nbsp; <b>Date:</b>&nbsp;03 Sep 2000</p>
<p>
The ~ operation should be applied after the cast to int_type.
</p>
<p><b>Proposed resolution:</b></p>
<p>
Change 17.3.2.1.2 [lib.bitmask.types] operator~ from:
</p>

<pre>
   bitmask operator~ ( bitmask X )
     { return static_cast&lt; bitmask&gt;(static_cast&lt;int_type&gt;(~ X)); }
</pre>

<p>
to:
</p>

<pre>
   bitmask operator~ ( bitmask X )
     { return static_cast&lt; bitmask&gt;(~static_cast&lt;int_type&gt;(X)); }
</pre>
<hr>
<a name="263"><h3>263.&nbsp;Severe restriction on <tt>basic_string</tt> reference counting</h3></a><p>
<b>Section:</b>&nbsp;21.3 <a href="lib-strings.html#lib.basic.string"> [lib.basic.string]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Kevlin Henney&nbsp; <b>Date:</b>&nbsp;04 Sep 2000</p>
<p>
The note in paragraph 6 suggests that the invalidation rules for
references, pointers, and iterators in paragraph 5 permit a reference-
counted implementation (actually, according to paragraph 6, they permit
a &quot;reference counted implementation&quot;, but this is a minor editorial fix).
</p>

<p>
However, the last sub-bullet is so worded as to make a reference-counted
implementation unviable. In the following example none of the
conditions for iterator invalidation are satisfied:
</p>

<pre>
    // first example: &quot;*******************&quot; should be printed twice
    string original = &quot;some arbitrary text&quot;, copy = original;
    const string &amp; alias = original;

    string::const_iterator i = alias.begin(), e = alias.end();
    for(string::iterator j = original.begin(); j != original.end(); ++j)
        *j = '*';
    while(i != e)
        cout &lt;&lt; *i++;
    cout &lt;&lt; endl;
    cout &lt;&lt; original &lt;&lt; endl;
</pre>

<p>
Similarly, in the following example:
</p>

<pre>
    // second example: &quot;some arbitrary text&quot; should be printed out
    string original = &quot;some arbitrary text&quot;, copy = original;
    const string &amp; alias = original;

    string::const_iterator i = alias.begin();
    original.begin();
    while(i != alias.end())
        cout &lt;&lt; *i++;
</pre>

<p>
I have tested this on three string implementations, two of which were
reference counted. The reference-counted implementations gave
&quot;surprising behavior&quot; because they invalidated iterators on
the first call to non-const begin since construction. The current
wording does not permit such invalidation because it does not take
into account the first call since construction, only the first call
since various member and non-member function calls.
</p>
<p><b>Proposed resolution:</b></p>
<p>
Change the following sentence in 21.3 paragraph 5 from
</p>

<blockquote>
    Subsequent to any of the above uses except the forms of insert() and
    erase() which return iterators, the first call to non-const member
    functions operator[](), at(), begin(), rbegin(), end(), or rend().
</blockquote>

<p>to</p>

<blockquote>
    Following construction or any of the above uses, except the forms of
    insert() and erase() that return iterators, the first call to non-
    const member functions operator[](), at(), begin(), rbegin(), end(),
    or rend().
</blockquote>
<hr>
<a name="265"><h3>265.&nbsp;std::pair::pair() effects overly restrictive</h3></a><p>
<b>Section:</b>&nbsp;20.2.2 <a href="lib-utilities.html#lib.pairs"> [lib.pairs]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Martin Sebor&nbsp; <b>Date:</b>&nbsp;11 Sep 2000</p>
<p>
I don't see any requirements on the types of the elements of the
std::pair container in 20.2.2. From the descriptions of the member
functions it appears that they must at least satisfy the requirements of
20.1.3 [lib.copyconstructible] and 20.1.4 [lib.default.con.req], and in
the case of the [in]equality operators also the requirements of 20.1.1
[lib.equalitycomparable] and 20.1.2 [lib.lessthancomparable].
</p>

<p>
I believe that the the CopyConstructible requirement is unnecessary in
the case of 20.2.2, p2.
</p>
<p><b>Proposed resolution:</b></p>
<p>Change the Effects clause in 20.2.2, p2 from</p>

<blockquote>
-2- <b>Effects</b>: Initializes its members as if implemented: <tt> pair() :
first(T1()), second(T2()) {} </tt>
</blockquote>

<p>to</p>

<blockquote>
-2- <b>Effects</b>: Initializes its members as if implemented: <tt> pair() :
first(), second() {} </tt>
</blockquote>
<p><b>Rationale:</b></p>
<p>The existing specification of pair's constructor appears to be a
historical artifact: there was concern that pair's members be properly
zero-initialized when they are built-in types.  At one time there was
uncertainty about whether they would be zero-initialized if the
default constructor was written the obvious way.  This has been
clarified by core issue 178, and there is no longer any doubt that
the straightforward implementation is correct.</p>
<hr>
<a name="268"><h3>268.&nbsp;Typo in locale synopsis</h3></a><p>
<b>Section:</b>&nbsp;22.1.1 <a href="lib-locales.html#lib.locale"> [lib.locale]</a>&nbsp; <b>Status:</b>&nbsp;<a href="lwg-active.html#DR">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Martin Sebor&nbsp; <b>Date:</b>&nbsp;5 Oct 2000</p>
<p>The synopsis of the class std::locale in 22.1.1 contains two typos:
the semicolons after the declarations of the default ctor
locale::locale() and the copy ctor locale::locale(const locale&amp;)
are missing.</p>
<p><b>Proposed resolution:</b></p>
<p>Add the missing semicolons, i.e., change</p>

<pre>
    //  construct/copy/destroy:
        locale() throw()
        locale(const locale&amp; other) throw()
</pre>

<p>in the synopsis in 22.1.1 to</p>

<pre>
    //  construct/copy/destroy:
        locale() throw();
        locale(const locale&amp; other) throw();
</pre>
<p>----- End of document -----</p>
</body>
</html>
