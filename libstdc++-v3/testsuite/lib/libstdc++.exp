# libstdc++ "tool init file" for DejaGNU

# Copyright (C) 2001-2018 Free Software Foundation, Inc.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; see the file COPYING3.  If not see
# <http://www.gnu.org/licenses/>.


# Define callbacks and load other libraries.  This file is loaded relatively
# early, and before any other file we write ourselves.  "load_lib" will
# find anything in the DejaGNU installation tree, or in our lib directory.
# "load_gcc_lib" will search the core compiler's .exp collection instead.
#
# The naming rule is that dg.exp looks for "tool-" and runtest.exp looks
# for "tool_" when finding callbacks.  Utility routines we define for
# our callbacks begin with "v3-".
#
# libstdc++_* callbacks we don't define, but could:
# ..._option_help           prints additional --help output
# ..._option_proc (--foo)   process our own options
# ..._init (normal.exp)     called once per test file
# ..._finish                bracketing function for libstdc++_init
# ...-dg-prune              removing output text, see top of system dg.exp
#
# Useful hook:  if ${hostname}_init exists, it will be called, almost
# the last thing before testing begins.  This can be defined in, e.g.,
# ~/.dejagnurc or $DEJAGNU.

proc load_gcc_lib { filename } {
    global srcdir loaded_libs

    load_file $srcdir/../../gcc/testsuite/lib/$filename
    set loaded_libs($filename) ""
}

# system routines
load_lib dg.exp
load_lib libgloss.exp
# compiler routines, then ours
load_gcc_lib target-supports.exp
load_gcc_lib target-supports-dg.exp
load_lib prune.exp
load_lib dg-options.exp
load_gcc_lib scanasm.exp
load_gcc_lib target-libpath.exp
load_gcc_lib timeout.exp
load_gcc_lib timeout-dg.exp
load_gcc_lib wrapper.exp
load_gcc_lib target-utils.exp

# Useful for debugging.  Pass the name of a variable and the verbosity
# threshold (number of -v's on the command line).
proc v3track { var n } {
    upvar $var val
    verbose "++ $var is $val" $n
}

# Copy file to the target.
proc v3-copy-file {src dst} {
    if { [catch { set symlink [file readlink $src] } x] } then {
	remote_download target $src $dst
    } else {
	if { [regexp "^/" "$symlink"] } then {
	    remote_download target $symlink $dst
	} else {
	    set dirname [file dirname $f]
	    remote_download target $dirname/$symlink $dst
	}
    }
}

# Called by v3-init below.  "Static" to this file.
proc v3-copy-files {srcfiles} {
    foreach f $srcfiles {
	v3-copy-file $f [file tail $f]
    }
}

# Called once, during runtest.exp setup.
proc libstdc++_init { testfile } {
    global env
    global v3-sharedlib v3-libgomp
    global srcdir blddir objdir tool_root_dir
    global cc cxx cxxflags cxxpchflags cxxldflags cxxvtvflags
    global includes
    global gluefile wrap_flags
    global ld_library_path
    global target_triplet
    global flags_file
    global tool_timeout
    global DEFAULT_CXXFLAGS
    global STATIC_LIBCXXFLAGS

    # We set LC_ALL and LANG to C so that we get the same error
    # messages as expected.
    setenv LC_ALL C
    setenv LANG C

    # LANGUAGE changes the behavior of GNU gettext(3) and causes
    # std::messages tests to fail.
    array unset env LANGUAGE

    # Many hosts now default to a non-ASCII C locale, however, so
    # they can set a charset encoding here if they need.
    if { [ishost "*-*-cygwin*"] } {
      setenv LC_ALL C.ASCII
      setenv LANG C.ASCII
    }

    set blddir [lookfor_file [get_multilibs] libstdc++-v3]
    set flags_file "${blddir}/scripts/testsuite_flags"
    set shlib_ext [get_shlib_extension]
    v3track flags_file 2

    # If a test doesn't have special options, use DEFAULT_CXXFLAGS.
    # Use this variable if the behavior
    #   1) only applies to libstdc++ testing
    #   2) might need to be negated
    # In particular, some tests have to be run without precompiled
    # headers, or without assertions.

    if ![info exists DEFAULT_CXXFLAGS] then {
	set DEFAULT_CXXFLAGS ""
	# Host specific goo here.
	if { [string match "powerpc-*-darwin*" $target_triplet] } {
	    append DEFAULT_CXXFLAGS " -multiply_defined suppress"
	}
	if { [string match "powerpc-ibm-aix*" $target_triplet] } {
	    append DEFAULT_CXXFLAGS " -Wl,-bmaxdata:0x20000000"
	}
    }
    v3track DEFAULT_CXXFLAGS 2

    # By default, we assume we want to run program images.
    global dg-do-what-default
    set dg-do-what-default run

    # Copy any required data files.
    v3-copy-files [glob -nocomplain "$srcdir/data/*.tst"]
    v3-copy-files [glob -nocomplain "$srcdir/data/*.txt"]

    set ld_library_path_tmp ""

    # Locate libgcc.a so we don't need to account for different values of
    # SHLIB_EXT on different platforms
    set gccdir [lookfor_file $tool_root_dir gcc/libgcc.a]
    if {$gccdir != ""} {
	set gccdir [file dirname $gccdir]
	append ld_library_path_tmp ":${gccdir}"
    }
    v3track gccdir 3

    # Locate libgomp. This is only required for parallel mode.
    set v3-libgomp 0
    set libgompdir [lookfor_file $blddir/../libgomp .libs/libgomp.$shlib_ext]
    if {$libgompdir != ""} {
	set v3-libgomp 1
	set libgompdir [file dirname $libgompdir]
	append ld_library_path_tmp ":${libgompdir}"
	verbose -log "libgomp support detected"
    }
    v3track libgompdir 3

    # Locate libvtv. This is only required for --enable-vtable-verify.
    set v3-libvtv 0
    set libvtvdir [lookfor_file $blddir/../libvtv .libs/libvtv.$shlib_ext]
    if {$libvtvdir != ""} {
	set v3-libvtv 1
	set libvtvdir [file dirname $libvtvdir]
	append ld_library_path_tmp ":${libvtvdir}"
	verbose -log "libvtv support detected"
    }
    v3track libvtvdir 3

    # Locate libstdc++ shared library. (ie libstdc++.so.)
    set v3-sharedlib 0
    set sharedlibdir [lookfor_file $blddir src/.libs/libstdc++.$shlib_ext]
    if {$sharedlibdir != ""} {
	if { ([string match "*-*-gnu*" $target_triplet]
	      || [string match "*-*-linux*" $target_triplet]
	      || [string match "*-*-solaris*" $target_triplet])
	     && [isnative] } then {
	    set v3-sharedlib 1
	    verbose -log "shared library support detected"
	}
    }
    v3track v3-sharedlib 3

    set STATIC_LIBCXXFLAGS ""
    set staticlibdir [lookfor_file $blddir src/.libs/libstdc++.a]
    if {$staticlibdir != ""} {
	set staticlibdir [file dirname $staticlibdir]
	# Some targets use libstdc++.a%s in their specs, so they need a
	# -B option for uninstalled testing.
	set STATIC_LIBCXXFLAGS " -B${staticlibdir} "
    }

    # Compute what needs to be added to the existing LD_LIBRARY_PATH.
    if {$gccdir != ""} {
	set compiler ${gccdir}/xg++
	set ld_library_path ${ld_library_path_tmp}
	append ld_library_path ":${blddir}/src/.libs"

	if { [is_remote host] == 0 && [which $compiler] != 0 } {
	  foreach i "[exec $compiler --print-multi-lib]" {
	    set mldir ""
	    regexp -- "\[a-z0-9=_/\.-\]*;" $i mldir
	    set mldir [string trimright $mldir "\;@"]
	    if { "$mldir" == "." } {
	      continue
	    }
	    if { [llength [glob -nocomplain ${gccdir}/${mldir}/libgcc_s*.so.*]] >= 1 } {
	      append ld_library_path ":${gccdir}/${mldir}"
	    }
	  }
	}

	set_ld_library_path_env_vars
	if [info exists env(LD_LIBRARY_PATH)] {
	  verbose -log "LD_LIBRARY_PATH = $env(LD_LIBRARY_PATH)"
	}
    } else {
	set compiler [transform "g++"]
    }

    # Set the default timeout for v3 tests.
    set tool_timeout 600

    # Default settings.
    set cxx [transform "g++"]
    set cxxflags "-fmessage-length=0"
    set cxxpchflags ""
    set cxxvtvflags ""
    set cxxldflags ""
    set cc [transform "gcc"]
    # Locate testsuite_hooks.h and other testsuite headers.
    set includes "-I${srcdir}/util"
    # Adapt the defaults for special circumstances.
    if [is_remote host] {
	# A remote host does not, in general, have access to the
	# $srcdir so we copy the testsuite headers into the current
	# directory, and then add that to the search path.
	foreach src [glob "${srcdir}/util/*.h" \
			  "${srcdir}/util/*.cc" \
			  "${srcdir}/util/*.tcc" \
			  "${srcdir}/util/*.hpp" \
			  "${srcdir}/util/*/*.h" \
			  "${srcdir}/util/*/*.cc" \
			  "${srcdir}/util/*/*.tcc" \
			  "${srcdir}/util/*/*.hpp" \
			  "${srcdir}/util/*/*/*.h" \
			  "${srcdir}/util/*/*/*.cc" \
			  "${srcdir}/util/*/*/*.tcc" \
			  "${srcdir}/util/*/*/*.hpp" \
			  "${srcdir}/util/*/*/*/*.h" \
			  "${srcdir}/util/*/*/*/*.cc" \
			  "${srcdir}/util/*/*/*/*.tcc" \
			  "${srcdir}/util/*/*/*/*.hpp" \
			  "${srcdir}/util/*/*/*/*/*.h" \
			  "${srcdir}/util/*/*/*/*/*.cc" \
			  "${srcdir}/util/*/*/*/*/*.tcc" \
			  "${srcdir}/util/*/*/*/*/*.hpp" ] {
	    # Remove everything up to "util/..."
	    set dst [string range $src [string length "${srcdir}/"] end]
	    # Create the directory containing the file.
	    set dir [file dirname $dst]
	    remote_exec host "mkdir" [list "-p" "$dir"]
	    # Download the file.
	    set result [remote_download host $src $dst]
	    if { $result == "" } {
		verbose -log "Unable to download ${srcdir}/${src} to host."
		return "untested"
	    }
	}
	set includes "-Iutil"
    } elseif { [file exists $flags_file] } {
	# If we find a testsuite_flags file, we're testing in the build dir.
	set cxx [exec sh $flags_file --build-cxx]
	set cxxflags [exec sh $flags_file --cxxflags]
	set cxxpchflags [exec sh $flags_file --cxxpchflags]
	set cxxvtvflags [exec sh $flags_file --cxxvtvflags]
	set cxxldflags [exec sh $flags_file --cxxldflags]
	set cc [exec sh $flags_file --build-cc]
	set includes [exec sh $flags_file --build-includes]
    }
    append cxxflags " "
    append cxxflags [getenv CXXFLAGS]

    if ![regexp ".*-O" $cxxflags] {
	append cxxflags " -g -O2"
    }

    v3track cxxflags 2

    # Should be as good as -fdiagnostics-color=never, but more compatible
    setenv GCC_COLORS ""
    # Always use MO files built by this test harness.
    set ccflags "$cxxflags -DLOCALEDIR=\".\""
    set cxxflags "$cxxflags -DLOCALEDIR=\".\""

    # If a PCH file is available, use it.  We must delay performing
    # this check until $cxx and such have been initialized because we
    # perform a test compilation.  (Ideally, gcc --print-file-name would
    # list PCH files, but it does not.)
    if { $cxxpchflags != "" } {
	set src "config[pid].cc"
	set f [open $src "w"]
	puts $f "int main () {}"
	close $f

	# Fixme: "additional_flags=$cxxpchflags" fails, but would be
	# useful as then the requested variant of the pre-build PCH
	# files could be tested to see if it works.
	set lines [v3_target_compile $src "config[pid].o" object \
		   "additional_flags=-include additional_flags=bits/stdc++.h"]
	if { $lines != "" } {
	    verbose -log "Requested PCH file: $cxxpchflags"
	    verbose -log "is not working, and will not be used."
	    set cxxpchflags ""
	}
	file delete $src
     }
    v3track cxxpchflags 2

    global PCH_CXXFLAGS
    if ![info exists PCH_CXXFLAGS] then {
	set PCH_CXXFLAGS $cxxpchflags
	v3track PCH_CXXFLAGS 2
    }

    libstdc++_maybe_build_wrapper "${objdir}/testglue.o" "-fexceptions"
}

# Callback for cleanup routines.
proc libstdc++_exit { } {
    global gluefile;

    if [info exists gluefile] {
	file_on_build delete $gluefile;
	unset gluefile;
    }
}

# Callback from system dg-test.
proc libstdc++-dg-test { prog do_what extra_tool_flags } {
    # Set up the compiler flags, based on what we're going to do.
    switch $do_what {
	"preprocess" {
	    set compile_type "preprocess"
	    set output_file "[file rootname [file tail $prog]].i"
	}
	"compile" {
	    set compile_type "assembly"
	    set output_file "[file rootname [file tail $prog]].s"
	}
	"assemble" {
	    set compile_type "object"
	    set output_file "[file rootname [file tail $prog]].o"
	}
	"link" {
	    set compile_type "executable"
	    set output_file "./[file rootname [file tail $prog]].exe"
	}
	"run" {
	    set compile_type "executable"
	    # FIXME: "./" is to cope with "." not being in $PATH.
	    # Should this be handled elsewhere?
	    # YES.
	    set output_file "./[file rootname [file tail $prog]].exe"
	    # This is the only place where we care if an executable was
	    # created or not.  If it was, dg.exp will try to run it.
	    catch { remote_file build delete $output_file }
	}
	default {
	    perror "$do_what: not a valid dg-do keyword"
	    return ""
	}
    }

    # Short-circut a bunch of complicated goo here for the special
    # case of compiling a test file as a "C" file, not as C++. Why? So
    # -nostdc++ doesn't trip us up. So all the extra object files
    # don't trip us up. So automatically linking in libstdc++ doesn't
    # happen. So CXXFLAGS don't error.
    set select_compile "v3_target_compile"
    set options ""
    if { $extra_tool_flags != "" } {
	verbose -log "extra_tool_flags are:"
	verbose -log $extra_tool_flags
	if { [string first "-x c" $extra_tool_flags ] != -1 } {
	    verbose -log "compiling and executing as C, not C++"
	    set edit_tool_flags $extra_tool_flags
	    regsub -all ".x c" $edit_tool_flags "" edit_tool_flags
	    lappend options "additional_flags=$edit_tool_flags"
	    set select_compile "v3_target_compile_as_c"
	} else {
	    lappend options "additional_flags=$extra_tool_flags"
	}
    }

    # There is a libstdc++_compile made for us by default (via the tool-
    # and-target file), but the defaults are lacking in goodness.
    set comp_output [$select_compile "$prog" "$output_file" "$compile_type" $options];

    set unsupported_message [libstdc++_check_unsupported_p $comp_output]
    if { $unsupported_message != "" } {
	set comp_output "::unsupported::$unsupported_message"
    }

    return [list $comp_output $output_file]
}

# Override the DejaGnu dg-test in order to clear flags after a test, as
# is done for compiler tests in gcc-dg.exp.

if { [info procs saved-dg-test] == [list] } {
    rename dg-test saved-dg-test

    proc dg-test { args } {
	global additional_prunes
	global errorInfo
	global testname_with_flags

	if { [ catch { eval saved-dg-test $args } errmsg ] } {
	    set saved_info $errorInfo
	    set additional_prunes ""
	    if [info exists testname_with_flags] {
		unset testname_with_flags
	    }
	    unset_timeout_vars
	    error $errmsg $saved_info
	}
	set additional_prunes ""
	unset_timeout_vars
	if [info exists testname_with_flags] {
	    unset testname_with_flags
	}
    }
}

# True if the library supports wchar_t.
set v3-wchar_t 0

# True if the library supports threads.
set v3-threads 0

# True if the library supports symbol versioning.
set v3-symver 0

# Called from libstdc++-dg-test above.  Calls back into system's
# target_compile to actually do the work.
proc v3_target_compile { source dest type options } {
    global gluefile
    global wrap_flags
    global cxx
    global cxxflags
    global cxxvtvflags
    global cxxldflags
    global includes
    global STATIC_LIBCXXFLAGS
    global tool

    lappend options "additional_flags=-fno-diagnostics-show-caret -fdiagnostics-color=never"

    if { [target_info needs_status_wrapper] != "" && [info exists gluefile] } {
	lappend options "libs=${gluefile}"
	lappend options "ldflags=${wrap_flags}"
    }

    set cxx_final $cxx
    set cxxlibglossflags  [libgloss_link_flags]
    set cxx_final [concat $cxx_final $cxxlibglossflags]
    set cxx_final [concat $cxx_final $STATIC_LIBCXXFLAGS]
    set cxx_final [concat $cxx_final $cxxflags]
    set cxx_final [concat $cxx_final $cxxvtvflags]
    set cxx_final [concat $cxx_final $includes]

    # Flag setting based on type argument.
    if { $type == "executable" } {
	# Link the support objects into executables.
	lappend options "additional_flags=./libtestc++.a $cxxldflags"
    } else {
	if { $type == "sharedlib" } {
	    # Don't link in anything.
	    set type "executable"
	}
    }

    lappend options "compiler=$cxx_final"
    lappend options "timeout=[timeout_value]"

    set comp_output [target_compile $source $dest $type $options]

    return $comp_output
}


# Called from libstdc++-dg-test above, but only for "C" compilation.
# Calls back into system's target_compile to actually do the work.
proc v3_target_compile_as_c { source dest type options } {
    global gluefile
    global wrap_flags
    global includes
    global flags_file
    global blddir
    global cc
    global cxxflags
    global STATIC_LIBCXXFLAGS
    global tool

    if { [target_info needs_status_wrapper] != "" && [info exists gluefile] } {
	lappend options "libs=${gluefile}"
	lappend options "ldflags=${wrap_flags}"
    }

    set tname [target_info name]
    set cc_final $cc
    set cxxlibglossflags [libgloss_link_flags]
    set cc_final [concat $cc_final $cxxlibglossflags]
    set cc_final [concat $cc_final $STATIC_LIBCXXFLAGS]
    set cc_final [concat $cc_final $cxxflags]
    set cc_final [concat $cc_final $includes]
    regsub -all {\s[-]nostdinc[+][+]} $cc_final "" cc_final

    # This is needed for "C" tests, as this type of test may need the
    # C++ includes. And if we're not testing in the build directory,
    # the includes variable is not likely to include the necessary
    # info.
    if { ![file exists $flags_file] } {
	# ??? We need a --print-include-dirs option to GCC, so that
	# we can avoid these hacks.  The heuristics here will not
	# work with non-standard --with-includedir= options.
	set version [remote_exec host ${cc} -dumpversion]
	# Remove the trailing newline from the output.
	set version [string trimright [lindex $version 1]]
	set machine [remote_exec host ${cc} -dumpmachine]
	set machine [string trimright [lindex $machine 1]]
	set comp_base_dir [remote_exec host ${cc} --print-prog-name=cc1]
	set comp_base_dir [lindex $comp_base_dir 1]
	set comp_base_dir [file dirname [file dirname [file dirname [file dirname [file dirname $comp_base_dir]]]]]
	# For a cross compiler, the header files will be located in a
	# machine-specific subdirectory.
	set crossbase "${comp_base_dir}/${machine}/include/c++/${version}"
	set crosstarget "${crossbase}/${machine}"
	set cc_final [concat $cc_final "-I$crossbase -I$crosstarget"]
	# For a native compiler, the header files will be located at
	# the top level.
	set includesbase "${comp_base_dir}/include/c++/${version}"
	set includestarget "${includesbase}/${machine}"
	set cc_final [concat $cc_final "-I$includesbase -I$includestarget"]

	set libdir "-L${comp_base_dir}/lib"
    } else {
	set libdir "-L${blddir}/libsupc++/.libs"
	set libdir [concat $libdir "-L${blddir}/src/.libs"]
    }

    set cc_final [concat $cc_final "$libdir"]

    lappend options "compiler=$cc_final"
    lappend options "timeout=[timeout_value]"

    set comp_output [target_compile $source $dest $type $options]

    return $comp_output
}

# Build the support objects linked in with the libstdc++ tests.  In
# addition, set v3-wchar_t, v3-threads, and v3-symver appropriately.
proc v3-build_support { } {
    global env
    global srcdir
    global v3-wchar_t
    global v3-threads
    global v3-symver
    global v3-sharedlib

    # Figure out whether or not the library supports certain features.
    set v3-wchar_t 0
    set v3-threads 0
    set v3-symver 0
    set libtest_objs ""

    set config_src "config.cc"
    set config_out "config.ii"
    set f [open $config_src "w"]
    puts $f "#include <bits/c++config.h>"
    puts $f "#include <bits/gthr.h>"
    close $f
    v3_target_compile $config_src $config_out preprocess "additional_flags=-dN"
    set file [open $config_out r]
    set preprocessed [read $file]
    close $file
    if { [string first "_GLIBCXX_USE_WCHAR_T" $preprocessed] != -1 } {
	verbose -log "wchar_t support detected"
	set v3-wchar_t 1
    }
    if { [string first "_GLIBCXX_SYMVER" $preprocessed] != -1 } {
	verbose -log "symbol versioning support detected"
	set v3-symver 1
    }
    if { [string first "__GTHREADS" $preprocessed] != -1 } {
	verbose -log "thread support detected"
	set v3-threads 1
    }

    # Try to build the MO files that are used by some of the locale
    # tests.  If we can't build them, that's OK; it just means that
    # those tests will fail.
    foreach lang [list "fr" "de"] {
	catch {
	    file mkdir "$lang/LC_MESSAGES"
	    remote_exec "build" "msgfmt" "-o $lang/LC_MESSAGES/libstdc++.mo $srcdir/../po/$lang.po"
	    if [is_remote host] {
		remote_exec "host" "mkdir" "-p $lang/LC_MESSAGES"
		remote_download "host" "$lang/LC_MESSAGES/libstdc++.mo" "$lang/LC_MESSAGES/libstdc++.mo"
	    }
	}
    }

    # Build the support objects.
    set source_files [list testsuite_abi.cc testsuite_allocator.cc \
			  testsuite_character.cc testsuite_hooks.cc \
			  io/verified_cmd_line_input.cc \
			  io/prog_bar.cc performance/time/elapsed_timer.cc ]
    foreach f $source_files {
	set obj [file rootname $f].o
	set object_file [file tail $obj]
	# Compile with "-w" so that warnings issued by the compiler
	# do not prevent compilation.
	# Disable LTO so that ar/ranlib don't need the LTO plugin.
	if { [v3_target_compile $srcdir/util/$f $object_file "object" \
		  [list "incdir=$srcdir" "additional_flags=-w -fno-lto"]]
	     != "" } {
	    error "could not compile $f"
	}
	append libtest_objs "$object_file "
    }

    # Collect into libtestc++.a
    if  [info exists env(AR)] {
	set ar $env(AR)
    } else {
	set ar [transform "ar"]
    }
    set arargs "-rc ./libtestc++.a ${libtest_objs}"
    verbose -log "$ar $arargs"
    set result [lindex [remote_exec host "$ar" "$arargs"] 0]
    verbose "link result is $result"
    if { $result == 0 } {
	if  [info exists env(RANLIB)] {
	    set ranlib $env(RANLIB)
	} else {
	    set ranlib [transform "ranlib"]
	}
	set ranlibargs "./libtestc++.a"
	verbose -log "$ranlib $ranlibargs"
	set result [lindex [remote_exec host "$ranlib" "$ranlibargs"] 0]
	if { $result != 0 } {
	    error "could not link libtestc++.a"
	}
    }

    # Build any shared objects needed for regression testing.
    if { ${v3-sharedlib} == 1 } {
	set source_files [list testsuite_shared.cc]
	foreach f $source_files {
	    set object_file [file rootname $f].so
	    # Compile with "-w" so that warnings issued by the compiler
	    # do not prevent compilation.
	    if { [v3_target_compile $srcdir/util/$f $object_file "sharedlib" \
	     [list "incdir=$srcdir" "additional_flags=-fno-inline -w -shared -fPIC -DPIC -std=gnu++98"]]
		 != "" } {
		error "could not compile $f"
	    }
	}
    }
}

proc check_v3_target_fileio { } {
    global et_fileio_saved
    global et_fileio_target_name
    global tool
    global srcdir

    if { ![info exists et_fileio_target_name] } {
	set et_fileio_target_name ""
    }

    # If the target has changed since we set the cached value, clear it.
    set current_target [current_target_name]
    if { $current_target != $et_fileio_target_name } {
	verbose "check_v3_target_fileio: `$et_fileio_target_name'" 2
	set et_fileio_target_name $current_target
	if [info exists et_fileio_saved] {
	    verbose "check_v3_target_fileio: removing cached result" 2
	    unset et_fileio_saved
	}
    }

    if [info exists et_fileio_saved] {
	verbose "check_v3_target_fileio: using cached result" 2
    } else {
	set et_fileio_saved 0

	# Set up, compile, and execute a C++ test program that tries to use
	# the file functions
	set src fileio[pid].cc
	set exe fileio[pid].x
	set testfile "cin_unget-1.[pid].txt"
	v3-copy-file "$srcdir/data/cin_unget-1.txt" "$testfile"

	set f [open $src "w"]
	puts $f "#include <sys/types.h>"
	puts $f "#include <sys/stat.h>"
	puts $f "#include <fcntl.h>"
	puts $f "#include <unistd.h>"
	puts $f "#include <errno.h>"
	puts $f "#include <string.h>"
	puts $f "using namespace std;"
	puts $f "int main ()"
	puts $f "{"
	puts $f "  int fd  = open (\"$testfile\", O_RDONLY);"
	puts $f "  int ret = 0;"
	puts $f "  char buf\[10\];"
	puts $f "  if (fd == -1)"
	puts $f "    ret = 1;"
	puts $f "  else"
	puts $f "  {"
	puts $f "    if (lseek (fd, -1, SEEK_CUR) != -1 || errno != EINVAL)"
	puts $f "      ret = 1;"
	puts $f "    errno = 0;"
	puts $f "    if (lseek (fd, 0, SEEK_CUR) != 0"
	puts $f "        || read (fd, buf, 4) != 4"
	puts $f "        || memcmp (buf, \"1234\", 4) != 0"
	puts $f "        || lseek (fd, -2, SEEK_CUR) != 2"
	puts $f "        || read (fd, buf, 2) != 2"
	puts $f "        || memcmp (buf, \"34\", 2) != 0)"
	puts $f "      ret = 1;"
	puts $f "    close (fd);"
	puts $f "  }"
	puts $f "  return ret;"
	puts $f "}"
	close $f

	set lines [v3_target_compile $src $exe executable ""]
	file delete $src

	if [string match "" $lines] {
	    # No error message, compilation succeeded.
	    set result [${tool}_load "./$exe" "" ""]
	    set status [lindex $result 0]
	    remote_file build delete $exe

	    verbose "check_v3_target_fileio: status is <$status>" 2

	    if { $status == "pass" } {
		set et_fileio_saved 1
	    }
	} else {
	    verbose "check_v3_target_fileio: compilation failed" 2
	}
    }
    return $et_fileio_saved
}

# Eventually we want C90/C99 determining and switching from this.
proc check_v3_target_c_std { } {
    global et_c_std_saved
    global et_c_std_target_name
    global tool

    if { ![info exists et_c_std_target_name] } {
	set et_c_std_target_name ""
    }

    # If the target has changed since we set the cached value, clear it.
    set current_target [current_target_name]
    if { $current_target != $et_c_std_target_name } {
	verbose "check_v3_target_c_std: `$et_c_std_target_name'" 2
	set et_c_std_target_name $current_target
	if [info exists et_c_std_saved] {
	    verbose "check_v3_target_c_std: removing cached result" 2
	    unset et_c_std_saved
	}
    }

    if [info exists et_c_std_saved] {
	verbose "check_v3_target_c_std: using cached result" 2
    } else {
	set et_c_std_saved 0

	# Set up, compile, and execute a C++ test program that tries to use
	# C99 functionality.
	# For math bits, could use check_effective_target_c99_math.
	set src fileio[pid].cc
	set exe fileio[pid].x

	set f [open $src "w"]
	puts $f "#include <tr1/cmath>"
	puts $f "#include <cstdlib>"
	puts $f "int main ()"
	puts $f "{"
	puts $f "  float f = 45.55;"
	puts $f "  int i = std::tr1::isnan(f);"
	puts $f "  "
	puts $f "  using std::wctomb;"
	puts $f "  return i;"
	puts $f "}"
	close $f

	set lines [v3_target_compile $src $exe executable ""]
	file delete $src

	if [string match "" $lines] {
	    # No error message, compilation succeeded.
	    set result [${tool}_load "./$exe" "" ""]
	    set status [lindex $result 0]
	    remote_file build delete $exe

	    verbose "check_v3_target_c_std: status is <$status>" 2

	    if { $status == "pass" } {
		set et_c_std_saved 1
	    }
	} else {
	    verbose "check_v3_target_c_std: compilation failed" 2
	}
    }
    return $et_c_std_saved
}

proc check_v3_target_sharedlib { } {
    global v3-sharedlib
    return ${v3-sharedlib}
}

proc check_v3_target_time { } {
    global et_time_saved
    global et_time_target_name
    global tool

    if { ![info exists et_time_target_name] } {
	set et_time_target_name ""
    }

    # If the target has changed since we set the cached value, clear it.
    set current_target [current_target_name]
    if { $current_target != $et_time_target_name } {
	verbose "check_v3_target_time: `$et_time_target_name'" 2
	set et_time_target_name $current_target
	if [info exists et_time_saved] {
	    verbose "check_v3_target_time: removing cached result" 2
	    unset et_time_saved
	}
    }

    if [info exists et_time_saved] {
	verbose "check_v3_target_time: using cached result" 2
    } else {
	set et_time_saved 0

	# Set up and compile a C++ test program that tries to use
	# the time function
	set src time[pid].cc

	set f [open $src "w"]
	puts $f "#include <time.h>"
	puts $f "using namespace std;"
	puts $f "int main ()"
	puts $f "{"
	puts $f "  time (0);"
	puts $f "}"
	close $f

	set lines [v3_target_compile $src /dev/null executable ""]
	file delete $src

	if [string match "" $lines] {
	    # No error message, compilation succeeded.
	    verbose "check_v3_target_time: compilation succeeded" 2
	    set et_time_saved 1
	} else {
	    verbose "check_v3_target_time: compilation failed" 2
	}
    }
    return $et_time_saved
}

proc check_v3_target_namedlocale { args } {
    global et_namedlocale
    global tool

    set et_namedlocale 0

    # Set up, compile, and execute a C++ test program that tries to use
    # the required named locale.
    set exe nlocale[pid].x

    if ![file exists ./$exe] {
      set src nlocale[pid].cc

      set f [open $src "w"]
      puts $f "#include <locale>"
      puts $f "#include <cstdio>"
      puts $f "#include <cstring>"
      puts $f "using namespace std;"
      puts $f "char *transform_locale(const char *name)"
      puts $f "{"
      puts $f "    char *result = new char\[50\];"
      puts $f "    strcpy(result, name);"
      puts $f "#if defined __FreeBSD__ || defined __DragonFly__ || defined __NetBSD__"
      puts $f "    /* fall-through */"
      puts $f "#else"
      puts $f "    if (strstr(result, \"ISO8859-15\")) {"
      puts $f "        strcat(result, \"@euro\");"
      puts $f "    }"
      puts $f "#endif"
      puts $f "    return result;"
      puts $f "}"
      puts $f "int main (int argc, char** argv)"
      puts $f "{"
      puts $f "  if (argc < 2)"
      puts $f "  {"
      puts $f "    printf(\"locale support test not supported\\n\");"
      puts $f "    return 1;"
      puts $f "  }"
      puts $f "  const char *namedloc = transform_locale(*(argv + 1));"
      puts $f "  try"
      puts $f "  {"
      puts $f "    locale((const char*)namedloc);"
      puts $f "    delete\[\] namedloc;"
      puts $f "    return 0;"
      puts $f "  }"
      puts $f "  catch(...)"
      puts $f "  {"
      puts $f "    printf(\"locale '%s' not supported\\n\", namedloc);"
      puts $f "    delete\[\] namedloc;"
      puts $f "    return 1;"
      puts $f "  }"
      puts $f "}"
      close $f

      set lines [v3_target_compile $src $exe executable ""]
      file delete $src

      if ![string match "" $lines] {
	verbose "check_v3_target_namedlocale: compilation failed" 2
	return $et_namedlocale
      }
      # else No error message, compilation succeeded.
    }

    set result [${tool}_load "./$exe" "$args" ""]
    set status [lindex $result 0]

    verbose "check_v3_target_namedlocale <$args>: status is <$status>" 2

    if { $status == "pass" } {
      set et_namedlocale 1
    }
    return $et_namedlocale
}

proc check_v3_target_debug_mode { } {
    global et_debug_mode
    global tool

    if { ![info exists et_debug_mode_target_name] } {
	set et_debug_mode_target_name ""
    }

    # If the target has changed since we set the cached value, clear it.
    set current_target [current_target_name]
    if { $current_target != $et_debug_mode_target_name } {
	verbose "check_v3_target_debug_mode: `$et_debug_mode_target_name'" 2
	set et_debug_mode_target_name $current_target
	if [info exists et_debug_mode] {
	    verbose "check_v3_target_debug_mode: removing cached result" 2
	    unset et_debug_mode
	}
    }

    if [info exists et_debug_mode] {
	verbose "check_v3_target_debug_mode: using cached result" 2
    } else {
	set et_debug_mode 0

	# Set up and preprocess a C++ test program that depends
	# on debug mode activated.
	set src debug_mode[pid].cc

	set f [open $src "w"]
	puts $f "#ifndef _GLIBCXX_DEBUG"
	puts $f "#  error No debug mode"
	puts $f "#endif"
	close $f

	set lines [v3_target_compile $src /dev/null preprocess ""]
	file delete $src

	if [string match "" $lines] {
	    # No error message, preprocessing succeeded.
	    set et_debug_mode 1
	}
    }
    verbose "check_v3_target_debug_mode: $et_debug_mode" 2
    return $et_debug_mode
}

proc check_v3_target_profile_mode { } {
    global et_profile_mode
    global tool	

    if { ![info exists et_profile_mode_target_name] } {
	set et_profile_mode_target_name ""
    }

    # If the target has changed since we set the cached value, clear it.
    set current_target [current_target_name]
    if { $current_target != $et_profile_mode_target_name } {
	verbose "check_v3_target_profile_mode: `$et_profile_mode_target_name'" 2
	set et_profile_mode_target_name $current_target
	if [info exists et_profile_mode] {
	    verbose "check_v3_target_profile_mode: removing cached result" 2
	    unset et_profile_mode
	}
    }

    if [info exists et_profile_mode] {
	verbose "check_v3_target_profile_mode: using cached result" 2
    } else {
	set et_profile_mode 0

	# Set up and preprocess a C++ test program that depends
	# on profile mode activated.
	set src profile_mode[pid].cc

	set f [open $src "w"]
	puts $f "#ifndef _GLIBCXX_PROFILE"
	puts $f "#  error No profile mode"
	puts $f "#endif"
	close $f

	set lines [v3_target_compile $src /dev/null preprocess ""]
	file delete $src

	if [string match "" $lines] {
	    # No error message, preprocessing succeeded.
	    set et_profile_mode 1
	}
    }
    verbose "check_v3_target_profile_mode: $et_profile_mode" 2
    return $et_profile_mode
}

proc check_v3_target_normal_mode { } {
    global et_normal_mode
    global tool

    if { ![info exists et_normal_mode_target_name] } {
	set et_normal_mode_target_name ""
    }

    # If the target has changed since we set the cached value, clear it.
    set current_target [current_target_name]
    if { $current_target != $et_normal_mode_target_name } {
	verbose "check_v3_target_normal_mode: `$et_normal_mode_target_name'" 2
	set et_normal_mode_target_name $current_target
	if [info exists et_normal_mode] {
	    verbose "check_v3_target_normal_mode: removing cached result" 2
	    unset et_normal_mode
	}
    }

    if [info exists et_normal_mode] {
	verbose "check_v3_target_normal_mode: using cached result" 2
    } else {
	set et_normal_mode 0

	# Set up and compile a C++ test program that depends
	# on normal mode activated.
	set src normal_mode[pid].cc

	set f [open $src "w"]
	puts $f "#include <bits/c++config.h>"
	puts $f "#if defined(_GLIBCXX_DEBUG) || \\"
	puts $f "    defined(_GLIBCXX_PROFILE) || \\"
	puts $f "    defined(_GLIBCXX_PARALLEL)"
	puts $f "#  error No normal mode"
	puts $f "#endif"
	close $f

	set lines [v3_target_compile $src /dev/null preprocess ""]
	file delete $src

	if [string match "" $lines] {
	    # No error message, compilation succeeded.
	    set et_normal_mode 1
	}
    }
    verbose "check_v3_target_normal_mode: $et_normal_mode" 2
    return $et_normal_mode
}

proc check_v3_target_normal_namespace { } {
    global et_normal_namespace
    global tool

    if { ![info exists et_normal_namespace_target_name] } {
	set et_normal_namespace_target_name ""
    }

    # If the target has changed since we set the cached value, clear it.
    set current_target [current_target_name]
    if { $current_target != $et_normal_namespace_target_name } {
	verbose "check_v3_target_normal_namespace: `$et_normal_namespace_target_name'" 2
	set et_normal_namespace_target_name $current_target
	if [info exists et_normal_namespace] {
	    verbose "check_v3_target_normal_namespace: removing cached result" 2
	    unset et_normal_namespace
	}
    }

    if [info exists et_normal_namespace] {
	verbose "check_v3_target_normal_namespace: using cached result" 2
    } else {
	set et_normal_namespace 0

	# Set up and compile a C++ test program that depends
	# on normal std namespace.
	set src normal_namespace[pid].cc

	set f [open $src "w"]
	puts $f "#include <bits/c++config.h>"
	puts $f "#if _GLIBCXX_INLINE_VERSION"
	puts $f "#  error No normal namespace"
	puts $f "#endif"
	close $f

	set lines [v3_target_compile $src /dev/null preprocess ""]
	file delete $src

	if [string match "" $lines] {
	    # No error message, compilation succeeded.
	    set et_normal_namespace 1
	}
    }
    verbose "check_v3_target_normal_namespace: $et_normal_namespace" 2
    return $et_normal_namespace
}

proc check_v3_target_parallel_mode { } {
    global cxxflags
    global v3-libgomp
    global et_parallel_mode

    global tool

    if { ![info exists et_parallel_mode_target_name] } {
	set et_parallel_mode_target_name ""
    }

    # If the target has changed since we set the cached value, clear it.
    set current_target [current_target_name]
    if { $current_target != $et_parallel_mode_target_name } {
	verbose "check_v3_target_parallel_mode: `$et_parallel_mode_target_name'" 2
	set et_parallel_mode_target_name $current_target
	if [info exists et_parallel_mode] {
	    verbose "check_v3_target_parallel_mode: removing cached result" 2
	    unset et_parallel_mode
	}
    }

    if [info exists et_parallel_mode] {
	verbose "check_v3_target_parallel_mode: using cached result" 2
    } else {
	set et_parallel_mode 0

	# If 'make check-parallel' is running the test succeeds.
	if { ${v3-libgomp} == 1 && [regexp "libgomp" $cxxflags] } {
	    set et_parallel_mode 1
	}
    }
    verbose "check_v3_target_parallel_mode: $et_parallel_mode" 2
    return $et_parallel_mode
}

proc check_v3_target_cstdint { } {
    global cxxflags
    global DEFAULT_CXXFLAGS
    global et_cstdint

    global tool

    if { ![info exists et_cstdint_target_name] } {
	set et_cstdint_target_name ""
    }

    # If the target has changed since we set the cached value, clear it.
    set current_target [current_target_name]
    if { $current_target != $et_cstdint_target_name } {
	verbose "check_v3_target_cstdint: `$et_cstdint_target_name'" 2
	set et_cstdint_target_name $current_target
	if [info exists et_cstdint] {
	    verbose "check_v3_target_cstdint: removing cached result" 2
	    unset et_cstdint
	}
    }

    if [info exists et_cstdint] {
	verbose "check_v3_target_cstdint: using cached result" 2
    } else {
	set et_cstdint 0

	# Set up and preprocess a C++0x test program that depends
	# on the C99 stdint facilities to be available.
	set src cstdint[pid].cc

	set f [open $src "w"]
	puts $f "#include <tr1/cstdint>"
	puts $f "#ifndef _GLIBCXX_USE_C99_STDINT_TR1"
	puts $f "#  error No C99 stdint"
	puts $f "#endif"
	close $f

	set cxxflags_saved $cxxflags
	set cxxflags "$cxxflags $DEFAULT_CXXFLAGS -Werror"

	set lines [v3_target_compile $src /dev/null preprocess ""]
	set cxxflags $cxxflags_saved
	file delete $src

	if [string match "" $lines] {
	    # No error message, preprocess succeeded.
	    set et_cstdint 1
	} else {
	    verbose "check_v3_target_cstdint: compilation failed" 2
	}
    }
    verbose "check_v3_target_cstdint: $et_cstdint" 2
    return $et_cstdint
}

proc check_v3_target_cmath { } {
    global cxxflags
    global DEFAULT_CXXFLAGS
    global et_c99_math

    global tool

    if { ![info exists et_c99_math_target_name] } {
	set et_c99_math_target_name ""
    }

    # If the target has changed since we set the cached value, clear it.
    set current_target [current_target_name]
    if { $current_target != $et_c99_math_target_name } {
	verbose "check_v3_target_c99_math: `$et_c99_math_target_name'" 2
	set et_c99_math_target_name $current_target
	if [info exists et_c99_math] {
	    verbose "check_v3_target_c99_math: removing cached result" 2
	    unset et_c99_math
	}
    }

    if [info exists et_c99_math] {
	verbose "check_v3_target_c99_math: using cached result" 2
    } else {
	set et_c99_math 0

	# Set up and preprocess a C++0x test program that depends
	# on the C99 math facilities to be available.
	set src c99_math[pid].cc

	set f [open $src "w"]
	puts $f "#include <tr1/cmath>"
	puts $f "#ifndef _GLIBCXX_USE_C99_MATH_TR1"
	puts $f "#  error No C99 math"
	puts $f "#endif"
	close $f

	set cxxflags_saved $cxxflags
	set cxxflags "$cxxflags $DEFAULT_CXXFLAGS -Werror"

	set lines [v3_target_compile $src /dev/null preprocess ""]
	set cxxflags $cxxflags_saved
	file delete $src

	if [string match "" $lines] {
	    # No error message, preprocess succeeded.
	    set et_c99_math 1
	} else {
	    verbose "check_v3_target_c99_math: compilation failed" 2
	}
    }
    verbose "check_v3_target_c99_math: $et_c99_math" 2
    return $et_c99_math
}

proc check_v3_target_thread_fence { } {
    global cxxflags
    global DEFAULT_CXXFLAGS
    global et_thread_fence

    global tool

    if { ![info exists et_thread_fence_target_name] } {
	set et_thread_fence_target_name ""
    }

    # If the target has changed since we set the cached value, clear it.
    set current_target [current_target_name]
    if { $current_target != $et_thread_fence_target_name } {
	verbose "check_v3_target_thread_fence: `$et_thread_fence_target_name'" 2
	set et_thread_fence_target_name $current_target
	if [info exists et_thread_fence] {
	    verbose "check_v3_target_thread_fence: removing cached result" 2
	    unset et_thread_fence
	}
    }

    if [info exists et_thread_fence] {
	verbose "check_v3_target_thread_fence: using cached result" 2
    } else {
	set et_thread_fence 0

	# Set up and preprocess a C++11 test program that depends
	# on the thread fence to be available.
	set src thread_fence[pid].cc

	set f [open $src "w"]
	puts $f "int main() {"
	puts $f "__atomic_thread_fence (__ATOMIC_SEQ_CST);"
	puts $f "return 0;"
	puts $f "}"
	close $f

	set cxxflags_saved $cxxflags
	set cxxflags "$cxxflags $DEFAULT_CXXFLAGS -Werror -std=gnu++11"

	set lines [v3_target_compile $src /dev/null executable ""]
	set cxxflags $cxxflags_saved
	file delete $src

	if [string match "" $lines] {
	    # No error message, linking succeeded.
	    set et_thread_fence 1
	} else {
	    verbose "check_v3_target_thread_fence: compilation failed" 2
	}
    }
    verbose "check_v3_target_thread_fence: $et_thread_fence" 2
    return $et_thread_fence
}

proc check_v3_target_atomic_builtins { } {
    global cxxflags
    global DEFAULT_CXXFLAGS
    global et_atomic_builtins

    global tool

    if { ![info exists et_atomic_builtins_target_name] } {
	set et_atomic_builtins_target_name ""
    }

    # If the target has changed since we set the cached value, clear it.
    set current_target [current_target_name]
    if { $current_target != $et_atomic_builtins_target_name } {
	verbose "check_v3_target_atomic_builtins: `$et_atomic_builtins_target_name'" 2
	set et_atomic_builtins_target_name $current_target
	if [info exists et_atomic_builtins] {
	    verbose "check_v3_target_atomic_builtins: removing cached result" 2
	    unset et_atomic_builtins
	}
    }

    if [info exists et_atomic_builtins] {
	verbose "check_v3_target_atomic_builtins: using cached result" 2
    } else {
	set et_atomic_builtins 0

	# Set up and preprocess a C++11 test program that depends
	# on the atomic builtin facilities to be available.
	set src atomic_builtins[pid].cc

	set f [open $src "w"]
	puts $f "#if __GCC_ATOMIC_BOOL_LOCK_FREE < 2"
	puts $f "#  error No atomic bool"
	puts $f "#endif"
	puts $f "#if __GCC_ATOMIC_INT_LOCK_FREE < 2"
	puts $f "#  error No atomic int"
	puts $f "#endif"
	close $f

	set cxxflags_saved $cxxflags
	set cxxflags "$cxxflags $DEFAULT_CXXFLAGS -Werror -std=gnu++11"

	set lines [v3_target_compile $src /dev/null preprocess ""]
	set cxxflags $cxxflags_saved
	file delete $src

	if [string match "" $lines] {
	    # No error message, preprocess succeeded.
	    set et_atomic_builtins 1
	} else {
	    verbose "check_v3_target_atomic_builtins: compilation failed" 2
	}
    }
    verbose "check_v3_target_atomic_builtins: $et_atomic_builtins" 2
    return $et_atomic_builtins
}

proc check_v3_target_gthreads { } {
    global cxxflags
    global DEFAULT_CXXFLAGS
    global et_gthreads

    global tool

    if { ![info exists et_gthreads_target_name] } {
	set et_gthreads_target_name ""
    }

    # If the target has changed since we set the cached value, clear it.
    set current_target [current_target_name]
    if { $current_target != $et_gthreads_target_name } {
	verbose "check_v3_target_gthreads: `$et_gthreads_target_name'" 2
	set et_gthreads_target_name $current_target
	if [info exists et_gthreads] {
	    verbose "check_v3_target_gthreads: removing cached result" 2
	    unset et_gthreads
	}
    }

    if [info exists et_gthreads] {
	verbose "check_v3_target_gthreads: using cached result" 2
    } else {
	set et_gthreads 0

	# Set up and preprocess a C++0x test program that depends
	# on the gthreads facilities to be available.
	set src gthreads[pid].cc

	set f [open $src "w"]
	puts $f "#include <bits/c++config.h>"
	puts $f "#ifndef _GLIBCXX_HAS_GTHREADS"
	puts $f "#  error No gthread"
	puts $f "#endif"
	close $f

	set cxxflags_saved $cxxflags
	set cxxflags "$cxxflags $DEFAULT_CXXFLAGS -Werror"

	set lines [v3_target_compile $src /dev/null preprocess ""]
	set cxxflags $cxxflags_saved
	file delete $src

	if [string match "" $lines] {
	    # No error message, preprocessing succeeded.
	    set et_gthreads 1
	} else {
	    verbose "check_v3_target_gthreads: compilation failed" 2
	}
    }
    verbose "check_v3_target_gthreads: $et_gthreads" 2
    return $et_gthreads
}

proc check_v3_target_gthreads_timed { } {
    global cxxflags
    global DEFAULT_CXXFLAGS
    global et_gthreads_timed

    global tool

    if { ![info exists et_gthreads_timed_target_name] } {
	set et_gthreads_timed_target_name ""
    }

    # If the target has changed since we set the cached value, clear it.
    set current_target [current_target_name]
    if { $current_target != $et_gthreads_timed_target_name } {
	verbose "check_v3_target_gthreads_timed: `$et_gthreads_timed_target_name'" 2
	set et_gthreads_timed_target_name $current_target
	if [info exists et_gthreads_timed] {
	    verbose "check_v3_target_gthreads_timed: removing cached result" 2
	    unset et_gthreads_timed
	}
    }

    if [info exists et_gthreads_timed] {
	verbose "check_v3_target_gthreads_timed: using cached result" 2
    } else {
	set et_gthreads_timed 0

	# Set up and preprocess a C++0x test program that depends
	# on the gthreads timed mutex facilities to be available.
	set src gthreads_timed[pid].cc

	set f [open $src "w"]
	puts $f "#include <bits/c++config.h>"
	puts $f "#ifndef _GLIBCXX_HAS_GTHREADS"
	puts $f "#  error No gthread"
	puts $f "#endif"
	puts $f "#if !_GTHREAD_USE_MUTEX_TIMEDLOCK"
	puts $f "#  error No gthread timed mutexes"
	puts $f "#endif"
	close $f

	set cxxflags_saved $cxxflags
	set cxxflags "$cxxflags $DEFAULT_CXXFLAGS -Werror"

	set lines [v3_target_compile $src /dev/null preprocess ""]
	set cxxflags $cxxflags_saved
	file delete $src

	if [string match "" $lines] {
	    # No error message, preprocessing succeeded.
	    set et_gthreads_timed 1
	} else {
	    verbose "check_v3_target_gthreads_timed: compilation failed" 2
	}
    }
    verbose "check_v3_target_gthreads_timed: $et_gthreads_timed" 2
    return $et_gthreads_timed
}


proc check_v3_target_sleep { } {
    global cxxflags
    global DEFAULT_CXXFLAGS
    global et_sleep

    global tool

    if { ![info exists et_sleep_target_name] } {
	set et_sleep_target_name ""
    }

    # If the target has changed since we set the cached value, clear it.
    set current_target [current_target_name]
    if { $current_target != $et_sleep_target_name } {
	verbose "check_v3_target_sleep: `$et_sleep_target_name'" 2
	set et_sleep_target_name $current_target
	if [info exists et_sleep] {
	    verbose "check_v3_target_sleep: removing cached result" 2
	    unset et_sleep
	}
    }

    if [info exists et_sleep] {
	verbose "check_v3_target_sleep: using cached result" 2
    } else {
	set et_sleep 0
	
	# Set up and preprocess a C++11 test program that depends
	# on the sleep facilities to be available.
	set src sleep[pid].cc

	set f [open $src "w"]
	puts $f "#include <bits/c++config.h>"
	puts $f "#ifndef _GLIBCXX_USE_NANOSLEEP"
	puts $f "# ifndef _GLIBCXX_HAVE_SLEEP"
	puts $f "#  error No nanosleep or sleep"
	puts $f "# endif"
	puts $f "#endif"
	close $f

	set cxxflags_saved $cxxflags
	set cxxflags "$cxxflags $DEFAULT_CXXFLAGS -Werror"

	set lines [v3_target_compile $src /dev/null preprocess ""]
	set cxxflags $cxxflags_saved
	file delete $src

	if [string match "" $lines] {
	    # No error message, preprocessing succeeded.
	    set et_sleep 1
	} else {
	    verbose "check_v3_target_sleep: compilation failed" 2
	}
    }
    verbose "check_v3_target_sleep: $et_sleep" 2
    return $et_sleep
}

proc check_v3_target_sched_yield { } {
    global cxxflags
    global DEFAULT_CXXFLAGS
    global et_sched_yield

    global tool

    if { ![info exists et_sched_yield_target_name] } {
	set et_sched_yield_target_name ""
    }

    # If the target has changed since we set the cached value, clear it.
    set current_target [current_target_name]
    if { $current_target != $et_sched_yield_target_name } {
	verbose "check_v3_target_sched_yield: `$et_sched_yield_target_name'" 2
	set et_sched_yield_target_name $current_target
	if [info exists et_sched_yield] {
	    verbose "check_v3_target_sched_yield: removing cached result" 2
	    unset et_sched_yield
	}
    }

    if [info exists et_sched_yield] {
	verbose "check_v3_target_sched_yield: using cached result" 2
    } else {
	set et_sched_yield 0

	# Set up and preprocess a C++0x test program that depends
	# on the sched_yield facility to be available.
	set src sched_yield[pid].cc

	set f [open $src "w"]
	puts $f "#include <bits/c++config.h>"
	puts $f "#ifndef _GLIBCXX_USE_SCHED_YIELD"
	puts $f "#  error No sched yield"
	puts $f "#endif"
	close $f

	set cxxflags_saved $cxxflags
	set cxxflags "$cxxflags $DEFAULT_CXXFLAGS -Werror"

	set lines [v3_target_compile $src /dev/null preprocess ""]
	set cxxflags $cxxflags_saved
	file delete $src

	if [string match "" $lines] {
	    # No error message, preprocessing succeeded.
	    set et_sched_yield 1
	} else {
	    verbose "check_v3_target_sched_yield: compilation failed" 2
	}
    }
    verbose "check_v3_target_sched_yield: $et_sched_yield" 2
    return $et_sched_yield
}

proc check_v3_target_string_conversions { } {
    global cxxflags
    global DEFAULT_CXXFLAGS
    global et_string_conversions

    global tool

    if { ![info exists et_string_conversions_target_name] } {
	set et_string_conversions_target_name ""
    }

    # If the target has changed since we set the cached value, clear it.
    set current_target [current_target_name]
    if { $current_target != $et_string_conversions_target_name } {
	verbose "check_v3_target_string_conversions: `$et_string_conversions_target_name'" 2
	set et_string_conversions_target_name $current_target
	if [info exists et_string_conversions] {
	    verbose "check_v3_target_string_conversions: removing cached result" 2
	    unset et_string_conversions
	}
    }

    if [info exists et_string_conversions] {
	verbose "check_v3_target_string_conversions: using cached result" 2
    } else {
	set et_string_conversions 0
	
	# Set up and preprocess a C++0x test program that depends
	# on the string_conversions facilities to be available.
	set src string_conversions[pid].cc

	set f [open $src "w"]
	puts $f "#include <bits/c++config.h>"
	puts $f "#if !(_GLIBCXX_USE_C99_STDIO && _GLIBCXX_USE_C99_STDLIB && _GLIBCXX_USE_C99_WCHAR) || defined(_GLIBCXX_HAVE_BROKEN_VSWPRINTF)"
	puts $f "#  error No string conversions"
	puts $f "#endif"
	close $f

	set cxxflags_saved $cxxflags
	set cxxflags "$cxxflags $DEFAULT_CXXFLAGS -Werror"

	set lines [v3_target_compile $src /dev/null preprocess ""]
	set cxxflags $cxxflags_saved
	file delete $src

	if [string match "" $lines] {
	    # No error message, preprocessing succeeded.
	    set et_string_conversions 1
	} else {
	    verbose "check_v3_target_string_conversions: compilation failed" 2
	}
    }
    verbose "check_v3_target_string_conversions: $et_string_conversions" 2
    return $et_string_conversions
}

proc check_v3_target_swprintf { } {
    global cxxflags
    global DEFAULT_CXXFLAGS
    global et_swprintf

    global tool

    if { ![info exists et_swprintf_target_name] } {
	set et_swprintf_target_name ""
    }

    # If the target has changed since we set the cached value, clear it.
    set current_target [current_target_name]
    if { $current_target != $et_swprintf_target_name } {
	verbose "check_v3_target_swprintf: `$et_swprintf_target_name'" 2
	set et_swprintf_target_name $current_target
	if [info exists et_swprintf] {
	    verbose "check_v3_target_swprintf: removing cached result" 2
	    unset et_swprintf
	}
    }

    if [info exists et_swprintf] {
	verbose "check_v3_target_swprintf: using cached result" 2
    } else {
	set et_swprintf 0
	
	# Set up and preprocess a C++0x test program that depends
	# on a standard swprintf function to be available.
	set src swprintf[pid].cc

	set f [open $src "w"]
	puts $f "#include <bits/c++config.h>"
	puts $f "#if defined(_GLIBCXX_HAVE_BROKEN_VSWPRINTF)"
	puts $f "#  error No swprintf"
	puts $f "#endif"
	close $f

	set cxxflags_saved $cxxflags
	set cxxflags "$cxxflags $DEFAULT_CXXFLAGS -Werror"

	set lines [v3_target_compile $src /dev/null preprocess ""]
	set cxxflags $cxxflags_saved
	file delete $src

	if [string match "" $lines] {
	    # No error message, preprocessing succeeded.
	    set et_swprintf 1
	} else {
	    verbose "check_v3_target_swprintf: compilation failed" 2
	}
    }
    verbose "check_v3_target_swprintf: $et_swprintf" 2
    return $et_swprintf
}

proc check_v3_target_binary_io { } {
    global cxxflags
    global DEFAULT_CXXFLAGS
    global et_binary_io

    global tool

    if { ![info exists et_binary_io_target_name] } {
	set et_binary_io_target_name ""
    }

    # If the target has changed since we set the cached value, clear it.
    set current_target [current_target_name]
    if { $current_target != $et_binary_io_target_name } {
	verbose "check_v3_target_binary_io: `$et_binary_io_target_name'" 2
	set et_binary_io_target_name $current_target
	if [info exists et_binary_io] {
	    verbose "check_v3_target_binary_io: removing cached result" 2
	    unset et_binary_io
	}
    }

    if [info exists et_binary_io] {
	verbose "check_v3_target_binary_io: using cached result" 2
    } else {
	set et_binary_io 0
	
	# Set up and preprocess a C++0x test program that depends
	# on text and binary I/O being the same.
	set src binary_io[pid].cc

	set f [open $src "w"]
	puts $f "#include <bits/c++config.h>"
	puts $f "#if defined(_GLIBCXX_HAVE_DOS_BASED_FILESYSTEM)"
	puts $f "#  error No binary io"
	puts $f "#endif"
	close $f

	set cxxflags_saved $cxxflags
	set cxxflags "$cxxflags $DEFAULT_CXXFLAGS -Werror"

	set lines [v3_target_compile $src /dev/null preprocess ""]
	set cxxflags $cxxflags_saved
	file delete $src

	if [string match "" $lines] {
	    # No error message, preprocessing succeeded.
	    set et_binary_io 1
	} else {
	    verbose "check_v3_target_binary_io: compilation failed" 2
	}
    }
    verbose "check_v3_target_binary_io: $et_binary_io" 2
    return $et_binary_io
}

proc check_v3_target_nprocs { } {
    global cxxflags
    global DEFAULT_CXXFLAGS
    global et_nprocs

    global tool

    if { ![info exists et_nprocs_target_name] } {
	set et_nprocs_target_name ""
    }

    # If the target has changed since we set the cached value, clear it.
    set current_target [current_target_name]
    if { $current_target != $et_nprocs_target_name } {
	verbose "check_v3_target_nprocs: `$et_nprocs_target_name'" 2
	set et_nprocs_target_name $current_target
	if [info exists et_nprocs] {
	    verbose "check_v3_target_nprocs: removing cached result" 2
	    unset et_nprocs
	}
    }

    if [info exists et_nprocs] {
	verbose "check_v3_target_nprocs: using cached result" 2
    } else {
	set et_nprocs 0

	# Set up and preprocess a C++0x test program that depends
	# on either get_nprocs or sysconf to be available.
	set src nprocs[pid].cc

	set f [open $src "w"]
	puts $f "#include <bits/c++config.h>"
	puts $f "#if defined(_GLIBCXX_USE_GET_NPROCS)"
	puts $f "#elif defined(_GLIBCXX_USE_PTHREADS_NUM_PROCESSORS_NP)"
	puts $f "#elif defined(_GLIBCXX_USE_SYSCTL_HW_NCPU)"
	puts $f "#elif defined(_GLIBCXX_USE_SC_NPROCESSORS_ONLN)"
	puts $f "#elif defined(_GLIBCXX_USE_SC_NPROC_ONLN)"
	puts $f "#else"
	puts $f "#  error hardware_concurrency not implemented"
	puts $f "#endif"
	close $f

	set cxxflags_saved $cxxflags
	set cxxflags "$cxxflags $DEFAULT_CXXFLAGS -Werror"

	set lines [v3_target_compile $src /dev/null preprocess ""]
	set cxxflags $cxxflags_saved
	file delete $src

	if [string match "" $lines] {
	    # No error message, preprocess succeeded.
	    set et_nprocs 1
	} else {
	    verbose "check_v3_target_nprocs: compilation failed" 2
	}
    }
    verbose "check_v3_target_nprocs: $et_nprocs" 2
    return $et_nprocs
}

proc check_v3_target_static_libstdcxx { } {
    global cxxflags
    global DEFAULT_CXXFLAGS
    global et_static_libstdcxx

    global tool

    if [info exists et_static_libstdcxx] {
	verbose "check_v3_target_static_libstdcxx: using cached result" 2
    } else {
	set et_static_libstdcxx 0

	# Set up and link a C++0x test program that depends
	# on static linking
	set src static-maybe[pid].cc

	set f [open $src "w"]
	puts $f "#include <iostream>"
	puts $f "int main() {"
	puts $f "int i(415);"
	puts $f "std::cout<< i << std::endl;"
	puts $f "return 0; }"
	puts $f ""
	close $f

	set cxxflags_saved $cxxflags
	set cxxflags "$cxxflags $DEFAULT_CXXFLAGS -static-libstdc++"

	set lines [v3_target_compile $src /dev/null executable ""]
	set cxxflags $cxxflags_saved
	file delete $src

	if [string match "" $lines] {
	    # No error message, link succeeded.
	    set et_static_libstdcxx 1
	} else {
	    verbose "check_v3_target_static_libstdcxx: compilation failed" 2
	}
    }
    verbose "check_v3_target_static_libstdcxx: $et_static_libstdcxx" 2
    return $et_static_libstdcxx
}

proc check_v3_target_little_endian { } {
    global cxxflags
    global DEFAULT_CXXFLAGS
    global et_little_endian

    global tool

    if { ![info exists et_little_endian_target_name] } {
	set et_little_endian_target_name ""
    }

    # If the target has changed since we set the cached value, clear it.
    set current_target [current_target_name]
    if { $current_target != $et_little_endian_target_name } {
	verbose "check_v3_target_little_endian: `$et_little_endian_target_name'" 2
	set et_little_endian_target_name $current_target
	if [info exists et_little_endian] {
	    verbose "check_v3_target_little_endian: removing cached result" 2
	    unset et_little_endian
	}
    }

    if [info exists et_little_endian] {
	verbose "check_v3_target_little_endian: using cached result" 2
    } else {
	set et_little_endian 0
	
	set src little_endian[pid].cc

	set f [open $src "w"]
	puts $f "#if __BYTE_ORDER__ != __ORDER_LITTLE_ENDIAN__"
	puts $f "#  error Not little endian"
	puts $f "#endif"
	close $f

	set cxxflags_saved $cxxflags
	set cxxflags "$cxxflags $DEFAULT_CXXFLAGS -Werror"

	set lines [v3_target_compile $src /dev/null preprocess ""]
	set cxxflags $cxxflags_saved
	file delete $src

	if [string match "" $lines] {
	    # No error message, preprocessing succeeded.
	    set et_little_endian 1
	} else {
	    verbose "check_v3_target_little_endian: compilation failed" 2
	}
    }
    verbose "check_v3_target_little_endian: $et_little_endian" 2
    return $et_little_endian
}

# Return 1 if the Filesystem TS is supported, 0 otherwise.
# Cache the result.
proc check_v3_target_filesystem_ts { } {
    global cxxflags
    global DEFAULT_CXXFLAGS
    global et_filesystem_ts
    global tool

    if { ![info exists et_filesystem_ts_target_name] } {
	set et_filesystem_ts_target_name ""
    }

    # If the target has changed since we set the cached value, clear it.
    set current_target [current_target_name]
    if { $current_target != $et_filesystem_ts_target_name } {
	verbose "check_v3_target_filesystem_ts: `$et_filesystem_ts_target_name'" 2
	set et_filesystem_ts_target_name $current_target
	if [info exists et_filesystem_ts] {
	    verbose "check_v3_target_filesystem_ts: removing cached result" 2
	    unset et_filesystem_ts
	}
    }

    if [info exists et_filesystem_ts] {
	verbose "check_v3_target_filesystem_ts: using cached result" 2
    } else {
	set et_filesystem_ts 0

	# Set up and preprocess a C++ test program that depends
	# on the Filesystem TS feature-test macro being defined.
	set src filesystem_ts[pid].cc

	set f [open $src "w"]
	puts $f "#include <experimental/filesystem>"
	puts $f "#if ! __cpp_lib_experimental_filesystem"
	puts $f "#  error No Filesystem TS support"
	puts $f "#endif"
	close $f

	set cxxflags_saved $cxxflags
	set cxxflags "$cxxflags $DEFAULT_CXXFLAGS -Werror"

	set lines [v3_target_compile $src /dev/null preprocess ""]
	set cxxflags $cxxflags_saved
	file delete $src

	if [string match "" $lines] {
	    # No error message, preprocessing succeeded.
	    set et_filesystem_ts 1
	}
    }
    verbose "check_v3_target_filesystem_ts: $et_filesystem_ts" 2
    return $et_filesystem_ts
}

# Return 1 if the "cxx11" ABI is in use using the current flags, 0 otherwise.
proc check_effective_target_cxx11-abi { } {
    global cxxflags

    # Set up and preprocess a C++ test program that depends
    # on the new ABI being enabled.
    set src cxx11_abi[pid].cc

    set f [open $src "w"]
    puts $f "#include <bits/c++config.h>"
    puts $f "#if ! _GLIBCXX_USE_CXX11_ABI"
    puts $f "#  error old ABI in use"
    puts $f "#endif"
    close $f

    set lines [v3_target_compile $src /dev/null preprocess ""]
    file delete $src

    if [string match "" $lines] {
	# No error message, preprocessing succeeded.
	verbose "check_v3_cxx11_abi: `1'" 2
	return 1
    }

    verbose "check_v3_cxx11_abi: `0'" 2
    return 0
}

# Return 1 if std::random_device should be usable using the current flags, 0 otherwise.
proc check_effective_target_random_device { } {
    global cxxflags

    # Set up and preprocess a C++ test program that depends
    # on std::random_device being usable.
    set src random_device[pid].cc

    set f [open $src "w"]
    puts $f "#include <bits/c++config.h>"
    puts $f "#if ! _GLIBCXX_USE_RANDOM_TR1"
    puts $f "#  error No working std::random_device available"
    puts $f "#endif"
    close $f

    set lines [v3_target_compile $src /dev/null preprocess ""]
    file delete $src

    if [string match "" $lines] {
	# No error message, preprocessing succeeded.
	verbose "check_v3_random_device: `1'" 2
	return 1
    }

    verbose "check_v3_random_device: `0'" 2
    return 0
}

set additional_prunes ""

if { [info exists env(GCC_RUNTEST_PARALLELIZE_DIR)] \
     && [info procs runtest_file_p] != [list] \
     && [info procs gcc_parallelize_saved_runtest_file_p] == [list] } then {
    global gcc_runtest_parallelize_counter
    global gcc_runtest_parallelize_counter_minor
    global gcc_runtest_parallelize_enable
    global gcc_runtest_parallelize_dir
    global gcc_runtest_parallelize_last

    set gcc_runtest_parallelize_counter 0
    set gcc_runtest_parallelize_counter_minor 0
    set gcc_runtest_parallelize_enable 1
    set gcc_runtest_parallelize_dir [getenv GCC_RUNTEST_PARALLELIZE_DIR]
    set gcc_runtest_parallelize_last 0

    proc gcc_parallel_test_run_p { testcase } {
	global gcc_runtest_parallelize_counter
	global gcc_runtest_parallelize_counter_minor
	global gcc_runtest_parallelize_enable
	global gcc_runtest_parallelize_dir
	global gcc_runtest_parallelize_last

	if { $gcc_runtest_parallelize_enable == 0 } {
	    return 1
	}

	# Only test the filesystem every 10th iteration
	incr gcc_runtest_parallelize_counter_minor
	if { $gcc_runtest_parallelize_counter_minor == 10 } {
	    set gcc_runtest_parallelize_counter_minor 0
	}
	if { $gcc_runtest_parallelize_counter_minor != 1 } {
	    #verbose -log "gcc_parallel_test_run_p $testcase $gcc_runtest_parallelize_counter $gcc_runtest_parallelize_last"
	    return $gcc_runtest_parallelize_last
	}

	set path $gcc_runtest_parallelize_dir/$gcc_runtest_parallelize_counter

	if {![catch {open $path {RDWR CREAT EXCL} 0600} fd]} {
	    close $fd
	    set gcc_runtest_parallelize_last 1
	    #verbose -log "gcc_parallel_test_run_p $testcase $gcc_runtest_parallelize_counter 1"
	    incr gcc_runtest_parallelize_counter
	    return 1
	}
	set gcc_runtest_parallelize_last 0
	#verbose -log "gcc_parallel_test_run_p $testcase $gcc_runtest_parallelize_counter 0"
	incr gcc_runtest_parallelize_counter
	return 0
    }

    proc gcc_parallel_test_enable { val } {
	global gcc_runtest_parallelize_enable
	set gcc_runtest_parallelize_enable $val
    }

    rename runtest_file_p gcc_parallelize_saved_runtest_file_p
    proc runtest_file_p { runtests testcase } {
	if ![gcc_parallelize_saved_runtest_file_p $runtests $testcase] {
	    return 0
	}
	return [gcc_parallel_test_run_p $testcase]
    }

} else {

    proc gcc_parallel_test_run_p { testcase } {
	return 1
    }

    proc gcc_parallel_test_enable { val } {
    }

}
