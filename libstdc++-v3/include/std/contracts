// Contracts support header for -*- C++ -*-

// Copyright (C) 2019-2024 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file contracts
 *  This is a Standard C++ Library header.
 */

#ifndef _GLIBCXX_CONTRACTS
#define _GLIBCXX_CONTRACTS 1

#pragma GCC system_header

#include <source_location>
#include <cstdint>
#include <bits/exception_ptr.h>

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

namespace contracts
{

// From P3290
  struct __location_info{
    std::source_location _M_source_location;
    explicit __location_info(std::source_location __location)
    : _M_source_location(__location){}
  };

  [[noreturn]] void handle_enforced_contract_violation(
      const char*,
      const std::source_location &__location = std::source_location::current());

  [[noreturn]] void handle_enforced_contract_violation(
      const std::nothrow_t&,
      const char*,
      const std::source_location &__location = std::source_location::current()) noexcept;

  void handle_observed_contract_violation(
      const char*,
      const std::source_location &__location = std::source_location::current());

  void handle_observed_contract_violation(
      const std::nothrow_t&,
      const char*,
      const std::source_location &__location = std::source_location::current()) noexcept;

  [[noreturn]] void handle_quick_enforced_contract_violation(
      const char*,
      const std::source_location &__location = std::source_location::current()) noexcept;


  // From P2900R11
  enum class assertion_kind {
    pre = 1,
    post = 2,
    assert = 3,
    // From P3290
    manual = 4,
    cassert = 5
    /* to be extended with implementation−defined values and by future extensions */
    /* Implementation−defined values should have a minimum value of 1000. */
    };

  enum class evaluation_semantic {
      ignore = 1,
      observe = 2,
      enforce = 3,
      quick_enforce = 4
	// not explicitly provided
	// assume = 5
	// expected as a future extension
	/* to be extended with implementation−defined values and by future extensions */
	/* Implementation−defined values should have a minimum value of 1000. */
  };

  enum class detection_mode  {
  // From P3290
    unspecified = 0,
    predicate_false = 1,
    evaluation_exception = 2
    /* to be extended with implementation−defined values and by future extensions
	 Implementation−defined values should have a minimum value of 1000. */
  };

  using __vendor_ext = void;

  class contract_violation {
    int _M_version;
    __vendor_ext* _M_ext;
    const char* _M_comment;
    detection_mode _M_detection_mode;
    assertion_kind _M_assertion_kind;
    std::source_location _M_source_location;
    evaluation_semantic _M_evaluation_semantic;

    contract_violation(evaluation_semantic __semantic,
		       const std::source_location &__location,
		       const char* __comment):
		    	   _M_version(0),
				   _M_ext(nullptr),
				   _M_comment(__comment),
				   _M_detection_mode(detection_mode::unspecified),
				   _M_assertion_kind(assertion_kind::manual),
				   _M_source_location(__location),
				   _M_evaluation_semantic(__semantic)
    {

    }

    friend void handle_enforced_contract_violation(
	const char*,
	const std::source_location &);

    friend void handle_enforced_contract_violation(
	const std::nothrow_t&,
	const char*,
	const std::source_location &) noexcept;

    friend void handle_observed_contract_violation(
	const char*,
	const std::source_location &);

    friend void handle_observed_contract_violation(
	const std::nothrow_t&,
	const char*,
	const std::source_location &) noexcept;

    friend void handle_quick_enforced_contract_violation(
	const char*,
	const std::source_location &) noexcept;

  public:
    // cannot be copied or moved
	contract_violation(const contract_violation&) = delete;

	// cannot be assigned to
	contract_violation& operator=(const contract_violation&) = delete;

	const char* comment() const noexcept { return _M_comment; }
	detection_mode mode() const noexcept { return _M_detection_mode; }
	std::exception_ptr evaluation_exception () const noexcept {
	  if (_M_detection_mode == std::contracts::detection_mode::evaluation_exception)
	    return std::current_exception ();
	  return nullptr;
	}
	bool is_terminating () const noexcept {
	  return _M_evaluation_semantic == std::contracts::evaluation_semantic::enforce
	        || _M_evaluation_semantic == std::contracts::evaluation_semantic::quick_enforce;
	}
	assertion_kind kind() const noexcept { return _M_assertion_kind; }
	std::source_location location() const noexcept { return _M_source_location; }
	evaluation_semantic semantic() const noexcept { return _M_evaluation_semantic; }
  };

  void invoke_default_contract_violation_handler(const contract_violation&) noexcept;


} // namespace contracts

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace std

#endif // _GLIBCXX_CONTRACTS
