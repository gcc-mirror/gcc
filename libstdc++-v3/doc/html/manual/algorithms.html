<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Chapter 11.  Algorithms</title><meta name="generator" content="DocBook XSL-NS Stylesheets V1.76.1"/><meta name="keywords" content="&#10;      ISO C++&#10;    , &#10;      library&#10;    , &#10;      algorithm&#10;    "/><meta name="keywords" content="&#10;      ISO C++&#10;    , &#10;      runtime&#10;    , &#10;      library&#10;    "/><link rel="home" href="../index.html" title="The GNU C++ Library"/><link rel="up" href="bk01pt02.html" title="Part II.  Standard Contents"/><link rel="prev" href="iterators.html" title="Chapter 10.  Iterators"/><link rel="next" href="numerics.html" title="Chapter 12.  Numerics"/></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 11. 
  Algorithms
  
</th></tr><tr><td align="left"><a accesskey="p" href="iterators.html">Prev</a> </td><th width="60%" align="center">Part II. 
    Standard Contents
  </th><td align="right"> <a accesskey="n" href="numerics.html">Next</a></td></tr></table><hr/></div><div class="chapter" title="Chapter 11.  Algorithms"><div class="titlepage"><div><div><h2 class="title"><a id="std.algorithms"/>Chapter 11. 
  Algorithms
  <a id="id612473" class="indexterm"/>
</h2></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl><dt><span class="section"><a href="algorithms.html#std.algorithms.mutating">Mutating</a></span></dt><dd><dl><dt><span class="section"><a href="algorithms.html#algorithms.mutating.swap"><code class="function">swap</code></a></span></dt><dd><dl><dt><span class="section"><a href="algorithms.html#algorithms.swap.specializations">Specializations</a></span></dt></dl></dd></dl></dd></dl></div><p>
  The neatest accomplishment of the algorithms sect1 is that all the
  work is done via iterators, not containers directly.  This means two
  important things:
</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>
      Anything that behaves like an iterator can be used in one of
      these algorithms.  Raw pointers make great candidates, thus
      built-in arrays are fine containers, as well as your own
      iterators.
    </p></li><li class="listitem"><p>
      The algorithms do not (and cannot) affect the container as a
      whole; only the things between the two iterator endpoints.  If
      you pass a range of iterators only enclosing the middle third of
      a container, then anything outside that range is inviolate.
    </p></li></ol></div><p>
  Even strings can be fed through the algorithms here, although the
  string class has specialized versions of many of these functions
  (for example, <code class="code">string::find()</code>).  Most of the examples
  on this page will use simple arrays of integers as a playground
  for algorithms, just to keep things simple.  The use of
  <span class="emphasis"><em>N</em></span> as a size in the examples is to keep things
  easy to read but probably won't be valid code.  You can use wrappers
  such as those described in
  the <a class="link" href="containers.html" title="Chapter 9.  Containers">containers sect1</a> to keep
  real code readable.
</p><p>
  The single thing that trips people up the most is the definition
  of <span class="emphasis"><em>range</em></span> used with iterators; the famous
  "past-the-end" rule that everybody loves to hate.  The
  <a class="link" href="iterators.html" title="Chapter 10.  Iterators">iterators sect1</a> of this
    document has a complete explanation of this simple rule that seems
    to cause so much confusion.  Once you
    get <span class="emphasis"><em>range</em></span> into your head (it's not that hard,
    honest!), then the algorithms are a cakewalk.
</p><div class="section" title="Mutating"><div class="titlepage"><div><div><h2 class="title"><a id="std.algorithms.mutating"/>Mutating</h2></div></div></div><div class="section" title="swap"><div class="titlepage"><div><div><h3 class="title"><a id="algorithms.mutating.swap"/><code class="function">swap</code></h3></div></div></div><div class="section" title="Specializations"><div class="titlepage"><div><div><h4 class="title"><a id="algorithms.swap.specializations"/>Specializations</h4></div></div></div><p>If you call <code class="code"> std::swap(x,y); </code> where x and y are standard
      containers, then the call will automatically be replaced by a call to
      <code class="code"> x.swap(y); </code> instead.
   </p><p>This allows member functions of each container class to take over, and
      containers' swap functions should have O(1) complexity according to
      the standard.  (And while "should" allows implementations to
      behave otherwise and remain compliant, this implementation does in
      fact use constant-time swaps.)  This should not be surprising, since
      for two containers of the same type to swap contents, only some
      internal pointers to storage need to be exchanged.
   </p></div></div></div></div><div class="navfooter"><hr/><table width="100%" summary="Navigation footer"><tr><td align="left"><a accesskey="p" href="iterators.html">Prev</a> </td><td align="center"><a accesskey="u" href="bk01pt02.html">Up</a></td><td align="right"> <a accesskey="n" href="numerics.html">Next</a></td></tr><tr><td align="left" valign="top">Chapter 10. 
  Iterators
  
 </td><td align="center"><a accesskey="h" href="../index.html">Home</a></td><td align="right" valign="top"> Chapter 12. 
  Numerics
  
</td></tr></table></div></body></html>
