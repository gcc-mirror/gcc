<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Bugs</title><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><meta name="keywords" content="ISO C++, library" /><meta name="keywords" content="ISO C++, runtime, library" /><link rel="home" href="../index.html" title="The GNU C++ Library" /><link rel="up" href="status.html" title="Chapter 1. Status" /><link rel="prev" href="license.html" title="License" /><link rel="next" href="setup.html" title="Chapter 2. Setup" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Bugs</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="license.html">Prev</a> </td><th width="60%" align="center">Chapter 1. Status</th><td width="20%" align="right"> <a accesskey="n" href="setup.html">Next</a></td></tr></table><hr /></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="manual.intro.status.bugs"></a>Bugs</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="manual.intro.status.bugs.impl"></a>Implementation Bugs</h3></div></div></div><p>
      Information on known bugs, details on efforts to fix them, and
      fixed bugs are all available as part of the <a class="link" href="https://gcc.gnu.org/bugs/" target="_top">GCC bug tracking system</a>,
      under the component <span class="quote">“<span class="quote">libstdc++</span>”</span>.
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="manual.intro.status.bugs.iso"></a>Standard Bugs</h3></div></div></div><p>
	Everybody's got issues.  Even the C++ Standard Library.
      </p><p>
	The Library Working Group, or LWG, is the ISO subcommittee responsible
	for making changes to the library.  They periodically publish an
	Issues List containing problems and possible solutions.  As they reach
	a consensus on proposed solutions, we often incorporate the solution.
      </p><p>
	Here are the issues which have resulted in code changes to the library.
	The links are to the full version of the Issues List.
        You can read the full version online
	at the <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/" target="_top">ISO C++
	Committee homepage</a>.
      </p><p>
	If a DR is not listed here, we may simply not have gotten to
	it yet; feel free to submit a patch.  Search the
        <code class="filename">include</code> and
        <code class="filename">src</code>
	directories for appearances of
	<code class="constant">_GLIBCXX_RESOLVE_LIB_DEFECTS</code> for examples
	of style.  Note that we usually do not make changes to the
	code until an issue has reached <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#DR" target="_top">DR</a> status.
      </p><div class="variablelist"><dl class="variablelist"><dt><a id="manual.bugs.dr5"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#5" target="_top">5</a>:
	<span class="emphasis"><em>string::compare specification questionable</em></span>
    </span></dt><dd><p>This should be two overloaded functions rather than a single function.
    </p></dd><dt><a id="manual.bugs.dr17"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#17" target="_top">17</a>:
	<span class="emphasis"><em>Bad bool parsing</em></span>
    </span></dt><dd><p>Apparently extracting Boolean values was messed up...
    </p></dd><dt><a id="manual.bugs.dr19"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#19" target="_top">19</a>:
	<span class="emphasis"><em>"Noconv" definition too vague</em></span>
    </span></dt><dd><p>If <code class="code">codecvt::do_in</code> returns <code class="code">noconv</code> there are
	no changes to the values in <code class="code">[to, to_limit)</code>.
    </p></dd><dt><a id="manual.bugs.dr22"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#22" target="_top">22</a>:
	<span class="emphasis"><em>Member open vs flags</em></span>
    </span></dt><dd><p>Re-opening a file stream does <span class="emphasis"><em>not</em></span> clear the state flags.
    </p></dd><dt><a id="manual.bugs.dr23"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#23" target="_top">23</a>:
	<span class="emphasis"><em>Num_get overflow result</em></span>
    </span></dt><dd><p>Implement the proposed resolution.
    </p></dd><dt><a id="manual.bugs.dr25"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#25" target="_top">25</a>:
	<span class="emphasis"><em>String operator&lt;&lt; uses width() value wrong</em></span>
    </span></dt><dd><p>Padding issues.
    </p></dd><dt><a id="manual.bugs.dr48"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#48" target="_top">48</a>:
	<span class="emphasis"><em>Use of non-existent exception constructor</em></span>
    </span></dt><dd><p>An instance of <code class="code">ios_base::failure</code> is constructed instead.
    </p></dd><dt><a id="manual.bugs.dr49"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#49" target="_top">49</a>:
	<span class="emphasis"><em>Underspecification of ios_base::sync_with_stdio</em></span>
    </span></dt><dd><p>The return type is the <span class="emphasis"><em>previous</em></span> state of synchronization.
    </p></dd><dt><a id="manual.bugs.dr50"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#50" target="_top">50</a>:
	<span class="emphasis"><em>Copy constructor and assignment operator of ios_base</em></span>
    </span></dt><dd><p>These members functions are declared <code class="code">private</code> and are
	thus inaccessible.  Specifying the correct semantics of
	"copying stream state" was deemed too complicated.
    </p></dd><dt><a id="manual.bugs.dr60"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#60" target="_top">60</a>:
	<span class="emphasis"><em>What is a formatted input function?</em></span>
    </span></dt><dd><p>This DR made many widespread changes to <code class="code">basic_istream</code>
	and <code class="code">basic_ostream</code> all of which have been implemented.
    </p></dd><dt><a id="manual.bugs.dr63"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#63" target="_top">63</a>:
	<span class="emphasis"><em>Exception-handling policy for unformatted output</em></span>
    </span></dt><dd><p>Make the policy consistent with that of formatted input, unformatted
	input, and formatted output.
    </p></dd><dt><a id="manual.bugs.dr68"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#68" target="_top">68</a>:
	<span class="emphasis"><em>Extractors for char* should store null at end</em></span>
    </span></dt><dd><p>And they do now.  An editing glitch in the last item in the list of
	[27.6.1.2.3]/7.
    </p></dd><dt><a id="manual.bugs.dr74"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#74" target="_top">74</a>:
	<span class="emphasis"><em>Garbled text for codecvt::do_max_length</em></span>
    </span></dt><dd><p>The text of the standard was gibberish.  Typos gone rampant.
    </p></dd><dt><a id="manual.bugs.dr75"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#75" target="_top">75</a>:
	<span class="emphasis"><em>Contradiction in codecvt::length's argument types</em></span>
    </span></dt><dd><p>Change the first parameter to <code class="code">stateT&amp;</code> and implement
	the new effects paragraph.
    </p></dd><dt><a id="manual.bugs.dr83"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#83" target="_top">83</a>:
	<span class="emphasis"><em>string::npos vs. string::max_size()</em></span>
    </span></dt><dd><p>Safety checks on the size of the string should test against
	<code class="code">max_size()</code> rather than <code class="code">npos</code>.
    </p></dd><dt><a id="manual.bugs.dr90"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#90" target="_top">90</a>:
	<span class="emphasis"><em>Incorrect description of operator&gt;&gt; for strings</em></span>
    </span></dt><dd><p>The effect contain <code class="code">isspace(c,getloc())</code> which must be
	replaced by <code class="code">isspace(c,is.getloc())</code>.
    </p></dd><dt><a id="manual.bugs.dr91"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#91" target="_top">91</a>:
	<span class="emphasis"><em>Description of operator&gt;&gt; and getline() for string&lt;&gt;
	    might cause endless loop</em></span>
    </span></dt><dd><p>They behave as a formatted input function and as an unformatted
	input function, respectively (except that <code class="code">getline</code> is
	not required to set <code class="code">gcount</code>).
    </p></dd><dt><a id="manual.bugs.dr103"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#103" target="_top">103</a>:
	<span class="emphasis"><em>set::iterator is required to be modifiable, but this allows
	    modification of keys.</em></span>
    </span></dt><dd><p>For associative containers where the value type is the same as
	the key type, both <code class="code">iterator</code> and <code class="code">const_iterator
	</code> are constant iterators.
    </p></dd><dt><a id="manual.bugs.dr109"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#109" target="_top">109</a>:
	<span class="emphasis"><em>Missing binders for non-const sequence elements</em></span>
    </span></dt><dd><p>The <code class="code">binder1st</code> and <code class="code">binder2nd</code> didn't have an
	<code class="code">operator()</code> taking a non-const parameter.
    </p></dd><dt><a id="manual.bugs.dr110"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#110" target="_top">110</a>:
	<span class="emphasis"><em>istreambuf_iterator::equal not const</em></span>
    </span></dt><dd><p>This was not a const member function.  Note that the DR says to
	replace the function with a const one; we have instead provided an
	overloaded version with identical contents.
    </p></dd><dt><a id="manual.bugs.dr117"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#117" target="_top">117</a>:
	<span class="emphasis"><em>basic_ostream uses nonexistent num_put member functions</em></span>
    </span></dt><dd><p><code class="code">num_put::put()</code> was overloaded on the wrong types.
    </p></dd><dt><a id="manual.bugs.dr118"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#118" target="_top">118</a>:
	<span class="emphasis"><em>basic_istream uses nonexistent num_get member functions</em></span>
    </span></dt><dd><p>Same as 117, but for <code class="code">num_get::get()</code>.
    </p></dd><dt><a id="manual.bugs.dr129"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#129" target="_top">129</a>:
	<span class="emphasis"><em>Need error indication from seekp() and seekg()</em></span>
    </span></dt><dd><p>These functions set <code class="code">failbit</code> on error now.
    </p></dd><dt><a id="manual.bugs.dr130"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#130" target="_top">130</a>:
	<span class="emphasis"><em>Return type of container::erase(iterator) differs for associative containers</em></span>
    </span></dt><dd><p>Make member <code class="code">erase</code> return iterator for <code class="code">set</code>, <code class="code">multiset</code>, <code class="code">map</code>, <code class="code">multimap</code>.
    </p></dd><dt><a id="manual.bugs.dr136"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#136" target="_top">136</a>:
	<span class="emphasis"><em>seekp, seekg setting wrong streams?</em></span>
    </span></dt><dd><p><code class="code">seekp</code> should only set the output stream, and
	<code class="code">seekg</code> should only set the input stream.
    </p></dd><dt><a id="manual.bugs.dr167"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#167" target="_top">167</a>:
	<span class="emphasis"><em>Improper use of traits_type::length()</em></span>
    </span></dt><dd><p><code class="code">op&lt;&lt;</code> with a <code class="code">const char*</code> was
	calculating an incorrect number of characters to write.
    </p></dd><dt><a id="manual.bugs.dr169"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#169" target="_top">169</a>:
	<span class="emphasis"><em>Bad efficiency of overflow() mandated</em></span>
    </span></dt><dd><p>Grow efficiently the internal array object.
    </p></dd><dt><a id="manual.bugs.dr171"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#171" target="_top">171</a>:
	<span class="emphasis"><em>Strange seekpos() semantics due to joint position</em></span>
    </span></dt><dd><p>Quite complex to summarize...
    </p></dd><dt><a id="manual.bugs.dr181"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#181" target="_top">181</a>:
	<span class="emphasis"><em>make_pair() unintended behavior</em></span>
    </span></dt><dd><p>This function used to take its arguments as reference-to-const, now
	it copies them (pass by value).
    </p></dd><dt><a id="manual.bugs.dr195"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#195" target="_top">195</a>:
	<span class="emphasis"><em>Should basic_istream::sentry's constructor ever set eofbit?</em></span>
    </span></dt><dd><p>Yes, it can, specifically if EOF is reached while skipping whitespace.
    </p></dd><dt><a id="manual.bugs.dr206"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#206" target="_top">206</a>:
	<span class="emphasis"><em><code class="code">operator new(size_t, nothrow)</code> may become
          unlinked to ordinary <code class="code">operator new</code> if ordinary
          version replaced
        </em></span>
    </span></dt><dd><p>The <code class="code">nothrow</code> forms of new and delete were
      changed to call the throwing forms, handling any exception by
      catching it and returning a null pointer.
    </p></dd><dt><a id="manual.bugs.dr211"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#211" target="_top">211</a>:
	<span class="emphasis"><em>operator&gt;&gt;(istream&amp;, string&amp;) doesn't set failbit</em></span>
    </span></dt><dd><p>If nothing is extracted into the string, <code class="code">op&gt;&gt;</code> now
	sets <code class="code">failbit</code> (which can cause an exception, etc., etc.).
    </p></dd><dt><a id="manual.bugs.dr214"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#214" target="_top">214</a>:
	<span class="emphasis"><em>set::find() missing const overload</em></span>
    </span></dt><dd><p>Both <code class="code">set</code> and <code class="code">multiset</code> were missing
	overloaded find, lower_bound, upper_bound, and equal_range functions
	for const instances.
    </p></dd><dt><a id="manual.bugs.dr231"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#231" target="_top">231</a>:
	<span class="emphasis"><em>Precision in iostream?</em></span>
    </span></dt><dd><p>For conversion from a floating-point type, <code class="code">str.precision()</code>
	is specified in the conversion specification.
    </p></dd><dt><a id="manual.bugs.dr233"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#233" target="_top">233</a>:
	<span class="emphasis"><em>Insertion hints in associative containers</em></span>
    </span></dt><dd><p>Implement N1780, first check before then check after, insert as close
	to hint as possible.
    </p></dd><dt><a id="manual.bugs.dr235"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#235" target="_top">235</a>:
	<span class="emphasis"><em>No specification of default ctor for reverse_iterator</em></span>
    </span></dt><dd><p>The declaration of <code class="code">reverse_iterator</code> lists a default constructor.
	However, no specification is given what this constructor should do.
    </p></dd><dt><a id="manual.bugs.dr241"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#241" target="_top">241</a>:
	<span class="emphasis"><em>Does unique_copy() require CopyConstructible and Assignable?</em></span>
    </span></dt><dd><p>Add a helper for forward_iterator/output_iterator, fix the existing
	one for input_iterator/output_iterator to not rely on Assignability.
    </p></dd><dt><a id="manual.bugs.dr243"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#243" target="_top">243</a>:
	<span class="emphasis"><em>get and getline when sentry reports failure</em></span>
    </span></dt><dd><p>Store a null character only if the character array has a non-zero size.
    </p></dd><dt><a id="manual.bugs.dr251"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#251" target="_top">251</a>:
	<span class="emphasis"><em>basic_stringbuf missing allocator_type</em></span>
    </span></dt><dd><p>This nested typedef was originally not specified.
    </p></dd><dt><a id="manual.bugs.dr253"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#253" target="_top">253</a>:
	<span class="emphasis"><em>valarray helper functions are almost entirely useless</em></span>
    </span></dt><dd><p>Make the copy constructor and copy-assignment operator declarations
	public in gslice_array, indirect_array, mask_array, slice_array; provide
	definitions.
    </p></dd><dt><a id="manual.bugs.dr265"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#265" target="_top">265</a>:
	<span class="emphasis"><em>std::pair::pair() effects overly restrictive</em></span>
    </span></dt><dd><p>The default ctor would build its members from copies of temporaries;
	now it simply uses their respective default ctors.
    </p></dd><dt><a id="manual.bugs.dr266"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#266" target="_top">266</a>:
	<span class="emphasis"><em>bad_exception::~bad_exception() missing Effects clause</em></span>
    </span></dt><dd><p>The <code class="code">bad_</code>* classes no longer have destructors (they
	are trivial), since no description of them was ever given.
    </p></dd><dt><a id="manual.bugs.dr271"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#271" target="_top">271</a>:
	<span class="emphasis"><em>basic_iostream missing typedefs</em></span>
    </span></dt><dd><p>The typedefs it inherits from its base classes can't be used, since
	(for example) <code class="code">basic_iostream&lt;T&gt;::traits_type</code> is ambiguous.
    </p></dd><dt><a id="manual.bugs.dr275"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#275" target="_top">275</a>:
	<span class="emphasis"><em>Wrong type in num_get::get() overloads</em></span>
    </span></dt><dd><p>Similar to 118.
    </p></dd><dt><a id="manual.bugs.dr280"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#280" target="_top">280</a>:
	<span class="emphasis"><em>Comparison of reverse_iterator to const reverse_iterator</em></span>
    </span></dt><dd><p>Add global functions with two template parameters.
	(NB: not added for now a templated assignment operator)
    </p></dd><dt><a id="manual.bugs.dr292"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#292" target="_top">292</a>:
	<span class="emphasis"><em>Effects of a.copyfmt (a)</em></span>
    </span></dt><dd><p>If <code class="code">(this == &amp;rhs)</code> do nothing.
    </p></dd><dt><a id="manual.bugs.dr300"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#300" target="_top">300</a>:
	<span class="emphasis"><em>List::merge() specification incomplete</em></span>
    </span></dt><dd><p>If <code class="code">(this == &amp;x)</code> do nothing.
    </p></dd><dt><a id="manual.bugs.dr303"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#303" target="_top">303</a>:
	<span class="emphasis"><em>Bitset input operator underspecified</em></span>
    </span></dt><dd><p>Basically, compare the input character to
		    <code class="code">is.widen(0)</code> and <code class="code">is.widen(1)</code>.
    </p></dd><dt><a id="manual.bugs.dr305"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#305" target="_top">305</a>:
	<span class="emphasis"><em>Default behavior of codecvt&lt;wchar_t, char,
		  mbstate_t&gt;::length()</em></span>
    </span></dt><dd><p>Do not specify what <code class="code">codecvt&lt;wchar_t, char,
		    mbstate_t&gt;::do_length</code> must return.
    </p></dd><dt><a id="manual.bugs.dr328"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#328" target="_top">328</a>:
	<span class="emphasis"><em>Bad sprintf format modifier in
		  money_put&lt;&gt;::do_put()</em></span>
    </span></dt><dd><p>Change the format string to "%.0Lf".
    </p></dd><dt><a id="manual.bugs.dr365"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#365" target="_top">365</a>:
	<span class="emphasis"><em>Lack of const-qualification in clause 27</em></span>
    </span></dt><dd><p>Add const overloads of <code class="code">is_open</code>.
    </p></dd><dt><a id="manual.bugs.dr387"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#387" target="_top">387</a>:
	<span class="emphasis"><em>std::complex over-encapsulated</em></span>
    </span></dt><dd><p>Add the <code class="code">real(T)</code> and <code class="code">imag(T)</code>
		    members;  in C++11 mode, also adjust the existing
		    <code class="code">real()</code> and <code class="code">imag()</code> members and
		    free functions.
    </p></dd><dt><a id="manual.bugs.dr389"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#389" target="_top">389</a>:
	<span class="emphasis"><em>Const overload of valarray::operator[] returns
		  by value</em></span>
    </span></dt><dd><p>Change it to return a <code class="code">const T&amp;</code>.
    </p></dd><dt><a id="manual.bugs.dr396"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#396" target="_top">396</a>:
	<span class="emphasis"><em>what are characters zero and one</em></span>
    </span></dt><dd><p>Implement the proposed resolution.
    </p></dd><dt><a id="manual.bugs.dr402"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#402" target="_top">402</a>:
	<span class="emphasis"><em>Wrong new expression in [some_]allocator::construct</em></span>
    </span></dt><dd><p>Replace "new" with "::new".
    </p></dd><dt><span class="term"><a class="link" href="../ext/lwg-closed.html#408" target="_top">408</a>:
	<span class="emphasis"><em>
	Is vector&lt;reverse_iterator&lt;char*&gt; &gt; forbidden?
	</em></span>
    </span></dt><dd><p>Tweak the debug-mode checks in _Safe_iterator.
    </p></dd><dt><a id="manual.bugs.dr409"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#409" target="_top">409</a>:
	<span class="emphasis"><em>Closing an fstream should clear the error state</em></span>
    </span></dt><dd><p>Have <code class="code">open</code> clear the error flags.
    </p></dd><dt><span class="term"><a class="link" href="../ext/lwg-closed.html#431" target="_top">431</a>:
	<span class="emphasis"><em>Swapping containers with unequal allocators</em></span>
    </span></dt><dd><p>Implement Option 3, as per N1599.
    </p></dd><dt><a id="manual.bugs.dr432"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#432" target="_top">432</a>:
	<span class="emphasis"><em>stringbuf::overflow() makes only one write position
	    available</em></span>
    </span></dt><dd><p>Implement the resolution, beyond DR 169.
    </p></dd><dt><a id="manual.bugs.dr434"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#434" target="_top">434</a>:
	<span class="emphasis"><em>bitset::to_string() hard to use</em></span>
    </span></dt><dd><p>Add three overloads, taking fewer template arguments.
    </p></dd><dt><a id="manual.bugs.dr438"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#438" target="_top">438</a>:
	<span class="emphasis"><em>Ambiguity in the "do the right thing" clause</em></span>
    </span></dt><dd><p>Implement the resolution, basically cast less.
    </p></dd><dt><a id="manual.bugs.dr445"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#445" target="_top">445</a>:
	<span class="emphasis"><em>iterator_traits::reference unspecified for some iterator categories</em></span>
    </span></dt><dd><p>Change <code class="code">istreambuf_iterator::reference</code> in C++11 mode.
    </p></dd><dt><a id="manual.bugs.dr453"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#453" target="_top">453</a>:
	<span class="emphasis"><em>basic_stringbuf::seekoff need not always fail for an empty stream</em></span>
    </span></dt><dd><p>Don't fail if the next pointer is null and newoff is zero.
    </p></dd><dt><a id="manual.bugs.dr455"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#455" target="_top">455</a>:
	<span class="emphasis"><em>cerr::tie() and wcerr::tie() are overspecified</em></span>
    </span></dt><dd><p>Initialize cerr tied to cout and wcerr tied to wcout.
    </p></dd><dt><a id="manual.bugs.dr464"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#464" target="_top">464</a>:
	<span class="emphasis"><em>Suggestion for new member functions in standard containers</em></span>
    </span></dt><dd><p>Add <code class="code">data()</code> to <code class="code">std::vector</code> and
	<code class="code">at(const key_type&amp;)</code> to <code class="code">std::map</code>.
    </p></dd><dt><a id="manual.bugs.dr467"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#467" target="_top">467</a>:
	<span class="emphasis"><em>char_traits::lt(), compare(), and memcmp()</em></span>
    </span></dt><dd><p>Change <code class="code">lt</code>.
    </p></dd><dt><a id="manual.bugs.dr508"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#508" target="_top">508</a>:
	<span class="emphasis"><em>Bad parameters for ranlux64_base_01</em></span>
    </span></dt><dd><p>Fix the parameters.
    </p></dd><dt><span class="term"><a class="link" href="../ext/lwg-closed.html#512" target="_top">512</a>:
	<span class="emphasis"><em>Seeding subtract_with_carry_01 from a single unsigned long</em></span>
    </span></dt><dd><p>Construct a <code class="code">linear_congruential</code> engine and seed with it.
    </p></dd><dt><span class="term"><a class="link" href="../ext/lwg-closed.html#526" target="_top">526</a>:
	<span class="emphasis"><em>Is it undefined if a function in the standard changes in
	    parameters?</em></span>
    </span></dt><dd><p>Use &amp;value.
    </p></dd><dt><a id="manual.bugs.dr538"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#538" target="_top">538</a>:
	<span class="emphasis"><em>241 again: Does unique_copy() require CopyConstructible
	    and Assignable?</em></span>
    </span></dt><dd><p>In case of input_iterator/output_iterator rely on Assignability of
	input_iterator' value_type.
    </p></dd><dt><a id="manual.bugs.dr539"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#539" target="_top">539</a>:
	<span class="emphasis"><em>partial_sum and adjacent_difference should mention
	    requirements</em></span>
    </span></dt><dd><p>We were almost doing the right thing, just use std::move
	in adjacent_difference.
    </p></dd><dt><a id="manual.bugs.dr541"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#541" target="_top">541</a>:
	<span class="emphasis"><em>shared_ptr template assignment and void</em></span>
    </span></dt><dd><p>Add an auto_ptr&lt;void&gt; specialization.
    </p></dd><dt><a id="manual.bugs.dr543"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#543" target="_top">543</a>:
	<span class="emphasis"><em>valarray slice default constructor</em></span>
    </span></dt><dd><p>Follow the straightforward proposed resolution.
    </p></dd><dt><a id="manual.bugs.dr550"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#550" target="_top">550</a>:
	<span class="emphasis"><em>What should the return type of pow(float,int) be?</em></span>
    </span></dt><dd><p>In C++11 mode, remove the pow(float,int), etc., signatures.
    </p></dd><dt><a id="manual.bugs.dr586"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#586" target="_top">586</a>:
	<span class="emphasis"><em>string inserter not a formatted function</em></span>
    </span></dt><dd><p>Change it to be a formatted output function (i.e. catch exceptions).
    </p></dd><dt><a id="manual.bugs.dr596"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#596" target="_top">596</a>:
	<span class="emphasis"><em>27.8.1.3 Table 112 omits "a+" and "a+b" modes</em></span>
    </span></dt><dd><p>Add the missing modes to fopen_mode.
    </p></dd><dt><a id="manual.bugs.dr630"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#630" target="_top">630</a>:
	<span class="emphasis"><em>arrays of valarray</em></span>
    </span></dt><dd><p>Implement the simple resolution.
    </p></dd><dt><a id="manual.bugs.dr660"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#660" target="_top">660</a>:
	<span class="emphasis"><em>Missing bitwise operations</em></span>
    </span></dt><dd><p>Add the missing operations.
    </p></dd><dt><a id="manual.bugs.dr691"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#691" target="_top">691</a>:
	<span class="emphasis"><em>const_local_iterator cbegin, cend missing from TR1</em></span>
    </span></dt><dd><p>In C++11 mode add cbegin(size_type) and cend(size_type)
		    to the unordered containers.
    </p></dd><dt><a id="manual.bugs.dr693"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#693" target="_top">693</a>:
	<span class="emphasis"><em>std::bitset::all() missing</em></span>
    </span></dt><dd><p>Add it, consistently with the discussion.
    </p></dd><dt><a id="manual.bugs.dr695"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#695" target="_top">695</a>:
	<span class="emphasis"><em>ctype&lt;char&gt;::classic_table() not accessible</em></span>
    </span></dt><dd><p>Make the member functions table and classic_table public.
    </p></dd><dt><a id="manual.bugs.dr696"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#696" target="_top">696</a>:
	<span class="emphasis"><em>istream::operator&gt;&gt;(int&amp;) broken</em></span>
    </span></dt><dd><p>Implement the straightforward resolution.
    </p></dd><dt><a id="manual.bugs.dr761"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#761" target="_top">761</a>:
	<span class="emphasis"><em>unordered_map needs an at() member function</em></span>
    </span></dt><dd><p>In C++11 mode, add at() and at() const.
    </p></dd><dt><a id="manual.bugs.dr775"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#775" target="_top">775</a>:
	<span class="emphasis"><em>Tuple indexing should be unsigned?</em></span>
    </span></dt><dd><p>Implement the int -&gt; size_t replacements.
    </p></dd><dt><a id="manual.bugs.dr776"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#776" target="_top">776</a>:
	<span class="emphasis"><em>Undescribed assign function of std::array</em></span>
    </span></dt><dd><p>In C++11 mode, remove assign, add fill.
    </p></dd><dt><a id="manual.bugs.dr781"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#781" target="_top">781</a>:
	<span class="emphasis"><em>std::complex should add missing C99 functions</em></span>
    </span></dt><dd><p>In C++11 mode, add std::proj.
    </p></dd><dt><a id="manual.bugs.dr809"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#809" target="_top">809</a>:
	<span class="emphasis"><em>std::swap should be overloaded for array types</em></span>
    </span></dt><dd><p>Add the overload.
    </p></dd><dt><a id="manual.bugs.dr853"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#853" target="_top">853</a>:
	<span class="emphasis"><em>to_string needs updating with zero and one</em></span>
    </span></dt><dd><p>Update / add the signatures.
    </p></dd><dt><a id="manual.bugs.dr865"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#865" target="_top">865</a>:
	<span class="emphasis"><em>More algorithms that throw away information</em></span>
    </span></dt><dd><p>The traditional HP / SGI return type and value is blessed
		    by the resolution of the DR.
    </p></dd><dt><a id="manual.bugs.dr1339"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1339" target="_top">1339</a>:
       <span class="emphasis"><em>uninitialized_fill_n should return the end of its range</em></span>
    </span></dt><dd><p>Return the end of the filled range.
    </p></dd><dt><a id="manual.bugs.dr2021"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2021" target="_top">2021</a>:
       <span class="emphasis"><em>Further incorrect uses of <code class="code">result_of</code></em></span>
    </span></dt><dd><p>Correctly decay types in signature of <code class="code">std::async</code>.
    </p></dd><dt><a id="manual.bugs.dr2049"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2049" target="_top">2049</a>:
	<span class="emphasis"><em><code class="code">is_destructible</code> underspecified</em></span>
    </span></dt><dd><p>Handle non-object types.
    </p></dd><dt><a id="manual.bugs.dr2056"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2056" target="_top">2056</a>:
	<span class="emphasis"><em>future_errc enums start with value 0 (invalid value for broken_promise)</em></span>
    </span></dt><dd><p>Reorder enumerators.
    </p></dd><dt><a id="manual.bugs.dr2059"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2059" target="_top">2059</a>:
	<span class="emphasis"><em>C++0x ambiguity problem with map::erase</em></span>
    </span></dt><dd><p>Add additional overloads.
    </p></dd><dt><a id="manual.bugs.dr2062"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2062" target="_top">2062</a>:
	<span class="emphasis"><em>2062. Effect contradictions w/o no-throw guarantee of <code class="code">std::function</code> swaps</em></span>
    </span></dt><dd><p>Add <code class="code">noexcept</code> to swap functions.
    </p></dd><dt><a id="manual.bugs.dr2063"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2063" target="_top">2063</a>:
	<span class="emphasis"><em>Contradictory requirements for string move assignment</em></span>
    </span></dt><dd><p>Respect propagation trait for move assignment.
    </p></dd><dt><a id="manual.bugs.dr2064"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2064" target="_top">2064</a>:
	<span class="emphasis"><em>More noexcept issues in basic_string</em></span>
    </span></dt><dd><p>Add noexcept to the comparison operators.
    </p></dd><dt><a id="manual.bugs.dr2067"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2067" target="_top">2067</a>:
	<span class="emphasis"><em>packaged_task should have deleted copy c'tor with const parameter</em></span>
    </span></dt><dd><p>Fix signatures.
    </p></dd><dt><a id="manual.bugs.dr2101"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2101" target="_top">2101</a>:
	<span class="emphasis"><em>Some transformation types can produce impossible types</em></span>
    </span></dt><dd><p>Use the referenceable type concept.
    </p></dd><dt><a id="manual.bugs.dr2106"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2106" target="_top">2106</a>:
	<span class="emphasis"><em>move_iterator wrapping iterators returning prvalues</em></span>
    </span></dt><dd><p>Change the <code class="code">reference</code> type.
    </p></dd><dt><a id="manual.bugs.dr2108"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2108" target="_top">2108</a>:
	<span class="emphasis"><em>No way to identify allocator types that always compare equal</em></span>
    </span></dt><dd><p>Define and use <code class="code">is_always_equal</code> even for C++11.
    </p></dd><dt><a id="manual.bugs.dr2118"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2118" target="_top">2118</a>:
	<span class="emphasis"><em><code class="code">unique_ptr</code> for array does not support cv qualification conversion of actual argument</em></span>
    </span></dt><dd><p>Adjust constraints to allow safe conversions.
    </p></dd><dt><a id="manual.bugs.dr2127"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2127" target="_top">2127</a>:
	<span class="emphasis"><em>Move-construction with <code class="code">raw_storage_iterator</code></em></span>
    </span></dt><dd><p>Add assignment operator taking an rvalue.
    </p></dd><dt><a id="manual.bugs.dr2132"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2132" target="_top">2132</a>:
	<span class="emphasis"><em><code class="code">std::function</code> ambiguity</em></span>
    </span></dt><dd><p>Constrain the constructor to only accept callable types.
    </p></dd><dt><a id="manual.bugs.dr2141"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2141" target="_top">2141</a>:
	<span class="emphasis"><em><code class="code">common_type</code> trait produces reference types</em></span>
    </span></dt><dd><p>Use <code class="code">decay</code> for the result type.
    </p></dd><dt><a id="manual.bugs.dr2144"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2144" target="_top">2144</a>:
	<span class="emphasis"><em>Missing <code class="code">noexcept</code> specification in <code class="code">type_index</code></em></span>
    </span></dt><dd><p>Add <code class="code">noexcept</code>
    </p></dd><dt><a id="manual.bugs.dr2145"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2145" target="_top">2145</a>:
	<span class="emphasis"><em><code class="code">error_category</code> default constructor</em></span>
    </span></dt><dd><p>Declare a public constexpr constructor.
    </p></dd><dt><a id="manual.bugs.dr2162"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2162" target="_top">2162</a>:
	<span class="emphasis"><em><code class="code">allocator_traits::max_size</code> missing <code class="code">noexcept</code></em></span>
    </span></dt><dd><p>Add <code class="code">noexcept</code>.
    </p></dd><dt><a id="manual.bugs.dr2187"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2187" target="_top">2187</a>:
	<span class="emphasis"><em><code class="code">vector&lt;bool&gt;</code> is missing <code class="code">emplace</code> and <code class="code">emplace_back</code> member functions</em></span>
    </span></dt><dd><p>Add <code class="code">emplace</code> and <code class="code">emplace_back</code> member functions.
    </p></dd><dt><a id="manual.bugs.dr2192"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2192" target="_top">2192</a>:
	<span class="emphasis"><em>Validity and return type of <code class="code">std::abs(0u)</code> is unclear</em></span>
    </span></dt><dd><p>Move all declarations to a common header and remove the
    generic <code class="code">abs</code> which accepted unsigned arguments.
    </p></dd><dt><a id="manual.bugs.dr2196"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2196" target="_top">2196</a>:
	<span class="emphasis"><em>Specification of <code class="code">is_*[copy/move]_[constructible/assignable]</code> unclear for non-referencable types</em></span>
    </span></dt><dd><p>Use the referenceable type concept.
    </p></dd><dt><a id="manual.bugs.dr2212"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2212" target="_top">2212</a>:
	<span class="emphasis"><em><code class="code">tuple_size</code> for <code class="code">const pair</code> request <code class="code">&lt;tuple&gt;</code> header</em></span>
    </span></dt><dd><p>The <code class="code">tuple_size</code> and <code class="code">tuple_element</code>
    partial specializations are defined in <code class="code">&lt;utility&gt;</code> which
    is included by <code class="code">&lt;array&gt;</code>.
    </p></dd><dt><a id="manual.bugs.dr2296"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2296" target="_top">2296</a>:
	<span class="emphasis"><em><code class="code">std::addressof</code> should be constexpr</em></span>
    </span></dt><dd><p>Use <code class="code">__builtin_addressof</code> and add
    <code class="code">constexpr</code> to <code class="code">addressof</code> for C++17 and later.
    </p></dd><dt><a id="manual.bugs.dr2306"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2306" target="_top">2306</a>:
	<span class="emphasis"><em><code class="code">match_results::reference</code> should be <code class="code">value_type&amp;</code>, not <code class="code">const value_type&amp;</code></em></span>
    </span></dt><dd><p>Change typedef.
    </p></dd><dt><a id="manual.bugs.dr2313"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2313" target="_top">2313</a>:
	<span class="emphasis"><em><code class="code">tuple_size</code> should always derive from <code class="code">integral_constant&lt;size_t, N&gt;</code></em></span>
    </span></dt><dd><p>Update definitions of the partial specializations for const and volatile types.
    </p></dd><dt><a id="manual.bugs.dr2328"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2328" target="_top">2328</a>:
       <span class="emphasis"><em>Rvalue stream extraction should use perfect forwarding</em></span>
    </span></dt><dd><p>Use perfect forwarding for right operand.
    </p></dd><dt><a id="manual.bugs.dr2329"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2329" target="_top">2329</a>:
       <span class="emphasis"><em><code class="code">regex_match()/regex_search()</code> with <code class="code">match_results</code> should forbid temporary strings</em></span>
    </span></dt><dd><p>Add deleted overloads for rvalue strings.
    </p></dd><dt><a id="manual.bugs.dr2332"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2332" target="_top">2332</a>:
       <span class="emphasis"><em><code class="code">regex_iterator/regex_token_iterator</code> should forbid temporary regexes</em></span>
    </span></dt><dd><p>Add deleted constructors.
    </p></dd><dt><a id="manual.bugs.dr2354"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2354" target="_top">2332</a>:
       <span class="emphasis"><em>Unnecessary copying when inserting into maps with braced-init syntax</em></span>
    </span></dt><dd><p>Add overloads of <code class="code">insert</code> taking <code class="code">value_type&amp;&amp;</code> rvalues.
    </p></dd><dt><a id="manual.bugs.dr2399"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2399" target="_top">2399</a>:
	<span class="emphasis"><em><code class="code">shared_ptr</code>'s constructor from <code class="code">unique_ptr</code> should be constrained</em></span>
    </span></dt><dd><p>Constrain the constructor to require convertibility.
    </p></dd><dt><a id="manual.bugs.dr2400"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2400" target="_top">2400</a>:
	<span class="emphasis"><em><code class="code">shared_ptr</code>'s <code class="code">get_deleter()</code> should use <code class="code">addressof()</code></em></span>
    </span></dt><dd><p>Use <code class="code">addressof</code>.
    </p></dd><dt><a id="manual.bugs.dr2401"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2401" target="_top">2401</a>:
	<span class="emphasis"><em><code class="code">std::function</code> needs more <code class="code">noexcept</code></em></span>
    </span></dt><dd><p>Add <code class="code">noexcept</code> to the assignment and comparisons.
    </p></dd><dt><a id="manual.bugs.dr2407"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2407" target="_top">2407</a>:
       <span class="emphasis"><em><code class="code">packaged_task(allocator_arg_t, const Allocator&amp;, F&amp;&amp;)</code>
                 should neither be constrained nor <code class="code">explicit</code>
       </em></span>
    </span></dt><dd><p>Remove <code class="code">explicit</code> from the constructor.
    </p></dd><dt><a id="manual.bugs.dr2415"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2415" target="_top">2415</a>:
       <span class="emphasis"><em>Inconsistency between <code class="code">unique_ptr</code> and <code class="code">shared_ptr</code></em></span>
    </span></dt><dd><p>Create empty an <code class="code">shared_ptr</code> from an empty
                    <code class="code">unique_ptr</code>.
    </p></dd><dt><a id="manual.bugs.dr2418"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2418" target="_top">2418</a>:
       <span class="emphasis"><em><code class="code">apply</code> does not work with member pointers</em></span>
    </span></dt><dd><p>Use <code class="code">mem_fn</code> for member pointers.
    </p></dd><dt><a id="manual.bugs.dr2440"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2440" target="_top">2440</a>:
       <span class="emphasis"><em><code class="code">seed_seq::size()</code> should be <code class="code">noexcept</code></em></span>
    </span></dt><dd><p>Add <code class="code">noexcept</code>.
    </p></dd><dt><a id="manual.bugs.dr2441"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2441" target="_top">2441</a>:
       <span class="emphasis"><em>Exact-width atomic typedefs should be provided</em></span>
    </span></dt><dd><p>Define the typedefs.
    </p></dd><dt><a id="manual.bugs.dr2442"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2442" target="_top">2442</a>:
       <span class="emphasis"><em><code class="code">call_once()</code> shouldn't <code class="code">DECAY_COPY()</code></em></span>
    </span></dt><dd><p>Remove indirection through call wrapper that made copies
    of arguments and forward arguments straight to <code class="code">std::invoke</code>.
    </p></dd><dt><a id="manual.bugs.dr2454"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2454" target="_top">2454</a>:
       <span class="emphasis"><em>Add <code class="code">raw_storage_iterator::base()</code> member
       </em></span>
    </span></dt><dd><p>Add the <code class="code">base()</code> member function.
    </p></dd><dt><a id="manual.bugs.dr2455"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2455" target="_top">2455</a>:
       <span class="emphasis"><em>Allocator default construction should be allowed to throw
       </em></span>
    </span></dt><dd><p>Make <code class="code">noexcept</code> specifications conditional.
    </p></dd><dt><a id="manual.bugs.dr2458"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2458" target="_top">2458</a>:
       <span class="emphasis"><em>N3778 and new library deallocation signatures
       </em></span>
    </span></dt><dd><p>Remove unused overloads.
    </p></dd><dt><a id="manual.bugs.dr2459"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2459" target="_top">2459</a>:
       <span class="emphasis"><em><code class="code">std::polar</code> should require a non-negative rho
       </em></span>
    </span></dt><dd><p>Add debug mode assertion.
    </p></dd><dt><a id="manual.bugs.dr2466"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2466" target="_top">2466</a>:
       <span class="emphasis"><em><code class="code">allocator_traits::max_size()</code> default behavior is incorrect
       </em></span>
    </span></dt><dd><p>Divide by the object type.
    </p></dd><dt><a id="manual.bugs.dr2484"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2484" target="_top">2484</a>:
       <span class="emphasis"><em><code class="code">rethrow_if_nested()</code>  is doubly unimplementable
       </em></span>
    </span></dt><dd><p>Avoid using <code class="code">dynamic_cast</code> when it would be
    ill-formed.
    </p></dd><dt><a id="manual.bugs.dr2583"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2583" target="_top">2583</a>:
       <span class="emphasis"><em>There is no way to supply an allocator for <code class="code">basic_string(str, pos)</code>
       </em></span>
    </span></dt><dd><p>Add new constructor
    </p></dd><dt><a id="manual.bugs.dr2684"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2684" target="_top">2684</a>:
       <span class="emphasis"><em><code class="code">priority_queue</code> lacking comparator typedef
       </em></span>
    </span></dt><dd><p>Define the <code class="code">value_compare</code> typedef.
    </p></dd><dt><a id="manual.bugs.dr2770"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2770" target="_top">2770</a>:
       <span class="emphasis"><em><code class="code">tuple_size&lt;const T&gt;</code> specialization is not
	 SFINAE compatible and breaks decomposition declarations
       </em></span>
    </span></dt><dd><p>Safely detect <code class="code">tuple_size&lt;T&gt;::value</code> and
      only use it if valid.
    </p></dd><dt><a id="manual.bugs.dr2781"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2781" target="_top">2781</a>:
       <span class="emphasis"><em>Contradictory requirements for <code class="code">std::function</code>
         and <code class="code">std::reference_wrapper</code>
       </em></span>
    </span></dt><dd><p>Remove special handling for <code class="code">reference_wrapper</code>
      arguments and store them directly as the target object.
    </p></dd><dt><a id="manual.bugs.dr2802"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2802" target="_top">2802</a>:
       <span class="emphasis"><em>Add noexcept to several <code class="code">shared_ptr</code> related
         functions
       </em></span>
    </span></dt><dd><p>Add noexcept.
    </p></dd><dt><a id="manual.bugs.dr2873"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2873" target="_top">2873</a>:
       <span class="emphasis"><em><code class="code">shared_ptr</code> constructor requirements for a deleter
       </em></span>
    </span></dt><dd><p>Use rvalues for deleters.
    </p></dd><dt><a id="manual.bugs.dr2942"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2942" target="_top">2942</a>:
       <span class="emphasis"><em>LWG 2873's resolution missed
         <code class="code">weak_ptr::owner_before</code>
       </em></span>
    </span></dt><dd><p>Add noexcept.
    </p></dd><dt><a id="manual.bugs.dr2993"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2993" target="_top">2993</a>:
       <span class="emphasis"><em><code class="code">reference_wrapper&lt;T&gt;</code> conversion from <code class="code">T&amp;&amp;</code>
       </em></span>
    </span></dt><dd><p>Replaced the constructors with a constrained template,
      to prevent participation in overload resolution when not valid.
    </p></dd><dt><a id="manual.bugs.dr3074"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#3074" target="_top">3074</a>:
       <span class="emphasis"><em>Non-member functions for <code class="code">valarray</code> should only deduce from the <code class="code">valarray</code>
       </em></span>
    </span></dt><dd><p>Change scalar operands to be non-deduced context, so that
      they will allow conversions from other types to the value_type.
    </p></dd><dt><a id="manual.bugs.dr3076"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#3076" target="_top">3076</a>:
       <span class="emphasis"><em><code class="code">basic_string</code> CTAD ambiguity
       </em></span>
    </span></dt><dd><p>Change constructors to constrained templates.
    </p></dd></dl></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="license.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="status.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="setup.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">License </td><td width="20%" align="center"><a accesskey="h" href="../index.html">Home</a></td><td width="40%" align="right" valign="top"> Chapter 2. Setup</td></tr></table></div></body></html>