<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<!-- saved from url=(0060)http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>C++ Standard Library Defect Report List</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
</style>
</head>
<body>
<table>
<tbody><tr>
  <td align="left">Doc. no.</td>
  <td align="left">D3182=10-0172</td>
</tr>
<tr>
  <td align="left">Date:</td>
  <td align="left">2010-11-29</td>
</tr>
<tr>
  <td align="left">Project:</td>
  <td align="left">Programming Language C++</td>
</tr>
<tr>
  <td align="left">Reply to:</td>
  <td align="left">Alisdair Meredith &lt;<a href="mailto:lwgchair@gmail.com">lwgchair@gmail.com</a>&gt;</td>
</tr>
</tbody></table>
<h1>C++ Standard Library Defect Report List (Revision D73)</h1>
<p>Revised 2010-11-29 at 10:11:56 UTC</p>

  <p>Reference ISO/IEC IS 14882:2003(E)</p>
  <p>Also see:</p>
    <ul>
      <li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-toc.html">Table of Contents</a> for all library issues.</li>
      <li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html">Index by Section</a> for all library issues.</li>
      <li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html">Index by Status</a> for all library issues.</li>
      <li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html">Library Active Issues List</a></li>
      <li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html">Library Closed Issues List</a></li>
    </ul>
  <p>This document contains only library issues which have been closed
  by the Library Working Group (LWG) after being found to be defects
  in the standard.  That is, issues which have a status of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#DR">DR</a>,
  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC">TC</a>, or <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#RR">RR</a>. See the
  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html">Library Closed Issues List</a> for issues closed as non-defects.  See the
  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html">Library Active Issues List</a> for active issues and more information.  The
  introductory material in that document also applies to this
  document.</p>

<h2>Revision History</h2>
<ul>
<li>D73: Batavia meeting preview<ul>
<li><b>Summary:</b><ul>
<li>80 open issues, down by 126.</li>
<li>1459 closed issues, up by 145.</li>
<li>1539 issues total, up by 19.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following 11 New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1521">1521</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1523">1523</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#2008">2008</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#2012">2012</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#2013">2013</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#2014">2014</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#2015">2015</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#2016">2016</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#2017">2017</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#2018">2018</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#2019">2019</a>.</li>
<li>Added the following 5 Open issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#2001">2001</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#2003">2003</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#2005">2005</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#2010">2010</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#2011">2011</a>.</li>
<li>Added the following Resolved issue: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2002">2002</a>.</li>
<li>Added the following Review issue: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#2009">2009</a>.</li>
<li>Added the following Tentatively NAD issue: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#2006">2006</a>.</li>
<li>Added the following 3 Tentatively Ready issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#2000">2000</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#2004">2004</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#2007">2007</a>.</li>
<li>Added the following WP issue: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1522">1522</a>.</li>
<li>Changed the following 3 issues from New to Deferred: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1213">1213</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1214">1214</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1330">1330</a>.</li>
<li>Changed the following issue from Open to Deferred: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1450">1450</a>.</li>
<li>Changed the following 14 issues from Open to Dup: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1350">1350</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1351">1351</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1352">1352</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1375">1375</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1411">1411</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1443">1443</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1451">1451</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1454">1454</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1458">1458</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1463">1463</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1470">1470</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1475">1475</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1476">1476</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1477">1477</a>.</li>
<li>Changed the following issue from New to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1331">1331</a>.</li>
<li>Changed the following 8 issues from Open to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#579">579</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1359">1359</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1361">1361</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1373">1373</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1376">1376</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1398">1398</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1446">1446</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1473">1473</a>.</li>
<li>Changed the following 2 issues from Tentatively NAD to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1190">1190</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1200">1200</a>.</li>
<li>Changed the following issue from WP to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#822">822</a>.</li>
<li>Changed the following 11 issues from Open to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1395">1395</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1442">1442</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1471">1471</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1472">1472</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1489">1489</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1495">1495</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1496">1496</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1509">1509</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1510">1510</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1511">1511</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1512">1512</a>.</li>
<li>Changed the following issue from Review to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1281">1281</a>.</li>
<li>Changed the following issue from New to NAD Future: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1289">1289</a>.</li>
<li>Changed the following 6 issues from Open to NAD Future: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1406">1406</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1422">1422</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1484">1484</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1488">1488</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1493">1493</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1499">1499</a>.</li>
<li>Changed the following 2 issues from Tentatively NAD Future to NAD Future: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1173">1173</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1188">1188</a>.</li>
<li>Changed the following 2 issues from New to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1252">1252</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1297">1297</a>.</li>
<li>Changed the following 3 issues from New to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1279">1279</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1318">1318</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1332">1332</a>.</li>
<li>Changed the following 6 issues from Open to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1385">1385</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1401">1401</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1408">1408</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1418">1418</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1420">1420</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1438">1438</a>.</li>
<li>Changed the following 42 issues from NAD Editorial to Resolved: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#353">353</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#431">431</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#482">482</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#525">525</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#594">594</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#625">625</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#635">635</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#658">658</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#697">697</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#719">719</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#742">742</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#786">786</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#815">815</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#816">816</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#823">823</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#827">827</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#834">834</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#884">884</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#932">932</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#947">947</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#950">950</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#953">953</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#983">983</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1054">1054</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1055">1055</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1075">1075</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1100">1100</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1116">1116</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1117">1117</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1122">1122</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1135">1135</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1151">1151</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1174">1174</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1258">1258</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1260">1260</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1283">1283</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1293">1293</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1307">1307</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1321">1321</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1394">1394</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1405">1405</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1407">1407</a>.</li>
<li>Changed the following 5 issues from New to Resolved: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1290">1290</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1322">1322</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1324">1324</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1326">1326</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1328">1328</a>.</li>
<li>Changed the following 46 issues from Open to Resolved: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#801">801</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1268">1268</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1327">1327</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1344">1344</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1346">1346</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1347">1347</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1355">1355</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1356">1356</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1357">1357</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1365">1365</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1366">1366</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1377">1377</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1378">1378</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1379">1379</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1380">1380</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1382">1382</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1383">1383</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1389">1389</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1390">1390</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1391">1391</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1392">1392</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1393">1393</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1397">1397</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1409">1409</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1410">1410</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1412">1412</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1445">1445</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1447">1447</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1453">1453</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1455">1455</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1462">1462</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1464">1464</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1465">1465</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1466">1466</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1467">1467</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1468">1468</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1469">1469</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1481">1481</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1482">1482</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1490">1490</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1491">1491</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1492">1492</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1498">1498</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1501">1501</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1508">1508</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1513">1513</a>.</li>
<li>Changed the following issue from Open to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1480">1480</a>.</li>
<li>Changed the following 2 issues from Open to Tentatively NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1371">1371</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1413">1413</a>.</li>
<li>Changed the following issue from New to Tentatively NAD Future: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1320">1320</a>.</li>
<li>Changed the following 3 issues from New to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1215">1215</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1253">1253</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1310">1310</a>.</li>
<li>Changed the following issue from Open to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1497">1497</a>.</li>
<li>Changed the following 24 issues from NAD Editorial to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1360">1360</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1363">1363</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1367">1367</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1372">1372</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1381">1381</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1384">1384</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1386">1386</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1387">1387</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1388">1388</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1399">1399</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1400">1400</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1402">1402</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1403">1403</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1416">1416</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1417">1417</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1423">1423</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1424">1424</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1425">1425</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1426">1426</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1427">1427</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1429">1429</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1430">1430</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1431">1431</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1441">1441</a>.</li>
<li>Changed the following issue from New to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1294">1294</a>.</li>
<li>Changed the following 10 issues from Open to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1354">1354</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1362">1362</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1368">1368</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1370">1370</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1428">1428</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1435">1435</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1436">1436</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1437">1437</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1439">1439</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1440">1440</a>.</li>
<li>Changed the following 2 issues from Ready to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#868">868</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#951">951</a>.</li>
<li>Changed the following 33 issues from Tentatively Ready to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#956">956</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1118">1118</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1171">1171</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1181">1181</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1183">1183</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1191">1191</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1198">1198</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1207">1207</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1234">1234</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1240">1240</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1249">1249</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1292">1292</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1295">1295</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1316">1316</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1319">1319</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1323">1323</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1325">1325</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1333">1333</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1334">1334</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1335">1335</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1337">1337</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1338">1338</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1339">1339</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1340">1340</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1404">1404</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1414">1414</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1432">1432</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1449">1449</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1516">1516</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1517">1517</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1518">1518</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1519">1519</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1520">1520</a>.</li>
</ul></li>
</ul>
</li>
<li>R72: 
2010-10-18 pre-Batavia mailing.
<ul>
<li><b>Summary:</b><ul>
<li>206 open issues, up by 141.</li>
<li>1314 closed issues, up by 36.</li>
<li>1520 issues total, up by 177.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following Dup issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1433">1433</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1444">1444</a>.</li>
<li>Added the following NAD Editorial issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1360">1360</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1363">1363</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1367">1367</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1372">1372</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1381">1381</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1384">1384</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1386">1386</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1387">1387</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1388">1388</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1394">1394</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1399">1399</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1400">1400</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1402">1402</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1403">1403</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1405">1405</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1407">1407</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1415">1415</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1416">1416</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1417">1417</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1419">1419</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1423">1423</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1424">1424</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1425">1425</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1426">1426</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1427">1427</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1429">1429</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1430">1430</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1431">1431</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1434">1434</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1441">1441</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1483">1483</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1500">1500</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1506">1506</a>.</li>
<li>Added the following Open issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1344">1344</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1345">1345</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1346">1346</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1347">1347</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1348">1348</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1349">1349</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1350">1350</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1351">1351</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1352">1352</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1353">1353</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1354">1354</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1355">1355</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1356">1356</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1357">1357</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1358">1358</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1359">1359</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1361">1361</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1362">1362</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1364">1364</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1365">1365</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1366">1366</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1368">1368</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1369">1369</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1370">1370</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1371">1371</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1373">1373</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1374">1374</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1375">1375</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1376">1376</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1377">1377</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1378">1378</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1379">1379</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1380">1380</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1382">1382</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1383">1383</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1385">1385</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1389">1389</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1390">1390</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1391">1391</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1392">1392</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1393">1393</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1395">1395</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1396">1396</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1397">1397</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1398">1398</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1401">1401</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1406">1406</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1408">1408</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1409">1409</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1410">1410</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1411">1411</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1412">1412</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1413">1413</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1418">1418</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1420">1420</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1421">1421</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1422">1422</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1428">1428</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1435">1435</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1436">1436</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1437">1437</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1438">1438</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1439">1439</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1440">1440</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1442">1442</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1443">1443</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1445">1445</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1446">1446</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1447">1447</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1448">1448</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1450">1450</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1451">1451</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1452">1452</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1453">1453</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1454">1454</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1455">1455</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1456">1456</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1457">1457</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1458">1458</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1459">1459</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1460">1460</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1461">1461</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1462">1462</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1463">1463</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1464">1464</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1465">1465</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1466">1466</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1467">1467</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1468">1468</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1469">1469</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1470">1470</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1471">1471</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1472">1472</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1473">1473</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1474">1474</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1475">1475</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1476">1476</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1477">1477</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1478">1478</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1479">1479</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1480">1480</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1481">1481</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1482">1482</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1484">1484</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1485">1485</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1486">1486</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1487">1487</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1488">1488</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1489">1489</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1490">1490</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1491">1491</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1492">1492</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1493">1493</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1494">1494</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1495">1495</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1496">1496</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1497">1497</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1498">1498</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1499">1499</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1501">1501</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1502">1502</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1503">1503</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1504">1504</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1505">1505</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1507">1507</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1508">1508</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1509">1509</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1510">1510</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1511">1511</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1512">1512</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1513">1513</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1514">1514</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1515">1515</a>.</li>
<li>Added the following Tentatively Ready issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1404">1404</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1414">1414</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1432">1432</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1449">1449</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1516">1516</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1517">1517</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1518">1518</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1519">1519</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1520">1520</a>.</li>
<li>Changed the following issues from New to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1260">1260</a>.</li>
<li>Changed the following issues from New to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1181">1181</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1240">1240</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1249">1249</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1292">1292</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1295">1295</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1316">1316</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1319">1319</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1323">1323</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1325">1325</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1333">1333</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1334">1334</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1335">1335</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1337">1337</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1338">1338</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1339">1339</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1340">1340</a>.</li>
<li>Changed the following issues from Open to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#956">956</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1118">1118</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1183">1183</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1234">1234</a>.</li>
</ul></li>
</ul>
</li>
<li>R71: 
2010-08-25 post-Rapperswil mailing.
<ul>
<li><b>Summary:</b><ul>
<li>65 open issues, up by 2.</li>
<li>1278 closed issues, up by 7.</li>
<li>1343 issues total, up by 9.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1335">1335</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#2008">2008</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1337">1337</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1338">1338</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1339">1339</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1340">1340</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#2009">2009</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#2010">2010</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#2011">2011</a>.</li>
<li>Changed the following issues from Open to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#996">996</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1119">1119</a>.</li>
<li>Changed the following issues from Open to NAD Concepts: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1076">1076</a>.</li>
<li>Changed the following issues from Open to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#953">953</a>.</li>
<li>Changed the following issues from New to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1169">1169</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1175">1175</a>.</li>
<li>Changed the following issues from Open to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#951">951</a>.</li>
<li>Changed the following issues from Review to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#868">868</a>.</li>
<li>Changed the following issues from New to Tentatively NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1190">1190</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1200">1200</a>.</li>
<li>Changed the following issues from New to Tentatively NAD Future: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1188">1188</a>.</li>
<li>Changed the following issues from Open to Tentatively NAD Future: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1173">1173</a>.</li>
<li>Changed the following issues from New to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1198">1198</a>.</li>
<li>Changed the following issues from Open to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1171">1171</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1191">1191</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1207">1207</a>.</li>
<li>Changed the following issues from Ready to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1187">1187</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1206">1206</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1278">1278</a>.</li>
</ul></li>
</ul>
</li>
<li>R70: 
2010-03-26 post-Pittsburgh mailing.
<ul>
<li><b>Summary:</b><ul>
<li>63 open issues, down by 203.</li>
<li>1271 closed issues, up by 219.</li>
<li>1334 issues total, up by 16.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following NAD Editorial issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1321">1321</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1329">1329</a>.</li>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1319">1319</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1320">1320</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1322">1322</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1323">1323</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1324">1324</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1325">1325</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1326">1326</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1328">1328</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1330">1330</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1331">1331</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1332">1332</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1333">1333</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1334">1334</a>.</li>
<li>Added the following Open issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1327">1327</a>.</li>
<li>Changed the following issues from Tentatively Dup to Dup: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1219">1219</a>.</li>
<li>Changed the following issues from New to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1302">1302</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1308">1308</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1313">1313</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1314">1314</a>.</li>
<li>Changed the following issues from Open to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#887">887</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1008">1008</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1068">1068</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1069">1069</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1153">1153</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1156">1156</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1228">1228</a>.</li>
<li>Changed the following issues from Tentatively NAD to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#631">631</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#726">726</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#959">959</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1056">1056</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1099">1099</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1125">1125</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1176">1176</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1202">1202</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1223">1223</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1224">1224</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1246">1246</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1251">1251</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1259">1259</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1263">1263</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1265">1265</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1296">1296</a>.</li>
<li>Changed the following issues from Tentatively NAD Concepts to NAD Concepts: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#910">910</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1186">1186</a>.</li>
<li>Changed the following issues from New to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1185">1185</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1210">1210</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1212">1212</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1225">1225</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1244">1244</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1266">1266</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1269">1269</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1272">1272</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1275">1275</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1291">1291</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1305">1305</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1307">1307</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1311">1311</a>.</li>
<li>Changed the following issues from Open to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#299">299</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#397">397</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#408">408</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#446">446</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#594">594</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#625">625</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#742">742</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#834">834</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#915">915</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1093">1093</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1151">1151</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1211">1211</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1248">1248</a>.</li>
<li>Changed the following issues from Ready to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#485">485</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#932">932</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#940">940</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#950">950</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#983">983</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1100">1100</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1135">1135</a>.</li>
<li>Changed the following issues from Tentatively NAD Editorial to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#815">815</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#816">816</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#889">889</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1106">1106</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1115">1115</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1233">1233</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1239">1239</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1258">1258</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1283">1283</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1301">1301</a>.</li>
<li>Changed the following issues from Tentatively Ready to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1090">1090</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1226">1226</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1273">1273</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1274">1274</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1293">1293</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1300">1300</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1304">1304</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1315">1315</a>.</li>
<li>Changed the following issues from New to NAD Future: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1154">1154</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1317">1317</a>.</li>
<li>Changed the following issues from Ready to NAD Future: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1052">1052</a>.</li>
<li>Changed the following issues from Tentatively NAD Future to NAD Future: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1112">1112</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1121">1121</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1201">1201</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1238">1238</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1282">1282</a>.</li>
<li>Changed the following issues from New to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1234">1234</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1268">1268</a>.</li>
<li>Changed the following issues from Tentatively Ready to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#579">579</a>.</li>
<li>Changed the following issues from New to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1187">1187</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1206">1206</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1278">1278</a>.</li>
<li>Changed the following issues from New to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1281">1281</a>.</li>
<li>Changed the following issues from Ready to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#868">868</a>.</li>
<li>Changed the following issues from New to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1159">1159</a>.</li>
<li>Changed the following issues from Open to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#427">427</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#430">430</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#774">774</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#819">819</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#835">835</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#861">861</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#885">885</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#896">896</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#900">900</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#911">911</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1079">1079</a>.</li>
<li>Changed the following issues from Ready to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#296">296</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#471">471</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#473">473</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#539">539</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#671">671</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#836">836</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#854">854</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#860">860</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#865">865</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#871">871</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#872">872</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#920">920</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#921">921</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#939">939</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#954">954</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#957">957</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#960">960</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#962">962</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#963">963</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#967">967</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#968">968</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#974">974</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1011">1011</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1030">1030</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1094">1094</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1095">1095</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1097">1097</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1098">1098</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1104">1104</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1123">1123</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1134">1134</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1136">1136</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1144">1144</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1157">1157</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1194">1194</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1204">1204</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1216">1216</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1227">1227</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1237">1237</a>.</li>
<li>Changed the following issues from Tentatively Ready to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#556">556</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#676">676</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#704">704</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#724">724</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#727">727</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#780">780</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#811">811</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#817">817</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#870">870</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#891">891</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#893">893</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#929">929</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#978">978</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#987">987</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#999">999</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1033">1033</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1034">1034</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1071">1071</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1089">1089</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1108">1108</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1110">1110</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1113">1113</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1114">1114</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1126">1126</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1130">1130</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1131">1131</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1133">1133</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1137">1137</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1138">1138</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1152">1152</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1158">1158</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1170">1170</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1177">1177</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1180">1180</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1182">1182</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1189">1189</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1192">1192</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1193">1193</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1195">1195</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1197">1197</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1199">1199</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1205">1205</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1208">1208</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1209">1209</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1218">1218</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1220">1220</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1221">1221</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1222">1222</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1231">1231</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1241">1241</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1245">1245</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1247">1247</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1250">1250</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1254">1254</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1255">1255</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1256">1256</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1257">1257</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1261">1261</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1262">1262</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1264">1264</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1267">1267</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1270">1270</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1271">1271</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1276">1276</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1277">1277</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1280">1280</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1284">1284</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1285">1285</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1286">1286</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1287">1287</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1288">1288</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1298">1298</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1299">1299</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1303">1303</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1306">1306</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1309">1309</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1312">1312</a>.</li>
</ul></li>
</ul>
</li>
<li>R69: 
2010-02-12 pre-Pittsburgh mailing.
<ul>
<li><b>Summary:</b><ul>
<li>266 open issues, up by 61.</li>
<li>1052 closed issues, down by 3.</li>
<li>1318 issues total, up by 58.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1266">1266</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1268">1268</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1269">1269</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1272">1272</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1275">1275</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1278">1278</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1279">1279</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1281">1281</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1289">1289</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1290">1290</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1291">1291</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1292">1292</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1294">1294</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1295">1295</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1297">1297</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1302">1302</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1305">1305</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1307">1307</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1308">1308</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1310">1310</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1311">1311</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1313">1313</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1314">1314</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1316">1316</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1317">1317</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1318">1318</a>.</li>
<li>Added the following Tentatively NAD issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1263">1263</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1265">1265</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1296">1296</a>.</li>
<li>Added the following Tentatively NAD Editorial issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1283">1283</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1301">1301</a>.</li>
<li>Added the following Tentatively NAD Future issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1282">1282</a>.</li>
<li>Added the following Tentatively Ready issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1261">1261</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1262">1262</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1264">1264</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1267">1267</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1270">1270</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1271">1271</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1273">1273</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1274">1274</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1276">1276</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1277">1277</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1280">1280</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1284">1284</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1285">1285</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1286">1286</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1287">1287</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1288">1288</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1293">1293</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1298">1298</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1299">1299</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1300">1300</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1303">1303</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1304">1304</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1306">1306</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1309">1309</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1312">1312</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1315">1315</a>.</li>
<li>Changed the following issues from NAD to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#101">101</a>.</li>
<li>Changed the following issues from NAD Future to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1248">1248</a>.</li>
<li>Changed the following issues from New to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1207">1207</a>.</li>
<li>Changed the following issues from Ready to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1079">1079</a>.</li>
<li>Changed the following issues from New to Tentatively Dup: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1219">1219</a>.</li>
<li>Changed the following issues from New to Tentatively NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1125">1125</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1176">1176</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1202">1202</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1223">1223</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1224">1224</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1246">1246</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1251">1251</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1259">1259</a>.</li>
<li>Changed the following issues from Open to Tentatively NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#726">726</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#959">959</a>.</li>
<li>Changed the following issues from Review to Tentatively NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#631">631</a>.</li>
<li>Changed the following issues from Open to Tentatively NAD Concepts: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#910">910</a>.</li>
<li>Changed the following issues from New to Tentatively NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1258">1258</a>.</li>
<li>Changed the following issues from Open to Tentatively NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#815">815</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1106">1106</a>.</li>
<li>Changed the following issues from Ready to Tentatively NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#816">816</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#889">889</a>.</li>
<li>Changed the following issues from NAD to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#579">579</a>.</li>
<li>Changed the following issues from NAD Editorial to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1195">1195</a>.</li>
<li>Changed the following issues from New to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1131">1131</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1133">1133</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1137">1137</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1170">1170</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1180">1180</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1182">1182</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1193">1193</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1197">1197</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1199">1199</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1205">1205</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1209">1209</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1218">1218</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1221">1221</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1222">1222</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1245">1245</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1250">1250</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1254">1254</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1255">1255</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1256">1256</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1257">1257</a>.</li>
<li>Changed the following issues from Open to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#704">704</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#724">724</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#811">811</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#817">817</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#870">870</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#891">891</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1033">1033</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1034">1034</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1089">1089</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1110">1110</a>.</li>
<li>Changed the following issues from Ready to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#893">893</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#978">978</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1177">1177</a>.</li>
<li>Changed the following issues from Review to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#556">556</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#676">676</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#727">727</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#780">780</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#929">929</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1130">1130</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1247">1247</a>.</li>
<li>Changed the following issues from Pending WP to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#970">970</a>.</li>
</ul></li>
</ul>
</li>
<li>R68: 
2009-11-06 post-Santa Cruz mailing.
<ul>
<li><b>Summary:</b><ul>
<li>205 open issues, down by 77.</li>
<li>1055 closed issues, up by 120.</li>
<li>1260 issues total, up by 43.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following Dup issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1230">1230</a>.</li>
<li>Added the following NAD issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1229">1229</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1236">1236</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1243">1243</a>.</li>
<li>Added the following NAD Editorial issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1232">1232</a>.</li>
<li>Added the following NAD Future issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1235">1235</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1242">1242</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1248">1248</a>.</li>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1218">1218</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1219">1219</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1221">1221</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1222">1222</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1223">1223</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1224">1224</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1225">1225</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1234">1234</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1240">1240</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1244">1244</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1245">1245</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1246">1246</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1249">1249</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1250">1250</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1251">1251</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1252">1252</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1253">1253</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1254">1254</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1255">1255</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1256">1256</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1257">1257</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1258">1258</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1259">1259</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1260">1260</a>.</li>
<li>Added the following Open issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1228">1228</a>.</li>
<li>Added the following Ready issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1227">1227</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1237">1237</a>.</li>
<li>Added the following Review issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1247">1247</a>.</li>
<li>Added the following Tentatively NAD Editorial issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1233">1233</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1239">1239</a>.</li>
<li>Added the following Tentatively NAD Future issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1238">1238</a>.</li>
<li>Added the following Tentatively Ready issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1220">1220</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1226">1226</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1231">1231</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1241">1241</a>.</li>
<li>Changed the following issues from New to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1132">1132</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1148">1148</a>.</li>
<li>Changed the following issues from Open to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#96">96</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#458">458</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#463">463</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#916">916</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#917">917</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#919">919</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#955">955</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#977">977</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1009">1009</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1020">1020</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1035">1035</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1042">1042</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1051">1051</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1064">1064</a>.</li>
<li>Changed the following issues from Review to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#668">668</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#930">930</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1091">1091</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1102">1102</a>.</li>
<li>Changed the following issues from Tentatively NAD to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#588">588</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#617">617</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#971">971</a>.</li>
<li>Changed the following issues from Tentatively NAD Future to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1062">1062</a>.</li>
<li>Changed the following issues from NAD Concepts to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1143">1143</a>.</li>
<li>Changed the following issues from New to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1116">1116</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1117">1117</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1122">1122</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1129">1129</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1145">1145</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1146">1146</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1147">1147</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1155">1155</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1166">1166</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1172">1172</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1174">1174</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1179">1179</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1195">1195</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1196">1196</a>.</li>
<li>Changed the following issues from Open to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#431">431</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#580">580</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#635">635</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#719">719</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#823">823</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#827">827</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#879">879</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#880">880</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#908">908</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#923">923</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#924">924</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#926">926</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#944">944</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#947">947</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#958">958</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1046">1046</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1048">1048</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1054">1054</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1055">1055</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1075">1075</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1088">1088</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1160">1160</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1161">1161</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1162">1162</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1163">1163</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1165">1165</a>.</li>
<li>Changed the following issues from Review to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#828">828</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#897">897</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#976">976</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1043">1043</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1047">1047</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1049">1049</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1050">1050</a>.</li>
<li>Changed the following issues from New to NAD Future: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1120">1120</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1150">1150</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1184">1184</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1203">1203</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1217">1217</a>.</li>
<li>Changed the following issues from Open to NAD Future: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#484">484</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#532">532</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#851">851</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#933">933</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#935">935</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#936">936</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#961">961</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1041">1041</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1053">1053</a>.</li>
<li>Changed the following issues from Tentatively NAD Future to NAD Future: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1031">1031</a>.</li>
<li>Changed the following issues from New to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1118">1118</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1119">1119</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1151">1151</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1153">1153</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1156">1156</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1171">1171</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1173">1173</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1183">1183</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1191">1191</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1211">1211</a>.</li>
<li>Changed the following issues from Ready to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#430">430</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#834">834</a>.</li>
<li>Changed the following issues from Review to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#397">397</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#408">408</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#835">835</a>.</li>
<li>Changed the following issues from Tentatively NAD to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#625">625</a>.</li>
<li>Changed the following issues from New to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1123">1123</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1134">1134</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1135">1135</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1136">1136</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1144">1144</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1177">1177</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1194">1194</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1204">1204</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1216">1216</a>.</li>
<li>Changed the following issues from Open to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#296">296</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#471">471</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#485">485</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#539">539</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#816">816</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#860">860</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#865">865</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#872">872</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#920">920</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#932">932</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#939">939</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#940">940</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#960">960</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#963">963</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#974">974</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#978">978</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1011">1011</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1030">1030</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1079">1079</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1098">1098</a>.</li>
<li>Changed the following issues from Review to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#473">473</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#671">671</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#836">836</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#854">854</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#868">868</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#871">871</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#889">889</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#893">893</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#921">921</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#950">950</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#954">954</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#957">957</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#962">962</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#967">967</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#968">968</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#983">983</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1052">1052</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1094">1094</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1095">1095</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1097">1097</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1100">1100</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1104">1104</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1157">1157</a>.</li>
<li>Changed the following issues from New to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1130">1130</a>.</li>
<li>Changed the following issues from Open to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#556">556</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#631">631</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#676">676</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#727">727</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#929">929</a>.</li>
<li>Changed the following issues from Open to Tentatively NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1056">1056</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1099">1099</a>.</li>
<li>Changed the following issues from New to Tentatively NAD Concepts: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1186">1186</a>.</li>
<li>Changed the following issues from New to Tentatively NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1115">1115</a>.</li>
<li>Changed the following issues from New to Tentatively NAD Future: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1121">1121</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1201">1201</a>.</li>
<li>Changed the following issues from Open to Tentatively NAD Future: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1112">1112</a>.</li>
<li>Changed the following issues from New to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1126">1126</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1138">1138</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1152">1152</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1158">1158</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1189">1189</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1192">1192</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1208">1208</a>.</li>
<li>Changed the following issues from Open to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#987">987</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#999">999</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1071">1071</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1090">1090</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1108">1108</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1113">1113</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1114">1114</a>.</li>
<li>Changed the following issues from Ready to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#149">149</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#419">419</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#498">498</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#564">564</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#565">565</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#630">630</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#659">659</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#696">696</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#711">711</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#716">716</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#723">723</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#788">788</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#822">822</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#838">838</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#847">847</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#857">857</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#859">859</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#876">876</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#881">881</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#883">883</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#886">886</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#934">934</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1004">1004</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1178">1178</a>.</li>
<li>Changed the following issues from Tentatively Ready to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1012">1012</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1019">1019</a>.</li>
</ul></li>
</ul>
</li>
<li>R67: 
2009-09-25 pre-Santa Cruz mailing.
<ul>
<li><b>Summary:</b><ul>
<li>282 open issues, up by 32.</li>
<li>935 closed issues, down by 1.</li>
<li>1217 issues total, up by 31.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1187">1187</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1188">1188</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1189">1189</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1190">1190</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1191">1191</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1192">1192</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1193">1193</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1194">1194</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1195">1195</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1196">1196</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1197">1197</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1198">1198</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1199">1199</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1200">1200</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1201">1201</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1202">1202</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1203">1203</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1204">1204</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1205">1205</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1206">1206</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1207">1207</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1208">1208</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1209">1209</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1210">1210</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1211">1211</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1212">1212</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1213">1213</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1214">1214</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1215">1215</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1216">1216</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1217">1217</a>.</li>
<li>Changed the following issues from NAD to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#296">296</a>.</li>
<li>Changed the following issues from WP to Pending WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#970">970</a>.</li>
<li>Changed the following issues from Open to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#976">976</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1052">1052</a>.</li>
<li>Changed the following issues from Ready to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#780">780</a>.</li>
</ul></li>
</ul>
</li>
<li>R66: 
2009-07-31 post-Frankfurt mailing.
<ul>
<li><b>Summary:</b><ul>
<li>250 open issues, down by 128.</li>
<li>936 closed issues, up by 171.</li>
<li>1186 issues total, up by 43.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following NAD issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1164">1164</a>.</li>
<li>Added the following NAD Concepts issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1149">1149</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1167">1167</a>.</li>
<li>Added the following NAD Editorial issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1168">1168</a>.</li>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1144">1144</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1145">1145</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1146">1146</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1147">1147</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1148">1148</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1150">1150</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1151">1151</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1152">1152</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1153">1153</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1154">1154</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1155">1155</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1156">1156</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1158">1158</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1159">1159</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1166">1166</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1169">1169</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1170">1170</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1171">1171</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1172">1172</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1173">1173</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1174">1174</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1175">1175</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1176">1176</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1177">1177</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1179">1179</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1180">1180</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1181">1181</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1182">1182</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1183">1183</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1184">1184</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1185">1185</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1186">1186</a>.</li>
<li>Added the following Open issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1160">1160</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1161">1161</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1162">1162</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1163">1163</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1165">1165</a>.</li>
<li>Added the following Ready issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1178">1178</a>.</li>
<li>Added the following Review issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1157">1157</a>.</li>
<li>Changed the following issues from Open to Dup: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#750">750</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#895">895</a>.</li>
<li>Changed the following issues from Open to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#111">111</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#128">128</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#138">138</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#190">190</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#219">219</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#290">290</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#309">309</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#342">342</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#343">343</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#382">382</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#394">394</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#398">398</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#417">417</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#418">418</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#421">421</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#459">459</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#466">466</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#492">492</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#502">502</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#503">503</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#546">546</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#573">573</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#582">582</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#585">585</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#597">597</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#606">606</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#614">614</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#632">632</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#721">721</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#747">747</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#751">751</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#833">833</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#941">941</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#992">992</a>.</li>
<li>Changed the following issues from Review to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1003">1003</a>.</li>
<li>Changed the following issues from Tentatively NAD to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#568">568</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#644">644</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#667">667</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#669">669</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#701">701</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#702">702</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#785">785</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#863">863</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#901">901</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#903">903</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#946">946</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#988">988</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#995">995</a>.</li>
<li>Changed the following issues from Tentatively Ready to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1002">1002</a>.</li>
<li>Changed the following issues from New to NAD Concepts: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1124">1124</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1127">1127</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1128">1128</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1139">1139</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1140">1140</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1141">1141</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1142">1142</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1143">1143</a>.</li>
<li>Changed the following issues from Open to NAD Concepts: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#902">902</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#989">989</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1000">1000</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1007">1007</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1010">1010</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1015">1015</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1016">1016</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1017">1017</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1018">1018</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1026">1026</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1027">1027</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1028">1028</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1029">1029</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1032">1032</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1036">1036</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1057">1057</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1059">1059</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1072">1072</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1078">1078</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1081">1081</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1082">1082</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1083">1083</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1084">1084</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1085">1085</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1086">1086</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1092">1092</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1096">1096</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1105">1105</a>.</li>
<li>Changed the following issues from Review to NAD Concepts: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1001">1001</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1005">1005</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1080">1080</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1087">1087</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1111">1111</a>.</li>
<li>Changed the following issues from Tentatively NAD to NAD Concepts: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#912">912</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#918">918</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1074">1074</a>.</li>
<li>Changed the following issues from Tentatively NAD Editorial to NAD Concepts: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#927">927</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1109">1109</a>.</li>
<li>Changed the following issues from Tentatively Ready to NAD Concepts: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#906">906</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#913">913</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#914">914</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#928">928</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1024">1024</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1063">1063</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1067">1067</a>.</li>
<li>Changed the following issues from Open to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#718">718</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#873">873</a>.</li>
<li>Changed the following issues from Tentatively NAD Editorial to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#424">424</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#825">825</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#830">830</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#837">837</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#862">862</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#867">867</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#884">884</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#945">945</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#952">952</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#969">969</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#972">972</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#973">973</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#979">979</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1023">1023</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1058">1058</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1060">1060</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1061">1061</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1077">1077</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1101">1101</a>.</li>
<li>Changed the following issues from Tentatively Ready to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1013">1013</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1107">1107</a>.</li>
<li>Changed the following issues from Open to NAD Future: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#255">255</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#423">423</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#523">523</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#708">708</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#760">760</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#839">839</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#877">877</a>.</li>
<li>Changed the following issues from CD1 to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#823">823</a>.</li>
<li>Changed the following issues from NAD Editorial to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#299">299</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#484">484</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#532">532</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#556">556</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#594">594</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#631">631</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#676">676</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#704">704</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#724">724</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#742">742</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#811">811</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#870">870</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#872">872</a>.</li>
<li>Changed the following issues from Review to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#879">879</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#919">919</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#929">929</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#939">939</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#987">987</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1009">1009</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1093">1093</a>.</li>
<li>Changed the following issues from Tentatively NAD to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#458">458</a>.</li>
<li>Changed the following issues from Tentatively NAD Future to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#96">96</a>.</li>
<li>Changed the following issues from Tentatively Ready to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#910">910</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#915">915</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#932">932</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#940">940</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#974">974</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#976">976</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#999">999</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1011">1011</a>.</li>
<li>Changed the following issues from Open to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#149">149</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#419">419</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#430">430</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#498">498</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#564">564</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#565">565</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#630">630</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#659">659</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#696">696</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#711">711</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#716">716</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#723">723</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#788">788</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#834">834</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#838">838</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#847">847</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#857">857</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#859">859</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#876">876</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#881">881</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#883">883</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#886">886</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1004">1004</a>.</li>
<li>Changed the following issues from Review to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#780">780</a>.</li>
<li>Changed the following issues from Tentatively NAD to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#822">822</a>.</li>
<li>Changed the following issues from Tentatively Ready to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#934">934</a>.</li>
<li>Changed the following issues from NAD to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#871">871</a>.</li>
<li>Changed the following issues from Open to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#397">397</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#408">408</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#473">473</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#671">671</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#836">836</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#868">868</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#889">889</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#893">893</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#930">930</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#954">954</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#962">962</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#967">967</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#968">968</a>.</li>
<li>Changed the following issues from Tentatively NAD to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#668">668</a>.</li>
<li>Changed the following issues from Tentatively Ready to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#950">950</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1100">1100</a>.</li>
<li>Changed the following issues from Open to Tentatively NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#588">588</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#617">617</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#625">625</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#971">971</a>.</li>
<li>Changed the following issues from Open to Tentatively NAD Future: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1031">1031</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1062">1062</a>.</li>
<li>Changed the following issues from Open to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1012">1012</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1019">1019</a>.</li>
<li>Changed the following issues from Tentatively Ready to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#688">688</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#765">765</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#810">810</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#814">814</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#853">853</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#869">869</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#878">878</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#888">888</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#890">890</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#898">898</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#899">899</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#904">904</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#907">907</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#909">909</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#922">922</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#925">925</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#931">931</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#938">938</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#943">943</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#948">948</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#949">949</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#965">965</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#970">970</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#975">975</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#981">981</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#982">982</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#984">984</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#986">986</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#990">990</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#991">991</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#993">993</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#994">994</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#997">997</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#998">998</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1006">1006</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1014">1014</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1021">1021</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1037">1037</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1038">1038</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1039">1039</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1040">1040</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1044">1044</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1045">1045</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1065">1065</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1066">1066</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1070">1070</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1073">1073</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1103">1103</a>.</li>
</ul></li>
</ul>
</li>
<li>R65: 
2009-06-19 pre-Frankfurt mailing.
<ul>
<li><b>Summary:</b><ul>
<li>378 open issues, up by 32.</li>
<li>765 closed issues, up by 0.</li>
<li>1143 issues total, up by 32.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1115">1115</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1116">1116</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1117">1117</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1118">1118</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1119">1119</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1120">1120</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1121">1121</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1122">1122</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1123">1123</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1124">1124</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1125">1125</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1126">1126</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1127">1127</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1128">1128</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1129">1129</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1130">1130</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1131">1131</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1132">1132</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1133">1133</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1134">1134</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1135">1135</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1136">1136</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1137">1137</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1138">1138</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1139">1139</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1140">1140</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1141">1141</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1142">1142</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1143">1143</a>.</li>
<li>Added the following Open issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1112">1112</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1113">1113</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1114">1114</a>.</li>
<li>Changed the following issues from Pending NAD Editorial to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#937">937</a>.</li>
<li>Changed the following issues from New to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#696">696</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#716">716</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#727">727</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#865">865</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#900">900</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#911">911</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#916">916</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#917">917</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#920">920</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#933">933</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#935">935</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#941">941</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#947">947</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#951">951</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#953">953</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#954">954</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#955">955</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#956">956</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#977">977</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#978">978</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#985">985</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#989">989</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#996">996</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1033">1033</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1054">1054</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1056">1056</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1057">1057</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1059">1059</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1062">1062</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1068">1068</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1069">1069</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1071">1071</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1072">1072</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1076">1076</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1090">1090</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1092">1092</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1096">1096</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1098">1098</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1099">1099</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1105">1105</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1106">1106</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1108">1108</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1110">1110</a>.</li>
<li>Changed the following issues from Review to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#817">817</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#971">971</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#992">992</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1004">1004</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1010">1010</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1012">1012</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1015">1015</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1019">1019</a>.</li>
<li>Changed the following issues from New to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#780">780</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#835">835</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#897">897</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#919">919</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#939">939</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#957">957</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#983">983</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1001">1001</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1080">1080</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1091">1091</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1093">1093</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1094">1094</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1095">1095</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1097">1097</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1102">1102</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1104">1104</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1111">1111</a>.</li>
<li>Changed the following issues from Open to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#921">921</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#987">987</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1087">1087</a>.</li>
<li>Changed the following issues from New to Tentatively NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#568">568</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#701">701</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#702">702</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#785">785</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#863">863</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#903">903</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#912">912</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#918">918</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#946">946</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#995">995</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1074">1074</a>.</li>
<li>Changed the following issues from Open to Tentatively NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#458">458</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#644">644</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#667">667</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#668">668</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#669">669</a>.</li>
<li>Changed the following issues from Review to Tentatively NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#901">901</a>.</li>
<li>Changed the following issues from Tentatively Ready to Tentatively NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#822">822</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#988">988</a>.</li>
<li>Changed the following issues from New to Tentatively NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#837">837</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#862">862</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#867">867</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#927">927</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#945">945</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#952">952</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#969">969</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#972">972</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#973">973</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#979">979</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1058">1058</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1060">1060</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1061">1061</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1077">1077</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1101">1101</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1109">1109</a>.</li>
<li>Changed the following issues from Open to Tentatively NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#424">424</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#825">825</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#830">830</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#884">884</a>.</li>
<li>Changed the following issues from Review to Tentatively NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1023">1023</a>.</li>
<li>Changed the following issues from Open to Tentatively NAD Future: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#96">96</a>.</li>
<li>Changed the following issues from New to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#810">810</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#898">898</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#906">906</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#910">910</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#913">913</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#914">914</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#915">915</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#925">925</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#974">974</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#976">976</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#981">981</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#982">982</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#984">984</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#990">990</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#998">998</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#999">999</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1063">1063</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1067">1067</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1070">1070</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1073">1073</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1100">1100</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1103">1103</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1107">1107</a>.</li>
<li>Changed the following issues from Open to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#688">688</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#814">814</a>.</li>
<li>Changed the following issues from Review to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#899">899</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#907">907</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#909">909</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#934">934</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#938">938</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#940">940</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#943">943</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#950">950</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#965">965</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#970">970</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#975">975</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#986">986</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#991">991</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#993">993</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#994">994</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#997">997</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1002">1002</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1006">1006</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1011">1011</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1013">1013</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1014">1014</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1021">1021</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1024">1024</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1037">1037</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1038">1038</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1039">1039</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1040">1040</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1044">1044</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1045">1045</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1065">1065</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1066">1066</a>.</li>
</ul></li>
</ul>
</li>
<li>R64: 
2009-05-01 mid-term mailing.
<ul>
<li><b>Summary:</b><ul>
<li>346 open issues, up by 19.</li>
<li>765 closed issues, up by 0.</li>
<li>1111 issues total, up by 19.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1093">1093</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1094">1094</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1095">1095</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1096">1096</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1097">1097</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1098">1098</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1099">1099</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1100">1100</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1101">1101</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1102">1102</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1103">1103</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1104">1104</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1105">1105</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1106">1106</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1107">1107</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1108">1108</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1109">1109</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1110">1110</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1111">1111</a>.</li>
<li>Changed the following issues from DR to CD1: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#130">130</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#386">386</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#406">406</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#409">409</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#413">413</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#434">434</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#438">438</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#444">444</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#445">445</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#455">455</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#457">457</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#460">460</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#469">469</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#533">533</a>.</li>
<li>Changed the following issues from Review to New: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1070">1070</a>.</li>
</ul></li>
</ul>
</li>
<li>R63: 
2009-03-20 post-Summit mailing.
<ul>
<li><b>Summary:</b><ul>
<li>327 open issues, up by 96.</li>
<li>765 closed issues, up by 14.</li>
<li>1092 issues total, up by 110.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following NAD Editorial issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1022">1022</a>.</li>
<li>Added the following NAD Future issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1025">1025</a>.</li>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#983">983</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#984">984</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#985">985</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#989">989</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#990">990</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#995">995</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#996">996</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#998">998</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#999">999</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1001">1001</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1033">1033</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1054">1054</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1056">1056</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1057">1057</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1058">1058</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1059">1059</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1060">1060</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1061">1061</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1062">1062</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1063">1063</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1067">1067</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1068">1068</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1069">1069</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1071">1071</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1072">1072</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1073">1073</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1074">1074</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1076">1076</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1077">1077</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1080">1080</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1090">1090</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1091">1091</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1092">1092</a>.</li>
<li>Added the following Open issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#987">987</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1000">1000</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1007">1007</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1008">1008</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1016">1016</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1017">1017</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1018">1018</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1020">1020</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1026">1026</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1027">1027</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1028">1028</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1029">1029</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1030">1030</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1031">1031</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1032">1032</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1034">1034</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1035">1035</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1036">1036</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1041">1041</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1042">1042</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1046">1046</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1048">1048</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1051">1051</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1052">1052</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1053">1053</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1055">1055</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1064">1064</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1075">1075</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1078">1078</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1079">1079</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1081">1081</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1082">1082</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1083">1083</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1084">1084</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1085">1085</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1086">1086</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1087">1087</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1088">1088</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1089">1089</a>.</li>
<li>Added the following Review issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#986">986</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#991">991</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#992">992</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#993">993</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#994">994</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#997">997</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1002">1002</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1003">1003</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1004">1004</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1005">1005</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1006">1006</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1009">1009</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1010">1010</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1011">1011</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1012">1012</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1013">1013</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1014">1014</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1015">1015</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1019">1019</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1021">1021</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1023">1023</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1024">1024</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1037">1037</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1038">1038</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1039">1039</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1040">1040</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1043">1043</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1044">1044</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1045">1045</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1047">1047</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1049">1049</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1050">1050</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1065">1065</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1066">1066</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1070">1070</a>.</li>
<li>Added the following Tentatively Ready issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#988">988</a>.</li>
<li>Changed the following issues from New to Dup: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#905">905</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#942">942</a>.</li>
<li>Changed the following issues from New to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#980">980</a>.</li>
<li>Changed the following issues from New to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#874">874</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#875">875</a>.</li>
<li>Changed the following issues from Open to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#732">732</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#793">793</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#794">794</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#800">800</a>.</li>
<li>Changed the following issues from Pending NAD Editorial to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#683">683</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#892">892</a>.</li>
<li>Changed the following issues from Ready to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#803">803</a>.</li>
<li>Changed the following issues from NAD to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#466">466</a>.</li>
<li>Changed the following issues from NAD Future to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#111">111</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#138">138</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#149">149</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#219">219</a>.</li>
<li>Changed the following issues from New to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#880">880</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#891">891</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#893">893</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#902">902</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#908">908</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#921">921</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#923">923</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#924">924</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#926">926</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#930">930</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#936">936</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#944">944</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#958">958</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#959">959</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#960">960</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#961">961</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#962">962</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#963">963</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#964">964</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#966">966</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#967">967</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#968">968</a>.</li>
<li>Changed the following issues from Ready to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#788">788</a>.</li>
<li>Changed the following issues from New to Pending NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#937">937</a>.</li>
<li>Changed the following issues from New to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#879">879</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#899">899</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#901">901</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#907">907</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#909">909</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#929">929</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#934">934</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#938">938</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#940">940</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#943">943</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#950">950</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#965">965</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#970">970</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#971">971</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#975">975</a>.</li>
<li>Changed the following issues from Open to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#817">817</a>.</li>
<li>Changed the following issues from New to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#904">904</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#922">922</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#928">928</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#931">931</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#932">932</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#948">948</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#949">949</a>.</li>
<li>Changed the following issues from Open to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#890">890</a>.</li>
<li>Changed the following issues from Review to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#765">765</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#822">822</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#853">853</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#869">869</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#878">878</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#888">888</a>.</li>
<li>Changed the following issues from Ready to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#752">752</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#753">753</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#758">758</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#821">821</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#866">866</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#894">894</a>.</li>
</ul></li>
</ul>
</li>
<li>R62: 
2009-02-06 pre-Summit mailing.
<ul>
<li><b>Summary:</b><ul>
<li>231 open issues, up by 44.</li>
<li>751 closed issues, up by 0.</li>
<li>982 issues total, up by 44.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#939">939</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#940">940</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#941">941</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#942">942</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#943">943</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#944">944</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#945">945</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#946">946</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#947">947</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#948">948</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#949">949</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#950">950</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#951">951</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#952">952</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#953">953</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#954">954</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#955">955</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#956">956</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#957">957</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#958">958</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#959">959</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#960">960</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#961">961</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#962">962</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#963">963</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#964">964</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#965">965</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#966">966</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#967">967</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#968">968</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#969">969</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#970">970</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#971">971</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#972">972</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#973">973</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#974">974</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#975">975</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#976">976</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#977">977</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#978">978</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#979">979</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#980">980</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#981">981</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#982">982</a>.</li>
</ul></li>
</ul>
</li>
<li>R61: 
2008-12-05 mid-term mailing.
<ul>
<li><b>Summary:</b><ul>
<li>187 open issues, up by 20.</li>
<li>751 closed issues, up by 0.</li>
<li>938 issues total, up by 20.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#919">919</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#920">920</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#921">921</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#922">922</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#923">923</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#924">924</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#925">925</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#926">926</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#927">927</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#928">928</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#929">929</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#930">930</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#931">931</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#932">932</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#933">933</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#934">934</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#935">935</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#936">936</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#937">937</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#938">938</a>.</li>
</ul></li>
</ul>
</li>
<li>R60: 
2008-10-03 post-San Francisco mailing.
<ul>
<li><b>Summary:</b><ul>
<li>167 open issues, down by 25.</li>
<li>751 closed issues, up by 65.</li>
<li>918 issues total, up by 40.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following CD1 issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#882">882</a>.</li>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#879">879</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#880">880</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#891">891</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#893">893</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#897">897</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#898">898</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#899">899</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#900">900</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#901">901</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#902">902</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#903">903</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#904">904</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#905">905</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#906">906</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#907">907</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#908">908</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#909">909</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#910">910</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#911">911</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#912">912</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#913">913</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#914">914</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#915">915</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#916">916</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#917">917</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#918">918</a>.</li>
<li>Added the following Open issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#881">881</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#883">883</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#884">884</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#885">885</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#886">886</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#887">887</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#889">889</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#890">890</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#895">895</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#896">896</a>.</li>
<li>Added the following Pending NAD Editorial issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#892">892</a>.</li>
<li>Added the following Ready issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#894">894</a>.</li>
<li>Added the following Review issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#888">888</a>.</li>
<li>Changed the following issues from New to CD1: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#818">818</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#820">820</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#843">843</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#845">845</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#846">846</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#856">856</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#858">858</a>.</li>
<li>Changed the following issues from Ready to CD1: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#180">180</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#387">387</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#396">396</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#522">522</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#629">629</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#691">691</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#713">713</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#714">714</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#720">720</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#728">728</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#762">762</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#769">769</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#771">771</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#772">772</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#776">776</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#779">779</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#787">787</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#805">805</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#806">806</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#807">807</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#808">808</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#809">809</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#813">813</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#824">824</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#829">829</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#842">842</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#844">844</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#848">848</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#850">850</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#852">852</a>.</li>
<li>Changed the following issues from Review to CD1: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#23">23</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#675">675</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#692">692</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#698">698</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#709">709</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#734">734</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#804">804</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#823">823</a>.</li>
<li>Changed the following issues from WP to CD1: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#44">44</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#49">49</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#76">76</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#91">91</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#92">92</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#98">98</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#103">103</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#109">109</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#117">117</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#118">118</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#120">120</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#123">123</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#136">136</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#153">153</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#165">165</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#167">167</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#171">171</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#179">179</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#182">182</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#183">183</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#184">184</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#185">185</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#186">186</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#187">187</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#198">198</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#200">200</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#201">201</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#202">202</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#206">206</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#214">214</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#221">221</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#225">225</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#226">226</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#228">228</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#229">229</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#230">230</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#231">231</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#232">232</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#233">233</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#234">234</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#235">235</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#237">237</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#238">238</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#239">239</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#240">240</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#241">241</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#242">242</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#243">243</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#247">247</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#248">248</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#250">250</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#251">251</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#252">252</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#253">253</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#254">254</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#256">256</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#258">258</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#259">259</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#260">260</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#261">261</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#262">262</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#263">263</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#264">264</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#265">265</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#266">266</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#268">268</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#270">270</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#271">271</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#272">272</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#273">273</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#274">274</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#275">275</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#276">276</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#278">278</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#280">280</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#281">281</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#282">282</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#283">283</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#284">284</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#285">285</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#286">286</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#288">288</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#291">291</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#292">292</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#294">294</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#295">295</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#297">297</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#298">298</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#300">300</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#301">301</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#303">303</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#305">305</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#306">306</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#307">307</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#308">308</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#310">310</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#311">311</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#312">312</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#315">315</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#316">316</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#317">317</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#318">318</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#319">319</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#320">320</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#321">321</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#322">322</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#324">324</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#325">325</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#327">327</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#328">328</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#329">329</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#331">331</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#333">333</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#334">334</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#335">335</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#336">336</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#337">337</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#338">338</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#339">339</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#340">340</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#341">341</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#345">345</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#346">346</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#347">347</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#349">349</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#352">352</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#354">354</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#355">355</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#358">358</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#359">359</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#360">360</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#362">362</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#363">363</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#364">364</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#365">365</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#369">369</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#370">370</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#371">371</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#373">373</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#375">375</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#376">376</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#379">379</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#380">380</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#381">381</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#383">383</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#384">384</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#389">389</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#391">391</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#395">395</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#400">400</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#401">401</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#402">402</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#403">403</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#404">404</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#405">405</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#407">407</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#410">410</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#411">411</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#412">412</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#414">414</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#415">415</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#416">416</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#420">420</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#422">422</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#425">425</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#426">426</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#428">428</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#432">432</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#435">435</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#436">436</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#441">441</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#442">442</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#443">443</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#448">448</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#449">449</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#453">453</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#456">456</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#461">461</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#464">464</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#465">465</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#467">467</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#468">468</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#474">474</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#475">475</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#478">478</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#488">488</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#495">495</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#496">496</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#497">497</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#505">505</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#507">507</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#508">508</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#518">518</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#519">519</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#520">520</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#521">521</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#524">524</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#527">527</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#530">530</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#531">531</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#534">534</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#535">535</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#537">537</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#538">538</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#540">540</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#541">541</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#542">542</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#543">543</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#545">545</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#550">550</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#551">551</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#552">552</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#559">559</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#561">561</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#562">562</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#563">563</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#566">566</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#567">567</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#574">574</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#575">575</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#576">576</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#577">577</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#578">578</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#581">581</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#586">586</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#589">589</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#593">593</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#595">595</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#596">596</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#607">607</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#608">608</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#609">609</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#610">610</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#611">611</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#612">612</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#613">613</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#616">616</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#618">618</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#619">619</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#620">620</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#621">621</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#622">622</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#623">623</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#624">624</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#628">628</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#634">634</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#638">638</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#640">640</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#643">643</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#646">646</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#650">650</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#651">651</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#652">652</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#654">654</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#655">655</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#660">660</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#661">661</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#664">664</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#665">665</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#666">666</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#672">672</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#673">673</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#674">674</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#677">677</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#678">678</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#679">679</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#680">680</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#681">681</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#682">682</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#685">685</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#687">687</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#689">689</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#693">693</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#694">694</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#695">695</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#699">699</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#700">700</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#703">703</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#705">705</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#706">706</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#710">710</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#712">712</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#715">715</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#722">722</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#740">740</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#743">743</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#744">744</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#746">746</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#749">749</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#755">755</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#759">759</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#761">761</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#766">766</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#768">768</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#770">770</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#775">775</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#777">777</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#778">778</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#781">781</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#782">782</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#783">783</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#789">789</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#792">792</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#798">798</a>.</li>
<li>Changed the following issues from Open to Dup: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#670">670</a>.</li>
<li>Changed the following issues from New to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#849">849</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#855">855</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#871">871</a>.</li>
<li>Changed the following issues from Open to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#454">454</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#832">832</a>.</li>
<li>Changed the following issues from New to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#811">811</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#812">812</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#841">841</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#864">864</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#870">870</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#872">872</a>.</li>
<li>Changed the following issues from Open to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#299">299</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#484">484</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#556">556</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#631">631</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#676">676</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#704">704</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#724">724</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#742">742</a>.</li>
<li>Changed the following issues from Pending NAD Editorial to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#532">532</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#594">594</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#717">717</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#725">725</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#738">738</a>.</li>
<li>Changed the following issues from New to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#721">721</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#751">751</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#814">814</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#816">816</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#817">817</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#819">819</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#827">827</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#836">836</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#838">838</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#847">847</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#857">857</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#859">859</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#860">860</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#861">861</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#868">868</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#873">873</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#876">876</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#877">877</a>.</li>
<li>Changed the following issues from Pending NAD Editorial to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#424">424</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#625">625</a>.</li>
<li>Changed the following issues from Review to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#851">851</a>.</li>
<li>Changed the following issues from New to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#788">788</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#821">821</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#866">866</a>.</li>
<li>Changed the following issues from Open to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#753">753</a>.</li>
<li>Changed the following issues from Review to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#752">752</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#758">758</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#803">803</a>.</li>
<li>Changed the following issues from New to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#765">765</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#822">822</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#853">853</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#854">854</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#869">869</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#878">878</a>.</li>
<li>Changed the following issues from TC to TC1: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1">1</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#3">3</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#5">5</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#7">7</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#8">8</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#9">9</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#11">11</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#13">13</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#14">14</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#15">15</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#16">16</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#17">17</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#18">18</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#19">19</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#20">20</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#21">21</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#22">22</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#24">24</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#25">25</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#26">26</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#27">27</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#28">28</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#29">29</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#30">30</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#31">31</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#32">32</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#33">33</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#34">34</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#35">35</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#36">36</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#37">37</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#38">38</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#39">39</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#40">40</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#41">41</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#42">42</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#46">46</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#47">47</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#48">48</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#50">50</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#51">51</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#52">52</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#53">53</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#54">54</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#55">55</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#56">56</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#57">57</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#59">59</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#60">60</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#61">61</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#62">62</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#63">63</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#64">64</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#66">66</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#68">68</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#69">69</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#70">70</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#71">71</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#74">74</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#75">75</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#78">78</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#79">79</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#80">80</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#83">83</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#86">86</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#90">90</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#106">106</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#108">108</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#110">110</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#112">112</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#114">114</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#115">115</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#119">119</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#122">122</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#124">124</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#125">125</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#126">126</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#127">127</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#129">129</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#132">132</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#133">133</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#134">134</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#137">137</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#139">139</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#141">141</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#142">142</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#144">144</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#146">146</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#147">147</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#148">148</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#150">150</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#151">151</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#152">152</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#154">154</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#155">155</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#156">156</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#158">158</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#159">159</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#160">160</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#161">161</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#164">164</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#168">168</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#169">169</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#170">170</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#172">172</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#173">173</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#174">174</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#175">175</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#176">176</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#181">181</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#189">189</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#193">193</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#195">195</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#199">199</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#208">208</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#209">209</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#210">210</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#211">211</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#212">212</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#217">217</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#220">220</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#222">222</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#223">223</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#224">224</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#227">227</a>.</li>
</ul></li>
</ul>
</li>
<li>R59: 
2008-08-22 pre-San Francisco mailing.
<ul>
<li><b>Summary:</b><ul>
<li>192 open issues, up by 9.</li>
<li>686 closed issues, up by 0.</li>
<li>878 issues total, up by 9.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#870">870</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#871">871</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#872">872</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#873">873</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#874">874</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#875">875</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#876">876</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#877">877</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#878">878</a>.</li>
</ul></li>
</ul>
</li>
<li>R58: 
2008-07-28 mid-term mailing.
<ul>
<li><b>Summary:</b><ul>
<li>183 open issues, up by 12.</li>
<li>686 closed issues, down by 4.</li>
<li>869 issues total, up by 8.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#862">862</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#863">863</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#864">864</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#865">865</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#866">866</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#867">867</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#868">868</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#869">869</a>.</li>
<li>Changed the following issues from Pending NAD Editorial to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#393">393</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#557">557</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#592">592</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#754">754</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#757">757</a>.</li>
<li>Changed the following issues from Pending WP to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#644">644</a>.</li>
<li>Changed the following issues from WP to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#387">387</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#629">629</a>.</li>
<li>Changed the following issues from Pending NAD Editorial to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#709">709</a>.</li>
</ul></li>
</ul>
</li>
<li>R57: 
2008-06-27 post-Sophia Antipolis mailing.
<ul>
<li><b>Summary:</b><ul>
<li>171 open issues, down by 20.</li>
<li>690 closed issues, up by 43.</li>
<li>861 issues total, up by 23.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following NAD issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#840">840</a>.</li>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#841">841</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#843">843</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#845">845</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#846">846</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#847">847</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#849">849</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#853">853</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#854">854</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#855">855</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#856">856</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#857">857</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#858">858</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#859">859</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#860">860</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#861">861</a>.</li>
<li>Added the following Open issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#839">839</a>.</li>
<li>Added the following Ready issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#842">842</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#844">844</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#848">848</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#850">850</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#852">852</a>.</li>
<li>Added the following Review issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#851">851</a>.</li>
<li>Changed the following issues from New to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#826">826</a>.</li>
<li>Changed the following issues from Open to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#570">570</a>.</li>
<li>Changed the following issues from New to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#786">786</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#831">831</a>.</li>
<li>Changed the following issues from Open to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#756">756</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#767">767</a>.</li>
<li>Changed the following issues from New to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#723">723</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#726">726</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#794">794</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#815">815</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#825">825</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#830">830</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#833">833</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#834">834</a>.</li>
<li>Changed the following issues from Ready to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#471">471</a>.</li>
<li>Changed the following issues from Review to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#539">539</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#711">711</a>.</li>
<li>Changed the following issues from New to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#713">713</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#714">714</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#769">769</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#772">772</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#779">779</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#787">787</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#805">805</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#806">806</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#807">807</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#808">808</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#809">809</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#813">813</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#824">824</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#829">829</a>.</li>
<li>Changed the following issues from Open to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#180">180</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#396">396</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#522">522</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#720">720</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#762">762</a>.</li>
<li>Changed the following issues from Review to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#691">691</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#728">728</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#771">771</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#776">776</a>.</li>
<li>Changed the following issues from New to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#692">692</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#698">698</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#752">752</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#804">804</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#823">823</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#828">828</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#832">832</a>.</li>
<li>Changed the following issues from Open to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#23">23</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#675">675</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#734">734</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#803">803</a>.</li>
<li>Changed the following issues from Ready to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#758">758</a>.</li>
<li>Changed the following issues from Ready to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#387">387</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#518">518</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#550">550</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#574">574</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#595">595</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#596">596</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#612">612</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#618">618</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#629">629</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#638">638</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#672">672</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#673">673</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#685">685</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#710">710</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#715">715</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#722">722</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#740">740</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#743">743</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#744">744</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#746">746</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#749">749</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#755">755</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#759">759</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#761">761</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#766">766</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#768">768</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#770">770</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#775">775</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#777">777</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#778">778</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#781">781</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#782">782</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#783">783</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#789">789</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#792">792</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#798">798</a>.</li>
</ul></li>
</ul>
</li>
<li>R56: 
2008-05-16 pre-Sophia Antipolis mailing.
<ul>
<li><b>Summary:</b><ul>
<li>191 open issues, up by 24.</li>
<li>647 closed issues, up by 1.</li>
<li>838 issues total, up by 25.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#814">814</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#815">815</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#816">816</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#817">817</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#818">818</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#819">819</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#820">820</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#821">821</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#822">822</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#823">823</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#824">824</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#825">825</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#826">826</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#827">827</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#828">828</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#829">829</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#830">830</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#831">831</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#832">832</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#833">833</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#834">834</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#835">835</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#836">836</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#837">837</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#838">838</a>.</li>
<li>Changed the following issues from New to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#802">802</a>.</li>
</ul></li>
</ul>
</li>
<li>R55: 
2008-03-14 post-Bellevue mailing.
<ul>
<li><b>Summary:</b><ul>
<li>167 open issues, down by 39.</li>
<li>646 closed issues, up by 65.</li>
<li>813 issues total, up by 26.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following Dup issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#795">795</a>.</li>
<li>Added the following NAD issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#790">790</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#791">791</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#796">796</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#797">797</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#799">799</a>.</li>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#788">788</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#794">794</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#802">802</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#804">804</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#805">805</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#806">806</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#807">807</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#808">808</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#809">809</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#810">810</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#811">811</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#812">812</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#813">813</a>.</li>
<li>Added the following Open issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#793">793</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#800">800</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#801">801</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#803">803</a>.</li>
<li>Added the following Ready issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#789">789</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#792">792</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#798">798</a>.</li>
<li>Changed the following issues from NAD Future to Dup: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#116">116</a>.</li>
<li>Changed the following issues from NAD Future to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#188">188</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#323">323</a>.</li>
<li>Changed the following issues from New to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#729">729</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#730">730</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#731">731</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#733">733</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#735">735</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#736">736</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#737">737</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#739">739</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#741">741</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#745">745</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#748">748</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#763">763</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#764">764</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#773">773</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#784">784</a>.</li>
<li>Changed the following issues from Open to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#388">388</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#462">462</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#579">579</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#627">627</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#653">653</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#686">686</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#707">707</a>.</li>
<li>Changed the following issues from NAD Future to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#140">140</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#390">390</a>.</li>
<li>Changed the following issues from Open to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#529">529</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#626">626</a>.</li>
<li>Changed the following issues from Review to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#645">645</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#684">684</a>.</li>
<li>Changed the following issues from NAD Future to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#128">128</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#180">180</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#190">190</a>.</li>
<li>Changed the following issues from New to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#617">617</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#718">718</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#719">719</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#720">720</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#724">724</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#732">732</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#734">734</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#742">742</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#747">747</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#750">750</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#753">753</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#756">756</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#760">760</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#762">762</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#767">767</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#774">774</a>.</li>
<li>Changed the following issues from Ready to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#675">675</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#676">676</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#688">688</a>.</li>
<li>Changed the following issues from New to Pending NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#709">709</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#717">717</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#725">725</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#738">738</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#754">754</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#757">757</a>.</li>
<li>Changed the following issues from Open to Pending NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#424">424</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#557">557</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#625">625</a>.</li>
<li>Changed the following issues from New to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#710">710</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#715">715</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#722">722</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#740">740</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#743">743</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#744">744</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#746">746</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#749">749</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#755">755</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#758">758</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#759">759</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#761">761</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#766">766</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#768">768</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#770">770</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#775">775</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#777">777</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#778">778</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#781">781</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#782">782</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#783">783</a>.</li>
<li>Changed the following issues from Open to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#387">387</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#471">471</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#550">550</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#612">612</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#629">629</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#673">673</a>.</li>
<li>Changed the following issues from Review to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#518">518</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#574">574</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#596">596</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#618">618</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#638">638</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#672">672</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#685">685</a>.</li>
<li>Changed the following issues from New to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#711">711</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#728">728</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#771">771</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#776">776</a>.</li>
<li>Changed the following issues from Open to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#539">539</a>.</li>
<li>Changed the following issues from Ready to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#561">561</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#562">562</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#563">563</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#567">567</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#581">581</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#620">620</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#621">621</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#622">622</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#623">623</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#624">624</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#661">661</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#664">664</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#665">665</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#666">666</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#674">674</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#679">679</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#680">680</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#687">687</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#689">689</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#693">693</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#694">694</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#695">695</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#700">700</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#703">703</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#705">705</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#706">706</a>.</li>
<li>Changed the following issues from Tentatively Ready to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#527">527</a>.</li>
</ul></li>
</ul>
</li>
<li>R54: 
2008-02-01 pre-Bellevue mailing.
<ul>
<li><b>Summary:</b><ul>
<li>206 open issues, up by 23.</li>
<li>581 closed issues, up by 0.</li>
<li>787 issues total, up by 23.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#765">765</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#766">766</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#767">767</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#768">768</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#769">769</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#770">770</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#771">771</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#772">772</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#773">773</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#774">774</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#775">775</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#776">776</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#777">777</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#778">778</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#779">779</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#780">780</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#781">781</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#782">782</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#783">783</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#784">784</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#785">785</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#786">786</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#787">787</a>.</li>
<li>Changed the following issues from NAD Future to Dup: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#105">105</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#348">348</a>.</li>
<li>Changed the following issues from NAD Future to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#353">353</a>.</li>
<li>Changed the following issues from New to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#697">697</a>.</li>
<li>Changed the following issues from NAD Future to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#388">388</a>.</li>
<li>Changed the following issues from Open to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#527">527</a>.</li>
</ul></li>
</ul>
</li>
<li>R53: 
2007-12-09 mid-term mailing.
<ul>
<li><b>Summary:</b><ul>
<li>183 open issues, up by 11.</li>
<li>581 closed issues, down by 1.</li>
<li>764 issues total, up by 10.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#755">755</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#756">756</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#757">757</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#758">758</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#759">759</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#760">760</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#761">761</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#762">762</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#763">763</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#764">764</a>.</li>
<li>Changed the following issues from NAD to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#463">463</a>.</li>
<li>Changed the following issues from Pending WP to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#607">607</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#608">608</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#654">654</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#655">655</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#677">677</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#682">682</a>.</li>
</ul></li>
</ul>
</li>
<li>R52: 
2007-10-19 post-Kona mailing.
<ul>
<li><b>Summary:</b><ul>
<li>172 open issues, up by 4.</li>
<li>582 closed issues, up by 27.</li>
<li>754 issues total, up by 31.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#724">724</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#725">725</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#726">726</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#727">727</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#728">728</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#729">729</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#730">730</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#731">731</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#732">732</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#733">733</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#734">734</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#735">735</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#736">736</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#737">737</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#738">738</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#739">739</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#740">740</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#741">741</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#742">742</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#743">743</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#744">744</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#745">745</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#746">746</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#747">747</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#748">748</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#749">749</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#750">750</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#751">751</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#752">752</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#753">753</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#754">754</a>.</li>
<li>Changed the following issues from NAD Future to Dup: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#77">77</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#350">350</a>.</li>
<li>Changed the following issues from New to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#639">639</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#657">657</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#663">663</a>.</li>
<li>Changed the following issues from Open to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#548">548</a>.</li>
<li>Changed the following issues from New to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#546">546</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#550">550</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#564">564</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#565">565</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#573">573</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#585">585</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#588">588</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#627">627</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#629">629</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#630">630</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#632">632</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#635">635</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#653">653</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#659">659</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#667">667</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#668">668</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#669">669</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#670">670</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#671">671</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#673">673</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#686">686</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#704">704</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#707">707</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#708">708</a>.</li>
<li>Changed the following issues from New to Pending NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#393">393</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#592">592</a>.</li>
<li>Changed the following issues from New to Pending WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#607">607</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#608">608</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#654">654</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#655">655</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#677">677</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#682">682</a>.</li>
<li>Changed the following issues from New to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#561">561</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#562">562</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#563">563</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#567">567</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#581">581</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#595">595</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#620">620</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#621">621</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#622">622</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#623">623</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#624">624</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#661">661</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#664">664</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#665">665</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#666">666</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#674">674</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#675">675</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#676">676</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#679">679</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#687">687</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#688">688</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#689">689</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#693">693</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#694">694</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#695">695</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#700">700</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#703">703</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#705">705</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#706">706</a>.</li>
<li>Changed the following issues from Open to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#680">680</a>.</li>
<li>Changed the following issues from New to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#574">574</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#596">596</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#618">618</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#638">638</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#645">645</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#672">672</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#684">684</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#685">685</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#691">691</a>.</li>
<li>Changed the following issues from New to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#552">552</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#634">634</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#650">650</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#651">651</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#652">652</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#678">678</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#681">681</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#699">699</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#712">712</a>.</li>
<li>Changed the following issues from Open to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#258">258</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#401">401</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#524">524</a>.</li>
<li>Changed the following issues from Ready to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#488">488</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#577">577</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#660">660</a>.</li>
</ul></li>
</ul>
</li>
<li>R51: 
2007-09-09 pre-Kona mailing.
<ul>
<li><b>Summary:</b><ul>
<li>168 open issues, up by 15.</li>
<li>555 closed issues, up by 0.</li>
<li>723 issues total, up by 15.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#709">709</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#710">710</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#711">711</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#712">712</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#713">713</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#714">714</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#715">715</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#716">716</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#717">717</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#718">718</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#719">719</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#720">720</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#721">721</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#722">722</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#723">723</a>.</li>
</ul></li>
</ul>
</li>
<li>R50: 
2007-08-05 post-Toronto mailing.
<ul>
<li><b>Summary:</b><ul>
<li>153 open issues, down by 5.</li>
<li>555 closed issues, up by 17.</li>
<li>708 issues total, up by 12.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#697">697</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#698">698</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#699">699</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#700">700</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#701">701</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#702">702</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#703">703</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#704">704</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#705">705</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#706">706</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#707">707</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#708">708</a>.</li>
<li>Changed the following issues from New to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#583">583</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#584">584</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#662">662</a>.</li>
<li>Changed the following issues from Open to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#528">528</a>.</li>
<li>Changed the following issues from New to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#637">637</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#647">647</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#658">658</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#690">690</a>.</li>
<li>Changed the following issues from Open to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#525">525</a>.</li>
<li>Changed the following issues from Pending NAD Editorial to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#553">553</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#571">571</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#591">591</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#633">633</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#636">636</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#641">641</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#642">642</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#648">648</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#649">649</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#656">656</a>.</li>
<li>Changed the following issues from New to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#579">579</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#631">631</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#680">680</a>.</li>
<li>Changed the following issues from Pending WP to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#258">258</a>.</li>
<li>Changed the following issues from Ready to Pending WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#644">644</a>.</li>
<li>Changed the following issues from New to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#577">577</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#660">660</a>.</li>
<li>Changed the following issues from Open to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#488">488</a>.</li>
<li>Changed the following issues from Open to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#518">518</a>.</li>
<li>Changed the following issues from Ready to TRDec: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#604">604</a>.</li>
<li>Changed the following issues from DR to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#453">453</a>.</li>
<li>Changed the following issues from Ready to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#531">531</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#551">551</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#566">566</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#628">628</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#640">640</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#643">643</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#646">646</a>.</li>
</ul></li>
</ul>
</li>
<li>R49: 
2007-06-23 pre-Toronto mailing.
<ul>
<li><b>Summary:</b><ul>
<li>158 open issues, up by 13.</li>
<li>538 closed issues, up by 7.</li>
<li>696 issues total, up by 20.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#677">677</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#678">678</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#679">679</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#680">680</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#681">681</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#682">682</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#684">684</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#685">685</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#686">686</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#687">687</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#688">688</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#689">689</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#690">690</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#691">691</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#692">692</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#693">693</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#694">694</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#695">695</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#696">696</a>.</li>
<li>Added the following Pending NAD Editorial issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#683">683</a>.</li>
<li>Changed the following issues from New to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#587">587</a>.</li>
<li>Changed the following issues from Open to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#590">590</a>.</li>
<li>Changed the following issues from New to Pending NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#636">636</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#642">642</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#648">648</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#649">649</a>.</li>
</ul></li>
</ul>
</li>
<li>R48: 
2007-05-06 post-Oxford mailing.
<ul>
<li><b>Summary:</b><ul>
<li>145 open issues, down by 33.</li>
<li>531 closed issues, up by 53.</li>
<li>676 issues total, up by 20.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#657">657</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#658">658</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#659">659</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#660">660</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#661">661</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#662">662</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#663">663</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#664">664</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#665">665</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#666">666</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#667">667</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#668">668</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#669">669</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#670">670</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#671">671</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#672">672</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#673">673</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#674">674</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#675">675</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#676">676</a>.</li>
<li>Changed the following issues from Tentatively Ready to Dup: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#479">479</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#536">536</a>.</li>
<li>Changed the following issues from Tentatively Ready to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#385">385</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#463">463</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#466">466</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#470">470</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#515">515</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#526">526</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#547">547</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#560">560</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#572">572</a>.</li>
<li>Changed the following issues from NAD to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#351">351</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#357">357</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#368">368</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#499">499</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#504">504</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#512">512</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#513">513</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#514">514</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#516">516</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#544">544</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#549">549</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#555">555</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#558">558</a>.</li>
<li>Changed the following issues from Tentatively Ready to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#482">482</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#615">615</a>.</li>
<li>Changed the following issues from NAD_Future to NAD Future: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#77">77</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#105">105</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#111">111</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#116">116</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#128">128</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#138">138</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#140">140</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#149">149</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#180">180</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#188">188</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#190">190</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#219">219</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#323">323</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#348">348</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#350">350</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#353">353</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#388">388</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#390">390</a>.</li>
<li>Changed the following issues from Tentatively Ready to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#471">471</a>.</li>
<li>Changed the following issues from New to Pending NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#633">633</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#641">641</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#656">656</a>.</li>
<li>Changed the following issues from Tentatively Ready to Pending NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#532">532</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#553">553</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#571">571</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#591">591</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#594">594</a>.</li>
<li>Changed the following issues from Tentatively Ready to Pending WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#258">258</a>.</li>
<li>Changed the following issues from New to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#566">566</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#628">628</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#640">640</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#643">643</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#644">644</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#646">646</a>.</li>
<li>Changed the following issues from Review to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#531">531</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#551">551</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#604">604</a>.</li>
<li>Changed the following issues from Ready to TRDec: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#598">598</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#599">599</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#600">600</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#601">601</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#602">602</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#603">603</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#605">605</a>.</li>
<li>Changed the following issues from Ready to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#543">543</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#545">545</a>.</li>
<li>Changed the following issues from Tentatively Ready to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#201">201</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#206">206</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#233">233</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#254">254</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#416">416</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#422">422</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#456">456</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#534">534</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#542">542</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#559">559</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#575">575</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#576">576</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#578">578</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#586">586</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#589">589</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#593">593</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#609">609</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#610">610</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#611">611</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#613">613</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#616">616</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#619">619</a>.</li>
</ul></li>
</ul>
</li>
<li>R47: 
2007-03-09 pre-Oxford mailing.
<ul>
<li><b>Summary:</b><ul>
<li>178 open issues, up by 37.</li>
<li>478 closed issues, up by 0.</li>
<li>656 issues total, up by 37.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#620">620</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#621">621</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#622">622</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#623">623</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#624">624</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#627">627</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#628">628</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#629">629</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#630">630</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#631">631</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#632">632</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#633">633</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#634">634</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#635">635</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#636">636</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#637">637</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#638">638</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#639">639</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#640">640</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#641">641</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#642">642</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#643">643</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#644">644</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#645">645</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#646">646</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#647">647</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#648">648</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#649">649</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#650">650</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#651">651</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#652">652</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#653">653</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#654">654</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#655">655</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#656">656</a>.</li>
<li>Added the following Open issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#625">625</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#626">626</a>.</li>
<li>Changed the following issues from New to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#570">570</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#580">580</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#582">582</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#590">590</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#612">612</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#614">614</a>.</li>
<li>Changed the following issues from New to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#547">547</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#553">553</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#560">560</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#571">571</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#572">572</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#575">575</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#576">576</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#578">578</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#586">586</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#589">589</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#591">591</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#593">593</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#594">594</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#609">609</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#610">610</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#611">611</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#613">613</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#615">615</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#616">616</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#619">619</a>.</li>
<li>Changed the following issues from Open to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#201">201</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#206">206</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#233">233</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#254">254</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#258">258</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#385">385</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#416">416</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#422">422</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#456">456</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#463">463</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#466">466</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#470">470</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#471">471</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#479">479</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#482">482</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#515">515</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#526">526</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#532">532</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#536">536</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#542">542</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#559">559</a>.</li>
<li>Changed the following issues from Review to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#534">534</a>.</li>
</ul></li>
</ul>
</li>
<li>R46: 
2007-01-12 mid-term mailing.
<ul>
<li><b>Summary:</b><ul>
<li>141 open issues, up by 11.</li>
<li>478 closed issues, down by 1.</li>
<li>619 issues total, up by 10.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#610">610</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#611">611</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#612">612</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#613">613</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#614">614</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#615">615</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#616">616</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#617">617</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#618">618</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#619">619</a>.</li>
</ul></li>
</ul>
</li>
<li>R45: 
2006-11-03 post-Portland mailing.
<ul>
<li><b>Summary:</b><ul>
<li>130 open issues, up by 0.</li>
<li>479 closed issues, up by 17.</li>
<li>609 issues total, up by 17.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Moved issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#520">520</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#521">521</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#530">530</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#535">535</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#537">537</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#538">538</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#540">540</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#541">541</a> to WP.</li>
<li>Moved issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#504">504</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#512">512</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#516">516</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#544">544</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#549">549</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#554">554</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#555">555</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#558">558</a> to NAD.</li>
<li>Moved issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#569">569</a> to Dup.</li>
<li>Moved issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#518">518</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#523">523</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#524">524</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#542">542</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#556">556</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#557">557</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#559">559</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#597">597</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#606">606</a> to Open.</li>
<li>Moved issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#543">543</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#545">545</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#549">549</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#549">549</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#598">598</a> - <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#603">603</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#605">605</a> to Ready.</li>
<li>Moved issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#531">531</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#551">551</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#604">604</a> to Review.</li>
<li>Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#593">593</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#594">594</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#595">595</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#596">596</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#597">597</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#598">598</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#599">599</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#600">600</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#601">601</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#602">602</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#603">603</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#604">604</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#605">605</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#606">606</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#607">607</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#608">608</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#609">609</a>.</li>
</ul></li>
</ul>
</li>
<li>R44: 
2006-09-08 pre-Portland mailing.
<ul>
<li><b>Summary:</b><ul>
<li>130 open issues, up by 6.</li>
<li>462 closed issues, down by 1.</li>
<li>592 issues total, up by 5.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#583">583</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#584">584</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#585">585</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#586">586</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#587">587</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#588">588</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#589">589</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#590">590</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#591">591</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#592">592</a>.</li>
</ul></li>
</ul>
</li>
<li>R43: 
2006-06-23 mid-term mailing.
<ul>
<li><b>Summary:</b><ul>
<li>124 open issues, up by 14.</li>
<li>463 closed issues, down by 1.</li>
<li>587 issues total, up by 13.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#575">575</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#576">576</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#577">577</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#578">578</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#579">579</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#580">580</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#581">581</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#582">582</a>.</li>
<li>Reopened <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#255">255</a>.</li>
<li>Moved issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#520">520</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#541">541</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#544">544</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#569">569</a> to Tentatively Ready.</li>
</ul></li>
</ul>
</li>
<li>R42: 
2006-04-21 post-Berlin mailing.
<ul>
<li><b>Summary:</b><ul>
<li>110 open issues, down by 16.</li>
<li>464 closed issues, up by 24.</li>
<li>574 issues total, up by 8.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#567">567</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#568">568</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#569">569</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#570">570</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#571">571</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#572">572</a>.</li>
<li>Moved issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#499">499</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#501">501</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#506">506</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#509">509</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#510">510</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#511">511</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#513">513</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#514">514</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#517">517</a> to NAD.</li>
<li>Moved issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#502">502</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#503">503</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#515">515</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#516">516</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#522">522</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#525">525</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#526">526</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#527">527</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#528">528</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#529">529</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#532">532</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#536">536</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#539">539</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#548">548</a> to Open.</li>
<li>Moved issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#504">504</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#512">512</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#521">521</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#530">530</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#531">531</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#535">535</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#537">537</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#538">538</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#540">540</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#549">549</a> to Ready.</li>
<li>Moved issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#247">247</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#294">294</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#362">362</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#369">369</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#371">371</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#376">376</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#384">384</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#475">475</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#478">478</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#495">495</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#497">497</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#505">505</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#507">507</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#508">508</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#519">519</a> to WP.</li>
<li>Moved issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#534">534</a> to Review.</li>
</ul></li>
</ul>
</li>
<li>R41: 
2006-02-24 pre-Berlin mailing.
<ul>
<li><b>Summary:</b><ul>
<li>126 open issues, up by 31.</li>
<li>440 closed issues, up by 0.</li>
<li>566 issues total, up by 31.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#536">536</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#537">537</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#538">538</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#539">539</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#540">540</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#541">541</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#542">542</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#543">543</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#544">544</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#545">545</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#546">546</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#547">547</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#548">548</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#549">549</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#550">550</a> ,<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#551">551</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#552">552</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#553">553</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#554">554</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#555">555</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#556">556</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#557">557</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#558">558</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#559">559</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#560">560</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#561">561</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#562">562</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#563">563</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#564">564</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#565">565</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#566">566</a>.</li>
<li>Moved <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#342">342</a> from Ready to Open.</li>
<li>Reopened <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#309">309</a>.</li>
</ul></li>
</ul>
</li>
<li>R40: 
2005-12-16 mid-term mailing.
<ul>
<li><b>Summary:</b><ul>
<li>95 open issues.</li>
<li>440 closed issues.</li>
<li>535 issues total.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#529">529</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#530">530</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#531">531</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#532">532</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#533">533</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#534">534</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#535">535</a>.</li>
</ul></li>
</ul>
</li>
<li>R39: 
2005-10-14 post-Mont Tremblant mailing.
Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#526">526</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#528">528</a>.
Moved issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#280">280</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#461">461</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#464">464</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#465">465</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#467">467</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#468">468</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#474">474</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#496">496</a> from Ready to WP as per the vote from Mont Tremblant.
Moved issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#247">247</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#294">294</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#342">342</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#362">362</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#369">369</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#371">371</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#376">376</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#384">384</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#475">475</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#478">478</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#495">495</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#497">497</a> from Review to Ready.
Moved issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#498">498</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#504">504</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#506">506</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#509">509</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#510">510</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#511">511</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#512">512</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#513">513</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#514">514</a> from New to Open.
Moved issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#505">505</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#507">507</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#508">508</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#519">519</a> from New to Ready.
Moved issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#500">500</a> from New to NAD.
Moved issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#518">518</a> from New to Review.
</li>
<li>R38: 
2005-07-03 pre-Mont Tremblant mailing.
Merged open TR1 issues in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#504">504</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#522">522</a>.
Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#523">523</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#523">523</a>
</li>
<li>R37: 
2005-06 mid-term mailing.
Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#498">498</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#503">503</a>.
</li>
<li>R36: 
2005-04 post-Lillehammer mailing. All issues in "ready" status except
for <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#454">454</a> were moved to "DR" status, and all issues
previously in "DR" status were moved to "WP".
</li>
<li>R35: 
2005-03 pre-Lillehammer mailing.
</li>
<li>R34: 
2005-01 mid-term mailing.  Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#488">488</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#494">494</a>.
</li>
<li>R33: 
2004-11 post-Redmond mailing. Reflects actions taken in Redmond.
</li>
<li>R32: 
2004-09 pre-Redmond mailing: reflects new proposed resolutions and
new issues received after the 2004-07 mailing.  Added
new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#479">479</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#481">481</a>.
</li>
<li>R31: 
2004-07 mid-term mailing: reflects new proposed resolutions and
new issues received after the post-Sydney mailing.  Added
new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#463">463</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#478">478</a>.
</li>
<li>R30: 
Post-Sydney mailing: reflects decisions made at the Sydney meeting.
Voted all "Ready" issues from R29 into the working paper.
Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#460">460</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#462">462</a>.
</li>
<li>R29: 
Pre-Sydney mailing.  Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#441">441</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#457">457</a>.
</li>
<li>R28: 
Post-Kona mailing: reflects decisions made at the Kona meeting.
Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#432">432</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#440">440</a>.
</li>
<li>R27: 
Pre-Kona mailing.  Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#404">404</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#431">431</a>.
</li>
<li>R26: 
Post-Oxford mailing: reflects decisions made at the Oxford meeting.
All issues in Ready status were voted into DR status.  All issues in
DR status were voted into WP status.
</li>
<li>R25: 
Pre-Oxford mailing.  Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#390">390</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#402">402</a>.
</li>
<li>R24: 
Post-Santa Cruz mailing: reflects decisions made at the Santa Cruz
meeting.  All Ready issues from R23 with the exception of <iref ref="253">, which has been given a new proposed resolution, were
moved to DR status.  Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#383">383</a>-<iref ref="389">.  (Issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#387">387</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#389">389</a> were discussed
at the meeting.)  Made progress on issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#225">225</a>, <iref ref="226">, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#229">229</a>: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#225">225</a> and <iref ref="229"> have been moved to Ready status, and the only remaining
concerns with <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#226">226</a> involve wording.
</iref></iref></iref></iref></li>
<li>R23: 
Pre-Santa Cruz mailing.  Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#367">367</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#382">382</a>.
Moved issues in the TC to TC status.
</li>
<li>R22: 
Post-Curaao mailing.  Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#362">362</a>-<iref ref="366">.
</iref></li>
<li>R21: 
Pre-Curaao mailing.  Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#351">351</a>-<iref ref="361">.
</iref></li>
<li>R20: 
Post-Redmond mailing; reflects actions taken in Redmond.  Added
new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#336">336</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#350">350</a>, of which issues 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#347">347</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#350">350</a> were added since Redmond, hence
not discussed at the meeting.  

All Ready issues were moved to DR status, with the exception of issues
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#284">284</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#241">241</a>, and <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#267">267</a>.

Noteworthy issues discussed at Redmond include 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#120">120</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#202">202</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#226">226</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#233">233</a>, 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#270">270</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#253">253</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#254">254</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#323">323</a>.
</li>
<li>R19: 
Pre-Redmond mailing.  Added new issues 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#323">323</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#335">335</a>.
</li>
<li>R18: 
Post-Copenhagen mailing; reflects actions taken in Copenhagen.
Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#312">312</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#317">317</a>, and discussed
new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#271">271</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#314">314</a>.

Changed status of issues
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#103">103</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#118">118</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#136">136</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#153">153</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#165">165</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#171">171</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#183">183</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#184">184</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#185">185</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#186">186</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#214">214</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#221">221</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#234">234</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#237">237</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#243">243</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#248">248</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#251">251</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#252">252</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#256">256</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#260">260</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#261">261</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#262">262</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#263">263</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#265">265</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#268">268</a>
to DR.

Changed status of issues
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#49">49</a>  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#109">109</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#117">117</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#182">182</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#228">228</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#230">230</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#232">232</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#235">235</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#238">238</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#241">241</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#242">242</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#250">250</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#259">259</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#264">264</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#266">266</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#267">267</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#271">271</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#272">272</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#273">273</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#275">275</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#281">281</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#284">284</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#285">285</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#286">286</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#288">288</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#292">292</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#295">295</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#297">297</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#298">298</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#301">301</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#303">303</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#306">306</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#307">307</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#308">308</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#312">312</a>
to Ready.

Closed issues 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#111">111</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#277">277</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#279">279</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#287">287</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#289">289</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#293">293</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#302">302</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#313">313</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#314">314</a>
as NAD.

</li>
<li>R17: 
Pre-Copenhagen mailing.  Converted issues list to XML.  Added proposed
resolutions for issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#49">49</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#76">76</a>, <iref ref="91">, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#235">235</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#250">250</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#267">267</a>.
Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#278">278</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#311">311</a>.
</iref></li>
<li>R16:  
post-Toronto mailing; reflects actions taken in Toronto. Added new
issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#265">265</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#277">277</a>.  Changed status of issues
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#3">3</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#8">8</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#9">9</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#19">19</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#26">26</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#31">31</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#61">61</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#63">63</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#86">86</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#108">108</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#112">112</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#114">114</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#115">115</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#122">122</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#127">127</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#129">129</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#134">134</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#137">137</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#142">142</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#144">144</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#146">146</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#147">147</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#159">159</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#164">164</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#170">170</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#181">181</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#199">199</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#208">208</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#209">209</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#210">210</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#211">211</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#212">212</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#217">217</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#220">220</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#222">222</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#223">223</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#224">224</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#227">227</a> to "DR".  Reopened issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#23">23</a>. Reopened
issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#187">187</a>. Changed issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#2">2</a> and
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#4">4</a> to NAD. Fixed a typo in issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#17">17</a>. Fixed
issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#70">70</a>: signature should be changed both places it
appears. Fixed issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#160">160</a>: previous version didn't fix
the bug in enough places.
</li>
<li>R15: 
pre-Toronto mailing. Added issues
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#233">233</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#264">264</a>. Some small HTML formatting
changes so that we pass Weblint tests.
</li>
<li>R14: 
post-Tokyo II mailing; reflects committee actions taken in
Tokyo. Added issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#228">228</a> to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#232">232</a>. (00-0019R1/N1242)
</li>
<li>R13: 
pre-Tokyo II updated: Added issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#212">212</a> to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#227">227</a>.
</li>
<li>R12: 
pre-Tokyo II mailing: Added issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#199">199</a> to
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#211">211</a>. Added "and paragraph 5" to the proposed resolution
of issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#29">29</a>.  Add further rationale to issue
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#178">178</a>.
</li>
<li>R11: 
post-Kona mailing: Updated to reflect LWG and full committee actions
in Kona (99-0048/N1224). Note changed resolution of issues
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#4">4</a> and <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#38">38</a>. Added issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#196">196</a>
to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#198">198</a>. Closed issues list split into "defects" and
"closed" documents.  Changed the proposed resolution of issue
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#4">4</a> to NAD, and changed the wording of proposed resolution
of issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#38">38</a>.
</li>
<li>R10: 
pre-Kona updated.  Added proposed resolutions <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#83">83</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#86">86</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#91">91</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#92">92</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#109">109</a>. Added issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#190">190</a> to
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#195">195</a>. (99-0033/D1209, 14 Oct 99)
</li>
<li>R9: 
pre-Kona mailing.  Added issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#140">140</a> to
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#189">189</a>. Issues list split into separate "active" and
"closed" documents. (99-0030/N1206, 25 Aug 99)
</li>
<li>R8: 
post-Dublin mailing. Updated to reflect LWG and full committee actions
in Dublin. (99-0016/N1193, 21 Apr 99)
</li>
<li>R7: 
pre-Dublin updated: Added issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#130">130</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#131">131</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#132">132</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#133">133</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#134">134</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#135">135</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#136">136</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#137">137</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#138">138</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#139">139</a> (31 Mar 99)
</li>
<li>R6: 
pre-Dublin mailing. Added issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#127">127</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#128">128</a>,
and <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#129">129</a>.  (99-0007/N1194, 22 Feb 99)
</li>
<li>R5: 
update issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#103">103</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#112">112</a>; added issues
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#114">114</a> to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#126">126</a>. Format revisions to prepare
for making list public. (30 Dec 98)
</li>
<li>R4: 
post-Santa Cruz II updated: Issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#110">110</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#111">111</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#112">112</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#113">113</a> added, several
issues corrected. (22 Oct 98)
</li>
<li>R3: 
post-Santa Cruz II: Issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#94">94</a> to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#109">109</a>
added, many issues updated to reflect LWG consensus (12 Oct 98)
</li>
<li>R2: 
pre-Santa Cruz II: Issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#73">73</a> to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#93">93</a> added,
issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#17">17</a> updated. (29 Sep 98)
</li>
<li>R1: 
Correction to issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#55">55</a> resolution, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#60">60</a> code
format, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#64">64</a> title. (17 Sep 98)
</li>
</ul>

<h2>Defect Reports</h2>
<hr>
<h3><a name="1"></a>1. C library linkage editing oversight</h3>
<p><b>Section:</b> 17.6.2.3 [using.linkage] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Beman Dawes <b>Opened:</b> 1997-11-16 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>The change specified in the proposed resolution below did not make
it into the Standard. This change was accepted in principle at the
London meeting, and the exact wording below was accepted at the
Morristown meeting.</p>


<p><b>Proposed resolution:</b></p>
<p>Change 17.6.2.3 [using.linkage] paragraph 2
from:</p>

<blockquote>
  <p>It is unspecified whether a name from the Standard C library
  declared with external linkage has either extern "C" or
  extern "C++" linkage.</p>
</blockquote>

<p>to:</p>

<blockquote>
  <p>Whether a name from the Standard C library declared with external
  linkage has extern "C" or extern "C++" linkage
  is implementation defined. It is recommended that an implementation
  use extern "C++" linkage for this purpose.</p>
</blockquote>





<hr>
<h3><a name="3"></a>3. Atexit registration during atexit() call is not described</h3>
<p><b>Section:</b> 18.5 [support.start.term] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Steve Clamage <b>Opened:</b> 1997-12-12 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#support.start.term">issues</a> in [support.start.term].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>We appear not to have covered all the possibilities of
 exit processing with respect to
atexit registration. <br>
<br>
Example 1: (C and C++)</p>

<pre>    #include &lt;stdlib.h&gt;
    void f1() { }
    void f2() { atexit(f1); }
    
    int main()
    {
        atexit(f2); // the only use of f2
        return 0; // for C compatibility
    }</pre>

<p>At program exit, f2 gets called due to its registration in
main. Running f2 causes f1 to be newly registered during the exit
processing. Is this a valid program? If so, what are its
semantics?</p>

<p>
Interestingly, neither the C standard, nor the C++ draft standard nor
the forthcoming C9X Committee Draft says directly whether you can
register a function with atexit during exit processing.</p>

<p>
All 3 standards say that functions are run in reverse order of their
registration. Since f1 is registered last, it ought to be run first,
but by the time it is registered, it is too late to be first.</p>

<p>If the program is valid, the standards are self-contradictory about
its semantics.</p>

<p>Example 2: (C++ only)</p>

<pre>    
    void F() { static T t; } // type T has a destructor

    int main()
    {
        atexit(F); // the only use of F
    }
</pre>

<p>Function F registered with atexit has a local static variable t,
and F is called for the first time during exit processing. A local
static object is initialized the first time control flow passes
through its definition, and all static objects are destroyed during
exit processing. Is the code valid? If so, what are its semantics?</p>

<p>
Section 18.3 "Start and termination" says that if a function
F is registered with atexit before a static object t is initialized, F
will not be called until after t's destructor completes.</p>

<p>
In example 2, function F is registered with atexit before its local
static object O could possibly be initialized. On that basis, it must
not be called by exit processing until after O's destructor
completes. But the destructor cannot be run until after F is called,
since otherwise the object could not be constructed in the first
place.</p>

<p>If the program is valid, the standard is self-contradictory about
its semantics.</p>

<p>I plan to submit Example 1 as a public comment on the C9X CD, with
a recommendation that the results be undefined. (Alternative: make it
unspecified. I don't think it is worthwhile to specify the case where
f1 itself registers additional functions, each of which registers
still more functions.)</p>

<p>I think we should resolve the situation in the whatever way the C
committee decides. </p>

<p>For Example 2, I recommend we declare the results undefined.</p>

<p><i>[See reflector message lib-6500 for further discussion.]</i></p>




<p><b>Proposed resolution:</b></p>
<p>Change section 18.3/8 from:</p>
<blockquote><p>
  First, objects with static storage duration are destroyed and
  functions registered by calling atexit are called. Objects with
  static storage duration are destroyed in the reverse order of the
  completion of their constructor.  (Automatic objects are not
  destroyed as a result of calling exit().) Functions registered with
  atexit are called in the reverse order of their registration.  A
  function registered with atexit before an object obj1 of static
  storage duration is initialized will not be called until obj1's
  destruction has completed. A function registered with atexit after
  an object obj2 of static storage duration is initialized will be
  called before obj2's destruction starts.
</p></blockquote>
<p>to:</p>
<blockquote><p>
  First, objects with static storage duration are destroyed and
  functions registered by calling atexit are called. Non-local objects
  with static storage duration are destroyed in the reverse order of
  the completion of their constructor. (Automatic objects are not
  destroyed as a result of calling exit().) Functions registered with
  atexit are called in the reverse order of their registration, except
  that a function is called after any previously registered functions
  that had already been called at the time it was registered. A
  function registered with atexit before a non-local object obj1 of
  static storage duration is initialized will not be called until
  obj1's destruction has completed. A function registered with atexit
  after a non-local object obj2 of static storage duration is
  initialized will be called before obj2's destruction starts. A local
  static object obj3 is destroyed at the same time it would be if a
  function calling the obj3 destructor were registered with atexit at
  the completion of the obj3 constructor.
</p></blockquote>


<p><b>Rationale:</b></p>
<p>See 99-0039/N1215, October 22, 1999, by Stephen D. Clamage for the analysis
supporting to the proposed resolution.</p>





<hr>
<h3><a name="5"></a>5. String::compare specification questionable</h3>
<p><b>Section:</b> 21.4.6.8 [string::swap] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Jack Reeves <b>Opened:</b> 1997-12-11 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#string::swap">issues</a> in [string::swap].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#87">87</a></p>
<p><b>Discussion:</b></p>
<p>At the very end of the basic_string class definition is the signature: int
compare(size_type pos1, size_type n1, const charT* s, size_type n2 = npos) const; In the
following text this is defined as: returns
basic_string&lt;charT,traits,Allocator&gt;(*this,pos1,n1).compare(
basic_string&lt;charT,traits,Allocator&gt;(s,n2); </p>

<p>Since the constructor basic_string(const charT* s, size_type n, const Allocator&amp; a
= Allocator()) clearly requires that s != NULL and n &lt; npos and further states that it
throws length_error if n == npos, it appears the compare() signature above should always
throw length error if invoked like so: str.compare(1, str.size()-1, s); where 's' is some
null terminated character array. </p>

<p>This appears to be a typo since the obvious intent is to allow either the call above or
something like: str.compare(1, str.size()-1, s, strlen(s)-1); </p>

<p>This would imply that what was really intended was two signatures int compare(size_type
pos1, size_type n1, const charT* s) const int compare(size_type pos1, size_type n1, const
charT* s, size_type n2) const; each defined in terms of the corresponding constructor. </p>


<p><b>Proposed resolution:</b></p>
<p>Replace the compare signature in 21.4 [basic.string]
(at the very end of the basic_string synopsis) which reads:</p>

<blockquote>
  <p><tt>int compare(size_type pos1, size_type n1,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const charT* s,
  size_type n2 = npos) const;</tt></p>
</blockquote>

<p>with:</p>

<blockquote>
  <p><tt>int compare(size_type pos1, size_type n1,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const charT* s) const;<br>
  int compare(size_type pos1, size_type n1,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const charT* s,
  size_type n2) const;</tt></p>
</blockquote>

<p>Replace the portion of 21.4.6.8 [string::swap]
paragraphs 5 and 6 which read:</p>

<blockquote>
  <p><tt>int compare(size_type pos, size_type n1,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; charT * s, size_type n2
  = npos) const;<br>
  </tt>Returns:<tt><br>
  basic_string&lt;charT,traits,Allocator&gt;(*this, pos, n1).compare(<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  basic_string&lt;charT,traits,Allocator&gt;( s, n2))</tt></p>
</blockquote>

<p>with:</p>

<blockquote>
  <p><tt>int compare(size_type pos, size_type n1,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const charT * s) const;<br>
  </tt>Returns:<tt><br>
  basic_string&lt;charT,traits,Allocator&gt;(*this, pos, n1).compare(<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  basic_string&lt;charT,traits,Allocator&gt;( s ))<br>
  <br>
  int compare(size_type pos, size_type n1,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const charT * s,
  size_type n2) const;<br>
  </tt>Returns:<tt><br>
  basic_string&lt;charT,traits,Allocator&gt;(*this, pos, n1).compare(<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  basic_string&lt;charT,traits,Allocator&gt;( s, n2))</tt></p>
</blockquote>

<p>Editors please note that in addition to splitting the signature, the third argument
becomes const, matching the existing synopsis.</p>


<p><b>Rationale:</b></p>
<p>While the LWG dislikes adding signatures, this is a clear defect in
the Standard which must be fixed.&nbsp; The same problem was also
identified in issues 7 (item 5) and 87.</p>





<hr>
<h3><a name="7"></a>7. String clause minor problems</h3>
<p><b>Section:</b> 21 [strings] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 1997-12-15 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#strings">issues</a> in [strings].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>(1) In 21.4.6.4 [string::insert], the description of template
&lt;class InputIterator&gt; insert(iterator, InputIterator,
InputIterator) makes no sense. It refers to a member function that
doesn't exist. It also talks about the return value of a void
function. </p>

<p>(2) Several versions of basic_string::replace don't appear in the
class synopsis. </p>

<p>(3) basic_string::push_back appears in the synopsis, but is never
described elsewhere.  In the synopsis its argument is const charT,
which doesn't makes much sense; it should probably be charT, or
possible const charT&amp;. </p>

<p>(4) basic_string::pop_back is missing. </p>

<p>(5) int compare(size_type pos, size_type n1, charT* s, size_type n2
= npos) make no sense. First, it's const charT* in the synopsis and
charT* in the description. Second, given what it says in RETURNS,
leaving out the final argument will always result in an exception
getting thrown. This is paragraphs 5 and 6 of 
21.4.6.8 [string::swap]</p>

<p>(6) In table 37, in section 21.2.1 [char.traits.require],
there's a note for X::move(s, p, n). It says "Copies correctly
even where p is in [s, s+n)". This is correct as far as it goes,
but it doesn't go far enough; it should also guarantee that the copy
is correct even where s in in [p, p+n). These are two orthogonal
guarantees, and neither one follows from the other. Both guarantees
are necessary if X::move is supposed to have the same sort of
semantics as memmove (which was clearly the intent), and both
guarantees are necessary if X::move is actually supposed to be
useful. </p>


<p><b>Proposed resolution:</b></p>
<p>ITEM 1: In 21.3.5.4 [lib.string::insert], change paragraph 16 to <br>
<br>
&nbsp;&nbsp;&nbsp; EFFECTS: Equivalent to insert(p - begin(), basic_string(first, last)).<br>
<br>
ITEM 2:&nbsp; Not a defect; the Standard is clear.. There are ten versions of replace() in
the synopsis, and ten versions in 21.3.5.6 [lib.string::replace].<br>
<br>
ITEM 3: Change the declaration of push_back in the string synopsis (21.3,
[lib.basic.string]) from:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp; void push_back(const charT)<br>
<br>
to<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp; void push_back(charT)<br>
<br>
Add the following text immediately after 21.3.5.2 [lib.string::append], paragraph 10.<br>
<br>
&nbsp;&nbsp;&nbsp; void basic_string::push_back(charT c);<br>
&nbsp;&nbsp;&nbsp; EFFECTS: Equivalent to append(static_cast&lt;size_type&gt;(1), c);<br>
<br>
ITEM 4: Not a defect. The omission appears to have been deliberate.<br>
<br>
ITEM 5: Duplicate; see issue 5 (and 87).<br>
<br>
ITEM 6: In table 37, Replace:<br>
<br>
&nbsp;&nbsp;&nbsp; "Copies correctly even where p is in [s, s+n)."<br>
<br>
with:<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp; "Copies correctly even where the ranges [p, p+n) and [s,
s+n) overlap."</p>





<hr>
<h3><a name="8"></a>8. Locale::global lacks guarantee</h3>
<p><b>Section:</b> 22.3.1.5 [locale.statics] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 1997-12-24 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>It appears there's an important guarantee missing from clause
22. We're told that invoking locale::global(L) sets the C locale if L
has a name. However, we're not told whether or not invoking
setlocale(s) sets the global C++ locale. </p>

<p>The intent, I think, is that it should not, but I can't find any
such words anywhere. </p>


<p><b>Proposed resolution:</b></p>
<p>Add a sentence at the end of 22.3.1.5 [locale.statics],
paragraph 2:&nbsp; </p>

<blockquote>
  <p>No library function other than <tt>locale::global()</tt> shall affect 
  the value returned by <tt>locale()</tt>. </p>

</blockquote>





<hr>
<h3><a name="9"></a>9. Operator new(0) calls should not yield the same pointer</h3>
<p><b>Section:</b> 18.6.1 [new.delete] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Steve Clamage <b>Opened:</b> 1998-01-04 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#new.delete">issues</a> in [new.delete].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>Scott Meyers, in a comp.std.c++ posting: I just noticed that
section 3.7.3.1 of CD2 seems to allow for the possibility that all
calls to operator new(0) yield the same pointer, an implementation
technique specifically prohibited by ARM 5.3.3.Was this prohibition
really lifted? Does the FDIS agree with CD2 in the regard? [Issues
list maintainer's note: the IS is the same.]</p>


<p><b>Proposed resolution:</b></p>
<p>Change the last paragraph of 3.7.3 from:</p>
<blockquote>
  <p>Any allocation and/or deallocation functions defined in a C++ program shall
  conform to the semantics specified in 3.7.3.1 and 3.7.3.2.</p>
</blockquote>
<p>to:</p>
<blockquote>
  <p>Any allocation and/or deallocation functions defined in a C++ program,
  including the default versions in the library, shall conform to the semantics
  specified in 3.7.3.1 and 3.7.3.2.</p>
</blockquote>
<p>Change 3.7.3.1/2, next-to-last sentence, from :</p>
<blockquote>
  <p>If the size of the space requested is zero, the value returned shall not be
  a null pointer value (4.10).</p>
</blockquote>
<p>to:</p>
<blockquote>
  <p>Even if the size of the space requested is zero, the request can fail. If
  the request succeeds, the value returned shall be a non-null pointer value
  (4.10) p0 different from any previously returned value p1, unless that value
  p1 was since passed to an operator delete.</p>
</blockquote>
<p>5.3.4/7 currently reads:</p>
<blockquote>
  <p>When the value of the expression in a direct-new-declarator is zero, the
  allocation function is called to allocate an array with no elements. The
  pointer returned by the new-expression is non-null. [Note: If the library
  allocation function is called, the pointer returned is distinct from the
  pointer to any other object.]</p>
</blockquote>
<p>Retain the first sentence, and delete the remainder.</p>
<p>18.5.1 currently has no text. Add the following:</p>
<blockquote>
  <p>Except where otherwise specified, the provisions of 3.7.3 apply to the
  library versions of operator new and operator delete.</p>
</blockquote>
<p>To 18.5.1.3, add the following text:</p>
<blockquote>
  <p>The provisions of 3.7.3 do not apply to these reserved placement forms of
  operator new and operator delete.</p>
</blockquote>


<p><b>Rationale:</b></p>
<p>See 99-0040/N1216, October 22, 1999, by Stephen D. Clamage for the analysis
supporting to the proposed resolution.</p>





<hr>
<h3><a name="11"></a>11. Bitset minor problems</h3>
<p><b>Section:</b> 20.5 [template.bitset] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 1998-01-22 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#template.bitset">issues</a> in [template.bitset].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>(1) bitset&lt;&gt;::operator[] is mentioned in the class synopsis (23.3.5), but it is
not documented in 23.3.5.2. </p>

<p>(2) The class synopsis only gives a single signature for bitset&lt;&gt;::operator[],
reference operator[](size_t pos). This doesn't make much sense. It ought to be overloaded
on const. reference operator[](size_t pos); bool operator[](size_t pos) const. </p>

<p>(3) Bitset's stream input function (23.3.5.3) ought to skip all whitespace before
trying to extract 0s and 1s. The standard doesn't explicitly say that, though. This should
go in the Effects clause.</p>


<p><b>Proposed resolution:</b></p>
<p>ITEMS 1 AND 2:<br>
<br>
In the bitset synopsis (20.5 [template.bitset]), 
replace the member function <br>
<br>
<tt>&nbsp;&nbsp;&nbsp; reference operator[](size_t pos);<br>
</tt><br>
with the two member functions<br>
<br>
<tt>&nbsp;&nbsp;&nbsp; bool operator[](size_t pos) const; <br>
&nbsp;&nbsp;&nbsp; reference operator[](size_t pos); <br>
</tt><br>
Add the following text at the end of 20.5.2 [bitset.members], 
immediately after paragraph 45:</p>

<blockquote>
  <p><tt>bool operator[](size_t pos) const;</tt><br>
  Requires: pos is valid<br>
  Throws: nothing<br>
  Returns: <tt>test(pos)</tt><br>
  <br>
  <tt>bitset&lt;N&gt;::reference operator[](size_t pos);</tt> <br>
  Requires: pos is valid<br>
  Throws: nothing<br>
  Returns: An object of type <tt>bitset&lt;N&gt;::reference</tt> such that <tt>(*this)[pos]
  == this-&gt;test(pos)</tt>, and such that <tt>(*this)[pos] = val</tt> is equivalent to <tt>this-&gt;set(pos,
  val);</tt></p>
</blockquote>


<p><b>Rationale:</b></p>
<p>The LWG believes Item 3 is not a defect. "Formatted
input" implies the desired semantics. See 27.7.1.2 [istream.formatted].
</p>





<hr>
<h3><a name="13"></a>13. Eos refuses to die</h3>
<p><b>Section:</b> 27.7.1.2.3 [istream::extractors] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> William M. Miller <b>Opened:</b> 1998-03-03 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#istream::extractors">issues</a> in [istream::extractors].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>In 27.6.1.2.3, there is a reference to "eos", which is
the only one in the whole draft (at least using Acrobat search), so
it's undefined. </p>


<p><b>Proposed resolution:</b></p>
<p>In 27.7.1.2.3 [istream::extractors], replace "eos" with
"charT()"</p>





<hr>
<h3><a name="14"></a>14. Locale::combine should be const</h3>
<p><b>Section:</b> 22.3.1.3 [locale.members] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Nathan Myers <b>Opened:</b> 1998-08-06 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.members">issues</a> in [locale.members].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>locale::combine is the only member function of locale (other than constructors and
destructor) that is not const. There is no reason for it not to be const, and good reasons
why it should have been const. Furthermore, leaving it non-const conflicts with 22.1.1
paragraph 6: "An instance of a locale is immutable." </p>

<p>History: this member function originally was a constructor. it happened that the
interface it specified had no corresponding language syntax, so it was changed to a member
function. As constructors are never const, there was no "const" in the interface
which was transformed into member "combine". It should have been added at that
time, but the omission was not noticed. </p>


<p><b>Proposed resolution:</b></p>
<p>In 22.3.1 [locale] and also in 22.3.1.3 [locale.members], add 
"const" to the declaration of member combine: </p>
<blockquote>
  <pre>template &lt;class Facet&gt; locale combine(const locale&amp; other) const; </pre>
</blockquote>





<hr>
<h3><a name="15"></a>15. Locale::name requirement inconsistent</h3>
<p><b>Section:</b> 22.3.1.3 [locale.members] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Nathan Myers <b>Opened:</b> 1998-08-06 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.members">issues</a> in [locale.members].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>locale::name() is described as returning a string that can be passed to a locale
constructor, but there is no matching constructor. </p>


<p><b>Proposed resolution:</b></p>
<p>In 22.3.1.3 [locale.members], paragraph 5, replace
"<tt>locale(name())</tt>" with
"<tt>locale(name().c_str())</tt>".
</p>





<hr>
<h3><a name="16"></a>16. Bad ctype_byname&lt;char&gt; decl</h3>
<p><b>Section:</b> 22.4.1.4 [locale.codecvt] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Nathan Myers <b>Opened:</b> 1998-08-06 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.codecvt">issues</a> in [locale.codecvt].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>The new virtual members ctype_byname&lt;char&gt;::do_widen and do_narrow did not get
edited in properly. Instead, the member do_widen appears four times, with wrong argument
lists. </p>


<p><b>Proposed resolution:</b></p>
<p>The correct declarations for the overloaded members
<tt>do_narrow</tt> and <tt>do_widen</tt> should be copied 
from 22.4.1.3 [facet.ctype.special].</p>





<hr>
<h3><a name="17"></a>17. Bad bool parsing</h3>
<p><b>Section:</b> 22.4.2.1.2 [facet.num.get.virtuals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Nathan Myers <b>Opened:</b> 1998-08-06 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#facet.num.get.virtuals">issues</a> in [facet.num.get.virtuals].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>This section describes the process of parsing a text boolean value from the input
stream. It does not say it recognizes either of the sequences "true" or
"false" and returns the corresponding bool value; instead, it says it recognizes
only one of those sequences, and chooses which according to the received value of a
reference argument intended for returning the result, and reports an error if the other
sequence is found. (!) Furthermore, it claims to get the names from the ctype&lt;&gt;
facet rather than the numpunct&lt;&gt; facet, and it examines the "boolalpha"
flag wrongly; it doesn't define the value "loc"; and finally, it computes
wrongly whether to use numeric or "alpha" parsing.<br>
<br>
I believe the correct algorithm is "as if": </p>

<pre>  // in, err, val, and str are arguments.
  err = 0;
  const numpunct&lt;charT&gt;&amp; np = use_facet&lt;numpunct&lt;charT&gt; &gt;(str.getloc());
  const string_type t = np.truename(), f = np.falsename();
  bool tm = true, fm = true;
  size_t pos = 0;
  while (tm &amp;&amp; pos &lt; t.size() || fm &amp;&amp; pos &lt; f.size()) {
    if (in == end) { err = str.eofbit; }
    bool matched = false;
    if (tm &amp;&amp; pos &lt; t.size()) {
      if (!err &amp;&amp; t[pos] == *in) matched = true;
      else tm = false;
    }
    if (fm &amp;&amp; pos &lt; f.size()) {
      if (!err &amp;&amp; f[pos] == *in) matched = true;
      else fm = false;
    }
    if (matched) { ++in; ++pos; }
    if (pos &gt; t.size()) tm = false;
    if (pos &gt; f.size()) fm = false;
  }
  if (tm == fm || pos == 0) { err |= str.failbit; }
  else                      { val = tm; }
  return in;</pre>

<p>Notice this works reasonably when the candidate strings are both empty, or equal, or
when one is a substring of the other. The proposed text below captures the logic of the
code above.</p>


<p><b>Proposed resolution:</b></p>
<p>In 22.4.2.1.2 [facet.num.get.virtuals], in the first line of paragraph 14,
change "&amp;&amp;" to "&amp;".</p>

<p>Then, replace paragraphs 15 and 16 as follows:</p>

<blockquote>

  <p>Otherwise target sequences are determined "as if" by
  calling the members <tt>falsename()</tt> and
  <tt>truename()</tt> of the facet obtained by
  <tt>use_facet&lt;numpunct&lt;charT&gt;&nbsp;&gt;(str.getloc())</tt>.  
  Successive characters in the range <tt>[in,end)</tt> (see
  [lib.sequence.reqmts]) are obtained and matched against
  corresponding positions in the target sequences only as necessary to
  identify a unique match. The input iterator <tt>in</tt> is
  compared to <tt>end</tt> only when necessary to obtain a
  character. If and only if a target sequence is uniquely matched,
  <tt>val</tt> is set to the corresponding value.</p>

</blockquote>

<blockquote>
  <p>The <tt>in</tt> iterator is always left pointing one position beyond the last character
  successfully matched. If <tt>val</tt> is set, then err is set to <tt>str.goodbit</tt>; or to
  <tt>str.eofbit</tt> if, when seeking another character to match, it is found that
  <tt>(in==end)</tt>. If <tt>val</tt> is not set, then <i>err</i> is set to <tt>str.failbit</tt>; or to
  <tt>(str.failbit|str.eofbit)</tt>if
  the reason for the failure was that <tt>(in==end)</tt>. [Example: for targets
  <tt>true</tt>:"a" and <tt>false</tt>:"abb", the input sequence "a" yields
  <tt>val==true</tt> and <tt>err==str.eofbit</tt>; the input sequence "abc" yields
  <tt>err=str.failbit</tt>, with <tt>in</tt> ending at the 'c' element. For targets
  <tt>true</tt>:"1"
  and <tt>false</tt>:"0", the input sequence "1" yields <tt>val==true</tt>
  and <tt>err=str.goodbit</tt>. For empty targets (""), any input sequence yields
  <tt>err==str.failbit</tt>. --end example]</p>
</blockquote>





<hr>
<h3><a name="18"></a>18. Get(...bool&amp;) omitted</h3>
<p><b>Section:</b> 22.4.2.1.1 [facet.num.get.members] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Nathan Myers <b>Opened:</b> 1998-08-06 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#facet.num.get.members">issues</a> in [facet.num.get.members].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>In the list of num_get&lt;&gt; non-virtual members on page 22-23, the member
that parses bool values was omitted from the list of definitions of non-virtual
members, though it is listed in the class definition and the corresponding
virtual is listed everywhere appropriate. </p>


<p><b>Proposed resolution:</b></p>
<p>Add at the beginning of 22.4.2.1.1 [facet.num.get.members]
another get member for bool&amp;, copied from the entry in 
22.4.2.1 [locale.num.get].</p>





<hr>
<h3><a name="19"></a>19. "Noconv" definition too vague</h3>
<p><b>Section:</b> 22.4.1.4 [locale.codecvt] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Nathan Myers <b>Opened:</b> 1998-08-06 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.codecvt">issues</a> in [locale.codecvt].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#10">10</a></p>
<p><b>Discussion:</b></p>
<p>
In the definitions of codecvt&lt;&gt;::do_out and do_in, they are
specified to return noconv if "no conversion is
needed". This definition is too vague, and does not say
normatively what is done with the buffers.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change the entry for noconv in the table under paragraph 4 in section 
22.4.1.4.2 [locale.codecvt.virtuals] to read:
</p>
<blockquote>
  <p><tt>noconv</tt>: <tt>internT</tt> and <tt>externT</tt> are the same type,
  and input sequence is identical to converted sequence.</p>
</blockquote>
<p>Change the Note in paragraph 2 to normative text as follows:</p>
<blockquote>
  <p>If returns <tt>noconv</tt>, <tt>internT</tt> and <tt>externT</tt> are the
  same type and the converted sequence is identical to the input sequence <tt>[from,from_next)</tt>.
  <tt>to_next</tt> is set equal to <tt>to</tt>, the value of <tt>state</tt> is
  unchanged, and there are no changes to the values in <tt>[to, to_limit)</tt>.</p>
</blockquote>





<hr>
<h3><a name="20"></a>20. Thousands_sep returns wrong type</h3>
<p><b>Section:</b> 22.4.3.1.2 [facet.numpunct.virtuals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Nathan Myers <b>Opened:</b> 1998-08-06 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>The synopsis for numpunct&lt;&gt;::do_thousands_sep, and the
definition of numpunct&lt;&gt;::thousands_sep which calls it, specify
that it returns a value of type char_type. Here it is erroneously
described as returning a "string_type". </p>


<p><b>Proposed resolution:</b></p>
<p>In 22.4.3.1.2 [facet.numpunct.virtuals], above paragraph 2, change 
"string_type" to "char_type". </p>





<hr>
<h3><a name="21"></a>21. Codecvt_byname&lt;&gt; instantiations</h3>
<p><b>Section:</b> 22.3.1.1.1 [locale.category] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Nathan Myers <b>Opened:</b> 1998-08-06 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.category">issues</a> in [locale.category].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>In the second table in the section, captioned "Required
instantiations", the instantiations for codecvt_byname&lt;&gt;
have been omitted. These are necessary to allow users to construct a
locale by name from facets. </p>


<p><b>Proposed resolution:</b></p>
<p>Add in 22.3.1.1.1 [locale.category] to the table captioned
"Required instantiations", in the category "ctype"
the lines </p>

<blockquote>
  <pre>codecvt_byname&lt;char,char,mbstate_t&gt;,
codecvt_byname&lt;wchar_t,char,mbstate_t&gt; </pre>
</blockquote>





<hr>
<h3><a name="22"></a>22. Member open vs. flags</h3>
<p><b>Section:</b> 27.9.1.9 [ifstream.members] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Nathan Myers <b>Opened:</b> 1998-08-06 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#ifstream.members">issues</a> in [ifstream.members].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>The description of basic_istream&lt;&gt;::open leaves unanswered questions about how it
responds to or changes flags in the error status for the stream. A strict reading
indicates that it ignores the bits and does not change them, which confuses users who do
not expect eofbit and failbit to remain set after a successful open. There are three
reasonable resolutions: 1) status quo 2) fail if fail(), ignore eofbit 3) clear failbit
and eofbit on call to open(). </p>


<p><b>Proposed resolution:</b></p>
<p>In 27.9.1.9 [ifstream.members] paragraph 3, <i>and</i> in 27.9.1.13 [ofstream.members] paragraph 3, under open() effects, add a footnote:
</p>

<blockquote>
  <p>A successful open does not change the error state.</p>
</blockquote>


<p><b>Rationale:</b></p>
<p>This may seem surprising to some users, but it's just an instance
of a general rule: error flags are never cleared by the
implementation. The only way error flags are are ever cleared is if
the user explicitly clears them by hand.</p>

<p>The LWG believed that preserving this general rule was
important enough so that an exception shouldn't be made just for this
one case.  The resolution of this issue clarifies what the LWG
believes to have been the original intent.</p>






<hr>
<h3><a name="23"></a>23. Num_get overflow result</h3>
<p><b>Section:</b> 22.4.2.1.2 [facet.num.get.virtuals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Nathan Myers <b>Opened:</b> 1998-08-06 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#facet.num.get.virtuals">issues</a> in [facet.num.get.virtuals].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>The current description of numeric input does not account for the
possibility of overflow. This is an implicit result of changing the
description to rely on the definition of scanf() (which fails to
report overflow), and conflicts with the documented behavior of
traditional and current implementations. </p>

<p>Users expect, when reading a character sequence that results in a
value unrepresentable in the specified type, to have an error
reported. The standard as written does not permit this. </p>

<p><b>Further comments from Dietmar:</b></p>

<p>
I don't feel comfortable with the proposed resolution to issue 23: It
kind of simplifies the issue to much. Here is what is going on:
</p>

<p>
Currently, the behavior of numeric overflow is rather counter intuitive
and hard to trace, so I will describe it briefly:
</p>

<ul>
  <li>
    According to 22.4.2.1.2 [facet.num.get.virtuals]
    paragraph 11 <tt>failbit</tt> is set if <tt>scanf()</tt> would
    return an input error; otherwise a value is converted to the rules
    of <tt>scanf</tt>.
  </li>
  <li> 
    <tt>scanf()</tt> is defined in terms of <tt>fscanf()</tt>. 
  </li>
  <li>
    <tt>fscanf()</tt> returns an input failure if during conversion no
    character matching the conversion specification could be extracted
    before reaching EOF. This is the only reason for <tt>fscanf()</tt>
    to fail due to an input error and clearly does not apply to the case
    of overflow.
  </li>
  <li>
    Thus, the conversion is performed according to the rules of
    <tt>fscanf()</tt> which basically says that <tt>strtod</tt>,
    <tt>strtol()</tt>, etc. are to be used for the conversion.
  </li>
  <li>
    The <tt>strtod()</tt>, <tt>strtol()</tt>, etc. functions consume as
    many matching characters as there are and on overflow continue to
    consume matching characters but also return a value identical to
    the maximum (or minimum for signed types if there was a leading minus)
    value of the corresponding type and set <tt>errno</tt> to <tt>ERANGE</tt>.
  </li>
  <li>
    Thus, according to the current wording in the standard, overflows
    can be detected! All what is to be done is to check <tt>errno</tt>
    after reading an element and, of course, clearing <tt>errno</tt>
    before trying a conversion. With the current wording, it can be
    detected whether the overflow was due to a positive or negative
    number for signed types.
  </li>
</ul>

<p><b>Further discussion from Redmond:</b></p>

<p>The basic problem is that we've defined our behavior,
including our error-reporting behavior, in terms of C90.  However,
C90's method of reporting overflow in scanf is not technically an
"input error".  The <tt>strto_*</tt> functions are more precise.</p>

<p>There was general consensus that <tt>failbit</tt> should be set
upon overflow.  We considered three options based on this:</p>
<ol>
<li>Set failbit upon conversion error (including overflow), and 
    don't store any value.</li>
<li>Set failbit upon conversion error, and also set <tt>errno</tt> to 
    indicated the precise nature of the error.</li>
<li>Set failbit upon conversion error.  If the error was due to
    overflow, store +-numeric_limits&lt;T&gt;::max() as an
    overflow indication.</li>
</ol>

<p>Straw poll: (1) 5; (2) 0; (3) 8.</p>


<p>Discussed at Lillehammer.  General outline of what we want the
  solution to look like: we want to say that overflow is an error, and
  provide a way to distinguish overflow from other kinds of errors.
  Choose candidate field the same way scanf does, but don't describe
  the rest of the process in terms of format.  If a finite input field
  is too large (positive or negative) to be represented as a finite
  value, then set failbit and assign the nearest representable value.
  Bill will provide wording.</p>

<p>
Discussed at Toronto:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2327.pdf">N2327</a>
is in alignment with the direction we wanted to go with in Lillehammer.  Bill
to work on.
</p>



<p><b>Proposed resolution:</b></p>

<p>
Change 22.4.2.1.2 [facet.num.get.virtuals], end of p3:
</p>

<blockquote>
<p>
<b>Stage 3:</b> <del>The result of stage 2 processing can be one of</del>
<ins>The sequence of <tt>char</tt>s accumulated in stage 2 (the field) is
converted to a numeric value by the rules of one of the functions declared
in the header <tt>&lt;cstdlib&gt;</tt>:</ins>
</p>
<ul>
<li>
<del>A sequence of <tt>char</tt>s has been accumulated in stage 2 that is
converted (according to the rules of <tt>scanf</tt>) to a value of the
type of <i>val</i>. This value is stored in <i>val</i> and <tt>ios_base::goodbit</tt> is
stored in <i>err</i>.</del>
<ins>For a signed integer value, the function <tt>strtoll</tt>.</ins>
</li>
<li>
<del>The sequence of <tt>char</tt>s accumulated in stage 2 would have caused
<tt>scanf</tt> to report an input failure. <tt>ios_base::failbit</tt> is
assigned to <i>err</i>.</del>
<ins>For an unsigned integer value, the function <tt>strtoull</tt>.</ins>
</li>
<li>
<ins>For a floating-point value, the function <tt>strtold</tt>.</ins>
</li>
</ul>
<p>
<ins>The numeric value to be stored can be one of:</ins>
</p>
<ul>
<li><ins>zero, if the conversion function fails to convert the entire field.
<tt>ios_base::failbit</tt> is assigned to err.</ins></li>
<li><ins>the most positive representable value, if the field represents a value
too large positive to be represented in <i>val</i>. <tt>ios_base::failbit</tt> is assigned
to <i>err</i>.</ins></li>
<li><ins>the most negative representable value (zero for unsigned integer), if
the field represents a value too large negative to be represented in <i>val</i>.
<tt>ios_base::failbit</tt> is assigned to <i>err</i>.</ins></li>
<li><ins>the converted value, otherwise.</ins></li>
</ul>

<p><ins>
The resultant numeric value is stored in <i>val</i>.
</ins></p>
</blockquote>

<p>
Change 22.4.2.1.2 [facet.num.get.virtuals], p6-p7:
</p>

<blockquote>
<pre>iter_type do_get(iter_type <i>in</i>, iter_type <i>end</i>, ios_base&amp; <i>str</i>, 
                 ios_base::iostate&amp; <i>err</i>, bool&amp; <i>val</i>) const;
</pre>
<blockquote>
<p>
-6- <i>Effects:</i> If
<tt>(<i>str</i>.flags()&amp;ios_base::boolalpha)==0</tt> then input
proceeds as it would for a <tt>long</tt> except that if a value is being
stored into <i>val</i>, the value is determined according to the
following: If the value to be stored is 0 then <tt>false</tt> is stored.
If the value is 1 then <tt>true</tt> is stored. Otherwise
<del><tt><i>err</i>|=ios_base::failbit</tt> is performed and no value</del> <ins><tt>true</tt></ins> is
stored<del>.</del> <ins>and <tt>ios_base::failbit</tt> is assigned to <i>err</i>.</ins>
</p>
<p>
-7- Otherwise target sequences are determined "as if" by calling the
members <tt>falsename()</tt> and <tt>truename()</tt> of the facet
obtained by <tt>use_facet&lt;numpunct&lt;charT&gt;
&gt;(<i>str</i>.getloc())</tt>. Successive characters in the range
<tt>[<i>in</i>,<i>end</i>)</tt> (see 23.1.1) are obtained and matched
against corresponding positions in the target sequences only as
necessary to identify a unique match. The input iterator <i>in</i> is
compared to <i>end</i> only when necessary to obtain a character. If <del>and
only if</del> a target sequence is uniquely matched, <i>val</i> is set to the
corresponding value. <ins>Otherwise <tt>false</tt> is stored and <tt>ios_base::failbit</tt>
is assigned to <i>err</i>.</ins>
</p>
</blockquote>
</blockquote>





<hr>
<h3><a name="24"></a>24. "do_convert" doesn't exist</h3>
<p><b>Section:</b> 22.4.1.4 [locale.codecvt] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Nathan Myers <b>Opened:</b> 1998-08-06 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.codecvt">issues</a> in [locale.codecvt].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#72">72</a></p>
<p><b>Discussion:</b></p>
<p>The description of codecvt&lt;&gt;::do_out and do_in mentions a
symbol "do_convert" which is not defined in the
standard. This is a leftover from an edit, and should be "do_in
and do_out". </p>


<p><b>Proposed resolution:</b></p>
<p>In 22.4.1.4 [locale.codecvt], paragraph 3, change
"do_convert" to "do_in or do_out". Also, in 22.4.1.4.2 [locale.codecvt.virtuals], change "do_convert()" to "do_in
or do_out". </p>





<hr>
<h3><a name="25"></a>25. String operator&lt;&lt; uses width() value wrong</h3>
<p><b>Section:</b> 21.4.8.9 [string.io] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Nathan Myers <b>Opened:</b> 1998-08-06 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#string.io">issues</a> in [string.io].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#67">67</a></p>
<p><b>Discussion:</b></p>
<p>In the description of operator&lt;&lt; applied to strings, the standard says that uses
the smaller of os.width() and str.size(), to pad "as described in stage 3"
elsewhere; but this is inconsistent, as this allows no possibility of space for padding. </p>


<p><b>Proposed resolution:</b></p>
<p>Change 21.4.8.9 [string.io]  paragraph 4 from:<br>
<br>
&nbsp;&nbsp;&nbsp; "... where <tt>n</tt> is the smaller of <tt>os.width()</tt> and <tt>str.size()</tt>;
..."<br>
<br>
to: <br>
<br>
&nbsp;&nbsp;&nbsp; "... where <tt>n</tt> is the larger of <tt>os.width()</tt> and <tt>str.size()</tt>;
..."</p>





<hr>
<h3><a name="26"></a>26. Bad sentry example</h3>
<p><b>Section:</b> 27.7.1.1.3 [istream::sentry] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Nathan Myers <b>Opened:</b> 1998-08-06 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#istream::sentry">issues</a> in [istream::sentry].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>In paragraph 6, the code in the example: </p>

<pre>  template &lt;class charT, class traits = char_traits&lt;charT&gt; &gt;
  basic_istream&lt;charT,traits&gt;::sentry(
           basic_istream&lt;charT,traits&gt;&amp; is, bool noskipws = false) {
      ...
      int_type c;
      typedef ctype&lt;charT&gt; ctype_type;
      const ctype_type&amp; ctype = use_facet&lt;ctype_type&gt;(is.getloc());
      while ((c = is.rdbuf()-&gt;snextc()) != traits::eof()) {
        if (ctype.is(ctype.space,c)==0) {
          is.rdbuf()-&gt;sputbackc (c);
          break;
        }
      }
      ...
   }</pre>

<p>fails to demonstrate correct use of the facilities described. In
particular, it fails to use traits operators, and specifies incorrect
semantics. (E.g. it specifies skipping over the first character in the
sequence without examining it.) </p>


<p><b>Proposed resolution:</b></p>
<p>Remove the example above from 27.7.1.1.3 [istream::sentry]
paragraph 6.</p>


<p><b>Rationale:</b></p>
<p>The originally proposed replacement code for the example was not
correct. The LWG tried in Kona and again in Tokyo to correct it
without success. In Tokyo, an implementor reported that actual working
code ran over one page in length and was quite complicated. The LWG
decided that it would be counter-productive to include such a lengthy
example, which might well still contain errors.</p>





<hr>
<h3><a name="27"></a>27. String::erase(range) yields wrong iterator</h3>
<p><b>Section:</b> 21.4.6.5 [string::erase] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Nathan Myers <b>Opened:</b> 1998-08-06 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#string::erase">issues</a> in [string::erase].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>The string::erase(iterator first, iterator last) is specified to return an element one
place beyond the next element after the last one erased. E.g. for the string
"abcde", erasing the range ['b'..'d') would yield an iterator for element 'e',
while 'd' has not been erased. </p>


<p><b>Proposed resolution:</b></p>
<p>In 21.4.6.5 [string::erase], paragraph 10, change: </p>

<blockquote>
  <p>Returns: an iterator which points to the element immediately following _last_ prior to
  the element being erased. </p>
</blockquote>

<p>to read </p>

<blockquote>
  <p>Returns: an iterator which points to the element pointed to by _last_ prior to the
  other elements being erased. </p>
</blockquote>





<hr>
<h3><a name="28"></a>28. Ctype&lt;char&gt;is ambiguous</h3>
<p><b>Section:</b> 22.4.1.3.2 [facet.ctype.char.members] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Nathan Myers <b>Opened:</b> 1998-08-06 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#facet.ctype.char.members">issues</a> in [facet.ctype.char.members].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#236">236</a></p>
<p><b>Discussion:</b></p>
<p>The description of the vector form of ctype&lt;char&gt;::is can be interpreted to mean
something very different from what was intended. Paragraph 4 says </p>

<blockquote>
  <p>Effects: The second form, for all *p in the range [low, high), assigns vec[p-low] to
  table()[(unsigned char)*p]. </p>
</blockquote>

<p>This is intended to copy the value indexed from table()[] into the place identified in
vec[]. </p>


<p><b>Proposed resolution:</b></p>
<p>Change 22.4.1.3.2 [facet.ctype.char.members], paragraph 4, to read </p>

<blockquote>
  <p>Effects: The second form, for all *p in the range [low, high), assigns into vec[p-low]
  the value table()[(unsigned char)*p]. </p>
</blockquote>





<hr>
<h3><a name="29"></a>29. Ios_base::init doesn't exist</h3>
<p><b>Section:</b> 27.4.1 [narrow.stream.objects] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Nathan Myers <b>Opened:</b> 1998-08-06 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#narrow.stream.objects">issues</a> in [narrow.stream.objects].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>Sections 27.4.1 [narrow.stream.objects] and 27.4.2 [wide.stream.objects] mention
a function ios_base::init, which is not defined. Probably they mean
basic_ios&lt;&gt;::init, defined in 27.5.4.1 [basic.ios.cons],
paragraph 3. </p>


<p><b>Proposed resolution:</b></p>
<p>[R12: modified to include paragraph 5.]</p>

<p>In 27.4.1 [narrow.stream.objects] paragraph 2 and 5, change </p>

<blockquote>
  <p>ios_base::init </p>
</blockquote>

<p>to </p>

<blockquote>
  <p>basic_ios&lt;char&gt;::init </p>
</blockquote>

<p>Also, make a similar change in 27.4.2 [wide.stream.objects] except it
should read </p>

<blockquote>
  <p>basic_ios&lt;wchar_t&gt;::init </p>
</blockquote>





<hr>
<h3><a name="30"></a>30. Wrong header for LC_*</h3>
<p><b>Section:</b> 22.3.1.1.1 [locale.category] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Nathan Myers <b>Opened:</b> 1998-08-06 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.category">issues</a> in [locale.category].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>Paragraph 2 implies that the C macros LC_CTYPE etc. are defined in &lt;cctype&gt;,
where they are in fact defined elsewhere to appear in &lt;clocale&gt;. </p>


<p><b>Proposed resolution:</b></p>
<p>In 22.3.1.1.1 [locale.category], paragraph 2, change
"&lt;cctype&gt;" to read "&lt;clocale&gt;". </p>





<hr>
<h3><a name="31"></a>31. Immutable locale values</h3>
<p><b>Section:</b> 22.3.1 [locale] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Nathan Myers <b>Opened:</b> 1998-08-06 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale">issues</a> in [locale].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#378">378</a></p>
<p><b>Discussion:</b></p>
<p>Paragraph 6, says "An instance of <tt>locale</tt> is
<i>immutable</i>; once a facet reference is obtained from it,
...". This has caused some confusion, because locale variables
are manifestly assignable. </p>


<p><b>Proposed resolution:</b></p>
<p>In 22.3.1 [locale] replace paragraph 6</p>

<blockquote>
  <p>An instance of <tt>locale</tt> is immutable; once a facet
  reference is obtained from it, that reference remains usable as long
  as the locale value itself exists.</p>
</blockquote>

<p>with</p>

<blockquote>
  <p>Once a facet reference is obtained from a locale object by
  calling use_facet&lt;&gt;, that reference remains usable, and the
  results from member functions of it may be cached and re-used, as
  long as some locale object refers to that facet.</p>
</blockquote>





<hr>
<h3><a name="32"></a>32. Pbackfail description inconsistent</h3>
<p><b>Section:</b> 27.6.2.4.4 [streambuf.virt.pback] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Nathan Myers <b>Opened:</b> 1998-08-06 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>The description of the required state before calling virtual member
basic_streambuf&lt;&gt;::pbackfail requirements is inconsistent with the conditions
described in 27.5.2.2.4 [lib.streambuf.pub.pback] where member sputbackc calls it.
Specifically, the latter says it calls pbackfail if: </p>

<p>&nbsp;&nbsp;&nbsp; traits::eq(c,gptr()[-1]) is false </p>

<p>where pbackfail claims to require: </p>

<p>&nbsp;&nbsp;&nbsp; traits::eq(*gptr(),traits::to_char_type(c)) returns false </p>

<p>It appears that the pbackfail description is wrong. </p>


<p><b>Proposed resolution:</b></p>
<p>In 27.6.2.4.4 [streambuf.virt.pback], paragraph 1, change:</p>

<blockquote>
  <p>"<tt>traits::eq(*gptr(),traits::to_char_type( c))</tt>"</p>
</blockquote>

<p>to </p>

<blockquote>
  <p>"<tt>traits::eq(traits::to_char_type(c),gptr()[-1])</tt>"
  </p>
</blockquote>


<p><b>Rationale:</b></p>
<p>Note deliberate reordering of arguments for clarity in addition to the correction of
the argument value.</p>





<hr>
<h3><a name="33"></a>33. Codecvt&lt;&gt; mentions from_type</h3>
<p><b>Section:</b> 22.4.1.4 [locale.codecvt] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Nathan Myers <b>Opened:</b> 1998-08-06 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.codecvt">issues</a> in [locale.codecvt].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#43">43</a></p>
<p><b>Discussion:</b></p>
<p>In the table defining the results from do_out and do_in, the specification for the
result <i>error</i> says </p>

<blockquote>
  <p>encountered a from_type character it could not convert </p>
</blockquote>

<p>but from_type is not defined. This clearly is intended to be an externT for do_in, or
an internT for do_out. </p>


<p><b>Proposed resolution:</b></p>
<p>In 22.4.1.4.2 [locale.codecvt.virtuals] paragraph 4, replace the definition
in the table for the case of _error_ with </p>

<blockquote>
  <p>encountered a character in <tt>[from,from_end)</tt> that it could not convert. </p>
</blockquote>





<hr>
<h3><a name="34"></a>34. True/falsename() not in ctype&lt;&gt;</h3>
<p><b>Section:</b> 22.4.2.2.2 [facet.num.put.virtuals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Nathan Myers <b>Opened:</b> 1998-08-06 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#facet.num.put.virtuals">issues</a> in [facet.num.put.virtuals].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>In paragraph 19, Effects:, members truename() and falsename are used from facet
ctype&lt;charT&gt;, but it has no such members. Note that this is also a problem in
22.2.2.1.2, addressed in (4). </p>


<p><b>Proposed resolution:</b></p>
<p>In 22.4.2.2.2 [facet.num.put.virtuals], paragraph 19, in the Effects:
clause for member put(...., bool), replace the initialization of the
string_type value s as follows: </p>

<blockquote>
  <pre>const numpunct&amp; np = use_facet&lt;numpunct&lt;charT&gt; &gt;(loc);
string_type s = val ? np.truename() : np.falsename(); </pre>
</blockquote>





<hr>
<h3><a name="35"></a>35. No manipulator unitbuf in synopsis</h3>
<p><b>Section:</b> 27.5 [iostreams.base] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Nathan Myers <b>Opened:</b> 1998-08-06 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#iostreams.base">issues</a> in [iostreams.base].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>In 27.5.5.1 [fmtflags.manip], we have a definition for a manipulator
named "unitbuf". Unlike other manipulators, it's not listed
in synopsis. Similarly for "nounitbuf". </p>


<p><b>Proposed resolution:</b></p>
<p>Add to the synopsis for &lt;ios&gt; in 27.5 [iostreams.base], after
the entry for "nouppercase", the prototypes: </p>

<blockquote>
  <pre>ios_base&amp; unitbuf(ios_base&amp; str);
ios_base&amp; nounitbuf(ios_base&amp; str); </pre>
</blockquote>





<hr>
<h3><a name="36"></a>36. Iword &amp; pword storage lifetime omitted</h3>
<p><b>Section:</b> 27.5.2.5 [ios.base.storage] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Nathan Myers <b>Opened:</b> 1998-08-06 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#ios.base.storage">issues</a> in [ios.base.storage].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>In the definitions for ios_base::iword and pword, the lifetime of the storage is
specified badly, so that an implementation which only keeps the last value stored appears
to conform. In particular, it says: </p>

<p>The reference returned may become invalid after another call to the object's iword
member with a different index ... </p>

<p>This is not idle speculation; at least one implementation was done this way. </p>


<p><b>Proposed resolution:</b></p>
<p>Add in 27.5.2.5 [ios.base.storage], in both paragraph 2 and also in
paragraph 4, replace the sentence: </p>

<blockquote>
  <p>The reference returned may become invalid after another call to the object's iword
  [pword] member with a different index, after a call to its copyfmt member, or when the
  object is destroyed. </p>
</blockquote>

<p>with: </p>

<blockquote>
  <p>The reference returned is invalid after any other operations on the object. However,
  the value of the storage referred to is retained, so that until the next call to copyfmt,
  calling iword [pword] with the same index yields another reference to the same value. </p>
</blockquote>

<p>substituting "iword" or "pword" as appropriate. </p>





<hr>
<h3><a name="37"></a>37. Leftover "global" reference</h3>
<p><b>Section:</b> 22.3.1 [locale] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Nathan Myers <b>Opened:</b> 1998-08-06 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale">issues</a> in [locale].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>In the overview of locale semantics, paragraph 4, is the sentence </p>

<blockquote>
  <p>If Facet is not present in a locale (or, failing that, in the global locale), it throws
  the standard exception bad_cast. </p>
</blockquote>

<p>This is not supported by the definition of use_facet&lt;&gt;, and represents semantics
from an old draft. </p>


<p><b>Proposed resolution:</b></p>
<p>In 22.3.1 [locale], paragraph 4, delete the parenthesized
expression </p>

<blockquote>
  <p>(or, failing that, in the global locale) </p>
</blockquote>





<hr>
<h3><a name="38"></a>38. Facet definition incomplete</h3>
<p><b>Section:</b> 22.3.2 [locale.global.templates] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Nathan Myers <b>Opened:</b> 1998-08-06 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>It has been noticed by Esa Pulkkinen that the definition of
"facet" is incomplete. In particular, a class derived from
another facet, but which does not define a member <i>id</i>, cannot
safely serve as the argument <i>F</i> to use_facet&lt;F&gt;(loc),
because there is no guarantee that a reference to the facet instance
stored in <i>loc</i> is safely convertible to <i>F</i>. </p>


<p><b>Proposed resolution:</b></p>
<p>In the definition of std::use_facet&lt;&gt;(), replace the text in paragraph 1 which
reads: </p>

<blockquote>
  <p>Get a reference to a facet of a locale. </p>
</blockquote>

<p>with: </p>

<blockquote>
  <p>Requires: <tt>Facet</tt> is a facet class whose definition
  contains the public static member <tt>id</tt> as defined in 22.3.1.1.2 [locale.facet]. </p>
</blockquote>

<p><i>[
Kona: strike as overspecification the text "(not inherits)"
from the original resolution, which read "... whose definition
contains (not inherits) the public static member
<tt>id</tt>..."
]</i></p>







<hr>
<h3><a name="39"></a>39. istreambuf_iterator&lt;&gt;::operator++(int) definition garbled</h3>
<p><b>Section:</b> 24.6.3.4 [istreambuf.iterator::op++] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Nathan Myers <b>Opened:</b> 1998-08-06 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>Following the definition of istreambuf_iterator&lt;&gt;::operator++(int) in paragraph
3, the standard contains three lines of garbage text left over from a previous edit. </p>

<blockquote>
  <pre>istreambuf_iterator&lt;charT,traits&gt; tmp = *this;
sbuf_-&gt;sbumpc();
return(tmp); </pre>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>In 24.6.3.4 [istreambuf.iterator::op++], delete the three lines of code at the
end of paragraph 3. </p>





<hr>
<h3><a name="40"></a>40. Meaningless normative paragraph in examples</h3>
<p><b>Section:</b> 22.4.8 [facets.examples] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Nathan Myers <b>Opened:</b> 1998-08-06 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#facets.examples">issues</a> in [facets.examples].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>Paragraph 3 of the locale examples is a description of part of an
implementation technique that has lost its referent, and doesn't mean
anything. </p>


<p><b>Proposed resolution:</b></p>
<p>Delete 22.4.8 [facets.examples] paragraph 3 which begins "This
initialization/identification system depends...", or (at the
editor's option) replace it with a place-holder to keep the paragraph
numbering the same. </p>





<hr>
<h3><a name="41"></a>41. Ios_base needs clear(), exceptions()</h3>
<p><b>Section:</b> 27.5.2 [ios.base] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Nathan Myers <b>Opened:</b> 1998-08-06 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#ios.base">issues</a> in [ios.base].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#157">157</a></p>
<p><b>Discussion:</b></p>
<p>The description of ios_base::iword() and pword() in 27.5.2.4 [ios.members.static], say that if they fail, they "set badbit,
which may throw an exception". However, ios_base offers no
interface to set or to test badbit; those interfaces are defined in
basic_ios&lt;&gt;. </p>


<p><b>Proposed resolution:</b></p>
<p>Change the description in 27.5.2.5 [ios.base.storage] in
paragraph 2, and also in paragraph 4, as follows. Replace</p>

<blockquote>
  <p>If the function fails it sets badbit, which may throw an exception.</p>
</blockquote>

<p>with</p>

<blockquote>
  <p>If the function fails, and <tt>*this</tt> is a base sub-object of
  a <tt>basic_ios&lt;&gt;</tt> object or sub-object, the effect is
  equivalent to calling <tt>basic_ios&lt;&gt;::setstate(badbit)</tt>
  on the derived object (which may throw <tt>failure</tt>).</p>
</blockquote>

<p><i>[Kona: LWG reviewed wording; setstate(failbit) changed to
setstate(badbit).]</i></p>







<hr>
<h3><a name="42"></a>42. String ctors specify wrong default allocator</h3>
<p><b>Section:</b> 21.4 [basic.string] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Nathan Myers <b>Opened:</b> 1998-08-06 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#basic.string">issues</a> in [basic.string].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>The basic_string&lt;&gt; copy constructor: </p>

<pre>basic_string(const basic_string&amp; str, size_type pos = 0,
             size_type n = npos, const Allocator&amp; a = Allocator()); </pre>

<p>specifies an Allocator argument default value that is
counter-intuitive. The natural choice for a the allocator to copy from
is str.get_allocator(). Though this cannot be expressed in
default-argument notation, overloading suffices. </p>

<p>Alternatively, the other containers in Clause 23 (deque, list,
vector) do not have this form of constructor, so it is inconsistent,
and an evident source of confusion, for basic_string&lt;&gt; to have
it, so it might better be removed. </p>


<p><b>Proposed resolution:</b></p>
<p> In 21.4 [basic.string], replace the declaration of the copy
constructor as follows: </p>

<blockquote>
  <pre>basic_string(const basic_string&amp; str);
basic_string(const basic_string&amp; str, size_type pos, size_type n = npos,
             const Allocator&amp; a = Allocator());</pre>
</blockquote>

<p>In 21.4.1 [string.require], replace the copy constructor declaration
as above. Add to paragraph 5, Effects:</p>

<blockquote>
  <p>In the first form, the Allocator value used is copied from
  <tt>str.get_allocator()</tt>.</p>
</blockquote>


<p><b>Rationale:</b></p>
<p>The LWG believes the constructor is actually broken, rather than
just an unfortunate design choice.</p>

<p>The LWG considered two other possible resolutions:</p>

<p>A. In 21.4 [basic.string], replace the declaration of the copy
constructor as follows:</p>

<blockquote>
  <pre>basic_string(const basic_string&amp; str, size_type pos = 0,
             size_type n = npos);
basic_string(const basic_string&amp; str, size_type pos,
             size_type n, const Allocator&amp; a); </pre>
</blockquote>

<p>In 21.4.1 [string.require], replace the copy constructor declaration
as above. Add to paragraph 5, Effects: </p>

<blockquote>
  <p>When no <tt>Allocator</tt> argument is provided, the string is constructed using the
  value <tt>str.get_allocator()</tt>. </p>
</blockquote>

<p>B. In 21.4 [basic.string], and also in 21.4.1 [string.require], replace
the declaration of the copy constructor as follows: </p>

<blockquote>
  <pre>basic_string(const basic_string&amp; str, size_type pos = 0,
             size_type n = npos); </pre>
</blockquote>

<p>The proposed resolution reflects the original intent of the LWG. It
was also noted by Pete Becker that this fix "will cause
a small amount of existing code to now work correctly."</p>

<p><i>[
Kona: issue editing snafu fixed - the proposed resolution now correctly
reflects the LWG consensus.
]</i></p>






<hr>
<h3><a name="44"></a>44. Iostreams use operator== on int_type values</h3>
<p><b>Section:</b> 27 [input.output] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Nathan Myers <b>Opened:</b> 1998-08-06 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#input.output">issues</a> in [input.output].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>Many of the specifications for iostreams specify that character
values or their int_type equivalents are compared using operators ==
or !=, though in other places traits::eq() or traits::eq_int_type is
specified to be used throughout. This is an inconsistency; we should
change uses of == and != to use the traits members instead. </p>


<p><b>Proposed resolution:</b></p>

<p><i>[Pre-Kona: Dietmar supplied wording]</i></p>


<p>List of changes to clause 27:</p>
<ol>
<li>
   In lib.basic.ios.members paragraph 13 (postcondition clause for
   'fill(cT)') change

<blockquote><pre>     fillch == fill()
</pre></blockquote>

   to

<blockquote><pre>     traits::eq(fillch, fill())
</pre></blockquote>


</li>
<li>
   In lib.istream.unformatted paragraph 7 (effects clause for
   'get(cT,streamsize,cT)'), third bullet, change

<blockquote><pre>     c == delim for the next available input character c
</pre></blockquote>

   to

<blockquote><pre>     traits::eq(c, delim) for the next available input character c
</pre></blockquote>

</li>
<li>
   In lib.istream.unformatted paragraph 12 (effects clause for
   'get(basic_streambuf&lt;cT,Tr&gt;&amp;,cT)'), third bullet, change

<blockquote><pre>     c == delim for the next available input character c
</pre></blockquote>

   to

<blockquote><pre>     traits::eq(c, delim) for the next available input character c
</pre></blockquote>

</li>
<li>
   In lib.istream.unformatted paragraph 17 (effects clause for
   'getline(cT,streamsize,cT)'), second bullet, change

<blockquote><pre>     c == delim for the next available input character c
</pre></blockquote>

   to

<blockquote><pre>     traits::eq(c, delim) for the next available input character c
  </pre></blockquote>

</li>
<li>
   In lib.istream.unformatted paragraph 24 (effects clause for
   'ignore(int,int_type)'), second bullet, change

<blockquote><pre>     c == delim for the next available input character c
</pre></blockquote>

   to

<blockquote><pre>     traits::eq_int_type(c, delim) for the next available input
     character c
</pre></blockquote>
  
</li>
<li>
   In lib.istream.unformatted paragraph 25 (notes clause for
   'ignore(int,int_type)'), second bullet, change

<blockquote><pre>     The last condition will never occur if delim == traits::eof()
</pre></blockquote>

   to

<blockquote><pre>     The last condition will never occur if
     traits::eq_int_type(delim, traits::eof()).
</pre></blockquote>

</li>
<li>
   In lib.istream.sentry paragraph 6 (example implementation for the
   sentry constructor) change

<blockquote><pre>     while ((c = is.rdbuf()-&gt;snextc()) != traits::eof()) {
</pre></blockquote>

   to

<blockquote><pre>     while (!traits::eq_int_type(c = is.rdbuf()-&gt;snextc(), traits::eof())) {
</pre></blockquote>

</li>
</ol>

<p>List of changes to Chapter 21:</p>

<ol>
<li>
   In lib.string::find paragraph 1 (effects clause for find()),
   second bullet, change

<blockquote><pre>     at(xpos+I) == str.at(I) for all elements ...
</pre></blockquote>

   to

<blockquote><pre>     traits::eq(at(xpos+I), str.at(I)) for all elements ...
</pre></blockquote>

</li>
<li>
   In lib.string::rfind paragraph 1 (effects clause for rfind()),
   second bullet, change

<blockquote><pre>     at(xpos+I) == str.at(I) for all elements ...
</pre></blockquote>

   to

<blockquote><pre>     traits::eq(at(xpos+I), str.at(I)) for all elements ...
</pre></blockquote>

</li>
<li>
   In lib.string::find.first.of paragraph 1 (effects clause for
   find_first_of()), second bullet, change

<blockquote><pre>     at(xpos+I) == str.at(I) for all elements ...
</pre></blockquote>

   to

<blockquote><pre>     traits::eq(at(xpos+I), str.at(I)) for all elements ...
</pre></blockquote>

</li>
<li>
   In lib.string::find.last.of paragraph 1 (effects clause for
   find_last_of()), second bullet, change

<blockquote><pre>     at(xpos+I) == str.at(I) for all elements ...
</pre></blockquote>

   to

<blockquote><pre>     traits::eq(at(xpos+I), str.at(I)) for all elements ...
</pre></blockquote>

</li>
<li>
   In lib.string::find.first.not.of paragraph 1 (effects clause for
   find_first_not_of()), second bullet, change

<blockquote><pre>     at(xpos+I) == str.at(I) for all elements ...
</pre></blockquote>

   to

<blockquote><pre>     traits::eq(at(xpos+I), str.at(I)) for all elements ...
</pre></blockquote>
</li>

<li>
   In lib.string::find.last.not.of paragraph 1 (effects clause for
   find_last_not_of()), second bullet, change

<blockquote><pre>     at(xpos+I) == str.at(I) for all elements ...
</pre></blockquote>

   to

<blockquote><pre>     traits::eq(at(xpos+I), str.at(I)) for all elements ...
</pre></blockquote>
</li>

<li>
   In lib.string.ios paragraph 5 (effects clause for getline()),
   second bullet, change

<blockquote><pre>     c == delim for the next available input character c 
</pre></blockquote>

   to

<blockquote><pre>     traits::eq(c, delim) for the next available input character c 
</pre></blockquote>
</li>

</ol>

<p>Notes:</p>
<ul>
<li>
  Fixing this issue highlights another sloppyness in
  lib.istream.unformatted paragraph 24: this clause mentions a "character"
  which is then compared to an 'int_type' (see item 5. in the list
  below). It is not clear whether this requires explicit words and
  if so what these words are supposed to be. A similar issue exists,
  BTW, for operator*() of istreambuf_iterator which returns the result
  of sgetc() as a character type (see lib.istreambuf.iterator::op*
  paragraph 1), and for operator++() of istreambuf_iterator which
  passes the result of sbumpc() to a constructor taking a char_type
  (see lib.istreambuf.iterator::operator++ paragraph 3). Similarily, the
  assignment operator ostreambuf_iterator passes a char_type to a function
  taking an int_type (see lib.ostreambuf.iter.ops paragraph 1).
</li>
<li>
  It is inconsistent to use comparisons using the traits functions in
  Chapter 27 while not using them in Chapter 21, especially as some
  of the inconsistent uses actually involve streams (eg. getline() on
  streams). To avoid leaving this issue open still longer due to this
  inconsistency (it is open since 1998), a list of changes to Chapter
  21 is below.
</li>
<li>
  In Chapter 24 there are several places with statements like "the end
  of stream is reached (streambuf_type::sgetc() returns traits::eof())"
  (lib.istreambuf.iterator paragraph 1, lib.ostreambuf.iter.ops
  paragraph 5). It is unclear whether these should be clarified to use
  traits::eq_int_type() for detecting traits::eof().
</li>
</ul>






<hr>
<h3><a name="46"></a>46. Minor Annex D errors</h3>
<p><b>Section:</b> D.9 [depr.str.strstreams] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Brendan Kehoe <b>Opened:</b> 1998-06-01 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p><p>See lib-6522 and edit-814.</p>

<p><b>Proposed resolution:</b></p>
<p>Change D.9.1 [depr.strstreambuf] (since streambuf is a typedef of
basic_streambuf&lt;char&gt;) from:</p>

<pre>         virtual streambuf&lt;char&gt;* setbuf(char* s, streamsize n);</pre>

<p>to:</p>

<pre>         virtual streambuf* setbuf(char* s, streamsize n);</pre>

<p>In D.9.4 [depr.strstream] insert the semicolon now missing after
int_type:</p>

<pre>     namespace std {
       class strstream
         : public basic_iostream&lt;char&gt; {
       public:
         // Types
         typedef char                                char_type;
         typedef typename char_traits&lt;char&gt;::int_type int_type
         typedef typename char_traits&lt;char&gt;::pos_type pos_type;</pre>





<hr>
<h3><a name="47"></a>47. Imbue() and getloc() Returns clauses swapped</h3>
<p><b>Section:</b> 27.5.2.3 [ios.base.locales] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 1998-06-21 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#ios.base.locales">issues</a> in [ios.base.locales].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>Section 27.4.2.3 specifies how imbue() and getloc() work. That
section has two RETURNS clauses, and they make no sense as
stated. They make perfect sense, though, if you swap them. Am I
correct in thinking that paragraphs 2 and 4 just got mixed up by
accident?</p>


<p><b>Proposed resolution:</b></p>
<p>In 27.5.2.3 [ios.base.locales] swap paragraphs 2 and 4.</p>





<hr>
<h3><a name="48"></a>48. Use of non-existent exception constructor</h3>
<p><b>Section:</b> 27.5.2.1.1 [ios::failure] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 1998-06-21 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#ios::failure">issues</a> in [ios::failure].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>27.4.2.1.1, paragraph 2, says that class failure initializes the
base class, exception, with exception(msg). Class exception (see
18.6.1) has no such constructor.</p>


<p><b>Proposed resolution:</b></p>
<p>Replace 27.5.2.1.1 [ios::failure], paragraph 2, with</p>

<blockquote>
  <p>EFFECTS: Constructs an object of class <tt>failure</tt>.</p>
</blockquote>





<hr>
<h3><a name="49"></a>49. Underspecification of ios_base::sync_with_stdio</h3>
<p><b>Section:</b> 27.5.2.4 [ios.members.static] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 1998-06-21 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>Two problems</p>

<p>(1) 27.4.2.4 doesn't say what ios_base::sync_with_stdio(f)
returns. Does it return f, or does it return the previous
synchronization state? My guess is the latter, but the standard
doesn't say so.</p>

<p>(2) 27.4.2.4 doesn't say what it means for streams to be
synchronized with stdio.  Again, of course, I can make some
guesses. (And I'm unhappy about the performance implications of those
guesses, but that's another matter.)</p>


<p><b>Proposed resolution:</b></p>
<p>Change the following sentence in 27.5.2.4 [ios.members.static]
returns clause from:</p>

<blockquote>
  <p><tt>true</tt> if the standard iostream objects (27.3) are
  synchronized and otherwise returns <tt>false</tt>.</p>
</blockquote>

<p>to:</p>

<blockquote>
  <p><tt>true</tt> if the previous state of the standard iostream
  objects (27.3) was synchronized and otherwise returns
  <tt>false</tt>.</p>
</blockquote>

<p>Add the following immediately after 27.5.2.4 [ios.members.static],
paragraph 2:</p>

<blockquote>
<p>When a standard iostream object str is <i>synchronized</i> with a
standard stdio stream f, the effect of inserting a character c by</p>
<pre>  fputc(f, c);
</pre>

<p>is the same as the effect of</p>
<pre>  str.rdbuf()-&gt;sputc(c);
</pre>

<p>for any sequence of characters; the effect of extracting a
character c by</p>
<pre>  c = fgetc(f);
</pre>

<p>is the same as the effect of:</p>
<pre>  c = str.rdbuf()-&gt;sbumpc(c);
</pre>

<p>for any sequences of characters; and the effect of pushing
back a character c by</p>
<pre>  ungetc(c, f);
</pre>

<p>is the same as the effect of</p>
<pre>  str.rdbuf()-&gt;sputbackc(c);
</pre>

<p>for any sequence of characters.  [<i>Footnote</i>: This implies
that operations on a standard iostream object can be mixed arbitrarily
with operations on the corresponding stdio stream.  In practical
terms, synchronization usually means that a standard iostream object
and a standard stdio object share a buffer. <i>--End Footnote</i>]</p>
</blockquote>

<p><i>[pre-Copenhagen: PJP and Matt contributed the definition
of "synchronization"]</i></p>


<p><i>[post-Copenhagen: proposed resolution was revised slightly:
text was added in the non-normative footnote to say that operations
on the two streams can be mixed arbitrarily.]</i></p>






<hr>
<h3><a name="50"></a>50. Copy constructor and assignment operator of ios_base</h3>
<p><b>Section:</b> 27.5.2 [ios.base] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 1998-06-21 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#ios.base">issues</a> in [ios.base].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>As written, ios_base has a copy constructor and an assignment
operator. (Nothing in the standard says it doesn't have one, and all
classes have copy constructors and assignment operators unless you
take specific steps to avoid them.) However, nothing in 27.4.2 says
what the copy constructor and assignment operator do. </p>

<p>My guess is that this was an oversight, that ios_base is, like
basic_ios, not supposed to have a copy constructor or an assignment
operator.</p>

<p>
Jerry Schwarz comments: Yes, its an oversight, but in the opposite
sense to what you're suggesting. At one point there was a definite
intention that you could copy ios_base. It's an easy way to save the
entire state of a stream for future use. As you note, to carry out
that intention would have required a explicit description of the
semantics (e.g. what happens to the iarray and parray stuff).
</p>


<p><b>Proposed resolution:</b></p>
<p>In 27.5.2 [ios.base], class ios_base, specify the copy
constructor and operator= members as being private.</p>


<p><b>Rationale:</b></p>
<p>The LWG believes the difficulty of specifying correct semantics
outweighs any benefit of allowing ios_base objects to be copyable.</p>





<hr>
<h3><a name="51"></a>51. Requirement to not invalidate iterators missing</h3>
<p><b>Section:</b> 23.2 [container.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> David Vandevoorde <b>Opened:</b> 1998-06-23 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#container.requirements">issues</a> in [container.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>The std::sort algorithm can in general only sort a given sequence
by moving around values. The list&lt;&gt;::sort() member on the other
hand could move around values or just update internal pointers. Either
method can leave iterators into the list&lt;&gt; dereferencable, but
they would point to different things. </p>

<p>Does the FDIS mandate anywhere which method should be used for
list&lt;&gt;::sort()?</p>

<p>Matt Austern comments:</p>

<p>I think you've found an omission in the standard. </p>

<p>The library working group discussed this point, and there was
supposed to be a general requirement saying that list, set, map,
multiset, and multimap may not invalidate iterators, or change the
values that iterators point to, except when an operation does it
explicitly. So, for example, insert() doesn't invalidate any iterators
and erase() and remove() only invalidate iterators pointing to the
elements that are being erased. </p>

<p>I looked for that general requirement in the FDIS, and, while I
found a limited form of it for the sorted associative containers, I
didn't find it for list. It looks like it just got omitted. </p>

<p>The intention, though, is that list&lt;&gt;::sort does not
invalidate any iterators and does not change the values that any
iterator points to. There would be no reason to have the member
function otherwise.</p>


<p><b>Proposed resolution:</b></p>
<p>Add a new paragraph at the end of 23.1:</p>

<blockquote>
  <p>Unless otherwise specified (either explicitly or by defining a function in terms of
  other functions), invoking a container member function or passing a container as an
  argument to a library function shall not invalidate iterators to, or change the values of,
  objects within that container. </p>
</blockquote>


<p><b>Rationale:</b></p>
<p>This was US issue CD2-23-011; it was accepted in London but the
change was not made due to an editing oversight. The wording in the
proposed resolution below is somewhat updated from CD2-23-011,
particularly the addition of the phrase "or change the values
of"</p>





<hr>
<h3><a name="52"></a>52. Small I/O problems</h3>
<p><b>Section:</b> 27.5.3.2 [fpos.operations] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 1998-06-23 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#fpos.operations">issues</a> in [fpos.operations].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>First, 27.5.4.1 [basic.ios.cons], table 89. This is pretty obvious:
it should be titled "basic_ios&lt;&gt;() effects", not
"ios_base() effects". </p>

<p>[The second item is a duplicate; see issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#6">6</a> for
resolution.]</p>

<p>Second, 27.5.3.2 [fpos.operations] table 88 . There are a couple
different things wrong with it, some of which I've already discussed
with Jerry, but the most obvious mechanical sort of error is that it
uses expressions like P(i) and p(i), without ever defining what sort
of thing "i" is.
</p>

<p>(The other problem is that it requires support for streampos
arithmetic. This is impossible on some systems, i.e. ones where file
position is a complicated structure rather than just a number. Jerry
tells me that the intention was to require syntactic support for
streampos arithmetic, but that it wasn't actually supposed to do
anything meaningful except on platforms, like Unix, where genuine
arithmetic is possible.) </p>


<p><b>Proposed resolution:</b></p>
<p>Change 27.5.4.1 [basic.ios.cons] table 89 title from
"ios_base() effects" to "basic_ios&lt;&gt;()
effects". </p>





<hr>
<h3><a name="53"></a>53. Basic_ios destructor unspecified</h3>
<p><b>Section:</b> 27.5.4.1 [basic.ios.cons] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 1998-06-23 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#basic.ios.cons">issues</a> in [basic.ios.cons].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>There's nothing in 27.4.4 saying what basic_ios's destructor does.
The important question is whether basic_ios::~basic_ios() destroys
rdbuf().</p>


<p><b>Proposed resolution:</b></p>
<p>Add after 27.5.4.1 [basic.ios.cons] paragraph 2:</p>

<blockquote>
  <p><tt>virtual ~basic_ios();</tt></p>
  <p><b>Notes</b>: The destructor does not destroy <tt>rdbuf()</tt>.</p>
</blockquote>


<p><b>Rationale:</b></p> 
<p>The LWG reviewed the additional question of whether or not
<tt>rdbuf(0)</tt> may set <tt>badbit</tt>.  The answer is
clearly yes; it may be set via <tt>clear()</tt>.  See 27.5.4.2 [basic.ios.members], paragraph 6.  This issue was reviewed at length
by the LWG, which removed from the original proposed resolution a
footnote which incorrectly said "<tt>rdbuf(0)</tt> does not set
<tt>badbit</tt>".</p>





<hr>
<h3><a name="54"></a>54. Basic_streambuf's destructor</h3>
<p><b>Section:</b> 27.6.2.1 [streambuf.cons] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 1998-06-25 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#streambuf.cons">issues</a> in [streambuf.cons].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>The class synopsis for basic_streambuf shows a (virtual)
destructor, but the standard doesn't say what that destructor does. My
assumption is that it does nothing, but the standard should say so
explicitly. </p>


<p><b>Proposed resolution:</b></p>
<p>Add after 27.6.2.1 [streambuf.cons] paragraph 2:</p>

<blockquote>
  <p><tt>virtual&nbsp; ~basic_streambuf();</tt></p>
  <p><b>Effects</b>: None.</p>
</blockquote>





<hr>
<h3><a name="55"></a>55. Invalid stream position is undefined</h3>
<p><b>Section:</b> 27 [input.output] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 1998-06-26 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#input.output">issues</a> in [input.output].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>Several member functions in clause 27 are defined in certain
circumstances to return an "invalid stream position", a term
that is defined nowhere in the standard. Two places (27.5.2.4.2,
paragraph 4, and 27.8.1.4, paragraph 15) contain a cross-reference to
a definition in _lib.iostreams.definitions_, a nonexistent
section. </p>

<p>I suspect that the invalid stream position is just supposed to be
pos_type(-1).  Probably best to say explicitly in (for example)
27.5.2.4.2 that the return value is pos_type(-1), rather than to use
the term "invalid stream position", define that term
somewhere, and then put in a cross-reference. </p>

<p>The phrase "invalid stream position" appears ten times in
the C++ Standard.  In seven places it refers to a return value, and it
should be changed. In three places it refers to an argument, and it
should not be changed. Here are the three places where "invalid
stream position" should not be changed:</p>

<blockquote>
  <p>27.8.1.4 [stringbuf.virtuals], paragraph 14<br>
  27.9.1.5 [filebuf.virtuals], paragraph 14<br>
  D.9.1.3 [depr.strstreambuf.virtuals], paragraph 17
  </p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>In 27.6.2.4.2 [streambuf.virt.buffer], paragraph 4, change "Returns an
object of class pos_type that stores an invalid stream position
(_lib.iostreams.definitions_)" to "Returns
<tt>pos_type(off_type(-1))</tt>".
</p>

<p>In 27.6.2.4.2 [streambuf.virt.buffer], paragraph 6, change "Returns
an object of class pos_type that stores an invalid stream
position" to "Returns <tt>pos_type(off_type(-1))</tt>".</p>

<p>In 27.8.1.4 [stringbuf.virtuals], paragraph 13, change "the object
stores an invalid stream position" to "the return value is
<tt>pos_type(off_type(-1))</tt>". </p>

<p>In 27.9.1.5 [filebuf.virtuals], paragraph 13, change "returns an
invalid stream position (27.4.3)" to "returns
<tt>pos_type(off_type(-1))</tt>" </p>

<p>In 27.9.1.5 [filebuf.virtuals], paragraph 15, change "Otherwise
returns an invalid stream position (_lib.iostreams.definitions_)"
to "Otherwise returns <tt>pos_type(off_type(-1))</tt>"
</p>

<p>In D.9.1.3 [depr.strstreambuf.virtuals], paragraph 15, change "the object
stores an invalid stream position" to "the return value is
<tt>pos_type(off_type(-1))</tt>" </p>

<p>In D.9.1.3 [depr.strstreambuf.virtuals], paragraph 18, change "the object
stores an invalid stream position" to "the return value is
<tt>pos_type(off_type(-1))</tt>"</p>





<hr>
<h3><a name="56"></a>56. Showmanyc's return type</h3>
<p><b>Section:</b> 27.6.2 [streambuf] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 1998-06-29 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#streambuf">issues</a> in [streambuf].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>The class summary for basic_streambuf&lt;&gt;, in 27.5.2, says that
showmanyc has return type int. However, 27.5.2.4.3 says that its
return type is streamsize. </p>


<p><b>Proposed resolution:</b></p>
<p>Change <tt>showmanyc</tt>'s return type in the
27.6.2 [streambuf] class summary to <tt>streamsize</tt>.</p>





<hr>
<h3><a name="57"></a>57. Mistake in char_traits</h3>
<p><b>Section:</b> 21.2.3.4 [char.traits.specializations.wchar.t] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 1998-07-01 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>21.1.3.2, paragraph 3, says "The types streampos and
wstreampos may be different if the implementation supports no shift
encoding in narrow-oriented iostreams but supports one or more shift
encodings in wide-oriented streams". </p>

<p>That's wrong: the two are the same type. The &lt;iosfwd&gt; summary
in 27.2 says that streampos and wstreampos are, respectively, synonyms
for fpos&lt;char_traits&lt;char&gt;::state_type&gt; and
fpos&lt;char_traits&lt;wchar_t&gt;::state_type&gt;, and, flipping back
to clause 21, we see in 21.1.3.1 and 21.1.3.2 that
char_traits&lt;char&gt;::state_type and
char_traits&lt;wchar_t&gt;::state_type must both be mbstate_t. </p>


<p><b>Proposed resolution:</b></p>
<p>Remove the sentence in 21.2.3.4 [char.traits.specializations.wchar.t] paragraph 3 which
begins "The types streampos and wstreampos may be
different..." . </p>





<hr>
<h3><a name="59"></a>59. Ambiguity in specification of gbump</h3>
<p><b>Section:</b> 27.6.2.3.2 [streambuf.get.area] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 1998-07-28 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>27.5.2.3.1 says that basic_streambuf::gbump() "Advances the
next pointer for the input sequence by n." </p>

<p>The straightforward interpretation is that it is just gptr() +=
n. An alternative interpretation, though, is that it behaves as if it
calls sbumpc n times. (The issue, of course, is whether it might ever
call underflow.) There is a similar ambiguity in the case of
pbump. </p>

<p>(The "classic" AT&amp;T implementation used the
former interpretation.)</p>


<p><b>Proposed resolution:</b></p>
<p>Change 27.6.2.3.2 [streambuf.get.area] paragraph 4 gbump effects from:</p>

<blockquote>
  <p>Effects: Advances the next pointer for the input sequence by n.</p>
</blockquote>

<p>to:</p>

<blockquote>
  <p>Effects: Adds <tt>n</tt> to the next pointer for the input sequence.</p>
</blockquote>

<p>Make the same change to 27.6.2.3.3 [streambuf.put.area] paragraph 4 pbump
effects.</p>





<hr>
<h3><a name="60"></a>60. What is a formatted input function?</h3>
<p><b>Section:</b> 27.7.1.2.1 [istream.formatted.reqmts] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 1998-08-03 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#istream.formatted.reqmts">issues</a> in [istream.formatted.reqmts].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#162">162</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#163">163</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#166">166</a></p>
<p><b>Discussion:</b></p>
<p>Paragraph 1 of 27.6.1.2.1 contains general requirements for all
formatted input functions. Some of the functions defined in section
27.6.1.2 explicitly say that those requirements apply ("Behaves
like a formatted input member (as described in 27.6.1.2.1)"), but
others don't. The question: is 27.6.1.2.1 supposed to apply to
everything in 27.6.1.2, or only to those member functions that
explicitly say "behaves like a formatted input member"? Or
to put it differently: are we to assume that everything that appears
in a section called "Formatted input functions" really is a
formatted input function? I assume that 27.6.1.2.1 is intended to
apply to the arithmetic extractors (27.6.1.2.2), but I assume that it
is not intended to apply to extractors like </p>

<pre>    basic_istream&amp; operator&gt;&gt;(basic_istream&amp; (*pf)(basic_istream&amp;));</pre>

<p>and </p>

<pre>    basic_istream&amp; operator&gt;&gt;(basic_streammbuf*);</pre>

<p>There is a similar ambiguity for unformatted input, formatted output, and unformatted
output. </p>

<p>Comments from Judy Ward: It seems like the problem is that the
basic_istream and basic_ostream operator &lt;&lt;()'s that are used
for the manipulators and streambuf* are in the wrong section and
should have their own separate section or be modified to make it clear
that the "Common requirements" listed in section 27.6.1.2.1
(for basic_istream) and section 27.6.2.5.1 (for basic_ostream) do not
apply to them. </p>

<p>Additional comments from Dietmar Khl: It appears to be somewhat
nonsensical to consider the functions defined in 27.7.1.2.3 [istream::extractors] paragraphs 1 to 5 to be "Formatted input
function" but since these functions are defined in a section
labeled "Formatted input functions" it is unclear to me
whether these operators are considered formatted input functions which
have to conform to the "common requirements" from 27.7.1.2.1 [istream.formatted.reqmts]: If this is the case, all manipulators, not
just <tt>ws</tt>, would skip whitespace unless <tt>noskipws</tt> is
set (... but setting <tt>noskipws</tt> using the manipulator syntax
would also skip whitespace :-)</p> <p>It is not clear which functions
are to be considered unformatted input functions. As written, it seems
that all functions in 27.7.1.3 [istream.unformatted] are unformatted input
functions. However, it does not really make much sense to construct a
sentry object for <tt>gcount()</tt>, <tt>sync()</tt>, ... Also it is
unclear what happens to the <tt>gcount()</tt> if
eg. <tt>gcount()</tt>, <tt>putback()</tt>, <tt>unget()</tt>, or
<tt>sync()</tt> is called: These functions don't extract characters,
some of them even "unextract" a character. Should this still
be reflected in <tt>gcount()</tt>? Of course, it could be read as if
after a call to <tt>gcount()</tt> <tt>gcount()</tt> return <tt>0</tt>
(the last unformatted input function, <tt>gcount()</tt>, didn't
extract any character) and after a call to <tt>putback()</tt>
<tt>gcount()</tt> returns <tt>-1</tt> (the last unformatted input
function <tt>putback()</tt> did "extract" back into the
stream). Correspondingly for <tt>unget()</tt>. Is this what is
intended?  If so, this should be clarified. Otherwise, a corresponding
clarification should be used.</p>


<p><b>Proposed resolution:</b></p>
<p>
In 27.6.1.2.2 [lib.istream.formatted.arithmetic], paragraph 1.
Change the beginning of the second sentence from "The conversion
occurs" to "These extractors behave as formatted input functions (as
described in 27.6.1.2.1).  After a sentry object is constructed,
the conversion occurs"
</p>

<p>
In 27.6.1.2.3, [lib.istream::extractors], before paragraph 1.
Add an effects clause.  "Effects: None.  This extractor does
not behave as a formatted input function (as described in
27.6.1.2.1).
</p>

<p>
In 27.6.1.2.3, [lib.istream::extractors], paragraph 2.  Change the
effects clause to "Effects: Calls pf(*this).  This extractor does not
behave as a formatted input function (as described in 27.6.1.2.1).
</p>

<p>
In 27.6.1.2.3, [lib.istream::extractors], paragraph 4.  Change the
effects clause to "Effects: Calls pf(*this).  This extractor does not
behave as a formatted input function (as described in 27.6.1.2.1).
</p>

<p>
In 27.6.1.2.3, [lib.istream::extractors], paragraph 12.  Change the
first two sentences from "If sb is null, calls setstate(failbit),
which may throw ios_base::failure (27.4.4.3).  Extracts characters
from *this..." to "Behaves as a formatted input function (as described
in 27.6.1.2.1).  If sb is null, calls setstate(failbit), which may
throw ios_base::failure (27.4.4.3).  After a sentry object is
constructed, extracts characters from *this...".
</p>

<p>
In 27.6.1.3, [lib.istream.unformatted], before paragraph 2.  Add an
effects clause.  "Effects: none. This member function does not behave
as an unformatted input function (as described in 27.6.1.3, paragraph 1)."
</p>

<p>
In 27.6.1.3, [lib.istream.unformatted], paragraph 3.  Change the
beginning of the first sentence of the effects clause from "Extracts a
character" to "Behaves as an unformatted input function (as described
in 27.6.1.3, paragraph 1).  After constructing a sentry object, extracts a
character"
</p>

<p>
In 27.6.1.3, [lib.istream.unformatted], paragraph 5.  Change the
beginning of the first sentence of the effects clause from "Extracts a
character" to "Behaves as an unformatted input function (as described
in 27.6.1.3, paragraph 1).  After constructing a sentry object, extracts a
character"
</p>

<p>
In 27.6.1.3, [lib.istream.unformatted], paragraph 7.  Change the
beginning of the first sentence of the effects clause from "Extracts
characters" to "Behaves as an unformatted input function (as described
in 27.6.1.3, paragraph 1).  After constructing a sentry object, extracts
characters"
</p>

<p>
[No change needed in paragraph 10, because it refers to paragraph 7.]
</p>

<p>
In 27.6.1.3, [lib.istream.unformatted], paragraph 12.  Change the
beginning of the first sentence of the effects clause from "Extracts
characters" to "Behaves as an unformatted input function (as described
in 27.6.1.3, paragraph 1).  After constructing a sentry object, extracts
characters"
</p>

<p>
[No change needed in paragraph 15.]
</p>

<p>
In 27.6.1.3, [lib.istream.unformatted], paragraph 17.  Change the
beginning of the first sentence of the effects clause from "Extracts
characters" to "Behaves as an unformatted input function (as described
in 27.6.1.3, paragraph 1).  After constructing a sentry object, extracts
characters"
</p>

<p>
[No change needed in paragraph 23.]
</p>

<p>
In 27.6.1.3, [lib.istream.unformatted], paragraph 24.  Change the
beginning of the first sentence of the effects clause from "Extracts
characters" to "Behaves as an unformatted input function (as described
in 27.6.1.3, paragraph 1).  After constructing a sentry object, extracts
characters"
</p>

<p>
In 27.6.1.3, [lib.istream.unformatted], before paragraph 27.  Add an
Effects clause: "Effects: Behaves as an unformatted input function (as
described in 27.6.1.3, paragraph 1).  After constructing a sentry
object, reads but does not extract the current input character."
</p>

<p>
In 27.6.1.3, [lib.istream.unformatted], paragraph 28.  Change the
first sentence of the Effects clause from "If !good() calls" to
Behaves as an unformatted input function (as described in 27.6.1.3,
paragraph 1).  After constructing a sentry object, if !good() calls"
</p>

<p>
In 27.6.1.3, [lib.istream.unformatted], paragraph 30.  Change the
first sentence of the Effects clause from "If !good() calls" to
"Behaves as an unformatted input function (as described in 27.6.1.3,
paragraph 1).  After constructing a sentry object, if !good() calls"
</p>

<p>
In 27.6.1.3, [lib.istream.unformatted], paragraph 32.  Change the
first sentence of the Effects clause from "If !good() calls..." to
"Behaves as an unformatted input function (as described in 27.6.1.3,
paragraph 1).  After constructing a sentry object, if !good()
calls..."  Add a new sentence to the end of the Effects clause:
"[Note: this function extracts no characters, so the value returned
by the next call to gcount() is 0.]"
</p>

<p>
In 27.6.1.3, [lib.istream.unformatted], paragraph 34.  Change the
first sentence of the Effects clause from "If !good() calls" to
"Behaves as an unformatted input function (as described in 27.6.1.3,
paragraph 1).  After constructing a sentry object, if !good() calls".
Add a new sentence to the end of the Effects clause: "[Note: this
function extracts no characters, so the value returned by the next
call to gcount() is 0.]"
</p>

<p>
In 27.6.1.3, [lib.istream.unformatted], paragraph 36.  Change the
first sentence of the Effects clause from "If !rdbuf() is" to "Behaves
as an unformatted input function (as described in 27.6.1.3, paragraph
1), except that it does not count the number of characters extracted
and does not affect the value returned by subsequent calls to
gcount().  After constructing a sentry object, if rdbuf() is"
</p>

<p>
In 27.6.1.3, [lib.istream.unformatted], before paragraph 37.  Add an
Effects clause: "Effects: Behaves as an unformatted input function (as
described in 27.6.1.3, paragraph 1), except that it does not count the
number of characters extracted and does not affect the value returned
by subsequent calls to gcount()."  Change the first sentence of
paragraph 37 from "if fail()" to "after constructing a sentry object,
if fail()".
</p>

<p>
In 27.6.1.3, [lib.istream.unformatted], paragraph 38.  Change the
first sentence of the Effects clause from "If fail()" to "Behaves
as an unformatted input function (as described in 27.6.1.3, paragraph
1), except that it does not count the number of characters extracted
and does not affect the value returned by subsequent calls to
gcount().  After constructing a sentry object, if fail()
</p>

<p>
In 27.6.1.3, [lib.istream.unformatted], paragraph 40.  Change the
first sentence of the Effects clause from "If fail()" to "Behaves
as an unformatted input function (as described in 27.6.1.3, paragraph
1), except that it does not count the number of characters extracted
and does not affect the value returned by subsequent calls to
gcount().  After constructing a sentry object, if fail()
</p>

<p>
In 27.6.2.5.2 [lib.ostream.inserters.arithmetic], paragraph 1.  Change
the beginning of the third sentence from "The formatting conversion"
to "These extractors behave as formatted output functions (as
described in 27.6.2.5.1).  After the sentry object is constructed, the
conversion occurs".
</p>

<p>
In 27.6.2.5.3 [lib.ostream.inserters], before paragraph 1.  Add an
effects clause: "Effects: None. Does not behave as a formatted output
function (as described in 27.6.2.5.1).".
</p>

<p>
In 27.6.2.5.3 [lib.ostream.inserters], paragraph 2.  Change the
effects clause to "Effects: calls pf(*this).  This extractor does not
behave as a formatted output function (as described in 27.6.2.5.1).".
</p>

<p>
In 27.6.2.5.3 [lib.ostream.inserters], paragraph 4.  Change the
effects clause to "Effects: calls pf(*this).  This extractor does not
behave as a formatted output function (as described in 27.6.2.5.1).".
</p>

<p>
In 27.6.2.5.3 [lib.ostream.inserters], paragraph 6.  Change the first
sentence from "If sb" to "Behaves as a formatted output function (as
described in 27.6.2.5.1).  After the sentry object is constructed, if
sb".
</p>

<p>
In 27.6.2.6 [lib.ostream.unformatted], paragraph 2.  Change the first
sentence from "Inserts the character" to "Behaves as an unformatted
output function (as described in 27.6.2.6, paragraph 1).  After
constructing a sentry object, inserts the character".
</p>

<p>
In 27.6.2.6 [lib.ostream.unformatted], paragraph 5.  Change the first
sentence from "Obtains characters" to "Behaves as an unformatted
output function (as described in 27.6.2.6, paragraph 1).  After
constructing a sentry object, obtains characters".
</p>

<p>
In 27.6.2.6 [lib.ostream.unformatted], paragraph 7.  Add a new
sentence at the end of the paragraph: "Does not behave as an
unformatted output function (as described in 27.6.2.6, paragraph 1)."
</p>


<p><b>Rationale:</b></p>
<p>See J16/99-0043==WG21/N1219, Proposed Resolution to Library Issue 60,
by Judy Ward and Matt Austern.  This proposed resolution is section
VI of that paper.</p>





<hr>
<h3><a name="61"></a>61. Ambiguity in iostreams exception policy</h3>
<p><b>Section:</b> 27.7.1.3 [istream.unformatted] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 1998-08-06 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#istream.unformatted">issues</a> in [istream.unformatted].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>The introduction to the section on unformatted input (27.6.1.3)
says that every unformatted input function catches all exceptions that
were thrown during input, sets badbit, and then conditionally rethrows
the exception. That seems clear enough. Several of the specific
functions, however, such as get() and read(), are documented in some
circumstances as setting eofbit and/or failbit. (The standard notes,
correctly, that setting eofbit or failbit can sometimes result in an
exception being thrown.) The question: if one of these functions
throws an exception triggered by setting failbit, is this an exception
"thrown during input" and hence covered by 27.6.1.3, or does
27.6.1.3 only refer to a limited class of exceptions? Just to make
this concrete, suppose you have the following snippet. </p>

<pre>  
  char buffer[N];
  istream is;
  ...
  is.exceptions(istream::failbit); // Throw on failbit but not on badbit.
  is.read(buffer, N);</pre>

<p>Now suppose we reach EOF before we've read N characters. What
iostate bits can we expect to be set, and what exception (if any) will
be thrown? </p>


<p><b>Proposed resolution:</b></p>
<p>
In 27.6.1.3, paragraph 1, after the sentence that begins
"If an exception is thrown...", add the following
parenthetical comment: "(Exceptions thrown from 
<tt>basic_ios&lt;&gt;::clear()</tt> are not caught or rethrown.)"
</p>


<p><b>Rationale:</b></p>
<p>The LWG looked to two alternative wordings, and choose the proposed
resolution as better standardese.</p>





<hr>
<h3><a name="62"></a>62. <tt>Sync</tt>'s return value</h3>
<p><b>Section:</b> 27.7.1.3 [istream.unformatted] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 1998-08-06 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#istream.unformatted">issues</a> in [istream.unformatted].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>The Effects clause for sync() (27.6.1.3, paragraph 36) says that it
"calls rdbuf()-&gt;pubsync() and, if that function returns -1
... returns traits::eof()." </p>

<p>That looks suspicious, because traits::eof() is of type
traits::int_type while the return type of sync() is int. </p>


<p><b>Proposed resolution:</b></p>
<p>In 27.7.1.3 [istream.unformatted], paragraph 36, change "returns
<tt>traits::eof()</tt>" to "returns <tt>-1</tt>".
</p>





<hr>
<h3><a name="63"></a>63. Exception-handling policy for unformatted output</h3>
<p><b>Section:</b> 27.7.2.7 [ostream.unformatted] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 1998-08-11 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#ostream.unformatted">issues</a> in [ostream.unformatted].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>Clause 27 details an exception-handling policy for formatted input,
unformatted input, and formatted output. It says nothing for
unformatted output (27.6.2.6). 27.6.2.6 should either include the same
kind of exception-handling policy as in the other three places, or
else it should have a footnote saying that the omission is
deliberate. </p>


<p><b>Proposed resolution:</b></p>
<p>
In 27.6.2.6, paragraph 1, replace the last sentence ("In any
case, the unformatted output function ends by destroying the sentry
object, then returning the value specified for the formatted output
function.") with the following text:
</p>
<blockquote><p>
If an exception is thrown during output, then <tt>ios::badbit</tt> is
turned on [Footnote: without causing an <tt>ios::failure</tt> to be
thrown.] in <tt>*this</tt>'s error state. If <tt>(exceptions() &amp;
badbit) != 0</tt> then the exception is rethrown.  In any case, the
unformatted output function ends by destroying the sentry object,
then, if no exception was thrown, returning the value specified for
the formatted output function.
</p></blockquote>


<p><b>Rationale:</b></p>
<p>
This exception-handling policy is consistent with that of formatted
input, unformatted input, and formatted output.
</p>





<hr>
<h3><a name="64"></a>64. Exception handling in <tt>basic_istream::operator&gt;&gt;(basic_streambuf*)</tt></h3>
<p><b>Section:</b> 27.7.1.2.3 [istream::extractors] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 1998-08-11 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#istream::extractors">issues</a> in [istream::extractors].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>27.6.1.2.3, paragraph 13, is ambiguous. It can be interpreted two
different ways, depending on whether the second sentence is read as an
elaboration of the first. </p>


<p><b>Proposed resolution:</b></p>
<p>Replace 27.7.1.2.3 [istream::extractors], paragraph 13, which begins
"If the function inserts no characters ..." with:</p>

<blockquote>
  <p>If the function inserts no characters, it calls
  <tt>setstate(failbit)</tt>, which may throw
  <tt>ios_base::failure</tt> (27.4.4.3). If it inserted no characters
  because it caught an exception thrown while extracting characters
  from <tt>sb</tt> and <tt>failbit</tt> is on in <tt>exceptions()</tt>
  (27.4.4.3), then the caught exception is rethrown. </p>
</blockquote>





<hr>
<h3><a name="66"></a>66. Strstreambuf::setbuf</h3>
<p><b>Section:</b> D.9.1.3 [depr.strstreambuf.virtuals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 1998-08-18 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#depr.strstreambuf.virtuals">issues</a> in [depr.strstreambuf.virtuals].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>D.7.1.3, paragraph 19, says that strstreambuf::setbuf
"Performs an operation that is defined separately for each class
derived from strstreambuf". This is obviously an incorrect
cut-and-paste from basic_streambuf. There are no classes derived from
strstreambuf. </p>


<p><b>Proposed resolution:</b></p>
<p>D.9.1.3 [depr.strstreambuf.virtuals], paragraph 19, replace the setbuf effects
clause which currently says "Performs an operation that is
defined separately for each class derived from strstreambuf"
with:</p>

<blockquote>
  <p><b>Effects</b>: implementation defined, except that
  <tt>setbuf(0,0)</tt> has no effect.</p>
</blockquote>





<hr>
<h3><a name="68"></a>68. Extractors for char* should store null at end</h3>
<p><b>Section:</b> 27.7.1.2.3 [istream::extractors] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Angelika Langer <b>Opened:</b> 1998-07-14 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#istream::extractors">issues</a> in [istream::extractors].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>Extractors for char* (27.6.1.2.3) do not store a null character
after the extracted character sequence whereas the unformatted
functions like get() do. Why is this?</p>

<p>Comment from Jerry Schwarz: There is apparently an editing
glitch. You'll notice that the last item of the list of what stops
extraction doesn't make any sense. It was supposed to be the line that
said a null is stored.</p>


<p><b>Proposed resolution:</b></p>
<p>27.7.1.2.3 [istream::extractors], paragraph 7, change the last list
item from:</p>

<blockquote><p>
  A null byte (<tt>charT()</tt>) in the next position, which may be
  the first position if no characters were extracted.
</p></blockquote>

<p>to become a new paragraph which reads:</p>

<blockquote><p>
  Operator&gt;&gt; then stores a null byte (<tt>charT()</tt>) in the
  next position, which may be the first position if no characters were
  extracted.
</p></blockquote>





<hr>
<h3><a name="69"></a>69. Must elements of a vector be contiguous?</h3>
<p><b>Section:</b> 23.4.1 [vector] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Andrew Koenig <b>Opened:</b> 1998-07-29 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#vector">issues</a> in [vector].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>The issue is this: Must the elements of a vector be in contiguous memory?</p>

<p>(Please note that this is entirely separate from the question of
whether a vector iterator is required to be a pointer; the answer to
that question is clearly "no," as it would rule out
debugging implementations)</p>


<p><b>Proposed resolution:</b></p>
<p>Add the following text to the end of 23.4.1 [vector],
paragraph 1. </p>

<blockquote>
  <p>The elements of a vector are stored contiguously, meaning that if
  v is a <tt>vector&lt;T, Allocator&gt;</tt> where T is some type
  other than <tt>bool</tt>, then it obeys the identity <tt>&amp;v[n]
  == &amp;v[0] + n</tt> for all <tt>0 &lt;= n &lt; v.size()</tt>.</p>
</blockquote>


<p><b>Rationale:</b></p>
<p>The LWG feels that as a practical matter the answer is clearly
"yes".  There was considerable discussion as to the best way
to express the concept of "contiguous", which is not
directly defined in the standard.  Discussion included:</p>

<ul>
  <li>An operational definition similar to the above proposed resolution is 
    already used for valarray (26.6.2.3 [valarray.access]).</li>
  <li>There is no need to explicitly consider a user-defined operator&amp; 
    because elements must be copyconstructible (23.2 [container.requirements] para 3) 
    and copyconstructible (20.2.1 [utility.arg.requirements]) specifies
    requirements for operator&amp;.</li>
  <li>There is no issue of one-past-the-end because of language rules.</li>
</ul>





<hr>
<h3><a name="70"></a>70. Uncaught_exception() missing throw() specification</h3>
<p><b>Section:</b> 18.8 [support.exception], 18.8.4 [uncaught] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Steve Clamage <b>Opened:</b> 1998-08-03 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#support.exception">issues</a> in [support.exception].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>In article 3E04@pratique.fr, Valentin Bonnard writes: </p>

<p>uncaught_exception() doesn't have a throw specification.</p>

<p>It is intentional ? Does it means that one should be prepared to
handle exceptions thrown from uncaught_exception() ?</p>

<p>uncaught_exception() is called in exception handling contexts where
exception safety is very important.</p>


<p><b>Proposed resolution:</b></p>
<p>In 15.5.3 [except.uncaught], paragraph 1, 18.8 [support.exception], and 18.8.4 [uncaught], add "throw()" to uncaught_exception().</p>




<hr>
<h3><a name="71"></a>71. Do_get_monthname synopsis missing argument</h3>
<p><b>Section:</b> 22.4.5.1 [locale.time.get] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Nathan Myers <b>Opened:</b> 1998-08-13 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>The locale facet member <tt>time_get&lt;&gt;::do_get_monthname</tt>
is described in 22.4.5.1.2 [locale.time.get.virtuals] with five arguments,
consistent with do_get_weekday and with its specified use by member
get_monthname. However, in the synopsis, it is specified instead with
four arguments. The missing argument is the "end" iterator
value.</p>


<p><b>Proposed resolution:</b></p>
<p>In 22.4.5.1 [locale.time.get], add an "end" argument to
the declaration of member do_monthname as follows:</p>

<pre>  virtual iter_type do_get_monthname(iter_type s, iter_type end, ios_base&amp;,
                                     ios_base::iostate&amp; err, tm* t) const;</pre>




<hr>
<h3><a name="74"></a>74. Garbled text for <tt>codecvt::do_max_length</tt></h3>
<p><b>Section:</b> 22.4.1.4 [locale.codecvt] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 1998-09-08 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.codecvt">issues</a> in [locale.codecvt].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>The text of <tt>codecvt::do_max_length</tt>'s "Returns"
clause (22.2.1.5.2, paragraph 11) is garbled. It has unbalanced
parentheses and a spurious <b>n</b>.</p>


<p><b>Proposed resolution:</b></p>
<p>Replace 22.4.1.4.2 [locale.codecvt.virtuals] paragraph 11 with the
following:</p>

<blockquote><p>
  <b>Returns</b>: The maximum value that
  <tt>do_length(state, from, from_end, 1)</tt> can return for any
  valid range <tt>[from, from_end)</tt> and <tt>stateT</tt> value
  <tt>state</tt>. The specialization <tt>codecvt&lt;char, char,
  mbstate_t&gt;::do_max_length()</tt> returns 1.
</p></blockquote>




<hr>
<h3><a name="75"></a>75. Contradiction in <tt>codecvt::length</tt>'s argument types</h3>
<p><b>Section:</b> 22.4.1.4 [locale.codecvt] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b>  Matt
Austern <b>Opened:</b> 1998-09-18 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.codecvt">issues</a> in [locale.codecvt].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>The class synopses for classes <tt>codecvt&lt;&gt;</tt> (22.2.1.5)
and <tt>codecvt_byname&lt;&gt;</tt> (22.2.1.6) say that the first
parameter of the member functions <tt>length</tt> and
<tt>do_length</tt> is of type <tt>const stateT&amp;</tt>. The member
function descriptions, however (22.2.1.5.1, paragraph 6; 22.2.1.5.2,
paragraph 9) say that the type is <tt>stateT&amp;</tt>.  Either the
synopsis or the summary must be changed. </p>

<p>If (as I believe) the member function descriptions are correct,
then we must also add text saying how <tt>do_length</tt> changes its
<tt>stateT</tt> argument. </p>


<p><b>Proposed resolution:</b></p>
<p>In 22.4.1.4 [locale.codecvt], and also in 22.4.1.5 [locale.codecvt.byname],
change the <tt>stateT</tt> argument type on both member
<tt>length()</tt> and member <tt>do_length()</tt> from </p>

<blockquote>
  <p><tt>const stateT&amp;</tt></p>
</blockquote>

<p>to</p>

<blockquote>
  <p><tt>stateT&amp;</tt></p>
</blockquote>

<p>In 22.4.1.4.2 [locale.codecvt.virtuals], add to the definition for member
<tt>do_length</tt> a paragraph:</p>

<blockquote>
  <p>Effects: The effect on the <tt>state</tt> argument is ``as if''
  it called <tt>do_in(state, from, from_end, from, to, to+max,
  to)</tt> for <tt>to</tt> pointing to a buffer of at least
  <tt>max</tt> elements.</p>
</blockquote>




<hr>
<h3><a name="76"></a>76. Can a <tt>codecvt</tt> facet always convert one internal character at a time?</h3>
<p><b>Section:</b> 22.4.1.4 [locale.codecvt] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 1998-09-25 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.codecvt">issues</a> in [locale.codecvt].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>This issue concerns the requirements on classes derived from
<tt>codecvt</tt>, including user-defined classes. What are the
restrictions on the conversion from external characters
(e.g. <tt>char</tt>) to internal characters (e.g. <tt>wchar_t</tt>)?
Or, alternatively, what assumptions about <tt>codecvt</tt> facets can
the I/O library make? </p>

<p>The question is whether it's possible to convert from internal
characters to external characters one internal character at a time,
and whether, given a valid sequence of external characters, it's
possible to pick off internal characters one at a time. Or, to put it
differently: given a sequence of external characters and the
corresponding sequence of internal characters, does a position in the
internal sequence correspond to some position in the external
sequence? </p>

<p>To make this concrete, suppose that <tt>[first, last)</tt> is a
sequence of <i>M</i> external characters and that <tt>[ifirst,
ilast)</tt> is the corresponding sequence of <i>N</i> internal
characters, where <i>N &gt; 1</i>. That is, <tt>my_encoding.in()</tt>,
applied to <tt>[first, last)</tt>, yields <tt>[ifirst,
ilast)</tt>. Now the question: does there necessarily exist a
subsequence of external characters, <tt>[first, last_1)</tt>, such
that the corresponding sequence of internal characters is the single
character <tt>*ifirst</tt>?
</p>

<p>(What a "no" answer would mean is that
<tt>my_encoding</tt> translates sequences only as blocks. There's a
sequence of <i>M</i> external characters that maps to a sequence of
<i>N</i> internal characters, but that external sequence has no
subsequence that maps to <i>N-1</i> internal characters.) </p>

<p>Some of the wording in the standard, such as the description of
<tt>codecvt::do_max_length</tt> (22.4.1.4.2 [locale.codecvt.virtuals],
paragraph 11) and <tt>basic_filebuf::underflow</tt> (27.9.1.5 [filebuf.virtuals], paragraph 3) suggests that it must always be
possible to pick off internal characters one at a time from a sequence
of external characters. However, this is never explicitly stated one
way or the other. </p>

<p>This issue seems (and is) quite technical, but it is important if
we expect users to provide their own encoding facets. This is an area
where the standard library calls user-supplied code, so a well-defined
set of requirements for the user-supplied code is crucial. Users must
be aware of the assumptions that the library makes. This issue affects
positioning operations on <tt>basic_filebuf</tt>, unbuffered input,
and several of <tt>codecvt</tt>'s member functions. </p>


<p><b>Proposed resolution:</b></p>
<p>Add the following text as a new paragraph, following 22.4.1.4.2 [locale.codecvt.virtuals] paragraph 2:</p>

<blockquote>
<p>A <tt>codecvt</tt> facet that is used by <tt>basic_filebuf</tt>
(27.9 [file.streams]) must have the property that if</p>
<pre>    do_out(state, from, from_end, from_next, to, to_lim, to_next)
</pre>
<p>would return <tt>ok</tt>, where <tt>from != from_end</tt>, then </p>
<pre>    do_out(state, from, from + 1, from_next, to, to_end, to_next)
</pre>
<p>must also return <tt>ok</tt>, and that if</p>
<pre>    do_in(state, from, from_end, from_next, to, to_lim, to_next)
</pre>
<p>would return <tt>ok</tt>, where <tt>to != to_lim</tt>, then</p>
<pre>    do_in(state, from, from_end, from_next, to, to + 1, to_next)
</pre>
<p>must also return <tt>ok</tt>.  [<i>Footnote:</i> Informally, this
means that <tt>basic_filebuf</tt> assumes that the mapping from
internal to external characters is 1 to N: a <tt>codecvt</tt> that is
used by <tt>basic_filebuf</tt> must be able to translate characters
one internal character at a time.  <i>--End Footnote</i>]</p>
</blockquote>

<p><i>[Redmond: Minor change in proposed resolution.  Original
proposed resolution talked about "success", with a parenthetical
comment that success meant returning <tt>ok</tt>.  New wording
removes all talk about "success", and just talks about the
return value.]</i></p>




<p><b>Rationale:</b></p>

  <p>The proposed resoluion says that conversions can be performed one
  internal character at a time.  This rules out some encodings that
  would otherwise be legal.  The alternative answer would mean there
  would be some internal positions that do not correspond to any
  external file position.</p>
  <p>
  An example of an encoding that this rules out is one where the
  <tt>internT</tt> and <tt>externT</tt> are of the same type, and
  where the internal sequence <tt>c1 c2</tt> corresponds to the
  external sequence <tt>c2 c1</tt>.
  </p>
  <p>It was generally agreed that <tt>basic_filebuf</tt> relies
  on this property: it was designed under the assumption that
  the external-to-internal mapping is N-to-1, and it is not clear
  that <tt>basic_filebuf</tt> is implementable without that 
  restriction.
  </p>
  <p>
  The proposed resolution is expressed as a restriction on
  <tt>codecvt</tt> when used by <tt>basic_filebuf</tt>, rather
  than a blanket restriction on all <tt>codecvt</tt> facets,
  because <tt>basic_filebuf</tt> is the only other part of the 
  library that uses <tt>codecvt</tt>.  If a user wants to define
  a <tt>codecvt</tt> facet that implements a more general N-to-M
  mapping, there is no reason to prohibit it, so long as the user
  does not expect <tt>basic_filebuf</tt> to be able to use it.
  </p>





<hr>
<h3><a name="78"></a>78. Typo: event_call_back</h3>
<p><b>Section:</b> 27.5.2 [ios.base] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Nico Josuttis <b>Opened:</b> 1998-09-29 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#ios.base">issues</a> in [ios.base].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>typo: event_call_back should be event_callback &nbsp; </p>


<p><b>Proposed resolution:</b></p>
<p>In the 27.5.2 [ios.base] synopsis change
"event_call_back" to "event_callback". </p>




<hr>
<h3><a name="79"></a>79. Inconsistent declaration of polar()</h3>
<p><b>Section:</b> 26.4.1 [complex.syn], 26.4.7 [complex.value.ops] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Nico Josuttis <b>Opened:</b> 1998-09-29 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#complex.syn">issues</a> in [complex.syn].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>In 26.4.1 [complex.syn] polar is declared as follows:</p>
<pre>   template&lt;class T&gt; complex&lt;T&gt; polar(const T&amp;, const T&amp;); </pre>

<p>In 26.4.7 [complex.value.ops] it is declared as follows:</p>
<pre>   template&lt;class T&gt; complex&lt;T&gt; polar(const T&amp; rho, const T&amp; theta = 0); </pre>

<p>Thus whether the second parameter is optional is not clear. </p>


<p><b>Proposed resolution:</b></p>
<p>In 26.4.1 [complex.syn] change:</p>
<pre>   template&lt;class T&gt; complex&lt;T&gt; polar(const T&amp;, const T&amp;);</pre>

<p>to:</p>
<pre>   template&lt;class T&gt; complex&lt;T&gt; polar(const T&amp; rho, const T&amp; theta = 0); </pre>





<hr>
<h3><a name="80"></a>80. Global Operators of complex declared twice</h3>
<p><b>Section:</b> 26.4.1 [complex.syn], 26.4.2 [complex] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Nico Josuttis <b>Opened:</b> 1998-09-29 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#complex.syn">issues</a> in [complex.syn].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>Both 26.2.1 and 26.2.2 contain declarations of global operators for
class complex. This redundancy should be removed.</p>


<p><b>Proposed resolution:</b></p>
<p>Reduce redundancy according to the general style of the standard. </p>




<hr>
<h3><a name="83"></a>83. String::npos vs. string::max_size()</h3>
<p><b>Section:</b> 21.4 [basic.string] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Nico Josuttis <b>Opened:</b> 1998-09-29 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#basic.string">issues</a> in [basic.string].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#89">89</a></p>
<p><b>Discussion:</b></p>
<p>Many string member functions throw if size is getting or exceeding
npos. However, I wonder why they don't throw if size is getting or
exceeding max_size() instead of npos.  May be npos is known at compile
time, while max_size() is known at runtime. However, what happens if
size exceeds max_size() but not npos, then? It seems the standard
lacks some clarifications here.</p>


<p><b>Proposed resolution:</b></p>
<p>After 21.4 [basic.string] paragraph 4 ("The functions
described in this clause...") add a new paragraph:</p>

<blockquote>
  <p>For any string operation, if as a result of the operation, <tt> size()</tt> would exceed
  <tt> max_size()</tt> then
  the operation throws <tt>length_error</tt>.</p>
</blockquote>


<p><b>Rationale:</b></p>
<p>The LWG believes length_error is the correct exception to throw.</p>




<hr>
<h3><a name="86"></a>86. String constructors don't describe exceptions</h3>
<p><b>Section:</b> 21.4.1 [string.require] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Nico Josuttis <b>Opened:</b> 1998-09-29 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#string.require">issues</a> in [string.require].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>The constructor from a range:</p>

<pre>template&lt;class InputIterator&gt; 
         basic_string(InputIterator begin, InputIterator end, 
                      const Allocator&amp; a = Allocator());</pre>

<p>lacks a throws clause. However, I would expect that it throws
according to the other constructors if the numbers of characters in
the range equals npos (or exceeds max_size(), see above). </p>


<p><b>Proposed resolution:</b></p>
<p>In 21.4.1 [string.require], Strike throws paragraphs for
constructors which say "Throws: length_error if n ==
npos."</p>


<p><b>Rationale:</b></p>
<p>Throws clauses for length_error if n == npos are no longer needed
because they are subsumed by the general wording added by the
resolution for issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#83">83</a>.</p>




<hr>
<h3><a name="90"></a>90. Incorrect description of operator &gt;&gt; for strings</h3>
<p><b>Section:</b> 21.4.8.9 [string.io] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Nico Josuttis <b>Opened:</b> 1998-09-29 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#string.io">issues</a> in [string.io].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>The effect of operator &gt;&gt; for strings contain the following item:</p>

<p>&nbsp;&nbsp;&nbsp; <tt>isspace(c,getloc())</tt> is true for the next available input
character c.</p>

<p>Here <tt>getloc()</tt> has to be replaced by <tt>is.getloc()</tt>. </p>


<p><b>Proposed resolution:</b></p>
<p>In 21.4.8.9 [string.io] paragraph 1 Effects clause replace:</p>

<blockquote>
  <p><tt>isspace(c,getloc())</tt> is true for the next available input character c.</p>
</blockquote>

<p>with:</p>

<blockquote>
  <p><tt>isspace(c,is.getloc())</tt> is true for the next available input character c.</p>
</blockquote>





<hr>
<h3><a name="91"></a>91. Description of operator&gt;&gt; and getline() for string&lt;&gt; might cause endless loop</h3>
<p><b>Section:</b> 21.4.8.9 [string.io] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Nico Josuttis <b>Opened:</b> 1998-09-29 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#string.io">issues</a> in [string.io].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>Operator &gt;&gt; and getline() for strings read until eof()
in the input stream is true. However, this might never happen, if the
stream can't read anymore without reaching EOF. So shouldn't it be
changed into that it reads until !good() ? </p>


<p><b>Proposed resolution:</b></p>
<p>In 21.4.8.9 [string.io], paragraph 1, replace:</p>
<blockquote><p>
Effects: Begins by constructing a sentry object k as if k were
constructed by typename basic_istream&lt;charT,traits&gt;::sentry k( is). If
bool( k) is true, it calls str.erase() and then extracts characters
from is and appends them to str as if by calling str.append(1, c). If
is.width() is greater than zero, the maximum number n of characters
appended is is.width(); otherwise n is str.max_size(). Characters are
extracted and appended until any of the following occurs:
</p></blockquote>
<p>with:</p>
<blockquote><p>
Effects: Behaves as a formatted input function (27.7.1.2.1 [istream.formatted.reqmts]).  After constructing a sentry object, if the
sentry converts to true, calls str.erase() and then extracts
characters from is and appends them to str as if by calling
str.append(1,c). If is.width() is greater than zero, the maximum
number n of characters appended is is.width(); otherwise n is
str.max_size(). Characters are extracted and appended until any of the
following occurs:
</p></blockquote>

<p>In 21.4.8.9 [string.io], paragraph 6, replace</p>
<blockquote><p>
Effects: Begins by constructing a sentry object k as if by typename
basic_istream&lt;charT,traits&gt;::sentry k( is, true). If bool( k) is true,
it calls str.erase() and then extracts characters from is and appends
them to str as if by calling str.append(1, c) until any of the
following occurs:
</p></blockquote>
<p>with:</p>
<blockquote><p>
Effects: Behaves as an unformatted input function (27.7.1.3 [istream.unformatted]), except that it does not affect the value returned
by subsequent calls to basic_istream&lt;&gt;::gcount().  After
constructing a sentry object, if the sentry converts to true, calls
str.erase() and then extracts characters from is and appends them to
str as if by calling str.append(1,c) until any of the following
occurs:
</p></blockquote>

<p><i>[Redmond: Made changes in proposed resolution.  <tt>operator&gt;&gt;</tt>
should be a formatted input function, not an unformatted input function.
<tt>getline</tt> should not be required to set <tt>gcount</tt>, since
there is no mechanism for <tt>gcount</tt> to be set except by one of
<tt>basic_istream</tt>'s member functions.]</i></p>


<p><i>[Curaao: Nico agrees with proposed resolution.]</i></p>




<p><b>Rationale:</b></p>
<p>The real issue here is whether or not these string input functions
get their characters from a streambuf, rather than by calling an
istream's member functions, a streambuf signals failure either by
returning eof or by throwing an exception; there are no other
possibilities.  The proposed resolution makes it clear that these two
functions do get characters from a streambuf.</p>





<hr>
<h3><a name="92"></a>92. Incomplete Algorithm Requirements</h3>
<p><b>Section:</b> 25 [algorithms] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Nico Josuttis <b>Opened:</b> 1998-09-29 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#algorithms">issues</a> in [algorithms].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>The standard does not state, how often a function object is copied,
called, or the order of calls inside an algorithm. This may lead to
surprising/buggy behavior. Consider the following example: </p>

<pre>class Nth {    // function object that returns true for the nth element 
  private: 
    int nth;     // element to return true for 
    int count;   // element counter 
  public: 
    Nth (int n) : nth(n), count(0) { 
    } 
    bool operator() (int) { 
        return ++count == nth; 
    } 
}; 
.... 
// remove third element 
    list&lt;int&gt;::iterator pos; 
    pos = remove_if(coll.begin(),coll.end(),  // range 
                    Nth(3)),                  // remove criterion 
    coll.erase(pos,coll.end()); </pre>

<p>This call, in fact removes the 3rd <b>AND the 6th</b> element. This
happens because the usual implementation of the algorithm copies the
function object internally: </p>

<pre>template &lt;class ForwIter, class Predicate&gt; 
ForwIter std::remove_if(ForwIter beg, ForwIter end, Predicate op) 
{ 
    beg = find_if(beg, end, op); 
    if (beg == end) { 
        return beg; 
    } 
    else { 
        ForwIter next = beg; 
        return remove_copy_if(++next, end, beg, op); 
    } 
} </pre>

<p>The algorithm uses find_if() to find the first element that should
be removed. However, it then uses a copy of the passed function object
to process the resulting elements (if any). Here, Nth is used again
and removes also the sixth element. This behavior compromises the
advantage of function objects being able to have a state. Without any
cost it could be avoided (just implement it directly instead of
calling find_if()). </p>


<p><b>Proposed resolution:</b></p>

<p>Add a new paragraph following 25 [algorithms] paragraph 8:</p>
<blockquote><p>
[Note: Unless otherwise specified, algorithms that take function
objects as arguments are permitted to copy those function objects
freely.  Programmers for whom object identity is important should
consider using a wrapper class that points to a noncopied
implementation object, or some equivalent solution.]
</p></blockquote>

<p><i>[Dublin: Pete Becker felt that this may not be a defect,
but rather something that programmers need to be educated about.
There was discussion of adding wording to the effect that the number
and order of calls to function objects, including predicates, not
affect the behavior of the function object.]</i></p>


<p><i>[Pre-Kona: Nico comments: It seems the problem is that we don't
have a clear statement of "predicate" in the
standard. People including me seemed to think "a function
returning a Boolean value and being able to be called by an STL
algorithm or be used as sorting criterion or ... is a
predicate". But a predicate has more requirements: It should
never change its behavior due to a call or being copied. IMHO we have
to state this in the standard. If you like, see section 8.1.4 of my
library book for a detailed discussion.]</i></p>


<p><i>[Kona: Nico will provide wording to the effect that "unless
otherwise specified, the number of copies of and calls to function
objects by algorithms is unspecified".&nbsp; Consider placing in
25 [algorithms] after paragraph 9.]</i></p>


<p><i>[Santa Cruz: The standard doesn't currently guarantee that
  functions object won't be copied, and what isn't forbidden is
  allowed.  It is believed (especially since implementations that were
  written in concert with the standard do make copies of function
  objects) that this was intentional.  Thus, no normative change is
  needed.  What we should put in is a non-normative note suggesting to
  programmers that if they want to guarantee the lack of copying they
  should use something like the <tt>ref</tt> wrapper.]</i></p>


<p><i>[Oxford: Matt provided wording.]</i></p>








<hr>
<h3><a name="98"></a>98. Input iterator requirements are badly written</h3>
<p><b>Section:</b> 24.2.3 [input.iterators] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> AFNOR <b>Opened:</b> 1998-10-07 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#input.iterators">issues</a> in [input.iterators].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>Table 72 in 24.2.3 [input.iterators] specifies semantics for
<tt>*r++</tt> of:</p>

<p>&nbsp;&nbsp; <tt>{ T tmp = *r; ++r; return tmp; }</tt></p>

<p>There are two problems with this.  First, the return type is
specified to be "T", as opposed to something like "convertible to T".
This is too specific: we want to allow *r++ to return an lvalue.</p>

<p>Second, writing the semantics in terms of code misleadingly
suggests that the effects *r++ should precisely replicate the behavior
of this code, including side effects.  (Does this mean that *r++
should invoke the copy constructor exactly as many times as the sample
code above would?) See issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#334">334</a> for a similar
problem.</p>



<p><b>Proposed resolution:</b></p>
<p>In Table 72 in 24.2.3 [input.iterators], change the return type
for <tt>*r++</tt> from <tt>T</tt> to "convertible to T".</p>


<p><b>Rationale:</b></p>
<p>This issue has two parts: the return type, and the number of times
  the copy constructor is invoked.</p>

<p>The LWG believes the the first part is a real issue.  It's
  inappropriate for the return type to be specified so much more
  precisely for *r++ than it is for *r.  In particular, if r is of
  (say) type <tt>int*</tt>, then *r++ isn't <tt>int</tt>,
  but <tt>int&amp;</tt>.</p>

<p>The LWG does not believe that the number of times the copy
  constructor is invoked is a real issue.  This can vary in any case,
  because of language rules on copy constructor elision.  That's too
  much to read into these semantics clauses.</p>

<p>Additionally, as Dave Abrahams pointed out (c++std-lib-13703): since 
   we're told (24.1/3) that forward iterators satisfy all the requirements
   of input iterators, we can't impose any requirements in the Input
   Iterator requirements table that forward iterators don't satisfy.</p>





<hr>
<h3><a name="103"></a>103. set::iterator is required to be modifiable, but this allows modification of keys</h3>
<p><b>Section:</b> 23.2.4 [associative.reqmts] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> AFNOR <b>Opened:</b> 1998-10-07 <b>Last modified:</b> 2010-10-29</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#associative.reqmts">active issues</a> in [associative.reqmts].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#associative.reqmts">issues</a> in [associative.reqmts].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>Set::iterator is described as implementation-defined with a
reference to the container requirement; the container requirement says
that const_iterator is an iterator pointing to const T and iterator an
iterator pointing to T.</p>

<p>23.1.2 paragraph 2 implies that the keys should not be modified to
break the ordering of elements. But that is not clearly
specified. Especially considering that the current standard requires
that iterator for associative containers be different from
const_iterator. Set, for example, has the following: </p>

<p><tt>typedef implementation defined iterator;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // See _lib.container.requirements_</tt></p>

<p>23.2 [container.requirements] actually requires that iterator type pointing
to T (table 65). Disallowing user modification of keys by changing the
standard to require an iterator for associative container to be the
same as const_iterator would be overkill since that will unnecessarily
significantly restrict the usage of associative container. A class to
be used as elements of set, for example, can no longer be modified
easily without either redesigning the class (using mutable on fields
that have nothing to do with ordering), or using const_cast, which
defeats requiring iterator to be const_iterator. The proposed solution
goes in line with trusting user knows what he is doing. </p>

<p><b>Other Options Evaluated:</b> </p>

<p>Option A.&nbsp;&nbsp; In 23.2.4 [associative.reqmts], paragraph 2, after
first sentence, and before "In addition,...", add one line:
</p>

<blockquote>
  <p>Modification of keys shall not change their strict weak ordering. </p>
</blockquote>

<p>Option B.&nbsp;Add three new sentences to 23.2.4 [associative.reqmts]:</p>

<blockquote>
  <p>At the end of paragraph 5: "Keys in an associative container
  are immutable." At the end of paragraph 6: "For
  associative containers where the value type is the same as the key
  type, both <tt>iterator</tt> and <tt>const_iterator</tt> are
  constant iterators. It is unspecified whether or not
  <tt>iterator</tt> and <tt>const_iterator</tt> are the same
  type."</p>
</blockquote>

<p>Option C.&nbsp;To 23.2.4 [associative.reqmts], paragraph 3, which
currently reads:</p>

<blockquote>
  <p>The phrase ``equivalence of keys'' means the equivalence relation imposed by the
  comparison and not the operator== on keys. That is, two keys k1 and k2 in the same
  container are considered to be equivalent if for the comparison object comp, comp(k1, k2)
  == false &amp;&amp; comp(k2, k1) == false.</p>
</blockquote>

<p>&nbsp; add the following:</p>

<blockquote>
  <p>For any two keys k1 and k2 in the same container, comp(k1, k2) shall return the same
  value whenever it is evaluated. [Note: If k2 is removed from the container and later
  reinserted, comp(k1, k2) must still return a consistent value but this value may be
  different than it was the first time k1 and k2 were in the same container. This is
  intended to allow usage like a string key that contains a filename, where comp compares
  file contents; if k2 is removed, the file is changed, and the same k2 (filename) is
  reinserted, comp(k1, k2) must again return a consistent value but this value may be
  different than it was the previous time k2 was in the container.]</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>Add the following to 23.2.4 [associative.reqmts] at
the indicated location:</p>

<blockquote>
  <p>At the end of paragraph 3: "For any two keys k1 and k2 in the same container,
  calling comp(k1, k2) shall always return the same
  value."</p>
  <p>At the end of paragraph 5: "Keys in an associative container are immutable."</p>
  <p>At the end of paragraph 6: "For associative containers where the value type is the
  same as the key type, both <tt>iterator</tt> and <tt>const_iterator</tt> are constant
  iterators. It is unspecified whether or not <tt>iterator</tt> and <tt>const_iterator</tt>
  are the same type."</p>
</blockquote>


<p><b>Rationale:</b></p>
<p>Several arguments were advanced for and against allowing set elements to be
mutable as long as the ordering was not effected. The argument which swayed the
LWG was one of safety; if elements were mutable, there would be no compile-time
way to detect of a simple user oversight which caused ordering to be
modified.  There was a report that this had actually happened in practice,
and had been painful to diagnose.  If users need to modify elements,
it is possible to use mutable members or const_cast.</p>

<p>Simply requiring that keys be immutable is not sufficient, because the comparison
object may indirectly (via pointers) operate on values outside of the keys.</p>

<p>
The types <tt>iterator</tt> and <tt>const_iterator</tt> are permitted
to be different types to allow for potential future work in which some
member functions might be overloaded between the two types.  No such
member functions exist now, and the LWG believes that user functionality
will not be impaired by permitting the two types to be the same.  A
function that operates on both iterator types can be defined for 
<tt>const_iterator</tt> alone, and can rely on the automatic
conversion from <tt>iterator</tt> to <tt>const_iterator</tt>.
</p>

<p><i>[Tokyo: The LWG crafted the proposed resolution and rationale.]</i></p>






<hr>
<h3><a name="106"></a>106. Numeric library private members are implementation defined</h3>
<p><b>Section:</b> 26.6.5 [template.slice.array] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> AFNOR <b>Opened:</b> 1998-10-07 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#template.slice.array">issues</a> in [template.slice.array].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>This is the only place in the whole standard where the implementation has to document
something private.</p>


<p><b>Proposed resolution:</b></p>
<p>
Remove the comment which says "// remainder implementation defined" from:
</p>

<ul>
  <li>26.6.5 [template.slice.array]</li>
  <li>26.6.7 [template.gslice.array]</li>
  <li>26.6.8 [template.mask.array]</li>
  <li>26.6.9 [template.indirect.array]</li>
</ul>





<hr>
<h3><a name="108"></a>108. Lifetime of exception::what() return unspecified</h3>
<p><b>Section:</b> 18.7.1 [type.info] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> AFNOR <b>Opened:</b> 1998-10-07 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>In 18.6.1, paragraphs 8-9, the lifetime of the return value of
exception::what() is left unspecified. This issue has implications
with exception safety of exception handling: some exceptions should
not throw bad_alloc.</p>


<p><b>Proposed resolution:</b></p>
<p>Add to 18.7.1 [type.info] paragraph 9 (exception::what notes
clause) the sentence:</p>

<blockquote>
  <p>The return value remains valid until the exception object from which it is obtained is
  destroyed or a non-const member function of the exception object is called.</p>
</blockquote>


<p><b>Rationale:</b></p>
<p>If an exception object has non-const members, they may be used
to set internal state that should affect the contents of the string
returned by <tt>what()</tt>.
</p>





<hr>
<h3><a name="109"></a>109. Missing binders for non-const sequence elements</h3>
<p><b>Section:</b> D.11 [depr.lib.binders] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Bjarne Stroustrup <b>Opened:</b> 1998-10-07 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#depr.lib.binders">issues</a> in [depr.lib.binders].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>

<p>There are no versions of binders that apply to non-const elements
of a sequence. This makes examples like for_each() using bind2nd() on
page 521 of "The C++ Programming Language (3rd)"
non-conforming. Suitable versions of the binders need to be added.</p>

<p>Further discussion from Nico:</p>

<p>What is probably meant here is shown in the following example:</p>

<pre>class Elem { 
  public: 
    void print (int i) const { } 
    void modify (int i) { } 
}; </pre>
<pre>int main() 
{ 
    vector&lt;Elem&gt; coll(2); 
    for_each (coll.begin(), coll.end(), bind2nd(mem_fun_ref(&amp;Elem::print),42));    // OK 
    for_each (coll.begin(), coll.end(), bind2nd(mem_fun_ref(&amp;Elem::modify),42));   // ERROR 
}</pre>

<p>The error results from the fact that bind2nd() passes its first
argument (the argument of the sequence) as constant reference. See the
following typical implementation:</p>

<blockquote>
  <pre>template &lt;class Operation&gt; 
class binder2nd 
  : public unary_function&lt;typename Operation::first_argument_type, 
                          typename Operation::result_type&gt; { 
protected: 
  Operation op; 
  typename Operation::second_argument_type value; 
public: 
  binder2nd(const Operation&amp; o, 
            const typename Operation::second_argument_type&amp; v) 
      : op(o), value(v) {} </pre>
  <pre> typename Operation::result_type 
  operator()(const typename Operation::first_argument_type&amp; x) const { 
    return op(x, value); 
  } 
};</pre>
</blockquote>

<p>The solution is to overload operator () of bind2nd for non-constant arguments:</p>

<blockquote>
  <pre>template &lt;class Operation&gt; 
class binder2nd 
  : public unary_function&lt;typename Operation::first_argument_type, 
                          typename Operation::result_type&gt; { 
protected: 
  Operation op; 
  typename Operation::second_argument_type value; 
public: 
  binder2nd(const Operation&amp; o, 
            const typename Operation::second_argument_type&amp; v) 
      : op(o), value(v) {} </pre>
  <pre> typename Operation::result_type 
  operator()(const typename Operation::first_argument_type&amp; x) const { 
    return op(x, value); 
  } 
  typename Operation::result_type 
  operator()(typename Operation::first_argument_type&amp; x) const { 
    return op(x, value); 
  } 
};</pre>
</blockquote>


<p><b>Proposed resolution:</b></p>

<p><b>Howard believes there is a flaw</b> in this resolution.
See c++std-lib-9127.  We may need to reopen this issue.</p>

<p>In D.11 [depr.lib.binders] in the declaration of binder1st after:</p>
<blockquote>
  <p><tt>typename Operation::result_type<br>
  &nbsp;operator()(const typename Operation::second_argument_type&amp; x) const;</tt></p>
</blockquote>
<p>insert:</p>
<blockquote>
  <p><tt>typename Operation::result_type<br>
  &nbsp;operator()(typename Operation::second_argument_type&amp; x) const;</tt></p>
</blockquote>
<p>In D.11 [depr.lib.binders] in the declaration of binder2nd after:</p>
<blockquote>
  <p><tt>typename Operation::result_type<br>
  &nbsp;operator()(const typename Operation::first_argument_type&amp; x) const;</tt></p>
</blockquote>
<p>insert:</p>
<blockquote>
  <p><tt>typename Operation::result_type<br>
  &nbsp;operator()(typename Operation::first_argument_type&amp; x) const;</tt></p>
</blockquote>

<p><i>[Kona: The LWG discussed this at some length.It was agreed that
this is a mistake in the design, but there was no consensus on whether
it was a defect in the Standard.  Straw vote: NAD - 5.  Accept
proposed resolution - 3.  Leave open - 6.]</i></p>


<p><i>[Copenhagen: It was generally agreed that this was a defect.
Strap poll: NAD - 0.  Accept proposed resolution - 10. 
Leave open - 1.]</i></p>







<hr>
<h3><a name="110"></a>110. istreambuf_iterator::equal not const</h3>
<p><b>Section:</b> 24.6.3 [istreambuf.iterator], 24.6.3.5 [istreambuf.iterator::equal] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Nathan Myers <b>Opened:</b> 1998-10-15 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#istreambuf.iterator">issues</a> in [istreambuf.iterator].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>Member istreambuf_iterator&lt;&gt;::equal is not declared
"const", yet 24.6.3.6 [istreambuf.iterator::op==] says that operator==,
which is const, calls it. This is contradictory. </p>


<p><b>Proposed resolution:</b></p>
<p>In 24.6.3 [istreambuf.iterator] and also in 24.6.3.5 [istreambuf.iterator::equal],
replace:</p>

<blockquote>
  <pre>bool equal(istreambuf_iterator&amp; b);</pre>
</blockquote>

<p>with:</p>

<blockquote>
  <pre>bool equal(const istreambuf_iterator&amp; b) const;</pre>
</blockquote>





<hr>
<h3><a name="112"></a>112. Minor typo in <tt>ostreambuf_iterator</tt> constructor</h3>
<p><b>Section:</b> 24.6.4.1 [ostreambuf.iter.cons] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 1998-10-20 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>The <b>requires</b> clause for <tt>ostreambuf_iterator</tt>'s
constructor from an <tt>ostream_type</tt> (24.5.4.1, paragraph 1)
reads "<i>s</i> is not null". However, <i>s</i> is a
reference, and references can't be null. </p>


<p><b>Proposed resolution:</b></p>
<p>In 24.6.4.1 [ostreambuf.iter.cons]:</p>

<p>Move the current paragraph 1, which reads "Requires: s is not
null.", from the first constructor to the second constructor.</p>

<p>Insert a new paragraph 1 Requires clause for the first constructor
reading:</p>

<blockquote>
  <p><b>Requires</b>: <tt>s.rdbuf()</tt> is not null.</p>
</blockquote>





<hr>
<h3><a name="114"></a>114. Placement forms example in error twice</h3>
<p><b>Section:</b> 18.6.1.3 [new.delete.placement] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Steve Clamage <b>Opened:</b> 1998-10-28 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#new.delete.placement">issues</a> in [new.delete.placement].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#196">196</a></p>
<p><b>Discussion:</b></p>
<p>Section 18.5.1.3 contains the following example: </p>

<pre>[Example: This can be useful for constructing an object at a known address:
        char place[sizeof(Something)];
        Something* p = new (place) Something();
 -end example]</pre>

<p>First code line: "place" need not have any special alignment, and the
following constructor could fail due to misaligned data.</p>

<p>Second code line: Aren't the parens on Something() incorrect?&nbsp; [Dublin: the LWG
believes the () are correct.]</p>

<p>Examples are not normative, but nevertheless should not show code that is invalid or
likely to fail.</p>


<p><b>Proposed resolution:</b></p>
<p>Replace the first line of code in the example in 
18.6.1.3 [new.delete.placement] with:
</p>

<blockquote>
  <pre>void* place = operator new(sizeof(Something));</pre>
</blockquote>





<hr>
<h3><a name="115"></a>115. Typo in strstream constructors</h3>
<p><b>Section:</b> D.9.4.1 [depr.strstream.cons] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Steve Clamage <b>Opened:</b> 1998-11-02 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>D.7.4.1 strstream constructors paragraph 2 says: </p>

<blockquote>
  <p>Effects: Constructs an object of class strstream, initializing the base class with
  iostream(&amp; sb) and initializing sb with one of the two constructors: </p>
  <p>- If mode&amp;app==0, then s shall designate the first element of an array of n
  elements. The constructor is strstreambuf(s, n, s). </p>
  <p>- If mode&amp;app==0, then s shall designate the first element of an array of n
  elements that contains an NTBS whose first element is designated by s. The constructor is
  strstreambuf(s, n, s+std::strlen(s)).</p>
</blockquote>

<p>Notice the second condition is the same as the first. I think the second condition
should be "If mode&amp;app==app", or "mode&amp;app!=0", meaning that
the append bit is set.</p>


<p><b>Proposed resolution:</b></p>
<p>In D.9.3.1 [depr.ostrstream.cons] paragraph 2 and D.9.4.1 [depr.strstream.cons]
paragraph 2, change the first condition to <tt>(mode&amp;app)==0</tt>
and the second condition to <tt>(mode&amp;app)!=0</tt>.</p>





<hr>
<h3><a name="117"></a>117. <tt>basic_ostream</tt> uses nonexistent <tt>num_put</tt> member functions</h3>
<p><b>Section:</b> 27.7.2.6.2 [ostream.inserters.arithmetic] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 1998-11-20 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#ostream.inserters.arithmetic">issues</a> in [ostream.inserters.arithmetic].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>The <b>effects</b> clause for numeric inserters says that
insertion of a value <tt>x</tt>, whose type is either <tt>bool</tt>,
<tt>short</tt>, <tt>unsigned short</tt>, <tt>int</tt>, <tt>unsigned
int</tt>, <tt>long</tt>, <tt>unsigned long</tt>, <tt>float</tt>,
<tt>double</tt>, <tt>long double</tt>, or <tt>const void*</tt>, is
delegated to <tt>num_put</tt>, and that insertion is performed as if
through the following code fragment: </p>

<pre>bool failed = use_facet&lt;
   num_put&lt;charT,ostreambuf_iterator&lt;charT,traits&gt; &gt; 
   &gt;(getloc()).put(*this, *this, fill(), val). failed();</pre>

<p>This doesn't work, because <tt>num_put&lt;&gt;</tt>::put is only
overloaded for the types <tt>bool</tt>, <tt>long</tt>, <tt>unsigned
long</tt>, <tt>double</tt>, <tt>long double</tt>, and <tt>const
void*</tt>. That is, the code fragment in the standard is incorrect
(it is diagnosed as ambiguous at compile time) for the types
<tt>short</tt>, <tt>unsigned short</tt>, <tt>int</tt>, <tt>unsigned
int</tt>, and <tt>float</tt>. </p>

<p>We must either add new member functions to <tt>num_put</tt>, or
else change the description in <tt>ostream</tt> so that it only calls
functions that are actually there. I prefer the latter. </p>


<p><b>Proposed resolution:</b></p>
<p>Replace 27.6.2.5.2, paragraph 1 with the following: </p>

<blockquote>
<p>
The classes num_get&lt;&gt; and num_put&lt;&gt; handle locale-dependent numeric
formatting and parsing.  These inserter functions use the imbued
locale value to perform numeric formatting.  When val is of type bool,
long, unsigned long, double, long double, or const void*, the
formatting conversion occurs as if it performed the following code
fragment:
</p>

<pre>bool failed = use_facet&lt;
   num_put&lt;charT,ostreambuf_iterator&lt;charT,traits&gt; &gt;
   &gt;(getloc()).put(*this, *this, fill(), val). failed();
</pre>

<p>
When val is of type short the formatting conversion occurs as if it
performed the following code fragment:
</p>

<pre>ios_base::fmtflags baseflags = ios_base::flags() &amp; ios_base::basefield;
bool failed = use_facet&lt;
   num_put&lt;charT,ostreambuf_iterator&lt;charT,traits&gt; &gt;
   &gt;(getloc()).put(*this, *this, fill(),
      baseflags == ios_base::oct || baseflags == ios_base::hex
         ? static_cast&lt;long&gt;(static_cast&lt;unsigned short&gt;(val))
         : static_cast&lt;long&gt;(val)). failed();
</pre>

<p>
When val is of type int the formatting conversion occurs as if it performed
the following code fragment:
</p>

<pre>ios_base::fmtflags baseflags = ios_base::flags() &amp; ios_base::basefield;
bool failed = use_facet&lt;
   num_put&lt;charT,ostreambuf_iterator&lt;charT,traits&gt; &gt;
   &gt;(getloc()).put(*this, *this, fill(),
      baseflags == ios_base::oct || baseflags == ios_base::hex
         ? static_cast&lt;long&gt;(static_cast&lt;unsigned int&gt;(val))
         : static_cast&lt;long&gt;(val)). failed();
</pre>

<p>
When val is of type unsigned short or unsigned int the formatting conversion
occurs as if it performed the following code fragment:
</p>

<pre>bool failed = use_facet&lt;
   num_put&lt;charT,ostreambuf_iterator&lt;charT,traits&gt; &gt;
   &gt;(getloc()).put(*this, *this, fill(), static_cast&lt;unsigned long&gt;(val)).
failed();
</pre>

<p>
When val is of type float the formatting conversion occurs as if it
performed the following code fragment:
</p>

<pre>bool failed = use_facet&lt;
   num_put&lt;charT,ostreambuf_iterator&lt;charT,traits&gt; &gt;
   &gt;(getloc()).put(*this, *this, fill(), static_cast&lt;double&gt;(val)).
failed();
</pre>

</blockquote>

<p><i>[post-Toronto: This differs from the previous proposed
resolution; PJP provided the new wording.  The differences are in
signed short and int output.]</i></p>



<p><b>Rationale:</b></p>
<p>The original proposed resolution was to cast int and short to long,
unsigned int and unsigned short to unsigned long, and float to double,
thus ensuring that we don't try to use nonexistent num_put&lt;&gt;
member functions.  The current proposed resolution is more
complicated, but gives more expected results for hex and octal output
of signed short and signed int.  (On a system with 16-bit short, for
example, printing short(-1) in hex format should yield 0xffff.)</p>





<hr>
<h3><a name="118"></a>118. <tt>basic_istream</tt> uses nonexistent <tt>num_get</tt> member functions</h3>
<p><b>Section:</b> 27.7.1.2.2 [istream.formatted.arithmetic] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 1998-11-20 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#istream.formatted.arithmetic">issues</a> in [istream.formatted.arithmetic].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>Formatted input is defined for the types <tt>short</tt>, <tt>unsigned short</tt>, <tt>int</tt>,
<tt>unsigned int</tt>, <tt>long</tt>, <tt>unsigned long</tt>, <tt>float</tt>, <tt>double</tt>,
<tt>long double</tt>, <tt>bool</tt>, and <tt>void*</tt>. According to section 27.6.1.2.2,
formatted input of a value <tt>x</tt> is done as if by the following code fragment: </p>

<pre>typedef num_get&lt; charT,istreambuf_iterator&lt;charT,traits&gt; &gt; numget; 
iostate err = 0; 
use_facet&lt; numget &gt;(loc).get(*this, 0, *this, err, val); 
setstate(err);</pre>

<p>According to section 22.4.2.1.1 [facet.num.get.members], however,
<tt>num_get&lt;&gt;::get()</tt> is only overloaded for the types
<tt>bool</tt>, <tt>long</tt>, <tt>unsigned short</tt>, <tt>unsigned
int</tt>, <tt>unsigned long</tt>, <tt>unsigned long</tt>,
<tt>float</tt>, <tt>double</tt>, <tt>long double</tt>, and
<tt>void*</tt>. Comparing the lists from the two sections, we find
that 27.6.1.2.2 is using a nonexistent function for types
<tt>short</tt> and <tt>int</tt>. </p>


<p><b>Proposed resolution:</b></p>
<p>In 27.7.1.2.2 [istream.formatted.arithmetic] Arithmetic Extractors, remove the
two lines (1st and 3rd) which read:</p>
<blockquote>
  <pre>operator&gt;&gt;(short&amp; val);
...
operator&gt;&gt;(int&amp; val);</pre>
</blockquote>

<p>And add the following at the end of that section (27.6.1.2.2) :</p>

<blockquote>
  <pre>operator&gt;&gt;(short&amp; val);</pre>
  <p>The conversion occurs as if performed by the following code fragment (using
  the same notation as for the preceding code fragment):</p>
  <pre>  typedef num_get&lt; charT,istreambuf_iterator&lt;charT,traits&gt; &gt; numget;
  iostate err = 0;
  long lval;
  use_facet&lt; numget &gt;(loc).get(*this, 0, *this, err, lval);
        if (err == 0
                &amp;&amp; (lval &lt; numeric_limits&lt;short&gt;::min() || numeric_limits&lt;short&gt;::max() &lt; lval))
                err = ios_base::failbit;
  setstate(err);</pre>
  <pre>operator&gt;&gt;(int&amp; val);</pre>
  <p>The conversion occurs as if performed by the following code fragment (using
  the same notation as for the preceding code fragment):</p>
  <pre>  typedef num_get&lt; charT,istreambuf_iterator&lt;charT,traits&gt; &gt; numget;
  iostate err = 0;
  long lval;
  use_facet&lt; numget &gt;(loc).get(*this, 0, *this, err, lval);
        if (err == 0
                &amp;&amp; (lval &lt; numeric_limits&lt;int&gt;::min() || numeric_limits&lt;int&gt;::max() &lt; lval))
                err = ios_base::failbit;
  setstate(err);</pre>
</blockquote>

<p><i>[Post-Tokyo: PJP provided the above wording.]</i></p>






<hr>
<h3><a name="119"></a>119. Should virtual functions be allowed to strengthen the exception specification?</h3>
<p><b>Section:</b> 17.6.4.12 [res.on.exception.handling] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Judy Ward <b>Opened:</b> 1998-12-15 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#res.on.exception.handling">issues</a> in [res.on.exception.handling].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>Section 17.6.4.12 [res.on.exception.handling] states: </p>

<p>"An implementation may strengthen the exception-specification
for a function by removing listed exceptions." </p>

<p>The problem is that if an implementation is allowed to do this for
virtual functions, then a library user cannot write a class that
portably derives from that class. </p>

<p>For example, this would not compile if ios_base::failure::~failure
had an empty exception specification: </p>

<pre>#include &lt;ios&gt;
#include &lt;string&gt;

class D : public std::ios_base::failure {
public:
        D(const std::string&amp;);
        ~D(); // error - exception specification must be compatible with 
              // overridden virtual function ios_base::failure::~failure()
};</pre>


<p><b>Proposed resolution:</b></p>
<p>Change Section 17.6.4.12 [res.on.exception.handling] from:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp; "may strengthen the
exception-specification for a function"</p>

<p>to:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp; "may strengthen the
exception-specification for a non-virtual function". </p>





<hr>
<h3><a name="120"></a>120. Can an implementor add specializations?</h3>
<p><b>Section:</b> 17.6.3.3 [reserved.names] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Judy Ward <b>Opened:</b> 1998-12-15 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#reserved.names">issues</a> in [reserved.names].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>

<p>The original issue asked whether a library implementor could
specialize standard library templates for built-in types.  (This was
an issue because users are permitted to explicitly instantiate
standard library templates.)</p>

<p>Specializations are no longer a problem, because of the resolution
to core issue 259.  Under the proposed resolution, it will be legal
for a translation unit to contain both a specialization and an
explicit instantiation of the same template, provided that the
specialization comes first.  In such a case, the explicit
instantiation will be ignored.  Further discussion of library issue
120 assumes that the core 259 resolution will be adopted.</p>

<p>However, as noted in lib-7047, one piece of this issue still
remains: what happens if a standard library implementor explicitly
instantiates a standard library templates?  It's illegal for a program
to contain two different explicit instantiations of the same template
for the same type in two different translation units (ODR violation),
and the core working group doesn't believe it is practical to relax
that restriction.</p>

<p>The issue, then, is: are users allowed to explicitly instantiate
standard library templates for non-user defined types?  The status quo
answer is 'yes'.  Changing it to 'no' would give library implementors
more freedom.</p>

<p>This is an issue because, for performance reasons, library
implementors often need to explicitly instantiate standard library
templates.  (for example, std::basic_string&lt;char&gt;)  Does giving
users freedom to explicitly instantiate standard library templates for
non-user defined types make it impossible or painfully difficult for
library implementors to do this?</p>

<p>John Spicer suggests, in lib-8957, that library implementors have a
mechanism they can use for explicit instantiations that doesn't
prevent users from performing their own explicit instantiations: put
each explicit instantiation in its own object file.  (Different
solutions might be necessary for Unix DSOs or MS-Windows DLLs.)  On
some platforms, library implementors might not need to do anything
special: the "undefined behavior" that results from having two
different explicit instantiations might be harmless.</p>



<p><b>Proposed resolution:</b></p>
  <p>Append to 17.6.3.3 [reserved.names] paragraph 1: </p>
  <blockquote><p>
    A program may explicitly instantiate any templates in the standard
    library only if the declaration depends on the name of a user-defined
    type of external linkage and the instantiation meets the standard library
    requirements for the original template.
  </p></blockquote>

<p><i>[Kona: changed the wording from "a user-defined name" to "the name of
  a user-defined type"]</i></p>




<p><b>Rationale:</b></p>
<p>The LWG considered another possible resolution:</p>
<blockquote>
  <p>In light of the resolution to core issue 259, no normative changes
  in the library clauses are necessary.  Add the following non-normative
  note to the end of 17.6.3.3 [reserved.names] paragraph 1:</p>
  <blockquote><p>
    [<i>Note:</i> A program may explicitly instantiate standard library
    templates, even when an explicit instantiation does not depend on
    a user-defined name. <i>--end note</i>]
  </p></blockquote>
</blockquote>

<p>The LWG rejected this because it was believed that it would make
  it unnecessarily difficult for library implementors to write
  high-quality implementations.  A program may not include an
  explicit instantiation of the same template, for the same template
  arguments, in two different translation units.  If users are
  allowed to provide explicit instantiations of Standard Library
  templates for built-in types, then library implementors aren't,
  at least not without nonportable tricks.</p>

<p>The most serious problem is a class template that has writeable
  static member variables.  Unfortunately, such class templates are
  important and, in existing Standard Library implementations, are
  often explicitly specialized by library implementors: locale facets,
  which have a writeable static member variable <tt>id</tt>.  If a
  user's explicit instantiation collided with the implementations
  explicit instantiation, iostream initialization could cause locales
  to be constructed in an inconsistent state.</p>

<p>One proposed implementation technique was for Standard Library
  implementors to provide explicit instantiations in separate object
  files, so that they would not be picked up by the linker when the
  user also provides an explicit instantiation.  However, this
  technique only applies for Standard Library implementations that
  are packaged as static archives.  Most Standard Library
  implementations nowadays are packaged as dynamic libraries, so this
  technique would not apply.</p>

<p>The Committee is now considering standardization of dynamic
  linking.  If there are such changes in the future, it may be
  appropriate to revisit this issue later.</p>





<hr>
<h3><a name="122"></a>122. streambuf/wstreambuf description should not say they are specializations</h3>
<p><b>Section:</b> 27.6.2 [streambuf] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Judy Ward <b>Opened:</b> 1998-12-15 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#streambuf">issues</a> in [streambuf].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>Section 27.5.2 describes the streambuf classes this way: </p>

<blockquote>

<p>The class streambuf is a specialization of the template class basic_streambuf
specialized for the type char. </p>

<p>The class wstreambuf is a specialization of the template class basic_streambuf
specialized for the type wchar_t. </p>

</blockquote>

<p>This implies that these classes must be template specializations, not typedefs. </p>

<p>It doesn't seem this was intended, since Section 27.5 has them declared as typedefs. </p>


<p><b>Proposed resolution:</b></p>
<p>Remove 27.6.2 [streambuf] paragraphs 2 and 3 (the above two
sentences). </p>


<p><b>Rationale:</b></p>
<p>The <tt>streambuf</tt>  synopsis already has a declaration for the
typedefs and that is sufficient. </p>





<hr>
<h3><a name="123"></a>123. Should valarray helper arrays fill functions be const?</h3>
<p><b>Section:</b> 26.6.5.3 [slice.arr.fill], 26.6.7.3 [gslice.array.fill], 26.6.8.3 [mask.array.fill], 26.6.9.3 [indirect.array.fill] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Judy Ward <b>Opened:</b> 1998-12-15 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>One of the operator= in the valarray helper arrays is const and one
is not. For example, look at slice_array. This operator= in Section
26.6.5.1 [slice.arr.assign] is const: </p>

<p>&nbsp;&nbsp;&nbsp; <tt>void operator=(const valarray&lt;T&gt;&amp;) const;</tt> </p>

<p>but this one in Section 26.6.5.3 [slice.arr.fill] is not: </p>

<p>&nbsp;&nbsp;&nbsp; <tt>void operator=(const T&amp;); </tt></p>

<p>The description of the semantics for these two functions is similar. </p>


<p><b>Proposed resolution:</b></p>

<p>26.6.5 [template.slice.array] Template class slice_array</p>
<blockquote>

   <p>In the class template definition for slice_array, replace the member
   function declaration</p>
    <pre>      void operator=(const T&amp;);
    </pre>
   <p>with</p>
    <pre>      void operator=(const T&amp;) const;
    </pre>
</blockquote>

<p>26.6.5.3 [slice.arr.fill] slice_array fill function</p>
<blockquote>

   <p>Change the function declaration</p>
    <pre>      void operator=(const T&amp;);
    </pre>
   <p>to</p>
    <pre>      void operator=(const T&amp;) const;
    </pre>
</blockquote>

<p>26.6.7 [template.gslice.array] Template class gslice_array</p>
<blockquote>

   <p>In the class template definition for gslice_array, replace the member
   function declaration</p>
    <pre>      void operator=(const T&amp;);
    </pre>
   <p>with</p>
    <pre>      void operator=(const T&amp;) const;
    </pre>
</blockquote>

<p>26.6.7.3 [gslice.array.fill] gslice_array fill function</p>
<blockquote>

   <p>Change the function declaration</p>
    <pre>      void operator=(const T&amp;);
    </pre>
   <p>to</p>
    <pre>      void operator=(const T&amp;) const;
    </pre>
</blockquote>

<p>26.6.8 [template.mask.array] Template class mask_array</p>
<blockquote>

   <p>In the class template definition for mask_array, replace the member
   function declaration</p>
    <pre>      void operator=(const T&amp;);
    </pre>
   <p>with</p>
    <pre>      void operator=(const T&amp;) const;
    </pre>
</blockquote>

<p>26.6.8.3 [mask.array.fill] mask_array fill function</p>
<blockquote>

   <p>Change the function declaration</p>
    <pre>      void operator=(const T&amp;);
    </pre>
   <p>to</p>
    <pre>      void operator=(const T&amp;) const;
    </pre>
</blockquote>

<p>26.6.9 [template.indirect.array] Template class indirect_array</p>
<blockquote>

   <p>In the class template definition for indirect_array, replace the member
   function declaration</p>
    <pre>      void operator=(const T&amp;);
    </pre>
   <p>with</p>
    <pre>      void operator=(const T&amp;) const;
    </pre>
</blockquote>

<p>26.6.9.3 [indirect.array.fill] indirect_array fill function</p>
<blockquote>

   <p>Change the function declaration</p>
    <pre>      void operator=(const T&amp;);
    </pre>
   <p>to</p>
    <pre>      void operator=(const T&amp;) const;
    </pre>
</blockquote>


<p><i>[Redmond: Robert provided wording.]</i></p>




<p><b>Rationale:</b></p>
<p>There's no good reason for one version of operator= being const and
another one not.  Because of issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#253">253</a>, this now
matters: these functions are now callable in more circumstances.  In
many existing implementations, both versions are already const.</p>





<hr>
<h3><a name="124"></a>124. ctype_byname&lt;charT&gt;::do_scan_is &amp; do_scan_not return type should be const charT*</h3>
<p><b>Section:</b> 22.4.1.2 [locale.ctype.byname] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Judy Ward <b>Opened:</b> 1998-12-15 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.ctype.byname">issues</a> in [locale.ctype.byname].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>In Section 22.4.1.2 [locale.ctype.byname]
ctype_byname&lt;charT&gt;::do_scan_is() and do_scan_not() are declared
to return a const char* not a const charT*. </p>


<p><b>Proposed resolution:</b></p>
<p>Change Section 22.4.1.2 [locale.ctype.byname] <tt>do_scan_is()</tt> and
<tt>do_scan_not()</tt> to return a <tt> const
charT*</tt>. </p>





<hr>
<h3><a name="125"></a>125. valarray&lt;T&gt;::operator!() return type is inconsistent</h3>
<p><b>Section:</b> 26.6.2 [template.valarray] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Judy Ward <b>Opened:</b> 1998-12-15 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#template.valarray">issues</a> in [template.valarray].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>In Section 26.6.2 [template.valarray] valarray&lt;T&gt;::operator!() is
declared to return a valarray&lt;T&gt;, but in Section 26.6.2.5 [valarray.unary] it is declared to return a valarray&lt;bool&gt;. The
latter appears to be correct. </p>


<p><b>Proposed resolution:</b></p>
<p>Change in Section 26.6.2 [template.valarray] the declaration of
<tt>operator!()</tt> so that the return type is
<tt>valarray&lt;bool&gt;</tt>. </p>




<hr>
<h3><a name="126"></a>126. typos in Effects clause of ctype::do_narrow()</h3>
<p><b>Section:</b> 22.4.1.1.2 [locale.ctype.virtuals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Judy Ward <b>Opened:</b> 1998-12-15 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.ctype.virtuals">issues</a> in [locale.ctype.virtuals].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p><p>Typos in 22.2.1.1.2 need to be fixed.</p>

<p><b>Proposed resolution:</b></p>
<p>In Section 22.4.1.1.2 [locale.ctype.virtuals] change: </p>

<pre>   do_widen(do_narrow(c),0) == c</pre>

<p>to:</p>

<pre>   do_widen(do_narrow(c,0)) == c</pre>

<p>and change:</p>

<pre>   (is(M,c) || !ctc.is(M, do_narrow(c),dfault) )</pre>

<p>to:</p>

<pre>   (is(M,c) || !ctc.is(M, do_narrow(c,dfault)) )</pre>





<hr>
<h3><a name="127"></a>127. auto_ptr&lt;&gt; conversion issues</h3>
<p><b>Section:</b> D.12.1 [auto.ptr] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Greg Colvin <b>Opened:</b> 1999-02-17 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#auto.ptr">issues</a> in [auto.ptr].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>There are two problems with the current <tt>auto_ptr</tt> wording
in the standard: </p>

<p>First, the <tt>auto_ptr_ref</tt> definition cannot be nested
because <tt>auto_ptr&lt;Derived&gt;::auto_ptr_ref</tt> is unrelated to
<tt>auto_ptr&lt;Base&gt;::auto_ptr_ref</tt>.  <i>Also submitted by
Nathan Myers, with the same proposed resolution.</i></p>

<p>Second, there is no <tt>auto_ptr</tt> assignment operator taking an
<tt>auto_ptr_ref</tt> argument. </p>

<p>I have discussed these problems with my proposal coauthor, Bill
Gibbons, and with some compiler and library implementors, and we
believe that these problems are not desired or desirable implications
of the standard. </p>

<p>25 Aug 1999: The proposed resolution now reflects changes suggested
by Dave Abrahams, with Greg Colvin's concurrence; 1) changed
"assignment operator" to "public assignment
operator", 2) changed effects to specify use of release(), 3)
made the conversion to auto_ptr_ref const. </p>

<p>2 Feb 2000: Lisa Lippincott comments: [The resolution of] this issue
states that the conversion from auto_ptr to auto_ptr_ref should
be const.  This is not acceptable, because it would allow
initialization and assignment from _any_ const auto_ptr!  It also
introduces an implementation difficulty in writing this conversion
function -- namely, somewhere along the line, a const_cast will be
necessary to remove that const so that release() may be called.  This
may result in undefined behavior [7.1.5.1/4]. The conversion
operator does not have to be const, because a non-const implicit
object parameter may be bound to an rvalue [13.3.3.1.4/3]
[13.3.1/5]. </p>

  <p>Tokyo: The LWG removed the following from the proposed resolution:</p>

  <p>In 20.7.4 [meta.unary], paragraph 2, and 20.7.4.3 [meta.unary.prop], 
  paragraph 2, make the conversion to auto_ptr_ref const:</p>
  <blockquote>
    <pre>template&lt;class Y&gt; operator auto_ptr_ref&lt;Y&gt;() const throw();</pre>
  </blockquote>


<p><b>Proposed resolution:</b></p>
<p>In 20.7.4 [meta.unary], paragraph 2, move
the <tt>auto_ptr_ref</tt> definition to namespace scope.</p>

<p>In 20.7.4 [meta.unary], paragraph 2, add
a public assignment operator to the <tt>auto_ptr</tt> definition: </p>

<blockquote>
  <pre>auto_ptr&amp; operator=(auto_ptr_ref&lt;X&gt; r) throw();</pre>
</blockquote>

<p>Also add the assignment operator to 20.7.4.3 [meta.unary.prop]: </p>

<blockquote>
  <pre>auto_ptr&amp; operator=(auto_ptr_ref&lt;X&gt; r) throw()</pre>

  <p><b>Effects:</b> Calls <tt>reset(p.release())</tt> for the <tt>auto_ptr
  p</tt> that <tt>r</tt> holds a reference to.<br>
  <b>Returns: </b><tt>*this</tt>.</p>

</blockquote>





<hr>
<h3><a name="129"></a>129. Need error indication from seekp() and seekg()</h3>
<p><b>Section:</b> 27.7.1.3 [istream.unformatted], 27.7.2.5 [ostream.seeks] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Angelika Langer <b>Opened:</b> 1999-02-22 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#istream.unformatted">issues</a> in [istream.unformatted].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>Currently, the standard does not specify how seekg() and seekp()
indicate failure. They are not required to set failbit, and they can't
return an error indication because they must return *this, i.e. the
stream. Hence, it is undefined what happens if they fail. And they
<i>can</i> fail, for instance, when a file stream is disconnected from the
underlying file (is_open()==false) or when a wide character file
stream must perform a state-dependent code conversion, etc. </p>

<p>The stream functions seekg() and seekp() should set failbit in the
stream state in case of failure.</p>


<p><b>Proposed resolution:</b></p>
<p>Add to the Effects: clause of&nbsp; seekg() in 
27.7.1.3 [istream.unformatted] and to the Effects: clause of seekp() in
27.7.2.5 [ostream.seeks]: </p>

<blockquote>
  <p>In case of failure, the function calls <tt>setstate(failbit)</tt> (which may throw <tt>ios_base::failure</tt>).
  </p>
</blockquote>


<p><b>Rationale:</b></p>
<p>Setting failbit is the usual error reporting mechanism for streams</p>




<hr>
<h3><a name="130"></a>130. Return type of container::erase(iterator) differs for associative containers</h3>
<p><b>Section:</b> 23.2.4 [associative.reqmts], 23.2.3 [sequence.reqmts] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Andrew Koenig <b>Opened:</b> 1999-03-02 <b>Last modified:</b> 2010-10-29</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#associative.reqmts">active issues</a> in [associative.reqmts].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#associative.reqmts">issues</a> in [associative.reqmts].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#451">451</a></p>
<p><b>Discussion:</b></p>
<p>Table 67 (23.1.1) says that container::erase(iterator) returns an
iterator. Table 69 (23.1.2) says that in addition to this requirement,
associative containers also say that container::erase(iterator)
returns void.  That's not an addition; it's a change to the
requirements, which has the effect of making associative containers
fail to meet the requirements for containers.</p>


<p><b>Proposed resolution:</b></p>

<p>
In 23.2.4 [associative.reqmts], in Table 69 Associative container
requirements, change the return type of <tt>a.erase(q)</tt> from
<tt>void</tt> to <tt>iterator</tt>.  Change the
assertion/not/pre/post-condition from "erases the element pointed to
by <tt>q</tt>" to "erases the element pointed to by <tt>q</tt>.
Returns an iterator pointing to the element immediately following q
prior to the element being erased. If no such element exists, a.end()
is returned."
</p>

<p>
In 23.2.4 [associative.reqmts], in Table 69 Associative container
requirements, change the return type of <tt>a.erase(q1, q2)</tt>
from <tt>void</tt> to <tt>iterator</tt>.  Change the
assertion/not/pre/post-condition from "erases the elements in the
range <tt>[q1, q2)</tt>" to "erases the elements in the range <tt>[q1,
q2)</tt>.  Returns q2."
</p>

<p>
In 23.6.1 [map], in the <tt>map</tt> class synopsis; and 
in 23.6.2 [multimap], in the <tt>multimap</tt> class synopsis; and
in 23.6.3 [set], in the <tt>set</tt> class synopsis; and
in 23.6.4 [multiset], in the <tt>multiset</tt> class synopsis:
change the signature of the first <tt>erase</tt> overload to
</p>
<pre>   iterator erase(iterator position);
</pre>
<p>and change the signature of the third <tt>erase</tt> overload to</p>
<pre>  iterator erase(iterator first, iterator last); 
</pre>


<p><i>[Pre-Kona: reopened at the request of Howard Hinnant]</i></p>


<p><i>[Post-Kona: the LWG agrees the return type should be
<tt>iterator</tt>, not <tt>void</tt>.  (Alex Stepanov agrees too.)
Matt provided wording.]</i></p>


<p><i>[
 Sydney: the proposed wording went in the right direction, but it
 wasn't good enough. We want to return an iterator from the range form
 of erase as well as the single-iterator form. Also, the wording is
 slightly different from the wording we have for sequences; there's no
 good reason for having a difference.  Matt provided new wording,
(reflected above) which we will review at the next meeting.
]</i></p>


<p><i>[
Redmond:  formally voted into WP.
]</i></p>







<hr>
<h3><a name="132"></a>132. list::resize description uses random access iterators</h3>
<p><b>Section:</b> 23.3.4.2 [list.capacity] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 1999-03-06 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#list.capacity">issues</a> in [list.capacity].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>The description reads:</p>

<p>-1- Effects:</p>

<pre>         if (sz &gt; size())
           insert(end(), sz-size(), c);
         else if (sz &lt; size())
           erase(begin()+sz, end());
         else
           ;                           //  do nothing</pre>

<p>Obviously list::resize should not be specified in terms of random access iterators.</p>


<p><b>Proposed resolution:</b></p>
<p>Change 23.3.4.2 [list.capacity] paragraph 1 to:</p>

<p>Effects:</p>

<pre>         if (sz &gt; size())
           insert(end(), sz-size(), c);
         else if (sz &lt; size())
         {
           iterator i = begin();
           advance(i, sz);
           erase(i, end());
         }</pre>

<p><i>[Dublin: The LWG asked Howard to discuss exception safety offline
with David Abrahams. They had a discussion and believe there is
no issue of exception safety with the proposed resolution.]</i></p>






<hr>
<h3><a name="133"></a>133. map missing get_allocator()</h3>
<p><b>Section:</b> 23.6.1 [map] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 1999-03-06 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#map">issues</a> in [map].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p><p>The title says it all.</p>

<p><b>Proposed resolution:</b></p>
<p>Insert in 23.6.1 [map], paragraph 2,
after operator= in the map declaration:</p>

<pre>    allocator_type get_allocator() const;</pre>




<hr>
<h3><a name="134"></a>134. vector constructors over specified</h3>
<p><b>Section:</b> 23.4.1.1 [vector.cons] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 1999-03-06 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>The complexity description says: "It does at most 2N calls to the copy constructor
of T and logN reallocations if they are just input iterators ...".</p>

<p>This appears to be overly restrictive, dictating the precise memory/performance
tradeoff for the implementor.</p>


<p><b>Proposed resolution:</b></p>
<p>Change 23.4.1.1 [vector.cons], paragraph 1 to:</p>

<p>-1- Complexity: The constructor template &lt;class
InputIterator&gt; vector(InputIterator first, InputIterator last)
makes only N calls to the copy constructor of T (where N is the
distance between first and last) and no reallocations if iterators
first and last are of forward, bidirectional, or random access
categories. It makes order N calls to the copy constructor of T and
order logN reallocations if they are just input iterators.
</p>


<p><b>Rationale:</b></p>
<p>"at most 2N calls" is correct only if the growth factor
is greater than or equal to 2.
</p>




<hr>
<h3><a name="136"></a>136. seekp, seekg setting wrong streams?</h3>
<p><b>Section:</b> 27.7.1.3 [istream.unformatted] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 1999-03-06 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#istream.unformatted">issues</a> in [istream.unformatted].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>I may be misunderstanding the intent, but should not seekg set only
the input stream and seekp set only the output stream? The description
seems to say that each should set both input and output streams. If
that's really the intent, I withdraw this proposal.</p>


<p><b>Proposed resolution:</b></p>
<p>In section 27.6.1.3 change:</p>

<pre>basic_istream&lt;charT,traits&gt;&amp; seekg(pos_type pos);
Effects: If fail() != true, executes rdbuf()-&gt;pubseekpos(pos). </pre>

<p>To:</p>

<pre>basic_istream&lt;charT,traits&gt;&amp; seekg(pos_type pos);
Effects: If fail() != true, executes rdbuf()-&gt;pubseekpos(pos, ios_base::in). </pre>

<p>In section 27.6.1.3 change:</p>

<pre>basic_istream&lt;charT,traits&gt;&amp; seekg(off_type&amp; off, ios_base::seekdir dir);
Effects: If fail() != true, executes rdbuf()-&gt;pubseekoff(off, dir). </pre>

<p>To:</p>

<pre>basic_istream&lt;charT,traits&gt;&amp; seekg(off_type&amp; off, ios_base::seekdir dir);
Effects: If fail() != true, executes rdbuf()-&gt;pubseekoff(off, dir, ios_base::in). </pre>

<p>In section 27.6.2.4, paragraph 2 change:</p>

<pre>-2- Effects: If fail() != true, executes rdbuf()-&gt;pubseekpos(pos). </pre>

<p>To:</p>

<pre>-2- Effects: If fail() != true, executes rdbuf()-&gt;pubseekpos(pos, ios_base::out). </pre>

<p>In section 27.6.2.4, paragraph 4 change:</p>

<pre>-4- Effects: If fail() != true, executes rdbuf()-&gt;pubseekoff(off, dir). </pre>

<p>To:</p>

<pre>-4- Effects: If fail() != true, executes rdbuf()-&gt;pubseekoff(off, dir, ios_base::out). </pre>

<p><i>[Dublin: Dietmar Khl thinks this is probably correct, but would
like the opinion of more iostream experts before taking action.]</i></p>


<p><i>[Tokyo: Reviewed by the LWG. PJP noted that although his docs are
incorrect, his implementation already implements the Proposed
Resolution.]</i></p>


<p><i>[Post-Tokyo: Matt Austern comments:<br>
Is it a problem with basic_istream and basic_ostream, or is it a problem
with basic_stringbuf?
We could resolve the issue either by changing basic_istream and
basic_ostream, or by changing basic_stringbuf. I prefer the latter
change (or maybe both changes): I don't see any reason for the standard to
require that std::stringbuf s(std::string("foo"), std::ios_base::in);
s.pubseekoff(0, std::ios_base::beg); must fail.<br>
This requirement is a bit weird. There's no similar requirement
for basic_streambuf&lt;&gt;::seekpos, or for basic_filebuf&lt;&gt;::seekoff or
basic_filebuf&lt;&gt;::seekpos.]</i></p>






<hr>
<h3><a name="137"></a>137. Do use_facet and has_facet look in the global locale?</h3>
<p><b>Section:</b> 22.3.1 [locale] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Angelika Langer <b>Opened:</b> 1999-03-17 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale">issues</a> in [locale].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>Section 22.3.1 [locale] says:</p>

<p>-4- In the call to use_facet&lt;Facet&gt;(loc), the type argument
chooses a facet, making available all members of the named type. If
Facet is not present in a locale (or, failing that, in the global
locale), it throws the standard exception bad_cast. A C++ program can
check if a locale implements a particular facet with the template
function has_facet&lt;Facet&gt;(). </p>

<p>This contradicts the specification given in section 
22.3.2 [locale.global.templates]:
<br><br>
template &lt;class&nbsp; Facet&gt; const&nbsp; Facet&amp; use_facet(const
locale&amp;&nbsp; loc); <br>
<br>
-1- Get a reference to a facet of a locale. <br>
-2- Returns: a reference to the corresponding facet of loc, if present. <br>
-3- Throws: bad_cast if has_facet&lt;Facet&gt;(loc) is false. <br>
-4- Notes: The reference returned remains valid at least as long as any copy of loc exists
</p>


<p><b>Proposed resolution:</b></p>
<p>Remove the phrase "(or, failing that, in the global locale)"
from section 22.1.1. </p>


<p><b>Rationale:</b></p>
<p>Needed for consistency with the way locales are handled elsewhere
in the standard.</p>




<hr>
<h3><a name="139"></a>139. Optional sequence operation table description unclear</h3>
<p><b>Section:</b> 23.2.3 [sequence.reqmts] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Andrew Koenig <b>Opened:</b> 1999-03-30 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#sequence.reqmts">issues</a> in [sequence.reqmts].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>The sentence introducing the Optional sequence operation table
(23.1.1 paragraph 12) has two problems:</p>

<p>A. It says ``The operations in table 68 are provided only for the containers for which
they take constant time.''<br>
<br>
That could be interpreted in two ways, one of them being ``Even though table 68 shows
particular operations as being provided, implementations are free to omit them if they
cannot implement them in constant time.''<br>
<br>
B. That paragraph says nothing about amortized constant time, and it should.&nbsp;</p>


<p><b>Proposed resolution:</b></p>
<p>Replace the wording in 23.1.1 paragraph 12&nbsp; which begins ``The operations in table 68 are provided only..."
with:</p>

<blockquote>
  <p>Table 68 lists sequence operations that are provided for some types of sequential
  containers but not others. An implementation shall provide these operations for all
  container types shown in the ``container'' column, and shall implement them so as to take
  amortized constant time.</p>
</blockquote>




<hr>
<h3><a name="141"></a>141. basic_string::find_last_of, find_last_not_of say pos instead of xpos</h3>
<p><b>Section:</b> 21.4.6.4 [string::insert], 21.4.6.6 [string::replace] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Arch Robison <b>Opened:</b> 1999-04-28 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#string::insert">issues</a> in [string::insert].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>Sections 21.3.6.4 paragraph 1 and 21.3.6.6 paragraph 1 surely have misprints where they
say:<br>
<br>
 <tt>xpos &lt;= pos</tt> and <tt>pos &lt; size();</tt></p>

<p>Surely the document meant to say ``<tt>xpos &lt; size()</tt>'' in both places.</p>

<p><i>[Judy Ward also sent in this issue for 21.3.6.4 with the same
proposed resolution.]</i></p>



<p><b>Proposed resolution:</b></p>
<p>Change Sections 21.3.6.4 paragraph 1 and 21.3.6.6 paragraph 1, the line which says:<br>
<br>
 <tt>xpos &lt;= pos</tt> and <tt>pos &lt; size();<br>
<br>
</tt>to:<br>
<tt><br>
</tt> <tt>xpos &lt;= pos</tt> and <tt>xpos &lt; size();</tt></p>




<hr>
<h3><a name="142"></a>142. lexicographical_compare complexity wrong</h3>
<p><b>Section:</b> 25.4.8 [alg.lex.comparison] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 1999-06-20 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>The lexicographical_compare complexity is specified as:<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp; "At most min((last1 - first1), (last2 - first2))
applications of the corresponding comparison."<br>
<br>
The best I can do is twice that expensive.</p>

<p>Nicolai Josuttis comments in lib-6862: You mean, to check for
equality you have to check both &lt; and &gt;? Yes, IMO you are
right! (and Matt states this complexity in his book)</p>



<p><b>Proposed resolution:</b></p>
<p>Change 25.4.8 [alg.lex.comparison] complexity to:</p>
    <blockquote><p>
    At most <tt>2*min((last1 - first1), (last2 - first2))</tt>
    applications of the corresponding comparison.
    </p></blockquote>

<p>Change the example at the end of paragraph 3 to read:</p>
    <blockquote><p>
    [Example:<br>
    <br>
    &nbsp;&nbsp;&nbsp; for ( ; first1 != last1 &amp;&amp; first2 != last2 ;
    ++first1, ++first2) {<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (*first1 &lt; *first2) return true;<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (*first2 &lt; *first1) return false;<br>
    &nbsp;&nbsp;&nbsp; }<br>
    &nbsp;&nbsp;&nbsp; return first1 == last1 &amp;&amp; first2 != last2;<br>
    &nbsp;&nbsp;&nbsp;<br>
    --end example]
    </p></blockquote>




<hr>
<h3><a name="144"></a>144. Deque constructor complexity wrong </h3>
<p><b>Section:</b> 23.3.2.1 [deque.cons] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Herb Sutter <b>Opened:</b> 1999-05-09 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#deque.cons">issues</a> in [deque.cons].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>In 23.3.2.1 [deque.cons] paragraph 6, the deque ctor that takes an iterator range appears
to have complexity requirements which are incorrect, and which contradict the
complexity requirements for insert(). I suspect that the text in question,
below, was taken from vector:</p>
<blockquote>
  <p>Complexity: If the iterators first and last are forward iterators,
  bidirectional iterators, or random access iterators the constructor makes only
  N calls to the copy constructor, and performs no reallocations, where N is
  last - first.</p>
</blockquote>
<p>The word "reallocations" does not really apply to deque. Further,
all of the following appears to be spurious:</p>
<blockquote>
  <p>It makes at most 2N calls to the copy constructor of T and log N
  reallocations if they are input iterators.1)</p>
  <p>1) The complexity is greater in the case of input iterators because each
  element must be added individually: it is impossible to determine the distance
  between first abd last before doing the copying.</p>
</blockquote>
<p>This makes perfect sense for vector, but not for deque. Why should deque gain
an efficiency advantage from knowing in advance the number of elements to
insert?</p>


<p><b>Proposed resolution:</b></p>
<p>In 23.3.2.1 [deque.cons] paragraph 6, replace the Complexity description, including the
footnote, with the following text (which also corrects the "abd"
typo):</p>
<blockquote>
  <p>Complexity: Makes last - first calls to the copy constructor of T.</p>
</blockquote>




<hr>
<h3><a name="146"></a>146. complex&lt;T&gt; Inserter and Extractor need sentries</h3>
<p><b>Section:</b> 26.4.6 [complex.ops] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Angelika Langer <b>Opened:</b> 1999-05-12 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#complex.ops">issues</a> in [complex.ops].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>The extractor for complex numbers is specified as:&nbsp;</p>

<blockquote>

<p>     template&lt;class T, class charT, class traits&gt;&nbsp;<br>
     basic_istream&lt;charT, traits&gt;&amp;&nbsp;<br>
     operator&gt;&gt;(basic_istream&lt;charT, traits&gt;&amp;  is, complex&lt;T&gt;&amp;  x);<br>
&nbsp;<br>
Effects: Extracts a complex number x of the form: u, (u), or (u,v),
where u is the real part and v is the imaginary part
(lib.istream.formatted).&nbsp;<br>
Requires: The input values be convertible to T. If bad input is
encountered, calls is.setstate(ios::failbit) (which may throw
ios::failure (lib.iostate.flags).&nbsp;<br>
Returns: is .</p>

</blockquote>
<p>Is it intended that the extractor for complex numbers does not skip
whitespace, unlike all other extractors in the standard library do?
Shouldn't a sentry be used?&nbsp;<br>
<br>
The inserter for complex numbers is specified as:</p>

<blockquote>

<p>     template&lt;class T, class charT, class traits&gt;&nbsp;<br>
     basic_ostream&lt;charT, traits&gt;&amp;&nbsp;<br>
     operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp;  o, const complex&lt;T&gt;&amp;  x);<br>
<br>
Effects: inserts the complex number x onto the stream o as if it were implemented as follows:<br>
<br>
     template&lt;class T, class charT, class traits&gt;&nbsp;<br>
     basic_ostream&lt;charT, traits&gt;&amp;&nbsp;<br>
     operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp; o, const complex&lt;T&gt;&amp; x)&nbsp;<br>
     {&nbsp;<br>
             basic_ostringstream&lt;charT, traits&gt; s;&nbsp;<br>
             s.flags(o.flags());&nbsp;<br>
             s.imbue(o.getloc());&nbsp;<br>
             s.precision(o.precision());&nbsp;<br>
             s &lt;&lt; '(' &lt;&lt; x.real() &lt;&lt; "," &lt;&lt; x.imag() &lt;&lt; ')';&nbsp;<br>
             return o &lt;&lt; s.str();&nbsp;<br>
     }</p>

</blockquote>

<p>Is it intended that the inserter for complex numbers ignores the
field width and does not do any padding? If, with the suggested
implementation above, the field width were set in the stream then the
opening parentheses would be adjusted, but the rest not, because the
field width is reset to zero after each insertion.</p>

<p>I think that both operations should use sentries, for sake of
consistency with the other inserters and extractors in the
library. Regarding the issue of padding in the inserter, I don't know
what the intent was.&nbsp;</p>


<p><b>Proposed resolution:</b></p>
<p>After 26.4.6 [complex.ops] paragraph 14 (operator&gt;&gt;), add a
Notes clause:</p>

<blockquote>

<p>Notes: This extraction is performed as a series of simpler
extractions. Therefore, the skipping of whitespace is specified to be the
same for each of the simpler extractions.</p>

</blockquote>


<p><b>Rationale:</b></p>
<p>For extractors, the note is added to make it clear that skipping whitespace
follows an "all-or-none" rule.</p>

<p>For inserters, the LWG believes there is no defect; the standard is correct
as written.</p>




<hr>
<h3><a name="147"></a>147. Library Intro refers to global functions that aren't global</h3>
<p><b>Section:</b> 17.6.4.4 [global.functions] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Lois Goldthwaite <b>Opened:</b> 1999-06-04 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#global.functions">issues</a> in [global.functions].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>The library had many global functions until 17.4.1.1 [lib.contents]
paragraph 2 was added: </p>

<blockquote>

<p>All library entities except macros, operator new and operator
delete are defined within the namespace std or namespaces nested
within namespace std. </p>

</blockquote>

<p>It appears "global function" was never updated in the following: </p>

<blockquote>

<p>17.4.4.3 - Global functions [lib.global.functions]<br>
<br>
-1- It is unspecified whether any global functions in the C++ Standard
Library are defined as inline (dcl.fct.spec).<br>
<br>
-2- A call to a global function signature described in Clauses
lib.language.support through lib.input.output behaves the same as if
the implementation declares no additional global function
signatures.*<br>
<br>
    [Footnote: A valid C++ program always calls the expected library
    global function. An implementation may also define additional
    global functions that would otherwise not be called by a valid C++
    program. --- end footnote]<br>
<br>
-3- A global function cannot be declared by the implementation as
taking additional default arguments.&nbsp;<br>
<br>
17.4.4.4 - Member functions [lib.member.functions]<br>
<br>
-2- An implementation can declare additional non-virtual member
function signatures within a class: </p>

  <blockquote>

<p>-- by adding arguments with default values to a member function
signature; The same latitude does not extend to the implementation of
virtual or global functions, however. </p>

  </blockquote>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>     Change "global" to "global or non-member" in:</p>
<blockquote>
  <p>17.4.4.3 [lib.global.functions] section title,<br>
  17.4.4.3 [lib.global.functions] para 1,<br>
  17.4.4.3 [lib.global.functions] para 2 in 2 places plus 2 
           places in the footnote,<br>
  17.4.4.3 [lib.global.functions] para 3,<br>
  17.4.4.4 [lib.member.functions] para 2</p>
</blockquote>


<p><b>Rationale:</b></p>
<p>
Because operator new and delete are global, the proposed resolution
was changed from "non-member" to "global or non-member.
</p>




<hr>
<h3><a name="148"></a>148. Functions in the example facet BoolNames should be const</h3>
<p><b>Section:</b> 22.4.8 [facets.examples] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Jeremy Siek <b>Opened:</b> 1999-06-03 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#facets.examples">issues</a> in [facets.examples].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>In 22.4.8 [facets.examples] paragraph 13, the do_truename() and
do_falsename() functions in the example facet BoolNames should be
const. The functions they are overriding in
numpunct_byname&lt;char&gt; are const. </p>


<p><b>Proposed resolution:</b></p>
<p>In 22.4.8 [facets.examples] paragraph 13, insert "const" in
two places:</p>
<blockquote>
  <p><tt>string do_truename() const { return "Oui Oui!"; }<br>
  string do_falsename() const { return "Mais Non!"; }</tt></p>
</blockquote>




<hr>
<h3><a name="149"></a>149. Insert should return iterator to first element inserted</h3>
<p><b>Section:</b> 23.2.3 [sequence.reqmts] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Andrew Koenig <b>Opened:</b> 1999-06-28 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#sequence.reqmts">issues</a> in [sequence.reqmts].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>Suppose that c and c1 are sequential containers and i is an
iterator that refers to an element of c.  Then I can insert a copy of
c1's elements into c ahead of element i by executing </p>

<blockquote>

<pre>c.insert(i, c1.begin(), c1.end());</pre>

</blockquote>

<p>If c is a vector, it is fairly easy for me to find out where the
newly inserted elements are, even though i is now invalid: </p>

<blockquote>

<pre>size_t i_loc = i - c.begin();
c.insert(i, c1.begin(), c1.end());</pre>

</blockquote>

<p>and now the first inserted element is at c.begin()+i_loc and one
past the last is at c.begin()+i_loc+c1.size().<br>
<br>
But what if c is a list?  I can still find the location of one    past the last inserted element, because i is still valid.    To find the location of the first inserted element, though,    I must execute something like </p>

<blockquote>

<pre>for (size_t n = c1.size(); n; --n)
   --i;</pre>

</blockquote>

<p>because i is now no longer a random-access iterator.<br>
<br>
Alternatively, I might write something like </p>

<blockquote>

<pre>bool first = i == c.begin();
list&lt;T&gt;::iterator j = i;
if (!first) --j;
c.insert(i, c1.begin(), c1.end());
if (first)
   j = c.begin();
else
   ++j;</pre>

</blockquote>

<p>which, although wretched, requires less overhead.<br>
<br>
But I think the right solution is to change the definition of insert
so that instead of returning void, it returns an iterator that refers
to the first element inserted, if any, and otherwise is a copy of its
first argument.&nbsp; </p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Reopened by Alisdair.
</blockquote>

<p><i>[
Post Summit Alisdair adds:
]</i></p>


<blockquote>
<p>
In addition to the original rationale for C++03, this change also gives a
consistent interface for all container insert operations i.e. they all
return an iterator to the (first) inserted item.
</p>

<p>
Proposed wording provided.
</p>
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
Q: why isn't this change also proposed for associative containers?
</p>

<p>
A: The returned iterator wouldn't necessarily point to a contiguous range.
</p>

<p>
Moved to Ready.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
<sef ref="[sequence.reqmts]"> Table 83
change return type from <tt>void</tt> to <tt>iterator</tt> for the following rows:
</sef></p>

<blockquote>
<table border="1">
<caption>Table 83 -- Sequence container requirements (in addition to container)</caption>
<tbody><tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion/note pre-/post-condition</th>
</tr>
<tr>
<td>
<tt>a.insert(p,n,t)</tt>
</td>
<td>
<tt><del>void</del> <ins>iterator</ins></tt>
</td>
<td>
Inserts <tt>n</tt> copies of <tt>t</tt> before <tt>p</tt>.
</td>
</tr>

<tr>
<td>
<tt>a.insert(p,i,j)</tt>
</td>
<td>
<tt><del>void</del> <ins>iterator</ins></tt>
</td>
<td>
Each iterator in the range <tt>[i,j)</tt> shall be 
dereferenced exactly once. 
pre: <tt>i</tt> and <tt>j</tt> are not iterators into <tt>a</tt>. 
Inserts copies of elements in <tt>[i, j)</tt> before <tt>p</tt>
</td>
</tr>

<tr>
<td>
<tt>a.insert(p,il)</tt>
</td>
<td>
<tt><del>void</del> <ins>iterator</ins></tt>
</td>
<td>
<tt>a.insert(p, il.begin(), il.end())</tt>.
</td>
</tr>
</tbody></table>
</blockquote>

<p>
Add after p6 23.2.3 [sequence.reqmts]:
</p>

<blockquote>
<p>-6- ...</p>

<p><ins>
The iterator returned from <tt>a.insert(p,n,t)</tt> points to the copy of the
first element inserted into <tt>a</tt>, or <tt>p</tt> if <tt>n == 0</tt>.
</ins></p>

<p><ins>
The iterator returned from <tt>a.insert(p,i,j)</tt> points to the copy of the
first element inserted into <tt>a</tt>, or <tt>p</tt> if <tt>i == j</tt>.
</ins></p>

<p><ins>
The iterator returned from <tt>a.insert(p,il)</tt> points to the copy of the
first element inserted into <tt>a</tt>, or <tt>p</tt> if <tt>il</tt> is empty.
</ins></p>

</blockquote>

<p>
p2 23.3.2 [deque] Update class definition, change return type
from <tt>void</tt> to <tt>iterator</tt>:
</p>

<blockquote><pre><del>void</del> <ins>iterator</ins> insert(const_iterator position, size_type n, const T&amp; x);
template &lt;class InputIterator&gt;
  <del>void</del> <ins>iterator</ins> insert(const_iterator position, InputIterator first, InputIterator last);
  <del>void</del> <ins>iterator</ins> insert(const_iterator position, initializer_list&lt;T&gt;);
</pre></blockquote>

<p>
23.3.2.3 [deque.modifiers] change return type from <tt>void</tt> to <tt>iterator</tt> on following declarations:
</p>

<blockquote><pre>  <del>void</del> <ins>iterator</ins> insert(const_iterator position, size_type n, const T&amp; x);
template &lt;class InputIterator&gt;
  <del>void</del> <ins>iterator</ins> insert(const_iterator position, InputIterator first, InputIterator last);
</pre></blockquote>

<p>
Add the following (missing) declaration
</p>

<blockquote><pre><ins>iterator insert(const_iterator position, initializer_list&lt;T&gt;);</ins>
</pre></blockquote>

<p>
23.3.3 [forwardlist] Update class definition, change return type
from <tt>void</tt> to <tt>iterator</tt>:
</p>

<blockquote><pre><del>void</del> <ins>iterator</ins> insert_after(const_iterator position, initializer_list&lt;T&gt; il);
<del>void</del> <ins>iterator</ins> insert_after(const_iterator position, size_type n, const T&amp; x);
template &lt;class InputIterator&gt;
  <del>void</del> <ins>iterator</ins> insert_after(const_iterator position, InputIterator first, InputIterator last);
</pre></blockquote>

<p>
p8 23.3.3.4 [forwardlist.modifiers] change return type from <tt>void</tt> to <tt>iterator</tt>:
</p>

<blockquote><pre><del>void</del> <ins>iterator</ins> insert_after(const_iterator position, size_type n, const T&amp; x);
</pre></blockquote>

<p>
Add paragraph:
</p>

<blockquote>
Returns: position.
</blockquote>

<p>
p10 23.3.3.4 [forwardlist.modifiers] change return type from <tt>void</tt> to <tt>iterator</tt>:
</p>

<blockquote><pre>template &lt;class InputIterator&gt;
  <del>void</del> <ins>iterator</ins> insert_after(const_iterator position, InputIterator first, InputIterator last);
</pre></blockquote>

<p>
Add paragraph:
</p>

<blockquote>
Returns: position.
</blockquote>

<p>
p12 23.3.3.4 [forwardlist.modifiers] change return type from <tt>void</tt> to <tt>iterator</tt> on following declarations:
</p>

<blockquote><pre><del>void</del> <ins>iterator</ins> insert_after(const_iterator position, initializer_list&lt;T&gt; il);
</pre></blockquote>

<p>
change return type from <tt>void</tt> to <tt>iterator</tt> on following declarations:
</p>

<p>
p2 23.3.4 [list] Update class definition, change return type from <tt>void</tt> to <tt>iterator</tt>:
</p>

<blockquote><pre><del>void</del> <ins>iterator</ins> insert(const_iterator position, size_type n, const T&amp; x);

template &lt;class InputIterator&gt;
<del>void</del> <ins>iterator</ins> insert(const_iterator position, InputIterator first, InputIterator last);

<del>void</del> <ins>iterator</ins> insert(const_iterator position, initializer_list&lt;T&gt;);
</pre></blockquote>

<p>
23.3.4.3 [list.modifiers] change return type from <tt>void</tt> to <tt>iterator</tt> on following declarations:
</p>

<blockquote><pre><del>void</del> <ins>iterator</ins> insert(const_iterator position, size_type n, const T&amp; x);

template &lt;class InputIterator&gt;
  <del>void</del> <ins>iterator</ins> insert(const_iterator position, InputIterator first, InputIterator last);
</pre></blockquote>

<p>
Add the following (missing) declaration
</p>

<blockquote><pre>iterator insert(const_iterator position, initializer_list&lt;T&gt;);
</pre></blockquote>

<p>
p2 23.4.1 [vector]
</p>

<p>
Update class definition, change return type from <tt>void</tt> to <tt>iterator</tt>:
</p>

<blockquote><pre><del>void</del> <ins>iterator</ins> insert(const_iterator position, T&amp;&amp; x);

<del>void</del> <ins>iterator</ins> insert(const_iterator position, size_type n, const T&amp; x);

template &lt;class InputIterator&gt;
  <del>void</del> <ins>iterator</ins> insert(const_iterator position, InputIterator first, InputIterator last);

<del>void</del> <ins>iterator</ins> insert(const_iterator position, initializer_list&lt;T&gt;);
</pre></blockquote>

<p>
23.4.1.4 [vector.modifiers] change return type from <tt>void</tt> to <tt>iterator</tt> on following declarations:
</p>

<blockquote><pre><del>void</del> <ins>iterator</ins> insert(const_iterator position, size_type n, const T&amp; x);

template &lt;class InputIterator&gt;
  <del>void</del> <ins>iterator</ins> insert(const_iterator position, InputIterator first, InputIterator last);
</pre></blockquote>

<p>
Add the following (missing) declaration
</p>

<blockquote><pre>iterator insert(const_iterator position, initializer_list&lt;T&gt;);
</pre></blockquote>


<p>
p1 23.4.2 [vector.bool] Update class definition, change return type from <tt>void</tt> to <tt>iterator</tt>:
</p>

<blockquote><pre><del>void</del> <ins>iterator</ins> insert (const_iterator position, size_type n, const bool&amp; x);

template &lt;class InputIterator&gt;
  <del>void</del> <ins>iterator</ins> insert(const_iterator position, InputIterator first, InputIterator last);

  <del>void</del> <ins>iterator</ins> insert(const_iterator position, initializer_list&lt;bool&gt; il);
</pre></blockquote>

<p>
p5 21.4 [basic.string] Update class definition, change return type from <tt>void</tt> to <tt>iterator</tt>:
</p>

<blockquote><pre><del>void</del> <ins>iterator</ins> insert(const_iterator p, size_type n, charT c);

template&lt;class InputIterator&gt;
  <del>void</del> <ins>iterator</ins> insert(const_iterator p, InputIterator first, InputIterator last);

<del>void</del> <ins>iterator</ins> insert(const_iterator p, initializer_list&lt;charT&gt;);
</pre></blockquote>

<p>
p13 21.4.6.4 [string::insert] change return type from <tt>void</tt> to <tt>iterator</tt>:
</p>

<blockquote><pre><del>void</del> <ins>iterator</ins> insert(const_iterator p, size_type n, charT c);
</pre></blockquote>

<p>
Add paragraph:
</p>

<blockquote>
<i>Returns:</i> an iterator which refers to the copy of the first inserted
character, or <tt>p</tt> if <tt>n == 0</tt>.
</blockquote>

<p>
p15 21.4.6.4 [string::insert] change return type from <tt>void</tt> to <tt>iterator</tt>:
</p>

<blockquote><pre>template&lt;class InputIterator&gt;
  <del>void</del> <ins>iterator</ins> insert(const_iterator p, InputIterator first, InputIterator last);
</pre></blockquote>

<p>
Add paragraph:
</p>

<blockquote>
<i>Returns:</i> an iterator which refers to the copy of the first inserted
character, or <tt>p</tt> if <tt>first == last</tt>.
</blockquote>

<p>
p17 21.4.6.4 [string::insert] change return type from <tt>void</tt> to <tt>iterator</tt>:
</p>

<blockquote><pre><del>void</del> <ins>iterator</ins> insert(const_iterator p, initializer_list&lt;charT&gt; il);
</pre></blockquote>

<p>
Add paragraph:
</p>

<blockquote>
<i>Returns:</i> an iterator which refers to the copy of the first inserted
character, or <tt>p</tt> if <tt>il</tt> is empty.
</blockquote>



<p><b>Rationale:</b></p>

<p><i>[
The following was the C++98/03 rationale and does not necessarily apply to the
proposed resolution in the C++0X time frame:
]</i></p>


<blockquote>
<p>The LWG believes this was an intentional design decision and so is
not a defect. It may be worth revisiting for the next standard.</p>
</blockquote>




<hr>
<h3><a name="150"></a>150. Find_first_of says integer instead of iterator </h3>
<p><b>Section:</b> 25.2.7 [alg.find.first.of] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Matt McClure <b>Opened:</b> 1999-06-30 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.find.first.of">issues</a> in [alg.find.first.of].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>


<p><b>Proposed resolution:</b></p>
<p>Change 25.2.7 [alg.find.first.of] paragraph 2 from:</p>

<blockquote>
<p>Returns: The first iterator i in the range [first1, last1) such
that for some integer j in the range [first2, last2) ...</p>
</blockquote>

<p>to:</p>

<blockquote>
<p>Returns: The first iterator i in the range [first1, last1) such
that for some iterator j in the range [first2, last2) ...</p>
</blockquote>




<hr>
<h3><a name="151"></a>151. Can't currently clear() empty container</h3>
<p><b>Section:</b> 23.2.3 [sequence.reqmts] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Ed Brey <b>Opened:</b> 1999-06-21 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#sequence.reqmts">issues</a> in [sequence.reqmts].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>For both sequences and associative containers, a.clear() has the
semantics of erase(a.begin(),a.end()), which is undefined for an empty
container since erase(q1,q2) requires that q1 be dereferenceable
(23.1.1,3 and 23.1.2,7).  When the container is empty, a.begin() is
not dereferenceable.<br>
<br>
The requirement that q1 be unconditionally dereferenceable causes many
operations to be intuitively undefined, of which clearing an empty
container is probably the most dire.<br>
<br>
Since q1 and q2 are only referenced in the range [q1, q2), and [q1,
q2) is required to be a valid range, stating that q1 and q2 must be
iterators or certain kinds of iterators is unnecessary.
</p>


<p><b>Proposed resolution:</b></p>
<p>In 23.1.1, paragraph 3, change:</p>
<blockquote>
  <p>p and q2 denote valid iterators to a, q and q1 denote valid dereferenceable iterators to a, [q1, q2) denotes a valid range</p>
</blockquote>
<p>to:</p>
<blockquote>
  <p>p denotes a valid iterator to a, q denotes a valid dereferenceable iterator to a, [q1, q2) denotes a valid range
  in a</p>
</blockquote>
<p>In 23.1.2, paragraph 7, change:</p>
<blockquote>
  <p>p and q2 are valid iterators to a, q and q1 are valid dereferenceable
  iterators to a, [q1, q2) is a valid range</p>
</blockquote>
<p>to</p>
<blockquote>
  <p>p is a valid iterator to a, q is a valid dereferenceable iterator to a, [q1, q2) is a valid range
  into a</p>
</blockquote>




<hr>
<h3><a name="152"></a>152. Typo in <tt>scan_is()</tt> semantics</h3>
<p><b>Section:</b> 22.4.1.1.2 [locale.ctype.virtuals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Dietmar Khl <b>Opened:</b> 1999-07-20 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.ctype.virtuals">issues</a> in [locale.ctype.virtuals].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>The semantics of <tt>scan_is()</tt> (paragraphs 4 and 6) is not exactly described
because there is no function <tt>is()</tt> which only takes a character as
argument. Also, in the effects clause (paragraph 3), the semantic is also kept
vague.</p>


<p><b>Proposed resolution:</b></p>
<p>In 22.4.1.1.2 [locale.ctype.virtuals] paragraphs 4 and 6, change the returns
clause from:</p>
<blockquote>
  <p>"... such that <tt>is(*p)</tt>
would..."</p>
</blockquote>
<p>to:&nbsp; "... such that <tt>is(m, *p)</tt>
 would...."</p>





<hr>
<h3><a name="153"></a>153. Typo in <tt>narrow()</tt> semantics</h3>
<p><b>Section:</b> 22.4.1.3.2 [facet.ctype.char.members] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Dietmar Khl <b>Opened:</b> 1999-07-20 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#facet.ctype.char.members">issues</a> in [facet.ctype.char.members].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#207">207</a></p>
<p><b>Discussion:</b></p>
<p>The description of the array version of <tt>narrow()</tt> (in
paragraph 11) is flawed: There is no member <tt>do_narrow()</tt> which
takes only three arguments because in addition to the range a default
character is needed.</p>

<p>Additionally, for both <tt>widen</tt> and <tt>narrow</tt> we have
two signatures followed by a <b>Returns</b> clause that only addresses
one of them.</p>



<p><b>Proposed resolution:</b></p>
<p>Change the returns clause in 22.4.1.3.2 [facet.ctype.char.members]
paragraph 10 from:</p>
<p>&nbsp;&nbsp;&nbsp; Returns: do_widen(low, high, to).</p>

<p>to:</p>
<p>&nbsp;&nbsp;&nbsp; Returns: do_widen(c) or do_widen(low, high, to), 
respectively.</p>

<p>Change 22.4.1.3.2 [facet.ctype.char.members] paragraph 10 and 11 from:</p>
<pre>        char        narrow(char c, char /*dfault*/) const;
        const char* narrow(const char* low, const char* high,
                           char /*dfault*/, char* to) const;</pre>
<pre>        Returns: do_narrow(low, high, to).</pre>
<p>to:</p>
<pre>        char        narrow(char c, char dfault) const;
        const char* narrow(const char* low, const char* high,
                           char dfault, char* to) const;</pre>
<pre>        Returns: do_narrow(c, dfault) or
                 do_narrow(low, high, dfault, to), respectively.</pre>

<p><i>[Kona: 1) the problem occurs in additional places, 2) a user
defined version could be different.]</i></p>


<p><i>[Post-Tokyo: Dietmar provided the above wording at the request of
the LWG. He could find no other places the problem occurred. He
asks for clarification of the Kona "a user defined
version..." comment above.  Perhaps it was a circuitous way of
saying "dfault" needed to be uncommented?]</i></p>


<p><i>[Post-Toronto: the issues list maintainer has merged in the
proposed resolution from issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#207">207</a>, which addresses the
same paragraphs.]</i></p>






<hr>
<h3><a name="154"></a>154. Missing <tt>double</tt> specifier for <tt>do_get()</tt></h3>
<p><b>Section:</b> 22.4.2.1.2 [facet.num.get.virtuals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Dietmar Khl <b>Opened:</b> 1999-07-20 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#facet.num.get.virtuals">issues</a> in [facet.num.get.virtuals].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>The table in paragraph 7 for the length modifier does not list the length
modifier <tt>l</tt> to be applied if the type is <tt>double</tt>. Thus, the
standard asks the implementation to do undefined things when using <tt>scanf()</tt>
(the missing length modifier for <tt>scanf()</tt> when scanning <tt>double</tt>s
is actually a problem I found quite often in production code, too).</p>


<p><b>Proposed resolution:</b></p>
<p>In 22.4.2.1.2 [facet.num.get.virtuals], paragraph 7, add a row in the Length
Modifier table to say that for <tt>double</tt> a length modifier
<tt>l</tt> is to be used.</p>


<p><b>Rationale:</b></p>
<p>The standard makes an embarrassing beginner's mistake.</p>




<hr>
<h3><a name="155"></a>155. Typo in naming the class defining the class <tt>Init</tt></h3>
<p><b>Section:</b> 27.4 [iostream.objects] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Dietmar Khl <b>Opened:</b> 1999-07-20 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#iostream.objects">issues</a> in [iostream.objects].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>There are conflicting statements about where the class
<tt>Init</tt> is defined. According to 27.4 [iostream.objects] paragraph 2
it is defined as <tt>basic_ios::Init</tt>, according to 27.5.2 [ios.base] it is defined as <tt>ios_base::Init</tt>.</p>


<p><b>Proposed resolution:</b></p>
<p>Change 27.4 [iostream.objects] paragraph 2 from
"<tt>basic_ios::Init"</tt> to
"<tt>ios_base::Init"</tt>.</p>


<p><b>Rationale:</b></p>
<p>Although not strictly wrong, the standard was misleading enough to warrant
the change.</p>




<hr>
<h3><a name="156"></a>156. Typo in <tt>imbue()</tt> description</h3>
<p><b>Section:</b> 27.5.2.3 [ios.base.locales] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Dietmar Khl <b>Opened:</b> 1999-07-20 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#ios.base.locales">issues</a> in [ios.base.locales].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>There is a small discrepancy between the declarations of
<tt>imbue()</tt>: in 27.5.2 [ios.base] the argument is passed as
<tt>locale const&amp;</tt> (correct), in 27.5.2.3 [ios.base.locales] it
is passed as <tt>locale const</tt> (wrong).</p>


<p><b>Proposed resolution:</b></p>
<p>In 27.5.2.3 [ios.base.locales] change the <tt>imbue</tt> argument
from "<tt>locale const" to "locale
const&amp;".</tt></p>




<hr>
<h3><a name="158"></a>158. Underspecified semantics for <tt>setbuf()</tt></h3>
<p><b>Section:</b> 27.6.2.4.2 [streambuf.virt.buffer] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Dietmar Khl <b>Opened:</b> 1999-07-20 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#streambuf.virt.buffer">issues</a> in [streambuf.virt.buffer].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>The default behavior of <tt>setbuf()</tt> is described only for the
situation that <tt>gptr() != 0 &amp;&amp; gptr() != egptr()</tt>:
namely to do nothing.  What has to be done in other situations&nbsp;
is not described although there is actually only one reasonable
approach, namely to do nothing, too.</p> 

<p>Since changing the buffer would almost certainly mess up most
buffer management of derived classes unless these classes do it
themselves, the default behavior of <tt>setbuf()</tt> should always be
to do nothing.</p>


<p><b>Proposed resolution:</b></p>
<p>Change 27.6.2.4.2 [streambuf.virt.buffer], paragraph 3, Default behavior,
to: "Default behavior: Does nothing. Returns this."</p>




<hr>
<h3><a name="159"></a>159. Strange use of <tt>underflow()</tt></h3>
<p><b>Section:</b> 27.6.2.4.3 [streambuf.virt.get] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Dietmar Khl <b>Opened:</b> 1999-07-20 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>The description of the meaning of the result of
<tt>showmanyc()</tt> seems to be rather strange: It uses calls to
<tt>underflow()</tt>. Using <tt>underflow()</tt> is strange because
this function only reads the current character but does not extract
it, <tt>uflow()</tt> would extract the current character. This should
be fixed to use <tt>sbumpc()</tt> instead.</p>


<p><b>Proposed resolution:</b></p>
<p>Change 27.6.2.4.3 [streambuf.virt.get] paragraph 1,
<tt>showmanyc()</tt>returns clause, by replacing the word
"supplied" with the words "extracted from the
stream".</p>




<hr>
<h3><a name="160"></a>160. Typo: Use of non-existing function <tt>exception()</tt></h3>
<p><b>Section:</b> 27.7.1.1 [istream] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Dietmar Khl <b>Opened:</b> 1999-07-20 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#istream">issues</a> in [istream].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>The paragraph 4 refers to the function <tt>exception()</tt> which
is not defined. Probably, the referred function is
<tt>basic_ios&lt;&gt;::exceptions()</tt>.</p>


<p><b>Proposed resolution:</b></p>
<p>In 27.7.1.1 [istream], 27.7.1.3 [istream.unformatted], paragraph 1,
27.7.2.1 [ostream], paragraph 3, and 27.7.2.6.1 [ostream.formatted.reqmts],
paragraph 1, change "<tt>exception()" to
"exceptions()"</tt>.</p>

<p><i>[Note to Editor: "exceptions" with an "s"
is the correct spelling.]</i></p>






<hr>
<h3><a name="161"></a>161. Typo: <tt>istream_iterator</tt> vs. <tt>istreambuf_iterator</tt></h3>
<p><b>Section:</b> 27.7.1.2.2 [istream.formatted.arithmetic] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Dietmar Khl <b>Opened:</b> 1999-07-20 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#istream.formatted.arithmetic">issues</a> in [istream.formatted.arithmetic].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>The note in the second paragraph pretends that the first argument
is an object of type <tt>istream_iterator</tt>. This is wrong: It is
an object of type <tt>istreambuf_iterator</tt>.</p>


<p><b>Proposed resolution:</b></p>
<p>Change 27.7.1.2.2 [istream.formatted.arithmetic] from:</p>
<blockquote>
  <p>The first argument provides an object of the istream_iterator class...</p>
</blockquote>
<p>to</p>
<blockquote>
  <p>The first argument provides an object of the istreambuf_iterator class...</p>
</blockquote>





<hr>
<h3><a name="164"></a>164. do_put() has apparently unused fill argument</h3>
<p><b>Section:</b> 22.4.5.3.2 [locale.time.put.virtuals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Angelika Langer <b>Opened:</b> 1999-07-23 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>In 22.4.5.3.2 [locale.time.put.virtuals] the do_put() function is specified
as taking a fill character as an argument, but the description of the
function does not say whether the character is used at all and, if so,
in which way. The same holds for any format control parameters that
are accessible through the ios_base&amp; argument, such as the
adjustment or the field width. Is strftime() supposed to use the fill
character in any way? In any case, the specification of
time_put.do_put() looks inconsistent to me.<br> <br> Is the
signature of do_put() wrong, or is the effects clause incomplete?</p>


<p><b>Proposed resolution:</b></p>
<p>Add the following note after 22.4.5.3.2 [locale.time.put.virtuals]
paragraph 2:</p>
<blockquote>
  <p>  [Note: the <tt>fill</tt> argument may be used in the implementation-defined  formats, or by derivations.  A space character is a reasonable default
  for this argument. --end Note]</p>
</blockquote>


<p><b>Rationale:</b></p>
<p>The LWG felt that while the normative text was correct,
users need some guidance on what to pass for the <tt>fill</tt>
argument since the standard doesn't say how it's used.</p>




<hr>
<h3><a name="165"></a>165. <tt>xsputn()</tt>, <tt>pubsync()</tt> never called by <tt>basic_ostream</tt> members?</h3>
<p><b>Section:</b> 27.7.2.1 [ostream] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Dietmar Khl <b>Opened:</b> 1999-07-20 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#ostream">issues</a> in [ostream].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>Paragraph 2 explicitly states that none of the <tt>basic_ostream</tt>
functions falling into one of the groups "formatted output functions"
and "unformatted output functions" calls any stream buffer function
which might call a virtual function other than <tt>overflow()</tt>. Basically
this is fine but this implies that <tt>sputn()</tt> (this function would call
the virtual function <tt>xsputn()</tt>) is never called by any of the standard
output functions. Is this really intended? At minimum it would be convenient to
call <tt>xsputn()</tt> for strings... Also, the statement that <tt>overflow()</tt>
is the only virtual member of <tt>basic_streambuf</tt> called is in conflict
with the definition of <tt>flush()</tt> which calls <tt>rdbuf()-&gt;pubsync()</tt>
and thereby the virtual function <tt>sync()</tt> (<tt>flush()</tt> is listed
under "unformatted output functions").</p>
<p>In addition, I guess that the sentence starting with "They may use other
public members of <tt>basic_ostream</tt> ..." probably was intended to
start with "They may use other public members of <tt>basic_streamuf</tt>..."
although the problem with the virtual members exists in both cases.</p>
<p>I see two obvious resolutions:</p>
<ol>
  <li>state in a footnote that this means that <tt>xsputn()</tt> will never be
    called by any ostream member and that this is intended.</li>
  <li>relax the restriction and allow calling <tt>overflow()</tt> and <tt>xsputn()</tt>.
    Of course, the problem with <tt>flush()</tt> has to be resolved in some way.</li>
</ol>


<p><b>Proposed resolution:</b></p>
<p>Change the last sentence of 27.6.2.1 (lib.ostream) paragraph 2 from:</p>
<blockquote>
  <p>They may use other public members of basic_ostream except that they do not
  invoke any virtual members of rdbuf() except overflow().</p>
</blockquote>
<p>to:</p>
<blockquote>
  <p>They may use other public members of basic_ostream except that they shall
  not invoke any virtual members of rdbuf() except overflow(), xsputn(), and
  sync().</p>
</blockquote>

<p><i>[Kona: the LWG believes this is a problem. Wish to ask Jerry or
PJP why the standard is written this way.]</i></p>


<p><i>[Post-Tokyo: Dietmar supplied wording at the request of the
LWG. He comments: The rules can be made a little bit more specific if
necessary be explicitly spelling out what virtuals are allowed to be
called from what functions and eg to state specifically that flush()
is allowed to call sync() while other functions are not.]</i></p>






<hr>
<h3><a name="167"></a>167. Improper use of <tt>traits_type::length()</tt></h3>
<p><b>Section:</b> 27.7.2.6.4 [ostream.inserters.character] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Dietmar Khl <b>Opened:</b> 1999-07-20 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#ostream.inserters.character">issues</a> in [ostream.inserters.character].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>Paragraph 4 states that the length is determined using
<tt>traits::length(s)</tt>.  Unfortunately, this function is not
defined for example if the character type is <tt>wchar_t</tt> and the
type of <tt>s</tt> is <tt>char const*</tt>. Similar problems exist if
the character type is <tt>char</tt> and the type of <tt>s</tt> is
either <tt>signed char const*</tt> or <tt>unsigned char
const*</tt>.</p>


<p><b>Proposed resolution:</b></p>
<p>Change 27.7.2.6.4 [ostream.inserters.character] paragraph 4 from:</p>
<blockquote>
  <p>Effects: Behaves like an formatted inserter (as described in
  lib.ostream.formatted.reqmts) of out. After a sentry object is
  constructed it inserts characters. The number of characters starting
  at s to be inserted is traits::length(s). Padding is determined as
  described in lib.facet.num.put.virtuals. The traits::length(s)
  characters starting at s are widened using out.widen
  (lib.basic.ios.members). The widened characters and any required
  padding are inserted into out. Calls width(0).</p>
</blockquote>
<p>to:</p>
<blockquote>
  <p>Effects: Behaves like a formatted inserter (as described in
  lib.ostream.formatted.reqmts) of out. After a sentry object is
  constructed it inserts <i>n</i> characters starting at <i>s</i>,
  where <i>n</i> is the number that would be computed as if by:</p>
  <ul>
  <li>traits::length(s) for the overload where the first argument is of
    type basic_ostream&lt;charT, traits&gt;&amp; and the second is
    of type const charT*, and also for the overload where the first
    argument is of type basic_ostream&lt;char, traits&gt;&amp; and
    the second is of type const char*.</li>
  <li>std::char_traits&lt;char&gt;::length(s) 
    for the overload where the first argument is of type 
    basic_ostream&lt;charT, traits&gt;&amp; and the second is of type
    const char*.</li>
  <li>traits::length(reinterpret_cast&lt;const char*&gt;(s)) 
    for the other two overloads.</li>
  </ul>
  <p>Padding is determined as described in
  lib.facet.num.put.virtuals. The <i>n</i> characters starting at
  <i>s</i> are widened using out.widen (lib.basic.ios.members).  The
  widened characters and any required padding are inserted into
  out. Calls width(0).</p>
</blockquote>

<p><i>[Santa Cruz: Matt supplied new wording]</i></p>


<p><i>[Kona: changed "where <i>n</i> is" to " where <i>n</i> is the
  number that would be computed as if by"]</i></p>
 



<p><b>Rationale:</b></p>
<p>We have five separate cases.  In two of them we can use the
user-supplied traits class without any fuss.  In the other three we
try to use something as close to that user-supplied class as possible.
In two cases we've got a traits class that's appropriate for
char and what we've got is a const signed char* or a const
unsigned char*; that's close enough so we can just use a reinterpret
cast, and continue to use the user-supplied traits class.  Finally,
there's one case where we just have to give up: where we've got a
traits class for some arbitrary charT type, and we somehow have to
deal with a const char*.  There's nothing better to do but fall back
to char_traits&lt;char&gt;</p>





<hr>
<h3><a name="168"></a>168. Typo: formatted vs. unformatted</h3>
<p><b>Section:</b> 27.7.2.7 [ostream.unformatted] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Dietmar Khl <b>Opened:</b> 1999-07-20 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#ostream.unformatted">issues</a> in [ostream.unformatted].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>The first paragraph begins with a descriptions what has to be done
in <i>formatted</i> output functions. Probably this is a typo and the
paragraph really want to describe unformatted output functions...</p>


<p><b>Proposed resolution:</b></p>
<p>In 27.7.2.7 [ostream.unformatted] paragraph 1, the first and last
sentences, change the word "formatted" to
"unformatted":</p>
<blockquote>
  <p>"Each <b>unformatted </b> output function begins ..."<br>
  "... value specified for the <b>unformatted </b>  output 
  function."</p>
</blockquote>




<hr>
<h3><a name="169"></a>169. Bad efficiency of <tt>overflow()</tt> mandated</h3>
<p><b>Section:</b> 27.8.1.4 [stringbuf.virtuals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Dietmar Khl <b>Opened:</b> 1999-07-20 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#stringbuf.virtuals">issues</a> in [stringbuf.virtuals].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>Paragraph 8, Notes, of this section seems to mandate an extremely
inefficient way of buffer handling for <tt>basic_stringbuf</tt>,
especially in view of the restriction that <tt>basic_ostream</tt>
member functions are not allowed to use <tt>xsputn()</tt> (see 27.7.2.1 [ostream]): For each character to be inserted, a new buffer
is to be created.</p> 
<p>Of course, the resolution below requires some handling of
simultaneous input and output since it is no longer possible to update
<tt>egptr()</tt> whenever <tt>epptr()</tt> is changed. A possible
solution is to handle this in <tt>underflow()</tt>.</p>


<p><b>Proposed resolution:</b></p>
<p>In 27.8.1.4 [stringbuf.virtuals] paragraph 8, Notes, insert the words
"at least" as in the following:</p>
<blockquote>
  <p>To make a write position available, the function reallocates (or initially
  allocates) an array object with a sufficient number of elements to hold the
  current array object (if any), plus <b>at least</b> one additional write
  position.</p>
</blockquote>




<hr>
<h3><a name="170"></a>170. Inconsistent definition of <tt>traits_type</tt></h3>
<p><b>Section:</b> 27.8.4 [stringstream] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Dietmar Khl <b>Opened:</b> 1999-07-20 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>The classes <tt>basic_stringstream</tt> (27.8.4 [stringstream]),
<tt>basic_istringstream</tt> (27.8.2 [istringstream]), and
<tt>basic_ostringstream</tt> (27.8.3 [ostringstream]) are inconsistent
in their definition of the type <tt>traits_type</tt>: For
<tt>istringstream</tt>, this type is defined, for the other two it is
not. This should be consistent.</p>


<p><b>Proposed resolution:</b></p>
<p><b>Proposed resolution:</b></p> <p>To the declarations of
<tt>basic_ostringstream</tt> (27.8.3 [ostringstream]) and
<tt>basic_stringstream</tt> (27.8.4 [stringstream]) add:</p>
<blockquote>
<pre>typedef traits traits_type;</pre>
</blockquote>




<hr>
<h3><a name="171"></a>171. Strange <tt>seekpos()</tt> semantics due to joint position</h3>
<p><b>Section:</b> 27.9.1.5 [filebuf.virtuals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Dietmar Khl <b>Opened:</b> 1999-07-20 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#filebuf.virtuals">issues</a> in [filebuf.virtuals].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>Overridden virtual functions, seekpos()</p> <p>In 27.9.1.1 [filebuf] paragraph 3, it is stated that a joint input and
output position is maintained by <tt>basic_filebuf</tt>. Still, the
description of <tt>seekpos()</tt> seems to talk about different file
positions. In particular, it is unclear (at least to me) what is
supposed to happen to the output buffer (if there is one) if only the
input position is changed. The standard seems to mandate that the
output buffer is kept and processed as if there was no positioning of
the output position (by changing the input position). Of course, this
can be exactly what you want if the flag <tt>ios_base::ate</tt> is
set. However, I think, the standard should say something like
this:</p>
<ul>
  <li>If <tt>(which &amp; mode) == 0</tt> neither read nor write position is
    changed and the call fails. Otherwise, the joint read and write position is
    altered to correspond to <tt>sp</tt>.</li>
  <li>If there is an output buffer, the output sequences is updated and any
    unshift sequence is written before the position is altered.</li>
  <li>If there is an input buffer, the input sequence is updated after the
    position is altered.</li>
</ul>
<p>Plus the appropriate error handling, that is...</p>


<p><b>Proposed resolution:</b></p>
<p>Change the unnumbered paragraph in 27.8.1.4 (lib.filebuf.virtuals) before
paragraph 14 from:</p>
<blockquote>
  <p>pos_type seekpos(pos_type sp, ios_base::openmode = ios_base::in |
  ios_base::out);</p>
  <p>Alters the file position, if possible, to correspond to the position stored
  in sp (as described below).</p>
  <p>- if (which&amp;ios_base::in)!=0, set the file position to sp, then update
  the input sequence</p>
  <p>- if (which&amp;ios_base::out)!=0, then update the output sequence, write
  any unshift sequence, and set the file position to sp.</p>
</blockquote>
<p>to:</p>
<blockquote>
  <p>pos_type seekpos(pos_type sp, ios_base::openmode = ios_base::in |
  ios_base::out);</p>
  <p>Alters the file position, if possible, to correspond to the position stored
  in sp (as described below). Altering the file position performs as follows:</p>
  <p>1. if (om &amp; ios_base::out)!=0, then update the output sequence and
  write any unshift sequence;</p>
  <p>2. set the file position to sp;</p>
  <p>3. if (om &amp; ios_base::in)!=0, then update the input sequence;</p>
  <p>where om is the open mode passed to the last call to open(). The operation
  fails if is_open() returns false.</p>
</blockquote>

<p><i>[Kona: Dietmar is working on a proposed resolution.]</i></p>

<p><i>[Post-Tokyo: Dietmar supplied the above wording.]</i></p>






<hr>
<h3><a name="172"></a>172. Inconsistent types for <tt>basic_istream::ignore()</tt></h3>
<p><b>Section:</b> 27.7.1.3 [istream.unformatted] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Greg Comeau, Dietmar Khl <b>Opened:</b> 1999-07-23 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#istream.unformatted">issues</a> in [istream.unformatted].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>In 27.7.1.1 [istream] the function
<tt>ignore()</tt> gets an object of type <tt>streamsize</tt> as first
argument. However, in 27.7.1.3 [istream.unformatted]
paragraph 23 the first argument is of type <tt>int.</tt></p>

<p>As far as I can see this is not really a contradiction because
everything is consistent if <tt>streamsize</tt> is typedef to be
<tt>int</tt>. However, this is almost certainly not what was
intended. The same thing happened to <tt>basic_filebuf::setbuf()</tt>,
as described in issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#173">173</a>.</p>

<p>Darin Adler also
submitted this issue, commenting: Either 27.6.1.1 should be modified
to show a first parameter of type int, or 27.6.1.3 should be modified
to show a first parameter of type streamsize and use
numeric_limits&lt;streamsize&gt;::max.</p>


<p><b>Proposed resolution:</b></p>
<p>In 27.7.1.3 [istream.unformatted] paragraph 23 and 24, change both uses
of <tt>int</tt> in the description of <tt>ignore()</tt> to
<tt>streamsize</tt>.</p>




<hr>
<h3><a name="173"></a>173. Inconsistent types for <tt>basic_filebuf::setbuf()</tt></h3>
<p><b>Section:</b> 27.9.1.5 [filebuf.virtuals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Greg Comeau, Dietmar Khl <b>Opened:</b> 1999-07-23 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#filebuf.virtuals">issues</a> in [filebuf.virtuals].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>

<p>
In 27.9.1.1 [filebuf] the function <tt>setbuf()</tt> gets an
object of type <tt>streamsize</tt> as second argument. However, in
27.9.1.5 [filebuf.virtuals] paragraph 9 the second argument is of type
<tt>int</tt>.
</p>

<p>
As far as I can see this is not really a contradiction because
everything is consistent if <tt>streamsize</tt> is typedef to be
<tt>int</tt>. However, this is almost certainly not what was
intended. The same thing happened to <tt>basic_istream::ignore()</tt>,
as described in issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#172">172</a>.
</p>



<p><b>Proposed resolution:</b></p>
<p>In 27.9.1.5 [filebuf.virtuals] paragraph 9, change all uses of
<tt>int</tt> in the description of <tt>setbuf()</tt> to
<tt>streamsize</tt>.</p>




<hr>
<h3><a name="174"></a>174. Typo: <tt>OFF_T</tt> vs. <tt>POS_T</tt></h3>
<p><b>Section:</b> D.8 [depr.ios.members] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Dietmar Khl <b>Opened:</b> 1999-07-23 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#depr.ios.members">issues</a> in [depr.ios.members].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>According to paragraph 1 of this section, <tt>streampos</tt> is the
type <tt>OFF_T</tt>, the same type as <tt>streamoff</tt>. However, in
paragraph 6 the <tt>streampos</tt> gets the type <tt>POS_T</tt></p>


<p><b>Proposed resolution:</b></p>
<p>Change D.8 [depr.ios.members] paragraph 1 from "<tt>typedef
OFF_T streampos;</tt>" to "<tt>typedef POS_T
streampos;</tt>"</p>




<hr>
<h3><a name="175"></a>175. Ambiguity for <tt>basic_streambuf::pubseekpos()</tt> and a few other functions.</h3>
<p><b>Section:</b> D.8 [depr.ios.members] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Dietmar Khl <b>Opened:</b> 1999-07-23 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#depr.ios.members">issues</a> in [depr.ios.members].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>According to paragraph 8 of this section, the methods
<tt>basic_streambuf::pubseekpos()</tt>,
<tt>basic_ifstream::open()</tt>, and <tt>basic_ofstream::open</tt>
"may" be overloaded by a version of this function taking the
type <tt>ios_base::open_mode</tt> as last argument argument instead of
<tt>ios_base::openmode</tt> (<tt>ios_base::open_mode</tt> is defined
in this section to be an alias for one of the integral types). The
clause specifies, that the last argument has a default argument in
three cases.  However, this generates an ambiguity with the overloaded
version because now the arguments are absolutely identical if the last
argument is not specified.</p>


<p><b>Proposed resolution:</b></p>
<p>In D.8 [depr.ios.members] paragraph 8, remove the default arguments for
<tt>basic_streambuf::pubseekpos()</tt>,
<tt>basic_ifstream::open()</tt>, and
<tt>basic_ofstream::open().</tt></p>




<hr>
<h3><a name="176"></a>176. <tt>exceptions()</tt> in <tt>ios_base</tt>...?</h3>
<p><b>Section:</b> D.8 [depr.ios.members] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Dietmar Khl <b>Opened:</b> 1999-07-23 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#depr.ios.members">issues</a> in [depr.ios.members].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>The "overload" for the function <tt>exceptions()</tt> in
paragraph 8 gives the impression that there is another function of
this function defined in class <tt>ios_base</tt>. However, this is not
the case. Thus, it is hard to tell how the semantics (paragraph 9) can
be implemented: "Call the corresponding member function specified
in clause 27 [input.output]."</p>


<p><b>Proposed resolution:</b></p>
<p>In D.8 [depr.ios.members] paragraph 8, move the declaration of the
function <tt>exceptions()</tt>into class <tt>basic_ios</tt>.</p>




<hr>
<h3><a name="179"></a>179. Comparison of const_iterators to iterators doesn't work</h3>
<p><b>Section:</b> 23.2 [container.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Judy Ward <b>Opened:</b> 1998-07-02 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#container.requirements">issues</a> in [container.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>Currently the following will not compile on two well-known standard
library implementations:</p>

<blockquote>
  <pre>#include &lt;set&gt;
using namespace std;

void f(const set&lt;int&gt; &amp;s)
{
  set&lt;int&gt;::iterator i;
  if (i==s.end()); // s.end() returns a const_iterator
}</pre>
</blockquote>

<p>
The reason this doesn't compile is because operator== was implemented
as a member function of the nested classes set:iterator and
set::const_iterator, and there is no conversion from const_iterator to
iterator. Surprisingly, (s.end() == i) does work, though, because of
the conversion from iterator to const_iterator.
</p>

<p>
I don't see a requirement anywhere in the standard that this must
work. Should there be one?  If so, I think the requirement would need
to be added to the tables in section 24.1.1. I'm not sure about the
wording.  If this requirement existed in the standard, I would think
that implementors would have to make the comparison operators
non-member functions.</p>

<p>This issues was also raised on comp.std.c++ by Darin
Adler.&nbsp; The example given was:</p>

<blockquote>
  <pre>bool check_equal(std::deque&lt;int&gt;::iterator i,
std::deque&lt;int&gt;::const_iterator ci)
{
return i == ci;
}</pre>
</blockquote>

<p>Comment from John Potter:</p>
<blockquote>
    <p>
    In case nobody has noticed, accepting it will break reverse_iterator.
    </p>

    <p>
    The fix is to make the comparison operators templated on two types.
    </p>

    <pre>    template &lt;class Iterator1, class Iterator2&gt;
    bool operator== (reverse_iterator&lt;Iterator1&gt; const&amp; x,
                     reverse_iterator&lt;Iterator2&gt; const&amp; y);
    </pre>

    <p>
    Obviously:  return x.base() == y.base();
    </p>

    <p>
    Currently, no reverse_iterator to const_reverse_iterator compares are
    valid.
    </p>

    <p>
    BTW, I think the issue is in support of bad code.  Compares should be
    between two iterators of the same type.  All std::algorithms require
    the begin and end iterators to be of the same type. 
    </p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>Insert this paragraph after 23.2 [container.requirements] paragraph 7:</p>
<blockquote>
  <p>In the expressions</p>
  <pre>    i == j
    i != j
    i &lt; j
    i &lt;= j
    i &gt;= j
    i &gt; j
    i - j
  </pre>
  <p>Where i and j denote objects of a container's iterator type,
  either or both may be replaced by an object of the container's
  const_iterator type referring to the same element with no
  change in semantics.</p>
</blockquote>

<p><i>[post-Toronto: Judy supplied a proposed resolution saying that
<tt>iterator</tt> and <tt>const_iterator</tt> could be freely mixed in
iterator comparison and difference operations.]</i></p>


<p><i>[Redmond: Dave and Howard supplied a new proposed resolution which
explicitly listed expressions; there was concern that the previous
proposed resolution was too informal.]</i></p>



<p><b>Rationale:</b></p>
<p>
The LWG believes it is clear that the above wording applies only to
the nested types <tt>X::iterator</tt> and <tt>X::const_iterator</tt>,
where <tt>X</tt> is a container.  There is no requirement that
<tt>X::reverse_iterator</tt> and <tt>X::const_reverse_iterator</tt>
can be mixed.  If mixing them is considered important, that's a
separate issue.  (Issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#280">280</a>.)
</p>




<hr>
<h3><a name="180"></a>180. Container member iterator arguments constness has unintended consequences</h3>
<p><b>Section:</b> 21.4 [basic.string] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Dave Abrahams <b>Opened:</b> 1999-07-01 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#basic.string">issues</a> in [basic.string].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>It is the constness of the container which should control whether
it can be modified through a member function such as erase(), not the
constness of the iterators. The iterators only serve to give
positioning information.</p>

<p>Here's a simple and typical example problem which is currently very
difficult or impossible to solve without the change proposed
below.</p>

<p>Wrap a standard container C in a class W which allows clients to
find and read (but not modify) a subrange of (C.begin(), C.end()]. The
only modification clients are allowed to make to elements in this
subrange is to erase them from C through the use of a member function
of W.</p>

<p><i>[
post Bellevue, Alisdair adds:
]</i></p>


<blockquote>
<p>
This issue was implemented by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2350.pdf">N2350</a>
for everything but <tt>basic_string</tt>.
</p>

<p>
Note that the specific example in this issue (<tt>basic_string</tt>) is the one place
we forgot to amend in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2350.pdf">N2350</a>,
so we might open this issue for that
single container?
</p>
</blockquote>

<p><i>[
Sophia Antipolis:
]</i></p>


<blockquote>
<p>
This was a fix that was intended for all standard library containers,
and has been done for other containers, but string was missed.
</p>
<p>
The wording updated.
</p>
<p>
We did not make the change in <tt>replace</tt>, because this change would affect
the implementation because the string may be written into. This is an
issue that should be taken up by concepts.
</p>
<p>
We note that the supplied wording addresses the initializer list provided in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2679.pdf">N2679</a>.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Update the following signature in the <tt>basic_string</tt> class template definition in
21.4 [basic.string], p5:
</p>
<blockquote><pre>namespace std {
  template&lt;class charT, class traits = char_traits&lt;charT&gt;,
    class Allocator = allocator&lt;charT&gt; &gt;
  class basic_string {

    ...

    iterator insert(<ins>const_</ins>iterator p, charT c);
    void insert(<ins>const_</ins>iterator p, size_type n, charT c);
    template&lt;class InputIterator&gt;
      void insert(<ins>const_</ins>iterator p, InputIterator first, InputIterator last);
    void insert(<ins>const_</ins>iterator <ins>p</ins>, initializer_list&lt;charT&gt;);

    ...

    iterator erase(<ins>const_</ins>iterator <ins>const_</ins>position);
    iterator erase(<ins>const_</ins>iterator first, <ins>const_</ins>iterator last);

    ...

  };
}
</pre></blockquote>

<p>
Update the following signatures in 21.4.6.4 [string::insert]:
</p>

<blockquote><pre>iterator insert(<ins>const_</ins>iterator p, charT c);
void insert(<ins>const_</ins>iterator p, size_type n, charT c);
template&lt;class InputIterator&gt;
  void insert(<ins>const_</ins>iterator p, InputIterator first, InputIterator last);
void insert(<ins>const_</ins>iterator <ins>p</ins>, initializer_list&lt;charT&gt;);
</pre></blockquote>

<p>
Update the following signatures in 21.4.6.5 [string::erase]:
</p>

<blockquote><pre>iterator erase(<ins>const_</ins>iterator <ins>const_</ins>position);
iterator erase(<ins>const_</ins>iterator first, <ins>const_</ins>iterator last);
</pre></blockquote>



<p><b>Rationale:</b></p>
<p>The issue was discussed at length. It was generally agreed that 1)
There is no major technical argument against the change (although
there is a minor argument that some obscure programs may break), and
2) Such a change would not break const correctness. The concerns about
making the change were 1) it is user detectable (although only in
boundary cases), 2) it changes a large number of signatures, and 3) it
seems more of a design issue that an out-and-out defect.</p>

<p>The LWG believes that this issue should be considered as part of a
general review of const issues for the next revision of the
standard. Also see issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#200">200</a>.</p>




<hr>
<h3><a name="181"></a>181. make_pair() unintended behavior</h3>
<p><b>Section:</b> 20.3.5 [pairs] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Andrew Koenig <b>Opened:</b> 1999-08-03 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#pairs">issues</a> in [pairs].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>The claim has surfaced in Usenet that expressions such as<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <tt>make_pair("abc", 3)</tt><br>
<br>
are illegal, notwithstanding their use in examples, because template instantiation tries to bind the first template
parameter to <tt> const char (&amp;)[4]</tt>, which type is uncopyable.<br>
<br>
I doubt anyone intended that behavior...
</p>


<p><b>Proposed resolution:</b></p>
<p>In 20.3 [utility], paragraph 1 change the following
declaration of make_pair():</p>
<blockquote>
  <pre>template &lt;class T1, class T2&gt; pair&lt;T1,T2&gt; make_pair(const T1&amp;, const T2&amp;);</pre>
</blockquote>
<p>to:</p>
<blockquote>
  <pre>template &lt;class T1, class T2&gt; pair&lt;T1,T2&gt; make_pair(T1, T2);</pre>
</blockquote>
<p>  In 20.3.5 [pairs] paragraph 7 and the line before, change:</p>
<blockquote>
<pre>template &lt;class T1, class T2&gt;
pair&lt;T1, T2&gt; make_pair(const T1&amp; x, const T2&amp; y);</pre>
</blockquote>
<p>to:</p>
<blockquote>
<pre>template &lt;class T1, class T2&gt;
pair&lt;T1, T2&gt; make_pair(T1 x, T2 y);</pre>
</blockquote>
<p>and add the following footnote to the effects clause:</p>
<blockquote>
  <p> According to 12.8 [class.copy], an implementation is permitted
  to not perform a copy of an argument, thus avoiding unnecessary
  copies.</p>
</blockquote>


<p><b>Rationale:</b></p>
<p>Two potential fixes were suggested by Matt Austern and Dietmar
Khl, respectively, 1) overloading with array arguments, and 2) use of
a reference_traits class with a specialization for arrays.  Andy
Koenig suggested changing to pass by value. In discussion, it appeared
that this was a much smaller change to the standard that the other two
suggestions, and any efficiency concerns were more than offset by the
advantages of the solution. Two implementors reported that the
proposed resolution passed their test suites.</p>




<hr>
<h3><a name="182"></a>182. Ambiguous references to size_t</h3>
<p><b>Section:</b> 17 [library] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Al Stevens <b>Opened:</b> 1999-08-15 <b>Last modified:</b> 2010-10-29</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>Many references to <tt> size_t</tt> throughout the document
omit the <tt> std::</tt> namespace qualification.</p> <p>For
example, 17.6.3.6 [replacement.functions] paragraph 2:</p>
<blockquote>
<pre> operator new(size_t)
 operator new(size_t, const std::nothrow_t&amp;)
 operator new[](size_t)
 operator new[](size_t, const std::nothrow_t&amp;)</pre>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>   In 17.6.3.6 [replacement.functions] paragraph 2: replace:</p>
<blockquote>
<p><tt>     - operator new(size_t)<br>
     - operator new(size_t, const std::nothrow_t&amp;)<br>
     - operator new[](size_t)<br>
     - operator new[](size_t, const std::nothrow_t&amp;)</tt></p>
</blockquote>
<p>    by:</p>
<blockquote>
<pre>- operator new(std::size_t)
- operator new(std::size_t, const std::nothrow_t&amp;)
- operator new[](std::size_t)
- operator new[](std::size_t, const std::nothrow_t&amp;)</pre>
</blockquote>
<p>In [lib.allocator.requirements] 20.1.5, paragraph 4: replace:</p>
<blockquote>
  <p>The typedef members pointer, const_pointer, size_type, and difference_type
  are required to be T*, T const*, size_t, and ptrdiff_t, respectively.</p>
</blockquote>
<p>&nbsp;by:</p>
<blockquote>
  <p>The typedef members pointer, const_pointer, size_type, and difference_type
  are required to be T*, T const*, std::size_t, and std::ptrdiff_t,
  respectively.</p>
</blockquote>
<p>In [lib.allocator.members] 20.4.1.1, paragraphs 3 and 6: replace:</p>
<blockquote>
  <p>3 Notes: Uses ::operator new(size_t) (18.4.1).</p>
  <p>6 Note: the storage is obtained by calling ::operator new(size_t), but it
  is unspecified when or how often this function is called. The use of hint is
  unspecified, but intended as an aid to locality if an implementation so
  desires.</p>
</blockquote>
<p>by:</p>
<blockquote>
  <p>3 Notes: Uses ::operator new(std::size_t) (18.4.1).</p>
  <p>6 Note: the storage is obtained by calling ::operator new(std::size_t), but
  it is unspecified when or how often this function is called. The use of hint
  is unspecified, but intended as an aid to locality if an implementation so
  desires.</p>
</blockquote>
<p>In [lib.char.traits.require] 21.1.1, paragraph 1: replace:</p>
<blockquote>
  <p>In Table 37, X denotes a Traits class defining types and functions for the
  character container type CharT; c and d denote values of type CharT; p and q
  denote values of type const CharT*; s denotes a value of type CharT*; n, i and
  j denote values of type size_t; e and f denote values of type X::int_type; pos
  denotes a value of type X::pos_type; and state denotes a value of type X::state_type.</p>
</blockquote>
<p>by:</p>
<blockquote>
  <p>In Table 37, X denotes a Traits class defining types and functions for the
  character container type CharT; c and d denote values of type CharT; p and q
  denote values of type const CharT*; s denotes a value of type CharT*; n, i and
  j denote values of type std::size_t; e and f denote values of type X::int_type;
  pos denotes a value of type X::pos_type; and state denotes a value of type X::state_type.</p>
</blockquote>
<p>In [lib.char.traits.require] 21.1.1, table 37: replace the return type of
X::length(p): "size_t" by "std::size_t".</p>
<p>   In [lib.std.iterator.tags] 24.3.3, paragraph 2:    replace:<br>
&nbsp;&nbsp;&nbsp; typedef ptrdiff_t difference_type;<br>
    by:<br>
&nbsp;&nbsp;&nbsp; typedef std::ptrdiff_t difference_type;</p>
<p>   In [lib.locale.ctype] 22.2.1.1 put namespace std { ...} around the declaration of    template &lt;class charT&gt; class ctype.<br>
<br>
   In [lib.iterator.traits] 24.3.1, paragraph 2    put namespace std { ...} around the declaration of:<br>
<br>
&nbsp;&nbsp;&nbsp; template&lt;class Iterator&gt; struct iterator_traits<br>
&nbsp;&nbsp;&nbsp; template&lt;class T&gt; struct iterator_traits&lt;T*&gt;<br>
&nbsp;&nbsp;&nbsp; template&lt;class T&gt; struct iterator_traits&lt;const T*&gt;</p>


<p><b>Rationale:</b></p>
<p>The LWG believes correcting names like <tt>size_t</tt> and
<tt>ptrdiff_t</tt> to <tt>std::size_t</tt> and <tt>std::ptrdiff_t</tt>
to be essentially editorial.  There there can't be another size_t or
ptrdiff_t meant anyway because, according to 17.6.3.3.4 [extern.types],</p>

<blockquote><p>
For each type T from the Standard C library, the types ::T and std::T
are reserved to the implementation and, when defined, ::T shall be
identical to std::T.
</p></blockquote>

<p>The issue is treated as a Defect Report to make explicit the Project
Editor's authority to make this change.</p>

<p><i>[Post-Tokyo: Nico Josuttis provided the above wording at the
request of the LWG.]</i></p>


<p><i>[Toronto: This is tangentially related to issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#229">229</a>, but only tangentially: the intent of this issue is to
address use of the name <tt>size_t</tt> in contexts outside of
namespace std, such as in the description of <tt>::operator new</tt>.
The proposed changes should be reviewed to make sure they are
correct.]</i></p>


<p><i>[pre-Copenhagen: Nico has reviewed the changes and believes
them to be correct.]</i></p>







<hr>
<h3><a name="183"></a>183. I/O stream manipulators don't work for wide character streams</h3>
<p><b>Section:</b> 27.7.3 [std.manip] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Andy Sawyer <b>Opened:</b> 1999-07-07 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#std.manip">issues</a> in [std.manip].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>27.7.3 [std.manip] paragraph 3 says (clause numbering added for
exposition):</p>
<blockquote>
<p>Returns: An object s of unspecified type such that if [1] out is an (instance
of) basic_ostream then the expression out&lt;&lt;s behaves as if f(s) were
called, and if [2] in is an (instance of) basic_istream then the expression
in&gt;&gt;s behaves as if f(s) were called. Where f can be defined as: ios_base&amp;
f(ios_base&amp; str, ios_base::fmtflags mask) { // reset specified flags
str.setf(ios_base::fmtflags(0), mask); return str; } [3] The expression
out&lt;&lt;s has type ostream&amp; and value out. [4] The expression in&gt;&gt;s
has type istream&amp; and value in.</p>
</blockquote>
<p>Given the definitions [1] and [2] for out and in, surely [3] should read:
"The expression out &lt;&lt; s has type basic_ostream&amp; ..." and
[4] should read: "The expression in &gt;&gt; s has type basic_istream&amp;
..."</p>
<p>If the wording in the standard is correct, I can see no way of implementing
any of the manipulators so that they will work with wide character streams.</p>
<p>e.g. wcout &lt;&lt; setbase( 16 );</p>
<p>Must have value 'wcout' (which makes sense) and type 'ostream&amp;' (which
doesn't).</p>
<p>The same "cut'n'paste" type also seems to occur in Paras 4,5,7 and
8. In addition, Para 6 [setfill] has a similar error, but relates only to
ostreams.</p>
<p>I'd be happier if there was a better way of saying this, to make it clear
that the value of the expression is "the same specialization of
basic_ostream as out"&amp;</p>


<p><b>Proposed resolution:</b></p>
<p>Replace section 27.7.3 [std.manip] except paragraph 1 with the
following:</p>
<blockquote>
<p>2- The type designated smanip in each of the following function descriptions is implementation-specified and may be different for each
function.<br>
<br>
<tt>smanip resetiosflags(ios_base::fmtflags mask);</tt><br>
<br>
-3- Returns: An object s of unspecified type such that if out is an instance of basic_ostream&lt;charT,traits&gt; then the expression out&lt;&lt;s behaves
as if f(s, mask) were called, or if in is an instance of basic_istream&lt;charT,traits&gt; then the expression in&gt;&gt;s behaves as if
f(s, mask) were called. The function f can be defined as:*<br>
<br>
[Footnote: The expression cin &gt;&gt; resetiosflags(ios_base::skipws) clears ios_base::skipws in the format flags stored in the
basic_istream&lt;charT,traits&gt; object cin (the same as cin &gt;&gt; noskipws), and the expression cout &lt;&lt; resetiosflags(ios_base::showbase) clears
ios_base::showbase in the format flags stored in the basic_ostream&lt;charT,traits&gt; object cout (the same as cout &lt;&lt;
noshowbase). --- end footnote]<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp; <tt>ios_base&amp; f(ios_base&amp; str, ios_base::fmtflags mask)<br>
&nbsp;&nbsp; {<br>
&nbsp;&nbsp; //  reset specified flags<br>
&nbsp;&nbsp; str.setf(ios_base::fmtflags(0), mask);<br>
&nbsp;&nbsp; return str;<br>
&nbsp;&nbsp; }<br>
</tt><br>
The expression out&lt;&lt;s has type basic_ostream&lt;charT,traits&gt;&amp; and value out.
The expression in&gt;&gt;s has type basic_istream&lt;charT,traits&gt;&amp; and value in.<br>
<br>
&nbsp;<tt>smanip setiosflags(ios_base::fmtflags mask);</tt><br>
<br>
-4- Returns: An object s of unspecified type such that if out is an instance of basic_ostream&lt;charT,traits&gt; then the expression out&lt;&lt;s behaves
as if f(s, mask) were called, or if in is an instance of basic_istream&lt;charT,traits&gt; then the expression in&gt;&gt;s behaves as if f(s,
mask) were called. The function f can be defined as:<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp; <tt>ios_base&amp; f(ios_base&amp; str, ios_base::fmtflags mask)<br>
&nbsp;&nbsp; {<br>
&nbsp;&nbsp; //  set specified flags<br>
&nbsp;&nbsp; str.setf(mask);<br>
&nbsp;&nbsp; return str;<br>
&nbsp;&nbsp; }<br>
</tt><br>
The expression out&lt;&lt;s has type basic_ostream&lt;charT,traits&gt;&amp; and value out.
The expression in&gt;&gt;s has type basic_istream&lt;charT,traits&gt;&amp; and value in.<br>
<br>
<tt>smanip setbase(int base);</tt><br>
<br>
-5- Returns: An object s of unspecified type such that if out is an instance of basic_ostream&lt;charT,traits&gt; then the expression out&lt;&lt;s behaves
as if f(s, base) were called, or if in is an instance of basic_istream&lt;charT,traits&gt; then the expression in&gt;&gt;s behaves as if f(s,
base) were called. The function f can be defined as:<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp; <tt>ios_base&amp; f(ios_base&amp; str, int base)<br>
&nbsp;&nbsp; {<br>
&nbsp;&nbsp; //  set  basefield<br>
&nbsp;&nbsp; str.setf(base ==  8 ? ios_base::oct :<br>
&nbsp;&nbsp; base == 10 ? ios_base::dec :<br>
&nbsp;&nbsp; base == 16 ? ios_base::hex :<br>
&nbsp;&nbsp; ios_base::fmtflags(0), ios_base::basefield);<br>
&nbsp;&nbsp; return str;<br>
&nbsp;&nbsp; }<br>
</tt><br>
The expression out&lt;&lt;s has type basic_ostream&lt;charT,traits&gt;&amp; and value out.
The expression in&gt;&gt;s has type basic_istream&lt;charT,traits&gt;&amp; and value in.<br>
<br>
<tt>smanip setfill(char_type c);<br>
</tt><br>
-6- Returns: An object s of unspecified type such that if out is (or is derived from) basic_ostream&lt;charT,traits&gt; and c has type charT then the
expression out&lt;&lt;s behaves as if f(s, c) were called. The function f can be
defined as:<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <tt>template&lt;class charT, class traits&gt;<br>
&nbsp;&nbsp; basic_ios&lt;charT,traits&gt;&amp; f(basic_ios&lt;charT,traits&gt;&amp; str, charT c)<br>
&nbsp;&nbsp; {<br>
&nbsp;&nbsp; //  set fill character<br>
&nbsp;&nbsp; str.fill(c);<br>
&nbsp;&nbsp; return str;<br>
&nbsp;&nbsp; }<br>
</tt><br>
The expression out&lt;&lt;s has type basic_ostream&lt;charT,traits&gt;&amp; and value out.<br>
<br>
<tt>smanip setprecision(int n);</tt><br>
<br>
-7- Returns: An object s of unspecified type such that if out is an instance of basic_ostream&lt;charT,traits&gt; then the expression out&lt;&lt;s behaves
as if f(s, n) were called, or if in is an instance of basic_istream&lt;charT,traits&gt; then the expression in&gt;&gt;s behaves as if f(s, n)
were called. The function f can be defined as:<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <tt>ios_base&amp; f(ios_base&amp; str, int n)<br>
&nbsp;&nbsp; {<br>
&nbsp;&nbsp; //  set precision<br>
&nbsp;&nbsp; str.precision(n);<br>
&nbsp;&nbsp; return str;<br>
&nbsp;&nbsp; }<br>
</tt><br>
The expression out&lt;&lt;s has type basic_ostream&lt;charT,traits&gt;&amp; and value out.
The expression in&gt;&gt;s has type basic_istream&lt;charT,traits&gt;&amp; and value in<br>
.<br>
<tt>smanip setw(int n);<br>
</tt><br>
-8- Returns: An object s of unspecified type such that if out is an instance of basic_ostream&lt;charT,traits&gt; then the expression out&lt;&lt;s behaves
as if f(s, n) were called, or if in is an instance of basic_istream&lt;charT,traits&gt; then the expression in&gt;&gt;s behaves as if f(s, n)
were called. The function f can be defined as:<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <tt>ios_base&amp; f(ios_base&amp; str, int n)<br>
&nbsp;&nbsp; {<br>
&nbsp;&nbsp; //  set width<br>
&nbsp;&nbsp; str.width(n);<br>
&nbsp;&nbsp; return str;<br>
&nbsp;&nbsp; }<br>
</tt><br>
The expression out&lt;&lt;s has type
basic_ostream&lt;charT,traits&gt;&amp; and value out.  The expression
in&gt;&gt;s has type basic_istream&lt;charT,traits&gt;&amp; and value
in.
</p>
</blockquote>

<p><i>[Kona: Andy Sawyer and Beman Dawes will work to improve the wording of
the proposed resolution.]</i></p>


<p><i>[Tokyo - The LWG noted that issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#216">216</a> involves
the same paragraphs.]</i></p>


<p><i>[Post-Tokyo: The issues list maintainer combined the proposed
resolution of this issue with the proposed resolution for issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#216">216</a> as they both involved the same paragraphs, and were so
intertwined that dealing with them separately appear fraught with
error.  The full text was supplied by Bill Plauger; it was cross
checked against changes supplied by Andy Sawyer. It should be further
checked by the LWG.]</i></p>






<hr>
<h3><a name="184"></a>184. numeric_limits&lt;bool&gt; wording problems</h3>
<p><b>Section:</b> 18.3.1.5 [numeric.special] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Gabriel Dos Reis <b>Opened:</b> 1999-07-21 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#numeric.special">issues</a> in [numeric.special].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>bools are defined by the standard to be of integer types, as per
3.9.1 [basic.fundamental] paragraph 7.  However "integer types"
seems to have a special meaning for the author of 18.2. The net effect
is an unclear and confusing specification for
numeric_limits&lt;bool&gt; as evidenced below.</p>

<p>18.2.1.2/7 says numeric_limits&lt;&gt;::digits is, for built-in integer
types, the number of non-sign bits in the representation.</p>

<p>4.5/4 states that a bool promotes to int ; whereas 4.12/1 says any non zero
arithmetical value converts to true.</p>

<p>I don't think it makes sense at all to require
numeric_limits&lt;bool&gt;::digits and numeric_limits&lt;bool&gt;::digits10 to
be meaningful.</p>

<p>The standard defines what constitutes a signed (resp. unsigned) integer
types. It doesn't categorize bool as being signed or unsigned. And the set of
values of bool type has only two elements.</p>

<p>I don't think it makes sense to require numeric_limits&lt;bool&gt;::is_signed
to be meaningful.</p>

<p>18.2.1.2/18 for numeric_limits&lt;integer_type&gt;::radix&nbsp; says:</p>
<blockquote>
  <p>For integer types, specifies the base of the representation.186)</p>
</blockquote>

<p>This disposition is at best misleading and confusing for the standard
requires a "pure binary numeration system" for integer types as per
3.9.1/7</p>

<p>The footnote 186) says: "Distinguishes types with base other than 2 (e.g
BCD)."&nbsp; This also erroneous as the standard never defines any integer
types with base representation other than 2.</p>

<p>Furthermore, numeric_limits&lt;bool&gt;::is_modulo and
numeric_limits&lt;bool&gt;::is_signed have similar problems.</p>


<p><b>Proposed resolution:</b></p>
<p>Append to the end of 18.3.1.5 [numeric.special]:</p>
<blockquote>
  <p>The specialization for bool shall be provided as follows:</p>
  <pre>    namespace std {
       template&lt;&gt; class numeric_limits&lt;bool&gt; {
       public:
         static const bool is_specialized = true;
         static bool min() throw() { return false; }
         static bool max() throw() { return true; }

         static const int  digits = 1;
         static const int  digits10 = 0;
         static const bool is_signed = false;
         static const bool is_integer = true;
         static const bool is_exact = true;
         static const int  radix = 2;
         static bool epsilon() throw() { return 0; }
         static bool round_error() throw() { return 0; }

         static const int  min_exponent = 0;
         static const int  min_exponent10 = 0;
         static const int  max_exponent = 0;
         static const int  max_exponent10 = 0;

         static const bool has_infinity = false;
         static const bool has_quiet_NaN = false;
         static const bool has_signaling_NaN = false;
         static const float_denorm_style has_denorm = denorm_absent;
         static const bool has_denorm_loss = false;
         static bool infinity() throw() { return 0; }
         static bool quiet_NaN() throw() { return 0; }
         static bool signaling_NaN() throw() { return 0; }
         static bool denorm_min() throw() { return 0; }

         static const bool is_iec559 = false;
         static const bool is_bounded = true;
         static const bool is_modulo = false;

         static const bool traps = false;
         static const bool tinyness_before = false;
         static const float_round_style round_style = round_toward_zero;
       };
     }</pre>
</blockquote>

<p><i>[Tokyo:&nbsp; The LWG desires wording that specifies exact values
rather than more general wording in the original proposed
resolution.]</i></p>


<p><i>[Post-Tokyo:&nbsp; At the request of the LWG in Tokyo, Nico
Josuttis provided the above wording.]</i></p>






<hr>
<h3><a name="185"></a>185. Questionable use of term "inline"</h3>
<p><b>Section:</b> 20.8 [function.objects] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> UK Panel <b>Opened:</b> 1999-07-26 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#function.objects">issues</a> in [function.objects].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>Paragraph 4 of 20.8 [function.objects] says:</p>
<blockquote>
  <p>&nbsp;[Example: To negate every element of a: transform(a.begin(), a.end(),
  a.begin(), negate&lt;double&gt;()); The corresponding functions will inline
  the addition and the negation. end example]</p>
</blockquote>
<p>(Note: The "addition" referred to in the above is in para 3) we can
find no other wording, except this (non-normative) example which suggests that
any "inlining" will take place in this case.</p>
<p>Indeed both:</p>
<blockquote>
  <p>17.4.4.3 Global Functions [lib.global.functions] 1 It is
  unspecified whether any global functions in the C++ Standard Library
  are defined as inline (7.1.2).</p>
</blockquote>
<p>and</p>
<blockquote>
  <p>17.4.4.4 Member Functions [lib.member.functions] 1 It is
  unspecified whether any member functions in the C++ Standard Library
  are defined as inline (7.1.2).</p>
</blockquote>
<p>take care to state that this may indeed NOT be the case.</p>
<p>Thus the example "mandates" behavior that is explicitly
not required elsewhere.</p>


<p><b>Proposed resolution:</b></p>
<p>In 20.8 [function.objects] paragraph 1, remove the sentence:</p>
<blockquote>
<p>They are important for the effective use of the library.</p>
</blockquote>
<p>Remove 20.8 [function.objects] paragraph 2, which reads:</p>
<blockquote>
  <p> Using function objects together with function templates
  increases the expressive power of the library as well as making the
  resulting code much more efficient.</p>
</blockquote>
<p>In 20.8 [function.objects] paragraph 4, remove the sentence:</p>
<blockquote>
  <p>The corresponding functions will inline the addition and the
  negation.</p>
</blockquote>

<p><i>[Kona: The LWG agreed there was a defect.]</i></p>

<p><i>[Tokyo: The LWG crafted the proposed resolution.]</i></p>






<hr>
<h3><a name="186"></a>186. bitset::set() second parameter should be bool</h3>
<p><b>Section:</b> 20.5.2 [bitset.members] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Darin Adler <b>Opened:</b> 1999-08-13 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#bitset.members">issues</a> in [bitset.members].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>In section 20.5.2 [bitset.members], paragraph 13 defines the
bitset::set operation to take a second parameter of type int. The
function tests whether this value is non-zero to determine whether to
set the bit to true or false. The type of this second parameter should
be bool. For one thing, the intent is to specify a Boolean value. For
another, the result type from test() is bool. In addition, it's
possible to slice an integer that's larger than an int. This can't
happen with bool, since conversion to bool has the semantic of
translating 0 to false and any non-zero value to true.</p>


<p><b>Proposed resolution:</b></p>
<p>In 20.5 [template.bitset] Para 1 Replace:</p>
<blockquote>
<pre>bitset&lt;N&gt;&amp; set(size_t pos, int val = true ); </pre>
</blockquote>
<p>With:</p>
<blockquote>
  <pre>bitset&lt;N&gt;&amp; set(size_t pos, bool val = true );</pre>
</blockquote>
<p>In 20.5.2 [bitset.members] Para 12(.5) Replace:</p>
<blockquote>
  <pre>bitset&lt;N&gt;&amp; set(size_t pos, int val = 1 );</pre>
</blockquote>
<p>With:</p>
<blockquote>
  <pre>bitset&lt;N&gt;&amp; set(size_t pos, bool val = true );</pre>
</blockquote>

<p><i>[Kona: The LWG agrees with the description.&nbsp; Andy Sawyer will work
on better P/R wording.]</i></p>

<p><i>[Post-Tokyo: Andy provided the above wording.]</i></p>



<p><b>Rationale:</b></p>
<p><tt>bool</tt> is a better choice.  It is believed that binary
compatibility is not an issue, because this member function is
usually implemented as <tt>inline</tt>, and because it is already
the case that users cannot rely on the type of a pointer to a
nonvirtual member of a standard library class.</p>





<hr>
<h3><a name="187"></a>187. iter_swap underspecified</h3>
<p><b>Section:</b> 25.3.3 [alg.swap] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Andrew Koenig <b>Opened:</b> 1999-08-14 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.swap">issues</a> in [alg.swap].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>The description of iter_swap in 25.2.2 paragraph 7,says that it
``exchanges the values'' of the objects to which two iterators
refer.<br> <br> What it doesn't say is whether it does so using swap
or using the assignment operator and copy constructor.<br> <br> This
question is an important one to answer, because swap is specialized to
work efficiently for standard containers.<br> For example:</p>
<blockquote>
<pre>vector&lt;int&gt; v1, v2;
iter_swap(&amp;v1, &amp;v2);</pre>
</blockquote>
<p>Is this call to iter_swap equivalent to calling swap(v1, v2)?&nbsp;
Or is it equivalent to</p>
<blockquote>
<pre>{
vector&lt;int&gt; temp = v1;
v1 = v2;
v2 = temp;
}</pre>
</blockquote>
<p>The first alternative is O(1); the second is O(n).</p>
<p>A LWG member, Dave Abrahams, comments:</p>
<blockquote>
<p>Not an objection necessarily, but I want to point out the cost of
that requirement:</p>
  <blockquote>
<p><tt>iter_swap(list&lt;T&gt;::iterator, list&lt;T&gt;::iterator)</tt></p>
  </blockquote>
<p>can currently be specialized to be more efficient than
iter_swap(T*,T*) for many T (by using splicing). Your proposal would
make that optimization illegal.&nbsp;</p>
</blockquote>

<p><i>[Kona: The LWG notes the original need for iter_swap was proxy iterators
which are no longer permitted.]</i></p>



<p><b>Proposed resolution:</b></p>
<p>Change the effect clause of iter_swap in 25.2.2 paragraph 7 from:</p>
<blockquote>
<p>Exchanges the values pointed to by the two iterators a and b.</p>
</blockquote>
<p>to</p>
<blockquote>
<p><tt>swap(*a, *b)</tt>.</p>
</blockquote>



<p><b>Rationale:</b></p>
<p>It's useful to say just what <tt>iter_swap</tt> does.  There may be
  some iterators for which we want to specialize <tt>iter_swap</tt>,
  but the fully general version should have a general specification.</p>

<p>Note that in the specific case of <tt>list&lt;T&gt;::iterator</tt>,
iter_swap should not be specialized as suggested above.  That would do
much more than exchanging the two iterators' values: it would change
predecessor/successor relationships, possibly moving the iterator from
one list to another.  That would surely be inappropriate.</p>





<hr>
<h3><a name="189"></a>189. setprecision() not specified correctly</h3>
<p><b>Section:</b> 27.5.2.2 [fmtflags.state] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Andrew Koenig <b>Opened:</b> 1999-08-25 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#fmtflags.state">issues</a> in [fmtflags.state].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>27.4.2.2 paragraph 9 claims that setprecision() sets the precision,
and includes a parenthetical note saying that it is the number of
digits after the decimal point.<br>
<br>
This claim is not strictly correct.  For example, in the default
floating-point output format, setprecision sets the number of
significant digits printed, not the number of digits after the decimal
point.<br>
<br>
I would like the committee to look at the definition carefully and
correct the statement in 27.4.2.2</p>


<p><b>Proposed resolution:</b></p>
<p>Remove from 27.5.2.2 [fmtflags.state], paragraph 9, the text
"(number of digits after the decimal point)".</p>




<hr>
<h3><a name="193"></a>193. Heap operations description incorrect</h3>
<p><b>Section:</b> 25.4.6 [alg.heap.operations] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Markus Mauhart <b>Opened:</b> 1999-09-24 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#216">216</a></p>
<p><b>Discussion:</b></p>
<p>25.3.6 [lib.alg.heap.operations] states two key properties of a heap [a,b), the first of them
is<br>
<br>
&nbsp;&nbsp;&nbsp; `"(1) *a is the largest element"<br>
<br>
I think this is incorrect and should be changed to the wording in the proposed
resolution.</p>
<p>Actually there are two independent changes:</p>
<blockquote>
  <p>A-"part of largest equivalence class" instead of "largest", cause 25.3
  [lib.alg.sorting] asserts "strict weak ordering" for all its sub clauses.</p>
  <p>B-Take 'an oldest' from that equivalence class, otherwise the heap functions  could not be used for a
  priority queue as explained in 23.2.3.2.2 [lib.priqueue.members] (where I assume that a "priority queue" respects  priority AND time).</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>Change 25.4.6 [alg.heap.operations] property (1) from:</p>
<blockquote>
  <p>(1) *a is the largest element</p>
</blockquote>
<p>to:</p>
<blockquote>
  <p>(1) There is no element greater than <tt>*a</tt></p>
</blockquote>





<hr>
<h3><a name="195"></a>195. Should <tt>basic_istream::sentry</tt>'s constructor ever set eofbit?</h3>
<p><b>Section:</b> 27.7.1.1.3 [istream::sentry] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 1999-10-13 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#istream::sentry">issues</a> in [istream::sentry].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>Suppose that <tt>is.flags() &amp; ios_base::skipws</tt> is nonzero.
What should <tt>basic_istream&lt;&gt;::sentry</tt>'s constructor do if it
reaches eof while skipping whitespace?  27.6.1.1.2/5 suggests it
should set failbit. Should it set eofbit as well?  The standard
doesn't seem to answer that question.</p>

<p>On the one hand, nothing in 27.7.1.1.3 [istream::sentry] says that
<tt>basic_istream&lt;&gt;::sentry</tt> should ever set eofbit.  On the
other hand, 27.7.1.1 [istream] paragraph 4 says that if
extraction from a <tt>streambuf</tt> "returns
<tt>traits::eof()</tt>, then the input function, except as explicitly
noted otherwise, completes its actions and does
<tt>setstate(eofbit)"</tt>.  So the question comes down to
whether <tt>basic_istream&lt;&gt;::sentry</tt>'s constructor is an
input function.</p>

<p>Comments from Jerry Schwarz:</p>
<blockquote>
<p>It was always my intention that eofbit should be set any time that a
virtual returned something to indicate eof, no matter what reason
iostream code had for calling the virtual.</p>
<p>
The motivation for this is that I did not want to require streambufs
to behave consistently if their virtuals are called after they have
signaled eof.</p>
<p>
The classic case is a streambuf reading from a UNIX file.  EOF isn't
really a state for UNIX file descriptors.  The convention is that a
read on UNIX returns 0 bytes to indicate "EOF", but the file
descriptor isn't shut down in any way and future reads do not
necessarily also return 0 bytes.  In particular, you can read from
tty's on UNIX even after they have signaled "EOF".  (It
isn't always understood that a ^D on UNIX is not an EOF indicator, but
an EOL indicator.  By typing a "line" consisting solely of
^D you cause a read to return 0 bytes, and by convention this is
interpreted as end of file.)</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>Add a sentence to the end of 27.6.1.1.2 paragraph 2:</p>
<blockquote>
<p>If <tt>is.rdbuf()-&gt;sbumpc()</tt> or <tt>is.rdbuf()-&gt;sgetc()</tt>
returns <tt>traits::eof()</tt>, the function calls
<tt>setstate(failbit | eofbit)</tt> (which may throw
<tt>ios_base::failure</tt>).
</p>
</blockquote>




<hr>
<h3><a name="198"></a>198. Validity of pointers and references unspecified after iterator destruction</h3>
<p><b>Section:</b> X [iterator.concepts] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Beman Dawes <b>Opened:</b> 1999-11-03 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#iterator.concepts">issues</a> in [iterator.concepts].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Is a pointer or reference obtained from an iterator still valid after
destruction of the iterator?
</p>
<p>
Is a pointer or reference obtained from an iterator still valid after the value
of the iterator changes?
</p>
<blockquote>
<pre>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;iterator&gt;

int main()
{
    typedef std::vector&lt;int&gt; vec_t;
    vec_t v;
    v.push_back( 1 );

    // Is a pointer or reference obtained from an iterator still
    // valid after destruction of the iterator?
    int * p = &amp;*v.begin();
    std::cout &lt;&lt; *p &lt;&lt; '\n';  // OK?

    // Is a pointer or reference obtained from an iterator still
    // valid after the value of the iterator changes?
    vec_t::iterator iter( v.begin() );
    p = &amp;*iter++;
    std::cout &lt;&lt; *p &lt;&lt; '\n';  // OK?

    return 0;
}
</pre>
</blockquote>

<p>The standard doesn't appear to directly address these
questions. The standard needs to be clarified. At least two real-world
cases have been reported where library implementors wasted
considerable effort because of the lack of clarity in the
standard. The question is important because requiring pointers and
references to remain valid has the effect for practical purposes of
prohibiting iterators from pointing to cached rather than actual
elements of containers.</p>

<p>The standard itself assumes that pointers and references obtained
from an iterator are still valid after iterator destruction or
change. The definition of reverse_iterator::operator*(), 24.5.1.3.3 [reverse.iter.conv], which returns a reference, defines
effects:</p>

<blockquote>
  <pre>Iterator tmp = current;
return *--tmp;</pre>
</blockquote>
<p>The definition of reverse_iterator::operator-&gt;(), 24.5.1.3.4 [reverse.iter.op.star], which returns a pointer, defines effects:</p>
<blockquote>
  <pre>return &amp;(operator*());</pre>
</blockquote>

<p>Because the standard itself assumes pointers and references remain
valid after iterator destruction or change, the standard should say so
explicitly. This will also reduce the chance of user code breaking
unexpectedly when porting to a different standard library
implementation.</p>


<p><b>Proposed resolution:</b></p>
<p>Add a new paragraph to X [iterator.concepts]:</p>
<blockquote><p>
Destruction of an iterator may invalidate pointers and references
previously obtained from that iterator.
</p></blockquote>

<p>Replace paragraph 1 of 24.5.1.3.3 [reverse.iter.conv] with:</p>

<blockquote>
<p><b>Effects:</b></p>
<pre>  this-&gt;tmp = current;
  --this-&gt;tmp;
  return *this-&gt;tmp;
</pre>

<p>
[<i>Note:</i> This operation must use an auxiliary member variable,
rather than a temporary variable, to avoid returning a reference that
persists beyond the lifetime of its associated iterator.  (See
X [iterator.concepts].)  The name of this member variable is shown for
exposition only.  <i>--end note</i>]
</p>
</blockquote>

<p><i>[Post-Tokyo: The issue has been reformulated purely
in terms of iterators.]</i></p>


<p><i>[Pre-Toronto: Steve Cleary pointed out the no-invalidation
assumption by reverse_iterator. The issue and proposed resolution was
reformulated yet again to reflect this reality.]</i></p>


<p><i>[Copenhagen: Steve Cleary pointed out that reverse_iterator
assumes its underlying iterator has persistent pointers and
references.  Andy Koenig pointed out that it is possible to rewrite
reverse_iterator so that it no longer makes such an assupmption.
However, this issue is related to issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#299">299</a>.  If we
decide it is intentional that <tt>p[n]</tt> may return by value
instead of reference when <tt>p</tt> is a Random Access Iterator,
other changes in reverse_iterator will be necessary.]</i></p>



<p><b>Rationale:</b></p>
<p>This issue has been discussed extensively.  Note that it is
<i>not</i> an issue about the behavior of predefined iterators.  It is
asking whether or not user-defined iterators are permitted to have
transient pointers and references.  Several people presented examples
of useful user-defined iterators that have such a property; examples
include a B-tree iterator, and an "iota iterator" that doesn't point
to memory.  Library implementors already seem to be able to cope with
such iterators: they take pains to avoid forming references to memory
that gets iterated past.  The only place where this is a problem is
<tt>reverse_iterator</tt>, so this issue changes
<tt>reverse_iterator</tt> to make it work.</p>

<p>This resolution does not weaken any guarantees provided by
predefined iterators like <tt>list&lt;int&gt;::iterator</tt>.
Clause 23 should be reviewed to make sure that guarantees for
predefined iterators are as strong as users expect.</p>






<hr>
<h3><a name="199"></a>199. What does <tt>allocate(0)</tt> return?</h3>
<p><b>Section:</b> 20.2.5 [allocator.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 1999-11-19 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#allocator.requirements">issues</a> in [allocator.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Suppose that <tt>A</tt> is a class that conforms to the
Allocator requirements of Table 32, and <tt>a</tt> is an
object of class <tt>A</tt>  What should be the return
value of <tt>a.allocate(0)</tt>?  Three reasonable
possibilities: forbid the argument <tt>0</tt>, return
a null pointer, or require that the return value be a
unique non-null pointer.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add a note to the <tt>allocate</tt> row of Table 32:
"[<i>Note:</i> If <tt>n == 0</tt>, the return value is unspecified. <i>--end note</i>]"</p>


<p><b>Rationale:</b></p>
<p>A key to understanding this issue is that the ultimate use of
allocate() is to construct an iterator, and that iterator for zero
length sequences must be the container's past-the-end
representation.  Since this already implies special case code, it
would be over-specification to mandate the return value.
</p>




<hr>
<h3><a name="200"></a>200. Forward iterator requirements don't allow constant iterators</h3>
<p><b>Section:</b> 24.2.5 [forward.iterators] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 1999-11-19 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#forward.iterators">issues</a> in [forward.iterators].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In table 74, the return type of the expression <tt>*a</tt> is given
as <tt>T&amp;</tt>, where <tt>T</tt> is the iterator's value type.
For constant iterators, however, this is wrong.  ("Value type"
is never defined very precisely, but it is clear that the value type
of, say, <tt>std::list&lt;int&gt;::const_iterator</tt> is supposed to be
<tt>int</tt>, not <tt>const int</tt>.)
</p>


<p><b>Proposed resolution:</b></p>
<p>
In table 74, in the <tt>*a</tt> and <tt>*r++</tt> rows, change the
return type from "<tt>T&amp;</tt>" to "<tt>T&amp;</tt>
if <tt>X</tt> is mutable, otherwise <tt>const T&amp;</tt>".
In the <tt>a-&gt;m</tt> row, change the return type from
"<tt>U&amp;</tt>" to "<tt>U&amp;</tt> if <tt>X</tt> is mutable,
otherwise <tt>const U&amp;</tt>".
</p>

<p><i>[Tokyo: The LWG believes this is the tip of a larger iceberg;
there are multiple const problems with the STL portion of the library
and that these should be addressed as a single package.&nbsp; Note
that issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#180">180</a> has already been declared NAD Future for
that very reason.]</i></p>


<p><i>[Redmond: the LWG thinks this is separable from other constness
issues.  This issue is just cleanup; it clarifies language that was
written before we had iterator_traits.  Proposed resolution was
modified: the original version only discussed *a.  It was pointed out
that we also need to worry about *r++ and a-&gt;m.]</i></p>







<hr>
<h3><a name="201"></a>201. Numeric limits terminology wrong</h3>
<p><b>Section:</b> 18.3.1 [limits] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Stephen Cleary <b>Opened:</b> 1999-12-21 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#limits">issues</a> in [limits].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In some places in this section, the terms "fundamental types" and
"scalar types" are used when the term "arithmetic types" is intended.
The current usage is incorrect because void is a fundamental type and
pointers are scalar types, neither of which should have
specializations of numeric_limits.
</p>
<p><i>[Lillehammer: it remains true that numeric_limits is using
  imprecise language. However, none of the proposals for changed
  wording are clearer.  A redesign of numeric_limits is needed, but this
  is more a task than an open issue.]</i></p>



<p><b>Proposed resolution:</b></p>

<p>
Change 18.3 [support.limits] to:
</p>

<blockquote>
<p>
-1- The headers <tt>&lt;limits&gt;</tt>, <tt>&lt;climits&gt;</tt>,
<tt>&lt;cfloat&gt;</tt>, and <tt>&lt;cinttypes&gt;</tt> supply
characteristics of implementation-dependent <del>fundamental</del>
<ins>arithmetic</ins> types (3.9.1).
</p>
</blockquote>

<p>
Change 18.3.1 [limits] to:
</p>

<blockquote>
<p>
-1- The <tt>numeric_limits</tt> component provides a C++ program with
information about various properties of the implementation's
representation of the <del>fundamental</del> <ins>arithmetic</ins>
types.
</p>
<p>
-2- Specializations shall be provided for each <del>fundamental</del>
<ins>arithmetic</ins> type, both floating point and integer, including
<tt>bool</tt>. The member <tt>is_specialized</tt> shall be <tt>true</tt>
for all such specializations of <tt>numeric_limits</tt>.
</p>
<p>
-4- Non-<del>fundamental</del><ins>arithmetic</ins> standard types, such
as <tt>complex&lt;T&gt;</tt> (26.3.2), shall not have specializations.
</p>
</blockquote>

<p>
Change 18.3.1.1 [numeric.limits] to:
</p>

<blockquote>
<p>
<del>-1- The member <tt>is_specialized</tt> makes it possible to distinguish
between fundamental types, which have specializations, and non-scalar types,
which do not.</del>
</p>
</blockquote>






<hr>
<h3><a name="202"></a>202. unique() effects unclear when predicate not an equivalence relation</h3>
<p><b>Section:</b> 25.3.9 [alg.unique] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Andrew Koenig <b>Opened:</b> 2000-01-13 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.unique">issues</a> in [alg.unique].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
What should unique() do if you give it a predicate that is not an
equivalence relation?  There are at least two plausible answers:
</p>

<blockquote>

<p>
   1. You can't, because 25.2.8 says that it it "eliminates all but
   the first element from every consecutive group of equal
   elements..." and it wouldn't make sense to interpret "equal" as
   meaning anything but an equivalence relation.  [It also doesn't
   make sense to interpret "equal" as meaning ==, because then there
   would never be any sense in giving a predicate as an argument at
   all.]
</p>

<p>
   2. The word "equal" should be interpreted to mean whatever the
   predicate says, even if it is not an equivalence relation
   (and in particular, even if it is not transitive).
</p>

</blockquote>

<p>
The example that raised this question is from Usenet:
</p>

<blockquote>

<pre>int f[] = { 1, 3, 7, 1, 2 };
int* z = unique(f, f+5, greater&lt;int&gt;());</pre>

</blockquote>

<p>
If one blindly applies the definition using the predicate
greater&lt;int&gt;, and ignore the word "equal", you get:
</p>

<blockquote>

<p>
    Eliminates all but the first element from every consecutive group    
    of elements referred to by the iterator i in the range [first, last)    
    for which *i &gt; *(i - 1).
</p>

</blockquote>

<p>
The first surprise is the order of the comparison.  If we wanted to
allow for the predicate not being an equivalence relation, then we
should surely compare elements the other way: pred(*(i - 1), *i).  If
we do that, then the description would seem to say: "Break the
sequence into subsequences whose elements are in strictly increasing
order, and keep only the first element of each subsequence".  So the
result would be 1, 1, 2.  If we take the description at its word, it
would seem to call for strictly DEcreasing order, in which case the
result should be 1, 3, 7, 2.<br>
<br>
In fact, the SGI implementation of unique() does neither: It yields 1,
3, 7.
</p>


<p><b>Proposed resolution:</b></p>
<p>Change 25.3.9 [alg.unique] paragraph 1 to:</p>
<blockquote><p>
For a nonempty range, eliminates all but the first element from every
consecutive group of equivalent elements referred to by the iterator
<tt>i</tt> in the range [first+1, last) for which the following
conditions hold: <tt>*(i-1) == *i</tt> or <tt>pred(*(i-1), *i) !=
false</tt>.
</p></blockquote>

<p>
Also insert a new paragraph, paragraph 2a, that reads: "Requires: The
comparison function must be an equivalence relation."
</p>

<p><i>[Redmond: discussed arguments for and against requiring the
comparison function to be an equivalence relation.  Straw poll:
14-2-5.  First number is to require that it be an equivalence
relation, second number is to explicitly not require that it be an
equivalence relation, third number is people who believe they need
more time to consider the issue.  A separate issue: Andy Sawyer
pointed out that "i-1" is incorrect, since "i" can refer to the first
iterator in the range.  Matt provided wording to address this
problem.]</i></p>


<p><i>[Curaao: The LWG changed "... the range (first,
last)..." to "...  the range [first+1, last)..." for
clarity. They considered this change close enough to editorial to not
require another round of review.]</i></p>




<p><b>Rationale:</b></p>
<p>The LWG also considered an alternative resolution: change 
25.3.9 [alg.unique] paragraph 1 to:</p>

<blockquote><p>
For a nonempty range, eliminates all but the first element from every
consecutive group of elements referred to by the iterator
<tt>i</tt> in the range (first, last) for which the following
conditions hold: <tt>*(i-1) == *i</tt> or <tt>pred(*(i-1), *i) !=
false</tt>.
</p></blockquote>

<p>
Also insert a new paragraph, paragraph 1a, that reads: "Notes: The
comparison function need not be an equivalence relation."
</p>


<p>Informally: the proposed resolution imposes an explicit requirement
that the comparison function be an equivalence relation.  The
alternative resolution does not, and it gives enough information so
that the behavior of unique() for a non-equivalence relation is
specified.  Both resolutions are consistent with the behavior of
existing implementations.</p>





<hr>
<h3><a name="206"></a>206. operator new(size_t, nothrow) may become unlinked to ordinary operator new if ordinary version replaced</h3>
<p><b>Section:</b> 18.6.1.1 [new.delete.single] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 1999-08-29 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#new.delete.single">issues</a> in [new.delete.single].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>As specified, the implementation of the nothrow version of operator
new does not necessarily call the ordinary operator new, but may
instead simply call the same underlying allocator and return a null
pointer instead of throwing an exception in case of failure.</p>

<p>Such an implementation breaks code that replaces the ordinary
version of new, but not the nothrow version. If the ordinary version
of new/delete is replaced, and if the replaced delete is not
compatible with pointers returned from the library versions of new,
then when the replaced delete receives a pointer allocated by the
library new(nothrow), crash follows.</p>

<p>The fix appears to be that the lib version of new(nothrow) must
call the ordinary new. Thus when the ordinary new gets replaced, the
lib version will call the replaced ordinary new and things will
continue to work.</p>

<p>An alternative would be to have the ordinary new call
new(nothrow). This seems sub-optimal to me as the ordinary version of
new is the version most commonly replaced in practice. So one would
still need to replace both ordinary and nothrow versions if one wanted
to replace the ordinary version.</p>

<p>Another alternative is to put in clear text that if one version is
replaced, then the other must also be replaced to maintain
compatibility. Then the proposed resolution below would just be a
quality of implementation issue. There is already such text in
paragraph 7 (under the new(nothrow) version). But this nuance is
easily missed if one reads only the paragraphs relating to the
ordinary new.</p>

<p>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2158.html">N2158</a>
has been written explaining the rationale for the proposed resolution below.
</p>



<p><b>Proposed resolution:</b></p>
<p>
Change 18.5.1.1 [new.delete.single]:
</p>

<blockquote>
<pre>void* operator new(std::size_t <i>size</i>, const std::nothrow_t&amp;) throw();
</pre>
<blockquote>
<p>
-5- <i>Effects:</i> Same as above, except that it is called by a placement
version of a <i>new-expression</i> when a C++ program prefers a null pointer result as
an error indication, instead of a <tt>bad_alloc</tt> exception.
</p>

<p>
-6- <i>Replaceable:</i> a C++ program may define a function with this function
signature that displaces the default version defined by the C++ Standard
library.
</p>

<p>
-7- <i>Required behavior:</i> Return a non-null pointer to suitably aligned
storage (3.7.4), or else return a null pointer. This nothrow version of operator
new returns a pointer obtained as if acquired from the <ins>(possibly
replaced)</ins> ordinary version. This requirement is binding on a replacement
version of this function.
</p>

<p>
-8- <i>Default behavior:</i>
</p>
<ul>
<li><ins>
Calls <tt>operator new(<i>size</i>)</tt>.
</ins></li>
<li><ins>
If the call to <tt>operator new(<i>size</i>)</tt> returns normally, returns
the result of that call, else
</ins></li>
<li><ins>
if the call to <tt>operator new(<i>size</i>)</tt> throws an exception, returns
a null pointer.
</ins></li>
<li><del>
Executes a loop: Within the loop, the function first attempts to allocate the
requested storage. Whether the attempt involves a call to the Standard C library
function <tt>malloc</tt> is unspecified.
</del></li>
<li><del>
Returns a pointer to the allocated storage if the attempt is successful.
Otherwise, if the last argument to <tt>set_new_handler()</tt> was a null
pointer, return a null pointer.
</del></li>
<li><del>
Otherwise, the function calls the current <i>new_handler</i> (18.5.2.2). If the
called function returns, the loop repeats.
</del></li>
<li><del>
The loop terminates when an attempt to allocate the requested storage is
successful or when a called <i>new_handler</i> function does not return. If the
called <i>new_handler</i> function terminates by throwing a <tt>bad_alloc
exception</tt>, the function returns a null pointer.
</del></li>
</ul>
<p>
-9- [<i>Example:</i>
</p>
<blockquote><pre>T* p1 = new T;                 <i>// throws bad_alloc if it fails</i>
T* p2 = new(nothrow) T;        <i>// returns 0 if it fails</i>
</pre></blockquote>
<p>
--<i>end example</i>]
</p>
</blockquote>

<pre>void operator delete(void* <i>ptr</i>) throw();
<del>void operator delete(void* <i>ptr</i>, const std::nothrow_t&amp;) throw();</del>
</pre>

<blockquote>
<p>
-10- <i>Effects:</i> The <i>deallocation function</i> (3.7.4.2) called by a
<i>delete-expression</i> to render the value of <tt><i>ptr</i></tt> invalid.
</p>
<p>
-11- <i>Replaceable:</i> a C++ program may define a function with this function
signature that displaces the default version defined by the C++ Standard
library.
</p>
<p>
-12- <i>Requires:</i> the value of <tt><i>ptr</i></tt> is null or the value
returned by an earlier call to the <del>default</del> <ins>(possibly
replaced)</ins> <tt>operator new(std::size_t)</tt> or <tt>operator
new(std::size_t, const std::nothrow_t&amp;)</tt>.
</p>
<p>
-13- <i>Default behavior:</i>
</p>
<ul>
<li>
For a null value of <tt><i>ptr</i></tt>, do nothing.
</li>
<li>
Any other value of <tt><i>ptr</i></tt> shall be a value returned earlier by a
call to the default <tt>operator new</tt>, which was not invalidated by an
intervening call to <tt>operator delete(void*)</tt> (17.4.3.7). For such a
non-null value of <tt><i>ptr</i></tt>, reclaims storage allocated by the earlier
call to the default <tt>operator new</tt>.
</li>
</ul>
<p>
-14- <i>Remarks:</i>  It is unspecified under what conditions part or all of
such reclaimed storage is allocated by a subsequent call to <tt>operator
new</tt> or any of <tt>calloc</tt>, <tt>malloc</tt>, or <tt>realloc</tt>,
declared in <tt>&lt;cstdlib&gt;</tt>.
</p>
</blockquote>

<pre><ins>void operator delete(void* <i>ptr</i>, const std::nothrow_t&amp;) throw();</ins>
</pre>

<blockquote>
<p><ins>
-15- <i>Effects:</i> Same as above, except that it is called by the
implementation when an exception propagates from a nothrow placement version
of the <i>new-expression</i> (i.e. when the constructor throws an exception).
</ins></p>
<p><ins>
-16- <i>Replaceable:</i> a C++ program may define a function with this function
signature that displaces the default version defined by the C++ Standard
library.
</ins></p>
<p><ins>
-17- <i>Requires:</i> the value of <tt><i>ptr</i></tt> is null or the
value returned by an earlier call to the (possibly replaced) <tt>operator
new(std::size_t)</tt> or <tt>operator new(std::size_t, const
std::nothrow_t&amp;)</tt>. </ins></p>
<p><ins>
-18- <i>Default behavior:</i> Calls <tt>operator delete(<i>ptr</i>)</tt>.
</ins></p>
</blockquote>

</blockquote>

<p>
Change 18.5.1.2 [new.delete.array]
</p>

<blockquote>
<pre>void* operator new[](std::size_t <i>size</i>, const std::nothrow_t&amp;) throw();
</pre>

<blockquote>
<p>
-5- <i>Effects:</i> Same as above, except that it is called by a placement
version of a <i>new-expression</i> when a C++ program prefers a null pointer result as
an error indication, instead of a <tt>bad_alloc</tt> exception.
</p>

<p>
-6- <i>Replaceable:</i>  a C++ program can define a function with this function
signature that displaces the default version defined by the C++ Standard
library.
</p>

<p>
-7- <i>Required behavior:</i> <del>Same as for operator <tt>new(std::size_t,
const std::nothrow_t&amp;)</tt>. This nothrow version of operator <tt>new[]</tt>
returns a pointer obtained as if acquired from the ordinary version.</del>
<ins>Return a non-null pointer to suitably aligned storage (3.7.4), or else
return a null pointer. This nothrow version of operator new returns a pointer
obtained as if acquired from the (possibly replaced) <tt>operator
new[](std::size_t <i>size</i>)</tt>. This requirement is binding on a
replacement version of this function.</ins>
</p>

<p>
-8- <i>Default behavior:</i> <del>Returns <tt>operator new(<i>size</i>,
nothrow)</tt>.</del>
</p>

<ul>
<li><ins>
Calls <tt>operator new[](<i>size</i>)</tt>.
</ins></li>
<li><ins>
If the call to <tt>operator new[](<i>size</i>)</tt> returns normally, returns
the result of that call, else
</ins></li>
<li><ins>
if the call to <tt>operator new[](<i>size</i>)</tt> throws an exception, returns
a null pointer.
</ins></li>
</ul>
</blockquote>

<pre>void operator delete[](void* <i>ptr</i>) throw(); 
void operator delete[](void* <i>ptr</i>, const std::nothrow_t&amp;) throw();
</pre>

<blockquote>
<p>
-9- <i>Effects:</i> The <i>deallocation function</i> (3.7.4.2) called by the
array form of a <i>delete-expression</i> to render the value of
<tt><i>ptr</i></tt> invalid.
</p>

<p>
-10- <i>Replaceable:</i> a C++ program can define a function with this function
signature that displaces the default version defined by the C++ Standard
library.
</p>

<p>
-11- <i>Requires:</i> the value of
<tt><i>ptr</i></tt> is null or the value returned by an earlier call to
<tt>operator new[](std::size_t)</tt> or <tt>operator new[](std::size_t, const
std::nothrow_t&amp;)</tt>.
</p>

<p>
-12- <i>Default behavior:</i> Calls <tt>operator delete(<i>ptr</i>)</tt> or
<tt>operator delete<ins>[]</ins>(<i>ptr</i><del>, std::nothrow</del>)</tt> respectively.
</p>
</blockquote>

</blockquote>



<p><b>Rationale:</b></p>
<p>Yes, they may become unlinked, and that is by design. If a user
replaces one, the user should also replace the other.</p>

<p><i>[
Reopened due to a gcc conversation between Howard, Martin and Gaby.  Forwarding
or not is visible behavior to the client and it would be useful for the client
to know which behavior it could depend on.
]</i></p>


<p><i>[
Batavia: Robert voiced serious reservations about backwards compatibility for
his customers.
]</i></p>






<hr>
<h3><a name="208"></a>208. Unnecessary restriction on past-the-end iterators</h3>
<p><b>Section:</b> X [iterator.concepts] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Stephen Cleary <b>Opened:</b> 2000-02-02 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#iterator.concepts">issues</a> in [iterator.concepts].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>In 24.1 paragraph 5, it is stated ". . . Dereferenceable and
past-the-end values are always non-singular."</p>
<p>This places an unnecessary restriction on past-the-end iterators for
containers with forward iterators (for example, a singly-linked list). If the
past-the-end value on such a container was a well-known singular value, it would
still satisfy all forward iterator requirements.</p>
<p>Removing this restriction would allow, for example, a singly-linked list
without a "footer" node.</p>
<p>This would have an impact on existing code that expects past-the-end
iterators obtained from different (generic) containers being not equal.</p>


<p><b>Proposed resolution:</b></p>
<p>Change X [iterator.concepts] paragraph 5, the last sentence, from:</p>
<blockquote>
<p>Dereferenceable and past-the-end values are always non-singular.</p>
</blockquote>
<p>to:</p>
<blockquote>
<p>Dereferenceable values are always non-singular.&nbsp;</p>
</blockquote>


<p><b>Rationale:</b></p>
<p>For some kinds of containers, including singly linked lists and
zero-length vectors, null pointers are perfectly reasonable past-the-end
iterators.  Null pointers are singular.
</p>




<hr>
<h3><a name="209"></a>209. basic_string declarations inconsistent</h3>
<p><b>Section:</b> 21.4 [basic.string] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Igor Stauder <b>Opened:</b> 2000-02-11 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#basic.string">issues</a> in [basic.string].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>In Section 21.4 [basic.string] the basic_string member function
declarations use a consistent style except for the following functions:</p>
<blockquote>
  <pre>void push_back(const charT);
basic_string&amp; assign(const basic_string&amp;);
void swap(basic_string&lt;charT,traits,Allocator&gt;&amp;);</pre>
</blockquote>
<p>- push_back, assign, swap: missing argument name&nbsp;<br>
- push_back: use of const with charT (i.e. POD type passed by value
not by reference - should be charT or const charT&amp; )<br>
- swap: redundant use of template parameters in argument
basic_string&lt;charT,traits,Allocator&gt;&amp;</p>


<p><b>Proposed resolution:</b></p>
<p>In Section 21.4 [basic.string] change the basic_string member
function declarations push_back, assign, and swap to:</p>
<blockquote>
  <pre>void push_back(charT c); 

basic_string&amp; assign(const basic_string&amp; str);
void swap(basic_string&amp; str);</pre>
</blockquote>


<p><b>Rationale:</b></p>
<p>Although the standard is in general not consistent in declaration
style, the basic_string declarations are consistent other than the
above.  The LWG felt that this was sufficient reason to merit the
change.
</p>




<hr>
<h3><a name="210"></a>210. distance first and last confused</h3>
<p><b>Section:</b> 25 [algorithms] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Lisa Lippincott <b>Opened:</b> 2000-02-15 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#algorithms">issues</a> in [algorithms].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>In paragraph 9 of section 25 [algorithms], it is written:</p>
<blockquote>
  <p>      In the description of the algorithms operators + and - are used
           for some of the iterator categories for which they do not have to
           be defined. In these cases the semantics of [...] a-b is the same
           as of<br>
  <br>
  &nbsp;&nbsp;&nbsp;&nbsp; <tt>return distance(a, b);</tt></p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>On the last line of paragraph 9 of section 25 [algorithms] change
<tt>"a-b"</tt> to <tt>"b-a".</tt></p>


<p><b>Rationale:</b></p>
<p>There are two ways to fix the defect; change the description to b-a
or change the return to distance(b,a).  The LWG preferred the
former for consistency.</p>




<hr>
<h3><a name="211"></a>211. operator&gt;&gt;(istream&amp;, string&amp;) doesn't set failbit</h3>
<p><b>Section:</b> 21.4.8.9 [string.io] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Scott Snyder <b>Opened:</b> 2000-02-04 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#string.io">issues</a> in [string.io].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>The description of the stream extraction operator for std::string (section
21.3.7.9 [lib.string.io]) does not contain a requirement that failbit be set in
the case that the operator fails to extract any characters from the input
stream.</p>
<p>This implies that the typical construction</p>
<blockquote>
  <pre>std::istream is;
std::string str;
...
while (is &gt;&gt; str) ... ;</pre>
</blockquote>
<p>(which tests failbit) is not required to terminate at EOF.</p>
<p>Furthermore, this is inconsistent with other extraction operators,
which do include this requirement. (See sections 27.7.1.2 [istream.formatted] and 27.7.1.3 [istream.unformatted]), where this
requirement is present, either explicitly or implicitly, for the
extraction operators. It is also present explicitly in the description
of getline (istream&amp;, string&amp;, charT) in section 21.4.8.9 [string.io] paragraph 8.)</p>


<p><b>Proposed resolution:</b></p>
<p>Insert new paragraph after paragraph 2 in section 21.4.8.9 [string.io]:</p>
<blockquote>

<p>If the function extracts no characters, it calls
is.setstate(ios::failbit) which may throw ios_base::failure
(27.4.4.3).</p>
</blockquote>




<hr>
<h3><a name="212"></a>212. Empty range behavior unclear for several algorithms</h3>
<p><b>Section:</b> 25.4.7 [alg.min.max] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Nico Josuttis <b>Opened:</b> 2000-02-26 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.min.max">issues</a> in [alg.min.max].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>The standard doesn't specify what min_element() and max_element() shall
return if the range is empty (first equals last). The usual implementations
return last. This problem seems also apply to partition(), stable_partition(),
next_permutation(), and prev_permutation().</p>


<p><b>Proposed resolution:</b></p>
<p>In 25.4.7 [alg.min.max] - Minimum and maximum, paragraphs 7 and
9, append: Returns last if first==last.</p>


<p><b>Rationale:</b></p>
<p>The LWG looked in some detail at all of the above mentioned
algorithms, but believes that except for min_element() and
max_element() it is already clear that last is returned if first ==
last.</p>




<hr>
<h3><a name="214"></a>214. set::find() missing const overload</h3>
<p><b>Section:</b> 23.6.3 [set], 23.6.4 [multiset] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Judy Ward <b>Opened:</b> 2000-02-28 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#set">issues</a> in [set].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#450">450</a></p>
<p><b>Discussion:</b></p>
<p>The specification for the associative container requirements in
Table 69 state that the find member function should "return
iterator; const_iterator for constant a". The map and multimap
container descriptions have two overloaded versions of find, but set
and multiset do not, all they have is:</p>
<blockquote>
  <pre>iterator find(const key_type &amp; x) const;</pre>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>Change the prototypes for find(), lower_bound(), upper_bound(), and
equal_range() in section 23.6.3 [set] and section 23.6.4 [multiset] to each have two overloads:</p>
<blockquote>
  <pre>iterator find(const key_type &amp; x);
const_iterator find(const key_type &amp; x) const;</pre>
  <pre>iterator lower_bound(const key_type &amp; x);
const_iterator lower_bound(const key_type &amp; x) const;</pre>
  <pre>iterator upper_bound(const key_type &amp; x);
const_iterator upper_bound(const key_type &amp; x) const;</pre>
  <pre>pair&lt;iterator, iterator&gt; equal_range(const key_type &amp; x);
pair&lt;const_iterator, const_iterator&gt; equal_range(const key_type &amp; x) const;</pre>
</blockquote>

<p><i>[Tokyo: At the request of the LWG, Judy Ward provided wording
extending the proposed resolution to lower_bound, upper_bound, and
equal_range.]</i></p>






<hr>
<h3><a name="217"></a>217. Facets example (Classifying Japanese characters) contains errors</h3>
<p><b>Section:</b> 22.4.8 [facets.examples] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2000-02-29 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#facets.examples">issues</a> in [facets.examples].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>The example in 22.2.8, paragraph 11 contains the following errors:</p>
<p>1) The member function `My::JCtype::is_kanji()' is non-const; the function
must be const in order for it to be callable on a const object (a reference to
which which is what std::use_facet&lt;&gt;() returns).</p>
<p>2) In file filt.C, the definition of `JCtype::id' must be qualified with the
name of the namespace `My'.</p>
<p>3) In the definition of `loc' and subsequently in the call to use_facet&lt;&gt;()
in main(), the name of the facet is misspelled: it should read `My::JCtype'
rather than `My::JCType'.</p>


<p><b>Proposed resolution:</b></p>
<p>Replace the "Classifying Japanese characters" example in 22.2.8,
paragraph 11 with the following:</p>
<pre>#include &lt;locale&gt;</pre>
<pre>namespace My {
    using namespace std;
    class JCtype : public locale::facet {
    public:
        static locale::id id;     //  required for use as a new locale facet
        bool is_kanji (wchar_t c) const;
        JCtype() {}
    protected:
        ~JCtype() {}
    };
}</pre>
<pre>//  file:  filt.C
#include &lt;iostream&gt;
#include &lt;locale&gt;
#include "jctype"                 //  above
std::locale::id My::JCtype::id;   //  the static  JCtype  member
declared above.</pre>
<pre>int main()
{
    using namespace std;
    typedef ctype&lt;wchar_t&gt; wctype;
    locale loc(locale(""),              //  the user's preferred locale...
               new My::JCtype);         //  and a new feature ...
    wchar_t c = use_facet&lt;wctype&gt;(loc).widen('!');
    if (!use_facet&lt;My::JCtype&gt;(loc).is_kanji(c))
        cout &lt;&lt; "no it isn't!" &lt;&lt; endl;
    return 0;
}</pre>




<hr>
<h3><a name="220"></a>220. ~ios_base() usage valid?</h3>
<p><b>Section:</b> 27.5.2.7 [ios.base.cons] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Jonathan Schilling, Howard Hinnant <b>Opened:</b> 2000-03-13 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>The pre-conditions for the ios_base destructor are described in 27.4.2.7
paragraph 2:</p>
<blockquote>
  <p>Effects: Destroys an object of class ios_base. Calls each registered
  callback pair (fn,index) (27.4.2.6) as (*fn)(erase_event,*this,index) at such
  time that any ios_base member function called from within fn has well defined
  results.</p>
</blockquote>
<p>But what is not clear is: If no callback functions were ever registered, does
it matter whether the ios_base members were ever initialized?</p>
<p>For instance, does this program have defined behavior:</p>
<blockquote>
  <pre>#include &lt;ios&gt;</pre>
  <pre>class D : public std::ios_base { };</pre>
  <pre>int main() { D d; }</pre>
</blockquote>
<p>It seems that registration of a callback function would surely affect the
state of an ios_base. That is, when you register a callback function with an
ios_base, the ios_base must record that fact somehow.</p>
<p>But if after construction the ios_base is in an indeterminate state, and that
state is not made determinate before the destructor is called, then how would
the destructor know if any callbacks had indeed been registered? And if the
number of callbacks that had been registered is indeterminate, then is not the
behavior of the destructor undefined?</p>
<p>By comparison, the basic_ios class description in 27.4.4.1 paragraph 2 makes
it explicit that destruction before initialization results in undefined
behavior.</p>


<p><b>Proposed resolution:</b></p>
<p>Modify 27.4.2.7 paragraph 1 from</p>
<blockquote>
  <p>Effects: Each ios_base member has an indeterminate value after
  construction.</p>
</blockquote>
<p>to</p>
<blockquote>
  <p>Effects: Each ios_base member has an indeterminate value after
  construction. These members must be initialized by calling basic_ios::init. If an ios_base object is destroyed before these initializations
  have taken place, the behavior is undefined.</p>
</blockquote>




<hr>
<h3><a name="221"></a>221. num_get&lt;&gt;::do_get stage 2 processing broken</h3>
<p><b>Section:</b> 22.4.2.1.2 [facet.num.get.virtuals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2000-03-14 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#facet.num.get.virtuals">issues</a> in [facet.num.get.virtuals].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>Stage 2 processing of numeric conversion is broken.</p>

<p>Table 55 in 22.2.2.1.2 says that when basefield is 0 the integral
conversion specifier is %i. A %i specifier determines a number's base
by its prefix (0 for octal, 0x for hex), so the intention is clearly
that a 0x prefix is allowed.  Paragraph 8 in the same section,
however, describes very precisely how characters are processed. (It
must be done "as if" by a specified code fragment.) That
description does not allow a 0x prefix to be recognized.</p>

<p>Very roughly, stage 2 processing reads a char_type ct. It converts
ct to a char, not by using narrow but by looking it up in a
translation table that was created by widening the string literal
"0123456789abcdefABCDEF+-". The character "x" is
not found in that table, so it can't be recognized by stage 2
processing.</p>


<p><b>Proposed resolution:</b></p>
<p>In 22.2.2.1.2 paragraph 8, replace the line:</p>
<blockquote>
  <pre>static const char src[] = "0123456789abcdefABCDEF+-";</pre>
</blockquote>
<p>with the line:</p>
<blockquote>
  <pre>static const char src[] = "0123456789abcdefxABCDEFX+-";</pre>
</blockquote>


<p><b>Rationale:</b></p>
<p>If we're using the technique of widening a string literal, the
string literal must contain every character we wish to recognize.
This technique has the consequence that alternate representations
of digits will not be recognized.  This design decision was made
deliberately, with full knowledge of that limitation.</p>





<hr>
<h3><a name="222"></a>222. Are throw clauses necessary if a throw is already implied by the effects clause?</h3>
<p><b>Section:</b> 17.5.1.4 [structure.specifications] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Judy Ward <b>Opened:</b> 2000-03-17 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#structure.specifications">issues</a> in [structure.specifications].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>Section 21.3.6.8 describes the basic_string::compare function this way:</p>
<blockquote>
  <pre>21.3.6.8 - basic_string::compare [lib.string::compare]

int compare(size_type pos1, size_type n1,
                const basic_string&lt;charT,traits,Allocator&gt;&amp;  str ,
                size_type  pos2 , size_type  n2 ) const;

-4- Returns: 

    basic_string&lt;charT,traits,Allocator&gt;(*this,pos1,n1).compare(
                 basic_string&lt;charT,traits,Allocator&gt;(str,pos2,n2)) .</pre>
</blockquote>
<p>and the constructor that's implicitly called by the above is
defined to throw an out-of-range exception if pos &gt; str.size(). See
section 21.4.1 [string.require] paragraph 4.</p>

<p>On the other hand, the compare function descriptions themselves don't have
"Throws: " clauses and according to 17.3.1.3, paragraph 3, elements
that do not apply to a function are omitted.</p>
<p>So it seems there is an inconsistency in the standard -- are the
"Effects" clauses correct, or are the "Throws" clauses
missing?</p>


<p><b>Proposed resolution:</b></p>
<p>In 17.5.1.4 [structure.specifications] paragraph 3, the footnote 148 attached to
the sentence "Descriptions of function semantics contain the
following elements (as appropriate):", insert the word
"further" so that the foot note reads:</p>
<blockquote>
  <p>To save space, items that do not apply to a function are
  omitted. For example, if a function does not specify any further
  preconditions, there will be no "Requires" paragraph.</p>
</blockquote>


<p><b>Rationale:</b></p>
<p>The standard is somewhat inconsistent, but a failure to note a
throw condition in a throws clause does not grant permission not to
throw.  The inconsistent wording is in a footnote, and thus
non-normative. The proposed resolution from the LWG clarifies the
footnote.</p>




<hr>
<h3><a name="223"></a>223. reverse algorithm should use iter_swap rather than swap</h3>
<p><b>Section:</b> 25.3.10 [alg.reverse] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Dave Abrahams <b>Opened:</b> 2000-03-21 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>Shouldn't the effects say "applies iter_swap to all pairs..."?</p>


<p><b>Proposed resolution:</b></p>
<p>In 25.3.10 [alg.reverse], replace:</p>
  <blockquote><p>
  Effects: For each non-negative integer i &lt;= (last - first)/2, 
  applies swap to all pairs of iterators first + i, (last - i) - 1.
  </p></blockquote>
<p>with:</p>
  <blockquote><p>
  Effects: For each non-negative integer i &lt;= (last - first)/2, 
  applies iter_swap to all pairs of iterators first + i, (last - i) - 1.
  </p></blockquote>




<hr>
<h3><a name="224"></a>224. clear() complexity for associative containers refers to undefined N</h3>
<p><b>Section:</b> 23.2.4 [associative.reqmts] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Ed Brey <b>Opened:</b> 2000-03-23 <b>Last modified:</b> 2010-10-29</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#associative.reqmts">active issues</a> in [associative.reqmts].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#associative.reqmts">issues</a> in [associative.reqmts].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>In the associative container requirements table in 23.1.2 paragraph 7,
a.clear() has complexity "log(size()) + N". However, the meaning of N
is not defined.</p>


<p><b>Proposed resolution:</b></p>
<p>In the associative container requirements table in 23.1.2 paragraph
7, the complexity of a.clear(), change "log(size()) + N" to
"linear in <tt>size()</tt>".</p>


<p><b>Rationale:</b></p>
<p>It's the "log(size())", not the "N", that is in
error: there's no difference between <i>O(N)</i> and <i>O(N +
log(N))</i>.  The text in the standard is probably an incorrect
cut-and-paste from the range version of <tt>erase</tt>.</p>




<hr>
<h3><a name="225"></a>225. std:: algorithms use of other unqualified algorithms</h3>
<p><b>Section:</b> 17.6.4.4 [global.functions] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Dave Abrahams <b>Opened:</b> 2000-04-01 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#global.functions">issues</a> in [global.functions].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>Are algorithms in std:: allowed to use other algorithms without qualification, so functions in
user namespaces might be found through Koenig lookup?</p>
<p>For example, a popular standard library implementation includes this
implementation of std::unique:</p>
<blockquote>
<pre>namespace std {
    template &lt;class _ForwardIter&gt;
    _ForwardIter unique(_ForwardIter __first, _ForwardIter __last) {
      __first = adjacent_find(__first, __last);
      return unique_copy(__first, __last, __first);
    }
    }</pre>
</blockquote>
<p>Imagine two users on opposite sides of town, each using unique on his own
sequences bounded by my_iterators . User1 looks at his standard library
implementation and says, "I know how to implement a more efficient
unique_copy for my_iterators", and writes:</p>
<blockquote>
<pre>namespace user1 {
    class my_iterator;
    // faster version for my_iterator
    my_iterator unique_copy(my_iterator, my_iterator, my_iterator);
    }</pre>
</blockquote>
<p>user1::unique_copy() is selected by Koenig lookup, as he intended.</p>
<p>User2 has other needs, and writes:</p>
<blockquote>
<pre>namespace user2 {
    class my_iterator;
    // Returns true iff *c is a unique copy of *a and *b.
    bool unique_copy(my_iterator a, my_iterator b, my_iterator c);
    }</pre>
</blockquote>
<p>User2 is shocked to find later that his fully-qualified use of
std::unique(user2::my_iterator, user2::my_iterator, user2::my_iterator) fails to
compile (if he's lucky). Looking in the standard, he sees the following Effects
clause for unique():</p>
<blockquote>
  <p>Effects: Eliminates all but the first element from every consecutive group
  of equal elements referred to by the iterator i in the range [first, last) for
  which the following corresponding conditions hold: *i == *(i - 1) or pred(*i,
  *(i - 1)) != false</p>
</blockquote>
<p>The standard gives user2 absolutely no reason to think he can interfere with
std::unique by defining names in namespace user2. His standard library has been
built with the template export feature, so he is unable to inspect the
implementation. User1 eventually compiles his code with another compiler, and
his version of unique_copy silently stops being called. Eventually, he realizes
that he was depending on an implementation detail of his library and had no
right to expect his unique_copy() to be called portably.</p>
<p>On the face of it, and given above scenario, it may seem obvious that the
implementation of unique() shown is non-conforming because it uses unique_copy()
rather than ::std::unique_copy(). Most standard library implementations,
however, seem to disagree with this notion.</p>
<p> <i>[Tokyo:&nbsp; Steve Adamczyk from
the core working group indicates that "std::" is sufficient;&nbsp;
leading "::" qualification is not required because any namespace
qualification is sufficient to suppress Koenig lookup.]</i></p>


<p><b>Proposed resolution:</b></p>
<p>Add a paragraph and a note at the end of 
17.6.4.4 [global.functions]:</p>
<blockquote>

<p>Unless otherwise specified, no global or non-member function in the
standard library shall use a function from another namespace which is
found through <i>argument-dependent name lookup</i> (3.4.2 [basic.lookup.argdep]).</p>

<p>[Note: the phrase "unless otherwise specified" is intended to
allow Koenig lookup in cases like that of ostream_iterators:<br>

<br>
  Effects:</p>
  <blockquote>
<p>*out_stream &lt;&lt; value;<br>
      if(delim != 0) *out_stream &lt;&lt; delim;<br>
      return (*this);</p>
    <p>--end note]</p>
  </blockquote>
</blockquote>

<p><i>[Tokyo: The LWG agrees that this is a defect in the standard, but
is as yet unsure if the proposed resolution is the best
solution. Furthermore, the LWG believes that the same problem of
unqualified library names applies to wording in the standard itself,
and has opened issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#229">229</a> accordingly. Any resolution of
issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#225">225</a> should be coordinated with the resolution of
issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#229">229</a>.]</i></p>


<p><i>[Toronto: The LWG is not sure if this is a defect in the
standard.  Most LWG members believe that an implementation of
<tt>std::unique</tt> like the one quoted in this issue is already
illegal, since, under certain circumstances, its semantics are not
those specified in the standard.  The standard's description of
<tt>unique</tt> does not say that overloading <tt>adjacent_find</tt>
should have any effect.]</i></p>


<p><i>[Curaao: An LWG-subgroup spent an afternoon working on issues
225, 226, and 229.  Their conclusion was that the issues should be
separated into an LWG portion (Howard's paper, N1387=02-0045), and a
EWG portion (Dave will write a proposal). The LWG and EWG had
(separate) discussions of this plan the next day.  The proposed
resolution for this issue is in accordance with Howard's paper.]</i></p>




<p><b>Rationale:</b></p>
<p>It could be argued that this proposed isn't strictly necessary,
  that the Standard doesn't grant implementors license to write a
  standard function that behaves differently than specified in the
  Standard just because of an unrelated user-defined name in some
  other namespace.  However, this is at worst a clarification.  It is
  surely right that algorithsm shouldn't pick up random names, that
  user-defined names should have no effect unless otherwise specified.
  Issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#226">226</a> deals with the question of when it is
  appropriate for the standard to explicitly specify otherwise.</p>





<hr>
<h3><a name="226"></a>226. User supplied specializations or overloads of namespace std function templates</h3>
<p><b>Section:</b> 17.6.3.3 [reserved.names] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Dave Abrahams <b>Opened:</b> 2000-04-01 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#reserved.names">issues</a> in [reserved.names].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>The issues are:&nbsp;</p>
<p>1. How can a 3rd party library implementor (lib1) write a version of a standard
algorithm which is specialized to work with his own class template?&nbsp;</p>
<p>2. How can another library implementor (lib2) write a generic algorithm which 
will take advantage of the specialized algorithm in lib1?</p>
<p>This appears to be the only viable answer under current language rules:</p>
<blockquote>
  <pre>namespace lib1
{
    // arbitrary-precision numbers using T as a basic unit
    template &lt;class T&gt;
    class big_num { //...
    };
    </pre>
  <pre>    // defining this in namespace std is illegal (it would be an
    // overload), so we hope users will rely on Koenig lookup
    template &lt;class T&gt;
    void swap(big_int&lt;T&gt;&amp;, big_int&lt;T&gt;&amp;);
}</pre>
  <pre>#include &lt;algorithm&gt;
namespace lib2
{
    template &lt;class T&gt;
    void generic_sort(T* start, T* end)
    {
            ...
        // using-declaration required so we can work on built-in types
        using std::swap;
        // use Koenig lookup to find specialized algorithm if available
        swap(*x, *y);
    }
}</pre>
</blockquote>
<p>This answer has some drawbacks. First of all, it makes writing lib2 difficult
and somewhat slippery. The implementor needs to remember to write the
using-declaration, or generic_sort will fail to compile when T is a built-in
type. The second drawback is that the use of this style in lib2 effectively
"reserves" names in any namespace which defines types which may
eventually be used with lib2. This may seem innocuous at first when applied to
names like swap, but consider more ambiguous names like unique_copy() instead.
It is easy to imagine the user wanting to define these names differently in his
own namespace. A definition with semantics incompatible with the standard
library could cause serious problems (see issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#225">225</a>).</p>
<p>Why, you may ask, can't we just partially specialize std::swap()? It's
because the language doesn't allow for partial specialization of function
templates. If you write:</p>
<blockquote>
  <pre>namespace std
{
    template &lt;class T&gt;
    void swap(lib1::big_int&lt;T&gt;&amp;, lib1::big_int&lt;T&gt;&amp;);
}</pre>
</blockquote>
<p>You have just overloaded std::swap, which is illegal under the current
language rules. On the other hand, the following full specialization is legal:</p>
<blockquote>
  <pre>namespace std
{
    template &lt;&gt;
    void swap(lib1::other_type&amp;, lib1::other_type&amp;);
}</pre>
</blockquote>

<p>This issue reflects concerns raised by the "Namespace issue
with specialized swap" thread on comp.lang.c++.moderated. A
similar set of concerns was earlier raised on the boost.org mailing
list and the ACCU-general mailing list.  Also see library reflector
message c++std-lib-7354.</p>

<p>
J. C. van Winkel points out (in c++std-lib-9565) another unexpected
fact: it's impossible to output a container of std::pair's using copy
and an ostream_iterator, as long as both pair-members are built-in or
std:: types.  That's because a user-defined operator&lt;&lt; for (for
example) std::pair&lt;const std::string, int&gt; will not be found:
lookup for operator&lt;&lt; will be performed only in namespace std.
Opinions differed on whether or not this was a defect, and, if so,
whether the defect is that something is wrong with user-defined
functionality and std, or whether it's that the standard library does
not provide an operator&lt;&lt; for std::pair&lt;&gt;.
</p>



<p><b>Proposed resolution:</b></p>

<p>Adopt the wording proposed in Howard Hinnant's paper
  N1523=03-0106, "Proposed Resolution To LWG issues 225, 226, 229".</p>


<p><i>[Tokyo: Summary, "There is no conforming way to extend
std::swap for user defined templates."&nbsp; The LWG agrees that
there is a problem.  Would like more information before
proceeding. This may be a core issue.  Core issue 229 has been opened
to discuss the core aspects of this problem. It was also noted that
submissions regarding this issue have been received from several
sources, but too late to be integrated into the issues list.
]</i></p>


<p><i>[Post-Tokyo: A paper with several proposed resolutions,
J16/00-0029==WG21/N1252, "Shades of namespace std functions
" by Alan Griffiths, is in the Post-Tokyo mailing. It
should be considered a part of this issue.]</i></p>


<p><i>[Toronto: Dave Abrahams and Peter Dimov have proposed a
resolution that involves core changes: it would add partial
specialization of function template.  The Core Working Group is
reluctant to add partial specialization of function templates.  It is
viewed as a large change, CWG believes that proposal presented leaves
some syntactic issues unanswered; if the CWG does add partial
specialization of function templates, it wishes to develop its own
proposal.  The LWG continues to believe that there is a serious
problem: there is no good way for users to force the library to use
user specializations of generic standard library functions, and in
certain cases (e.g. transcendental functions called by
<tt>valarray</tt> and <tt>complex</tt>) this is important.  Koenig
lookup isn't adequate, since names within the library must be
qualified with <tt>std</tt> (see issue 225), specialization doesn't
work (we don't have partial specialization of function templates), and
users aren't permitted to add overloads within namespace std.
]</i></p>


<p><i>[Copenhagen: Discussed at length, with no consensus.  Relevant
papers in the pre-Copenhagen mailing: N1289, N1295, N1296.  Discussion
focused on four options. (1) Relax restrictions on overloads within
namespace std. (2) Mandate that the standard library use unqualified
calls for <tt>swap</tt> and possibly other functions.  (3) Introduce
helper class templates for <tt>swap</tt> and possibly other functions.
(4) Introduce partial specialization of function templates.  Every
option had both support and opposition.  Straw poll (first number is
support, second is strongly opposed): (1) 6, 4; (2) 6, 7; (3) 3, 8;
(4) 4, 4.]</i></p>


<p><i>[Redmond: Discussed, again no consensus.  Herb presented an
argument that a user who is defining a type <tt>T</tt> with an
associated <tt>swap</tt> should not be expected to put that
<tt>swap</tt> in namespace std, either by overloading or by partial
specialization.  The argument is that <tt>swap</tt> is part of
<tt>T</tt>'s interface, and thus should to in the same namespace as
<tt>T</tt> and only in that namespace.  If we accept this argument,
the consequence is that standard library functions should use
unqualified call of <tt>swap</tt>.  (And which other functions? Any?)
A small group (Nathan, Howard, Jeremy, Dave, Matt, Walter, Marc) will
try to put together a proposal before the next meeting.]</i></p>


<p><i>[Curaao: An LWG-subgroup spent an afternoon working on issues
225, 226, and 229.  Their conclusion was that the issues should be
separated into an LWG portion (Howard's paper, N1387=02-0045), and a
EWG portion (Dave will write a proposal). The LWG and EWG had
(separate) discussions of this plan the next day.  The proposed
resolution is the one proposed by Howard.]</i></p>


<p><i>[Santa Cruz: the LWG agreed with the general direction of
  Howard's paper, N1387.  (Roughly: Koenig lookup is disabled unless
  we say otherwise; this issue is about when we do say otherwise.)
  However, there were concerns about wording.  Howard will provide new
  wording.  Bill and Jeremy will review it.]</i></p>


<p><i>[Kona: Howard proposed the new wording.  The LWG accepted his
  proposed resolution.]</i></p>




<p><b>Rationale:</b></p>
<p>Informally: introduce a Swappable concept, and specify that the
  value types of the iterators passed to certain standard algorithms
  (such as iter_swap, swap_ranges, reverse, rotate, and sort) conform
  to that concept.  The Swappable concept will make it clear that
  these algorithms use unqualified lookup for the calls
  to <tt>swap</tt>.  Also, in 26.6.3.3 [valarray.transcend] paragraph 1,
  state that the valarray transcendentals use unqualified lookup.</p>





<hr>
<h3><a name="227"></a>227. std::swap() should require CopyConstructible or DefaultConstructible arguments</h3>
<p><b>Section:</b> 25.3.3 [alg.swap] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC1">TC1</a>
 <b>Submitter:</b> Dave Abrahams <b>Opened:</b> 2000-04-09 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.swap">issues</a> in [alg.swap].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TC1">TC1</a> status.</p>
<p><b>Discussion:</b></p>
<p>25.2.2 reads:</p>
<blockquote>
  <p><tt>  template&lt;class T&gt; void swap(T&amp; a, T&amp; b);</tt><br>
  <br>
  Requires:    Type T is Assignable (_lib.container.requirements_).<br>
  Effects:    Exchanges values stored in two locations.</p>
</blockquote>
<p>The only reasonable** generic implementation of swap requires construction of a 
   new temporary copy of one of its arguments:</p>
<blockquote>
<pre>template&lt;class T&gt; void swap(T&amp; a, T&amp; b);
  {
      T tmp(a);
      a = b;
      b = tmp;
  }</pre>
</blockquote>
<p>But a type which is only Assignable cannot be swapped by this implementation.</p>
<p>**Yes, there's also an unreasonable implementation which would require T to be 
   DefaultConstructible instead of CopyConstructible. I don't think this is worthy 
   of consideration:</p>
<blockquote>
<pre>template&lt;class T&gt; void swap(T&amp; a, T&amp; b);
{
    T tmp;
    tmp = a;
    a = b;
    b = tmp;
}</pre>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>Change 25.2.2 paragraph 1 from:</p>
<blockquote>
<p>  Requires: Type T is Assignable (23.1).</p>
</blockquote>
<p>to:</p>
<blockquote>
<p>  Requires: Type T is CopyConstructible (20.1.3) and Assignable (23.1)</p>
</blockquote>





<hr>
<h3><a name="228"></a>228. Incorrect specification of "..._byname" facets</h3>
<p><b>Section:</b> 22.4 [locale.categories] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Dietmar Khl <b>Opened:</b> 2000-04-20 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.categories">issues</a> in [locale.categories].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>The sections 22.4.1.2 [locale.ctype.byname], 22.4.1.5 [locale.codecvt.byname],
sref ref="22.2.1.6", 22.4.3.2 [locale.numpunct.byname], 22.4.4.2 [locale.collate.byname], 22.4.5.4 [locale.time.put.byname], 22.4.6.4 [locale.moneypunct.byname], and 22.4.7.2 [locale.messages.byname] overspecify the
definitions of the "..._byname" classes by listing a bunch
of virtual functions. At the same time, no semantics of these
functions are defined. Real implementations do not define these
functions because the functional part of the facets is actually
implemented in the corresponding base classes and the constructor of
the "..._byname" version just provides suitable date used by
these implementations. For example, the 'numpunct' methods just return
values from a struct. The base class uses a statically initialized
struct while the derived version reads the contents of this struct
from a table.  However, no virtual function is defined in
'numpunct_byname'.</p>

<p>For most classes this does not impose a problem but specifically
for 'ctype' it does: The specialization for 'ctype_byname&lt;char&gt;'
is required because otherwise the semantics would change due to the
virtual functions defined in the general version for 'ctype_byname':
In 'ctype&lt;char&gt;' the method 'do_is()' is not virtual but it is
made virtual in both 'ctype&lt;cT&gt;' and 'ctype_byname&lt;cT&gt;'.
Thus, a class derived from 'ctype_byname&lt;char&gt;' can tell whether
this class is specialized or not under the current specification:
Without the specialization, 'do_is()' is virtual while with
specialization it is not virtual.</p>


<p><b>Proposed resolution:</b></p>
<p>&nbsp; Change section 22.2.1.2 (lib.locale.ctype.byname) to become:</p>
<pre>     namespace std {
       template &lt;class charT&gt;
       class ctype_byname : public ctype&lt;charT&gt; {
       public:
         typedef ctype&lt;charT&gt;::mask mask;
         explicit ctype_byname(const char*, size_t refs = 0);
       protected:
        ~ctype_byname();             //  virtual
       };
     }</pre>
<p>&nbsp; Change section 22.2.1.6 (lib.locale.codecvt.byname) to become:</p>
<pre>    namespace std {
      template &lt;class internT, class externT, class stateT&gt;
      class codecvt_byname : public codecvt&lt;internT, externT, stateT&gt; {
      public:
       explicit codecvt_byname(const char*, size_t refs = 0);
      protected:
      ~codecvt_byname();             //  virtual
       };
     }
</pre>
<p>&nbsp; Change section 22.2.3.2 (lib.locale.numpunct.byname) to become:</p>
<pre>     namespace std {
       template &lt;class charT&gt;
       class numpunct_byname : public numpunct&lt;charT&gt; {
     //  this class is specialized for  char  and  wchar_t.
       public:
         typedef charT                char_type;
         typedef basic_string&lt;charT&gt;  string_type;
         explicit numpunct_byname(const char*, size_t refs = 0);
       protected:
        ~numpunct_byname();          //  virtual
       };
     }</pre>
<p>&nbsp; Change section 22.2.4.2 (lib.locale.collate.byname) to become:</p>
<pre>     namespace std {
       template &lt;class charT&gt;
       class collate_byname : public collate&lt;charT&gt; {
       public:
         typedef basic_string&lt;charT&gt; string_type;
         explicit collate_byname(const char*, size_t refs = 0);
       protected:
        ~collate_byname();           //  virtual
       };
     }</pre>
<p>&nbsp; Change section 22.2.5.2 (lib.locale.time.get.byname) to become:</p>
<pre>     namespace std {
       template &lt;class charT, class InputIterator = istreambuf_iterator&lt;charT&gt; &gt;
       class time_get_byname : public time_get&lt;charT, InputIterator&gt; {
       public:
         typedef time_base::dateorder dateorder;
         typedef InputIterator        iter_type</pre>
<pre>         explicit time_get_byname(const char*, size_t refs = 0);
       protected:
        ~time_get_byname();          //  virtual
       };
     }</pre>
<p>&nbsp; Change section 22.2.5.4 (lib.locale.time.put.byname) to become:</p>
<pre>     namespace std {
       template &lt;class charT, class OutputIterator = ostreambuf_iterator&lt;charT&gt; &gt;
       class time_put_byname : public time_put&lt;charT, OutputIterator&gt;
       {
       public:
         typedef charT          char_type;
         typedef OutputIterator iter_type;</pre>
<pre>         explicit time_put_byname(const char*, size_t refs = 0);
       protected:
        ~time_put_byname();          //  virtual
       };
     }"</pre>
<p>&nbsp; Change section 22.2.6.4 (lib.locale.moneypunct.byname) to become:</p>
<pre>     namespace std {
       template &lt;class charT, bool Intl = false&gt;
       class moneypunct_byname : public moneypunct&lt;charT, Intl&gt; {
       public:
         typedef money_base::pattern pattern;
         typedef basic_string&lt;charT&gt; string_type;</pre>
<pre>         explicit moneypunct_byname(const char*, size_t refs = 0);
       protected:
        ~moneypunct_byname();        //  virtual
       };
     }</pre>
<p>&nbsp; Change section 22.2.7.2 (lib.locale.messages.byname) to become:</p>
<pre>     namespace std {
       template &lt;class charT&gt;
       class messages_byname : public messages&lt;charT&gt; {
       public:
         typedef messages_base::catalog catalog;
         typedef basic_string&lt;charT&gt;    string_type;</pre>
<pre>         explicit messages_byname(const char*, size_t refs = 0);
       protected:
        ~messages_byname();          //  virtual
       };
     }</pre>
<p>Remove section 22.4.1.4 [locale.codecvt] completely (because in
this case only those members are defined to be virtual which are
defined to be virtual in 'ctype&lt;cT&gt;'.)</p>

<p><i>[Post-Tokyo: Dietmar Khl submitted this issue at the request of
the LWG to solve the underlying problems raised by issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#138">138</a>.]</i></p>


<p><i>[Copenhagen: proposed resolution was revised slightly, to remove
three last virtual functions from <tt>messages_byname</tt>.]</i></p>







<hr>
<h3><a name="229"></a>229. Unqualified references of other library entities</h3>
<p><b>Section:</b> 17.6.1.1 [contents] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Steve Clamage <b>Opened:</b> 2000-04-19 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#contents">issues</a> in [contents].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>Throughout the library chapters, the descriptions of library entities refer
to other library entities without necessarily qualifying the names.</p>

<p>For example, section 25.2.2 "Swap" describes the effect of
swap_ranges in terms of the unqualified name "swap". This section
could reasonably be interpreted to mean that the library must be implemented so
as to do a lookup of the unqualified name "swap", allowing users to
override any ::std::swap function when Koenig lookup applies.</p>

<p>Although it would have been best to use explicit qualification with
"::std::" throughout, too many lines in the standard would have to be
adjusted to make that change in a Technical Corrigendum.</p>

<p>Issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#182">182</a>, which addresses qualification of
<tt>size_t</tt>, is a special case of this.
</p>


<p><b>Proposed resolution:</b></p>
<p>To section 17.4.1.1 "Library contents" Add the following paragraph:</p>
<blockquote>
  <p>Whenever a name x defined in the standard library is mentioned, the name x
  is assumed to be fully qualified as ::std::x, unless explicitly described
  otherwise. For example, if the Effects section for library function F is
  described as calling library function G, the function ::std::G is meant.</p>
</blockquote>

<p><i>[Post-Tokyo: Steve Clamage submitted this issue at the request of
the LWG to solve a problem in the standard itself similar to the
problem within implementations of library identified by issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#225">225</a>.  Any resolution of issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#225">225</a> should be
coordinated with the resolution of this issue.]</i></p>


<p><i>[post-Toronto: Howard is undecided about whether it is
appropriate for all standard library function names referred to in
other standard library functions to be explicitly qualified by
<tt>std</tt>: it is common advice that users should define global
functions that operate on their class in the same namespace as the 
class, and this requires argument-dependent lookup if those functions
are intended to be called by library code.  Several LWG members are
concerned that valarray appears to require argument-dependent lookup,
but that the wording may not be clear enough to fall under
"unless explicitly described otherwise".]</i></p>


<p><i>[Curaao: An LWG-subgroup spent an afternoon working on issues
225, 226, and 229.  Their conclusion was that the issues should be
separated into an LWG portion (Howard's paper, N1387=02-0045), and a
EWG portion (Dave will write a proposal). The LWG and EWG had
(separate) discussions of this plan the next day.  This paper resolves
issues 225 and 226.  In light of that resolution, the proposed
resolution for the current issue makes sense.]</i></p>







<hr>
<h3><a name="230"></a>230. Assignable specified without also specifying CopyConstructible</h3>
<p><b>Section:</b> 17 [library] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Beman Dawes <b>Opened:</b> 2000-04-26 <b>Last modified:</b> 2010-10-29</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>Issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#227">227</a> identified an instance (std::swap) where
Assignable was specified without also specifying
CopyConstructible. The LWG asked that the standard be searched to
determine if the same defect existed elsewhere.</p>

<p>There are a number of places (see proposed resolution below) where
Assignable is specified without also specifying
CopyConstructible. There are also several cases where both are
specified. For example, 26.5.1 [rand.req].</p>


<p><b>Proposed resolution:</b></p>
<p>In  23.2 [container.requirements] table 65 for value_type:
change "T is Assignable" to "T is CopyConstructible and
Assignable"
</p>

<p>In 23.2.4 [associative.reqmts] table 69 X::key_type; change
"Key is Assignable" to "Key is
CopyConstructible and Assignable"<br>
</p>

<p>In 24.2.4 [output.iterators] paragraph 1, change:
</p>
<blockquote>
<p> A class or a built-in type X satisfies the requirements of an
output iterator if X is an Assignable type (23.1) and also the
following expressions are valid, as shown in Table 73:
</p>
</blockquote>
<p>to:
</p>
<blockquote>
<p> A class or a built-in type X satisfies the requirements of an
output iterator if X is a CopyConstructible (20.1.3) and Assignable
type (23.1) and also the following expressions are valid, as shown in
Table 73:
</p>
</blockquote>

<p><i>[Post-Tokyo: Beman Dawes submitted this issue at the request of
the LWG.  He asks that the 25.3.5 [alg.replace] and 25.3.6 [alg.fill] changes be studied carefully, as it is not clear that
CopyConstructible is really a requirement and may be
overspecification.]</i></p>


<p><i>[Portions of the resolution for issue 230 have been superceded by
the resolution of issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#276">276</a>.]</i></p>




<p><b>Rationale:</b></p>
<p>The original proposed resolution also included changes to input
iterator, fill, and replace.  The LWG believes that those changes are
not necessary.  The LWG considered some blanket statement, where an
Assignable type was also required to be Copy Constructible, but
decided against this because fill and replace really don't require the
Copy Constructible property.</p>




<hr>
<h3><a name="231"></a>231. Precision in iostream?</h3>
<p><b>Section:</b> 22.4.2.2.2 [facet.num.put.virtuals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> James Kanze, Stephen Clamage <b>Opened:</b> 2000-04-25 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#facet.num.put.virtuals">issues</a> in [facet.num.put.virtuals].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>What is the following program supposed to output?</p>
<pre>#include &lt;iostream&gt;

    int
    main()
    {
        std::cout.setf( std::ios::scientific , std::ios::floatfield ) ;
        std::cout.precision( 0 ) ;
        std::cout &lt;&lt; 1.00 &lt;&lt; '\n' ;
        return 0 ;
    }</pre>
<p>From my C experience, I would expect "1e+00"; this is what 
<tt>printf("%.0e" , 1.00 );</tt> does. G++ outputs 
"1.000000e+00".</p>

<p>The only indication I can find in the standard is 22.2.2.2.2/11,
where it says "For conversion from a floating-point type, if
(flags &amp; fixed) != 0 or if str.precision() &gt; 0, then
str.precision() is specified in the conversion specification."
This is an obvious error, however, fixed is not a mask for a field,
but a value that a multi-bit field may take -- the results of and'ing
fmtflags with ios::fixed are not defined, at least not if
ios::scientific has been set. G++'s behavior corresponds to what might
happen if you do use (flags &amp; fixed) != 0 with a typical
implementation (floatfield == 3 &lt;&lt; something, fixed == 1
&lt;&lt; something, and scientific == 2 &lt;&lt; something).</p>

<p>Presumably, the intent is either (flags &amp; floatfield) != 0, or
(flags &amp; floatfield) == fixed; the first gives something more or
less like the effect of precision in a printf floating point
conversion. Only more or less, of course. In order to implement printf
formatting correctly, you must know whether the precision was
explicitly set or not. Say by initializing it to -1, instead of 6, and
stating that for floating point conversions, if precision &lt; -1, 6
will be used, for fixed point, if precision &lt; -1, 1 will be used,
etc. Plus, of course, if precision == 0 and flags &amp; floatfield ==
0, 1 should be = used. But it probably isn't necessary to emulate all
of the anomalies of printf:-).</p>


<p><b>Proposed resolution:</b></p>
<p>
Replace 22.4.2.2.2 [facet.num.put.virtuals], paragraph 11, with the following 
sentence:
</p>
<blockquote><p>
For conversion from a floating-point type,
<tt><i>str</i>.precision()</tt> is specified in the conversion
specification.
</p></blockquote>


<p><b>Rationale:</b></p>
<p>The floatfield determines whether numbers are formatted as if
with %f, %e, or %g.  If the <tt>fixed</tt> bit is set, it's %f,
if <tt>scientific</tt> it's %e, and if both bits are set, or 
neither, it's %g.</p>
<p>Turning to the C standard, a precision of 0 is meaningful
for %f and %e.  For %g, precision 0 is taken to be the same as 
precision 1.</p>
<p>The proposed resolution has the effect that if neither
<tt>fixed</tt> nor <tt>scientific</tt> is set we'll be
specifying a precision of 0, which will be internally
turned into 1.  There's no need to call it out as a special
case.</p>
<p>The output of the above program will be "1e+00".</p>

<p><i>[Post-Curaao: Howard provided improved wording covering the case
where precision is 0 and mode is %g.]</i></p>







<hr>
<h3><a name="232"></a>232. "depends" poorly defined in 17.4.3.1</h3>
<p><b>Section:</b> 17.6.3.3 [reserved.names] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Peter Dimov <b>Opened:</b> 2000-04-18 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#reserved.names">issues</a> in [reserved.names].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>17.4.3.1/1 uses the term "depends" to limit the set of allowed
specializations of standard templates to those that "depend on a
user-defined name of external linkage."</p>
<p>This term, however, is not adequately defined, making it possible to
construct a specialization that is, I believe, technically legal according to
17.4.3.1/1, but that specializes a standard template for a built-in type such as
'int'.</p>
<p>The following code demonstrates the problem:</p>
<blockquote>
  <pre>#include &lt;algorithm&gt;</pre>
  <pre>template&lt;class T&gt; struct X
{
 typedef T type;
};</pre>
  <pre>namespace std
{
 template&lt;&gt; void swap(::X&lt;int&gt;::type&amp; i, ::X&lt;int&gt;::type&amp; j);
}</pre>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>Change "user-defined name" to "user-defined
type".</p>


<p><b>Rationale:</b></p>
<p>This terminology is used in section 2.5.2 and 4.1.1 of <i>The C++
Programming Language</i>.  It disallows the example in the issue,
since the underlying type itself is not user-defined.  The only
possible problem I can see is for non-type templates, but there's no
possible way for a user to come up with a specialization for bitset,
for example, that might not have already been specialized by the
implementor?</p>

<p><i>[Toronto: this may be related to issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#120">120</a>.]</i></p>


<p><i>[post-Toronto: Judy provided the above proposed resolution and
rationale.]</i></p>






<hr>
<h3><a name="233"></a>233. Insertion hints in associative containers</h3>
<p><b>Section:</b> 23.2.4 [associative.reqmts] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Andrew Koenig <b>Opened:</b> 2000-04-30 <b>Last modified:</b> 2010-10-29</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#associative.reqmts">active issues</a> in [associative.reqmts].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#associative.reqmts">issues</a> in [associative.reqmts].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#192">192</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#246">246</a></p>
<p><b>Discussion:</b></p>
<p>
If <tt>mm</tt> is a multimap and <tt>p</tt> is an iterator
into the multimap, then <tt>mm.insert(p, x)</tt> inserts
<tt>x</tt> into <tt>mm</tt> with <tt>p</tt> as a hint as
to where it should go.  Table 69 claims that the execution time is
amortized constant if the insert winds up taking place adjacent to
<tt>p</tt>, but does not say when, if ever, this is guaranteed to
happen.  All it says it that <tt>p</tt> is a hint as to where to
insert.
</p>
<p>
The question is whether there is any guarantee about the relationship
between <tt>p</tt> and the insertion point, and, if so, what it
is.
</p>
<p>
I believe the present state is that there is no guarantee: The user
can supply <tt>p</tt>, and the implementation is allowed to
disregard it entirely.
</p>

<p><b>Additional comments from Nathan:</b><br>

The vote [in Redmond] was on whether to elaborately specify the use of
the hint, or to require behavior only if the value could be inserted
adjacent to the hint.  I would like to ensure that we have a chance to
vote for a deterministic treatment: "before, if possible, otherwise
after, otherwise anywhere appropriate", as an alternative to the
proposed "before or after, if possible, otherwise [...]".
</p>

<p><i>[Toronto: there was general agreement that this is a real defect:
when inserting an element x into a multiset that already contains
several copies of x, there is no way to know whether the hint will be
used.  The proposed resolution was that the new element should always
be inserted as close to the hint as possible.  So, for example, if
there is a subsequence of equivalent values, then providing a.begin()
as the hint means that the new element should be inserted before the
subsequence even if a.begin() is far away.  JC van Winkel supplied
precise wording for this proposed resolution, and also for an
alternative resolution in which hints are only used when they are
adjacent to the insertion point.]</i></p>


<p><i>[Copenhagen: the LWG agreed to the original proposed resolution,
in which an insertion hint would be used even when it is far from the
insertion point.  This was contingent on seeing a example
implementation showing that it is possible to implement this
requirement without loss of efficiency.  John Potter provided such a
example implementation.]</i></p>


<p><i>[Redmond: The LWG was reluctant to adopt the proposal that
emerged from Copenhagen: it seemed excessively complicated, and went
beyond fixing the defect that we identified in Toronto.  PJP provided
the new wording described in this issue.  Nathan agrees that we
shouldn't adopt the more detailed semantics, and notes: "we know that
you can do it efficiently enough with a red-black tree, but there are
other (perhaps better) balanced tree techniques that might differ
enough to make the detailed semantics hard to satisfy."]</i></p>


<p><i>[Curaao: Nathan should give us the alternative wording he
suggests so the LWG can decide between the two options.]</i></p>


<p><i>[Lillehammer: The LWG previously rejected the more detailed
  semantics, because it seemed more loike a new feature than like
  defect fixing.  We're now more sympathetic to it, but we (especially
  Bill) are still worried about performance.  N1780 describes a naive
  algorithm, but it's not clear whether there is a non-naive
  implementation. Is it possible to implement this as efficently as
  the current version of insert?]</i></p>


<p><i>[Post Lillehammer:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1780.html">N1780</a>
updated in post meeting mailing with
feedback from Lillehammer with more information regarding performance.
]</i></p>


<p><i>[
Batavia:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1780.html">1780</a>
accepted with minor wording changes in the proposed wording (reflected in the
proposed resolution below).  Concerns about the performance of the algorithm
were satisfactorily met by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1780.html">1780</a>.
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#371">371</a> already handles the stability of equal ranges
and so that part of the resolution from
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1780.html">1780</a>
is no longer needed (or reflected in the proposed wording below).
]</i></p>




<p><b>Proposed resolution:</b></p>

<p>
Change the indicated rows of the "Associative container requirements" Table in
23.2.4 [associative.reqmts] to:
</p>

<p></p><center>
<table border="1">
<caption>Associative container requirements</caption>
<tbody><tr><th>expression</th> <th>return type</th>
<th>assertion/note<br>pre/post-condition</th>
<th>complexity</th></tr>
<tr><td><tt>a_eq.insert(t)</tt></td>
<td><tt>iterator</tt></td>
<td>
inserts <tt>t</tt> and returns the iterator pointing to the newly inserted
element. <ins>If a range containing elements equivalent to <tt>t</tt> exists in
<tt>a_eq</tt>, <tt>t</tt> is inserted at the end of that range.</ins>
</td>
<td>
logarithmic
</td></tr>
<tr><td><tt>a.insert(p,t)</tt></td>
<td><tt>iterator</tt></td>
<td>
inserts <tt>t</tt> if and only if there is no element with key equivalent to the
key of <tt>t</tt> in containers with unique keys; always inserts <tt>t</tt> in containers
with equivalent keys. always returns the iterator pointing to the element with key
equivalent to the key of <tt>t</tt>. <del>iterator <tt>p</tt> is a hint pointing to where
the insert should start to search.</del> <ins><tt>t</tt> is inserted as close as possible
to the position just prior to <tt>p</tt>.</ins>
</td>
<td>
logarithmic in general, but amortized constant if <tt>t</tt> is inserted right <del>after</del>
 <ins>before</ins> <tt>p</tt>.
</td></tr>
</tbody></table>
</center><p></p>






<hr>
<h3><a name="234"></a>234. Typos in allocator definition</h3>
<p><b>Section:</b> 20.9.5.1 [allocator.members] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Dietmar Khl <b>Opened:</b> 2000-04-24 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#allocator.members">issues</a> in [allocator.members].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>In paragraphs 12 and 13 the effects of <tt>construct()</tt> and
<tt>destruct()</tt> are described as returns but the functions actually
return <tt>void</tt>.</p>


<p><b>Proposed resolution:</b></p>
<p>Substitute "Returns" by "Effect".</p>




<hr>
<h3><a name="235"></a>235. No specification of default ctor for reverse_iterator</h3>
<p><b>Section:</b> 24.5.1.1 [reverse.iterator] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Dietmar Khl <b>Opened:</b> 2000-04-24 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>The declaration of <tt>reverse_iterator</tt> lists a default
constructor.  However, no specification is given what this constructor
should do.</p>


<p><b>Proposed resolution:</b></p>
  <p>In section 24.5.1.3.1 [reverse.iter.cons] add the following
  paragraph:</p>
      <blockquote>
      <p><tt>reverse_iterator()</tt></p>

      <p>Default initializes <tt>current</tt>. Iterator operations
      applied to the resulting iterator have defined behavior if and
      only if the corresponding operations are defined on a default
      constructed iterator of type <tt>Iterator</tt>.</p>
      </blockquote>
  <p><i>[pre-Copenhagen: Dietmar provide wording for proposed
  resolution.]</i></p>






<hr>
<h3><a name="237"></a>237. Undefined expression in complexity specification</h3>
<p><b>Section:</b> 23.3.2.1 [deque.cons] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Dietmar Khl <b>Opened:</b> 2000-04-24 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#deque.cons">issues</a> in [deque.cons].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>The complexity specification in paragraph 6 says that the complexity
is linear in <tt>first - last</tt>. Even if <tt>operator-()</tt> is
defined on iterators this term is in general undefined because it
would have to be <tt>last - first</tt>.</p>


<p><b>Proposed resolution:</b></p>
  <p>Change paragraph 6 from</p>
     <blockquote><p>Linear in <i>first - last</i>.</p></blockquote>
  <p>to become</p>
     <blockquote><p>Linear in <i>distance(first, last)</i>.</p></blockquote>




<hr>
<h3><a name="238"></a>238. Contradictory results of stringbuf initialization.</h3>
<p><b>Section:</b> 27.8.1.1 [stringbuf.cons] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Dietmar Khl <b>Opened:</b> 2000-05-11 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#stringbuf.cons">issues</a> in [stringbuf.cons].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>In 27.7.1.1 paragraph 4 the results of calling the constructor of
'basic_stringbuf' are said to be <tt>str() == str</tt>. This is fine
that far but consider this code:</p>

<pre>  std::basic_stringbuf&lt;char&gt; sbuf("hello, world", std::ios_base::openmode(0));
  std::cout &lt;&lt; "'" &lt;&lt; sbuf.str() &lt;&lt; "'\n";
</pre>

<p>Paragraph 3 of 27.7.1.1 basically says that in this case neither
the output sequence nor the input sequence is initialized and
paragraph 2 of 27.7.1.2 basically says that <tt>str()</tt> either
returns the input or the output sequence. None of them is initialized,
ie. both are empty, in which case the return from <tt>str()</tt> is
defined to be <tt>basic_string&lt;cT&gt;()</tt>.</p>

<p>However, probably only test cases in some testsuites will detect this
"problem"...</p>


<p><b>Proposed resolution:</b></p>
<p>Remove 27.7.1.1 paragraph 4.</p>


<p><b>Rationale:</b></p>
<p>We could fix 27.7.1.1 paragraph 4, but there would be no point.  If
we fixed it, it would say just the same thing as text that's already
in the standard.</p>




<hr>
<h3><a name="239"></a>239. Complexity of unique() and/or unique_copy incorrect</h3>
<p><b>Section:</b> 25.3.9 [alg.unique] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Angelika Langer <b>Opened:</b> 2000-05-15 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.unique">issues</a> in [alg.unique].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>The complexity of unique and unique_copy are inconsistent with each
other and inconsistent with the implementations.&nbsp; The standard
specifies:</p>

<p>for unique():</p>

<blockquote><p>-3- Complexity: If the range (last - first) is not empty, exactly
(last - first) - 1 applications of the corresponding predicate, otherwise
no applications of the predicate.</p></blockquote>

<p>for unique_copy():</p>

<blockquote><p>-7- Complexity: Exactly last - first applications of the corresponding
predicate.</p></blockquote>

<p>
The implementations do it the other way round: unique() applies the
predicate last-first times and unique_copy() applies it last-first-1
times.</p>

<p>As both algorithms use the predicate for pair-wise comparison of
sequence elements I don't see a justification for unique_copy()
applying the predicate last-first times, especially since it is not
specified to which pair in the sequence the predicate is applied
twice.</p>


<p><b>Proposed resolution:</b></p>
<p>Change both complexity sections in 25.3.9 [alg.unique] to:</p>

<blockquote><p>Complexity: For nonempty ranges, exactly last - first - 1
applications of the corresponding predicate.</p></blockquote>






<hr>
<h3><a name="240"></a>240. Complexity of adjacent_find() is meaningless</h3>
<p><b>Section:</b> 25.2.8 [alg.adjacent.find] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Angelika Langer <b>Opened:</b> 2000-05-15 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.adjacent.find">issues</a> in [alg.adjacent.find].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>The complexity section of adjacent_find is defective:</p>

<blockquote>
<pre>template &lt;class ForwardIterator&gt;
ForwardIterator adjacent_find(ForwardIterator first, ForwardIterator last
                              BinaryPredicate pred);
</pre>

<p>-1- Returns: The first iterator i such that both i and i + 1 are in
the range [first, last) for which the following corresponding
conditions hold: *i == *(i + 1), pred(*i, *(i + 1)) != false. Returns
last if no such iterator is found.</p>

<p>-2- Complexity: Exactly find(first, last, value) - first applications
of the corresponding predicate.
</p>
</blockquote>

<p>In the Complexity section, it is not defined what "value"
is supposed to mean. My best guess is that "value" means an
object for which one of the conditions pred(*i,value) or
pred(value,*i) is true, where i is the iterator defined in the Returns
section. However, the value type of the input sequence need not be
equality-comparable and for this reason the term find(first, last,
value) - first is meaningless.</p>

<p>A term such as find_if(first, last, bind2nd(pred,*i)) - first or
find_if(first, last, bind1st(pred,*i)) - first might come closer to
the intended specification.  Binders can only be applied to function
objects that have the function call operator declared const, which is
not required of predicates because they can have non-const data
members. For this reason, a specification using a binder could only be
an "as-if" specification.</p>


<p><b>Proposed resolution:</b></p>
<p>Change the complexity section in 25.2.8 [alg.adjacent.find] to:</p>
<blockquote><p>
For a nonempty range, exactly <tt>min((<i>i</i> - <i>first</i>) + 1,
(<i>last</i> - <i>first</i>) - 1)</tt> applications of the
corresponding predicate, where <i>i</i> is <tt>adjacent_find</tt>'s
return value.
</p></blockquote>

<p><i>[Copenhagen: the original resolution specified an upper
bound.  The LWG preferred an exact count.]</i></p>







<hr>
<h3><a name="241"></a>241. Does unique_copy() require CopyConstructible and Assignable?</h3>
<p><b>Section:</b> 25.3.9 [alg.unique] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Angelika Langer <b>Opened:</b> 2000-05-15 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.unique">issues</a> in [alg.unique].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>

<p>Some popular implementations of unique_copy() create temporary
copies of values in the input sequence, at least if the input iterator
is a pointer.  Such an implementation is built on the assumption that
the value type is CopyConstructible and Assignable.</p>

<p>It is common practice in the standard that algorithms explicitly
specify any additional requirements that they impose on any of the
types used by the algorithm. An example of an algorithm that creates
temporary copies and correctly specifies the additional requirements
is accumulate(), 26.5.1 [rand.req].</p>

<p>Since the specifications of unique() and unique_copy() do not
require CopyConstructible and Assignable of the InputIterator's value
type the above mentioned implementations are not standard-compliant. I
cannot judge whether this is a defect in the standard or a defect in
the implementations.</p>


<p><b>Proposed resolution:</b></p>
<p>In 25.2.8 change:</p>

<blockquote><p>
-4- Requires: The ranges [first, last) and [result, result+(last-first))
shall not overlap.
</p></blockquote>

<p>to:</p>

<blockquote>
  <p>-4- Requires: The ranges [first, last) and [result,
  result+(last-first)) shall not overlap. The expression *result =
  *first must be valid. If neither InputIterator nor OutputIterator
  meets the requirements of forward iterator then the value type of
  InputIterator must be copy constructible. Otherwise copy
  constructible is not required. </p>
</blockquote>

<p><i>[Redmond: the original proposed resolution didn't impose an
explicit requirement that the iterator's value type must be copy
constructible, on the grounds that an input iterator's value type must
always be copy constructible.  Not everyone in the LWG thought that
this requirement was clear from table 72.  It has been suggested that
it might be possible to implement <tt>unique_copy</tt> without
requiring assignability, although current implementations do impose
that requirement.  Howard provided new wording.]</i></p>


<p><i>[
Curaao: The LWG changed the PR editorially to specify
"neither...nor...meet..." as clearer than
"both...and...do not meet...". Change believed to be so
minor as not to require re-review.
]</i></p>








<hr>
<h3><a name="242"></a>242. Side effects of function objects</h3>
<p><b>Section:</b> 25.3.4 [alg.transform], 26.5 [rand] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Angelika Langer <b>Opened:</b> 2000-05-15 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.transform">issues</a> in [alg.transform].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>The algorithms transform(), accumulate(), inner_product(),
partial_sum(), and adjacent_difference() require that the function
object supplied to them shall not have any side effects.</p>

<p>The standard defines a side effect in 1.9 [intro.execution] as:</p>
<blockquote><p>-7- Accessing an object designated by a volatile lvalue (basic.lval),
modifying an object, calling a library I/O function, or calling a function
that does any of those operations are all side effects, which are changes
in the state of the execution environment.</p></blockquote>

<p>As a consequence, the function call operator of a function object supplied
to any of the algorithms listed above cannot modify data members, cannot
invoke any function that has a side effect, and cannot even create and
modify temporary objects.&nbsp; It is difficult to imagine a function object
that is still useful under these severe limitations. For instance, any
non-trivial transformator supplied to transform() might involve creation
and modification of temporaries, which is prohibited according to the current
wording of the standard.</p>

<p>On the other hand, popular implementations of these algorithms exhibit
uniform and predictable behavior when invoked with a side-effect-producing
function objects. It looks like the strong requirement is not needed for
efficient implementation of these algorithms.</p>

<p>The requirement of&nbsp; side-effect-free function objects could be
replaced by a more relaxed basic requirement (which would hold for all
function objects supplied to any algorithm in the standard library):</p>
<blockquote><p>A function objects supplied to an algorithm shall not invalidate
any iterator or sequence that is used by the algorithm. Invalidation of
the sequence includes destruction of the sorting order if the algorithm
relies on the sorting order (see section 25.3 - Sorting and related operations
[lib.alg.sorting]).</p></blockquote>

<p>I can't judge whether it is intended that the function objects supplied
to transform(), accumulate(), inner_product(), partial_sum(), or adjacent_difference()
shall not modify sequence elements through dereferenced iterators.</p>

<p>It is debatable whether this issue is a defect or a change request.
Since the consequences for user-supplied function objects are drastic and
limit the usefulness of the algorithms significantly I would consider it
a defect.</p>


<p><b>Proposed resolution:</b></p>

<p><i>Things to notice about these changes:</i></p>

<ol>
<li> <i>The fully-closed ("[]" as opposed to half-closed "[)" ranges
     are intentional. we want to prevent side-effects from
     invalidating the end iterators.</i></li>

<li> <i>That has the unintentional side-effect of prohibiting
     modification of the end element as a side-effect. This could
     conceivably be significant in some cases.</i></li>

<li> <i>The wording also prevents side-effects from modifying elements
     of the output sequence. I can't imagine why anyone would want
     to do this, but it is arguably a restriction that implementors
     don't need to place on users.</i></li>

<li> <i>Lifting the restrictions imposed in #2 and #3 above is possible
     and simple, but would require more verbiage.</i></li>
</ol>

<p>Change 25.2.3/2 from:</p>

<blockquote><p>
   -2- Requires: op and binary_op shall not have any side effects.
</p></blockquote>

<p>to:</p>

<blockquote><p>
  -2- Requires: in the ranges [first1, last1], [first2, first2 +
  (last1 - first1)] and [result, result + (last1- first1)], op and
  binary_op shall neither modify elements nor invalidate iterators or
  subranges.
  [Footnote: The use of fully closed ranges is intentional --end footnote]
</p></blockquote>


<p>Change 25.2.3/2 from:</p>

<blockquote><p>
   -2- Requires: op and binary_op shall not have any side effects. 
</p></blockquote>

<p>to:</p>

<blockquote><p>
  -2- Requires: op and binary_op shall not invalidate iterators or
   subranges, or modify elements in the ranges [first1, last1],
   [first2, first2 + (last1 - first1)], and [result, result + (last1
   - first1)].
  [Footnote: The use of fully closed ranges is intentional --end footnote]
</p></blockquote>


<p>Change 26.4.1/2 from:</p>

<blockquote><p>
  -2- Requires: T must meet the requirements of CopyConstructible
   (lib.copyconstructible) and Assignable (lib.container.requirements)
   types. binary_op shall not cause side effects.
</p></blockquote>

<p>to:</p>

<blockquote><p>
  -2- Requires: T must meet the requirements of CopyConstructible
   (lib.copyconstructible) and Assignable
   (lib.container.requirements) types. In the range [first, last],
   binary_op shall neither modify elements nor invalidate iterators
   or subranges.
  [Footnote: The use of a fully closed range is intentional --end footnote]
</p></blockquote>

<p>Change 26.4.2/2 from:</p>

<blockquote><p>
  -2- Requires: T must meet the requirements of CopyConstructible
   (lib.copyconstructible) and Assignable (lib.container.requirements)
   types. binary_op1 and binary_op2 shall not cause side effects.
</p></blockquote>

<p>to:</p>

<blockquote><p>
  -2- Requires: T must meet the requirements of CopyConstructible
   (lib.copyconstructible) and Assignable (lib.container.requirements)
   types. In the ranges [first, last] and [first2, first2 + (last -
   first)], binary_op1 and binary_op2 shall neither modify elements
   nor invalidate iterators or subranges.
  [Footnote: The use of fully closed ranges is intentional --end footnote]
</p></blockquote>


<p>Change 26.4.3/4 from:</p>

<blockquote><p>
  -4- Requires: binary_op is expected not to have any side effects.
</p></blockquote>

<p>to:</p>

<blockquote><p>
  -4- Requires: In the ranges [first, last] and [result, result +
   (last - first)], binary_op shall neither modify elements nor
   invalidate iterators or subranges.
  [Footnote: The use of fully closed ranges is intentional --end footnote]
</p></blockquote>

<p>Change 26.4.4/2 from:</p>

<blockquote><p>
  -2- Requires: binary_op shall not have any side effects.
</p></blockquote>

<p>to:</p>

<blockquote><p>
  -2- Requires: In the ranges [first, last] and [result, result +
   (last - first)], binary_op shall neither modify elements nor
   invalidate iterators or subranges.
  [Footnote: The use of fully closed ranges is intentional --end footnote]
</p></blockquote>

<p><i>[Toronto: Dave Abrahams supplied wording.]</i></p>


<p><i>[Copenhagen: Proposed resolution was modified slightly. Matt
added footnotes pointing out that the use of closed ranges was
intentional.]</i></p>







<hr>
<h3><a name="243"></a>243. <tt>get</tt> and <tt>getline</tt> when sentry reports failure</h3>
<p><b>Section:</b> 27.7.1.3 [istream.unformatted] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2000-05-15 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#istream.unformatted">issues</a> in [istream.unformatted].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>basic_istream&lt;&gt;::get(), and basic_istream&lt;&gt;::getline(),
are unclear with respect to the behavior and side-effects of the named
functions in case of an error.</p>

<p>27.6.1.3, p1 states that "... If the sentry object returns
true, when converted to a value of type bool, the function endeavors
to obtain the requested input..." It is not clear from this (or
the rest of the paragraph) what precisely the behavior should be when
the sentry ctor exits by throwing an exception or when the sentry
object returns false.  In particular, what is the number of characters
extracted that gcount() returns supposed to be?</p>

<p>27.6.1.3 p8 and p19 say about the effects of get() and getline():
"...  In any case, it then stores a null character (using
charT()) into the next successive location of the array." Is not
clear whether this sentence applies if either of the conditions above
holds (i.e., when sentry fails).</p>


<p><b>Proposed resolution:</b></p>
<p>Add to 27.6.1.3, p1 after the sentence</p>

<blockquote><p>
"... If the sentry object returns true, when converted to a value of
type bool, the function endeavors to obtain the requested input."
</p></blockquote>

<p>the following</p>


<blockquote><p>
"Otherwise, if the sentry constructor exits by throwing an exception or
if the sentry object returns false, when converted to a value of type
bool, the function returns without attempting to obtain any input. In
either case the number of extracted characters is set to 0; unformatted
input functions taking a character array of non-zero size as an argument
shall also store a null character (using charT()) in the first location
of the array."
</p></blockquote>


<p><b>Rationale:</b></p>
<p>Although the general philosophy of the input functions is that the
argument should not be modified upon failure, <tt>getline</tt>
historically added a terminating null unconditionally.  Most
implementations still do that.  Earlier versions of the draft standard
had language that made this an unambiguous requirement; those words
were moved to a place where their context made them less clear.  See
Jerry Schwarz's message c++std-lib-7618.</p>




<hr>
<h3><a name="247"></a>247. <tt>vector</tt>, <tt>deque::insert</tt> complexity</h3>
<p><b>Section:</b> 23.4.1.4 [vector.modifiers] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Lisa Lippincott <b>Opened:</b> 2000-06-06 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#vector.modifiers">issues</a> in [vector.modifiers].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>Paragraph 2 of 23.4.1.4 [vector.modifiers] describes the complexity
of <tt>vector::insert</tt>:</p>

   <blockquote><p>
   Complexity: If first and last are forward iterators, bidirectional
   iterators, or random access iterators, the complexity is linear in
   the number of elements in the range [first, last) plus the distance
   to the end of the vector. If they are input iterators, the complexity
   is proportional to the number of elements in the range [first, last)
   times the distance to the end of the vector.
   </p></blockquote>

<p>First, this fails to address the non-iterator forms of
<tt>insert</tt>.</p>

<p>Second, the complexity for input iterators misses an edge case --
it requires that an arbitrary number of elements can be added at
the end of a <tt>vector</tt> in constant time.</p>

<p>I looked to see if <tt>deque</tt> had a similar problem, and was
surprised to find that <tt>deque</tt> places no requirement on the
complexity of inserting multiple elements (23.3.2.3 [deque.modifiers],
paragraph 3):</p>

   <blockquote><p>
   Complexity: In the worst case, inserting a single element into a
   deque takes time linear in the minimum of the distance from the
   insertion point to the beginning of the deque and the distance
   from the insertion point to the end of the deque. Inserting a
   single element either at the beginning or end of a deque always
   takes constant time and causes a single call to the copy constructor
   of T.
   </p></blockquote>


<p><b>Proposed resolution:</b></p>

<p>Change Paragraph 2 of 23.4.1.4 [vector.modifiers] to</p>
   <blockquote><p>
   Complexity: The complexity is linear in the number of elements 
   inserted plus the distance to the end of the vector.
   </p></blockquote>

   <p><i>[For input iterators, one may achieve this complexity by first
   inserting at the end of the <tt>vector</tt>, and then using
   <tt>rotate</tt>.]</i></p>


<p>Change 23.3.2.3 [deque.modifiers], paragraph 3, to:</p>

   <blockquote><p>
   Complexity: The complexity is linear in the number of elements 
   inserted plus the shorter of the distances to the beginning and
   end of the deque.  Inserting a single element at either the
   beginning or the end of a deque causes a single call to the copy
   constructor of T.
   </p></blockquote>



<p><b>Rationale:</b></p>
<p>This is a real defect, and proposed resolution fixes it: some
  complexities aren't specified that should be.  This proposed
  resolution does constrain deque implementations (it rules out the
  most naive possible implementations), but the LWG doesn't see a
  reason to permit that implementation.</p>





<hr>
<h3><a name="248"></a>248. time_get fails to set eofbit</h3>
<p><b>Section:</b> 22.4.5 [category.time] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2000-06-22 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>There is no requirement that any of time_get member functions set
ios::eofbit when they reach the end iterator while parsing their input.
Since members of both the num_get and money_get facets are required to
do so (22.2.2.1.2, and 22.2.6.1.2, respectively), time_get members
should follow the same requirement for consistency.</p>


<p><b>Proposed resolution:</b></p>
<p>Add paragraph 2 to section 22.2.5.1 with the following text:</p>

<blockquote><p>
If the end iterator is reached during parsing by any of the get()
member functions, the member sets ios_base::eofbit in err.
</p></blockquote>


<p><b>Rationale:</b></p>
<p>Two alternative resolutions were proposed.  The LWG chose this one
because it was more consistent with the way eof is described for other
input facets.</p>




<hr>
<h3><a name="250"></a>250. splicing invalidates iterators</h3>
<p><b>Section:</b> 23.3.4.4 [list.ops] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Brian Parker  <b>Opened:</b> 2000-07-14 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#list.ops">issues</a> in [list.ops].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Section 23.3.4.4 [list.ops] states that
</p>
<pre>  void splice(iterator position, list&lt;T, Allocator&gt;&amp; x);
</pre>
<p>
<i>invalidates</i> all iterators and references to list <tt>x</tt>.
</p>

<p>
This is unnecessary and defeats an important feature of splice. In
fact, the SGI STL guarantees that iterators to <tt>x</tt> remain valid
after <tt>splice</tt>.
</p>


<p><b>Proposed resolution:</b></p>

<p>Add a footnote to 23.3.4.4 [list.ops], paragraph 1:</p>
<blockquote><p>
[<i>Footnote:</i> As specified in  [default.con.req], paragraphs
4-5, the semantics described in this clause applies only to the case
where allocators compare equal.  --end footnote]
</p></blockquote>

<p>In 23.3.4.4 [list.ops], replace paragraph 4 with:</p>
<blockquote><p>
Effects: Inserts the contents of x before position and x becomes 
empty.  Pointers and references to the moved elements of x now refer to 
those same elements but as members of *this.  Iterators referring to the 
moved elements will continue to refer to their elements, but they now 
behave as iterators into *this, not into x.
</p></blockquote>

<p>In 23.3.4.4 [list.ops], replace paragraph 7 with:</p>
<blockquote><p>
Effects: Inserts an element pointed to by i from list x before 
position and removes the element from x. The result is unchanged if 
position == i or position == ++i.  Pointers and references to *i continue 
to refer to this same element but as a member of *this.  Iterators to *i 
(including i itself) continue to refer to the same element, but now 
behave as iterators into *this, not into x.
</p></blockquote>

<p>In 23.3.4.4 [list.ops], replace paragraph 12 with:</p>
<blockquote><p>
Requires: [first, last) is a valid range in x. The result is 
undefined if position is an iterator in the range [first, last).  
Pointers and references to the moved elements of x now refer to those 
same elements but as members of *this.  Iterators referring to the moved 
elements will continue to refer to their elements, but they now behave as 
iterators into *this, not into x.
</p></blockquote>

<p><i>[pre-Copenhagen: Howard provided wording.]</i></p>



<p><b>Rationale:</b></p>
<p>The original proposed resolution said that iterators and references
would remain "valid".  The new proposed resolution clarifies what that
means.  Note that this only applies to the case of equal allocators.
From  [default.con.req] paragraph 4, the behavior of list when
allocators compare nonequal is outside the scope of the standard.</p>




<hr>
<h3><a name="251"></a>251. basic_stringbuf missing allocator_type</h3>
<p><b>Section:</b> 27.8.1 [stringbuf] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2000-07-28 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>The synopsis for the template class <tt>basic_stringbuf</tt>
doesn't list a typedef for the template parameter
<tt>Allocator</tt>. This makes it impossible to determine the type of
the allocator at compile time. It's also inconsistent with all other
template classes in the library that do provide a typedef for the
<tt>Allocator</tt> parameter.</p>


<p><b>Proposed resolution:</b></p>
<p>Add to the synopses of the class templates basic_stringbuf (27.7.1),
basic_istringstream (27.7.2), basic_ostringstream (27.7.3), and 
basic_stringstream (27.7.4) the typedef:</p>
<pre>  typedef Allocator allocator_type;
</pre>




<hr>
<h3><a name="252"></a>252. missing casts/C-style casts used in iostreams</h3>
<p><b>Section:</b> 27.8 [string.streams] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2000-07-28 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#string.streams">issues</a> in [string.streams].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>27.7.2.2, p1 uses a C-style cast rather than the more appropriate
const_cast&lt;&gt; in the Returns clause for basic_istringstream&lt;&gt;::rdbuf().
The same C-style cast is being used in 27.7.3.2, p1, D.7.2.2, p1, and
D.7.3.2, p1, and perhaps elsewhere. 27.7.6, p1 and D.7.2.2, p1 are missing
the cast altogether.</p>

<p>C-style casts have not been deprecated, so the first part of this
issue is stylistic rather than a matter of correctness.</p>


<p><b>Proposed resolution:</b></p>
<p>In 27.7.2.2, p1 replace </p>
<pre>  -1- Returns: (basic_stringbuf&lt;charT,traits,Allocator&gt;*)&amp;sb.</pre>

<p>with</p>
<pre>  -1- Returns: const_cast&lt;basic_stringbuf&lt;charT,traits,Allocator&gt;*&gt;(&amp;sb).</pre>


<p>In 27.7.3.2, p1 replace</p>
<pre>  -1- Returns: (basic_stringbuf&lt;charT,traits,Allocator&gt;*)&amp;sb.</pre>

<p>with</p>
<pre>  -1- Returns: const_cast&lt;basic_stringbuf&lt;charT,traits,Allocator&gt;*&gt;(&amp;sb).</pre>

<p>In 27.7.6, p1, replace</p>
<pre>  -1- Returns: &amp;sb</pre>

<p>with</p>
<pre>  -1- Returns: const_cast&lt;basic_stringbuf&lt;charT,traits,Allocator&gt;*&gt;(&amp;sb).</pre>

<p>In D.7.2.2, p1 replace</p>
<pre>  -2- Returns: &amp;sb. </pre>

<p>with</p>
<pre>  -2- Returns: const_cast&lt;strstreambuf*&gt;(&amp;sb).</pre>




<hr>
<h3><a name="253"></a>253. valarray helper functions are almost entirely useless</h3>
<p><b>Section:</b> 26.6.2.1 [valarray.cons], 26.6.2.2 [valarray.assign] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Robert Klarer <b>Opened:</b> 2000-07-31 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#valarray.cons">issues</a> in [valarray.cons].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>This discussion is adapted from message c++std-lib-7056 posted
November 11, 1999.  I don't think that anyone can reasonably claim
that the problem described below is NAD.</p>

<p>These valarray constructors can never be called:</p>

<pre>   template &lt;class T&gt;
         valarray&lt;T&gt;::valarray(const slice_array&lt;T&gt; &amp;);
   template &lt;class T&gt;
         valarray&lt;T&gt;::valarray(const gslice_array&lt;T&gt; &amp;);
   template &lt;class T&gt;
         valarray&lt;T&gt;::valarray(const mask_array&lt;T&gt; &amp;);
   template &lt;class T&gt;
         valarray&lt;T&gt;::valarray(const indirect_array&lt;T&gt; &amp;);
</pre>

<p>Similarly, these valarray assignment operators cannot be
called:</p>

<pre>     template &lt;class T&gt;
     valarray&lt;T&gt; valarray&lt;T&gt;::operator=(const slice_array&lt;T&gt; &amp;);
     template &lt;class T&gt;
     valarray&lt;T&gt; valarray&lt;T&gt;::operator=(const gslice_array&lt;T&gt; &amp;);
     template &lt;class T&gt;
     valarray&lt;T&gt; valarray&lt;T&gt;::operator=(const mask_array&lt;T&gt; &amp;);
     template &lt;class T&gt;
     valarray&lt;T&gt; valarray&lt;T&gt;::operator=(const indirect_array&lt;T&gt; &amp;);
</pre>

<p>Please consider the following example:</p>

<pre>   #include &lt;valarray&gt;
   using namespace std;

   int main()
   {
       valarray&lt;double&gt; va1(12);
       valarray&lt;double&gt; va2(va1[slice(1,4,3)]); // line 1
   }
</pre>


<p>Since the valarray va1 is non-const, the result of the sub-expression
va1[slice(1,4,3)] at line 1 is an rvalue of type const
std::slice_array&lt;double&gt;.  This slice_array rvalue is then used to
construct va2.  The constructor that is used to construct va2 is
declared like this:</p>

<pre>     template &lt;class T&gt;
     valarray&lt;T&gt;::valarray(const slice_array&lt;T&gt; &amp;);
</pre>

<p>Notice the constructor's const reference parameter.  When the
constructor is called, a slice_array must be bound to this reference.
The rules for binding an rvalue to a const reference are in 8.5.3,
paragraph 5 (see also 13.3.3.1.4).  Specifically, paragraph 5
indicates that a second slice_array rvalue is constructed (in this
case copy-constructed) from the first one; it is this second rvalue
that is bound to the reference parameter.  Paragraph 5 also requires
that the constructor that is used for this purpose be callable,
regardless of whether the second rvalue is elided.  The
copy-constructor in this case is not callable, however, because it is
private.  Therefore, the compiler should report an error.</p>

<p>Since slice_arrays are always rvalues, the valarray constructor that has a
parameter of type const slice_array&lt;T&gt; &amp; can never be called.  The
same reasoning applies to the three other constructors and the four
assignment operators that are listed at the beginning of this post.
Furthermore, since these functions cannot be called, the valarray helper
classes are almost entirely useless.</p>


<p><b>Proposed resolution:</b></p>
<p>slice_array:</p>
<ul>
<li> Make the copy constructor and copy-assignment operator declarations
     public in the slice_array class template definition in 26.6.5 [template.slice.array] </li>
<li> remove paragraph 3 of 26.6.5 [template.slice.array]</li>
<li> remove the copy constructor declaration from  [cons.slice.arr]</li>
<li> change paragraph 1 of  [cons.slice.arr] to read "This constructor is declared
    to be private.  This constructor need not be defined."</li>
<li> remove the first sentence of paragraph 1 of 26.6.5.1 [slice.arr.assign]</li>
<li> Change the first three words of the second sentence of paragraph 1 of
    26.6.5.1 [slice.arr.assign] to "These assignment operators have"</li>
</ul>

<p>gslice_array:</p>
<ul>
<li> Make the copy constructor and copy-assignment operator declarations
    public in the gslice_array class template definition in 26.6.7 [template.gslice.array] </li>
<li> remove the note in paragraph 3 of 26.6.7 [template.gslice.array]</li>
<li> remove the copy constructor declaration from  [gslice.array.cons]</li>
<li> change paragraph 1 of  [gslice.array.cons] to read "This constructor is declared
    to be private.  This constructor need not be defined."</li>
<li> remove the first sentence of paragraph 1 of 26.6.7.1 [gslice.array.assign]</li>
<li> Change the first three words of the second sentence of paragraph 1 of
    26.6.7.1 [gslice.array.assign] to "These assignment operators have"</li>
</ul>

<p>mask_array:</p>
<ul>
<li> Make the copy constructor and copy-assignment operator declarations
    public in the mask_array class template definition in 26.6.8 [template.mask.array] </li>
<li> remove the note in paragraph 2 of 26.6.8 [template.mask.array]</li>
<li> remove the copy constructor declaration from  [mask.array.cons]</li>
<li> change paragraph 1 of  [mask.array.cons] to read "This constructor is declared
    to be private.  This constructor need not be defined."</li>
<li> remove the first sentence of paragraph 1 of 26.6.8.1 [mask.array.assign]</li>
<li> Change the first three words of the second sentence of paragraph 1 of
    26.6.8.1 [mask.array.assign] to "These assignment operators have"</li>
</ul>

<p>indirect_array:</p>
<ul>
<li>Make the copy constructor and copy-assignment operator declarations
    public in the indirect_array class definition in 26.6.9 [template.indirect.array]</li>
<li> remove the note in paragraph 2 of 26.6.9 [template.indirect.array]</li>
<li> remove the copy constructor declaration from  [indirect.array.cons]</li>
<li> change the descriptive text in  [indirect.array.cons] to read "This constructor is
    declared to be private.  This constructor need not be defined."</li>
<li> remove the first sentence of paragraph 1 of 26.6.9.1 [indirect.array.assign]</li>
<li> Change the first three words of the second sentence of paragraph 1 of
    26.6.9.1 [indirect.array.assign] to "These assignment operators have"</li>
</ul>
<p><i>[Proposed resolution was modified in Santa Cruz: explicitly make
copy constructor and copy assignment operators public, instead of
removing them.]</i></p>



<p><b>Rationale:</b></p>
<p>Keeping the valarray constructors private is untenable.  Merely
making valarray a friend of the helper classes isn't good enough,
because access to the copy constructor is checked in the user's
environment.</p>

<p>Making the assignment operator public is not strictly necessary to
solve this problem.  A majority of the LWG <i>(straw poll: 13-4)</i>
believed we should make the assignment operators public, in addition
to the copy constructors, for reasons of symmetry and user
expectation.</p>





<hr>
<h3><a name="254"></a>254. Exception types in clause 19 are constructed from <tt>std::string</tt></h3>
<p><b>Section:</b> 19.2 [std.exceptions], 27.5.2.1.1 [ios::failure] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Dave Abrahams <b>Opened:</b> 2000-08-01 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Many of the standard exception types which implementations are
required to throw are constructed with a const std::string&amp;
parameter. For example:
</p>

<pre>     19.1.5  Class out_of_range                          [lib.out.of.range]
     namespace std {
       class out_of_range : public logic_error {
       public:
         explicit out_of_range(const string&amp; what_arg);
       };
     }

   1 The class out_of_range defines the type of objects  thrown  as  excep-
     tions to report an argument value not in its expected range.

     out_of_range(const string&amp; what_arg);

     Effects:
       Constructs an object of class out_of_range.
     Postcondition:
       strcmp(what(), what_arg.c_str()) == 0.
</pre>

<p>
There are at least two problems with this:
</p>
<ol>
<li>A program which is low on memory may end up throwing
std::bad_alloc instead of out_of_range because memory runs out while
constructing the exception object.</li>
<li>An obvious implementation which stores a std::string data member
may end up invoking terminate() during exception unwinding because the
exception object allocates memory (or rather fails to) as it is being
copied.</li>
</ol>

<p>
There may be no cure for (1) other than changing the interface to
out_of_range, though one could reasonably argue that (1) is not a
defect. Personally I don't care that much if out-of-memory is reported
when I only have 20 bytes left, in the case when out_of_range would
have been reported. People who use exception-specifications might care
a lot, though.
</p>

<p>
There is a cure for (2), but it isn't completely obvious. I think a
note for implementors should be made in the standard. Avoiding
possible termination in this case shouldn't be left up to chance.  The
cure is to use a reference-counted "string" implementation
in the exception object. I am not necessarily referring to a
std::string here; any simple reference-counting scheme for a NTBS
would do.
</p>

<p><b>Further discussion, in email:</b></p>

<p>
...I'm not so concerned about (1). After all, a library implementation
can add const char* constructors as an extension, and users don't
<i>need</i> to avail themselves of the standard exceptions, though this is
a lame position to be forced into.  FWIW, std::exception and
std::bad_alloc don't require a temporary basic_string.
</p>

<p>
...I don't think the fixed-size buffer is a solution to the problem,
strictly speaking, because you can't satisfy the postcondition
<br>
    <tt>&nbsp;&nbsp;strcmp(what(), what_arg.c_str()) == 0</tt>
<br>
For all values of what_arg (i.e. very long values). That means that
the only truly conforming solution requires a dynamic allocation.
</p>

<p><b>Further discussion, from Redmond:</b></p>

<p>The most important progress we made at the Redmond meeting was
realizing that there are two separable issues here: the const
string&amp; constructor, and the copy constructor.  If a user writes
something like <tt>throw std::out_of_range("foo")</tt>, the const
string&amp; constructor is invoked before anything gets thrown.  The
copy constructor is potentially invoked during stack unwinding.</p>

<p>The copy constructor is a more serious problem, becuase failure
during stack unwinding invokes <tt>terminate</tt>.  The copy
constructor must be nothrow. <i>Curaao: Howard thinks this
requirement may already be present.</i></p>

<p>The fundamental problem is that it's difficult to get the nothrow
requirement to work well with the requirement that the exception
objects store a string of unbounded size, particularly if you also try
to make the const string&amp; constructor nothrow.  Options discussed
include:</p>

<ul>
<li>Limit the size of a string that exception objects are required to
throw: change the postconditions of 19.2.2 [domain.error] paragraph 3
and 19.2.6 [runtime.error] paragraph 3 to something like this:
"strncmp(what(), what_arg._str(), N) == 0, where N is an
implementation defined constant no smaller than 256".</li>
<li>Allow the const string&amp; constructor to throw, but not the
copy constructor.  It's the implementor's responsibility to get it
right.  (An implementor might use a simple refcount class.)</li>
<li>Compromise between the two: an implementation is not allowed to
throw if the string's length is less than some N, but, if it doesn't
throw, the string must compare equal to the argument.</li>
<li>Add a new constructor that takes a const char*</li>
</ul>

<p>(Not all of these options are mutually exclusive.)</p>



<p><b>Proposed resolution:</b></p>

<p>
Change 19.2.1 [logic.error]
</p>

<blockquote>
<pre>namespace std {
  class logic_error : public exception {
  public:
    explicit logic_error(const string&amp; <i>what_arg</i>);
    <ins>explicit logic_error(const char* <i>what_arg</i>);</ins>
  };
}
</pre>
<p>...</p>
<p>
<ins><tt>logic_error(const char* <i>what_arg</i>);</tt></ins>
</p>
<blockquote>
<p><ins>
-4- <i>Effects:</i> Constructs an object of class <tt>logic_error</tt>.
</ins></p>
<p><ins>
-5- <i>Postcondition:</i> <tt>strcmp(what(), <i>what_arg</i>) == 0</tt>.
</ins></p>
</blockquote>

</blockquote>

<p>
Change 19.2.2 [domain.error]
</p>

<blockquote>
<pre>namespace std {
  class domain_error : public logic_error {
  public:
    explicit domain_error(const string&amp; <i>what_arg</i>);
    <ins>explicit domain_error(const char* <i>what_arg</i>);</ins>
  };
}
</pre>
<p>...</p>
<p>
<ins><tt>domain_error(const char* <i>what_arg</i>);</tt></ins>
</p>
<blockquote>
<p><ins>
-4- <i>Effects:</i> Constructs an object of class <tt>domain_error</tt>.
</ins></p>
<p><ins>
-5- <i>Postcondition:</i> <tt>strcmp(what(), <i>what_arg</i>) == 0</tt>.
</ins></p>

</blockquote>
</blockquote>

<p>
Change 19.2.3 [invalid.argument]
</p>

<blockquote>
<pre>namespace std {
  class invalid_argument : public logic_error {
  public:
    explicit invalid_argument(const string&amp; <i>what_arg</i>);
    <ins>explicit invalid_argument(const char* <i>what_arg</i>);</ins>
  };
}
</pre>
<p>...</p>
<p>
<ins><tt>invalid_argument(const char* <i>what_arg</i>);</tt></ins>
</p>
<blockquote>
<p><ins>
-4- <i>Effects:</i> Constructs an object of class <tt>invalid_argument</tt>.
</ins></p>
<p><ins>
-5- <i>Postcondition:</i> <tt>strcmp(what(), <i>what_arg</i>) == 0</tt>.
</ins></p>
</blockquote>

</blockquote>

<p>
Change 19.2.4 [length.error]
</p>

<blockquote>
<pre>namespace std {
  class length_error : public logic_error {
  public:
    explicit length_error(const string&amp; <i>what_arg</i>);
    <ins>explicit length_error(const char* <i>what_arg</i>);</ins>
  };
}
</pre>
<p>...</p>
<p>
<ins><tt>length_error(const char* <i>what_arg</i>);</tt></ins>
</p>
<blockquote>
<p><ins>
-4- <i>Effects:</i> Constructs an object of class <tt>length_error</tt>.
</ins></p>
<p><ins>
-5- <i>Postcondition:</i> <tt>strcmp(what(), <i>what_arg</i>) == 0</tt>.
</ins></p>
</blockquote>

</blockquote>

<p>
Change 19.2.5 [out.of.range]
</p>

<blockquote>
<pre>namespace std {
  class out_of_range : public logic_error {
  public:
    explicit out_of_range(const string&amp; <i>what_arg</i>);
    <ins>explicit out_of_range(const char* <i>what_arg</i>);</ins>
  };
}
</pre>
<p>...</p>
<p>
<ins><tt>out_of_range(const char* <i>what_arg</i>);</tt></ins>
</p>
<blockquote>
<p><ins>
-4- <i>Effects:</i> Constructs an object of class <tt>out_of_range</tt>.
</ins></p>
<p><ins>
-5- <i>Postcondition:</i> <tt>strcmp(what(), <i>what_arg</i>) == 0</tt>.
</ins></p>
</blockquote>

</blockquote>

<p>
Change 19.2.6 [runtime.error]
</p>

<blockquote>
<pre>namespace std {
  class runtime_error : public exception {
  public:
    explicit runtime_error(const string&amp; <i>what_arg</i>);
    <ins>explicit runtime_error(const char* <i>what_arg</i>);</ins>
  };
}
</pre>
<p>...</p>
<p>
<ins><tt>runtime_error(const char* <i>what_arg</i>);</tt></ins>
</p>
<blockquote>
<p><ins>
-4- <i>Effects:</i> Constructs an object of class <tt>runtime_error</tt>.
</ins></p>
<p><ins>
-5- <i>Postcondition:</i> <tt>strcmp(what(), <i>what_arg</i>) == 0</tt>.
</ins></p>
</blockquote>

</blockquote>

<p>
Change 19.2.7 [range.error]
</p>

<blockquote>
<pre>namespace std {
  class range_error : public runtime_error {
  public:
    explicit range_error(const string&amp; <i>what_arg</i>);
    <ins>explicit range_error(const char* <i>what_arg</i>);</ins>
  };
}
</pre>
<p>...</p>
<p>
<ins><tt>range_error(const char* <i>what_arg</i>);</tt></ins>
</p>
<blockquote>
<p><ins>
-4- <i>Effects:</i> Constructs an object of class <tt>range_error</tt>.
</ins></p>
<p><ins>
-5- <i>Postcondition:</i> <tt>strcmp(what(), <i>what_arg</i>) == 0</tt>.
</ins></p>
</blockquote>

</blockquote>

<p>
Change 19.2.8 [overflow.error]
</p>

<blockquote>
<pre>namespace std {
  class overflow_error : public runtime_error {
  public:
    explicit overflow_error(const string&amp; <i>what_arg</i>);
    <ins>explicit overflow_error(const char* <i>what_arg</i>);</ins>
  };
}
</pre>
<p>...</p>
<p>
<ins><tt>overflow_error(const char* <i>what_arg</i>);</tt></ins>
</p>
<blockquote>
<p><ins>
-4- <i>Effects:</i> Constructs an object of class <tt>overflow_error</tt>.
</ins></p>
<p><ins>
-5- <i>Postcondition:</i> <tt>strcmp(what(), <i>what_arg</i>) == 0</tt>.
</ins></p>
</blockquote>

</blockquote>

<p>
Change 19.2.9 [underflow.error]
</p>

<blockquote>
<pre>namespace std {
  class underflow_error : public runtime_error {
  public:
    explicit underflow_error(const string&amp; <i>what_arg</i>);
    <ins>explicit underflow_error(const char* <i>what_arg</i>);</ins>
  };
}
</pre>
<p>...</p>
<p>
<ins><tt>underflow_error(const char* <i>what_arg</i>);</tt></ins>
</p>
<blockquote>
<p><ins>
-4- <i>Effects:</i> Constructs an object of class <tt>underflow_error</tt>.
</ins></p>
<p><ins>
-5- <i>Postcondition:</i> <tt>strcmp(what(), <i>what_arg</i>) == 0</tt>.
</ins></p>
</blockquote>

</blockquote>

<p>
Change 27.5.2.1.1 [ios::failure]
</p>

<blockquote>
<pre>namespace std {
  class ios_base::failure : public exception {
  public:
    explicit failure(const string&amp; <i>msg</i>);
    <ins>explicit failure(const char* <i>msg</i>);</ins>
    virtual const char* what() const throw();
};
}
</pre>
<p>...</p>
<p>
<ins><tt>failure(const char* <i>msg</i>);</tt></ins>
</p>
<blockquote>
<p><ins>
-4- <i>Effects:</i> Constructs an object of class <tt>failure</tt>.
</ins></p>
<p><ins>
-5- <i>Postcondition:</i> <tt>strcmp(what(), <i>msg</i>) == 0</tt>.
</ins></p>
</blockquote>

</blockquote>



<p><b>Rationale:</b></p>

<p>Throwing a bad_alloc while trying to construct a message for another
exception-derived class is not necessarily a bad thing.  And the
bad_alloc constructor already has a no throw spec on it (18.4.2.1).</p>

<p><b>Future:</b></p>

<p>All involved would like to see const char* constructors added, but
this should probably be done for C++0X as opposed to a DR.</p>

<p>I believe the no throw specs currently decorating these functions
could be improved by some kind of static no throw spec checking
mechanism (in a future C++ language).  As they stand, the copy
constructors might fail via a call to unexpected.  I think what is
intended here is that the copy constructors can't fail.</p>

<p><i>[Pre-Sydney: reopened at the request of Howard Hinnant.
  Post-Redmond: James Kanze noticed that the copy constructors of
  exception-derived classes do not have nothrow clauses.  Those
  classes have no copy constructors declared, meaning the
  compiler-generated implicit copy constructors are used, and those
  compiler-generated constructors might in principle throw anything.]</i></p>


<p><i>[
Batavia:  Merged copy constructor and assignment operator spec into <tt>exception</tt>
and added <tt>ios::failure</tt> into the proposed resolution.
]</i></p>


<p><i>[
Oxford:  The proposed resolution simply addresses the issue of constructing
the exception objects with <tt>const char*</tt> and string literals without
the need to explicit include or construct a <tt>std::string</tt>.
]</i></p>







<hr>
<h3><a name="256"></a>256. typo in 27.4.4.2, p17: copy_event does not exist</h3>
<p><b>Section:</b> 27.5.4.2 [basic.ios.members] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2000-08-21 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#basic.ios.members">issues</a> in [basic.ios.members].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
27.4.4.2, p17 says
</p>

<blockquote><p>
-17- Before copying any parts of rhs, calls each registered callback
pair (fn,index) as (*fn)(erase_event,*this,index). After all parts but
exceptions() have been replaced, calls each callback pair that was
copied from rhs as (*fn)(copy_event,*this,index). 
</p></blockquote>

<p>
The name copy_event isn't defined anywhere. The intended name was
copyfmt_event.
</p>


<p><b>Proposed resolution:</b></p>
<p>Replace copy_event with copyfmt_event in the named paragraph.</p>




<hr>
<h3><a name="258"></a>258. Missing allocator requirement</h3>
<p><b>Section:</b> 20.2.5 [allocator.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2000-08-22 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#allocator.requirements">issues</a> in [allocator.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
From lib-7752:
</p>

<p>
I've been assuming (and probably everyone else has been assuming) that
allocator instances have a particular property, and I don't think that
property can be deduced from anything in Table 32.
</p>

<p>
I think we have to assume that allocator type conversion is a
homomorphism.  That is, if x1 and x2 are of type X, where
X::value_type is T, and if type Y is X::template
rebind&lt;U&gt;::other, then Y(x1) == Y(x2) if and only if x1 == x2.
</p>

<p>
Further discussion: Howard Hinnant writes, in lib-7757:
</p>

<p>
I think I can prove that this is not provable by Table 32.  And I agree 
it needs to be true except for the "and only if".  If x1 != x2, I see no 
reason why it can't be true that Y(x1) == Y(x2).  Admittedly I can't 
think of a practical instance where this would happen, or be valuable.  
But I also don't see a need to add that extra restriction.  I think we 
only need:
</p>

<blockquote><p>
     if (x1 == x2) then Y(x1) == Y(x2)
</p></blockquote>

<p>
If we decide that == on allocators is transitive, then I think I can 
prove the above.  But I don't think == is necessarily transitive on 
allocators.  That is:
</p>

<p>
Given x1 == x2  and x2 == x3, this does not mean x1 == x3.
</p>

<p>Example:</p>

<blockquote>
<p>
x1 can deallocate pointers from:  x1, x2, x3    <br>
x2 can deallocate pointers from:  x1, x2, x4    <br>
x3 can deallocate pointers from:  x1, x3        <br>
x4 can deallocate pointers from:  x2, x4 
</p>

<p>
x1 == x2, and x2 == x4, but x1 != x4
</p>
</blockquote>
<p><i>[Toronto: LWG members offered multiple opinions.  One
opinion is that it should not be required that <tt>x1 == x2</tt>
implies <tt>Y(x1) == Y(x2)</tt>, and that it should not even be
required that <tt>X(x1) == x1</tt>.  Another opinion is that 
the second line from the bottom in table 32 already implies the
desired property.  This issue should be considered in light of
other issues related to allocator instances.]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
Accept proposed wording from
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2436.pdf">N2436</a> part 3.
</p>


<p><i>[Lillehammer: Same conclusion as before: this should be
  considered as part of an allocator redesign, not solved on its own.]</i></p>


<p><i>[
Batavia:  An allocator redesign is not forthcoming and thus we fixed this one issue.
]</i></p>


<p><i>[
Toronto:  Reopened at the request of the project editor (Pete) because the proposed
wording did not fit within the indicated table.  The intent of the resolution remains
unchanged.  Pablo to work with Pete on improved wording.
]</i></p>


<p><i>[
Kona (2007): The LWG adopted the proposed resolution of N2387 for this issue which
was subsequently split out into a separate paper N2436 for the purposes of voting.
The resolution in N2436 addresses this issue.  The LWG voted to accelerate this
issue to Ready status to be voted into the WP at Kona.
]</i></p>





<hr>
<h3><a name="259"></a>259. <tt>basic_string::operator[]</tt> and const correctness</h3>
<p><b>Section:</b> 21.4.4 [string.capacity] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Chris Newton  <b>Opened:</b> 2000-08-27 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#string.capacity">issues</a> in [string.capacity].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<i>Paraphrased from a message that Chris Newton posted to comp.std.c++:</i>
</p>

<p>
The standard's description of <tt>basic_string&lt;&gt;::operator[]</tt>
seems to violate const correctness.
</p>

<p>
The standard (21.3.4/1) says that "If <tt>pos &lt; size()</tt>,
returns <tt>data()[pos]</tt>." The types don't work.  The
return value of <tt>data()</tt> is <tt>const charT*</tt>, but
<tt>operator[]</tt> has a non-const version whose return type is <tt>reference</tt>.
</p>


<p><b>Proposed resolution:</b></p>
<p>
In section 21.3.4, paragraph 1, change
"<tt>data()[<i>pos</i>]</tt>" to "<tt>*(begin() +
<i>pos</i>)</tt>".
</p>




<hr>
<h3><a name="260"></a>260. Inconsistent return type of <tt>istream_iterator::operator++(int)</tt></h3>
<p><b>Section:</b> 24.6.1.2 [istream.iterator.ops] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2000-08-27 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#istream.iterator.ops">issues</a> in [istream.iterator.ops].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>The synopsis of istream_iterator::operator++(int) in 24.5.1 shows
it as returning the iterator by value. 24.5.1.2, p5 shows the same
operator as returning the iterator by reference. That's incorrect
given the Effects clause below (since a temporary is returned). The
`&amp;' is probably just a typo.</p>


<p><b>Proposed resolution:</b></p>
<p>Change the declaration in 24.5.1.2, p5 from</p>
 <pre> istream_iterator&lt;T,charT,traits,Distance&gt;&amp; operator++(int);
 </pre>
<p>to</p>
 <pre> istream_iterator&lt;T,charT,traits,Distance&gt; operator++(int);
 </pre>
<p>(that is, remove the `&amp;').</p>




<hr>
<h3><a name="261"></a>261. Missing description of <tt>istream_iterator::operator!=</tt></h3>
<p><b>Section:</b> 24.6.1.2 [istream.iterator.ops] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2000-08-27 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#istream.iterator.ops">issues</a> in [istream.iterator.ops].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
24.5.1, p3 lists the synopsis for
</p>

<pre>   template &lt;class T, class charT, class traits, class Distance&gt;
        bool operator!=(const istream_iterator&lt;T,charT,traits,Distance&gt;&amp; x,
                        const istream_iterator&lt;T,charT,traits,Distance&gt;&amp; y);
</pre>

<p>
but there is no description of what the operator does (i.e., no Effects
or Returns clause) in 24.5.1.2.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add paragraph 7 to the end of section 24.5.1.2 with the following text:
</p>

<pre>   template &lt;class T, class charT, class traits, class Distance&gt;
        bool operator!=(const istream_iterator&lt;T,charT,traits,Distance&gt;&amp; x,
                        const istream_iterator&lt;T,charT,traits,Distance&gt;&amp; y);
</pre>

<p>-7- Returns: !(x == y).</p>




<hr>
<h3><a name="262"></a>262. Bitmask operator ~ specified incorrectly</h3>
<p><b>Section:</b> 17.5.2.1.3 [bitmask.types] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Beman Dawes <b>Opened:</b> 2000-09-03 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#bitmask.types">issues</a> in [bitmask.types].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The ~ operation should be applied after the cast to int_type.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change 17.3.2.1.2 [lib.bitmask.types] operator~ from:
</p>

<pre>   bitmask operator~ ( bitmask X )
     { return static_cast&lt; bitmask&gt;(static_cast&lt;int_type&gt;(~ X)); }
</pre>

<p>
to:
</p>

<pre>   bitmask operator~ ( bitmask X )
     { return static_cast&lt; bitmask&gt;(~static_cast&lt;int_type&gt;(X)); }
</pre>




<hr>
<h3><a name="263"></a>263. Severe restriction on <tt>basic_string</tt> reference counting</h3>
<p><b>Section:</b> 21.4 [basic.string] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Kevlin Henney <b>Opened:</b> 2000-09-04 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#basic.string">issues</a> in [basic.string].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The note in paragraph 6 suggests that the invalidation rules for
references, pointers, and iterators in paragraph 5 permit a reference-
counted implementation (actually, according to paragraph 6, they permit
a "reference counted implementation", but this is a minor editorial fix).
</p>

<p>
However, the last sub-bullet is so worded as to make a reference-counted
implementation unviable. In the following example none of the
conditions for iterator invalidation are satisfied:
</p>

<pre>    // first example: "*******************" should be printed twice
    string original = "some arbitrary text", copy = original;
    const string &amp; alias = original;

    string::const_iterator i = alias.begin(), e = alias.end();
    for(string::iterator j = original.begin(); j != original.end(); ++j)
        *j = '*';
    while(i != e)
        cout &lt;&lt; *i++;
    cout &lt;&lt; endl;
    cout &lt;&lt; original &lt;&lt; endl;
</pre>

<p>
Similarly, in the following example:
</p>

<pre>    // second example: "some arbitrary text" should be printed out
    string original = "some arbitrary text", copy = original;
    const string &amp; alias = original;

    string::const_iterator i = alias.begin();
    original.begin();
    while(i != alias.end())
        cout &lt;&lt; *i++;
</pre>

<p>
I have tested this on three string implementations, two of which were
reference counted. The reference-counted implementations gave
"surprising behavior" because they invalidated iterators on
the first call to non-const begin since construction. The current
wording does not permit such invalidation because it does not take
into account the first call since construction, only the first call
since various member and non-member function calls.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change the following sentence in 21.3 paragraph 5 from
</p>

<blockquote><p>
    Subsequent to any of the above uses except the forms of insert() and
    erase() which return iterators, the first call to non-const member
    functions operator[](), at(), begin(), rbegin(), end(), or rend().
</p></blockquote>

<p>to</p>

<blockquote><p>
    Following construction or any of the above uses, except the forms of
    insert() and erase() that return iterators, the first call to non-
    const member functions operator[](), at(), begin(), rbegin(), end(),
    or rend().
</p></blockquote>




<hr>
<h3><a name="264"></a>264. Associative container <tt>insert(i, j)</tt> complexity requirements are not feasible.</h3>
<p><b>Section:</b> 23.2.4 [associative.reqmts] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> John Potter <b>Opened:</b> 2000-09-07 <b>Last modified:</b> 2010-10-29</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#associative.reqmts">active issues</a> in [associative.reqmts].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#associative.reqmts">issues</a> in [associative.reqmts].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#102">102</a></p>
<p><b>Discussion:</b></p>
<p>
Table 69 requires linear time if [i, j) is sorted.  Sorted is necessary but not sufficient.
Consider inserting a sorted range of even integers into a set&lt;int&gt; containing the odd
integers in the same range.
</p>

<p><i>Related issue: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#102">102</a></i></p>


<p><b>Proposed resolution:</b></p>
<p>
In Table 69, in section 23.1.2, change the complexity clause for
insertion of a range from "N log(size() + N) (N is the distance
from i to j) in general; linear if [i, j) is sorted according to
value_comp()" to "N log(size() + N), where N is the distance
from i to j".
</p>

<p><i>[Copenhagen: Minor fix in proposed resolution: fixed unbalanced
parens in the revised wording.]</i></p>




<p><b>Rationale:</b></p>
<p>
Testing for valid insertions could be less efficient than simply
inserting the elements when the range is not both sorted and between
two adjacent existing elements; this could be a QOI issue.
</p>

<p> 
The LWG considered two other options: (a) specifying that the
complexity was linear if [i, j) is sorted according to value_comp()
and between two adjacent existing elements; or (b) changing to
Klog(size() + N) + (N - K) (N is the distance from i to j and K is the
number of elements which do not insert immediately after the previous
element from [i, j) including the first).  The LWG felt that, since
we can't guarantee linear time complexity whenever the range to be
inserted is sorted, it's more trouble than it's worth to say that it's
linear in some special cases.
</p>




<hr>
<h3><a name="265"></a>265. std::pair::pair() effects overly restrictive</h3>
<p><b>Section:</b> 20.3.5 [pairs] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2000-09-11 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#pairs">issues</a> in [pairs].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I don't see any requirements on the types of the elements of the
std::pair container in 20.2.2. From the descriptions of the member
functions it appears that they must at least satisfy the requirements of
20.1.3 [lib.copyconstructible] and 20.1.4 [lib.default.con.req], and in
the case of the [in]equality operators also the requirements of 20.1.1
[lib.equalitycomparable] and 20.1.2 [lib.lessthancomparable].
</p>

<p>
I believe that the the CopyConstructible requirement is unnecessary in
the case of 20.2.2, p2.
</p>


<p><b>Proposed resolution:</b></p>
<p>Change the Effects clause in 20.2.2, p2 from</p>

<blockquote><p>
-2- <b>Effects</b>: Initializes its members as if implemented: <tt> pair() :
first(T1()), second(T2()) {} </tt>
</p></blockquote>

<p>to</p>

<blockquote><p>
-2- <b>Effects</b>: Initializes its members as if implemented: <tt> pair() :
first(), second() {} </tt>
</p></blockquote>


<p><b>Rationale:</b></p>
<p>The existing specification of pair's constructor appears to be a
historical artifact: there was concern that pair's members be properly
zero-initialized when they are built-in types.  At one time there was
uncertainty about whether they would be zero-initialized if the
default constructor was written the obvious way.  This has been
clarified by core issue 178, and there is no longer any doubt that
the straightforward implementation is correct.</p>




<hr>
<h3><a name="266"></a>266. bad_exception::~bad_exception() missing Effects clause</h3>
<p><b>Section:</b> 18.8.2 [bad.exception] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2000-09-24 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The synopsis for std::bad_exception lists the function ~bad_exception()
but there is no description of what the function does (the Effects
clause is missing).
</p>


<p><b>Proposed resolution:</b></p>
<p>
Remove the destructor from the class synopses of 
<tt>bad_alloc</tt> (18.6.2.1 [bad.alloc]),
<tt>bad_cast</tt> (18.7.2 [bad.cast]),
<tt>bad_typeid</tt> (18.7.3 [bad.typeid]),
and <tt>bad_exception</tt> (18.8.2 [bad.exception]).
</p>


<p><b>Rationale:</b></p>
<p>
This is a general problem with the exception classes in clause 18. 
The proposed resolution is to remove the destructors from the class
synopses, rather than to document the destructors' behavior, because
removing them is more consistent with how exception classes are
described in clause 19.
</p>




<hr>
<h3><a name="268"></a>268. Typo in locale synopsis</h3>
<p><b>Section:</b> 22.3.1 [locale] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2000-10-05 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale">issues</a> in [locale].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>The synopsis of the class std::locale in 22.1.1 contains two typos:
the semicolons after the declarations of the default ctor
locale::locale() and the copy ctor locale::locale(const locale&amp;)
are missing.</p>


<p><b>Proposed resolution:</b></p>
<p>Add the missing semicolons, i.e., change</p>

<pre>    //  construct/copy/destroy:
        locale() throw()
        locale(const locale&amp; other) throw()
</pre>

<p>in the synopsis in 22.1.1 to</p>

<pre>    //  construct/copy/destroy:
        locale() throw();
        locale(const locale&amp; other) throw();
</pre>




<hr>
<h3><a name="270"></a>270. Binary search requirements overly strict</h3>
<p><b>Section:</b> 25.4.3 [alg.binary.search] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2000-10-18 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.binary.search">issues</a> in [alg.binary.search].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#472">472</a></p>
<p><b>Discussion:</b></p>
<p>
Each of the four binary search algorithms (lower_bound, upper_bound,
equal_range, binary_search) has a form that allows the user to pass a
comparison function object.  According to 25.3, paragraph 2, that
comparison function object has to be a strict weak ordering.
</p>

<p>
This requirement is slightly too strict.  Suppose we are searching
through a sequence containing objects of type X, where X is some
large record with an integer key.  We might reasonably want to look
up a record by key, in which case we would want to write something
like this:
</p>
<pre>    struct key_comp {
      bool operator()(const X&amp; x, int n) const {
        return x.key() &lt; n;
      }
    }

    std::lower_bound(first, last, 47, key_comp());
</pre>

<p>
key_comp is not a strict weak ordering, but there is no reason to
prohibit its use in lower_bound.
</p>

<p>
There's no difficulty in implementing lower_bound so that it allows
the use of something like key_comp.  (It will probably work unless an
implementor takes special pains to forbid it.)  What's difficult is
formulating language in the standard to specify what kind of
comparison function is acceptable.  We need a notion that's slightly
more general than that of a strict weak ordering, one that can encompass
a comparison function that involves different types.  Expressing that
notion may be complicated.
</p>

<p><i>Additional questions raised at the Toronto meeting:</i></p>
<ul>
<li> Do we really want to specify what ordering the implementor must
     use when calling the function object?  The standard gives 
     specific expressions when describing these algorithms, but it also
     says that other expressions (with different argument order) are
     equivalent.</li>
<li> If we are specifying ordering, note that the standard uses both
     orderings when describing <tt>equal_range</tt>.</li>
<li> Are we talking about requiring these algorithms to work properly
     when passed a binary function object whose two argument types
     are not the same, or are we talking about requirements when
     they are passed a binary function object with several overloaded
     versions of <tt>operator()</tt>?</li>
<li> The definition of a strict weak ordering does not appear to give
     any guidance on issues of overloading; it only discusses expressions,
     and all of the values in these expressions are of the same type.
     Some clarification would seem to be in order.</li>
</ul>

<p><i>Additional discussion from Copenhagen:</i></p>
<ul>
<li>It was generally agreed that there is a real defect here: if
the predicate is merely required to be a Strict Weak Ordering, then
it's possible to pass in a function object with an overloaded
operator(), where the version that's actually called does something
completely inappropriate.  (Such as returning a random value.)</li>

<li>An alternative formulation was presented in a paper distributed by
David Abrahams at the meeting, "Binary Search with Heterogeneous
Comparison", J16-01/0027 = WG21 N1313: Instead of viewing the
predicate as a Strict Weak Ordering acting on a sorted sequence, view
the predicate/value pair as something that partitions a sequence.
This is almost equivalent to saying that we should view binary search
as if we are given a unary predicate and a sequence, such that f(*p)
is true for all p below a specific point and false for all p above it.
The proposed resolution is based on that alternative formulation.</li>
</ul>


<p><b>Proposed resolution:</b></p>

<p>Change 25.3 [lib.alg.sorting] paragraph 3 from:</p>

<blockquote><p>
  3 For all algorithms that take Compare, there is a version that uses
  operator&lt; instead. That is, comp(*i, *j) != false defaults to *i &lt;
  *j != false. For the algorithms to work correctly, comp has to
  induce a strict weak ordering on the values.
</p></blockquote>

<p>to:</p>

<blockquote><p>
  3 For all algorithms that take Compare, there is a version that uses
  operator&lt; instead. That is, comp(*i, *j) != false defaults to *i
  &lt; *j != false. For algorithms other than those described in
  lib.alg.binary.search (25.3.3) to work correctly, comp has to induce
  a strict weak ordering on the values.
</p></blockquote>

<p>Add the following paragraph after 25.3 [lib.alg.sorting] paragraph 5:</p>

<blockquote><p>
  -6- A sequence [start, finish) is partitioned with respect to an
  expression f(e) if there exists an integer n such that
  for all 0 &lt;= i &lt; distance(start, finish), f(*(begin+i)) is true if
  and only if i &lt; n.
</p></blockquote>

<p>Change 25.3.3 [lib.alg.binary.search] paragraph 1 from:</p>

<blockquote><p>
  -1- All of the algorithms in this section are versions of binary
   search and assume that the sequence being searched is in order
   according to the implied or explicit comparison function. They work
   on non-random access iterators minimizing the number of
   comparisons, which will be logarithmic for all types of
   iterators. They are especially appropriate for random access
   iterators, because these algorithms do a logarithmic number of
   steps through the data structure. For non-random access iterators
   they execute a linear number of steps.
</p></blockquote>

<p>to:</p>

<blockquote><p>
   -1- All of the algorithms in this section are versions of binary
    search and assume that the sequence being searched is partitioned
    with respect to an expression formed by binding the search key to
    an argument of the implied or explicit comparison function. They
    work on non-random access iterators minimizing the number of
    comparisons, which will be logarithmic for all types of
    iterators. They are especially appropriate for random access
    iterators, because these algorithms do a logarithmic number of
    steps through the data structure. For non-random access iterators
    they execute a linear number of steps.
</p></blockquote>

<p>Change 25.3.3.1 [lib.lower.bound] paragraph 1 from:</p>

<blockquote><p>
   -1- Requires: Type T is LessThanComparable
    (lib.lessthancomparable). 
</p></blockquote>

<p>to:</p>

<blockquote><p>
   -1- Requires: The elements e of [first, last) are partitioned with
   respect to the expression e &lt; value or comp(e, value)
</p></blockquote>


<p>Remove 25.3.3.1 [lib.lower.bound] paragraph 2:</p>

<blockquote><p>
   -2- Effects: Finds the first position into which value can be
    inserted without violating the ordering. 
</p></blockquote>

<p>Change 25.3.3.2 [lib.upper.bound] paragraph 1 from:</p>

<blockquote><p>
  -1- Requires: Type T is LessThanComparable (lib.lessthancomparable).
</p></blockquote>

<p>to:</p>

<blockquote><p>
   -1- Requires: The elements e of [first, last) are partitioned with
   respect to the expression !(value &lt; e) or !comp(value, e)
</p></blockquote>

<p>Remove 25.3.3.2 [lib.upper.bound] paragraph 2:</p>

<blockquote><p>
   -2- Effects: Finds the furthermost position into which value can be
    inserted without violating the ordering.
</p></blockquote>

<p>Change 25.3.3.3 [lib.equal.range] paragraph 1 from:</p>

<blockquote><p>
   -1- Requires: Type T is LessThanComparable
    (lib.lessthancomparable).
</p></blockquote>

<p>to:</p>

<blockquote><p>
   -1- Requires: The elements e of [first, last) are partitioned with
   respect to the expressions e &lt; value and !(value &lt; e) or
   comp(e, value) and !comp(value, e).  Also, for all elements e of
   [first, last), e &lt; value implies !(value &lt; e) or comp(e,
   value) implies !comp(value, e)
</p></blockquote>

<p>Change 25.3.3.3 [lib.equal.range] paragraph 2 from:</p>

<blockquote><p>
   -2- Effects: Finds the largest subrange [i, j) such that the value
    can be inserted at any iterator k in it without violating the
    ordering. k satisfies the corresponding conditions: !(*k &lt; value)
    &amp;&amp; !(value &lt; *k) or comp(*k, value) == false &amp;&amp; comp(value, *k) ==
    false.
</p></blockquote>

<p>to:</p>

<pre>   -2- Returns: 
         make_pair(lower_bound(first, last, value),
                   upper_bound(first, last, value))
       or
         make_pair(lower_bound(first, last, value, comp),
                   upper_bound(first, last, value, comp))
</pre>

<p>Change 25.3.3.3 [lib.binary.search] paragraph 1 from:</p>

<blockquote><p>
   -1- Requires: Type T is LessThanComparable
    (lib.lessthancomparable).
</p></blockquote>

<p>to:</p>

<blockquote><p>
   -1- Requires: The elements e of [first, last) are partitioned with
   respect to the expressions e &lt; value and !(value &lt; e) or comp(e,
   value) and !comp(value, e). Also, for all elements e of [first,
   last), e &lt; value implies !(value &lt; e) or comp(e, value) implies
   !comp(value, e)
</p></blockquote>

<p><i>[Copenhagen: Dave Abrahams provided this wording]</i></p>


<p><i>[Redmond: Minor changes in wording.  (Removed "non-negative", and
changed the "other than those described in" wording.) Also, the LWG
decided to accept the "optional" part.]</i></p>




<p><b>Rationale:</b></p>
<p>The proposed resolution reinterprets binary search. Instead of
thinking about searching for a value in a sorted range, we view that
as an important special case of a more general algorithm: searching
for the partition point in a partitioned range.</p>

<p>We also add a guarantee that the old wording did not: we ensure
that the upper bound is no earlier than the lower bound, that
the pair returned by equal_range is a valid range, and that the first
part of that pair is the lower bound.</p>





<hr>
<h3><a name="271"></a>271. basic_iostream missing typedefs</h3>
<p><b>Section:</b> 27.7.1.5 [iostreamclass] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2000-11-02 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Class template basic_iostream has no typedefs.  The typedefs it
inherits from its base classes can't be used, since (for example)
basic_iostream&lt;T&gt;::traits_type is ambiguous.
</p>


<p><b>Proposed resolution:</b></p>

<p>Add the following to basic_iostream's class synopsis in 
27.7.1.5 [iostreamclass], immediately after <tt>public</tt>:</p>

<pre>  // types:
  typedef charT                     char_type;
  typedef typename traits::int_type int_type;
  typedef typename traits::pos_type pos_type;
  typedef typename traits::off_type off_type;
  typedef traits                    traits_type;
</pre>




<hr>
<h3><a name="272"></a>272. Missing parentheses around subexpression</h3>
<p><b>Section:</b> 27.5.4.3 [iostate.flags] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2000-11-02 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#iostate.flags">issues</a> in [iostate.flags].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#569">569</a></p>
<p><b>Discussion:</b></p>
<p>
27.4.4.3, p4 says about the postcondition of the function: If
rdbuf()!=0 then state == rdstate(); otherwise
rdstate()==state|ios_base::badbit.
</p>

<p>
The expression on the right-hand-side of the operator==() needs to be
parenthesized in order for the whole expression to ever evaluate to
anything but non-zero.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add parentheses like so: rdstate()==(state|ios_base::badbit).
</p>




<hr>
<h3><a name="273"></a>273. Missing ios_base qualification on members of a dependent class</h3>
<p><b>Section:</b> 27 [input.output] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2000-11-02 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#input.output">issues</a> in [input.output].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>27.5.2.4.2, p4, and 27.8.1.6, p2, 27.8.1.7, p3, 27.8.1.9, p2,
27.8.1.10, p3 refer to in and/or out w/o ios_base:: qualification.
That's incorrect since the names are members of a dependent base
class (14.6.2 [temp.dep]) and thus not visible.</p>


<p><b>Proposed resolution:</b></p>
<p>Qualify the names with the name of the class of which they are
members, i.e., ios_base.</p>




<hr>
<h3><a name="274"></a>274. a missing/impossible allocator requirement</h3>
<p><b>Section:</b> 20.2.5 [allocator.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2000-11-02 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#allocator.requirements">issues</a> in [allocator.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I see that table 31 in 20.1.5, p3 allows T in std::allocator&lt;T&gt; to be of
any type. But the synopsis in 20.4.1 calls for allocator&lt;&gt;::address() to
be overloaded on reference and const_reference, which is ill-formed for
all T = const U. In other words, this won't work:
</p>

<p>
template class std::allocator&lt;const int&gt;;
</p>

<p>
The obvious solution is to disallow specializations of allocators on
const types. However, while containers' elements are required to be
assignable (which rules out specializations on const T's), I think that
allocators might perhaps be potentially useful for const values in other
contexts. So if allocators are to allow const types a partial
specialization of std::allocator&lt;const T&gt; would probably have to be
provided.
</p>


<p><b>Proposed resolution:</b></p>
<p>Change the text in row 1, column 2 of table 32 in 20.1.5, p3 from</p>

    <blockquote><p>
    any type
    </p></blockquote>

<p>to</p>
    <blockquote><p>
    any non-const, non-reference type
    </p></blockquote>

<p><i>[Redmond: previous proposed resolution was "any non-const,
non-volatile, non-reference type".  Got rid of the "non-volatile".]</i></p>




<p><b>Rationale:</b></p>
<p>
Two resolutions were originally proposed: one that partially
specialized std::allocator for const types, and one that said an
allocator's value type may not be const.  The LWG chose the second.
The first wouldn't be appropriate, because allocators are intended for
use by containers, and const value types don't work in containers.
Encouraging the use of allocators with const value types would only
lead to unsafe code.
</p>
<p>
The original text for proposed resolution 2 was modified so that it
also forbids volatile types and reference types.
</p>

<p><i>[Curaao: LWG double checked and believes volatile is correctly
excluded from the PR.]</i></p>







<hr>
<h3><a name="275"></a>275. Wrong type in num_get::get() overloads</h3>
<p><b>Section:</b> 22.4.2.1.1 [facet.num.get.members] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2000-11-02 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#facet.num.get.members">issues</a> in [facet.num.get.members].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 22.2.2.1.1, we have a list of overloads for num_get&lt;&gt;::get().
There are eight overloads, all of which are identical except for the
last parameter.  The overloads are: 
</p>
<ul>
<li> long&amp; </li>
<li> unsigned short&amp; </li>
<li> unsigned int&amp; </li>
<li> unsigned long&amp; </li>
<li> short&amp; </li>
<li> double&amp; </li>
<li> long double&amp; </li>
<li> void*&amp; </li>
</ul>

<p>
There is a similar list, in 22.2.2.1.2, of overloads for
num_get&lt;&gt;::do_get().  In this list, the last parameter has
the types: 
</p>
<ul>
<li> long&amp; </li>
<li> unsigned short&amp; </li>
<li> unsigned int&amp; </li>
<li> unsigned long&amp; </li>
<li> float&amp; </li>
<li> double&amp; </li>
<li> long double&amp; </li>
<li> void*&amp; </li>
</ul>

<p>
These two lists are not identical.  They should be, since
<tt>get</tt> is supposed to call <tt>do_get</tt> with exactly
the arguments it was given.
</p>


<p><b>Proposed resolution:</b></p>
<p>In 22.4.2.1.1 [facet.num.get.members], change</p>
<pre>  iter_type get(iter_type in, iter_type end, ios_base&amp; str,
                ios_base::iostate&amp; err, short&amp; val) const;
</pre>
<p>to</p>
<pre>  iter_type get(iter_type in, iter_type end, ios_base&amp; str,
                ios_base::iostate&amp; err, float&amp; val) const;
</pre>




<hr>
<h3><a name="276"></a>276. Assignable requirement for container value type overly strict</h3>
<p><b>Section:</b> 23.2 [container.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Peter Dimov <b>Opened:</b> 2000-11-07 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#container.requirements">issues</a> in [container.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
23.1/3 states that the objects stored in a container must be
Assignable.  23.6.1 [map], paragraph 2,
states that map satisfies all requirements for a container, while in
the same time defining value_type as pair&lt;const Key, T&gt; - a type
that is not Assignable.
</p>

<p>
It should be noted that there exists a valid and non-contradictory
interpretation of the current text. The wording in 23.1/3 avoids 
mentioning value_type, referring instead to "objects stored in a
container." One might argue that map does not store objects of
type map::value_type, but of map::mapped_type instead, and that the
Assignable requirement applies to map::mapped_type, not
map::value_type.
</p>

<p>
However, this makes map a special case (other containers store objects of
type value_type) and the Assignable requirement is needlessly restrictive in
general.
</p>

<p>
For example, the proposed resolution of active library issue 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#103">103</a> is to make set::iterator a constant iterator; this
means that no set operations can exploit the fact that the stored
objects are Assignable.
</p>

<p>
This is related to, but slightly broader than, closed issue
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#140">140</a>.
</p>


<p><b>Proposed resolution:</b></p>
<p>23.1/3: Strike the trailing part of the sentence:</p>
    <blockquote><p>
    , and the additional requirements of Assignable types from 23.1/3
    </p></blockquote>
<p>so that it reads:</p>
    <blockquote><p>
    -3- The type of objects stored in these components must meet the 
    requirements of CopyConstructible types (lib.copyconstructible).
    </p></blockquote>

<p>23.1/4: Modify to make clear that this requirement is not for all 
containers.  Change to:</p>

<blockquote><p>
-4- Table 64 defines the Assignable requirement.  Some containers 
require this property of the types to be stored in the container.  T is 
the type used to instantiate the container. t is a value of T, and u is 
a value of (possibly const) T.
</p></blockquote>

<p>23.1, Table 65: in the first row, change "T is Assignable" to "T is
CopyConstructible".</p>

<p>23.2.1/2: Add sentence for Assignable requirement.  Change to:</p>

<blockquote><p>
-2- A deque satisfies all of the requirements of a container and of a 
reversible container (given in tables in lib.container.requirements) and 
of a sequence, including the optional sequence requirements 
(lib.sequence.reqmts).  In addition to the requirements on the stored 
object described in 23.1[lib.container.requirements], the stored object 
must also meet the requirements of Assignable.  Descriptions are 
provided here only for operations on deque that are not described in one 
of these tables or for operations where there is additional semantic 
information.
</p></blockquote>

<p>23.2.2/2:  Add Assignable requirement to specific methods of list.  
Change to:</p>

<blockquote>
<p>-2- A list satisfies all of the requirements of a container and of a 
reversible container (given in two tables in lib.container.requirements) 
and of a sequence, including most of the the optional sequence 
requirements (lib.sequence.reqmts). The exceptions are the operator[] 
and at member functions, which are not provided. 

[Footnote: These member functions are only provided by containers whose 
iterators are random access iterators. --- end foonote]
</p>

<p>list does not require the stored type T to be Assignable unless the 
following methods are instantiated:

[Footnote: Implementors are permitted but not required to take advantage 
of T's Assignable properties for these methods. -- end foonote]
</p>
<pre>     list&lt;T,Allocator&gt;&amp; operator=(const list&lt;T,Allocator&gt;&amp;  x );
     template &lt;class InputIterator&gt;
       void assign(InputIterator first, InputIterator last);
     void assign(size_type n, const T&amp; t);
</pre>


<p>Descriptions are provided here only for operations on list that are not 
described in one of these tables or for operations where there is 
additional semantic information.</p>
</blockquote>

<p>23.2.4/2:   Add sentence for Assignable requirement.  Change to:</p>

<blockquote><p>
-2- A vector satisfies all of the requirements of a container and of a 
reversible container (given in two tables in lib.container.requirements) 
and of a sequence, including most of the optional sequence requirements 
(lib.sequence.reqmts). The exceptions are the push_front and pop_front 
member functions, which are not provided.  In addition to the 
requirements on the stored object described in 
23.1[lib.container.requirements], the stored object must also meet the 
requirements of Assignable.  Descriptions are provided here only for 
operations on vector that are not described in one of these tables or 
for operations where there is additional semantic information.
</p></blockquote>


<p><b>Rationale:</b></p>
<p>list, set, multiset, map, multimap are able to store non-Assignables.
However, there is some concern about <tt>list&lt;T&gt;</tt>:
although in general there's no reason for T to be Assignable, some
implementations of the member functions <tt>operator=</tt> and
<tt>assign</tt> do rely on that requirement.  The LWG does not want
to forbid such implementations.</p>

<p>Note that the type stored in a standard container must still satisfy
the requirements of the container's allocator; this rules out, for
example, such types as "const int".  See issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#274">274</a>
for more details.
</p>

<p>In principle we could also relax the "Assignable" requirement for
individual <tt>vector</tt> member functions, such as
<tt>push_back</tt>.  However, the LWG did not see great value in such
selective relaxation.  Doing so would remove implementors' freedom to
implement <tt>vector::push_back</tt> in terms of
<tt>vector::insert</tt>.</p>





<hr>
<h3><a name="278"></a>278. What does iterator validity mean?</h3>
<p><b>Section:</b> 23.3.4.4 [list.ops] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> P.J. Plauger <b>Opened:</b> 2000-11-27 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#list.ops">issues</a> in [list.ops].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Section 23.3.4.4 [list.ops] states that
</p>
<pre>  void splice(iterator position, list&lt;T, Allocator&gt;&amp; x);
</pre>
<p>
<i>invalidates</i> all iterators and references to list <tt>x</tt>.
</p>

<p>
But what does the C++ Standard mean by "invalidate"?  You
can still dereference the iterator to a spliced list element, but
you'd better not use it to delimit a range within the original
list. For the latter operation, it has definitely lost some of its
validity.
</p>

<p>
If we accept the proposed resolution to issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#250">250</a>,
then we'd better clarify that a "valid" iterator need no
longer designate an element within the same container as it once did.
We then have to clarify what we mean by invalidating a past-the-end
iterator, as when a vector or string grows by reallocation. Clearly,
such an iterator has a different kind of validity. Perhaps we should
introduce separate terms for the two kinds of "validity."
</p>


<p><b>Proposed resolution:</b></p>
<p>Add the following text to the end of section X [iterator.concepts],
after paragraph 5:</p>
<blockquote><p>
An <i>invalid</i> iterator is an iterator that may be
singular. [Footnote: This definition applies to pointers, since
pointers are iterators. The effect of dereferencing an iterator that
has been invalidated is undefined.]
</p></blockquote>

<p><i>[post-Copenhagen: Matt provided wording.]</i></p>


<p><i>[Redmond: General agreement with the intent, some objections to
the wording.  Dave provided new wording.]</i></p>



<p><b>Rationale:</b></p>
<p>This resolution simply defines a term that the Standard uses but
  never defines, "invalid", in terms of a term that is defined,
  "singular".</p>

<p>Why do we say "may be singular", instead of "is singular"?  That's
  becuase a valid iterator is one that is known to be nonsingular.
  Invalidating an iterator means changing it in such a way that it's
  no longer known to be nonsingular.  An example: inserting an
  element into the middle of a vector is correctly said to invalidate
  all iterators pointing into the vector.  That doesn't necessarily
  mean they all become singular.</p>





<hr>
<h3><a name="280"></a>280. Comparison of reverse_iterator to const reverse_iterator</h3>
<p><b>Section:</b> 24.5.1 [reverse.iterators] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Steve Cleary <b>Opened:</b> 2000-11-27 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
This came from an email from Steve Cleary to Fergus in reference to
issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#179">179</a>. The library working group briefly discussed
this in Toronto and believed it should be a separate issue.  There was
also some reservations about whether this was a worthwhile problem to
fix.
</p>

<p>
Steve said: "Fixing reverse_iterator. std::reverse_iterator can
(and should) be changed to preserve these additional
requirements." He also said in email that it can be done without
breaking user's code: "If you take a look at my suggested
solution, reverse_iterator doesn't have to take two parameters; there
is no danger of breaking existing code, except someone taking the
address of one of the reverse_iterator global operator functions, and
I have to doubt if anyone has ever done that. . .  <i>But</i>, just in
case they have, you can leave the old global functions in as well --
they won't interfere with the two-template-argument functions.  With
that, I don't see how <i>any</i> user code could break."
</p>


<p><b>Proposed resolution:</b></p>
<p>
<b>Section:</b> 24.5.1.1 [reverse.iterator]
add/change the following declarations:</p>
<pre>  A) Add a templated assignment operator, after the same manner
        as the templated copy constructor, i.e.:

  template &lt; class U &gt;
  reverse_iterator &lt; Iterator &gt;&amp; operator=(const reverse_iterator&lt; U &gt;&amp; u);

  B) Make all global functions (except the operator+) have
  two template parameters instead of one, that is, for
  operator ==, !=, &lt;, &gt;, &lt;=, &gt;=, - replace:

       template &lt; class Iterator &gt;
       typename reverse_iterator&lt; Iterator &gt;::difference_type operator-(
                 const reverse_iterator&lt; Iterator &gt;&amp; x,
                 const reverse_iterator&lt; Iterator &gt;&amp; y);

  with:

      template &lt; class Iterator1, class Iterator2 &gt;
      typename reverse_iterator &lt; Iterator1 &gt;::difference_type operator-(
                 const reverse_iterator &lt; Iterator1 &gt; &amp; x,
                 const reverse_iterator &lt; Iterator2 &gt; &amp; y);
</pre>
<p>
Also make the addition/changes for these signatures in 
24.5.1.3 [reverse.iter.ops].
</p>

<p><i>[
Copenhagen: The LWG is concerned that the proposed resolution 
introduces new overloads.  Experience shows that introducing
overloads is always risky, and that it would be inappropriate to
make this change without implementation experience.  It may be
desirable to provide this feature in a different way.
]</i></p>


<p><i>[
Lillehammer: We now have implementation experience, and agree that
this solution is safe and correct.
]</i></p>







<hr>
<h3><a name="281"></a>281. std::min() and max() requirements overly restrictive</h3>
<p><b>Section:</b> 25.4.7 [alg.min.max] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2000-12-02 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.min.max">issues</a> in [alg.min.max].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#486">486</a></p>
<p><b>Discussion:</b></p>
<p>The requirements in 25.3.7, p1 and 4 call for T to satisfy the
requirements of <tt>LessThanComparable</tt> ( [lessthancomparable])
and <tt>CopyConstructible</tt> (20.2.1 [utility.arg.requirements]).
Since the functions take and return their arguments and result by
const reference, I believe the <tt>CopyConstructible</tt> requirement
is unnecessary.
</p>


<p><b>Proposed resolution:</b></p>
<p>Remove the <tt>CopyConstructible</tt> requirement. Specifically, replace
25.3.7, p1 with</p>
<p><b>-1- Requires:</b> Type T is <tt>LessThanComparable</tt> 
( [lessthancomparable]).
</p>
<p>and replace 25.3.7, p4 with</p>
<p><b>-4- Requires:</b> Type T is <tt>LessThanComparable</tt> 
( [lessthancomparable]).
</p>




<hr>
<h3><a name="282"></a>282. What types does numpunct grouping refer to?</h3>
<p><b>Section:</b> 22.4.2.2.2 [facet.num.put.virtuals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2000-12-05 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#facet.num.put.virtuals">issues</a> in [facet.num.put.virtuals].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Paragraph 16 mistakenly singles out integral types for inserting 
thousands_sep() characters.  This conflicts with the syntax for floating 
point numbers described under 22.2.3.1/2.
</p>


<p><b>Proposed resolution:</b></p>
<p>Change paragraph 16 from:</p>

<blockquote><p>
For integral types, punct.thousands_sep() characters are inserted into 
the sequence as determined by the value returned by punct.do_grouping() 
using the method described in 22.4.3.1.2 [facet.numpunct.virtuals].
</p></blockquote>

<p>To:</p>

<blockquote><p>
For arithmetic types, punct.thousands_sep() characters are inserted into 
the sequence as determined by the value returned by punct.do_grouping() 
using the method described in 22.4.3.1.2 [facet.numpunct.virtuals].
</p></blockquote>

<p><i>[
Copenhagen: Opinions were divided about whether this is actually an
inconsistency, but at best it seems to have been unintentional.  This
is only an issue for floating-point output: The standard is
unambiguous that implementations must parse thousands_sep characters
when performing floating-point.  The standard is also unambiguous that
this requirement does not apply to the "C" locale.
]</i></p>


<p><i>[
A survey of existing practice is needed; it is believed that some
implementations do insert thousands_sep characters for floating-point
output and others fail to insert thousands_sep characters for 
floating-point input even though this is unambiguously required by the
standard.
]</i></p>


<p><i>[Post-Curaao: the above proposed resolution is the consensus of
Howard, Bill, Pete, Benjamin, Nathan, Dietmar, Boris, and Martin.]</i></p>






<hr>
<h3><a name="283"></a>283. std::replace() requirement incorrect/insufficient</h3>
<p><b>Section:</b> 25.3.5 [alg.replace] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2000-12-15 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.replace">issues</a> in [alg.replace].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#483">483</a></p>
<p><b>Discussion:</b></p>
<p>
(revision of the further discussion)
There are a number of problems with the requires clauses for the
algorithms in 25.1 and 25.2. The requires clause of each algorithm
should describe the necessary and sufficient requirements on the inputs
to the algorithm such that the algorithm compiles and runs properly.
Many of the requires clauses fail to do this. Here is a summary of the kinds
of mistakes:
</p>

<ol>
<li>
Use of EqualityComparable, which only puts requirements on a single
type, when in fact an equality operator is required between two
different types, typically either T and the iterator's value type
or between the value types of two different iterators.
</li>
<li>
Use of Assignable for T when in fact what was needed is Assignable
for the value_type of the iterator, and convertability from T to the
value_type of the iterator. Or for output iterators, the requirement
should be that T is writable to the iterator (output iterators do
not have value types).
</li>
</ol>

<p>
Here is the list of algorithms that contain mistakes:
</p>

<ul>
<li>25.1.2 std::find</li>
<li>25.1.6 std::count</li>
<li>25.1.8 std::equal</li>
<li>25.1.9 std::search, std::search_n</li>
<li>25.2.4 std::replace, std::replace_copy</li>
<li>25.2.5 std::fill</li>
<li>25.2.7 std::remove, std::remove_copy</li>
</ul>

<p>
Also, in the requirements for EqualityComparable, the requirement that
the operator be defined for const objects is lacking.
</p>



<p><b>Proposed resolution:</b></p>

<p>20.1.1 Change p1 from</p>

<p>In Table 28, <tt>T</tt> is a type to be supplied by a C++ program
instantiating a template, <tt>a</tt>, <tt>b</tt>, and <tt>c</tt> are
values of type <tt>T</tt>.
</p>

<p>to</p>

<p>
In Table 28, <tt>T</tt> is a type to be supplied by a C++ program
instantiating a template, <tt>a</tt>, <tt>b</tt>, and <tt>c</tt> are
values of type <tt>const T</tt>.
</p>

<p>25 Between p8 and p9</p>

<p>Add the following sentence:</p>

<p>When the description of an algorithm gives an expression such as
<tt>*first == value</tt> for a condition, it is required that the expression
evaluate to either true or false in boolean contexts.</p>

<p>25.1.2 Change p1 by deleting the requires clause.</p>

<p>25.1.6 Change p1 by deleting the requires clause.</p>

<p>25.1.9</p>

<p>Change p4 from</p>

<p>-4- Requires: Type <tt>T</tt> is <tt>EqualityComparable</tt>
(20.1.1), type Size is convertible to integral type (4.7.12.3).
</p>

<p>to</p>

<p>-4- Requires: The type <tt>Size</tt> is convertible to integral
type (4.7.12.3).</p>

<p>25.2.4 Change p1 from</p>

<p>-1- Requires: Type <tt>T</tt> is <tt>Assignable</tt> (23.1 ) (and, for <tt>replace()</tt>, <tt>EqualityComparable</tt> (20.1.1 )).</p>

<p>to</p>

<p>-1- Requires: The expression <tt>*first = new_value</tt> must be valid.</p>

<p>and change p4 from</p>

<p>-4- Requires: Type <tt>T</tt> is <tt>Assignable</tt> (23.1) (and,
for <tt>replace_copy()</tt>, <tt>EqualityComparable</tt>
(20.1.1)). The ranges <tt>[first, last)</tt> and <tt>[result, result +
(last - first))</tt> shall not overlap.</p>

<p>to</p>

<p>-4- Requires: The results of the expressions <tt>*first</tt> and
<tt>new_value</tt> must be writable to the result output iterator. The
ranges <tt>[first, last)</tt> and <tt>[result, result + (last -
first))</tt> shall not overlap.</p>


<p>25.2.5 Change p1 from</p>

<p>-1- Requires: Type <tt>T</tt> is <tt>Assignable</tt> (23.1). The
type <tt>Size</tt> is convertible to an integral type (4.7.12.3).</p>

<p>to</p>

<p>-1- Requires: The expression <tt>value</tt> must be is writable to
the output iterator. The type <tt>Size</tt> is convertible to an
integral type (4.7.12.3).</p>

<p>25.2.7 Change p1 from</p>

<p>-1- Requires: Type <tt>T</tt> is <tt>EqualityComparable</tt> (20.1.1).</p>

<p>to</p>

<p>
-1- Requires: The value type of the iterator must be
<tt>Assignable</tt> (23.1).
</p>



<p><b>Rationale:</b></p>
<p>
The general idea of the proposed solution is to remove the faulty
requires clauses and let the returns and effects clauses speak for
themselves. That is, the returns clauses contain expressions that must
be valid, and therefore already imply the correct requirements. In
addition, a sentence is added at the beginning of chapter 25 saying
that expressions given as conditions must evaluate to true or false in
a boolean context. An alternative would be to say that the type of
these condition expressions must be literally bool, but that would be
imposing a greater restriction that what the standard currently says
(which is convertible to bool).
</p>





<hr>
<h3><a name="284"></a>284. unportable example in 20.3.7, p6</h3>
<p><b>Section:</b> 20.8.6 [comparisons] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2000-12-26 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>The example in 20.8.6 [comparisons], p6 shows how to use the C
library function <tt>strcmp()</tt> with the function pointer adapter
<tt>ptr_fun()</tt>. But since it's unspecified whether the C library
functions have <tt>extern "C"</tt> or <tt>extern
"C++"</tt> linkage [17.6.2.3 [using.linkage]], and since
function pointers with different the language linkage specifications
(7.5 [dcl.link]) are incompatible, whether this example is
well-formed is unspecified.
</p>


<p><b>Proposed resolution:</b></p>
<p>Change 20.8.6 [comparisons] paragraph 6 from:</p>
<blockquote>
  <p>[<i>Example:</i></p>
  <pre>    replace_if(v.begin(), v.end(), not1(bind2nd(ptr_fun(strcmp), "C")), "C++");
  </pre>
  <p>replaces each <tt>C</tt> with <tt>C++</tt> in sequence <tt>v</tt>.</p>
</blockquote>


<p>to:</p>
<blockquote>
  <p>[<i>Example:</i></p>
  <pre>    int compare(const char*, const char*);
    replace_if(v.begin(), v.end(),
               not1(bind2nd(ptr_fun(compare), "abc")), "def");
  </pre>
  <p>replaces each <tt>abc</tt> with <tt>def</tt> in sequence <tt>v</tt>.</p>
</blockquote>

<p>Also, remove footnote 215 in that same paragraph.</p>

<p><i>[Copenhagen: Minor change in the proposed resolution.  Since this
issue deals in part with C and C++ linkage, it was believed to be too
confusing for the strings in the example to be "C" and "C++".
]</i></p>


<p><i>[Redmond: More minor changes.  Got rid of the footnote (which
seems to make a sweeping normative requirement, even though footnotes
aren't normative), and changed the sentence after the footnote so that
it corresponds to the new code fragment.]</i></p>






<hr>
<h3><a name="285"></a>285. minor editorial errors in fstream ctors</h3>
<p><b>Section:</b> 27.9.1.7 [ifstream.cons] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2000-12-31 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>27.9.1.7 [ifstream.cons], p2, 27.9.1.11 [ofstream.cons], p2, and
27.9.1.15 [fstream.cons], p2 say about the effects of each constructor:
</p>

<p>... If that function returns a null pointer, calls
<tt>setstate(failbit)</tt> (which may throw <tt>ios_base::failure</tt>).
</p>

<p>The parenthetical note doesn't apply since the ctors cannot throw an
exception due to the requirement in 27.5.4.1 [basic.ios.cons], p3 
that <tt>exceptions()</tt> be initialized to <tt>ios_base::goodbit</tt>.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Strike the parenthetical note from the Effects clause in each of the
paragraphs mentioned above.
</p>




<hr>
<h3><a name="286"></a>286. &lt;cstdlib&gt; requirements missing size_t typedef</h3>
<p><b>Section:</b> 25.5 [alg.c.library] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Judy Ward <b>Opened:</b> 2000-12-30 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.c.library">issues</a> in [alg.c.library].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The &lt;cstdlib&gt; header file contains prototypes for bsearch and
qsort (C++ Standard section 25.4 paragraphs 3 and 4) and other
prototypes (C++ Standard section 21.4 paragraph 1 table 49) that
require the typedef size_t. Yet size_t is not listed in the
&lt;cstdlib&gt; synopsis table 78 in section 25.4.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add the type size_t to Table 78 (section 25.4) and add
the type size_t &lt;cstdlib&gt; to Table 97 (section C.2).
</p>


<p><b>Rationale:</b></p>
<p>Since size_t is in &lt;stdlib.h&gt;, it must also be in &lt;cstdlib&gt;.</p>





<hr>
<h3><a name="288"></a>288. &lt;cerrno&gt; requirements missing macro EILSEQ</h3>
<p><b>Section:</b> 19.4 [errno] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Judy Ward <b>Opened:</b> 2000-12-30 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
ISO/IEC 9899:1990/Amendment1:1994 Section 4.3 States: "The list
of macros defined in &lt;errno.h&gt; is adjusted to include a new
macro, EILSEQ"
</p>

<p>
ISO/IEC 14882:1998(E) section 19.3 does not refer
to the above amendment.
</p>



<p><b>Proposed resolution:</b></p>
<p>
Update Table 26 (section 19.3) "Header  &lt;cerrno&gt; synopsis"
and Table 95 (section C.2) "Standard Macros" to include EILSEQ.
</p>





<hr>
<h3><a name="291"></a>291. Underspecification of set algorithms</h3>
<p><b>Section:</b> 25.4.5 [alg.set.operations] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2001-01-03 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.set.operations">issues</a> in [alg.set.operations].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The standard library contains four algorithms that compute set
operations on sorted ranges: <tt>set_union</tt>, <tt>set_intersection</tt>,
<tt>set_difference</tt>, and <tt>set_symmetric_difference</tt>.  Each
of these algorithms takes two sorted ranges as inputs, and writes the
output of the appropriate set operation to an output range.  The elements
in the output range are sorted.
</p>

<p>
The ordinary mathematical definitions are generalized so that they
apply to ranges containing multiple copies of a given element.  Two
elements are considered to be "the same" if, according to an
ordering relation provided by the user, neither one is less than the
other.  So, for example, if one input range contains five copies of an
element and another contains three, the output range of <tt>set_union</tt>
will contain five copies, the output range of
<tt>set_intersection</tt> will contain three, the output range of
<tt>set_difference</tt> will contain two, and the output range of
<tt>set_symmetric_difference</tt> will contain two.
</p>

<p>
Because two elements can be "the same" for the purposes
of these set algorithms, without being identical in other respects
(consider, for example, strings under case-insensitive comparison),
this raises a number of unanswered questions:
</p>

<ul>
<li>If we're copying an element that's present in both of the
input ranges, which one do we copy it from?</li>
<li>If there are <i>n</i> copies of an element in the relevant
input range, and the output range will contain fewer copies (say
<i>m</i>) which ones do we choose?  The first <i>m</i>, or the last
<i>m</i>, or something else?</li>
<li>Are these operations stable?  That is, does a run of equivalent
elements appear in the output range in the same order as as it
appeared in the input range(s)?</li>
</ul>

<p>
The standard should either answer these questions, or explicitly
say that the answers are unspecified.  I prefer the former option,
since, as far as I know, all existing implementations behave the
same way.
</p>



<p><b>Proposed resolution:</b></p>

<p>Add the following to the end of 25.4.5.2 [set.union] paragraph 5:</p>
<blockquote><p>
If [first1, last1) contains <i>m</i> elements that are equivalent to
each other and [first2, last2) contains <i>n</i> elements that are
equivalent to them, then max(<i>m</i>, <i>n</i>) of these elements
will be copied to the output range: all <i>m</i> of these elements
from [first1, last1), and the last max(<i>n-m</i>, 0) of them from
[first2, last2), in that order.
</p></blockquote>

<p>Add the following to the end of 25.4.5.3 [set.intersection] paragraph 5:</p>
<blockquote><p>
If [first1, last1) contains <i>m</i> elements that are equivalent to each
other and [first2, last2) contains <i>n</i> elements that are
equivalent to them, the first min(<i>m</i>, <i>n</i>) of those 
elements from [first1, last1) are copied to the output range.
</p></blockquote>

<p>Add a new paragraph, <b>Notes</b>, after 25.4.5.4 [set.difference]
paragraph 4:</p>
<blockquote><p>
If [first1, last1) contains <i>m</i> elements that are equivalent to each
other and [first2, last2) contains <i>n</i> elements that are
equivalent to them, the last max(<i>m-n</i>, 0) elements from 
[first1, last1) are copied to the output range.
</p></blockquote>

<p>Add a new paragraph, <b>Notes</b>, after 25.4.5.5 [set.symmetric.difference]
paragraph 4:</p>
<blockquote><p>
If [first1, last1) contains <i>m</i> elements that are equivalent to
each other and [first2, last2) contains <i>n</i> elements that are
equivalent to them, then |<i>m - n</i>| of those elements will be
copied to the output range: the last <i>m - n</i> of these elements
from [first1, last1) if <i>m</i> &gt; <i>n</i>, and the last <i>n -
m</i> of these elements from [first2, last2) if <i>m</i> &lt; <i>n</i>.
</p></blockquote>

<p><i>[Santa Cruz: it's believed that this language is clearer than
  what's in the Standard.  However, it's also believed that the
  Standard may already make these guarantees (although not quite in
  these words).  Bill and Howard will check and see whether they think
  that some or all of these changes may be redundant.  If so, we may
  close this issue as NAD.]</i></p>




<p><b>Rationale:</b></p>
<p>For simple cases, these descriptions are equivalent to what's
  already in the Standard.  For more complicated cases, they describe
  the behavior of existing implementations.</p>





<hr>
<h3><a name="292"></a>292. effects of a.copyfmt (a)</h3>
<p><b>Section:</b> 27.5.4.2 [basic.ios.members] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2001-01-05 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#basic.ios.members">issues</a> in [basic.ios.members].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>The Effects clause of the member function <tt>copyfmt()</tt> in
27.4.4.2, p15 doesn't consider the case where the left-hand side
argument is identical to the argument on the right-hand side, that is
<tt>(this == &amp;rhs)</tt>.  If the two arguments are identical there
is no need to copy any of the data members or call any callbacks
registered with <tt>register_callback()</tt>.  Also, as Howard Hinnant
points out in message c++std-lib-8149 it appears to be incorrect to
allow the object to fire <tt>erase_event</tt> followed by
<tt>copyfmt_event</tt> since the callback handling the latter event
may inadvertently attempt to access memory freed by the former.
</p>


<p><b>Proposed resolution:</b></p>
<p>Change the Effects clause in 27.4.4.2, p15 from</p>

<blockquote><p>
<b>-15- Effects:</b>Assigns to the member objects of <tt>*this</tt>
the corresponding member objects of <tt>rhs</tt>, except that...
</p></blockquote>

<p>to</p>

<blockquote><p>
<b>-15- Effects:</b>If <tt>(this == &amp;rhs)</tt> does nothing. Otherwise
assigns to the member objects of <tt>*this</tt> the corresponding member
objects of <tt>rhs</tt>, except that...
</p></blockquote>




<hr>
<h3><a name="294"></a>294. User defined macros and standard headers</h3>
<p><b>Section:</b> 17.6.3.3.1 [macro.names] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> James Kanze <b>Opened:</b> 2001-01-11 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#macro.names">issues</a> in [macro.names].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>Paragraph 2 of 17.6.3.3.1 [macro.names] reads: "A
translation unit that includes a header shall not contain any macros
that define names declared in that header." As I read this, it
would mean that the following program is legal:</p>

<pre>  #define npos 3.14
  #include &lt;sstream&gt;
</pre>

<p>since npos is not defined in &lt;sstream&gt;.  It is, however, defined
in &lt;string&gt;, and it is hard to imagine an implementation in
which &lt;sstream&gt; didn't include &lt;string&gt;.</p>

<p>I think that this phrase was probably formulated before it was
decided that a standard header may freely include other standard
headers.  The phrase would be perfectly appropriate for C, for
example.  In light of 17.6.4.2 [res.on.headers] paragraph 1, however,
it isn't stringent enough.</p>


<p><b>Proposed resolution:</b></p>
<p>For 17.6.3.3.1 [macro.names], replace the current wording, which reads:</p>
<blockquote>
     <p>Each name defined as a macro in a header is reserved to the
     implementation for any use if the translation unit includes
     the header.168)</p>

     <p>A translation unit that includes a header shall not contain any
     macros that define names declared or defined in that header. Nor shall
     such a translation unit define macros for names lexically
     identical to keywords.</p>

     <p>168) It is not permissible to remove a library macro definition by
     using the #undef directive.</p>
</blockquote>

<p>with the wording:</p>

<blockquote>
     <p>A translation unit that includes a standard library header shall not
     #define or #undef names declared in any standard library header.</p>

     <p>A translation unit shall not #define or #undef names lexically
     identical to keywords.</p>
</blockquote>

<p><i>[Lillehammer: Beman provided new wording]</i></p>






<hr>
<h3><a name="295"></a>295. Is abs defined in &lt;cmath&gt;?</h3>
<p><b>Section:</b> 26.8 [c.math] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Jens Maurer <b>Opened:</b> 2001-01-12 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#c.math">issues</a> in [c.math].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Table 80 lists the contents of the &lt;cmath&gt; header.  It does not
list <tt>abs()</tt>.  However, 26.5, paragraph 6, which lists added 
signatures present in &lt;cmath&gt;, does say that several overloads
of <tt>abs()</tt> should be defined in &lt;cmath&gt;.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add <tt>abs</tt> to Table 80.  Also, remove the parenthetical list
of functions "(abs(), div(), rand(), srand())" from 26.6 [numarray],
paragraph 1.
</p>

<p><i>[Copenhagen: Modified proposed resolution so that it also gets
rid of that vestigial list of functions in paragraph 1.]</i></p>




<p><b>Rationale:</b></p>
<p>All this DR does is fix a typo; it's uncontroversial.  A 
separate question is whether we're doing the right thing in 
putting some overloads in &lt;cmath&gt; that we aren't also 
putting in &lt;cstdlib&gt;.  That's issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#323">323</a>.</p>





<hr>
<h3><a name="296"></a>296. Missing descriptions and requirements of pair operators</h3>
<p><b>Section:</b> 20.3.5 [pairs] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2001-01-14 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#pairs">issues</a> in [pairs].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>The synopsis of the header <tt>&lt;utility&gt;</tt> in 20.3 [utility]
lists the complete set of equality and relational operators for <tt>pair</tt>
but the section describing the template and the operators only describes
<tt>operator==()</tt> and <tt>operator&lt;()</tt>, and it fails to mention
any requirements on the template arguments. The remaining operators are
not mentioned at all.
</p>

<p><i>[
2009-09-27 Alisdair reopens.
]</i></p>


<blockquote>
<p>
The issue is a lack of wording specifying the semantics of <tt>std::pair</tt>
relational operators.  The rationale is that this is covered by
catch-all wording in the relops component, and that as relops directly
precedes <tt>pair</tt> in the document this is an easy connection to make.
</p>

<p>
Reading the current working paper I make two observations:
</p>

<ol type="i">
<li>
relops no longer immediately precedes <tt>pair</tt> in the order of
specification.  However, even if it did, there is a lot of <tt>pair</tt>
specification itself between the (apparently) unrelated relops and the
relational operators for <tt>pair</tt>.  (The catch-all still requires
<tt>operator==</tt> and <tt>operator&lt;</tt> to be specified
explicitly)
</li>

<li>
No other library component relies on the catch-all clause. The following
all explicitly document all six relational operators, usually in a
manner that could have deferred to the relops clause.
</li>
</ol>

<blockquote><pre>tuple
unique_ptr
duration
time_point
basic_string
queue
stack
move_iterator
reverse_iterator 
regex submatch
thread::id
</pre></blockquote>

<p>
The container components provide their own (equivalent) definition in
23.2.1 [container.requirements.general] Table 90 -- Container
requirements and do so do not defer to relops.
</p>

<p>
<tt>Shared_ptr</tt> explicitly documents <tt>operator!=</tt> and does
not supply the other 3 missing operators
(<tt>&gt;</tt>,<tt>&gt;=</tt>,<tt>&lt;=</tt>) so does not meet the
reqirements of the relops clause.
</p>

<p>
<tt>Weak_ptr</tt> only supports <tt>operator&lt;</tt> so would not be
covered by relops.
</p>

<p>
At the very least I would request a note pointing to the relops clause
we rely on to provide this definition.  If this route is taken, I would
recommend reducing many of the above listed clauses to a similar note
rather than providing redundant specification.
</p>

<p>
My preference would be to supply the 4 missing specifications consistent
with the rest of the library.
</p>

</blockquote>

<p><i>[
2009-10-11 Daniel opens <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1233">1233</a> which deals with the same issue as
it pertains to <tt>unique_ptr</tt>.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Move to Ready
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
After p20 20.3.5 [pairs] add:
</p>

<blockquote><pre>template &lt;class T1, class T2&gt;
bool operator!=(const pair&lt;T1,T2&gt;&amp; x, const pair&lt;T1,T2&gt;&amp; y);
</pre>

<blockquote>
<i>Returns:</i> <tt>!(x==y)</tt>
</blockquote>

<pre>template &lt;class T1, class T2&gt;
bool operator&gt; (const pair&lt;T1,T2&gt;&amp; x, const pair&lt;T1,T2&gt;&amp; y);
</pre>

<blockquote>
<i>Returns:</i> <tt>y &lt; x</tt>
</blockquote>

<pre>template &lt;class T1, class T2&gt;
bool operator&gt;=(const pair&lt;T1,T2&gt;&amp; x, const pair&lt;T1,T2&gt;&amp; y);
</pre>

<blockquote>
<i>Returns:</i> <tt>!(x &lt; y)</tt>
</blockquote>

<pre>template &lt;class T1, class T2&gt;
bool operator&lt;=(const pair&lt;T1,T2&gt;&amp; x, const pair&lt;T1,T2&gt;&amp; y);
</pre>

<blockquote>
<i>Returns:</i> <tt>!(y &lt; x)</tt>
</blockquote>
</blockquote>


<p><b>Rationale:</b></p>
<p>20.3.1 [operators] paragraph 10 already specifies the semantics.
That paragraph says that, if declarations of operator!=, operator&gt;,
operator&lt;=, and operator&gt;= appear without definitions, they are
defined as specified in 20.3.1 [operators].  There should be no user
confusion, since that paragraph happens to immediately precede the
specification of <tt>pair</tt>.</p>





<hr>
<h3><a name="297"></a>297. const_mem_fun_t&lt;&gt;::argument_type should be const T*</h3>
<p><b>Section:</b> 20.8.7 [logical.operations] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2001-01-06 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>The class templates <tt>const_mem_fun_t</tt> in 20.5.8, p8 and
<tt>const_mem_fun1_t</tt>
in 20.5.8, p9 derive from <tt>unary_function&lt;T*, S&gt;</tt>, and
<tt>binary_function&lt;T*,
A, S&gt;</tt>, respectively. Consequently, their <tt>argument_type</tt>, and
<tt>first_argument_type</tt>
members, respectively, are both defined to be <tt>T*</tt> (non-const).
However, their function call member operator takes a <tt>const T*</tt>
argument. It is my opinion that <tt>argument_type</tt> should be <tt>const
T*</tt> instead, so that one can easily refer to it in generic code. The
example below derived from existing code fails to compile due to the
discrepancy:
</p>

<p><tt>template &lt;class T&gt;</tt>
<br><tt>void foo (typename T::argument_type arg)&nbsp;&nbsp; // #1</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; typename T::result_type (T::*pf) (typename
T::argument_type)
const =&nbsp;&nbsp; // #2</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;T::operator();</tt>
<br><tt>}</tt>
</p>

<p><tt>struct X { /* ... */ };</tt></p>

<p><tt>int main ()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; const X x;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; foo&lt;std::const_mem_fun_t&lt;void, X&gt;
&gt;(&amp;x);&nbsp;&nbsp;
// #3</tt>
<br><tt>}</tt>
</p>

<p>#1 <tt>foo()</tt> takes a plain unqualified <tt>X*</tt> as an argument
<br>#2 the type of the pointer is incompatible with the type of the member
function
<br>#3 the address of a constant being passed to a function taking a non-const
<tt>X*</tt>
</p>


<p><b>Proposed resolution:</b></p>
<p>Replace the top portion of the definition of the class template
const_mem_fun_t in 20.5.8, p8
</p>
<p><tt>template &lt;class S, class T&gt; class const_mem_fun_t</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : public
unary_function&lt;T*, S&gt; {</tt>
</p>
<p>with</p>
<p><tt>template &lt;class S, class T&gt; class const_mem_fun_t</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : public
unary_function&lt;<b>const</b> T*, S&gt; {</tt>
</p>
<p>Also replace the top portion of the definition of the class template
const_mem_fun1_t in 20.5.8, p9</p>
<p><tt>template &lt;class S, class T, class A&gt; class const_mem_fun1_t</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : public
binary_function&lt;T*, A, S&gt; {</tt>
</p>
<p>with</p>
<p><tt>template &lt;class S, class T, class A&gt; class const_mem_fun1_t</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : public
binary_function&lt;<b>const</b> T*, A, S&gt; {</tt>
</p>


<p><b>Rationale:</b></p>
<p>This is simply a contradiction: the <tt>argument_type</tt> typedef,
and the argument type itself, are not the same.</p>





<hr>
<h3><a name="298"></a>298. ::operator delete[] requirement incorrect/insufficient</h3>
<p><b>Section:</b> 18.6.1.2 [new.delete.array] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> John A. Pedretti <b>Opened:</b> 2001-01-10 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The default behavior of <tt>operator delete[]</tt> described in 18.5.1.2, p12 -
namely that for non-null value of <i>ptr</i>, the operator reclaims storage
allocated by the earlier call to the default <tt>operator new[]</tt> - is not
correct in all cases. Since the specified <tt>operator new[]</tt> default
behavior is to call <tt>operator new</tt> (18.5.1.2, p4, p8), which can be
replaced, along with <tt>operator delete</tt>, by the user, to implement their
own memory management, the specified default behavior of<tt> operator
delete[]</tt> must be to call <tt>operator delete</tt>.
</p>


<p><b>Proposed resolution:</b></p>
<p>Change 18.5.1.2, p12 from</p>
<blockquote><p>
<b>-12-</b> <b>Default behavior:</b></p>
<ul>
<li>
For a null value of <i><tt>ptr</tt></i> , does nothing.
</li>
<li>
Any other value of <i><tt>ptr</tt></i> shall be a value returned
earlier by a call to the default <tt>operator new[](std::size_t)</tt>.
[Footnote: The value must not have been invalidated by an intervening
call to <tt>operator delete[](void*)</tt> (17.6.3.9 [res.on.arguments]).
--- end footnote]
For such a non-null value of <i><tt>ptr</tt></i> , reclaims storage
allocated by the earlier call to the default <tt>operator new[]</tt>.
</li>
</ul>
</blockquote>

<p>to</p>

<blockquote><p>
<b>-12-</b> <b>Default behavior: </b>Calls <tt>operator
delete(</tt><i>ptr</i>)
or <tt>operator delete(<i>ptr</i>, std::nothrow)</tt> respectively.
</p></blockquote>
<p>and expunge paragraph 13.</p>




<hr>
<h3><a name="300"></a>300. list::merge() specification incomplete</h3>
<p><b>Section:</b> 23.3.4.4 [list.ops] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> John Pedretti <b>Opened:</b> 2001-01-23 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#list.ops">issues</a> in [list.ops].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The "Effects" clause for list::merge() (23.3.4.4 [list.ops], p23)
appears to be incomplete: it doesn't cover the case where the argument
list is identical to *this (i.e., this == &amp;x). The requirement in the
note in p24 (below) is that x be empty after the merge which is surely
unintended in this case.
</p>


<p><b>Proposed resolution:</b></p>
<p>In 23.3.4.4 [list.ops], replace paragraps 23-25 with:</p>
<blockquote>
<p>
23 Effects: if (&amp;x == this) does nothing; otherwise, merges the two
sorted ranges [begin(), end()) and [x.begin(), x.end()).  The result
is a range in which the elements will be sorted in non-decreasing
order according to the ordering defined by comp; that is, for every
iterator i in the range other than the first, the condition comp(*i,
*(i - 1)) will be false.
</p>

<p>
24 Notes: Stable: if (&amp;x != this), then for equivalent elements in the
two original ranges, the elements from the original range [begin(),
end()) always precede the elements from the original range [x.begin(),
x.end()).  If (&amp;x != this) the range [x.begin(), x.end()) is empty
after the merge.
</p>

<p>
25 Complexity: At most size() + x.size() - 1 applications of comp if
(&amp;x !  = this); otherwise, no applications of comp are performed.  If
an exception is thrown other than by a comparison there are no
effects.
</p>

</blockquote>

<p><i>[Copenhagen: The original proposed resolution did not fix all of
the problems in 23.3.4.4 [list.ops], p22-25.  Three different
paragraphs (23, 24, 25) describe the effects of <tt>merge</tt>.
Changing p23, without changing the other two, appears to introduce
contradictions.  Additionally, "merges the argument list into the
list" is excessively vague.]</i></p>


<p><i>[Post-Curaao: Robert Klarer provided new wording.]</i></p>







<hr>
<h3><a name="301"></a>301. basic_string template ctor effects clause omits allocator argument</h3>
<p><b>Section:</b> 21.4.1 [string.require] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2001-01-27 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#string.require">issues</a> in [string.require].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The effects clause for the basic_string template ctor in 21.3.1, p15
leaves out the third argument of type Allocator. I believe this to be
a mistake.
</p>


<p><b>Proposed resolution:</b></p>
<p>Replace</p>

<blockquote>
    <p><b>-15- Effects:</b> If <i><tt>InputIterator</tt></i> is an integral
    type, equivalent to</p>

    <blockquote><p><tt>basic_string(static_cast&lt;size_type&gt;(begin),
    static_cast&lt;value_type&gt;(end))</tt></p></blockquote>
</blockquote>

<p>with</p>

<blockquote>
    <p><b>-15- Effects:</b> If <i><tt>InputIterator</tt></i> is an integral
    type, equivalent to</p>

    <blockquote><p><tt>basic_string(static_cast&lt;size_type&gt;(begin),
    static_cast&lt;value_type&gt;(end), <b>a</b>)</tt></p></blockquote>
</blockquote>




<hr>
<h3><a name="303"></a>303. Bitset input operator underspecified</h3>
<p><b>Section:</b> 20.5.4 [bitset.operators] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2001-02-05 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 23.3.5.3, we are told that <tt>bitset</tt>'s input operator
"Extracts up to <i>N</i> (single-byte) characters from
<i>is</i>.", where <i>is</i> is a stream of type
<tt>basic_istream&lt;charT, traits&gt;</tt>.
</p>

<p>
The standard does not say what it means to extract single byte
characters from a stream whose character type, <tt>charT</tt>, is in
general not a single-byte character type.  Existing implementations
differ.
</p>

<p>
A reasonable solution will probably involve <tt>widen()</tt> and/or
<tt>narrow()</tt>, since they are the supplied mechanism for
converting a single character between <tt>char</tt> and 
arbitrary <tt>charT</tt>.
</p>

<p>Narrowing the input characters is not the same as widening the
literals <tt>'0'</tt> and <tt>'1'</tt>, because there may be some
locales in which more than one wide character maps to the narrow
character <tt>'0'</tt>.  Narrowing means that alternate
representations may be used for bitset input, widening means that
they may not be.</p>

<p>Note that for numeric input, <tt>num_get&lt;&gt;</tt>
(22.2.2.1.2/8) compares input characters to widened version of narrow
character literals.</p>

<p>From Pete Becker, in c++std-lib-8224:</p>
<blockquote>
<p>
Different writing systems can have different representations for the
digits that represent 0 and 1. For example, in the Unicode representation
of the Devanagari script (used in many of the Indic languages) the digit 0
is 0x0966, and the digit 1 is 0x0967. Calling narrow would translate those
into '0' and '1'. But Unicode also provides the ASCII values 0x0030 and
0x0031 for for the Latin representations of '0' and '1', as well as code
points for the same numeric values in several other scripts (Tamil has no
character for 0, but does have the digits 1-9), and any of these values
would also be narrowed to '0' and '1'.
</p>

<p>...</p>

<p>
It's fairly common to intermix both native and Latin
representations of numbers in a document. So I think the rule has to be
that if a wide character represents a digit whose value is 0 then the bit
should be cleared; if it represents a digit whose value is 1 then the bit
should be set; otherwise throw an exception. So in a Devanagari locale,
both 0x0966 and 0x0030 would clear the bit, and both 0x0967 and 0x0031
would set it. Widen can't do that. It would pick one of those two values,
and exclude the other one.
</p>

</blockquote>

<p>From Jens Maurer, in c++std-lib-8233:</p>

<blockquote>
<p>
Whatever we decide, I would find it most surprising if
bitset conversion worked differently from int conversion
with regard to alternate local representations of
numbers.
</p>

<p>Thus, I think the options are:</p>
<ul>
 <li> Have a new defect issue for 22.2.2.1.2/8 so that it will
require the use of narrow().</li>

 <li> Have a defect issue for bitset() which describes clearly
that widen() is to be used.</li>
</ul>
</blockquote>



<p><b>Proposed resolution:</b></p>

    <p>Replace the first two sentences of paragraph 5 with:</p>

    <blockquote><p>
    Extracts up to <i>N</i> characters from <i>is</i>. Stores these
    characters in a temporary object <i>str</i> of type
    <tt>basic_string&lt;charT, traits&gt;</tt>, then evaluates the
    expression <tt><i>x</i> = bitset&lt;N&gt;(<i>str</i>)</tt>.
    </p></blockquote>

    <p>Replace the third bullet item in paragraph 5 with:</p>
    <ul><li>
    the next input character is neither <tt><i>is</i>.widen(0)</tt>
    nor <tt><i>is</i>.widen(1)</tt> (in which case the input character
    is not extracted).
    </li></ul>



<p><b>Rationale:</b></p>
<p>Input for <tt>bitset</tt> should work the same way as numeric
input.  Using <tt>widen</tt> does mean that alternative digit
representations will not be recognized, but this was a known 
consequence of the design choice.</p>





<hr>
<h3><a name="305"></a>305. Default behavior of codecvt&lt;wchar_t, char, mbstate_t&gt;::length()</h3>
<p><b>Section:</b> 22.4.1.5 [locale.codecvt.byname] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2001-01-24 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.codecvt.byname">issues</a> in [locale.codecvt.byname].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>22.2.1.5/3 introduces codecvt in part with:</p>

<blockquote><p>
  codecvt&lt;wchar_t,char,mbstate_t&gt; converts between the native
  character sets for tiny and wide characters. Instantiations on
  mbstate_t perform conversion between encodings known to the library
  implementor.
</p></blockquote>

<p>But 22.2.1.5.2/10 describes do_length in part with:</p>

<blockquote><p>
  ... codecvt&lt;wchar_t, char, mbstate_t&gt; ... return(s) the lesser of max and 
  (from_end-from).
</p></blockquote>

<p>
The semantics of do_in and do_length are linked.  What one does must
be consistent with what the other does.  22.2.1.5/3 leads me to
believe that the vendor is allowed to choose the algorithm that
codecvt&lt;wchar_t,char,mbstate_t&gt;::do_in performs so that it makes
his customers happy on a given platform.  But 22.2.1.5.2/10 explicitly
says what codecvt&lt;wchar_t,char,mbstate_t&gt;::do_length must
return.  And thus indirectly specifies the algorithm that
codecvt&lt;wchar_t,char,mbstate_t&gt;::do_in must perform.  I believe
that this is not what was intended and is a defect.
</p>

<p>Discussion from the -lib reflector:

<br>This proposal would have the effect of making the semantics of
all of the virtual functions in <tt>codecvt&lt;wchar_t, char,
mbstate_t&gt;</tt> implementation specified.  Is that what we want, or
do we want to mandate specific behavior for the base class virtuals
and leave the implementation specified behavior for the codecvt_byname
derived class?  The tradeoff is that former allows implementors to
write a base class that actually does something useful, while the
latter gives users a way to get known and specified---albeit
useless---behavior, and is consistent with the way the standard
handles other facets.  It is not clear what the original intention
was.</p>

<p>
Nathan has suggest a compromise: a character that is a widened version
of the characters in the basic execution character set must be
converted to a one-byte sequence, but there is no such requirement
for characters that are not part of the basic execution character set.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change 22.2.1.5.2/5 from:
</p>
<p>
The instantiations required in Table 51 (lib.locale.category), namely
codecvt&lt;wchar_t,char,mbstate_t&gt; and
codecvt&lt;char,char,mbstate_t&gt;, store no characters. Stores no more
than (to_limit-to) destination elements. It always leaves the to_next
pointer pointing one beyond the last element successfully stored.
</p>
<p>
to:
</p>
<p>
Stores no more than (to_limit-to) destination elements, and leaves the
to_next pointer pointing one beyond the last element successfully
stored.  codecvt&lt;char,char,mbstate_t&gt; stores no characters.
</p>

<p>Change 22.2.1.5.2/10 from:</p>

<blockquote><p>
-10- Returns: (from_next-from) where from_next is the largest value in
the range [from,from_end] such that the sequence of values in the
range [from,from_next) represents max or fewer valid complete
characters of type internT. The instantiations required in Table 51
(21.1.1.1.1), namely codecvt&lt;wchar_t, char, mbstate_t&gt; and
codecvt&lt;char, char, mbstate_t&gt;, return the lesser of max and
(from_end-from).
</p></blockquote>

<p>to:</p>

<blockquote><p>
-10- Returns: (from_next-from) where from_next is the largest value in 
the range [from,from_end] such that the sequence of values in the range 
[from,from_next) represents max or fewer valid complete characters of 
type internT. The instantiation codecvt&lt;char, char, mbstate_t&gt; returns 
the lesser of max and (from_end-from). 
</p></blockquote>

<p><i>[Redmond: Nathan suggested an alternative resolution: same as
above, but require that, in the default encoding, a character from the
basic execution character set would map to a single external
character.  The straw poll was 8-1 in favor of the proposed
resolution.]</i></p>




<p><b>Rationale:</b></p>
<p>The default encoding should be whatever users of a given platform
would expect to be the most natural.  This varies from platform to
platform.  In many cases there is a preexisting C library, and users
would expect the default encoding to be whatever C uses in the default
"C" locale.  We could impose a guarantee like the one Nathan suggested
(a character from the basic execution character set must map to a
single external character), but this would rule out important
encodings that are in common use: it would rule out JIS, for
example, and it would rule out a fixed-width encoding of UCS-4.</p>

<p><i>[Curaao: fixed rationale typo at the request of Ichiro Koshida;
"shift-JIS" changed to "JIS".]</i></p>







<hr>
<h3><a name="306"></a>306. offsetof macro and non-POD types</h3>
<p><b>Section:</b> 18.2 [support.types] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Steve Clamage <b>Opened:</b> 2001-02-21 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#support.types">issues</a> in [support.types].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p> 
<p>Spliced together from reflector messages c++std-lib-8294 and -8295:</p>

<p>18.1, paragraph 5, reads: "The macro <tt>offsetof</tt>
accepts a restricted set of <i>type</i> arguments in this
International Standard. <i>type</i> shall be a POD structure or a POD
union (clause 9). The result of applying the offsetof macro to a field
that is a static data member or a function member is
undefined."</p>

<p>For the POD requirement, it doesn't say "no diagnostic
required" or "undefined behavior". I read 1.4 [intro.compliance], paragraph 1, to mean that a diagnostic is required.
It's not clear whether this requirement was intended.  While it's
possible to provide such a diagnostic, the extra complication doesn't
seem to add any value.
</p>


<p><b>Proposed resolution:</b></p>
<p>Change 18.1, paragraph 5, to "If <i>type</i> is not a POD
structure or a POD union the results are undefined."</p>

<p><i>[Copenhagen: straw poll was 7-4 in favor.  It was generally
agreed that requiring a diagnostic was inadvertent, but some LWG
members thought that diagnostics should be required whenever
possible.]</i></p>






<hr>
<h3><a name="307"></a>307. Lack of reference typedefs in container adaptors</h3>
<p><b>Section:</b> 23.3.4 [list] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2001-03-13 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>

<p>From reflector message c++std-lib-8330.  See also lib-8317.</p>

<p>
The standard is currently inconsistent in 23.3.4.2 [list.capacity]
paragraph 1 and 23.3.4.3 [list.modifiers] paragraph 1.
23.2.3.3/1, for example, says:
</p>

<blockquote><p>
-1- Any sequence supporting operations back(), push_back() and pop_back() 
can be used to instantiate stack. In particular, vector (lib.vector), list 
(lib.list) and deque (lib.deque) can be used. 
</p></blockquote>

<p>But this is false: vector&lt;bool&gt; can not be used, because the
container adaptors return a T&amp; rather than using the underlying
container's reference type.</p>

<p>This is a contradiction that can be fixed by:</p>

<ol>
<li>Modifying these paragraphs to say that vector&lt;bool&gt;
    is an exception.</li>
<li>Removing the vector&lt;bool&gt; specialization.</li>
<li>Changing the return types of stack and priority_queue to use 
    reference typedef's.</li>
</ol>

<p>
I propose 3.  This does not preclude option 2 if we choose to do it
later (see issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#96">96</a>); the issues are independent.  Option
3 offers a small step towards support for proxied containers.  This
small step fixes a current contradiction, is easy for vendors to
implement, is already implemented in at least one popular lib, and
does not break any code.
</p>



<p><b>Proposed resolution:</b></p>
<p>Summary: Add reference and const_reference typedefs to queue,
priority_queue and stack.  Change return types of "value_type&amp;" to
"reference".  Change return types of "const value_type&amp;" to
"const_reference".  Details:</p>

<p>Change 23.2.3.1/1 from:</p>

<pre>  namespace std {
    template &lt;class T, class Container = deque&lt;T&gt; &gt;
    class queue {
    public:
      typedef typename Container::value_type            value_type;
      typedef typename Container::size_type             size_type;
      typedef          Container                        container_type;
    protected:
      Container c;

    public:
      explicit queue(const Container&amp; = Container());

      bool      empty() const             { return c.empty(); }
      size_type size()  const             { return c.size(); }
      value_type&amp;       front()           { return c.front(); }
      const value_type&amp; front() const     { return c.front(); }
      value_type&amp;       back()            { return c.back(); }
      const value_type&amp; back() const      { return c.back(); }
      void push(const value_type&amp; x)      { c.push_back(x); }
      void pop()                          { c.pop_front(); }
    };
</pre>

<p>to:</p>

<pre>  namespace std {
    template &lt;class T, class Container = deque&lt;T&gt; &gt;
    class queue {
    public:
      typedef typename Container::value_type            value_type;
      typedef typename Container::reference             reference;
      typedef typename Container::const_reference       const_reference;
      typedef typename Container::value_type            value_type;
      typedef typename Container::size_type             size_type;
      typedef          Container                        container_type;
    protected:
      Container c;

    public:
      explicit queue(const Container&amp; = Container());

      bool      empty() const             { return c.empty(); }
      size_type size()  const             { return c.size(); }
      reference         front()           { return c.front(); }
      const_reference   front() const     { return c.front(); }
      reference         back()            { return c.back(); }
      const_reference   back() const      { return c.back(); }
      void push(const value_type&amp; x)      { c.push_back(x); }
      void pop()                          { c.pop_front(); }
    };
</pre>

<p>Change 23.2.3.2/1 from:</p>

<pre>  namespace std {
    template &lt;class T, class Container = vector&lt;T&gt;,
              class Compare = less&lt;typename Container::value_type&gt; &gt;
    class priority_queue {
    public:
      typedef typename Container::value_type            value_type;
      typedef typename Container::size_type             size_type;
      typedef          Container                        container_type;
    protected:
      Container c;
      Compare comp;

    public:
      explicit priority_queue(const Compare&amp; x = Compare(),
                              const Container&amp; = Container());
      template &lt;class InputIterator&gt;
        priority_queue(InputIterator first, InputIterator last,
                       const Compare&amp; x = Compare(),
                       const Container&amp; = Container());

      bool      empty() const       { return c.empty(); }
      size_type size()  const       { return c.size(); }
      const value_type&amp; top() const { return c.front(); }
      void push(const value_type&amp; x);
      void pop();
    };
                                  //  no equality is provided
  }
</pre>

<p>to:</p>

<pre>  namespace std {
    template &lt;class T, class Container = vector&lt;T&gt;,
              class Compare = less&lt;typename Container::value_type&gt; &gt;
    class priority_queue {
    public:
      typedef typename Container::value_type            value_type;
      typedef typename Container::reference             reference;
      typedef typename Container::const_reference       const_reference;
      typedef typename Container::size_type             size_type;
      typedef          Container                        container_type;
    protected:
      Container c;
      Compare comp;

    public:
      explicit priority_queue(const Compare&amp; x = Compare(),
                              const Container&amp; = Container());
      template &lt;class InputIterator&gt;
        priority_queue(InputIterator first, InputIterator last,
                       const Compare&amp; x = Compare(),
                       const Container&amp; = Container());

      bool      empty() const       { return c.empty(); }
      size_type size()  const       { return c.size(); }
      const_reference   top() const { return c.front(); }
      void push(const value_type&amp; x);
      void pop();
    };
                                  //  no equality is provided
  }
</pre>

<p>And change 23.2.3.3/1 from:</p>

<pre>  namespace std {
    template &lt;class T, class Container = deque&lt;T&gt; &gt;
    class stack {
    public:
      typedef typename Container::value_type            value_type;
      typedef typename Container::size_type             size_type;
      typedef          Container                        container_type;
    protected:
      Container c;

    public:
      explicit stack(const Container&amp; = Container());

      bool      empty() const             { return c.empty(); }
      size_type size()  const             { return c.size(); }
      value_type&amp;       top()             { return c.back(); }
      const value_type&amp; top() const       { return c.back(); }
      void push(const value_type&amp; x)      { c.push_back(x); }
      void pop()                          { c.pop_back(); }
    };

    template &lt;class T, class Container&gt;
      bool operator==(const stack&lt;T, Container&gt;&amp; x,
                      const stack&lt;T, Container&gt;&amp; y);
    template &lt;class T, class Container&gt;
      bool operator&lt; (const stack&lt;T, Container&gt;&amp; x,
                      const stack&lt;T, Container&gt;&amp; y);
    template &lt;class T, class Container&gt;
      bool operator!=(const stack&lt;T, Container&gt;&amp; x,
                      const stack&lt;T, Container&gt;&amp; y);
    template &lt;class T, class Container&gt;
      bool operator&gt; (const stack&lt;T, Container&gt;&amp; x,
                      const stack&lt;T, Container&gt;&amp; y);
    template &lt;class T, class Container&gt;
      bool operator&gt;=(const stack&lt;T, Container&gt;&amp; x,
                      const stack&lt;T, Container&gt;&amp; y);
    template &lt;class T, class Container&gt;
      bool operator&lt;=(const stack&lt;T, Container&gt;&amp; x,
                      const stack&lt;T, Container&gt;&amp; y);
  }
</pre>

<p>to:</p>

<pre>  namespace std {
    template &lt;class T, class Container = deque&lt;T&gt; &gt;
    class stack {
    public:
      typedef typename Container::value_type            value_type;
      typedef typename Container::reference             reference;
      typedef typename Container::const_reference       const_reference;
      typedef typename Container::size_type             size_type;
      typedef          Container                        container_type;
    protected:
      Container c;

    public:
      explicit stack(const Container&amp; = Container());

      bool      empty() const             { return c.empty(); }
      size_type size()  const             { return c.size(); }
      reference         top()             { return c.back(); }
      const_reference   top() const       { return c.back(); }
      void push(const value_type&amp; x)      { c.push_back(x); }
      void pop()                          { c.pop_back(); }
    };

    template &lt;class T, class Container&gt;
      bool operator==(const stack&lt;T, Container&gt;&amp; x,
                      const stack&lt;T, Container&gt;&amp; y);
    template &lt;class T, class Container&gt;
      bool operator&lt; (const stack&lt;T, Container&gt;&amp; x,
                      const stack&lt;T, Container&gt;&amp; y);
    template &lt;class T, class Container&gt;
      bool operator!=(const stack&lt;T, Container&gt;&amp; x,
                      const stack&lt;T, Container&gt;&amp; y);
    template &lt;class T, class Container&gt;
      bool operator&gt; (const stack&lt;T, Container&gt;&amp; x,
                      const stack&lt;T, Container&gt;&amp; y);
    template &lt;class T, class Container&gt;
      bool operator&gt;=(const stack&lt;T, Container&gt;&amp; x,
                      const stack&lt;T, Container&gt;&amp; y);
    template &lt;class T, class Container&gt;
      bool operator&lt;=(const stack&lt;T, Container&gt;&amp; x,
                      const stack&lt;T, Container&gt;&amp; y);
  }
</pre>

<p><i>[Copenhagen: This change was discussed before the IS was released
and it was deliberately not adopted.  Nevertheless, the LWG believes
(straw poll: 10-2) that it is a genuine defect.]</i></p>






<hr>
<h3><a name="308"></a>308. Table 82 mentions unrelated headers</h3>
<p><b>Section:</b> 27 [input.output] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2001-03-15 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#input.output">issues</a> in [input.output].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Table 82 in section 27 mentions the header &lt;cstdlib&gt; for String
streams (27.8 [string.streams]) and the headers &lt;cstdio&gt; and
&lt;cwchar&gt; for File streams (27.9 [file.streams]). It's not clear
why these headers are mentioned in this context since they do not
define any of the library entities described by the
subclauses. According to 17.6.1.1 [contents], only such headers
are to be listed in the summary.
</p>


<p><b>Proposed resolution:</b></p>
<p>Remove &lt;cstdlib&gt; and &lt;cwchar&gt; from
Table 82.</p>

<p><i>[Copenhagen: changed the proposed resolution slightly.  The
original proposed resolution also said to remove &lt;cstdio&gt; from
Table 82.  However, &lt;cstdio&gt; is mentioned several times within
section 27.9 [file.streams], including 27.9.2 [c.files].]</i></p>






<hr>
<h3><a name="310"></a>310. Is errno a macro?</h3>
<p><b>Section:</b> 17.6.1.2 [headers], 19.4 [errno] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Steve Clamage <b>Opened:</b> 2001-03-21 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#headers">issues</a> in [headers].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
  <p>
  Exactly how should errno be declared in a conforming C++ header?
  </p>

  <p>
  The C standard says in 7.1.4 that it is unspecified whether errno is a
  macro or an identifier with external linkage.  In some implementations
  it can be either, depending on compile-time options.  (E.g., on
  Solaris in multi-threading mode, errno is a macro that expands to a
  function call, but is an extern int otherwise.  "Unspecified" allows
  such variability.)
  </p>

  <p>The C++ standard:</p>
  <ul>
  <li>17.4.1.2 says in a note that errno must be macro in C. (false)</li>
  <li>17.4.3.1.3 footnote 166 says errno is reserved as an external 
      name (true), and implies that it is an identifier.</li>
  <li>19.3 simply lists errno as a macro (by what reasoning?) and goes
      on to say that the contents of of C++ &lt;errno.h&gt; are the
      same as in C, begging the question.</li>
  <li>C.2, table 95 lists errno as a macro, without comment.</li>
  </ul>

  <p>I find no other references to errno.</p>

  <p>We should either explicitly say that errno must be a macro, even
  though it need not be a macro in C, or else explicitly leave it
  unspecified.  We also need to say something about namespace std. 
  A user who includes &lt;cerrno&gt; needs to know whether to write
  <tt>errno</tt>, or <tt>::errno</tt>, or <tt>std::errno</tt>, or
  else &lt;cerrno&gt; is useless.</p>

  <p>Two acceptable fixes:</p>
  <ul>
    <li><p>errno must be a macro. This is trivially satisfied by adding<br>
        &nbsp;&nbsp;#define errno (::std::errno)<br>
        to the headers if errno is not already a macro. You then always
        write errno without any scope qualification, and it always expands
        to a correct reference. Since it is always a macro, you know to
        avoid using errno as a local identifer.</p></li>
    <li><p>errno is in the global namespace. This fix is inferior, because
        ::errno is not guaranteed to be well-formed.</p></li>
  </ul>

  <p><i>[
    This issue was first raised in 1999, but it slipped through 
    the cracks.
  ]</i></p>



<p><b>Proposed resolution:</b></p>
  <p>Change the Note in section 17.4.1.2p5 from</p>

    <blockquote><p>
    Note: the names defined as macros in C include the following:
    assert, errno, offsetof, setjmp, va_arg, va_end, and va_start.
    </p></blockquote>

  <p>to</p>

    <blockquote><p>
    Note: the names defined as macros in C include the following:
    assert, offsetof, setjmp, va_arg, va_end, and va_start.
    </p></blockquote>

  <p>In section 19.3, change paragraph 2 from</p>

    <blockquote><p>
    The contents are the same as the Standard C library header
    &lt;errno.h&gt;.
    </p></blockquote>

  <p>to</p>

    <blockquote><p>
    The contents are the same as the Standard C library header 
    &lt;errno.h&gt;, except that errno shall be defined as a macro.
    </p></blockquote>


<p><b>Rationale:</b></p>
<p>C++ must not leave it up to the implementation to decide whether or
not a name is a macro; it must explicitly specify exactly which names
are required to be macros.  The only one that really works is for it
to be a macro.</p>

<p><i>[Curaao: additional rationale added.]</i></p>







<hr>
<h3><a name="311"></a>311. Incorrect wording in basic_ostream class synopsis</h3>
<p><b>Section:</b> 27.7.2.1 [ostream] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Andy Sawyer <b>Opened:</b> 2001-03-21 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#ostream">issues</a> in [ostream].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>

<p>In 27.7.2.1 [ostream], the synopsis of class basic_ostream says:</p>

<pre>  // partial specializationss
  template&lt;class traits&gt;
    basic_ostream&lt;char,traits&gt;&amp; operator&lt;&lt;( basic_ostream&lt;char,traits&gt;&amp;,
                                            const char * );
</pre>

<p>Problems:</p>
<ul>
<li>Too many 's's at the end of "specializationss" </li>
<li>This is an overload, not a partial specialization</li>
</ul>



<p><b>Proposed resolution:</b></p>
<p>In the synopsis in 27.7.2.1 [ostream], remove the 
<i>// partial specializationss</i> comment.  Also remove the same 
comment (correctly spelled, but still incorrect) from the synopsis in 
27.7.2.6.4 [ostream.inserters.character].
</p>

<p><i>[
Pre-Redmond: added 27.7.2.6.4 [ostream.inserters.character] because of Martin's
comment in c++std-lib-8939.
]</i></p>







<hr>
<h3><a name="312"></a>312. Table 27 is missing headers</h3>
<p><b>Section:</b> 20 [utilities] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2001-03-29 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#utilities">issues</a> in [utilities].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>Table 27 in section 20 lists the header &lt;memory&gt; (only) for
Memory (lib.memory) but neglects to mention the headers
&lt;cstdlib&gt; and &lt;cstring&gt; that are discussed in 20.7.6 [meta.rel].</p>


<p><b>Proposed resolution:</b></p>
<p>Add &lt;cstdlib&gt; and &lt;cstring&gt; to Table 27, in the same row
as &lt;memory&gt;.</p>





<hr>
<h3><a name="315"></a>315. Bad "range" in list::unique complexity</h3>
<p><b>Section:</b> 23.3.4.4 [list.ops] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Andy Sawyer <b>Opened:</b> 2001-05-01 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#list.ops">issues</a> in [list.ops].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
23.3.4.4 [list.ops], Para 21 describes the complexity of
list::unique as: "If the range (last - first) is not empty, exactly
(last - first) -1 applications of the corresponding predicate,
otherwise no applications of the predicate)".
</p>

<p>
"(last - first)" is not a range.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change the "range" from (last - first) to [first, last).
</p>




<hr>
<h3><a name="316"></a>316. Vague text in Table 69</h3>
<p><b>Section:</b> 23.2.4 [associative.reqmts] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2001-05-04 <b>Last modified:</b> 2010-10-29</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#associative.reqmts">active issues</a> in [associative.reqmts].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#associative.reqmts">issues</a> in [associative.reqmts].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>Table 69 says this about a_uniq.insert(t):</p>

<blockquote><p>
inserts t if and only if there is no element in the container with key
equivalent to the key of t. The bool component of the returned pair 
indicates whether the insertion takes place and the iterator component of the
pair points to the element with key equivalent to the key of t.
</p></blockquote>

<p>The description should be more specific about exactly how the bool component
indicates whether the insertion takes place.</p>


<p><b>Proposed resolution:</b></p>
<p>Change the text in question to</p>

<blockquote><p>
...The bool component of the returned pair is true if and only if the insertion
takes place...
</p></blockquote>





<hr>
<h3><a name="317"></a>317. Instantiation vs. specialization of facets</h3>
<p><b>Section:</b> 22 [localization] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2001-05-04 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#localization">issues</a> in [localization].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The localization section of the standard refers to specializations of
the facet templates as instantiations even though the required facets
are typically specialized rather than explicitly (or implicitly)
instantiated. In the case of ctype&lt;char&gt; and
ctype_byname&lt;char&gt; (and the wchar_t versions), these facets are
actually required to be specialized. The terminology should be
corrected to make it clear that the standard doesn't mandate explicit
instantiation (the term specialization encompasses both explicit
instantiations and specializations).
</p>


<p><b>Proposed resolution:</b></p>
<p>
In the following paragraphs, replace all occurrences of the word
instantiation or instantiations with specialization or specializations,
respectively:
</p>

<blockquote><p>
22.1.1.1.1, p4, Table 52, 22.2.1.1, p2, 22.2.1.5, p3, 22.2.1.5.1, p5,
22.2.1.5.2, p10, 22.2.2, p2, 22.2.3.1, p1, 22.2.3.1.2, p1, p2 and p3, 
22.2.4.1, p1, 22.2.4.1.2, p1, 22,2,5, p1, 22,2,6, p2, 22.2.6.3.2, p7, and
Footnote 242.
</p></blockquote>

<p>And change the text in 22.1.1.1.1, p4 from</p>

<blockquote><p>
    An implementation is required to provide those instantiations
    for facet templates identified as members of a category, and
    for those shown in Table 52:
</p></blockquote>

<p>to</p>

<blockquote><p>
    An implementation is required to provide those specializations...
</p></blockquote>

<p><i>[Nathan will review these changes, and will look for places where
explicit specialization is necessary.]</i></p>




<p><b>Rationale:</b></p>
<p>This is a simple matter of outdated language.  The language to
describe templates was clarified during the standardization process,
but the wording in clause 22 was never updated to reflect that
change.</p>







<hr>
<h3><a name="318"></a>318. Misleading comment in definition of numpunct_byname</h3>
<p><b>Section:</b> 22.4.3.2 [locale.numpunct.byname] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2001-05-12 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>The definition of the numpunct_byname template contains the following
comment:</p>

<pre>    namespace std {
        template &lt;class charT&gt;
        class numpunct_byname : public numpunct&lt;charT&gt; {
    // this class is specialized for char and wchar_t.
        ...
</pre>

<p>There is no documentation of the specializations and it seems
conceivable that an implementation will not explicitly specialize the
template at all, but simply provide the primary template.</p>


<p><b>Proposed resolution:</b></p>
<p>Remove the comment from the text in 22.2.3.2 and from the proposed
resolution of library issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#228">228</a>.</p>




<hr>
<h3><a name="319"></a>319. Storage allocation wording confuses "Required behavior", "Requires"</h3>
<p><b>Section:</b> 18.6.1.1 [new.delete.single], 18.6.1.2 [new.delete.array] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Beman Dawes <b>Opened:</b> 2001-05-15 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#new.delete.single">issues</a> in [new.delete.single].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>The standard specifies 17.5.1.4 [structure.specifications] that "Required
behavior" elements describe "the semantics of a function definition
provided by either the implementation or a C++ program."</p>

<p>The standard specifies 17.5.1.4 [structure.specifications] that "Requires"
elements describe "the preconditions for calling the function."</p>

<p>In the sections noted below, the current wording specifies
"Required Behavior" for what are actually preconditions, and thus
should be specified as "Requires".</p>



<p><b>Proposed resolution:</b></p>

<p>In 18.6.1.1 [new.delete.single] Para 12 Change:</p>
<blockquote>
  <p>Required behavior: accept a value of ptr that is null or that was
  returned by an earlier call ...</p>
</blockquote>
<p>to:</p>
<blockquote>
  <p>Requires: the value of ptr is null or the value returned by an
  earlier call ...</p>
</blockquote>

<p>In 18.6.1.2 [new.delete.array] Para 11 Change:</p>
<blockquote>
  <p>Required behavior: accept a value of ptr that is null or that was
  returned by an earlier call ...</p>
</blockquote>
<p>to:</p>
<blockquote>
  <p>Requires: the value of ptr is null or the value returned by an
  earlier call ...</p>
</blockquote>





<hr>
<h3><a name="320"></a>320. list::assign overspecified</h3>
<p><b>Section:</b> 23.3.4.1 [list.cons] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2001-05-17 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#list.cons">issues</a> in [list.cons].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Section 23.3.4.1 [list.cons], paragraphs 6-8 specify that list assign (both forms) have
the "effects" of a call to erase followed by a call to insert.
</p>

<p>
I would like to document that implementers have the freedom to implement 
assign by other methods, as long as the end result is the same and the 
exception guarantee is as good or better than the basic guarantee.
</p>

<p>
The motivation for this is to use T's assignment operator to recycle
existing nodes in the list instead of erasing them and reallocating
them with new values.  It is also worth noting that, with careful
coding, most common cases of assign (everything but assignment with
true input iterators) can elevate the exception safety to strong if
T's assignment has a nothrow guarantee (with no extra memory cost).
Metrowerks does this.  However I do not propose that this subtlety be
standardized.  It is a QoI issue.  </p>

<p>Existing practise:
Metrowerks and SGI recycle nodes, Dinkumware and Rogue Wave don't.
</p>


<p><b>Proposed resolution:</b></p>
<p>Change 23.3.4.1 [list.cons]/7 from:</p>

<blockquote>
<p>Effects:</p>

<pre>   erase(begin(), end());
   insert(begin(), first, last);
</pre>
</blockquote>

<p>to:</p>

<blockquote>
<p>Effects: Replaces the contents of the list with the range [first, last).</p>
</blockquote>

<p>In 23.2.3 [sequence.reqmts], in Table 67 (sequence requirements), 
add two new rows:</p>
<pre>      a.assign(i,j)     void      pre: i,j are not iterators into a.
                                  Replaces elements in a with a copy
                                  of [i, j).

      a.assign(n,t)     void      pre: t is not a reference into a.
                                  Replaces elements in a with n copies
                                  of t.
</pre>

<p>Change 23.3.4.1 [list.cons]/8 from:</p>

<blockquote>
<p>Effects:</p>
<pre>   erase(begin(), end());
   insert(begin(), n, t);
</pre>
</blockquote>
<p>to:</p>

<blockquote>
<p>Effects: Replaces the contents of the list with n copies of t.</p>
</blockquote>

<p><i>[Redmond: Proposed resolution was changed slightly.  Previous
version made explicit statement about exception safety, which wasn't
consistent with the way exception safety is expressed elsewhere.
Also, the change in the sequence requirements is new.  Without that
change, the proposed resolution would have required that assignment of
a subrange would have to work.  That too would have been
overspecification; it would effectively mandate that assignment use a
temporary.  Howard provided wording.
]</i></p>


<p><i>[Curaao: Made editorial improvement in wording; changed
"Replaces elements in a with copies of elements in [i, j)."
with "Replaces the elements of a with a copy of [i, j)."
Changes not deemed serious enough to requre rereview.]</i></p>







<hr>
<h3><a name="321"></a>321. Typo in num_get</h3>
<p><b>Section:</b> 22.4.2.1.2 [facet.num.get.virtuals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Kevin Djang <b>Opened:</b> 2001-05-17 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#facet.num.get.virtuals">issues</a> in [facet.num.get.virtuals].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Section 22.2.2.1.2 at p7 states that "A length specifier is added to
the conversion function, if needed, as indicated in Table 56."
However, Table 56 uses the term "length modifier", not "length
specifier".
</p>


<p><b>Proposed resolution:</b></p>
<p>
In 22.2.2.1.2 at p7, change the text "A length specifier is added ..."
to be "A length modifier is added ..."
</p>


<p><b>Rationale:</b></p>
<p>C uses the term "length modifier".  We should be consistent.</p>






<hr>
<h3><a name="322"></a>322. iterator and const_iterator should have the same value type</h3>
<p><b>Section:</b> 23.2 [container.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2001-05-17 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#container.requirements">issues</a> in [container.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It's widely assumed that, if X is a container,
iterator_traits&lt;X::iterator&gt;::value_type and
iterator_traits&lt;X::const_iterator&gt;::value_type should both be
X::value_type.  However, this is nowhere stated.  The language in
Table 65 is not precise about the iterators' value types (it predates
iterator_traits), and could even be interpreted as saying that
iterator_traits&lt;X::const_iterator&gt;::value_type should be "const
X::value_type".
</p>

<p>Related issue: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#279">279</a>.</p>


<p><b>Proposed resolution:</b></p>
<p>In Table 65 ("Container Requirements"), change the return type for
X::iterator to "iterator type whose value type is T".  Change the
return type for X::const_iterator to "constant iterator type whose
value type is T".</p>


<p><b>Rationale:</b></p>
<p>
This belongs as a container requirement, rather than an iterator
requirement, because the whole notion of iterator/const_iterator
pairs is specific to containers' iterator.
</p>
<p>
It is existing practice that (for example) 
iterator_traits&lt;list&lt;int&gt;::const_iterator&gt;::value_type
is "int", rather than "const int".  This is consistent with
the way that const pointers are handled: the standard already 
requires that iterator_traits&lt;const int*&gt;::value_type is int.
</p>





<hr>
<h3><a name="324"></a>324. Do output iterators have value types?</h3>
<p><b>Section:</b> 24.2.4 [output.iterators] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Dave Abrahams <b>Opened:</b> 2001-06-07 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#output.iterators">issues</a> in [output.iterators].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>

<p>Table 73 suggests that output iterators have value types.  It 
requires the expression "*a = t".  Additionally, although Table 73
never lists "a = t" or "X(a) = t" in the "expressions" column, it
contains a note saying that "a = t" and "X(a) = t" have equivalent
(but nowhere specified!) semantics.</p>

<p>According to 24.1/9, t is supposed to be "a value of value type
T":</p>

    <blockquote><p>
    In the following sections, a and b denote values of X, n denotes a
    value of the difference type Distance, u, tmp, and m denote
    identifiers, r denotes a value of X&amp;, t denotes a value of
    value type T.
    </p></blockquote>

<p>Two other parts of the standard that are relevant to whether
output iterators have value types:</p>

<ul>
    <li>24.1/1 says "All iterators i support the expression *i,
    resulting in a value of some class, enumeration, or built-in type
    T, called the value type of the iterator".</li>

    <li>
    24.3.1/1, which says "In the case of an output iterator, the types
    iterator_traits&lt;Iterator&gt;::difference_type
    iterator_traits&lt;Iterator&gt;::value_type are both defined as void."
    </li>
</ul>

<p>The first of these passages suggests that "*i" is supposed to
return a useful value, which contradicts the note in 24.1.2/2 saying
that the only valid use of "*i" for output iterators is in an
expression of the form "*i = t".  The second of these passages appears
to contradict Table 73, because it suggests that "*i"'s return value
should be void.  The second passage is also broken in the case of a an
iterator type, like non-const pointers, that satisfies both the output
iterator requirements and the forward iterator requirements.</p>

<p>What should the standard say about <tt>*i</tt>'s return value when
i is an output iterator, and what should it say about that t is in the
expression "*i = t"?  Finally, should the standard say anything about
output iterators' pointer and reference types?</p>



<p><b>Proposed resolution:</b></p>
<p>24.1 p1, change</p>

<blockquote>
<p>All iterators <tt>i</tt> support the expression <tt>*i</tt>, resulting
in a value of some class, enumeration, or built-in type <tt>T</tt>,
called the value type of the iterator.</p>
</blockquote>

<p>to</p>

<blockquote>
<p>All input iterators <tt>i</tt> support the expression <tt>*i</tt>,
resulting in a value of some class, enumeration, or built-in type
<tt>T</tt>, called the value type of the iterator. All output
iterators support the expression <tt>*i = o</tt> where <tt>o</tt> is a
value of some type that is in the set of types that are <i>writable</i> to
the particular iterator type of <tt>i</tt>.
</p>
</blockquote>

<p>24.1 p9, add</p>

<blockquote>
<p><tt>o</tt> denotes a value of some type that is writable to the
output iterator.
</p>
</blockquote>

<p>Table 73, change</p>

<blockquote>
<pre>*a = t
</pre>
</blockquote>

<p>to</p>

<blockquote>
<pre>*r = o
</pre>
</blockquote>

<p>and change</p>

<blockquote>
<pre>*r++ = t
</pre>
</blockquote>

<p>to</p>

<blockquote>
<pre>*r++ = o
</pre>
</blockquote>

<p><i>[post-Redmond: Jeremy provided wording]</i></p>




<p><b>Rationale:</b></p>
<p>The LWG considered two options: change all of the language that
seems to imply that output iterators have value types, thus making it
clear that output iterators have no value types, or else define value
types for output iterator consistently.  The LWG chose the former
option, because it seems clear that output iterators were never
intended to have value types.  This was a deliberate design decision,
and any language suggesting otherwise is simply a mistake.</p>

<p>A future revision of the standard may wish to revisit this design
decision.</p>





<hr>
<h3><a name="325"></a>325. Misleading text in moneypunct&lt;&gt;::do_grouping</h3>
<p><b>Section:</b> 22.4.6.3.2 [locale.moneypunct.virtuals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2001-07-02 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.moneypunct.virtuals">issues</a> in [locale.moneypunct.virtuals].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>The Returns clause in 22.2.6.3.2, p3 says about
moneypunct&lt;charT&gt;::do_grouping()
</p>

<blockquote><p>
    Returns: A pattern defined identically as the result of
    numpunct&lt;charT&gt;::do_grouping().241)
</p></blockquote>

<p>Footnote 241 then reads</p>

<blockquote><p>
    This is most commonly the value "\003" (not "3").
</p></blockquote>

<p>
The returns clause seems to imply that the two member functions must
return an identical value which in reality may or may not be true,
since the facets are usually implemented in terms of struct std::lconv
and return the value of the grouping and mon_grouping, respectively.
The footnote also implies that the member function of the moneypunct
facet (rather than the overridden virtual functions in moneypunct_byname)
most commonly return "\003", which contradicts the C standard which
specifies the value of "" for the (most common) C locale.
</p>



<p><b>Proposed resolution:</b></p>
<p>Replace the text in Returns clause in 22.2.6.3.2, p3 with the following:</p>

<blockquote><p>
    Returns: A pattern defined identically as, but not necessarily
    equal to, the result of numpunct&lt;charT&gt;::do_grouping().241)
</p></blockquote>

<p>and replace the text in Footnote 241 with the following:</p>

<blockquote><p>
    To specify grouping by 3s the value is "\003", not "3".
</p></blockquote>


<p><b>Rationale:</b></p>
<p>
The fundamental problem is that the description of the locale facet
virtuals serves two purposes: describing the behavior of the base
class, and describing the meaning of and constraints on the behavior
in arbitrary derived classes.  The new wording makes that separation a
little bit clearer.  The footnote (which is nonnormative) is not
supposed to say what the grouping is in the "C" locale or in any other
locale. It is just a reminder that the values are interpreted as small
integers, not ASCII characters.
</p>




<hr>
<h3><a name="327"></a>327. Typo in time_get facet in table 52</h3>
<p><b>Section:</b> 22.3.1.1.1 [locale.category] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Tiki Wan <b>Opened:</b> 2001-07-06 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.category">issues</a> in [locale.category].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#447">447</a></p>
<p><b>Discussion:</b></p>
<p>The <tt>wchar_t</tt> versions of <tt>time_get</tt> and
<tt>time_get_byname</tt> are listed incorrectly in table 52,
required instantiations.  In both cases the second template
parameter is given as OutputIterator.  It should instead be
InputIterator, since these are input facets.</p>


<p><b>Proposed resolution:</b></p>
<p>
In table 52, required instantiations, in 
22.3.1.1.1 [locale.category], change</p>
<pre>    time_get&lt;wchar_t, OutputIterator&gt;
    time_get_byname&lt;wchar_t, OutputIterator&gt;
</pre>
<p>to</p>
<pre>    time_get&lt;wchar_t, InputIterator&gt;
    time_get_byname&lt;wchar_t, InputIterator&gt;
</pre>

<p><i>[Redmond: Very minor change in proposed resolution.  Original had
a typo, wchart instead of wchar_t.]</i></p>






<hr>
<h3><a name="328"></a>328. Bad sprintf format modifier in money_put&lt;&gt;::do_put()</h3>
<p><b>Section:</b> 22.4.6.2.2 [locale.money.put.virtuals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2001-07-07 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>The sprintf format string , "%.01f" (that's the digit one), in the
description of the do_put() member functions of the money_put facet in
22.2.6.2.2, p1 is incorrect. First, the f format specifier is wrong
for values of type long double, and second, the precision of 01
doesn't seem to make sense. What was most likely intended was
"%.0Lf"., that is a precision of zero followed by the L length
modifier.</p>


<p><b>Proposed resolution:</b></p>
<p>Change the format string to "%.0Lf".</p>


<p><b>Rationale:</b></p><p>Fixes an obvious typo</p>




<hr>
<h3><a name="329"></a>329. vector capacity, reserve and reallocation</h3>
<p><b>Section:</b> 23.4.1.2 [vector.capacity], 23.4.1.4 [vector.modifiers] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Anthony Williams <b>Opened:</b> 2001-07-13 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#vector.capacity">issues</a> in [vector.capacity].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There is an apparent contradiction about which circumstances can cause
a reallocation of a vector in Section 23.4.1.2 [vector.capacity] and
section 23.4.1.4 [vector.modifiers].
</p>

<p>23.4.1.2 [vector.capacity],p5 says:</p>
<blockquote><p>
Notes: Reallocation invalidates all the references, pointers, and iterators
referring to the elements in the sequence. It is guaranteed that no
reallocation takes place during insertions that happen after a call to
reserve() until the time when an insertion would make the size of the vector
greater than the size specified in the most recent call to reserve().
</p></blockquote>

<p>Which implies if I do</p>

<pre>  std::vector&lt;int&gt; vec;
  vec.reserve(23);
  vec.reserve(0);
  vec.insert(vec.end(),1);
</pre>

<p>then the implementation may reallocate the vector for the insert,
as the size specified in the previous call to reserve was zero.</p>

<p>However, the previous paragraphs (23.4.1.2 [vector.capacity], p1-2) state:</p>
<blockquote>
<p>
(capacity) Returns: The total number of elements the vector
can hold without requiring reallocation
</p>
<p>
...After reserve(), capacity() is greater or equal to the
argument of reserve if reallocation happens; and equal to the previous value
of capacity() otherwise...
</p>
</blockquote>

<p>
This implies that vec.capacity() is still 23, and so the insert()
should not require a reallocation, as vec.size() is 0. This is backed
up by 23.4.1.4 [vector.modifiers], p1:
</p>
<blockquote><p>
(insert) Notes: Causes reallocation if the new size is greater than the old
capacity.
</p></blockquote>

<p>
Though this doesn't rule out reallocation if the new size is less
than the old capacity, I think the intent is clear.
</p>



<p><b>Proposed resolution:</b></p>
<p>Change the wording of 23.4.1.2 [vector.capacity] paragraph 5 to:</p>

<blockquote><p>
Notes: Reallocation invalidates all the references, pointers, and
iterators referring to the elements in the sequence. It is guaranteed
that no reallocation takes place during insertions that happen after a
call to reserve() until the time when an insertion would make the size
of the vector greater than the value of capacity().
</p></blockquote>

<p><i>[Redmond: original proposed resolution was modified slightly.  In
the original, the guarantee was that there would be no reallocation
until the size would be greater than the value of capacity() after the
most recent call to reserve().  The LWG did not believe that the
"after the most recent call to reserve()" added any useful
information.]</i></p>




<p><b>Rationale:</b></p>
<p>There was general agreement that, when reserve() is called twice in
succession and the argument to the second invocation is smaller than
the argument to the first, the intent was for the second invocation to
have no effect.  Wording implying that such cases have an effect on
reallocation guarantees was inadvertant.</p>





<hr>
<h3><a name="331"></a>331. bad declaration of destructor for ios_base::failure</h3>
<p><b>Section:</b> 27.5.2.1.1 [ios::failure] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> PremAnand M. Rao <b>Opened:</b> 2001-08-23 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#ios::failure">issues</a> in [ios::failure].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
With the change in 17.6.4.12 [res.on.exception.handling] to state
   "An implementation may strengthen the exception-specification for a 
    non-virtual function by removing listed exceptions."
(issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#119">119</a>)
and the following declaration of ~failure() in ios_base::failure
</p>
<pre>    namespace std {
       class ios_base::failure : public exception {
       public:
           ...
           virtual ~failure();
           ...
       };
     }
</pre>
<p>the class failure cannot be implemented since in 18.7.1 [type.info] the destructor of class exception has an empty
exception specification:</p>
<pre>    namespace std {
       class exception {
       public:
         ...
         virtual ~exception() throw();
         ...
       };
     }
</pre>


<p><b>Proposed resolution:</b></p>
<p>Remove the declaration of ~failure().</p>


<p><b>Rationale:</b></p>
<p>The proposed resolution is consistent with the way that destructors
of other classes derived from <tt>exception</tt> are handled.</p>







<hr>
<h3><a name="333"></a>333. does endl imply synchronization with the device?</h3>
<p><b>Section:</b> 27.7.2.8 [ostream.manip] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> PremAnand M. Rao <b>Opened:</b> 2001-08-27 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>A footnote in 27.7.2.8 [ostream.manip] states:</p>
<blockquote><p>
    [Footnote: The effect of executing cout &lt;&lt; endl is to insert a 
     newline character in the output sequence controlled by cout, then 
     synchronize it with any external file with which it might be 
     associated. --- end foonote]
</p></blockquote>

<p>
Does the term "file" here refer to the external device?
This leads to some implementation ambiguity on systems with fully 
buffered files where a newline does not cause a flush to the device.
</p>

<p>
Choosing to sync with the device leads to significant performance
penalties for each call to endl, while not sync-ing leads to
errors under special circumstances.
</p>

<p>
I could not find any other statement that explicitly defined
the behavior one way or the other.
</p>


<p><b>Proposed resolution:</b></p>
<p>Remove footnote 300 from section 27.7.2.8 [ostream.manip].</p>


<p><b>Rationale:</b></p>
<p>We already have normative text saying what <tt>endl</tt> does: it
inserts a newline character and calls <tt>flush</tt>.  This footnote
is at best redundant, at worst (as this issue says) misleading,
because it appears to make promises about what <tt>flush</tt>
does.</p>







<hr>
<h3><a name="334"></a>334. map::operator[] specification forces inefficient implementation</h3>
<p><b>Section:</b> 23.6.1.2 [map.access] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Andrea Griffini <b>Opened:</b> 2001-09-02 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#map.access">issues</a> in [map.access].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The current standard describes map::operator[] using a
code example. That code example is however quite
inefficient because it requires several useless copies
of both the passed key_type value and of default
constructed mapped_type instances.
My opinion is that was not meant by the comitee to
require all those temporary copies. 
</p>

<p>Currently map::operator[] behaviour is specified as: </p>
<pre>  Returns:
    (*((insert(make_pair(x, T()))).first)).second.
</pre>
  
<p>
This specification however uses make_pair that is a
template function of which parameters in this case
will be deduced being of type const key_type&amp; and
const T&amp;. This will create a pair&lt;key_type,T&gt; that
isn't the correct type expected by map::insert so
another copy will be required using the template
conversion constructor available in pair to build
the required pair&lt;const key_type,T&gt; instance.
</p>

<p>If we consider calling of key_type copy constructor
and mapped_type default constructor and copy
constructor as observable behaviour (as I think we
should) then the standard is in this place requiring
two copies of a key_type element plus a default
construction and two copy construction of a mapped_type
(supposing the addressed element is already present
in the map; otherwise at least another copy
construction for each type). 
</p>

<p>A simple (half) solution would be replacing the description with:</p>
<pre>  Returns:
    (*((insert(value_type(x, T()))).first)).second.
</pre>

<p>This will remove the wrong typed pair construction that
requires one extra copy of both key and value.</p>

<p>However still the using of map::insert requires temporary
objects while the operation, from a logical point of view,
doesn't require any. </p>

<p>I think that a better solution would be leaving free an
implementer to use a different approach than map::insert
that, because of its interface, forces default constructed
temporaries and copies in this case.
The best solution in my opinion would be just requiring
map::operator[] to return a reference to the mapped_type
part of the contained element creating a default element
with the specified key if no such an element is already
present in the container. Also a logarithmic complexity
requirement should be specified for the operation.
</p>

<p>
This would allow library implementers to write alternative
implementations not using map::insert and reaching optimal
performance in both cases of the addressed element being
present or absent from the map (no temporaries at all and
just the creation of a new pair inside the container if
the element isn't present).
Some implementer has already taken this option but I think
that the current wording of the standard rules that as
non-conforming. 
</p>



<p><b>Proposed resolution:</b></p>

<p>
Replace 23.6.1.2 [map.access] paragraph 1 with
</p>
<blockquote>
<p>
-1- Effects:  If there is no key equivalent to x in the map, inserts 
value_type(x, T()) into the map.
</p>
<p>
-2- Returns: A reference to the mapped_type corresponding to x in *this.
</p>
<p>
-3- Complexity: logarithmic.
</p>
</blockquote>

<p><i>[This is the second option mentioned above.  Howard provided
wording.  We may also wish to have a blanket statement somewhere in
clause 17 saying that we do not intend the semantics of sample code
fragments to be interpreted as specifing exactly how many copies are
made.  See issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#98">98</a> for a similar problem.]</i></p>




<p><b>Rationale:</b></p>
<p>
This is the second solution described above; as noted, it is
consistent with existing practice.
</p>

<p>Note that we now need to specify the complexity explicitly, because
we are no longer defining <tt>operator[]</tt> in terms of
<tt>insert</tt>.</p>





<hr>
<h3><a name="335"></a>335. minor issue with char_traits, table 37</h3>
<p><b>Section:</b> 21.2.1 [char.traits.require] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Andy Sawyer <b>Opened:</b> 2001-09-06 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Table 37, in 21.2.1 [char.traits.require], descibes char_traits::assign
as:
</p>
<pre>  X::assign(c,d)   assigns c = d.
</pre>

<p>And para 1 says:</p>

<blockquote><p>
 [...] c and d denote values of type CharT [...]
</p></blockquote>

<p>
Naturally, if c and d are <i>values</i>, then the assignment is
(effectively) meaningless. It's clearly intended that (in the case of
assign, at least), 'c' is intended to be a reference type.
</p>

<p>I did a quick survey of the four implementations I happened to have
lying around, and sure enough they all have signatures:</p>
<pre>    assign( charT&amp;, const charT&amp; );
</pre>

<p>(or the equivalent). It's also described this way in Nico's book.
(Not to mention the synopses of char_traits&lt;char&gt; in 21.1.3.1
and char_traits&lt;wchar_t&gt; in 21.1.3.2...)
</p>


<p><b>Proposed resolution:</b></p>
<p>Add the following to 21.1.1 para 1:</p>
<blockquote><p>
 r denotes an lvalue of CharT
</p></blockquote>

<p>and change the description of assign in the table to:</p>
<pre>  X::assign(r,d)   assigns r = d
</pre>





<hr>
<h3><a name="336"></a>336. Clause 17 lack of references to deprecated headers</h3>
<p><b>Section:</b> 17 [library] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Detlef Vollmann <b>Opened:</b> 2001-09-05 <b>Last modified:</b> 2010-10-29</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>From c++std-edit-873:</p>

<p>17.6.1.2 [headers], Table 11.  In this table, the header
&lt;strstream&gt; is missing.</p>

<p>This shows a general problem: The whole clause 17 refers quite
often to clauses 18 through 27, but D.7 is also a part of the standard
library (though a deprecated one).</p>



<p><b>Proposed resolution:</b></p>

<p>To 17.6.1.2 [headers] Table 11, C++ Library Headers, add
"&lt;strstream&gt;".</p>

<p>In the following places, change "clauses 17 through 27" to "clauses
17 through 27 and Annex D":</p>

<ul>
<li>1.2 [intro.refs] Normative references/1/footnote 1</li>
<li>1.3 [intro.defs] Definitions/1</li>
<li>7 [dcl.dcl] Library introduction/9</li>
<li>17.5 [description] Method of description (Informative)/1</li>
<li>17.5.2.1.4 [character.seq] Character sequences/1/bullet 2</li>
<li>17.5.2.2 [functions.within.classes] Functions within classes/1</li>
<li>17.5.2.3 [objects.within.classes] Private members/1/(2 places)</li>
<li>17.6 [requirements] Library-wide requirements/1</li>
<li>17.6.1.2 [headers] Headers/4</li>
<li>17.6.3.6 [replacement.functions] Replacement functions/1</li>
<li>17.6.4.4 [global.functions] Global or non-member functions/2</li>
<li>17.6.4.10 [protection.within.classes] Protection within classes/1</li>
</ul>







<hr>
<h3><a name="337"></a>337. replace_copy_if's template parameter should be InputIterator</h3>
<p><b>Section:</b> 25.3.5 [alg.replace] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Detlef Vollmann <b>Opened:</b> 2001-09-07 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.replace">issues</a> in [alg.replace].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>From c++std-edit-876:</p>

<p>
In section 25.3.5 [alg.replace] before p4: The name of the first
parameter of template replace_copy_if should be "InputIterator"
instead of "Iterator".  According to 17.5.2.1 [type.descriptions] p1 the
parameter name conveys real normative meaning.
</p>


<p><b>Proposed resolution:</b></p>
<p>Change <tt>Iterator</tt> to <tt>InputIterator</tt>.</p>





<hr>
<h3><a name="338"></a>338.  is whitespace allowed between `-' and a digit?</h3>
<p><b>Section:</b> 22.4 [locale.categories] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2001-09-17 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.categories">issues</a> in [locale.categories].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
From Stage 2 processing in 22.4.2.1.2 [facet.num.get.virtuals], p8 and 9 (the
original text or the text corrected by the proposed resolution of
issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#221">221</a>) it seems clear that no whitespace is allowed
within a number, but 22.4.3.1 [locale.numpunct], p2, which gives the
format for integer and floating point values, says that whitespace is
optional between a plusminus and a sign.
</p>

<p>
The text needs to be clarified to either consistently allow or
disallow whitespace between a plusminus and a sign. It might be
worthwhile to consider the fact that the C library stdio facility does
not permit whitespace embedded in numbers and neither does the C or
C++ core language (the syntax of integer-literals is given in 2.14.2 [lex.icon], that of floating-point-literals in 2.14.4 [lex.fcon] of the C++ standard).
</p>


<p><b>Proposed resolution:</b></p>
<p>Change the first part of 22.4.3.1 [locale.numpunct] paragraph 2 from:</p>
<blockquote>
<p>
The syntax for number formats is as follows, where <tt>digit</tt>
represents the radix set specified by the <tt>fmtflags</tt> argument
value, <tt>whitespace</tt> is as determined by the facet
<tt>ctype&lt;charT&gt;</tt> (22.2.1.1), and <tt>thousands-sep</tt> and
<tt>decimal-point</tt> are the results of corresponding
<tt>numpunct&lt;charT&gt;</tt> members.  Integer values have the
format:
</p>
<pre>  integer   ::= [sign] units
  sign      ::= plusminus [whitespace]
  plusminus ::= '+' | '-'
  units     ::= digits [thousands-sep units]
  digits    ::= digit [digits]
</pre>
</blockquote>
<p>to:</p>
<blockquote>
<p>
The syntax for number formats is as follows, where <tt>digit</tt>
represents the radix set specified by the <tt>fmtflags</tt> argument
value, and <tt>thousands-sep</tt> and <tt>decimal-point</tt> are the
results of corresponding <tt>numpunct&lt;charT&gt;</tt> members.
Integer values have the format:
</p>
<pre>  integer   ::= [sign] units
  sign      ::= plusminus
  plusminus ::= '+' | '-'
  units     ::= digits [thousands-sep units]
  digits    ::= digit [digits]
</pre>
</blockquote>


<p><b>Rationale:</b></p>
<p>It's not clear whether the format described in 22.4.3.1 [locale.numpunct] paragraph 2 has any normative weight: nothing in the
standard says how, or whether, it's used.  However, there's no reason
for it to differ gratuitously from the very specific description of
numeric processing in 22.4.2.1.2 [facet.num.get.virtuals].  The proposed
resolution removes all mention of "whitespace" from that format.</p>





<hr>
<h3><a name="339"></a>339. definition of bitmask type restricted to clause 27</h3>
<p><b>Section:</b> 22.4.1 [category.ctype], 17.5.2.1.3 [bitmask.types] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2001-09-17 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#category.ctype">issues</a> in [category.ctype].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The ctype_category::mask type is declared to be an enum in 22.4.1 [category.ctype] with p1 then stating that it is a bitmask type, most
likely referring to the definition of bitmask type in 17.5.2.1.3 [bitmask.types], p1. However, the said definition only applies to
clause 27, making the reference in 22.2.1 somewhat dubious.
</p>


<p><b>Proposed resolution:</b></p>
<p>Clarify 17.3.2.1.2, p1 by changing the current text from</p>
    <blockquote><p>
    Several types defined in clause 27 are bitmask types. Each bitmask type
    can be implemented as an enumerated type that overloads certain operators,
    as an integer type, or as a bitset (20.5 [template.bitset]).
    </p></blockquote>
<p>to read</p>
    <blockquote><p>
    Several types defined in clauses lib.language.support through 
    lib.input.output and Annex D are bitmask types. Each bitmask type can
    be implemented as an enumerated type that overloads certain operators,
    as an integer  type, or as a bitset (lib.template.bitset).
    </p></blockquote>

<p>
Additionally, change the definition in 22.2.1 to adopt the same
convention as in clause 27 by replacing the existing text with the
following (note, in particluar, the cross-reference to 17.3.2.1.2 in
22.2.1, p1):
</p>

<blockquote>
<p>22.2.1 The ctype category [lib.category.ctype]</p>
<pre>namespace std {
    class ctype_base {
    public:
        typedef <b><i>T</i></b> mask;

        // numeric values are for exposition only.
        static const mask space = 1 &lt;&lt; 0;
        static const mask print = 1 &lt;&lt; 1;
        static const mask cntrl = 1 &lt;&lt; 2;
        static const mask upper = 1 &lt;&lt; 3;
        static const mask lower = 1 &lt;&lt; 4;
        static const mask alpha = 1 &lt;&lt; 5;
        static const mask digit = 1 &lt;&lt; 6;
        static const mask punct = 1 &lt;&lt; 7;
        static const mask xdigit = 1 &lt;&lt; 8;
        static const mask alnum = alpha | digit;
        static const mask graph = alnum | punct;
    };
}
</pre>

<p>The type <tt>mask</tt> is a bitmask type (17.5.2.1.3 [bitmask.types]).</p>
</blockquote>

<p><i>[Curaao: The LWG notes that T above should be bold-italics to be
consistent with the rest of the standard.]</i></p>









<hr>
<h3><a name="340"></a>340. interpretation of <tt>has_facet&lt;Facet&gt;(loc)</tt></h3>
<p><b>Section:</b> 22.3.1.1.1 [locale.category] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2001-09-18 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.category">issues</a> in [locale.category].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It's unclear whether 22.1.1.1.1, p3 says that
<tt>has_facet&lt;Facet&gt;(loc)</tt> returns true for any <tt>Facet</tt>
from Table 51 or whether it includes Table 52 as well:
</p>

<blockquote><p>
For any locale <tt>loc</tt> either constructed, or returned by
locale::classic(), and any facet <tt>Facet</tt> that is a member of a
standard category, <tt>has_facet&lt;Facet&gt;(loc)</tt> is true. Each
locale member function which takes a <tt>locale::category</tt>
argument operates on the corresponding set of facets.
</p></blockquote>

<p>
It seems that it comes down to which facets are considered to be members of a
standard category. Intuitively, I would classify all the facets in Table 52 as
members of their respective standard categories, but there are an unbounded set
of them...
</p>

<p>
The paragraph implies that, for instance, <tt>has_facet&lt;num_put&lt;C,
OutputIterator&gt; &gt;(loc)</tt> must always return true. I don't think that's
possible. If it were, then <tt>use_facet&lt;num_put&lt;C, OutputIterator&gt;
&gt;(loc)</tt> would have to return a reference to a distinct object for each
valid specialization of <tt>num_put&lt;C, OutputIteratory&gt;</tt>, which is
clearly impossible.
</p>

<p>
On the other hand, if none of the facets in Table 52 is a member of a standard
category then none of the locale member functions that operate on entire
categories of facets will work properly.
</p>

<p>
It seems that what p3 should mention that it's required (permitted?)
to hold only for specializations of <tt>Facet</tt> from Table 52 on
<tt>C</tt> from the set { <tt>char</tt>, <tt>wchar_t</tt> }, and
<tt>InputIterator</tt> and <tt>OutputIterator</tt> from the set of
{
{i,o}<tt>streambuf_iterator</tt>&lt;{<tt>char</tt>,<tt>wchar_t</tt>}<tt>&gt;</tt>
}.
</p>


<p><b>Proposed resolution:</b></p>
<p>In 22.3.1.1.1 [locale.category], paragraph 3, change
"that is a member of a standard category" to "shown in Table 51".</p>


<p><b>Rationale:</b></p>
<p>The facets in Table 52 are an unbounded set.  Locales should not be
required to contain an infinite number of facets.</p> 

<p>It's not necessary to talk about which values of InputIterator and
OutputIterator must be supported.  Table 51 already contains a
complete list of the ones we need.</p>






<hr>
<h3><a name="341"></a>341. Vector reallocation and swap</h3>
<p><b>Section:</b> 23.4.1.2 [vector.capacity] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Anthony Williams <b>Opened:</b> 2001-09-27 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#vector.capacity">issues</a> in [vector.capacity].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>It is a common idiom to reduce the capacity of a vector by swapping it with
an empty one:</p>
<pre>  std::vector&lt;SomeType&gt; vec;
  // fill vec with data
  std::vector&lt;SomeType&gt;().swap(vec);
  // vec is now empty, with minimal capacity
</pre>

<p>However, the wording of 23.4.1.2 [vector.capacity]paragraph 5 prevents
the capacity of a vector being reduced, following a call to
reserve(). This invalidates the idiom, as swap() is thus prevented
from reducing the capacity. The proposed wording for issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#329">329</a> does not affect this.  Consequently, the example above
requires the temporary to be expanded to cater for the contents of
vec, and the contents be copied across. This is a linear-time
operation.</p>

<p>However, the container requirements state that swap must have constant
complexity (23.2 [container.requirements] note to table 65).</p>

<p>This is an important issue, as reallocation affects the validity of
references and iterators.</p>

<p>If the wording of 23.2.4.2p5 is taken to be the desired intent, then
references and iterators remain valid after a call to swap, if they refer to
an element before the new end() of the vector into which they originally
pointed, in which case they refer to the element at the same index position.
Iterators and references that referred to an element whose index position
was beyond the new end of the vector are invalidated.</p>

<p>If the note to table 65 is taken as the desired intent, then there are two
possibilities with regard to iterators and references:</p>

<ol>
<li>All Iterators and references into both vectors are invalidated.</li>
<li>Iterators and references into either vector remain valid, and remain
pointing to the same element. Consequently iterators and references that
referred to one vector now refer to the other, and vice-versa.</li>
</ol>


<p><b>Proposed resolution:</b></p>
<p>Add a new paragraph after 23.4.1.2 [vector.capacity] paragraph 5:</p>
<blockquote>
<pre>  void swap(vector&lt;T,Allocator&gt;&amp; x);
</pre>
<p><b>Effects:</b> Exchanges the contents and capacity() of <tt>*this</tt>
with that of <tt>x</tt>.</p>
<p><b>Complexity:</b> Constant time.</p>
</blockquote>

<p><i>[This solves the problem reported for this issue.  We may also
have a problem with a circular definition of swap() for other
containers.]</i></p>




<p><b>Rationale:</b></p>
<p>
swap should be constant time.  The clear intent is that it should just
do pointer twiddling, and that it should exchange all properties of
the two vectors, including their reallocation guarantees.
</p>





<hr>
<h3><a name="345"></a>345. type tm in &lt;cwchar&gt;</h3>
<p><b>Section:</b> 21.7 [c.strings] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Clark Nelson <b>Opened:</b> 2001-10-19 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#c.strings">issues</a> in [c.strings].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
C99, and presumably amendment 1 to C90, specify that &lt;wchar.h&gt;
declares struct tm as an incomplete type. However, table 48 in 21.7 [c.strings] does not mention the type tm as being declared in
&lt;cwchar&gt;. Is this omission intentional or accidental?
</p>


<p><b>Proposed resolution:</b></p>
<p>In section 21.7 [c.strings], add "tm" to table 48.</p>





<hr>
<h3><a name="346"></a>346. Some iterator member functions should be const</h3>
<p><b>Section:</b> X [iterator.concepts] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Jeremy Siek <b>Opened:</b> 2001-10-20 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#iterator.concepts">issues</a> in [iterator.concepts].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>Iterator member functions and operators that do not change the state
of the iterator should be defined as const member functions or as
functions that take iterators either by const reference or by
value. The standard does not explicitly state which functions should
be const.  Since this a fairly common mistake, the following changes
are suggested to make this explicit.</p>

<p>The tables almost indicate constness properly through naming: r
for non-const and a,b for const iterators. The following changes
make this more explicit and also fix a couple problems.</p>


<p><b>Proposed resolution:</b></p>
<p>In X [iterator.concepts] Change the first section of p9 from
"In the following sections, a and b denote values of X..." to
"In the following sections, a and b denote values of type const X...".</p>

<p>In Table 73, change</p>
<pre>    a-&gt;m   U&amp;         ...
</pre>

<p>to</p>

<pre>    a-&gt;m   const U&amp;   ...
    r-&gt;m   U&amp;         ...
</pre>

<p>In Table 73 expression column, change</p>

<pre>    *a = t
</pre>

<p>to</p>

<pre>    *r = t
</pre>

<p><i>[Redmond: The container requirements should be reviewed to see if
the same problem appears there.]</i></p>







<hr>
<h3><a name="347"></a>347. locale::category and bitmask requirements</h3>
<p><b>Section:</b> 22.3.1.1.1 [locale.category] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> P.J. Plauger, Nathan Myers <b>Opened:</b> 2001-10-23 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.category">issues</a> in [locale.category].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 22.3.1.1.1 [locale.category] paragraph 1, the category members
are described as bitmask elements.  In fact, the bitmask requirements
in 17.5.2.1.3 [bitmask.types] don't seem quite right: <tt>none</tt>
and <tt>all</tt> are bitmask constants, not bitmask elements.</p>

<p>In particular, the requirements for <tt>none</tt> interact poorly
with the requirement that the LC_* constants from the C library must
be recognizable as C++ locale category constants.  LC_* values should
not be mixed with these values to make category values.</p>

<p>We have two options for the proposed resolution.  Informally:
option 1 removes the requirement that LC_* values be recognized as
category arguments.  Option 2 changes the category type so that this
requirement is implementable, by allowing <tt>none</tt> to be some
value such as 0x1000 instead of 0.</p>

<p>Nathan writes: "I believe my proposed resolution [Option 2] merely
re-expresses the status quo more clearly, without introducing any
changes beyond resolving the DR.</p>



<p><b>Proposed resolution:</b></p>
<p>Replace the first two paragraphs of 22.3.1.1 [locale.types] with:</p>
<blockquote>
<pre>    typedef int category;
</pre>

<p>Valid category values include the <tt>locale</tt> member bitmask
elements <tt>collate</tt>, <tt>ctype</tt>, <tt>monetary</tt>,
<tt>numeric</tt>, <tt>time</tt>, and <tt>messages</tt>, each of which
represents a single locale category. In addition, <tt>locale</tt> member
bitmask constant <tt>none</tt> is defined as zero and represents no
category. And locale member bitmask constant <tt>all</tt> is defined such that
the expression</p>
<pre>    (collate | ctype | monetary | numeric | time | messages | all) == all
</pre>
<p>
is <tt>true</tt>, and represents the union of all categories.  Further
the expression <tt>(X | Y)</tt>, where <tt>X</tt> and <tt>Y</tt> each
represent a single category, represents the union of the two
categories.
</p>

<p>
<tt>locale</tt> member functions expecting a <tt>category</tt>
argument require one of the <tt>category</tt> values defined above, or
the union of two or more such values. Such a <tt>category</tt>
argument identifies a set of locale categories. Each locale category,
in turn, identifies a set of locale facets, including at least those
shown in Table 51:
</p>
</blockquote>
<p><i>[Curaao: need input from locale experts.]</i></p>




<p><b>Rationale:</b></p>

<p>The LWG considered, and rejected, an alternate proposal (described
  as "Option 2" in the discussion).  The main reason for rejecting it
  was that library implementors were concerened about implementation
  difficult, given that getting a C++ library to work smoothly with a
  separately written C library is already a delicate business.  Some
  library implementers were also concerned about the issue of adding
  extra locale categories.</p>

<blockquote>
<p><b>Option 2:</b> <br>
Replace the first paragraph of 22.3.1.1 [locale.types] with:</p>
<blockquote>
<p>
Valid category values include the enumerated values.  In addition, the
result of applying commutative operators | and &amp; to any two valid 
values is valid, and results in the setwise union and intersection, 
respectively, of the argument categories.  The values <tt>all</tt> and 
<tt>none</tt> are defined such that for any valid value <tt>cat</tt>, the
expressions <tt>(cat | all == all)</tt>, <tt>(cat &amp; all == cat)</tt>,
<tt>(cat | none == cat)</tt> and <tt>(cat &amp; none == none)</tt> are 
true.  For non-equal values <tt>cat1</tt> and <tt>cat2</tt> of the
remaining enumerated values, <tt>(cat1 &amp; cat2 == none)</tt> is true.
For any valid categories <tt>cat1</tt> and <tt>cat2</tt>, the result
of <tt>(cat1 &amp; ~cat2)</tt> is valid, and equals the setwise union of 
those categories found in <tt>cat1</tt> but not found in <tt>cat2</tt>.
[Footnote: it is not required that <tt>all</tt> equal the setwise union
of the other enumerated values; implementations may add extra categories.]
</p>
</blockquote>
</blockquote>





<hr>
<h3><a name="349"></a>349. Minor typographical error in ostream_iterator</h3>
<p><b>Section:</b> 24.6.2 [ostream.iterator] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Andy Sawyer <b>Opened:</b> 2001-10-24 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>24.5.2 [lib.ostream.iterator] states:</p>
<pre>    [...]

    private:
    // basic_ostream&lt;charT,traits&gt;* out_stream; exposition only
    // const char* delim; exposition only
</pre>

<p>Whilst it's clearly marked "exposition only", I suspect 'delim'
should be of type 'const charT*'.</p>


<p><b>Proposed resolution:</b></p>
<p>
In 24.6.2 [ostream.iterator], replace <tt>const char* delim</tt> with
<tt>const charT* delim</tt>.
</p>





<hr>
<h3><a name="352"></a>352. missing fpos requirements</h3>
<p><b>Section:</b> 21.2.2 [char.traits.typedefs] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2001-12-02 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#char.traits.typedefs">issues</a> in [char.traits.typedefs].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<i>(1)</i>
There are no requirements on the <tt>stateT</tt> template parameter of
<tt>fpos</tt> listed in 27.4.3. The interface appears to require that
the type be at least Assignable and CopyConstructible (27.4.3.1, p1),
and I think also DefaultConstructible (to implement the operations in
Table 88).
</p>
<p>
21.1.2, p3, however, only requires that
<tt>char_traits&lt;charT&gt;::state_type</tt> meet the requirements of
CopyConstructible types.
</p>
<p>
<i>(2)</i>
Additionally, the <tt>stateT</tt> template argument has no
corresponding typedef in fpos which might make it difficult to use in
generic code.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Modify 21.1.2, p4 from
</p>
<p>
    Requires: <tt>state_type</tt> shall meet the requirements of
              CopyConstructible types (20.1.3).
</p>
<p>
    Requires: state_type shall meet the requirements of Assignable
              (23.1, p4), CopyConstructible (20.1.3), and
              DefaultConstructible  (20.1.4) types.
</p>



<p><b>Rationale:</b></p>
<p>The LWG feels this is two issues, as indicated above. The first is
a defect---std::basic_fstream is unimplementable without these
additional requirements---and the proposed resolution fixes it.  The
second is questionable; who would use that typedef?  The class
template fpos is used only in a very few places, all of which know the
state type already.  Unless motivation is provided, the second should
be considered NAD.</p>





<hr>
<h3><a name="353"></a>353. <tt>std::pair</tt> missing template assignment</h3>
<p><b>Section:</b> 20.3.5 [pairs] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2001-12-02 <b>Last modified:</b> 2010-11-19</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#pairs">issues</a> in [pairs].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The class template <tt>std::pair</tt> defines a template ctor (20.2.2, p4) but
no template assignment operator. This may lead to inefficient code since
assigning an object of <tt>pair&lt;C, D&gt;</tt> to <tt>pair&lt;A, B&gt;</tt>
where the types <tt>C</tt> and <tt>D</tt> are distinct from but convertible to
<tt>A</tt> and <tt>B</tt>, respectively, results in a call to the template copy
ctor to construct an unnamed temporary of type <tt>pair&lt;A, B&gt;</tt>
followed by an ordinary (perhaps implicitly defined) assignment operator,
instead of just a straight assignment.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add the following declaration to the definition of <tt>std::pair</tt>:
</p>
<pre>    template&lt;class U, class V&gt;
    pair&amp; operator=(const pair&lt;U, V&gt; &amp;p);
</pre>
<p>
And also add a paragraph describing the effects of the function template to the
end of 20.2.2:
</p>
<pre>    template&lt;class U, class V&gt;
    pair&amp; operator=(const pair&lt;U, V&gt; &amp;p);
</pre>
<p>
    <b>Effects</b>: <tt>first = p.first;</tt>
                    <tt>second = p.second;</tt>
    <b>Returns</b>: <tt>*this</tt>
</p>

<p><i>[Curaao: There is no indication this is was anything other than
a design decision, and thus NAD.&nbsp; May be appropriate for a future
standard.]</i></p>


<p><i>[
Pre Bellevue:  It was recognized that this was taken care of by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1856.html">N1856</a>,
and thus moved from NAD Future to <del>NAD Editorial</del><ins>Resolved</ins>.
]</i></p>






<hr>
<h3><a name="354"></a>354. Associative container lower/upper bound requirements</h3>
<p><b>Section:</b> 23.2.4 [associative.reqmts] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Hans Aberg <b>Opened:</b> 2001-12-17 <b>Last modified:</b> 2010-10-29</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#associative.reqmts">active issues</a> in [associative.reqmts].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#associative.reqmts">issues</a> in [associative.reqmts].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Discussions in the thread "Associative container lower/upper bound
requirements" on comp.std.c++ suggests that there is a defect in the
C++ standard, Table 69 of section 23.1.2, "Associative containers",
[lib.associative.reqmts].  It currently says:</p>

<blockquote>
<p>
a.find(k): returns an iterator pointing to an element with the key equivalent to
k, or a.end() if such an element is not found.
</p>

<p>
a.lower_bound(k): returns an iterator pointing to the first element with
key not less than k.
</p>

<p>
a.upper_bound(k): returns an iterator pointing to the first element with
key greater than k.
</p>
</blockquote>

<p>
We have "or a.end() if such an element is not found" for
<tt>find</tt>, but not for <tt>upper_bound</tt> or
<tt>lower_bound</tt>.  As the text stands, one would be forced to
insert a new element into the container and return an iterator to that
in case the sought iterator does not exist, which does not seem to be
the intention (and not possible with the "const" versions).
</p>


<p><b>Proposed resolution:</b></p>

<p>Change Table 69 of section 23.2.4 [associative.reqmts] indicated entries
to:</p>

<blockquote>
<p>
a.lower_bound(k): returns an iterator pointing to the first element with
key not less than k, or a.end() if such an element is not found.
</p>

<p>
a.upper_bound(k): returns an iterator pointing to the first element with
key greater than k, or a.end() if such an element is not found.
</p>
</blockquote>

<p><i>[Curaao: LWG reviewed PR.]</i></p>








<hr>
<h3><a name="355"></a>355. Operational semantics for a.back()</h3>
<p><b>Section:</b> 23.2.3 [sequence.reqmts] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Yaroslav Mironov <b>Opened:</b> 2002-01-23 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#sequence.reqmts">issues</a> in [sequence.reqmts].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>

<p>Table 68 "Optional Sequence Operations" in 23.1.1/12
specifies operational semantics for "a.back()" as
"*--a.end()", which may be ill-formed <i>[because calling
operator-- on a temporary (the return) of a built-in type is
ill-formed]</i>, provided a.end() returns a simple pointer rvalue
(this is almost always the case for std::vector::end(), for
example). Thus, the specification is not only incorrect, it
demonstrates a dangerous construct: "--a.end()" may
successfully compile and run as intended, but after changing the type
of the container or the mode of compilation it may produce
compile-time error. </p>



<p><b>Proposed resolution:</b></p>
<p>Change the specification in table 68 "Optional Sequence
Operations" in 23.1.1/12 for "a.back()" from</p>


<blockquote><pre>*--a.end()
</pre></blockquote>

<p>to</p>

<blockquote><pre>  { iterator tmp = a.end(); --tmp; return *tmp; }
</pre></blockquote>

<p>and the specification for "a.pop_back()" from</p>

<blockquote><pre>a.erase(--a.end())
</pre></blockquote>

<p>to</p>

<blockquote><pre>  { iterator tmp = a.end(); --tmp; a.erase(tmp); }
</pre></blockquote>

<p><i>[Curaao: LWG changed PR from "{ X::iterator tmp =
a.end(); return *--tmp; }" to "*a.rbegin()", and from
"{ X::iterator tmp = a.end(); a.erase(--tmp); }" to
"a.erase(rbegin())".]</i></p>


<p><i>[There is a second possible defect; table 68 "Optional
Sequence Operations" in the "Operational Semantics"
column uses operations present only in the "Reversible
Container" requirements, yet there is no stated dependency
between these separate requirements tables. Ask in Santa Cruz if the
LWG would like a new issue opened.]</i></p>


<p><i>[Santa Cruz: the proposed resolution is even worse than what's in
  the current standard: erase is undefined for reverse iterator.  If
  we're going to make the change, we need to define a temporary and
  use operator--.  Additionally, we don't know how prevalent this is:
  do we need to make this change in more than one place?  Martin has
  volunteered to review the standard and see if this problem occurs
  elsewhere.]</i></p>


<p><i>[Oxford: Matt provided new wording to address the concerns raised
  in Santa Cruz.  It does not appear that this problem appears
  anywhere else in clauses 23 or 24.]</i></p>


<p><i>[Kona: In definition of operational semantics of back(), change
"*tmp" to "return *tmp;"]</i></p>







<hr>
<h3><a name="358"></a>358. interpreting <tt>thousands_sep</tt> after a <tt>decimal_point</tt></h3>
<p><b>Section:</b> 22.4.2.1.2 [facet.num.get.virtuals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2002-03-12 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#facet.num.get.virtuals">issues</a> in [facet.num.get.virtuals].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I don't think <tt>thousands_sep</tt> is being treated correctly after
decimal_point has been seen. Since grouping applies only to the
integral part of the number, the first such occurrence should, IMO,
terminate Stage 2. (If it does not terminate it, then 22.2.2.1.2, p12
and 22.2.3.1.2, p3 need to explain how <tt>thousands_sep</tt> is to be
interpreted in the fractional part of a number.)
</p>

<p>
The easiest change I can think of that resolves this issue would be
something like below.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change the first sentence of 22.2.2.1.2, p9 from
</p>

<blockquote><p>
    If discard is true then the position of the character is
    remembered, but the character is otherwise ignored. If it is not
    discarded, then a check is made to determine if c is allowed as
    the next character of an input field of the conversion specifier
    returned by stage 1. If so it is accumulated.
</p></blockquote>

<p>to</p>

<blockquote><p>
    If <tt>discard</tt> is true, then if <tt>'.'</tt> has not yet been
    accumulated, then the position of the character is remembered, but
    the character is otherwise ignored. Otherwise, if <tt>'.'</tt> has
    already been accumulated, the character is discarded and Stage 2
     terminates. ...
</p></blockquote>



<p><b>Rationale:</b></p>
<p>We believe this reflects the intent of the Standard.  Thousands sep
  characters after the decimal point are not useful in any locale.
  Some formatting conventions do group digits that follow the decimal
  point, but they usually introduce a different grouping character
  instead of reusing the thousand sep character.  If we want to add
  support for such conventions, we need to do so explicitly.</p>






<hr>
<h3><a name="359"></a>359. num_put&lt;&gt;::do_put (..., bool) undocumented</h3>
<p><b>Section:</b> 22.4.2.2.1 [facet.num.put.members] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2002-03-12 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>22.2.2.2.1, p1:</p>

    <pre>    iter_type put (iter_type out, ios_base&amp; str, char_type fill,
                   bool val) const;
    ...

    1   Returns: do_put (out, str, fill, val).
    </pre>

<p>AFAICS, the behavior of do_put (..., bool) is not documented anywhere,
however, 22.2.2.2.2, p23:</p>

<blockquote>
<pre>iter_type put (iter_type out, ios_base&amp; str, char_type fill,
               bool val) const;
</pre>


        <p>Effects: If (str.flags() &amp; ios_base::boolalpha) == 0 then do
             out = do_put(out, str, fill, (int)val)
           Otherwise do</p>
<pre>             string_type s =
                 val ? use_facet&lt;ctype&lt;charT&gt; &gt;(loc).truename()
                     : use_facet&lt;ctype&lt;charT&gt; &gt;(loc).falsename();
</pre>
           <p>and then insert the characters of s into out. <i>out</i>.</p>
</blockquote>

<p>
This means that the bool overload of <tt>do_put()</tt> will never be called,
which contradicts the first paragraph. Perhaps the declaration
should read <tt>do_put()</tt>, and not <tt>put()</tt>?
</p>

<p>
Note also that there is no <b>Returns</b> clause for this function, which
should probably be corrected, just as should the second occurrence
of <i>"out."</i> in the text.
</p>

<p>
I think the least invasive change to fix it would be something like
the following:
</p>


<p><b>Proposed resolution:</b></p>
<p>In 22.4.2.2.2 [facet.num.put.virtuals], just above paragraph 1, remove
  the <tt>bool</tt> overload.</p>

<p>
In 22.4.2.2.2 [facet.num.put.virtuals], p23, make the following changes
</p>

<blockquote><p>
     Replace <tt>put()</tt> with <tt>do_put()</tt> in the declaration
     of the member function.
</p></blockquote>

<blockquote><p>
    Change the <b>Effects</b> clause to a <b>Returns</b> clause (to
    avoid the requirement to call <tt>do_put(..., int)</tt> from <tt>
    do_put (..., bool))</tt>
    like so:
</p></blockquote>

<blockquote><p>
    23   <b>Returns</b>: If <tt>(str.flags() &amp;
         ios_base::boolalpha) == 0</tt> then
         <tt>do_put (out, str, fill, (long)val)</tt>
         Otherwise the function obtains a string <tt>s</tt> as if by</p>
<pre>             string_type s =
                val ? use_facet&lt;ctype&lt;charT&gt; &gt;(loc).truename()
                    : use_facet&lt;ctype&lt;charT&gt; &gt;(loc).falsename();
</pre>
         <p>and then inserts each character <tt>c</tt> of s into out via
           <tt>*out++ = c</tt>
         and returns <tt>out</tt>.</p>
</blockquote>



<p><b>Rationale:</b></p><p>
This fixes a couple of obvious typos, and also fixes what appears to
be a requirement of gratuitous inefficiency.
</p>




<hr>
<h3><a name="360"></a>360. locale mandates inefficient implementation</h3>
<p><b>Section:</b> 22.3.1 [locale] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2002-03-12 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale">issues</a> in [locale].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
22.1.1, p7 (copied below) allows iostream formatters and extractors
to make assumptions about the values returned from facet members.
However, such assumptions are apparently not guaranteed to hold
in other cases (e.g., when the facet members are being called directly
rather than as a result of iostream calls, or between successive
calls to the same iostream functions with no interevening calls to
<tt>imbue()</tt>, or even when the facet member functions are called
from other member functions of other facets). This restriction
prevents locale from being implemented efficiently.
</p>


<p><b>Proposed resolution:</b></p>
<p>Change the first sentence in 22.1.1, p7 from</p>
<blockquote><p>
    In successive calls to a locale facet member function during
    a call to an iostream inserter or extractor or a streambuf member
    function, the returned result shall be identical. [Note: This
    implies that such results may safely be reused without calling
    the locale facet member function again, and that member functions
    of iostream classes cannot safely call <tt>imbue()</tt>
    themselves, except as specified elsewhere. --end note]
</p></blockquote>

<p>to</p>

<blockquote><p>
    In successive calls to a locale facet member function on a facet
    object installed in the same locale, the returned result shall be
    identical. ...
</p></blockquote>



<p><b>Rationale:</b></p>
<p>This change is reasonable becuase it clarifies the intent of this
  part of the standard.</p>





<hr>
<h3><a name="362"></a>362. bind1st/bind2nd type safety</h3>
<p><b>Section:</b> D.11 [depr.lib.binders] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Andrew Demkin <b>Opened:</b> 2002-04-26 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#depr.lib.binders">issues</a> in [depr.lib.binders].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The definition of bind1st() (D.11 [depr.lib.binders]) can result in
the construction of an unsafe binding between incompatible pointer
types. For example, given a function whose first parameter type is
'pointer to T', it's possible without error to bind an argument of
type 'pointer to U' when U does not derive from T:
</p>
<pre>   foo(T*, int);

   struct T {};
   struct U {};

   U u;

   int* p;
   int* q;

   for_each(p, q, bind1st(ptr_fun(foo), &amp;u));    // unsafe binding
</pre>

<p>
The definition of bind1st() includes a functional-style conversion to
map its argument to the expected argument type of the bound function
(see below):
</p>
<pre>  typename Operation::first_argument_type(x)
</pre>

<p>
A functional-style conversion (D.11 [depr.lib.binders]) is defined to be
semantically equivalent to an explicit cast expression (D.11 [depr.lib.binders]), which may (according to 5.4, paragraph 5) be interpreted
as a reinterpret_cast, thus masking the error.
</p>

<p>The problem and proposed change also apply to D.11 [depr.lib.binders].</p>


<p><b>Proposed resolution:</b></p>
<p>Add this sentence to the end of D.11 [depr.lib.binders]/1:
  "Binders <tt>bind1st</tt> and <tt>bind2nd</tt> are deprecated in
  favor of <tt>std::tr1::bind</tt>."</p>

<p>(Notes to editor: (1) when and if tr1::bind is incorporated into
  the standard, "std::tr1::bind" should be changed to "std::bind". (2)
  20.5.6 should probably be moved to Annex D.</p>


<p><b>Rationale:</b></p>
<p>There is no point in fixing bind1st and bind2nd.  tr1::bind is a
  superior solution.  It solves this problem and others.</p>





<hr>
<h3><a name="363"></a>363. Missing exception specification in 27.4.2.1.1</h3>
<p><b>Section:</b> 27.5.2.1.1 [ios::failure] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Walter Brown and Marc Paterno <b>Opened:</b> 2002-05-20 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#ios::failure">issues</a> in [ios::failure].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The destructor of ios_base::failure should have an empty throw
specification, because the destructor of its base class, exception, is
declared in this way.
</p>


<p><b>Proposed resolution:</b></p>
<p>Change the destructor to</p>
<pre>  virtual ~failure() throw();
</pre>


<p><b>Rationale:</b></p>
<p>Fixes an obvious glitch.  This is almost editorial.</p>





<hr>
<h3><a name="364"></a>364. Inconsistent wording in 27.5.2.4.2</h3>
<p><b>Section:</b> 27.6.2.4.2 [streambuf.virt.buffer] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Walter Brown, Marc Paterno <b>Opened:</b> 2002-05-10 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#streambuf.virt.buffer">issues</a> in [streambuf.virt.buffer].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
27.6.2.4.2 [streambuf.virt.buffer] paragraph 1 is inconsistent with the Effects
clause for seekoff.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Make this paragraph, the Effects clause for setbuf, consistent in wording
with the Effects clause for seekoff in paragraph 3 by amending paragraph 1
to indicate the purpose of setbuf:
</p>

<p>Original text:</p>

<blockquote><p>
1 Effects: Performs an operation that is defined separately for each
class derived from basic_streambuf in this clause (27.7.1.3, 27.8.1.4).
</p></blockquote>

<p>Proposed text:</p>

<blockquote><p>
1 Effects: Influences stream buffering in a way that is defined separately
for each class derived from basic_streambuf in this clause
(27.7.1.3, 27.8.1.4).
</p></blockquote>



<p><b>Rationale:</b></p>
<p>The LWG doesn't believe there is any normative difference between
  the existing wording and what's in the proposed resolution, but the
  change may make the intent clearer.</p>





<hr>
<h3><a name="365"></a>365. Lack of const-qualification in clause 27</h3>
<p><b>Section:</b> 27 [input.output] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Walter Brown, Marc Paterno <b>Opened:</b> 2002-05-10 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#input.output">issues</a> in [input.output].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Some stream and streambuf member functions are declared non-const,
even thought they appear only to report information rather than to
change an object's logical state.  They should be declared const.  See
document N1360 for details and rationale.
</p>

<p>The list of member functions under discussion: <tt>in_avail</tt>,
<tt>showmanyc</tt>, <tt>tellg</tt>, <tt>tellp</tt>, <tt>is_open</tt>.</p>

<p>Related issue: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#73">73</a></p>



<p><b>Proposed resolution:</b></p>
<p>In 27.8.1.5, 27.8.1.7, 27.8.1.8, 27.8.1.10, 27.8.1.11, and 27.8.1.13</p>
<p>Replace</p>
<pre>  bool is_open();
</pre>
<p>with</p>
<pre>  bool is_open() const;
</pre>


<p><b>Rationale:</b></p>
<p>Of the changes proposed in N1360, the only one that is safe is
changing the filestreams' is_open to const.  The LWG believed that
this was NAD the first time it considered this issue (issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#73">73</a>), but now thinks otherwise.  The corresponding streambuf
member function, after all,is already const.</p>

<p>The other proposed changes are less safe, because some streambuf
functions that appear merely to report a value do actually perform
mutating operations.  It's not even clear that they should be
considered "logically const", because streambuf has two interfaces, a
public one and a protected one.  These functions may, and often do,
change the state as exposed by the protected interface, even if the
state exposed by the public interface is unchanged.</p>

<p>Note that implementers can make this change in a binary compatible
way by providing both overloads; this would be a conforming extension.</p>






<hr>
<h3><a name="369"></a>369. io stream objects and static ctors</h3>
<p><b>Section:</b> 27.4 [iostream.objects] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Ruslan Abdikeev <b>Opened:</b> 2002-07-08 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#iostream.objects">issues</a> in [iostream.objects].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Is it safe to use standard iostream objects from constructors of
static objects?  Are standard iostream objects constructed and are
their associations established at that time?
</p>

<p>Surpisingly enough, Standard does NOT require that.</p>

<p>
27.3/2 [lib.iostream.objects] guarantees that standard iostream
objects are constructed and their associations are established before
the body of main() begins execution.  It also refers to ios_base::Init
class as the panacea for constructors of static objects.
</p>

<p>
However, there's nothing in 27.3 [lib.iostream.objects],
in 27.4.2 [lib.ios.base], and in 27.4.2.1.6 [lib.ios::Init],
that would require implementations to allow access to standard
iostream objects from constructors of static objects.
</p>

<p>Details:</p>

<p>Core text refers to some magic object ios_base::Init, which will
be discussed below:</p>

<blockquote><p>
    "The [standard iostream] objects are constructed, and their
    associations are established at some time prior to or during
    first time an object of class basic_ios&lt;charT,traits&gt;::Init
    is constructed, and in any case before the body of main
    begins execution." (27.3/2 [lib.iostream.objects])
</p></blockquote>

<p>
The first <i>non-normative</i> footnote encourages implementations
to initialize standard iostream objects earlier than required.
</p>

<p>However, the second <i>non-normative</i> footnote makes an explicit
and unsupported claim:</p>

<blockquote><p>
  "Constructors and destructors for static objects can access these
  [standard iostream] objects to read input from stdin or write output
  to stdout or stderr." (27.3/2 footnote 265 [lib.iostream.objects])
</p></blockquote>

<p>
The only bit of magic is related to that ios_base::Init class.  AFAIK,
the rationale behind ios_base::Init was to bring an instance of this
class to each translation unit which #included &lt;iostream&gt; or
related header.  Such an inclusion would support the claim of footnote
quoted above, because in order to use some standard iostream object it
is necessary to #include &lt;iostream&gt;.
</p>

<p>
However, while Standard explicitly describes ios_base::Init as
an appropriate class for doing the trick, I failed to found a
mention of an _instance_ of ios_base::Init in Standard.
</p>


<p><b>Proposed resolution:</b></p>

<p>Add to 27.4 [iostream.objects], p2, immediately before the last sentence
of the paragraph, the following two sentences:</p>

<blockquote><p>
If a translation unit includes &lt;iostream&gt;, or explicitly
constructs an ios_base::Init object, these stream objects shall
be constructed before dynamic initialization of non-local
objects defined later in that translation unit, and these stream
objects shall be destroyed after the destruction of dynamically
initialized non-local objects defined later in that translation unit.
</p></blockquote>

<p><i>[Lillehammer: Matt provided wording.]</i></p>

<p><i>[Mont Tremblant: Matt provided revised wording.]</i></p>



<p><b>Rationale:</b></p>
<p>
The original proposed resolution unconditionally required
implementations to define an ios_base::Init object of some
implementation-defined name in the header &lt;iostream&gt;. That's an
overspecification. First, defining the object may be unnecessary
and even detrimental to performance if an implementation can
guarantee that the 8 standard iostream objects will be initialized
before any other user-defined object in a program. Second, there
is no need to require implementations to document the name of the
object.</p>

<p>
The new proposed resolution gives users guidance on what they need to
do to ensure that stream objects are constructed during startup.</p>





<hr>
<h3><a name="370"></a>370. Minor error in basic_istream::get</h3>
<p><b>Section:</b> 27.7.1.3 [istream.unformatted] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Ray Lischner <b>Opened:</b> 2002-07-15 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#istream.unformatted">issues</a> in [istream.unformatted].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>Defect report for description of basic_istream::get (section 27.7.1.3 [istream.unformatted]), paragraph 15. The description for the get function
with the following signature:</p>

<pre>  basic_istream&lt;charT,traits&gt;&amp; get(basic_streambuf&lt;char_type,traits&gt;&amp;
  sb);
</pre>

<p>is incorrect. It reads</p>

<blockquote><p>
  Effects: Calls get(s,n,widen('\n'))
</p></blockquote>

<p>which I believe should be:</p>

<blockquote><p>
  Effects: Calls get(sb,widen('\n'))
</p></blockquote>


<p><b>Proposed resolution:</b></p>
<p>Change the <b>Effects</b> paragraph to:</p>
<blockquote><p>
  Effects: Calls get(sb,this-&gt;widen('\n'))
</p></blockquote>

<p><i>[Pre-Oxford: Minor correction from Howard: replaced 'widen' 
      with 'this-&gt;widen'.]</i></p>




<p><b>Rationale:</b></p><p>Fixes an obvious typo.</p>




<hr>
<h3><a name="371"></a>371. Stability of multiset and multimap member functions</h3>
<p><b>Section:</b> 23.2 [container.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Frank Compagner <b>Opened:</b> 2002-07-20 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#container.requirements">issues</a> in [container.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The requirements for multiset and multimap containers (23.1
[lib.containers.requirements], 23.1.2 [lib.associative.reqmnts],
23.3.2 [lib.multimap] and 23.3.4 [lib.multiset]) make no mention of
the stability of the required (mutating) member functions. It appears
the standard allows these functions to reorder equivalent elements of
the container at will, yet the pervasive red-black tree implementation
appears to provide stable behaviour.
</p>

<p>This is of most concern when considering the behaviour of erase().
A stability requirement would guarantee the correct working of the
following 'idiom' that removes elements based on a certain predicate
function.
</p>

<pre>  multimap&lt;int, int&gt; m;
  multimap&lt;int, int&gt;::iterator i = m.begin();
  while (i != m.end()) {
      if (pred(i))
          m.erase (i++);
      else
          ++i;
  }
</pre>

<p>
Although clause 23.1.2/8 guarantees that i remains a valid iterator
througout this loop, absence of the stability requirement could
potentially result in elements being skipped. This would make
this code incorrect, and, furthermore, means that there is no way
of erasing these elements without iterating first over the entire
container, and second over the elements to be erased. This would
be unfortunate, and have a negative impact on both performance and
code simplicity.
</p>

<p>
If the stability requirement is intended, it should be made explicit
(probably through an extra paragraph in clause 23.1.2).
</p>
<p>
If it turns out stability cannot be guaranteed, i'd argue that a
remark or footnote is called for (also somewhere in clause 23.1.2) to
warn against relying on stable behaviour (as demonstrated by the code
above).  If most implementations will display stable behaviour, any
problems emerging on an implementation without stable behaviour will
be hard to track down by users. This would also make the need for an
erase_if() member function that much greater.
</p>

<p>This issue is somewhat related to LWG issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#130">130</a>.</p>



<p><b>Proposed resolution:</b></p>

<p>Add the following to the end of 23.2.4 [associative.reqmts] paragraph 4: 
"For <tt>multiset</tt> and <tt>multimap</tt>, <tt>insert</tt>and <tt>erase</tt>
  are <i>stable</i>: they preserve the relative ordering of equivalent
  elements.</p> 

<p><i>[Lillehammer: Matt provided wording]</i></p>

<p><i>[Joe Gottman points out that the provided wording does not address
multimap and multiset.  N1780 also addresses this issue and suggests
wording.]</i></p>


<p><i>[Mont Tremblant: Changed set and map to multiset and multimap.]</i></p>




<p><b>Rationale:</b></p>
<p>The LWG agrees that this guarantee is necessary for common user
  idioms to work, and that all existing implementations provide this
  property.  Note that this resolution guarantees stability for
  multimap and multiset, not for all associative containers in
  general.</p>






<hr>
<h3><a name="373"></a>373. Are basic_istream and basic_ostream to use (exceptions()&amp;badbit) != 0 ?</h3>
<p><b>Section:</b> 27.7.1.2.1 [istream.formatted.reqmts], 27.7.2.6.1 [ostream.formatted.reqmts] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Keith Baker <b>Opened:</b> 2002-07-23 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#istream.formatted.reqmts">issues</a> in [istream.formatted.reqmts].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>

<p>
In 27.7.1.2.1 [istream.formatted.reqmts] and 27.7.2.6.1 [ostream.formatted.reqmts]
(exception()&amp;badbit) != 0 is used in testing for rethrow, yet
exception() is the constructor to class std::exception in 18.7.1 [type.info] that has no return type. Should member function
exceptions() found in 27.5.4 [ios] be used instead?
</p>



<p><b>Proposed resolution:</b></p>
<p>
In 27.7.1.2.1 [istream.formatted.reqmts] and 27.7.2.6.1 [ostream.formatted.reqmts], change
"(exception()&amp;badbit) != 0" to "(exceptions()&amp;badbit) != 0".
</p>


<p><b>Rationale:</b></p>
<p>Fixes an obvious typo.</p>





<hr>
<h3><a name="375"></a>375. basic_ios should be ios_base in 27.7.1.3</h3>
<p><b>Section:</b> 27.8.1.4 [stringbuf.virtuals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Ray Lischner <b>Opened:</b> 2002-08-14 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#stringbuf.virtuals">issues</a> in [stringbuf.virtuals].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In Section 27.8.1.4 [stringbuf.virtuals]: Table 90, Table 91, and paragraph
14 all contain references to "basic_ios::" which should be
"ios_base::".
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change all references to "basic_ios" in Table 90, Table 91, and
paragraph 14 to "ios_base".
</p>


<p><b>Rationale:</b></p><p>Fixes an obvious typo.</p>




<hr>
<h3><a name="376"></a>376. basic_streambuf semantics</h3>
<p><b>Section:</b> 27.8.1.4 [stringbuf.virtuals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Ray Lischner <b>Opened:</b> 2002-08-14 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#stringbuf.virtuals">issues</a> in [stringbuf.virtuals].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In Section 27.8.1.4 [stringbuf.virtuals], Table 90, the implication is that
the four conditions should be mutually exclusive, but they are not.
The first two cases, as written, are subcases of the third.</p>

<p>
As written, it is unclear what should be the result if cases 1 and 2
are both true, but case 3 is false.
</p>



<p><b>Proposed resolution:</b></p>

<p>Rewrite these conditions as:</p>
<blockquote>
<p>
  (which &amp; (ios_base::in|ios_base::out)) == ios_base::in
</p>

<p>
  (which &amp; (ios_base::in|ios_base::out)) == ios_base::out
</p>

<p>
  (which &amp; (ios_base::in|ios_base::out)) == 
(ios_base::in|ios_base::out)
   and way == either ios_base::beg or ios_base::end
</p>

<p>Otherwise</p>
</blockquote>



<p><b>Rationale:</b></p>
<p>It's clear what we wanted to say, we just failed to say it.  This
  fixes it.</p>





<hr>
<h3><a name="379"></a>379. nonsensical ctype::do_widen() requirement</h3>
<p><b>Section:</b> 22.4.1.1.2 [locale.ctype.virtuals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2002-09-06 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.ctype.virtuals">issues</a> in [locale.ctype.virtuals].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The last sentence in 22.2.1.1.2, p11 below doesn't seem to make sense.
</p>
<pre>  charT do_widen (char c) const;

  -11- Effects: Applies the simplest reasonable transformation from
       a char value or sequence of char values to the corresponding
       charT value or values. The only characters for which unique
       transformations are required are those in the basic source
       character set (2.2). For any named ctype category with a
       ctype&lt;charT&gt; facet ctw and valid ctype_base::mask value
       M (is(M, c) || !ctw.is(M, do_widen(c))) is true.
</pre>
<p>
Shouldn't the last sentence instead read
</p>
<pre>       For any named ctype category with a ctype&lt;char&gt; facet ctc
       and valid ctype_base::mask value M
       (ctc.is(M, c) || !is(M, do_widen(c))) is true.
</pre>
<p>
I.e., if the narrow character c is not a member of a class of
characters then neither is the widened form of c. (To paraphrase
footnote 224.)
</p>


<p><b>Proposed resolution:</b></p>
<p>
Replace the last sentence of 22.4.1.1.2 [locale.ctype.virtuals], p11 with the
following text:
</p>
<pre>       For any named ctype category with a ctype&lt;char&gt; facet ctc
       and valid ctype_base::mask value M,
       (ctc.is(M, c) || !is(M, do_widen(c))) is true.
</pre>

<p><i>[Kona: Minor edit. Added a comma after the <i>M</i> for clarity.]</i></p>




<p><b>Rationale:</b></p>
<p>The LWG believes this is just a typo, and that this is the correct fix.</p>





<hr>
<h3><a name="380"></a>380. typos in codecvt tables 53 and 54</h3>
<p><b>Section:</b> 22.4.1.5 [locale.codecvt.byname] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2002-09-06 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.codecvt.byname">issues</a> in [locale.codecvt.byname].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Tables 53 and 54 in 22.4.1.5 [locale.codecvt.byname] are both titled "convert
result values," when surely "do_in/do_out result values" must have
been intended for Table 53 and "do_unshift result values" for Table
54.
</p>
<p>
Table 54, row 3 says that the meaning of partial is "more characters
needed to be supplied to complete termination." The function is not
supplied any characters, it is given a buffer which it fills with
characters or, more precisely, destination elements (i.e., an escape
sequence). So partial means that space for more than (to_limit - to)
destination elements was needed to terminate a sequence given the
value of state.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change the title of Table 53 to "do_in/do_out result values" and
the title of Table 54 to "do_unshift result values."
</p>
<p>
Change the text in Table 54, row 3 (the <b>partial</b> row), under the
heading Meaning, to "space for more than (to_limit - to) destination
elements was needed to terminate a sequence given the value of state."
</p>




<hr>
<h3><a name="381"></a>381. detection of invalid mbstate_t in codecvt</h3>
<p><b>Section:</b> 22.4.1.5 [locale.codecvt.byname] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2002-09-06 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.codecvt.byname">issues</a> in [locale.codecvt.byname].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
All but one codecvt member functions that take a state_type argument
list as one of their preconditions that the state_type argument have
a valid value. However, according to 22.2.1.5.2, p6,
codecvt::do_unshift() is the only codecvt member that is supposed to
return error if the state_type object is invalid.
</p>

<p>
It seems to me that the treatment of state_type by all codecvt member
functions should be the same and the current requirements should be
changed. Since the detection of invalid state_type values may be
difficult in general or computationally expensive in some specific
cases, I propose the following:
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add a new paragraph before 22.2.1.5.2, p5, and after the function
declaration below
</p>
<pre>    result do_unshift(stateT&amp; state,
    externT* to, externT* to_limit, externT*&amp; to_next) const;
</pre>
<p>
as follows:
</p>
<pre>    Requires: (to &lt;= to_end) well defined and true; state initialized,
    if at the beginning of a sequence, or else equal to the result of
    converting the preceding characters in the sequence.
</pre>
<p>
and change the text in Table 54, row 4, the <b>error</b> row, under
the heading Meaning, from
</p>
<pre>    state has invalid value
</pre>
<p>
to
</p>
<pre>    an unspecified error has occurred
</pre>


<p><b>Rationale:</b></p>
<p>The intent is that implementations should not be required to detect
invalid state values; such a requirement appears nowhere else.  An
invalid state value is a precondition violation, <i>i.e.</i> undefined
behavior.  Implementations that do choose to detect invalid state
values, or that choose to detect any other kind of error, may return
<b>error</b> as an indication.</p>





<hr>
<h3><a name="383"></a>383. Bidirectional iterator assertion typo</h3>
<p><b>Section:</b> 24.2.6 [bidirectional.iterators] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> ysapir (submitted via comp.std.c++) <b>Opened:</b> 2002-10-17 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#bidirectional.iterators">issues</a> in [bidirectional.iterators].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Following a discussion on the boost list regarding end iterators and
the possibility of performing operator--() on them, it seems to me
that there is a typo in the standard.  This typo has nothing to do
with that discussion.
</p>

<p>
I have checked this newsgroup, as well as attempted a search of the
Active/Defect/Closed Issues List on the site for the words "s is
derefer" so I believe this has not been proposed before.  Furthermore,
the "Lists by Index" mentions only DR <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#299">299</a> on section
24.1.4, and DR <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#299">299</a> is not related to this issue.
</p>

<p>
The standard makes the following assertion on bidirectional iterators,
in section 24.1.4 [lib.bidirectional.iterators], Table 75:
</p>

<pre>                         operational  assertion/note
expression  return type   semantics    pre/post-condition

--r          X&amp;                        pre: there exists s such
                                       that r == ++s.
                                       post: s is dereferenceable.
                                       --(++r) == r.
                                       --r == --s implies r == s.
                                       &amp;r == &amp;--r.
</pre>

<p>
(See <a href="http://aspn.activestate.com/ASPN/Mail/Message/boost/1395763">http://aspn.activestate.com/ASPN/Mail/Message/boost/1395763</a>.)
</p>

<p>
In particular, "s is dereferenceable" seems to be in error.  It seems
that the intention was to say "r is dereferenceable".
</p>

<p>
If it were to say "r is dereferenceable" it would
make perfect sense.  Since s must be dereferenceable prior to
operator++, then the natural result of operator-- (to undo operator++)
would be to make r dereferenceable.  Furthermore, without other
assertions, and basing only on precondition and postconditions, we
could not otherwise know this.  So it is also interesting information.
</p>



<p><b>Proposed resolution:</b></p>
<p>
Change the guarantee to "postcondition: r is dereferenceable."
</p>


<p><b>Rationale:</b></p><p>Fixes an obvious typo</p>




<hr>
<h3><a name="384"></a>384. equal_range has unimplementable runtime complexity</h3>
<p><b>Section:</b> 25.4.3.3 [equal.range] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Hans Bos <b>Opened:</b> 2002-10-18 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#equal.range">issues</a> in [equal.range].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Section 25.4.3.3 [equal.range]
states that at most 2 * log(last - first) + 1
comparisons are allowed for equal_range.
</p>

<p>It is not possible to implement equal_range with these constraints.</p>

<p>In a range of one element as in:</p>
<pre>    int x = 1;
    equal_range(&amp;x, &amp;x + 1, 1)
</pre>

<p>it is easy to see that at least 2 comparison operations are needed.</p>

<p>For this case at most 2 * log(1) + 1 = 1 comparison is allowed.</p>

<p>I have checked a few libraries and they all use the same (nonconforming)
algorithm for equal_range that has a complexity of</p>
<pre>     2* log(distance(first, last)) + 2.
</pre>
<p>I guess this is the algorithm that the standard assumes for equal_range.</p>

<p>
It is easy to see that 2 * log(distance) + 2 comparisons are enough
since equal range can be implemented with lower_bound and upper_bound
(both log(distance) + 1).
</p>

<p>
I think it is better to require something like 2log(distance) + O(1)  (or
even logarithmic as multiset::equal_range).
Then an implementation has more room to optimize for certain cases (e.g.
have log(distance) characteristics when at most match is found in the range
but 2log(distance) + 4 for the worst case).
</p>



<p><b>Proposed resolution:</b></p>
<p>In 25.4.3.1 [lower.bound]/4, change <tt>log(last - first) + 1</tt>
to <tt>log<sub>2</sub>(last - first) + <i>O</i>(1)</tt>.</p>

<p>In 25.4.3.2 [upper.bound]/4, change <tt>log(last - first) + 1</tt>
to <tt>log<sub>2</sub>(last - first) + <i>O</i>(1)</tt>.</p>

<p>In 25.4.3.3 [equal.range]/4, change <tt>2*log(last - first) + 1</tt>
to <tt>2*log<sub>2</sub>(last - first) + <i>O</i>(1)</tt>.</p>

<p><i>[Matt provided wording]</i></p>



<p><b>Rationale:</b></p>
<p>The LWG considered just saying <i>O</i>(log n) for all three, but
  decided that threw away too much valuable information.  The fact
  that lower_bound is twice as fast as equal_range is important.
  However, it's better to allow an arbitrary additive constant than to
  specify an exact count.  An exact count would have to
  involve <tt>floor</tt> or <tt>ceil</tt>.  It would be too easy to
  get this wrong, and don't provide any substantial value for users.</p>




<hr>
<h3><a name="386"></a>386. Reverse iterator's operator[] has impossible return type</h3>
<p><b>Section:</b> 24.5.1.3.11 [reverse.iter.op-=] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2002-10-23 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>In 24.5.1.3.11 [reverse.iter.op-=], <tt>reverse_iterator&lt;&gt;::operator[]</tt> 
is specified as having a return type of <tt>reverse_iterator::reference</tt>,
which is the same as <tt>iterator_traits&lt;Iterator&gt;::reference</tt>.
(Where <tt>Iterator</tt> is the underlying iterator type.)</p>

<p>The trouble is that <tt>Iterator</tt>'s own operator[] doesn't
  necessarily have a return type
  of <tt>iterator_traits&lt;Iterator&gt;::reference</tt>.   Its
  return type is merely required to be convertible
  to <tt>Iterator</tt>'s value type.  The return type specified for
  reverse_iterator's operator[] would thus appear to be impossible.</p>

<p>With the resolution of issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#299">299</a>, the type of
  <tt>a[n]</tt> will continue to be required (for random access
  iterators) to be convertible to the value type, and also <tt>a[n] =
  t</tt> will be a valid expression.  Implementations of
  <tt>reverse_iterator</tt> will likely need to return a proxy from
  <tt>operator[]</tt> to meet these requirements. As mentioned in the
  comment from Dave Abrahams, the simplest way to specify that
  <tt>reverse_iterator</tt> meet this requirement to just mandate
  it and leave the return type of <tt>operator[]</tt> unspecified.</p>



<p><b>Proposed resolution:</b></p>

<p>In 24.5.1.2 [reverse.iter.requirements] change:</p>

<blockquote>
<pre>reference operator[](difference_type n) const;
</pre>
</blockquote>

<p>to:</p>

<blockquote>
<pre><b><i>unspecified</i></b> operator[](difference_type n) const; // see 24.2.7 [random.access.iterators]
</pre>
</blockquote>




<p><i>[
Comments from Dave Abrahams: IMO we should resolve 386 by just saying
    that the return type of reverse_iterator's operator[] is
    unspecified, allowing the random access iterator requirements to
    impose an appropriate return type.  If we accept 299's proposed
    resolution (and I think we should), the return type will be
    readable and writable, which is about as good as we can do.
]</i></p>






<hr>
<h3><a name="387"></a>387. std::complex over-encapsulated</h3>
<p><b>Section:</b> 26.4 [complex.numbers] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Gabriel Dos Reis <b>Opened:</b> 2002-11-08 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#complex.numbers">issues</a> in [complex.numbers].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The absence of explicit description of std::complex&lt;T&gt; layout
makes it imposible to reuse existing software developed in traditional
languages like Fortran or C with unambigous and commonly accepted
layout assumptions.  There ought to be a way for practitioners to
predict with confidence the layout of std::complex&lt;T&gt; whenever T
is a numerical datatype.  The absence of ways to access individual
parts of a std::complex&lt;T&gt; object as lvalues unduly promotes
severe pessimizations. For example, the only way to change,
independently, the real and imaginary parts is to write something like
</p>

<pre>complex&lt;T&gt; z;
// ...
// set the real part to r
z = complex&lt;T&gt;(r, z.imag());
// ...
// set the imaginary part to i
z = complex&lt;T&gt;(z.real(), i);
</pre>

<p>
At this point, it seems appropriate to recall that a complex number
is, in effect, just a pair of numbers with no particular invariant to
maintain.  Existing practice in numerical computations has it that a
complex number datatype is usually represented by Cartesian
coordinates. Therefore the over-encapsulation put in the specification
of std::complex&lt;&gt; is not justified.
</p>



<p><b>Proposed resolution:</b></p>
<p>Add the following requirements to 26.4 [complex.numbers] as 26.3/4:</p>
<blockquote>
<p>If z is an lvalue expression of type cv std::complex&lt;T&gt; then</p>

<ul>
<li>the expression reinterpret_cast&lt;cv T(&amp;)[2]&gt;(z)
is well-formed; and</li>
<li>reinterpret_cast&lt;cv T(&amp;)[2]&gt;(z)[0]designates the
real part of z; and</li>
<li>reinterpret_cast&lt;cv T(&amp;)[2]&gt;(z)[1]designates the
imaginary part of z.</li>
</ul>

<p>
Moreover, if a is an expression of pointer type cv complex&lt;T&gt;*
and the expression a[i] is well-defined for an integer expression
i then:
</p>

<ul>
<li>reinterpret_cast&lt;cv T*&gt;(a)[2*i] designates the real
part of a[i]; and</li>
<li>reinterpret_cast&lt;cv T*&gt;(a)[2*i+1] designates the
imaginary part of a[i].</li>
</ul>
</blockquote>

<p>
In 26.4.2 [complex] and 26.4.3 [complex.special] add the following member functions
(changing <tt>T</tt> to concrete types as appropriate for the specializations).
</p>

<blockquote><pre>void real(T);
void imag(T);
</pre></blockquote>

<p>
Add to 26.4.4 [complex.members]
</p>

<blockquote>
<pre>T real() const;
</pre>
<blockquote>
<i>Returns:</i> the value of the real component
</blockquote>
<pre>void real(T val);
</pre>
<blockquote>
Assigns val to the real component.
</blockquote>
<pre>T imag() const;
</pre>
<blockquote>
<i>Returns:</i> the value of the imaginary component
</blockquote>
<pre>void imag(T val);
</pre>
<blockquote>
Assigns val to the imaginary component.
</blockquote>
</blockquote>

<p><i>[Kona: The layout guarantee is absolutely necessary for C
  compatibility.  However, there was disagreement about the other part
  of this proposal: retrieving elements of the complex number as
  lvalues.  An alternative: continue to have real() and imag() return
  rvalues, but add set_real() and set_imag().  Straw poll: return
  lvalues - 2, add setter functions - 5.  Related issue: do we want
  reinterpret_cast as the interface for converting a complex to an
  array of two reals, or do we want to provide a more explicit way of
  doing it?  Howard will try to resolve this issue for the next
  meeting.]</i></p>


<p><i>[pre-Sydney: Howard summarized the options in n1589.]</i></p>


<p><i>[
Bellevue:
]</i></p>


<blockquote>
Second half of proposed wording replaced and moved to Ready.
</blockquote>

<p><i>[
Pre-Sophia Antipolis, Howard adds:
]</i></p>


<blockquote>
Added the members to 26.4.3 [complex.special] and changed from Ready to Review.
</blockquote>

<p><i>[
Post-Sophia Antipolis:
]</i></p>


<blockquote>
Moved from WP back to Ready so that the "and 26.4.3 [complex.special]" in the proposed
resolution can be officially applied.
</blockquote>



<p><b>Rationale:</b></p>
<p>The LWG believes that C99 compatibility would be enough
justification for this change even without other considerations.  All
existing implementations already have the layout proposed here.</p>





<hr>
<h3><a name="389"></a>389. Const overload of valarray::operator[] returns by value</h3>
<p><b>Section:</b> 26.6.2.3 [valarray.access] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Gabriel Dos Reis <b>Opened:</b> 2002-11-08 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#valarray.access">issues</a> in [valarray.access].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#77">77</a></p>
<p><b>Discussion:</b></p>
<p>Consider the following program:</p>
<pre>    #include &lt;iostream&gt;
    #include &lt;ostream&gt;
    #include &lt;vector&gt;
    #include &lt;valarray&gt;
    #include &lt;algorithm&gt;
    #include &lt;iterator&gt;
    template&lt;typename Array&gt;
    void print(const Array&amp; a)
    {
    using namespace std;
    typedef typename Array::value_type T;
    copy(&amp;a[0], &amp;a[0] + a.size(),
    ostream_iterator&lt;T&gt;(std::cout, " "));
    }
    template&lt;typename T, unsigned N&gt;
    unsigned size(T(&amp;)[N]) { return N; }
    int main()
    {
    double array[] = { 0.89, 9.3, 7, 6.23 };
    std::vector&lt;double&gt; v(array, array + size(array));
    std::valarray&lt;double&gt; w(array, size(array));
    print(v); // #1
    std::cout &lt;&lt; std::endl;
    print(w); // #2
    std::cout &lt;&lt; std::endl;
    }
</pre>

<p>While the call numbered #1 succeeds, the call numbered #2 fails
because the const version of the member function
valarray&lt;T&gt;::operator[](size_t) returns a value instead of a
const-reference. That seems to be so for no apparent reason, no
benefit. Not only does that defeats users' expectation but it also
does hinder existing software (written either in C or Fortran)
integration within programs written in C++.  There is no reason why
subscripting an expression of type valarray&lt;T&gt; that is const-qualified
should not return a const T&amp;.</p>


<p><b>Proposed resolution:</b></p>
<p>In the class synopsis in 26.6.2 [template.valarray], and in
26.6.2.3 [valarray.access] just above paragraph 1, change</p>
<pre>  T operator[](size_t const);
</pre>
<p>to</p>
<pre>  const T&amp; operator[](size_t const);
</pre>

<p><i>[Kona: fixed a minor typo: put semicolon at the end of the line
  wehre it belongs.]</i></p>




<p><b>Rationale:</b></p>
<p>Return by value seems to serve no purpose.  Valaray was explicitly
designed to have a specified layout so that it could easily be
integrated with libraries in other languages, and return by value
defeats that purpose.  It is believed that this change will have no
impact on allowable optimizations.</p>





<hr>
<h3><a name="391"></a>391. non-member functions specified as const</h3>
<p><b>Section:</b> 22.3.3.2 [conversions] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> James Kanze <b>Opened:</b> 2002-12-10 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The specifications of toupper and tolower both specify the functions as
const, althought they are not member functions, and are not specified as
const in the header file synopsis in section 22.3 [locales].
</p>


<p><b>Proposed resolution:</b></p>
<p>In 22.3.3.2 [conversions], remove <tt>const</tt> from the function
  declarations of std::toupper and std::tolower</p>


<p><b>Rationale:</b></p><p>Fixes an obvious typo</p>




<hr>
<h3><a name="395"></a>395. inconsistencies in the definitions of rand() and random_shuffle()</h3>
<p><b>Section:</b> 26.8 [c.math] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> James Kanze <b>Opened:</b> 2003-01-03 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#c.math">issues</a> in [c.math].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 26.8 [c.math], the C++ standard refers to the C standard for the
definition of rand(); in the C standard, it is written that "The
implementation shall behave as if no library function calls the rand
function."
</p>

<p>
In 25.3.12 [alg.random.shuffle], there is no specification as to
how the two parameter version of the function generates its random
value.  I believe that all current implementations in fact call rand()
(in contradiction with the requirement avove); if an implementation does
not call rand(), there is the question of how whatever random generator
it does use is seeded.  Something is missing.
</p>



<p><b>Proposed resolution:</b></p>
<p>
In [lib.c.math], add a paragraph specifying that the C definition of
rand shal be modified to say that "Unless otherwise specified, the
implementation shall behave as if no library function calls the rand
function."
</p>

<p>
In [lib.alg.random.shuffle], add a sentence to the effect that "In
the two argument form of the function, the underlying source of
random numbers is implementation defined. [Note: in particular, an
implementation is permitted to use <tt>rand</tt>.]
</p>


<p><b>Rationale:</b></p>
<p>The original proposed resolution proposed requiring the
  two-argument from of <tt>random_shuffle</tt> to
  use <tt>rand</tt>. We don't want to do that, because some existing
  implementations already use something else: gcc
  uses <tt>lrand48</tt>, for example.  Using <tt>rand</tt> presents a
  problem if the number of elements in the sequence is greater than
  RAND_MAX.</p> 





<hr>
<h3><a name="396"></a>396. what are characters zero and one</h3>
<p><b>Section:</b> 20.5.1 [bitset.cons] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2003-01-05 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#bitset.cons">issues</a> in [bitset.cons].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
    <p>
23.3.5.1, p6 [lib.bitset.cons] talks about a generic character
having the value of 0 or 1 but there is no definition of what
that means for charT other than char and wchar_t. And even for
those two types, the values 0 and 1 are not actually what is
intended -- the values '0' and '1' are. This, along with the
converse problem in the description of to_string() in 23.3.5.2,
p33, looks like a defect remotely related to DR 303.
    </p>
    <p>
http://anubis.dkuug.dk/jtc1/sc22/wg21/docs/lwg-defects.html#303
    </p>
    <pre>23.3.5.1:
  -6-  An element of the constructed string has value zero if the
       corresponding character in str, beginning at position pos,
       is 0. Otherwise, the element has the value one.
    </pre>
    <pre>23.3.5.2:
  -33-  Effects: Constructs a string object of the appropriate
        type and initializes it to a string of length N characters.
        Each character is determined by the value of its
        corresponding bit position in *this. Character position N
        ?- 1 corresponds to bit position zero. Subsequent decreasing
        character positions correspond to increasing bit positions.
        Bit value zero becomes the character 0, bit value one becomes
        the character 1.
    </pre>
    <p>
Also note the typo in 23.3.5.1, p6: the object under construction
is a bitset, not a string.
    </p>

<p><i>[
Sophia Antipolis:
]</i></p>


<blockquote>
<p>
We note that <tt>bitset</tt> has been moved from section 23 to section 20, by
another issue (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#842">842</a>) previously resolved at this meeting.
</p>
<p>
Disposition: move to ready.
</p>
<p>
We request that Howard submit a separate issue regarding the three to_string overloads.
</p>
</blockquote>

  

<p><b>Proposed resolution:</b></p>
<p>Change the constructor's function declaration immediately before 
20.5.1 [bitset.cons] p3 to:</p>
<pre>    template &lt;class charT, class traits, class Allocator&gt;
    explicit
    bitset(const basic_string&lt;charT, traits, Allocator&gt;&amp; str,
           typename basic_string&lt;charT, traits, Allocator&gt;::size_type pos = 0,
           typename basic_string&lt;charT, traits, Allocator&gt;::size_type n =
             basic_string&lt;charT, traits, Allocator&gt;::npos,
           charT zero = charT('0'), charT one = charT('1'))
</pre>
<p>Change the first two sentences of 20.5.1 [bitset.cons] p6 to: "An
element of the constructed string has value 0 if the corresponding
character in <i>str</i>, beginning at position <i>pos</i>,
is <i>zero</i>. Otherwise, the element has the value 1.</p>

<p>Change the text of the second sentence in 23.3.5.1, p5 to read:
    "The function then throws invalid_argument if any of the rlen
    characters in str beginning at position pos is other than <i>zero</i>
    or <i>one</i>. The function uses traits::eq() to compare the character
    values."
</p>

<p>Change the declaration of the <tt>to_string</tt> member function
  immediately before 20.5.2 [bitset.members] p33 to:</p>
<pre>    template &lt;class charT, class traits, class Allocator&gt;
    basic_string&lt;charT, traits, Allocator&gt; 
    to_string(charT zero = charT('0'), charT one = charT('1')) const;
</pre>
<p>Change the last sentence of 20.5.2 [bitset.members] p33 to: "Bit
  value 0 becomes the character <tt><i>zero</i></tt>, bit value 1 becomes the
  character <tt><i>one</i></tt>.</p>
<p>Change 20.5.4 [bitset.operators] p8 to:</p>
<p><b>Returns</b>:</p> 
<pre>  os &lt;&lt; x.template to_string&lt;charT,traits,allocator&lt;charT&gt; &gt;(
      use_facet&lt;ctype&lt;charT&gt; &gt;(<i>os</i>.getloc()).widen('0'),
      use_facet&lt;ctype&lt;charT&gt; &gt;(<i>os</i>.getloc()).widen('1'));
</pre>


<p><b>Rationale:</b></p>
<p>There is a real problem here: we need the character values of '0'
  and '1', and we have no way to get them since strings don't have
  imbued locales. In principle the "right" solution would be to
  provide an extra object, either a ctype facet or a full locale,
  which would be used to widen '0' and '1'. However, there was some
  discomfort about using such a heavyweight mechanism.  The proposed
  resolution allows those users who care about this issue to get it
  right.</p>
<p>We fix the inserter to use the new arguments.  Note that we already
  fixed the analogous problem with the extractor in issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#303">303</a>.</p>



<p><i>[
post Bellevue:
]</i></p>


<blockquote>
We are happy with the resolution as proposed, and we move this to Ready.
</blockquote>

<p><i>[
Howard adds:
]</i></p>


<blockquote>
The proposed wording neglects the 3 newer to_string overloads.
</blockquote>




<hr>
<h3><a name="400"></a>400. redundant type cast in lib.allocator.members</h3>
<p><b>Section:</b> 20.9.5.1 [allocator.members] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Markus Mauhart <b>Opened:</b> 2003-02-27 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#allocator.members">issues</a> in [allocator.members].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
20.9.5.1 [allocator.members] allocator members, contains
the following 3 lines:
</p>

<pre>  12 Returns: new((void *) p) T( val)
     void destroy(pointer p);
  13 Returns: ((T*) p)-&gt;~T()
</pre>

<p>
The type cast "(T*) p" in the last line is redundant cause
we know that std::allocator&lt;T&gt;::pointer is a typedef for T*.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Replace "((T*) p)" with "p".
</p>


<p><b>Rationale:</b></p><p>Just a typo, this is really editorial.</p>




<hr>
<h3><a name="401"></a>401.  incorrect type casts in table 32 in lib.allocator.requirements</h3>
<p><b>Section:</b> 20.2.5 [allocator.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Markus Mauhart <b>Opened:</b> 2003-02-27 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#allocator.requirements">issues</a> in [allocator.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I think that in par2 of  [default.con.req] the last two
lines of table 32 contain two incorrect type casts. The lines are ...
</p>

<pre>  a.construct(p,t)   Effect: new((void*)p) T(t)
  a.destroy(p)       Effect: ((T*)p)?-&gt;~T()
</pre>

<p>
.... with the prerequisits coming from the preceding two paragraphs, especially
from table 31:
</p>

<pre>  alloc&lt;T&gt;             a     ;// an allocator for T
  alloc&lt;T&gt;::pointer    p     ;// random access iterator
                              // (may be different from T*)
  alloc&lt;T&gt;::reference  r = *p;// T&amp;
  T const&amp;             t     ;
</pre>

<p>
For that two type casts ("(void*)p" and "(T*)p") to be well-formed
this would require then conversions to T* and void* for all
alloc&lt;T&gt;::pointer, so it would implicitely introduce extra
requirements for alloc&lt;T&gt;::pointer, additionally to the only
current requirement (being a random access iterator).
</p>


<p><b>Proposed resolution:</b></p>

<p>
Accept proposed wording from
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2436.pdf">N2436</a> part 1.
</p>

<p>
Note: Actually I would prefer to replace "((T*)p)?-&gt;dtor_name" with
"p?-&gt;dtor_name", but AFAICS this is not possible cause of an omission
in 13.5.6 [over.ref] (for which I have filed another DR on 29.11.2002).
</p>

<p><i>[Kona: The LWG thinks this is somewhere on the border between
  Open and NAD.  The intend is clear: <tt>construct</tt> constructs an
  object at the location <i>p</i>.  It's reading too much into the
  description to think that literally calling <tt>new</tt> is
  required.  Tweaking this description is low priority until we can do
  a thorough review of allocators, and, in particular, allocators with
  non-default pointer types.]</i></p>


<p><i>[
Batavia:  Proposed resolution changed to less code and more description.
]</i></p>


<p><i>[
post Oxford:  This would be rendered NAD Editorial by acceptance of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2257.html">N2257</a>.
]</i></p>


<p><i>[
Kona (2007): The LWG adopted the proposed resolution of N2387 for this issue which
was subsequently split out into a separate paper N2436 for the purposes of voting.
The resolution in N2436 addresses this issue.  The LWG voted to accelerate this
issue to Ready status to be voted into the WP at Kona.
]</i></p>







<hr>
<h3><a name="402"></a>402. wrong new expression in [some_]allocator::construct</h3>
<p><b>Section:</b> 20.2.5 [allocator.requirements], 20.9.5.1 [allocator.members] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Markus Mauhart <b>Opened:</b> 2003-02-27 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#allocator.requirements">issues</a> in [allocator.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
This applies to the new expression that is contained in both par12 of
20.9.5.1 [allocator.members] and in par2 (table 32) of  [default.con.req].
I think this new expression is wrong, involving unintended side
effects.
</p>


<p>20.9.5.1 [allocator.members]  contains the following 3 lines:</p>

<pre>  11 Returns: the largest value N for which the call allocate(N,0) might succeed.
     void construct(pointer p, const_reference val);
  12 Returns: new((void *) p) T( val)
</pre>


<p> [default.con.req] in table 32 has the following line:</p>
<pre>  a.construct(p,t)   Effect: new((void*)p) T(t)
</pre>

<p>
.... with the prerequisits coming from the preceding two paragraphs,
especially from table 31:
</p>

<pre>  alloc&lt;T&gt;             a     ;// an allocator for T
  alloc&lt;T&gt;::pointer    p     ;// random access iterator
                              // (may be different from T*)
  alloc&lt;T&gt;::reference  r = *p;// T&amp;
  T const&amp;             t     ;
</pre>

<p>
Cause of using "new" but not "::new", any existing "T::operator new"
function will hide the global placement new function. When there is no
"T::operator new" with adequate signature,
every_alloc&lt;T&gt;::construct(..) is ill-formed, and most
std::container&lt;T,every_alloc&lt;T&gt;&gt; use it; a workaround
would be adding placement new and delete functions with adequate
signature and semantic to class T, but class T might come from another
party. Maybe even worse is the case when T has placement new and
delete functions with adequate signature but with "unknown" semantic:
I dont like to speculate about it, but whoever implements
any_container&lt;T,any_alloc&gt; and wants to use construct(..)
probably must think about it.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Replace "new" with "::new" in both cases.
</p>







<hr>
<h3><a name="403"></a>403. basic_string::swap should not throw exceptions</h3>
<p><b>Section:</b> 21.4.6.8 [string::swap] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Beman Dawes <b>Opened:</b> 2003-03-25 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#string::swap">issues</a> in [string::swap].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>

<p>
std::basic_string, 21.4 [basic.string] paragraph 2 says that
basic_string "conforms to the requirements of a Sequence, as specified
in (23.1.1)." The sequence requirements specified in (23.1.1) to not
include any prohibition on swap members throwing exceptions.
</p>

<p>
Section 23.2 [container.requirements] paragraph 10 does limit conditions under
which exceptions may be thrown, but applies only to "all container
types defined in this clause" and so excludes basic_string::swap
because it is defined elsewhere.
</p>

<p>
Eric Niebler points out that 21.4 [basic.string] paragraph 5 explicitly
permits basic_string::swap to invalidates iterators, which is
disallowed by 23.2 [container.requirements] paragraph 10. Thus the standard would
be contradictory if it were read or extended to read as having
basic_string meet 23.2 [container.requirements] paragraph 10 requirements.
</p>

<p>
Yet several LWG members have expressed the belief that the original
intent was that basic_string::swap should not throw exceptions as
specified by 23.2 [container.requirements] paragraph 10, and that the standard is
unclear on this issue. The complexity of basic_string::swap is
specified as "constant time", indicating the intent was to avoid
copying (which could cause a bad_alloc or other exception). An
important use of swap is to ensure that exceptions are not thrown in
exception-safe code.
</p>

<p>
Note: There remains long standing concern over whether or not it is
possible to reasonably meet the 23.2 [container.requirements] paragraph 10 swap
requirements when allocators are unequal. The specification of
basic_string::swap exception requirements is in no way intended to
address, prejudice, or otherwise impact that concern.
</p>







<p><b>Proposed resolution:</b></p>
<p>
In 21.4.6.8 [string::swap], add a throws clause:
</p>

<p>
Throws: Shall not throw exceptions.
</p>





<hr>
<h3><a name="404"></a>404. May a replacement allocation function be declared inline?</h3>
<p><b>Section:</b> 17.6.3.6 [replacement.functions], 18.6.1 [new.delete] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2003-04-24 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The eight basic dynamic memory allocation functions (single-object
and array versions of ::operator new and ::operator delete, in the
ordinary and nothrow forms) are replaceable.  A C++ program may
provide an alternative definition for any of them, which will be used
in preference to the implementation's definition.  
</p>

<p>
Three different parts of the standard mention requirements on
replacement functions: 17.6.3.6 [replacement.functions], 18.6.1.1 [new.delete.single]
and 18.6.1.2 [new.delete.array], and 3.7.3 [basic.stc.auto].
</p>

<p>None of these three places say whether a replacement function may
  be declared inline.  18.6.1.1 [new.delete.single] paragraph 2 specifies a
  signature for the replacement function, but that's not enough:
  the <tt>inline</tt> specifier is not part of a function's signature.
  One might also reason from 7.1.2 [dcl.fct.spec] paragraph 2, which
  requires that "an inline function shall be defined in every
  translation unit in which it is used," but this may not be quite
  specific enough either.  We should either explicitly allow or
  explicitly forbid inline replacement memory allocation
  functions.</p>


<p><b>Proposed resolution:</b></p>
<p>
Add a new sentence to the end of 17.6.3.6 [replacement.functions] paragraph 3:
"The program's definitions shall not be specified as <tt>inline</tt>.
No diagnostic is required."
</p>

<p><i>[Kona: added "no diagnostic is required"]</i></p>




<p><b>Rationale:</b></p>
<p>
The fact that <tt>inline</tt> isn't mentioned appears to have been
nothing more than an oversight.  Existing implementations do not
permit inline functions as replacement memory allocation functions.
Providing this functionality would be difficult in some cases, and is
believed to be of limited value.
</p>





<hr>
<h3><a name="405"></a>405. qsort and POD</h3>
<p><b>Section:</b> 25.5 [alg.c.library] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Ray Lischner <b>Opened:</b> 2003-04-08 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.c.library">issues</a> in [alg.c.library].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Section 25.5 [alg.c.library] describes bsearch and qsort, from the C
standard library. Paragraph 4 does not list any restrictions on qsort,
but it should limit the base parameter to point to POD.  Presumably,
qsort sorts the array by copying bytes, which requires POD.
</p>


<p><b>Proposed resolution:</b></p>
<p>
In 25.5 [alg.c.library] paragraph 4, just after the declarations and
before the nonnormative note, add these words: "both of which have the
same behavior as the original declaration.  The behavior is undefined
unless the objects in the array pointed to by <i>base</i> are of POD
type."
</p>

<p><i>[Something along these lines is clearly necessary.  Matt
  provided wording.]</i></p>






<hr>
<h3><a name="406"></a>406. vector::insert(s) exception safety</h3>
<p><b>Section:</b> 23.4.1.4 [vector.modifiers] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Dave Abrahams <b>Opened:</b> 2003-04-27 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#vector.modifiers">issues</a> in [vector.modifiers].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There is a possible defect in the standard: the standard text was
never intended to prevent arbitrary ForwardIterators, whose operations
may throw exceptions, from being passed, and it also wasn't intended
to require a temporary buffer in the case where ForwardIterators were
passed (and I think most implementations don't use one).  As is, the
standard appears to impose requirements that aren't met by any
existing implementation.
</p>


<p><b>Proposed resolution:</b></p>
<p>Replace 23.4.1.4 [vector.modifiers] paragraph 1 with:</p>
<blockquote><p>
  1- Notes: Causes reallocation if the new size is greater than the
  old capacity. If no reallocation happens, all the iterators and
  references before the insertion point remain valid. If an exception
  is thrown other than by the copy constructor or assignment operator
  of T or by any InputIterator operation there are no effects.
</p></blockquote>

<p><i>[We probably need to say something similar for deque.]</i></p>







<hr>
<h3><a name="407"></a>407. Can singular iterators be destroyed?</h3>
<p><b>Section:</b> X [iterator.concepts] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Nathan Myers <b>Opened:</b> 2003-06-03 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#iterator.concepts">issues</a> in [iterator.concepts].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Clause X [iterator.concepts], paragraph 5, says that the only expression
that is defined for a singular iterator is "an assignment of a
non-singular value to an iterator that holds a singular value".  This 
means that destroying a singular iterator (e.g. letting an automatic
variable go out of scope) is technically undefined behavior.  This
seems overly strict, and probably unintentional.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change the sentence in question to "... the only exceptions are
destroying an iterator that holds a singular value, or the assignment
of a non-singular value to an iterator that holds a singular value."
</p>





<hr>
<h3><a name="409"></a>409. Closing an fstream should clear error state</h3>
<p><b>Section:</b> 27.9.1.9 [ifstream.members], 27.9.1.13 [ofstream.members] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Nathan Myers <b>Opened:</b> 2003-06-03 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#ifstream.members">issues</a> in [ifstream.members].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
A strict reading of 27.9.1 [fstreams] shows that opening or
closing a basic_[io]fstream does not affect the error bits.  This
means, for example, that if you read through a file up to EOF, and
then close the stream and reopen it at the beginning of the file,
the EOF bit in the stream's error state is still set.  This is
counterintuitive.
</p>
<p>
The LWG considered this issue once before, as issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#22">22</a>,
and put in a footnote to clarify that the strict reading was indeed
correct.  We did that because we believed the standard was
unambiguous and consistent, and that we should not make architectural
changes in a TC.  Now that we're working on a new revision of the
language, those considerations no longer apply.
</p>


<p><b>Proposed resolution:</b></p>

<p>Change 27.9.1.9 [ifstream.members], para. 3 from:</p>

<blockquote><p>
Calls rdbuf()-&gt;open(s,mode|in). If that function returns a null pointer, calls setstate(failbit) (which may throw ios_base::failure [Footnote: (lib.iostate.flags)].
</p></blockquote>

<p>to:</p>

<blockquote><p>
Calls rdbuf()-&gt;open(s,mode|in). If that function returns a null pointer, calls setstate(failbit) (which may throw ios_base::failure [Footnote: (lib.iostate.flags)), else calls clear().
</p></blockquote>

<p>Change 27.9.1.13 [ofstream.members], para. 3 from:</p>

<blockquote><p>
Calls rdbuf()-&gt;open(s,mode|out). If that function returns a null pointer, calls setstate(failbit) (which may throw ios_base::failure [Footnote: (lib.iostate.flags)).
</p></blockquote>

<p>to:</p>

<blockquote><p>
Calls rdbuf()-&gt;open(s,mode|out). If that function returns a null pointer, calls setstate(failbit) (which may throw ios_base::failure [Footnote: (lib.iostate.flags)), else calls clear().
</p></blockquote>

<p>Change 27.9.1.17 [fstream.members], para. 3 from:</p>

<blockquote><p>
Calls rdbuf()-&gt;open(s,mode), If that function returns a null pointer, calls setstate(failbit), (which may throw ios_base::failure). (lib.iostate.flags) )
</p></blockquote>

<p>to:</p>

<blockquote><p>
Calls rdbuf()-&gt;open(s,mode), If that function returns a null pointer, calls setstate(failbit), (which may throw ios_base::failure). (lib.iostate.flags) ), else calls clear().
</p></blockquote>



<p><i>[Kona: the LWG agrees this is a good idea.  Post-Kona: Bill
provided wording.  He suggests having open, not close, clear the error
flags.]</i></p>


<p><i>[Post-Sydney: Howard provided a new proposed resolution.  The
  old one didn't make sense because it proposed to fix this at the
  level of basic_filebuf, which doesn't have access to the stream's
  error state.  Howard's proposed resolution fixes this at the level
  of the three fstream class template instead.]</i></p>








<hr>
<h3><a name="410"></a>410. Missing semantics for stack and queue comparison operators</h3>
<p><b>Section:</b> 23.3.4.1 [list.cons], 23.3.4.3 [list.modifiers] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Hans Bos <b>Opened:</b> 2003-06-07 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#list.cons">issues</a> in [list.cons].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Sections 23.3.4.1 [list.cons] and 23.3.4.3 [list.modifiers] list
comparison operators (==, !=, &lt;, &lt;=, &gt;, =&gt;) for queue and
stack.  Only the semantics for queue::operator== (23.3.4.1 [list.cons] par2) and queue::operator&lt; (23.3.4.1 [list.cons]
par3) are defined.
</p>


<p><b>Proposed resolution:</b></p>

<p>Add the following new paragraphs after 23.3.4.1 [list.cons]
  paragraph 3:</p>

<blockquote>

<pre>  operator!=
</pre>
<p>Returns: <tt>x.c != y.c</tt></p>

<pre>  operator&gt;
</pre>
<p>Returns: <tt>x.c &gt; y.c</tt></p>

<pre>  operator&lt;=
</pre>
<p>Returns: <tt>x.c &lt;= y.c</tt></p>

<pre>  operator&gt;=
</pre>
<p>Returns: <tt>x.c &gt;= y.c</tt></p>

</blockquote>

<p>Add the following paragraphs at the end of 23.3.4.3 [list.modifiers]:</p>

<blockquote>

<pre>  operator==
</pre>
<p>Returns: <tt>x.c == y.c</tt></p>

<pre>  operator&lt;
</pre>
<p>Returns: <tt>x.c &lt; y.c</tt></p>

<pre>  operator!=
</pre>
<p>Returns: <tt>x.c != y.c</tt></p>

<pre>  operator&gt;
</pre>
<p>Returns: <tt>x.c &gt; y.c</tt></p>

<pre>  operator&lt;=
</pre>
<p>Returns: <tt>x.c &lt;= y.c</tt></p>

<pre>  operator&gt;=
</pre>
<p>Returns: <tt>x.c &gt;= y.c</tt></p>

</blockquote>


<p><i>[Kona: Matt provided wording.]</i></p>




<p><b>Rationale:</b></p>
<p>There isn't any real doubt about what these operators are
supposed to do, but we ought to spell it out.</p>





<hr>
<h3><a name="411"></a>411. Wrong names of set member functions</h3>
<p><b>Section:</b> 25.4.5 [alg.set.operations] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Daniel Frey <b>Opened:</b> 2003-07-09 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.set.operations">issues</a> in [alg.set.operations].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
25.4.5 [alg.set.operations] paragraph 1 reads:
"The semantics of the set operations are generalized to multisets in a 
standard way by defining union() to contain the maximum number of 
occurrences of every element, intersection() to contain the minimum, and 
so on."
</p>

<p>
This is wrong.  The name of the functions are set_union() and
set_intersection(), not union() and intersection().
</p>


<p><b>Proposed resolution:</b></p>
<p>Change that sentence to use the correct names.</p>





<hr>
<h3><a name="412"></a>412. Typo in 27.4.4.3</h3>
<p><b>Section:</b> 27.5.4.3 [iostate.flags] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2003-07-10 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#iostate.flags">issues</a> in [iostate.flags].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#429">429</a></p>
<p><b>Discussion:</b></p>
<p>
The Effects clause in 27.5.4.3 [iostate.flags] paragraph 5 says that the
function only throws if the respective bits are already set prior to
the function call. That's obviously not the intent. The typo ought to
be corrected and the text reworded as: "If (<i>state</i> &amp;
exceptions()) == 0, returns. ..."
</p>


<p><b>Proposed resolution:</b></p>
<p>
In 27.5.4.3 [iostate.flags] paragraph 5, replace "If (rdstate() &amp;
exceptions()) == 0" with "If ((state | (rdbuf() ? goodbit : badbit))
&amp; exceptions()) == 0".
</p>

<p><i>[Kona: the original proposed resolution wasn't quite right.  We
  really do mean rdstate(); the ambiguity is that the wording in the
  standard doesn't make it clear whether we mean rdstate() before
  setting the new state, or rdsate() after setting it.  We intend the
  latter, of course. Post-Kona: Martin provided wording.]</i></p>







<hr>
<h3><a name="413"></a>413. Proposed resolution to LDR#64 still wrong</h3>
<p><b>Section:</b> 27.7.1.2.3 [istream::extractors] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Bo Persson <b>Opened:</b> 2003-07-13 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#istream::extractors">issues</a> in [istream::extractors].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The second sentence of the proposed resolution says:
</p>

<p>
"If it inserted no characters because it caught an exception thrown
while extracting characters from sb and ..."
</p>

<p>
However, we are not extracting from sb, but extracting from the
basic_istream (*this) and inserting into sb. I can't really tell if
"extracting" or "sb" is a typo.
</p>

<p><i>[
Sydney: Definitely a real issue. We are, indeed, extracting characters
from an istream and not from sb. The problem was there in the FDIS and
wasn't fixed by issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#64">64</a>. Probably what was intended was
to have *this instead of sb. We're talking about the exception flag
state of a basic_istream object, and there's only one basic_istream
object in this discussion, so that would be a consistent
interpretation.  (But we need to be careful: the exception policy of
this member function must be consistent with that of other
extractors.)  PJP will provide wording.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>Change the sentence from:</p>

<blockquote><p>
If it inserted no characters because it caught an exception thrown
while extracting characters from sb and failbit is on in exceptions(),
then the caught exception is rethrown.
</p></blockquote>

<p>to:</p>

<blockquote><p>
If it inserted no characters because it caught an exception thrown
while extracting characters from *this and failbit is on in exceptions(),
then the caught exception is rethrown.
</p></blockquote>





<hr>
<h3><a name="414"></a>414. Which iterators are invalidated by v.erase()?</h3>
<p><b>Section:</b> 23.4.1.4 [vector.modifiers] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2003-08-19 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#vector.modifiers">issues</a> in [vector.modifiers].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Consider the following code fragment:
</p>
<blockquote>
<pre>int A[8] = { 1,3,5,7,9,8,4,2 };
std::vector&lt;int&gt; v(A, A+8);

std::vector&lt;int&gt;::iterator i1 = v.begin() + 3;
std::vector&lt;int&gt;::iterator i2 = v.begin() + 4;
v.erase(i1);
</pre>
</blockquote>

<p>
Which iterators are invalidated by <tt>v.erase(i1)</tt>: i1, i2,
both, or neither?
</p>

<p>
On all existing implementations that I know of, the status of i1 and
i2 is the same: both of them will be iterators that point to some
elements of the vector (albeit not the same elements they did
before).  You won't get a crash if you use them.  Depending on 
exactly what you mean by "invalidate", you might say that neither one
has been invalidated because they still point to <i>something</i>,
or you might say that both have been invalidated because in both
cases the elements they point to have been changed out from under the
iterator.
</p>

<p>
The standard doesn't say either of those things.  It says that erase
invalidates all iterators and references "after the point of the
erase".  This doesn't include i1, since it's at the point of the
erase instead of after it.  I can't think of any sensible definition
of invalidation by which one can say that i2 is invalidated but i1
isn't.
</p>

<p>
(This issue is important if you try to reason about iterator validity
based only on the guarantees in the standard, rather than reasoning
from typical implementation techniques.  Strict debugging modes,
which some programmers find useful, do not use typical implementation
techniques.)
</p>


<p><b>Proposed resolution:</b></p>
<p>
In 23.4.1.4 [vector.modifiers] paragraph 3, change "Invalidates all the
iterators and references after the point of the erase" to
"Invalidates iterators and references at or after the point of the
erase". 
</p>


<p><b>Rationale:</b></p>
<p>I believe this was essentially a typographical error, and that it
  was taken for granted that erasing an element invalidates iterators
  that point to it.  The effects clause in question treats iterators
  and references in parallel, and it would seem counterintuitive to
  say that a reference to an erased value remains valid.</p>





<hr>
<h3><a name="415"></a>415. behavior of std::ws</h3>
<p><b>Section:</b> 27.7.1.4 [istream.manip] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2003-09-18 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
According to 27.6.1.4, the ws() manipulator is not required to construct
the sentry object. The manipulator is also not a member function so the
text in 27.6.1, p1 through 4 that describes the exception policy for
istream member functions does not apply. That seems inconsistent with
the rest of extractors and all the other input functions (i.e., ws will
not cause a tied stream to be flushed before extraction, it doesn't check
the stream's exceptions or catch exceptions thrown during input, and it
doesn't affect the stream's gcount).
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add to 27.7.1.4 [istream.manip], immediately before the first sentence
of paragraph 1, the following text:
</p>

    <blockquote><p>
    Behaves as an unformatted input function (as described in
    27.6.1.3, paragraph 1), except that it does not count the number
    of characters extracted and does not affect the value returned by
    subsequent calls to is.gcount(). After constructing a sentry
    object...  
    </p></blockquote>

<p><i>[Post-Kona: Martin provided wording]</i></p>






<hr>
<h3><a name="416"></a>416. definitions of XXX_MIN and XXX_MAX macros in climits</h3>
<p><b>Section:</b> 18.3.2 [c.limits] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2003-09-18 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
        <p>

Given two overloads of the function foo(), one taking an argument of type
int and the other taking a long, which one will the call foo(LONG_MAX)
resolve to? The expected answer should be foo(long), but whether that
is true depends on the #defintion of the LONG_MAX macro, specifically
its type. This issue is about the fact that the type of these macros
is not actually required to be the same as the the type each respective
limit.
<br>

Section 18.2.2 of the C++ Standard does not specify the exact types of
the XXX_MIN and XXX_MAX macros #defined in the &lt;climits&gt; and &lt;limits.h&gt;
headers such as INT_MAX and LONG_MAX and instead defers to the C standard.
<br>

Section 5.2.4.2.1, p1 of the C standard specifies that "The values [of
these constants] shall be replaced by constant expressions suitable for use
in #if preprocessing directives. Moreover, except for CHAR_BIT and MB_LEN_MAX,
the following shall be replaced by expressions that have the same type as
would an expression that is an object of the corresponding type converted
according to the integer promotions."
<br>

The "corresponding type converted according to the integer promotions" for
LONG_MAX is, according to 6.4.4.1, p5 of the C standard, the type of long
converted to the first of the following set of types that can represent it:
int, long int, long long int. So on an implementation where (sizeof(long)
== sizeof(int)) this type is actually int, while on an implementation where
(sizeof(long) &gt; sizeof(int)) holds this type will be long.
<br>

This is not an issue in C since the type of the macro cannot be detected
by any conforming C program, but it presents a portability problem in C++
where the actual type is easily detectable by overload resolution.

        </p>
<p><i>[Kona: the LWG does not believe this is a defect.  The C macro
  definitions are what they are; we've got a better
  mechanism, <tt>std::numeric_limits</tt>, that is specified more
  precisely than the C limit macros.  At most we should add a
  nonnormative note recommending that users who care about the exact
  types of limit quantities should use &lt;limits&gt; instead of
  &lt;climits&gt;.]</i></p>


    

<p><b>Proposed resolution:</b></p>

<p>
Change 18.3.2 [c.limits], paragraph 2:
</p>

<blockquote><p>
-2- The contents are the same as the Standard C library header <tt>&lt;limits.h&gt;</tt>.
<ins>[<i>Note:</i> The types of the macros in <tt>&lt;climits&gt;</tt> are not guaranteed
to match the type to which they refer.<i>--end note</i>]</ins>
</p></blockquote>





<hr>
<h3><a name="419"></a>419. istream extractors not setting failbit if eofbit is already set</h3>
<p><b>Section:</b> 27.7.1.1.3 [istream::sentry] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2003-09-18 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#istream::sentry">issues</a> in [istream::sentry].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
        <p>

27.7.1.1.3 [istream::sentry], p2 says that istream::sentry ctor prepares for input if is.good()
is true. p4 then goes on to say that the ctor sets the sentry::ok_ member to
true if the stream state is good after any preparation. 27.7.1.2.1 [istream.formatted.reqmts], p1 then
says that a formatted input function endeavors to obtain the requested input
if the sentry's operator bool() returns true.

Given these requirements, no formatted extractor should ever set failbit if
the initial stream rdstate() == eofbit. That is contrary to the behavior of
all implementations I tested. The program below prints out

eof = 1, fail = 0
eof = 1, fail = 1

on all of them.
        </p>
<pre>
#include &lt;sstream&gt;
#include &lt;cstdio&gt;

int main()
{
    std::istringstream strm ("1");

    int i = 0;

    strm &gt;&gt; i;

    std::printf ("eof = %d, fail = %d\n",
                 !!strm.eof (), !!strm.fail ());

    strm &gt;&gt; i;

    std::printf ("eof = %d, fail = %d\n",
                 !!strm.eof (), !!strm.fail ());
}

</pre>
        <p>
<br>

Comments from Jerry Schwarz (c++std-lib-11373):
<br>

Jerry Schwarz wrote:
<br>

I don't know where (if anywhere) it says it in the standard, but the
formatted extractors are supposed to set failbit if they don't extract
any characters. If they didn't then simple loops like
<br>

while (cin &gt;&gt; x);
<br>

would loop forever.
<br>

Further comments from Martin Sebor:
<br>

The question is which part of the extraction should prevent this from happening
by setting failbit when eofbit is already set. It could either be the sentry
object or the extractor. It seems that most implementations have chosen to
set failbit in the sentry [...] so that's the text that will need to be
corrected. 

        </p>
<p>
Pre Berlin:  This issue is related to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#342">342</a>.  If the sentry
sets <tt>failbit</tt> when it finds <tt>eofbit</tt> already set, then
you can never seek away from the end of stream.
</p>
<p>Kona: Possibly NAD.  If eofbit is set then good() will return false.  We
  then set <i>ok</i> to false.  We believe that the sentry's
  constructor should always set failbit when <i>ok</i> is false, and
  we also think the standard already says that.  Possibly it could be
  clearer.</p> 


<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
Moved to Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 27.7.1.1.3 [istream::sentry], p2 to:
</p>

<blockquote>
<pre>explicit sentry(basic_istream&lt;charT,traits&gt;&amp; <i>is</i> , bool <i>noskipws</i> = false);</pre>
<p>
-2- <i>Effects:</i> If <tt>is.good()</tt> is <del><tt>true</tt></del>
<ins><tt>false</tt></ins>, <ins>calls <tt>is.setstate(failbit)</tt>. 
Otherwise</ins> prepares for formatted or unformatted input. ...
</p>
</blockquote>






<hr>
<h3><a name="420"></a>420. is std::FILE a complete type?</h3>
<p><b>Section:</b> 27.9.1 [fstreams] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2003-09-18 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#fstreams">issues</a> in [fstreams].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
7.19.1, p2, of C99 requires that the FILE type only be declared in
&lt;stdio.h&gt;.  None of the (implementation-defined) members of the
struct is mentioned anywhere for obvious reasons.
</p>

<p>
C++ says in 27.8.1, p2 that FILE is a type that's defined in &lt;cstdio&gt;. Is
it really the intent that FILE be a complete type or is an implementation
allowed to just declare it without providing a full definition?
</p>


<p><b>Proposed resolution:</b></p>
<p>In the first sentence of 27.9.1 [fstreams] paragraph 2, change
  "defined" to "declared".</p>


<p><b>Rationale:</b></p>
<p>We don't want to impose any restrictions beyond what the C standard
  already says. We don't want to make anything implementation defined,
  because that imposes new requirements in implementations.</p>





<hr>
<h3><a name="422"></a>422. explicit specializations of member functions of class templates</h3>
<p><b>Section:</b> 17.6.3.3 [reserved.names] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2003-09-18 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#reserved.names">issues</a> in [reserved.names].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It has been suggested that 17.4.3.1, p1 may or may not allow programs to
explicitly specialize members of standard templates on user-defined types.
The answer to the question might have an impact where library requirements
are given using the "as if" rule. I.e., if programs are allowed to specialize
member functions they will be able to detect an implementation's strict
conformance to Effects clauses that describe the behavior of the function
in terms of the other member function (the one explicitly specialized by
the program) by relying on the "as if" rule.
</p>


<p><b>Proposed resolution:</b></p>

<p>
  Add the following sentence to 17.6.3.3 [reserved.names], p1:
</p>

<blockquote><p>
It is undefined for a C++ program to add declarations or definitions to
namespace std or namespaces within namespace <tt>std</tt> unless otherwise specified. A
program may add template specializations for any standard library template to
namespace <tt>std</tt>. Such a specialization (complete or partial) of a standard library
template results in undefined behavior unless the declaration depends on a
user-defined type of external linkage and unless the specialization meets the
standard library requirements for the original template.<sup>168)</sup>
<ins>A program has undefined behavior if it declares</ins>
</p>
<ul>
<li><ins>an explicit specialization of any member function of a standard
            library class template, or</ins></li>
<li><ins>an explicit specialization of any member function template of a
            standard library class or class template, or</ins></li>
<li><ins>an explicit or partial specialization of any member class
            template of a standard library class or class template.</ins></li>
</ul>
<p>
A program may explicitly instantiate any templates in the standard library only
if the declaration depends on the name of a user-defined type of external
linkage and the instantiation meets the standard library requirements for the
original template.
</p></blockquote>

<p><i>[Kona: straw poll was 6-1 that user programs should not be
  allowed to specialize individual member functions of standard
  library class templates, and that doing so invokes undefined
  behavior. Post-Kona: Martin provided wording.]</i></p>


<p><i>[Sydney: The LWG agrees that the standard shouldn't permit users
to specialize individual member functions unless they specialize the
whole class, but we're not sure these words say what we want them to;
they could be read as prohibiting the specialization of any standard
library class templates. We need to consult with CWG to make sure we
use the right wording.]</i></p>






<hr>
<h3><a name="425"></a>425. return value of std::get_temporary_buffer</h3>
<p><b>Section:</b> 20.9.7 [temporary.buffer] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2003-09-18 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The standard is not clear about the requirements on the value returned from
a call to get_temporary_buffer(0). In particular, it fails to specify whether
the call should return a distinct pointer each time it is called (like
operator new), or whether the value is unspecified (as if returned by
malloc). The standard also fails to mention what the required behavior
is when the argument is less than 0.
</p>


<p><b>Proposed resolution:</b></p>
<p>Change 20.7.3 [meta.help] paragraph 2 from "...or a pair of 0
values if no storage can be obtained" to "...or a pair of 0 values if
no storage can be obtained or if <i>n</i> &lt;= 0."</p>
<p><i>[Kona: Matt provided wording]</i></p>





<hr>
<h3><a name="426"></a>426. search_n(), fill_n(), and generate_n() with negative n</h3>
<p><b>Section:</b> 25.2.13 [alg.search], 25.3.6 [alg.fill], 25.3.7 [alg.generate] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2003-09-18 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.search">issues</a> in [alg.search].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The complexity requirements for these function templates are incorrect
(or don't even make sense) for negative n:</p>

<p>25.1.9, p7 (search_n):
<br>
Complexity: At most (last1 - first1) * count applications
of the corresponding predicate.</p>

<p>25.2.5, p3 (fill_n):
<br>
Complexity: Exactly last - first (or n) assignments.</p>

<p>25.2.6, p3 (generate_n):
<br>
Complexity: Exactly last - first (or n) assignments.</p>

<p>
In addition, the Requirements or the Effects clauses for the latter two
templates don't say anything about the behavior when n is negative.
</p>


<p><b>Proposed resolution:</b></p>
<p>Change 25.1.9, p7 to</p>

<blockquote><p>
Complexity: At most (last1 - first1) * count applications
of the corresponding predicate if count is positive,
or 0 otherwise.
</p></blockquote>

<p>Change 25.2.5, p2 to</p>
<blockquote><p>
Effects: Assigns value through all the iterators in the range [first,
last), or [first, first + n) if n is positive, none otherwise.
</p></blockquote>

<p>Change 25.2.5, p3 to:</p>
<blockquote><p>
Complexity: Exactly last - first (or n if n is positive,
or 0 otherwise) assignments.
</p></blockquote>

<p>
Change 25.2.6, p1 
to (notice the correction for the misspelled "through"):
</p>
<blockquote><p>
Effects: Invokes the function object genand assigns the return
value of gen through all the iterators in the range [first, last),
or [first, first + n) if n is positive, or [first, first)
otherwise.
</p></blockquote>

<p>Change 25.2.6, p3 to:</p>
<blockquote><p>
Complexity: Exactly last - first (or n if n is positive,
or 0 otherwise) assignments.
</p></blockquote>


<p><b>Rationale:</b></p>
<p>Informally, we want to say that whenever we see a negative number
  we treat it the same as if it were zero.  We believe the above
  changes do that (although they may not be the minimal way of saying
  so).  The LWG considered and rejected the alternative of saying that
  negative numbers are undefined behavior.</p>





<hr>
<h3><a name="427"></a>427. stage 2 and rationale of DR 221</h3>
<p><b>Section:</b> 22.4.2.1.2 [facet.num.get.virtuals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2003-09-18 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#facet.num.get.virtuals">issues</a> in [facet.num.get.virtuals].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The requirements specified in Stage 2 and reiterated in the rationale
of DR 221 (and echoed again in DR 303) specify that num_get&lt;charT&gt;::
do_get() compares characters on the stream against the widened elements
of "012...abc...ABCX+-"
</p>

<p>
An implementation is required to allow programs to instantiate the num_get
template on any charT that satisfies the requirements on a user-defined
character type. These requirements do not include the ability of the
character type to be equality comparable (the char_traits template must
be used to perform tests for equality). Hence, the num_get template cannot
be implemented to support any arbitrary character type. The num_get template
must either make the assumption that the character type is equality-comparable
(as some popular implementations do), or it may use char_traits&lt;charT&gt; to do
the comparisons (some other popular implementations do that). This diversity
of approaches makes it difficult to write portable programs that attempt to
instantiate the num_get template on user-defined types.
</p>

<p><i>[Kona: the heart of the problem is that we're theoretically
  supposed to use traits classes for all fundamental character
  operations like assignment and comparison, but facets don't have
  traits parameters.  This is a fundamental design flaw and it
  appears all over the place, not just in this one place.  It's not
  clear what the correct solution is, but a thorough review of facets
  and traits is in order.  The LWG considered and rejected the
  possibility of changing numeric facets to use narrowing instead of
  widening.  This may be a good idea for other reasons (see issue
  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#459">459</a>), but it doesn't solve the problem raised by this
  issue.  Whether we use widen or narrow the <tt>num_get</tt> facet
  still has no idea which traits class the user wants to use for 
  the comparison, because only streams, not facets, are passed traits
  classes.   The standard does not require that two different
  traits classes with the same <tt>char_type</tt> must necessarily 
  have the same behavior.]</i></p>


<p>Informally, one possibility: require that some of the basic
character operations, such as <tt>eq</tt>, <tt>lt</tt>,
and <tt>assign</tt>, must behave the same way for all traits classes
with the same <tt>char_type</tt>.  If we accept that limitation on
traits classes, then the facet could reasonably be required to
use <tt>char_traits&lt;charT&gt;</tt>.</p>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
There was general agreement that the standard only needs to specify the
behavior when the character type is char or wchar_t.
</p>
<p>
Beman: we don't need to worry about C++1x because there is a non-zero
possibility that we would have a replacement facility for iostreams that
would solve these problems.
</p>
<p>
We need to change the following sentence in [locale.category], paragraph
6 to specify that C is char and wchar_t:
</p>
<p>
"A template formal parameter with name C represents the set of all
possible specializations on a parameter that satisfies the requirements
for a character on which any member of the iostream components can be
instantiated."
</p>
<p>
We also need to specify in 27 that the basic character operations, such
as eq, lt, and assign use std::char_traits.
</p>
<p>
Daniel volunteered to provide wording.
</p>
</blockquote>

<p><i>[
2009-09-19 Daniel provided wording.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Leave as Open. Alisdair and/or Tom will provide wording based on discussions.
We want to clearly state that streams and locales work just on <tt>char</tt>
and <tt>wchar_t</tt> (except where otherwise specified).
</blockquote>

<p><i>[
2010-02-06 Tom updated the proposed wording.
]</i></p>


<blockquote>
<p><i>[
The original proposed wording is preserved here:
]</i></p>


<blockquote class="note">
<ol>
<li>
<p>
Change 22.3.1.1.1 [locale.category]/6:
</p>

<blockquote>
[..] A template formal parameter with name <tt>C</tt> represents the set of all possible
specializations on a <ins><tt>char</tt> or <tt>wchar_t</tt></ins> parameter<del> that satisfies
the requirements for a character on which any of the iostream components
can be instantiated</del>. [..]
</blockquote>
</li>

<li>
<p>
Add the following sentence to the end of 22.4.2 [category.numeric]/2:
</p>

<blockquote>
[..] These specializations refer to [..], and also for the <tt>ctype&lt;&gt;</tt> facet to
perform character classification. <ins>Implementations are encouraged
but not required to use the <tt>char_traits&lt;charT&gt;</tt> functions for all
comparisons and assignments of characters of type <tt>charT</tt> that do
not belong to the set of required specializations.</ins>
</blockquote>
</li>

<li>
<p>
Change 22.4.2.1.2 [facet.num.get.virtuals]/3:
</p>

<blockquote>
<p>
Stage 2: If <tt>in==end</tt> then stage 2 terminates. Otherwise a <tt>charT</tt> is taken
from <tt>in</tt> and local variables are initialized as if by
</p>

<blockquote><pre>char_type ct = *in;
<ins>using tr = char_traits&lt;char_type&gt;;
const char_type* pos = tr::find(atoms, sizeof(src) - 1, ct);</ins>
char c = src[<del>find(atoms, atoms + sizeof(src) - 1, ct) - atoms</del>
             <ins>pos ? pos - atoms : sizeof(src) - 1</ins>];
if (<ins>tr::eq(ct, </ins><del>ct == </del>use_facet&lt;numpunct&lt;charT&gt;(loc).decimal_point()<ins>)</ins>)
    c = '.';
bool discard =
    <ins>tr::eq(ct, </ins><del>ct == </del>use_facet&lt;numpunct&lt;charT&gt;(loc).thousands_sep()<ins>)</ins>
    &amp;&amp; use_facet&lt;numpunct&lt;charT&gt; &gt;(loc).grouping().length() != 0;
</pre></blockquote>

<p>
where the values <tt>src</tt> and <tt>atoms</tt> are defined as if by: [..]
</p>
</blockquote>

<p>
[Remark of the author: I considered to replace the initialization
"<tt>char_type ct = *in;</tt>"
by the sequence "<tt>char_type ct; tr::assign(ct, *in);</tt>", but decided
against it, because
it is a copy-initialization context, not an assignment]
</p>
</li>

<li>
<p>
Add the following sentence to the end of 22.4.5 [category.time]/1:
</p>

<blockquote>
[..] Their members use [..] , to determine formatting details.
<ins>Implementations are encouraged but not required to use the
<tt>char_traits&lt;charT&gt;</tt> functions for all comparisons and assignments
of characters of type <tt>charT</tt> that do
not belong to the set of required specializations.</ins>
</blockquote>
</li>

<li>
<p>
Change 22.4.5.1.1 [locale.time.get.members]/8 bullet 4:
</p>

<ul>
<li>
<del>The next element of <tt>fmt</tt> is equal to <tt>'%'</tt></del> <ins>For the next element <tt>c</tt>
of <tt>fmt char_traits&lt;char_type&gt;::eq(c, use_facet&lt;ctype&lt;char_type&gt;&gt;(f.getloc()).widen('%')) == true</tt></ins>,
[..]
</li>
</ul>
</li>

<li>
<p>
Add the following sentence to the end of 22.4.6 [category.monetary]/2:
</p>

<blockquote>
Their members use [..] to determine formatting details.
<ins>Implementations are encouraged but not required to use the
<tt>char_traits&lt;charT&gt;</tt> functions for all comparisons and assignments
of characters of type <tt>charT</tt> that do
not belong to the set of required specializations.</ins>
</blockquote>
</li>

<li>
<p>
Change 22.4.6.1.2 [locale.money.get.virtuals]/4:
</p>

<blockquote>
<p>
[..] The value <tt>units</tt> is produced as if by:
</p>

<blockquote><pre>for (int i = 0; i &lt; n; ++i)
  buf2[i] = src[<ins>char_traits&lt;charT&gt;::</ins>find(atoms, <del>atoms+</del>sizeof(src), buf1[i]) - atoms];
buf2[n] = 0;
sscanf(buf2, "%Lf", &amp;units);
</pre></blockquote>
</blockquote>
</li>

<li>
<p>
Change 22.4.6.2.2 [locale.money.put.virtuals]/1:
</p>

<blockquote>
[..] for character buffers <tt>buf1</tt> and <tt>buf2</tt>. If <ins>for</ins> the first
character <ins><tt>c</tt></ins>
in <tt>digits</tt> or <tt>buf2</tt> <del>is equal to
<tt>ct.widen('-')</tt></del><ins><tt>char_traits&lt;charT&gt;::eq(c,
ct.widen('-')) == true</tt></ins>, [..]
</blockquote>
</li>

<li>
<p>
Add a footnote to the first sentence of 27.7.1.2.2 [istream.formatted.arithmetic]/1:
</p>

<blockquote>
<p>
As in the case of the inserters, these extractors depend on the locale's
<tt>num_get&lt;&gt;</tt> (22.4.2.1) object to perform parsing the input stream
data.<ins><sup>(footnote)</sup></ins> [..]
</p>

<p>
<ins>
<sup>footnote)</sup> If the traits of the input stream has different semantics for <tt>lt()</tt>,
<tt>eq()</tt>, and <tt>assign()</tt> than <tt>char_traits&lt;char_type&gt;</tt>, this may give surprising
results.
</ins>
</p>
</blockquote>
</li>

<li>
<p>
Add a footnote to the second sentence of 27.7.2.6.2 [ostream.inserters.arithmetic]/1:
</p>

<blockquote>
<p>
<i>Effects:</i> The classes <tt>num_get&lt;&gt;</tt> and
<tt>num_put&lt;&gt;</tt> handle locale-dependent numeric formatting and
parsing. These inserter functions use the imbued locale value to perform
numeric formatting.<ins><sup>(footnote)</sup></ins> [..]
</p>

<p>
<ins>
<sup>footnote)</sup> If the traits of the output stream has different semantics for <tt>lt()</tt>,
<tt>eq()</tt>, and <tt>assign()</tt> than <tt>char_traits&lt;char_type&gt;</tt>, this may give surprising
results.
</ins>
</p>
</blockquote>
</li>

<li>
<p>
Add a footnote after the first sentence of 27.7.4 [ext.manip]/4:
</p>

<blockquote>
<p>
<i>Returns:</i> An object of unspecified type such that if in is an object of type
<tt>basic_istream&lt;charT, traits&gt;</tt> then the expression <tt>in &gt;&gt; get_money(mon, intl)</tt>
behaves as if it called <tt>f(in, mon, intl)</tt>, where the function <tt>f</tt> is defined
as:<ins><sup>(footnote)</sup></ins> [..]
</p>

<p>
<ins>
<sup>footnote)</sup> If the traits of the input stream has different semantics for <tt>lt()</tt>,
<tt>eq()</tt>, and <tt>assign()</tt> than <tt>char_traits&lt;char_type&gt;</tt>, this may give surprising
results.
</ins>
</p>
</blockquote>
</li>

<li>
<p>
Add a footnote after the first sentence of 27.7.4 [ext.manip]/5:
</p>

<blockquote>
<p>
<i>Returns:</i> An object of unspecified type such that if <tt>out</tt> is an object of type
<tt>basic_ostream&lt;charT, traits&gt;</tt> then the expression <tt>out &lt;&lt; put_money(mon, intl)</tt>
behaves as a formatted input function that calls <tt>f(out, mon, intl)</tt>, where the
function <tt>f</tt> is defined as:<ins><sup>(footnote)</sup></ins> [..]
</p>

<p>
<ins>
<sup>footnote)</sup> If the traits of the output stream has different semantics for <tt>lt()</tt>,
<tt>eq()</tt>, and <tt>assign()</tt> than <tt>char_traits&lt;char_type&gt;</tt>, this may give surprising
results.
</ins>
</p>
</blockquote>
</li>

<li>
<p>
13) Add a footnote after the first sentence of 27.7.4 [ext.manip]/8:
</p>

<blockquote>
<p>
<i>Returns:</i> An object of unspecified type such that if <tt>in</tt> is an
object of type b<tt>asic_istream&lt;charT, traits&gt;</tt> then the expression
<tt>in &gt;&gt;get_time(tmb, fmt)</tt> behaves as if it called <tt>f(in, tmb, fmt)</tt>,
where the function <tt>f</tt> is defined as:<ins><sup>(footnote)</sup></ins> [..]
</p>

<p>
<ins>
<sup>footnote)</sup> If the traits of the input stream has different semantics for <tt>lt()</tt>,
<tt>eq()</tt>, and <tt>assign()</tt> than <tt>char_traits&lt;char_type&gt;</tt>, this may give surprising
results.
</ins>
</p>
</blockquote>
</li>

<li>
<p>
Add a footnote after the first sentence of 27.7.4 [ext.manip]/10:
</p>

<blockquote>
<p>
Returns: An object of unspecified type such that if <tt>out</tt> is an object of type
<tt>basic_ostream&lt;charT, traits&gt;</tt> then the expression <tt>out &lt;&lt;put_time(tmb, fmt)</tt>
behaves as if it called <tt>f(out, tmb, fmt)</tt>, where the function <tt>f</tt> is defined
as:<ins><sup>(footnote)</sup></ins> [..]
</p>

<p>
<ins>
<sup>footnote)</sup> If the traits of the output stream has different semantics for <tt>lt()</tt>,
<tt>eq()</tt>, and <tt>assign()</tt> than <tt>char_traits&lt;char_type&gt;</tt>, this may give surprising
results.
</ins>
</p>
</blockquote>
</li>
</ol>

</blockquote>
</blockquote>

<p><i>[
2010 Pittsburgh:
]</i></p>


<blockquote>
<p>
Moved to Ready with only two of the bullets.  The original wording is preserved
here:
</p>

<blockquote class="note">
<ol>
<li>
<p>
Change 22.3.1.1.1 [locale.category]/6:
</p>

<blockquote>
[..] A template formal parameter with name <tt>C</tt> represents 
the set 
<del>of all possible specializations on a</del> 
<ins>of types containing <tt>char</tt>, <tt>wchar_t</tt>,
and any other implementation-defined character type
</ins>
<del> parameter</del>
that satisfies
the requirements for a character on which any of the iostream components
can be instantiated. [..]
</blockquote>
</li>

<li>
<p>
Add the following sentence to the end of 22.4.2 [category.numeric]/2:
</p>

<blockquote>
[..] These specializations refer to [..], and also for the <tt>ctype&lt;&gt;</tt> facet to
perform character classification. <ins>[<i>Note:</i> Implementations are encouraged
but not required to use the <tt>char_traits&lt;charT&gt;</tt> functions for all
comparisons and assignments of characters of type <tt>charT</tt> that do
not belong to the set of required specializations - <i>end note</i>].</ins>
</blockquote>
</li>

<li>
<p>
Change 22.4.2.1.2 [facet.num.get.virtuals]/3:
</p>

<blockquote>
<p>
Stage 2: If <tt>in==end</tt> then stage 2 terminates. Otherwise a <tt>charT</tt> is taken
from <tt>in</tt> and local variables are initialized as if by
</p>

<blockquote><pre>char_type ct = *in;
<ins>using tr = char_traits&lt;char_type&gt;;
const char_type* pos = tr::find(atoms, sizeof(src) - 1, ct);</ins>
char c = src[<del>find(atoms, atoms + sizeof(src) - 1, ct) - atoms</del>
             <ins>pos ? pos - atoms : sizeof(src) - 1</ins>];
if (<ins>tr::eq(ct, </ins><del>ct == </del>use_facet&lt;numpunct&lt;charT&gt;(loc).decimal_point()<ins>)</ins>)
    c = '.';
bool discard =
    <ins>tr::eq(ct, </ins><del>ct == </del>use_facet&lt;numpunct&lt;charT&gt;(loc).thousands_sep()<ins>)</ins>
    &amp;&amp; use_facet&lt;numpunct&lt;charT&gt; &gt;(loc).grouping().length() != 0;
</pre></blockquote>

<p>
where the values <tt>src</tt> and <tt>atoms</tt> are defined as if by: [..]
</p>
</blockquote>

<p>
[Remark of the author: I considered to replace the initialization
"<tt>char_type ct = *in;</tt>"
by the sequence "<tt>char_type ct; tr::assign(ct, *in);</tt>", but decided
against it, because
it is a copy-initialization context, not an assignment]
</p>
</li>

<li>
<p>
Add the following sentence to the end of 22.4.5 [category.time]/1:
</p>

<blockquote>
[..] Their members use [..] , to determine formatting details.
<ins>[<i>Note:</i> Implementations are encouraged but not required to use the
<tt>char_traits&lt;charT&gt;</tt> functions for all comparisons and assignments
of characters of type <tt>charT</tt> that do
not belong to the set of required specializations - <i>end note</i>].</ins>
</blockquote>
</li>

<li>
<p>
Change 22.4.5.1.1 [locale.time.get.members]/8 bullet 4:
</p>

<ul>
<li>
<del>The next element of <tt>fmt</tt> is equal to <tt>'%'</tt></del> <ins>For the next element <tt>c</tt>
of <tt>fmt char_traits&lt;char_type&gt;::eq(c, use_facet&lt;ctype&lt;char_type&gt;&gt;(f.getloc()).widen('%')) == true</tt></ins>,
[..]
</li>
</ul>
</li>

<li>
<p>
Add the following sentence to the end of 22.4.6 [category.monetary]/2:
</p>

<blockquote>
Their members use [..] to determine formatting details.
<ins>[<i>Note:</i> Implementations are encouraged but not required to use the
<tt>char_traits&lt;charT&gt;</tt> functions for all comparisons and assignments
of characters of type <tt>charT</tt> that do
not belong to the set of required specializations - <i>end note</i>].</ins>
</blockquote>
</li>

<li>
<p>
Change 22.4.6.1.2 [locale.money.get.virtuals]/4:
</p>

<blockquote>
<p>
[..] The value <tt>units</tt> is produced as if by:
</p>

<blockquote><pre>for (int i = 0; i &lt; n; ++i)
  buf2[i] = src[<ins>char_traits&lt;charT&gt;::</ins>find(atoms, <del>atoms+</del>sizeof(src), buf1[i]) - atoms];
buf2[n] = 0;
sscanf(buf2, "%Lf", &amp;units);
</pre></blockquote>
</blockquote>
</li>

<li>
<p>
Change 22.4.6.2.2 [locale.money.put.virtuals]/1:
</p>

<blockquote>
[..] for character buffers <tt>buf1</tt> and <tt>buf2</tt>. If <ins>for</ins> the first
character <ins><tt>c</tt></ins>
in <tt>digits</tt> or <tt>buf2</tt> <del>is equal to
<tt>ct.widen('-')</tt></del><ins><tt>char_traits&lt;charT&gt;::eq(c,
ct.widen('-')) == true</tt></ins>, [..]
</blockquote>
</li>

<li>
<p>
Add a new paragraph after the 
first paragraph of 27.2.2 [iostreams.limits.pos]/1:
</p>
<blockquote>
In the classes of clause 27,
a template formal parameter with name <tt>charT</tt> represents 
one of
the set of types
containing <tt>char</tt>, <tt>wchar_t</tt>,
and any other implementation-defined character type
that satisfies
the requirements for a character on which any of the iostream components
can be instantiated.
</blockquote>
</li>

<li>
<p>
Add a footnote to the first sentence of 27.7.1.2.2 [istream.formatted.arithmetic]/1:
</p>

<blockquote>
<p>
As in the case of the inserters, these extractors depend on the locale's
<tt>num_get&lt;&gt;</tt> (22.4.2.1) object to perform parsing the input stream
data.<ins><sup>(footnote)</sup></ins> [..]
</p>

<p>
<ins>
<sup>footnote)</sup> If the traits of the input stream has different semantics for <tt>lt()</tt>,
<tt>eq()</tt>, and <tt>assign()</tt> than <tt>char_traits&lt;char_type&gt;</tt>, this may give surprising
results.
</ins>
</p>
</blockquote>
</li>

<li>
<p>
Add a footnote to the second sentence of 27.7.2.6.2 [ostream.inserters.arithmetic]/1:
</p>

<blockquote>
<p>
<i>Effects:</i> The classes <tt>num_get&lt;&gt;</tt> and
<tt>num_put&lt;&gt;</tt> handle locale-dependent numeric formatting and
parsing. These inserter functions use the imbued locale value to perform
numeric formatting.<ins><sup>(footnote)</sup></ins> [..]
</p>

<p>
<ins>
<sup>footnote)</sup> If the traits of the output stream has different semantics for <tt>lt()</tt>,
<tt>eq()</tt>, and <tt>assign()</tt> than <tt>char_traits&lt;char_type&gt;</tt>, this may give surprising
results.
</ins>
</p>
</blockquote>
</li>


<li>
<p>
Add a footnote after the first sentence of 27.7.4 [ext.manip]/4:
</p>

<blockquote>
<p>
<i>Returns:</i> An object of unspecified type such that if in is an object of type
<tt>basic_istream&lt;charT, traits&gt;</tt> then the expression <tt>in &gt;&gt; get_money(mon, intl)</tt>
behaves as if it called <tt>f(in, mon, intl)</tt>, where the function <tt>f</tt> is defined
as:<ins><sup>(footnote)</sup></ins> [..]
</p>

<p>
<ins>
<sup>footnote)</sup> If the traits of the input stream has different semantics for <tt>lt()</tt>,
<tt>eq()</tt>, and <tt>assign()</tt> than <tt>char_traits&lt;char_type&gt;</tt>, this may give surprising
results.
</ins>
</p>
</blockquote>
</li>

<li>
<p>
Add a footnote after the first sentence of 27.7.4 [ext.manip]/5:
</p>

<blockquote>
<p>
<i>Returns:</i> An object of unspecified type such that if <tt>out</tt> is an object of type
<tt>basic_ostream&lt;charT, traits&gt;</tt> then the expression <tt>out &lt;&lt; put_money(mon, intl)</tt>
behaves as a formatted input function that calls <tt>f(out, mon, intl)</tt>, where the
function <tt>f</tt> is defined as:<ins><sup>(footnote)</sup></ins> [..]
</p>

<p>
<ins>
<sup>footnote)</sup> If the traits of the output stream has different semantics for <tt>lt()</tt>,
<tt>eq()</tt>, and <tt>assign()</tt> than <tt>char_traits&lt;char_type&gt;</tt>, this may give surprising
results.
</ins>
</p>
</blockquote>
</li>

<li>
<p>
Add a footnote after the first sentence of 27.7.4 [ext.manip]/8:
</p>

<blockquote>
<p>
<i>Returns:</i> An object of unspecified type such that if <tt>in</tt> is an
object of type b<tt>asic_istream&lt;charT, traits&gt;</tt> then the expression
<tt>in &gt;&gt;get_time(tmb, fmt)</tt> behaves as if it called <tt>f(in, tmb, fmt)</tt>,
where the function <tt>f</tt> is defined as:<ins><sup>(footnote)</sup></ins> [..]
</p>

<p>
<ins>
<sup>footnote)</sup> If the traits of the input stream has different semantics for <tt>lt()</tt>,
<tt>eq()</tt>, and <tt>assign()</tt> than <tt>char_traits&lt;char_type&gt;</tt>, this may give surprising
results.
</ins>
</p>
</blockquote>
</li>

<li>
<p>
Add a footnote after the first sentence of 27.7.4 [ext.manip]/10:
</p>

<blockquote>
<p>
Returns: An object of unspecified type such that if <tt>out</tt> is an object of type
<tt>basic_ostream&lt;charT, traits&gt;</tt> then the expression <tt>out &lt;&lt;put_time(tmb, fmt)</tt>
behaves as if it called <tt>f(out, tmb, fmt)</tt>, where the function <tt>f</tt> is defined
as:<ins><sup>(footnote)</sup></ins> [..]
</p>

<p>
<ins>
<sup>footnote)</sup> If the traits of the output stream has different semantics for <tt>lt()</tt>,
<tt>eq()</tt>, and <tt>assign()</tt> than <tt>char_traits&lt;char_type&gt;</tt>, this may give surprising
results.
</ins>
</p>
</blockquote>
</li>
</ol>
</blockquote>
</blockquote>



<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>
Change 22.3.1.1.1 [locale.category]/6:
</p>

<blockquote>
[..] A template formal parameter with name <tt>C</tt> represents 
the set 
<del>of all possible specializations on a</del> 
<ins>of types containing <tt>char</tt>, <tt>wchar_t</tt>,
and any other implementation-defined character type
</ins>
<del> parameter</del>
that satisfies
the requirements for a character on which any of the iostream components
can be instantiated. [..]
</blockquote>
</li>

<li>
<p>
Add a new paragraph after the 
first paragraph of 27.2.2 [iostreams.limits.pos]/1:
</p>
<blockquote>
In the classes of clause 27,
a template formal parameter with name <tt>charT</tt> represents 
one of
the set of types
containing <tt>char</tt>, <tt>wchar_t</tt>,
and any other implementation-defined character type
that satisfies
the requirements for a character on which any of the iostream components
can be instantiated.
</blockquote>
</li>

</ol>




<hr>
<h3><a name="428"></a>428. string::erase(iterator) validity</h3>
<p><b>Section:</b> 21.4.6.5 [string::erase] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2003-09-18 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#string::erase">issues</a> in [string::erase].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
23.1.1, p3 along with Table 67 specify as a prerequisite for a.erase(q)
that q must be a valid dereferenceable iterator into the sequence a.
</p>

<p>
However, 21.3.5.5, p5 describing string::erase(p) only requires that
p be a valid iterator.
</p>

<p>
This may be interepreted as a relaxation of the general requirement,
which is most likely not the intent.
</p>


<p><b>Proposed resolution:</b></p>
<p>Remove 21.4.6.5 [string::erase] paragraph 5.</p>


<p><b>Rationale:</b></p>
<p>The LWG considered two options: changing the string requirements to
  match the general container requirements, or just removing the
  erroneous string requirements altogether.  The LWG chose the latter
  option, on the grounds that duplicating text always risks the
  possibility that it might be duplicated incorrectly.</p>





<hr>
<h3><a name="430"></a>430. valarray subset operations</h3>
<p><b>Section:</b> 26.6.2.4 [valarray.sub] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2003-09-18 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The standard fails to specify the behavior of valarray::operator[](slice)
and other valarray subset operations when they are passed an "invalid"
slice object, i.e., either a slice that doesn't make sense at all (e.g.,
slice (0, 1, 0) or one that doesn't specify a valid subset of the valarray
object (e.g., slice (2, 1, 1) for a valarray of size 1).
</p>
<p><i>[Kona: the LWG believes that invalid slices should invoke
  undefined behavior.  Valarrays are supposed to be designed for high
  performance, so we don't want to require specific checking.  We
  need wording to express this decision.]</i></p>


<p><i>[
Bellevue:
]</i></p>


<blockquote>
Please note that the standard also fails to specify the behavior of
slice_array and gslice_array in the valid case. Bill Plauger will
endeavor to provide revised wording for slice_array and gslice_array.
</blockquote>

<p><i>[
post-Bellevue:  Bill provided wording.
]</i></p>


<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
Move to Ready.
</p>
</blockquote>

<p><i>[
2009-11-04 Pete opens:
]</i></p>


<blockquote>
The resolution to LWG issue 430 has not been applied --- there have been
changes to the underlying text, and the resolution needs to be reworked.
</blockquote>

<p><i>[
2010-03-09 Matt updated wording.
]</i></p>


<p><i>[
2010 Pittsburgh: Moved to Ready for Pittsburgh.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
Replace 26.6.2.4 [valarray.sub], with the following:
</p>

<blockquote>
<p>
The member operator is overloaded to provide several ways to select
sequences of elements from among those controlled by <tt>*this</tt>.
Each of these operations returns a subset of the array.  The
const-qualified versions return this subset as a new <tt>valarray</tt>. The
non-const versions return a class template object which has reference
semantics to the original array, working in conjunction with various
overloads of <tt>operator=</tt> (and other assigning operators) to allow
selective replacement (slicing) of the controlled sequence. In each case
the selected element(s) must exist.
</p>

<pre>valarray&lt;T&gt; operator[](slice slicearr) const; 
</pre>

<blockquote>
<p>
This function returns an object of class <tt>valarray&lt;T&gt;</tt>
containing those elements of the controlled sequence designated by
<tt>slicearr</tt>. [<i>Example:</i>
</p>

<blockquote><pre>valarray&lt;char&gt; v0("abcdefghijklmnop", 16); 
valarray&lt;char&gt; v1("ABCDE", 5); 
v0[slice(2, 5, 3)] = v1; 
// v0 == valarray&lt;char&gt;("abAdeBghCjkDmnEp", 16)
</pre></blockquote>
<p>
<i>end example</i>]
</p>
</blockquote>
 
<pre>valarray&lt;T&gt; operator[](slice slicearr); 
</pre>

<blockquote>
<p>
This function selects those elements of the controlled sequence
designated by <tt>slicearr</tt>.  [<i>Example</i>:
</p>

<blockquote><pre>valarray&lt;char&gt; v0("abcdefghijklmnop", 16); 
valarray&lt;char&gt; v1("ABCDE", 5); 
v0[slice(2, 5, 3)] = v1; 
// v0 == valarray&lt;char&gt;("abAdeBghCjkDmnEp", 16)
</pre></blockquote>
<p>
<i>end example</i>]
</p>
</blockquote>
 
<pre>valarray&lt;T&gt; operator[](const gslice&amp; gslicearr) const; 
</pre>

<blockquote>
<p>
This function returns an object of class <tt>valarray&lt;T&gt;</tt>
containing those elements of the controlled sequence designated by
<tt>gslicearr</tt>. [<i>Example:</i>
</p>

<blockquote><pre>valarray&lt;char&gt; v0("abcdefghijklmnop", 16); 
const size_t lv[] = {2, 3}; 
const size_t dv[] = {7, 2}; 
const valarray&lt;size_t&gt; len(lv, 2), str(dv, 2); 
// v0[gslice(3, len, str)] returns 
// valarray&lt;char&gt;("dfhkmo", 6)
</pre></blockquote>
<p>
<i>end example</i>]
</p>
</blockquote>
 
<pre>gslice_array&lt;T&gt; operator[](const gslice&amp; gslicearr); 
</pre>

<blockquote>
<p>
This function selects those elements of the controlled sequence
designated by <tt>gslicearr</tt>.  [<i>Example:</i>
</p>

<blockquote><pre>valarray&lt;char&gt; v0("abcdefghijklmnop", 16); 
valarray&lt;char&gt; v1("ABCDEF", 6); 
const size_t lv[] = {2, 3}; 
const size_t dv[] = {7, 2}; 
const valarray&lt;size_t&gt; len(lv, 2), str(dv, 2); 
v0[gslice(3, len, str)] = v1; 
// v0 == valarray&lt;char&gt;("abcAeBgCijDlEnFp", 16)
</pre></blockquote>
<p>
<i>end example</i>]
</p>
</blockquote>
 
<pre>valarray&lt;T&gt; operator[](const valarray&lt;bool&gt;&amp; boolarr) const; 
</pre>

<blockquote>
<p>
This function returns an object of class <tt>valarray&lt;T&gt;</tt>
containing those elements of the controlled sequence designated by
<tt>boolarr</tt>. [<i>Example:</i>
</p>

<blockquote><pre>valarray&lt;char&gt; v0("abcdefghijklmnop", 16); 
const bool vb[] = {false, false, true, true, false, true}; 
// v0[valarray&lt;bool&gt;(vb, 6)] returns 
// valarray&lt;char&gt;("cdf", 3)
</pre></blockquote>
<p>
<i>end example</i>] 
</p>
</blockquote>
 
<pre>mask_array&lt;T&gt; operator[](const valarray&lt;bool&gt;&amp; boolarr); 
</pre>

<blockquote>
<p>
This function selects those elements of the controlled sequence
designated by <tt>boolarr</tt>. [<i>Example:</i>
</p>

<blockquote><pre>valarray&lt;char&gt; v0("abcdefghijklmnop", 16); 
valarray&lt;char&gt; v1("ABC", 3); 
const bool vb[] = {false, false, true, true, false, true}; 
v0[valarray&lt;bool&gt;(vb, 6)] = v1; 
// v0 == valarray&lt;char&gt;("abABeCghijklmnop", 16)
</pre></blockquote>
<p>
<i>end example</i>]
</p>
</blockquote>
 
<pre>valarray&lt;T&gt; operator[](const valarray&lt;size_t&gt;&amp; indarr) const; 
</pre>

<blockquote>
<p>
This function returns an object of class <tt>valarray&lt;T&gt;</tt>
containing those elements of the controlled sequence designated by
<tt>indarr</tt>. [<i>Example:</i>
</p>

<blockquote><pre>valarray&lt;char&gt; v0("abcdefghijklmnop", 16); 
const size_t vi[] = {7, 5, 2, 3, 8}; 
// v0[valarray&lt;size_t&gt;(vi, 5)] returns 
// valarray&lt;char&gt;("hfcdi", 5)
</pre></blockquote>
<p>
<i>end example</i>] 
</p>
</blockquote>
 
<pre>indirect_array&lt;T&gt; operator[](const valarray&lt;size_t&gt;&amp; indarr);
</pre>

<blockquote>
<p>
This function selects those elements of the controlled sequence
designated by <tt>indarr</tt>. [<i>Example:</i>
</p>

<blockquote><pre>valarray&lt;char&gt; v0("abcdefghijklmnop", 16); 
valarray&lt;char&gt; v1("ABCDE", 5); 
const size_t vi[] = {7, 5, 2, 3, 8}; 
v0[valarray&lt;size_t&gt;(vi, 5)] = v1; 
// v0 == valarray&lt;char&gt;("abCDeBgAEjklmnop", 16)
</pre></blockquote>
<p>
<i>end example</i>]
</p>
</blockquote>

</blockquote>





<hr>
<h3><a name="431"></a>431. Swapping containers with unequal allocators</h3>
<p><b>Section:</b> 20.2.5 [allocator.requirements], 25 [algorithms] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2003-09-20 <b>Last modified:</b> 2010-11-20</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#allocator.requirements">issues</a> in [allocator.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p>Clause 20.2.5 [allocator.requirements] paragraph 4 says that implementations
  are permitted to supply containers that are unable to cope with
  allocator instances and that container implementations may assume
  that all instances of an allocator type compare equal.  We gave
  implementers this latitude as a temporary hack, and eventually we
  want to get rid of it.  What happens when we're dealing with
  allocators that <i>don't</i> compare equal?
</p>

<p>In particular: suppose that <tt>v1</tt> and <tt>v2</tt> are both
  objects of type <tt>vector&lt;int, my_alloc&gt;</tt> and that
  <tt>v1.get_allocator() != v2.get_allocator()</tt>.  What happens if
  we write <tt>v1.swap(v2)</tt>?  Informally, three possibilities:</p>

<p>1. This operation is illegal.  Perhaps we could say that an
  implementation is required to check and to throw an exception, or
  perhaps we could say it's undefined behavior.</p>
<p>2. The operation performs a slow swap (i.e. using three
  invocations of <tt>operator=</tt>, leaving each allocator with its
  original container.  This would be an O(N) operation.</p>
<p>3. The operation swaps both the vectors' contents and their
  allocators.  This would be an O(1) operation. That is:</p>
  <blockquote>
  <pre>    my_alloc a1(...);
    my_alloc a2(...);
    assert(a1 != a2);

    vector&lt;int, my_alloc&gt; v1(a1);
    vector&lt;int, my_alloc&gt; v2(a2);
    assert(a1 == v1.get_allocator());
    assert(a2 == v2.get_allocator());

    v1.swap(v2);
    assert(a1 == v2.get_allocator());
    assert(a2 == v1.get_allocator());
  </pre>
  </blockquote>

<p><i>[Kona: This is part of a general problem.  We need a paper
  saying how to deal with unequal allocators in general.]</i></p>


<p><i>[pre-Sydney: Howard argues for option 3 in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1599.html">N1599</a>.
]</i></p>


<p><i>[
2007-01-12, Howard:  This issue will now tend to come up more often with move constructors
and move assignment operators.  For containers, these members transfer resources (i.e.
the allocated memory) just like swap.
]</i></p>


<p><i>[
Batavia:  There is agreement to overload the container <tt>swap</tt> on the allocator's Swappable
requirement using concepts.  If the allocator supports Swappable, then container's swap will
swap allocators, else it will perform a "slow swap" using copy construction and copy assignment.
]</i></p>


<p><i>[
2009-04-28 Pablo adds:
]</i></p>

<blockquote>
Fixed in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2525.pdf">N2525</a>.
I argued for marking this Tentatively-Ready right after Bellevue,
but there was a concern that
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2525.pdf">N2525</a>
would break in the presence of the RVO. (That breakage had nothing to do with
swap, but never-the-less). I addressed that breakage in in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2840.pdf">N2840</a>
(Summit) by means of a non-normative reference:

<blockquote>
[<i>Note:</i> in situations where the copy constructor for a container is elided,
this function is not called. The behavior in these cases is as if
<tt>select_on_container_copy_construction</tt> returned <tt>x</tt>  <i>end note</i>]
</blockquote>

</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
<del>NAD Editorial</del><ins>Resolved</ins>.  Addressed by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2982.pdf">N2982</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="432"></a>432. stringbuf::overflow() makes only one write position available</h3>
<p><b>Section:</b> 27.8.1.4 [stringbuf.virtuals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Christian W Brock <b>Opened:</b> 2003-09-24 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#stringbuf.virtuals">issues</a> in [stringbuf.virtuals].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>27.7.1.3 par 8 says:</p>
<blockquote><p>
Notes: The function can make a write position available only if
    ( mode &amp; ios_base::out) != 0. To make a write position
    available, the function reallocates (or initially allocates) an
    array object with a sufficient number of elements to hold the
    current array object (if any), plus one additional write position.
    If ( mode &amp; ios_base::in) != 0, the function alters the read end
    pointer egptr() to point just past the new write position (as
    does the write end pointer epptr()).
</p></blockquote>

<p>
The sentences "plus one additional write position." and especially
    "(as does the write end pointer epptr())" COULD by interpreted
    (and is interpreted by at least my library vendor) as:
</p>

<blockquote><p>
    post-condition: epptr() == pptr()+1
</p></blockquote>

<p>
This WOULD force sputc() to call the virtual overflow() each time.
</p>

<p>The proposed change also affects Defect Report 169.</p>



<p><b>Proposed resolution:</b></p>
<p>27.7.1.1/2 Change:</p>

<blockquote><p>
2- Notes: The function allocates no array object.
</p></blockquote>

<p>
to:
</p>

<blockquote><p>
2- Postcondition: str() == "".
</p></blockquote>

<p>
27.7.1.1/3 Change:
</p>

<blockquote>
<p>
-3- Effects: Constructs an object of class basic_stringbuf,
initializing the base class with basic_streambuf()
(lib.streambuf.cons), and initializing mode with which . Then copies
the content of str into the basic_stringbuf underlying character
sequence and initializes the input and output sequences according to
which. If which &amp; ios_base::out is true, initializes the output
sequence with the underlying sequence. If which &amp; ios_base::in is
true, initializes the input sequence with the underlying sequence.
</p>
</blockquote>

<p>to:</p>

<blockquote>
<p>
-3- Effects: Constructs an object of class basic_stringbuf,
initializing the base class with basic_streambuf()
(lib.streambuf.cons), and initializing mode with which. Then copies
the content of str into the basic_stringbuf underlying character
sequence. If which &amp; ios_base::out is true, initializes the output
sequence such that pbase() points to the first underlying character,
epptr() points one past the last underlying character, and if (which &amp;
ios_base::ate) is true, pptr() is set equal to
epptr() else pptr() is set equal to pbase(). If which &amp; ios_base::in
is true, initializes the input sequence such that eback() and gptr()
point to the first underlying character and egptr() points one past
the last underlying character.
</p>
</blockquote>

<p>27.7.1.2/1 Change:</p>

<blockquote>
<p>
-1- Returns: A basic_string object whose content is equal to the
basic_stringbuf underlying character sequence. If the buffer is only
created in input mode, the underlying character sequence is equal to
the input sequence; otherwise, it is equal to the output sequence. In
case of an empty underlying character sequence, the function returns
basic_string&lt;charT,traits,Allocator&gt;().
</p>
</blockquote>

<p>to:</p>

<blockquote>
<p>
-1- Returns: A basic_string object whose content is equal to the
basic_stringbuf underlying character sequence. If the basic_stringbuf
was created only in input mode, the resultant basic_string contains
the character sequence in the range [eback(), egptr()).  If the
basic_stringbuf was created with (which &amp; ios_base::out) being true
then the resultant basic_string contains the character sequence in the
range [pbase(), high_mark) where high_mark represents the position one
past the highest initialized character in the buffer.  Characters can
be initialized either through writing to the stream, or by
constructing the basic_stringbuf with a basic_string, or by calling
the str(basic_string) member function.  In the case of calling the
str(basic_string) member function, all characters initialized prior to
the call are now considered uninitialized (except for those
characters re-initialized by the new basic_string).  Otherwise the
basic_stringbuf has been created in neither input nor output mode and
a zero length basic_string is returned.
</p>
</blockquote>

<p>
27.7.1.2/2 Change:
</p>

<blockquote>
<p>
-2- Effects: If the basic_stringbuf's underlying character sequence is
not empty, deallocates it. Then copies the content of s into the
basic_stringbuf underlying character sequence and initializes the
input and output sequences according to the mode stored when creating
the basic_stringbuf object. If (mode&amp;ios_base::out) is true, then
initializes the output sequence with the underlying sequence. If
(mode&amp;ios_base::in) is true, then initializes the input sequence with
the underlying sequence.
</p>
</blockquote>

<p>to:</p>

<blockquote>
<p>
-2- Effects: Copies the content of s into the basic_stringbuf
underlying character sequence. If mode &amp; ios_base::out is true,
initializes the output sequence such that pbase() points to the first
underlying character, epptr() points one past the last underlying
character, and if (mode &amp; ios_base::ate) is true,
pptr() is set equal to epptr() else pptr() is set equal to pbase(). If
mode &amp; ios_base::in is true, initializes the input sequence such that
eback() and gptr() point to the first underlying character and egptr()
points one past the last underlying character.
</p>
</blockquote>

<p>Remove 27.2.1.2/3.  (Same rationale as issue 238: incorrect and unnecessary.)</p>

<p>27.7.1.3/1 Change:</p>

<blockquote>
<p>
1- Returns: If the input sequence has a read position available,
returns traits::to_int_type(*gptr()).  Otherwise, returns
traits::eof().
</p>
</blockquote>

<p>to:</p>

<blockquote>
<p>
1- Returns: If the input sequence has a read position available,
returns traits::to_int_type(*gptr()).  Otherwise, returns
traits::eof().  Any character in the underlying buffer which has been
initialized is considered to be part of the input sequence.
</p>
</blockquote>

<p>27.7.1.3/9 Change:</p>

<blockquote>
<p>
-9- Notes: The function can make a write position available only if (
mode &amp; ios_base::out) != 0. To make a write position available, the
function reallocates (or initially allocates) an array object with a
sufficient number of elements to hold the current array object (if
any), plus one additional write position. If ( mode &amp; ios_base::in) !=
0, the function alters the read end pointer egptr() to point just past
the new write position (as does the write end pointer epptr()).
</p>
</blockquote>

<p>to:</p>

<blockquote>
<p>
-9- The function can make a write position available only if ( mode &amp;
ios_base::out) != 0. To make a write position available, the function
reallocates (or initially allocates) an array object with a sufficient
number of elements to hold the current array object (if any), plus one
additional write position. If ( mode &amp; ios_base::in) != 0, the
function alters the read end pointer egptr() to point just past the
new write position.
</p>
</blockquote>

<p>27.7.1.3/12 Change:</p>

<blockquote>
<p>
-12- _ If (newoff + off) &lt; 0, or (xend - xbeg) &lt; (newoff + off), the
positioning operation fails. Otherwise, the function assigns xbeg +
newoff + off to the next pointer xnext .
</p>
</blockquote>

<p>to:</p>

<blockquote>
<p>
-12- _ If (newoff + off) &lt; 0, or if (newoff + off) refers to an
uninitialized character (as defined in 27.8.1.3 [stringbuf.members]
paragraph 1), the positioning operation fails. Otherwise, the function
assigns xbeg + newoff + off to the next pointer xnext .
</p>
</blockquote>

<p><i>[post-Kona: Howard provided wording.  At Kona the LWG agreed that
  something along these lines was a good idea, but the original
  proposed resolution didn't say enough about the effect of various
  member functions on the underlying character sequences.]</i></p>




<p><b>Rationale:</b></p>
<p>The current basic_stringbuf description is over-constrained in such
a way as to prohibit vendors from making this the high-performance
in-memory stream it was meant to be.  The fundamental problem is that
the pointers: eback(), gptr(), egptr(), pbase(), pptr(), epptr() are
observable from a derived client, and the current description
restricts the range [pbase(), epptr()) from being grown geometrically.
This change allows, but does not require, geometric growth of this
range.</p>

<p>Backwards compatibility issues: These changes will break code that
derives from basic_stringbuf, observes epptr(), and depends upon
[pbase(), epptr()) growing by one character on each call to overflow()
(i.e. test suites).  Otherwise there are no backwards compatibility
issues.</p>

<p>27.7.1.1/2: The non-normative note is non-binding, and if it were
binding, would be over specification.  The recommended change focuses
on the important observable fact.</p>

<p>27.7.1.1/3: This change does two things: 1.  It describes exactly
what must happen in terms of the sequences.  The terms "input
sequence" and "output sequence" are not well defined.  2.  It
introduces a common extension: open with app or ate mode.  I concur
with issue 238 that paragraph 4 is both wrong and unnecessary.</p>

<p>27.7.1.2/1: This change is the crux of the efficiency issue.  The
resultant basic_string is not dependent upon epptr(), and thus
implementors are free to grow the underlying buffer geometrically
during overflow() *and* place epptr() at the end of that buffer.</p>

<p>27.7.1.2/2:  Made consistent with the proposed 27.7.1.1/3.</p>

<p>27.7.1.3/1: Clarifies that characters written to the stream beyond
the initially specified string are available for reading in an i/o
basic_streambuf.</p>

<p>27.7.1.3/9: Made normative by removing "Notes:", and removed the
trailing parenthetical comment concerning epptr().</p>

<p>27.7.1.3/12: Restricting the positioning to [xbeg, xend) is no
longer allowable since [pbase(), epptr()) may now contain
uninitialized characters.  Positioning is only allowable over the
initialized range.</p>





<hr>
<h3><a name="434"></a>434. bitset::to_string() hard to use</h3>
<p><b>Section:</b> 20.5.2 [bitset.members] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2003-10-15 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#bitset.members">issues</a> in [bitset.members].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It has been pointed out a number of times that the bitset to_string() member
function template is tedious to use since callers must explicitly specify the
entire template argument list (3 arguments). At least two implementations
provide a number of overloads of this template to make it easier to use.
</p>



<p><b>Proposed resolution:</b></p>
<p>In order to allow callers to specify no template arguments at all, just the
first one (charT), or the first 2 (charT and traits), in addition to all
three template arguments, add the following three overloads to both the
interface (declarations only) of the class template bitset as well as to
section 23.3.5.2, immediately after p34, the Returns clause of the existing
to_string() member function template:</p>

<pre>    template &lt;class charT, class traits&gt;
    basic_string&lt;charT, traits, allocator&lt;charT&gt; &gt;
    to_string () const;

    -34.1- Returns: to_string&lt;charT, traits, allocator&lt;charT&gt; &gt;().

    template &lt;class charT&gt;
    basic_string&lt;charT, char_traits&lt;charT&gt;, allocator&lt;charT&gt; &gt;
    to_string () const;

    -34.2- Returns: to_string&lt;charT, char_traits&lt;charT&gt;, allocator&lt;charT&gt; &gt;().

    basic_string&lt;char, char_traits&lt;char&gt;, allocator&lt;char&gt; &gt;
    to_string () const;

    -34.3- Returns: to_string&lt;char, char_traits&lt;char&gt;, allocator&lt;char&gt; &gt;().
</pre>

<p><i>[Kona: the LWG agrees that this is an improvement over the
  status quo.  Dietmar thought about an alternative using a proxy
  object but now believes that the proposed resolution above is the
  right choice.
]</i></p>








<hr>
<h3><a name="435"></a>435. bug in DR 25</h3>
<p><b>Section:</b> 21.4.8.9 [string.io] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2003-10-15 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#string.io">issues</a> in [string.io].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>

<p>
It has been pointed out that the proposed resolution in DR 25 may not be
quite up to snuff: <br>
http://gcc.gnu.org/ml/libstdc++/2003-09/msg00147.html
http://anubis.dkuug.dk/jtc1/sc22/wg21/docs/lwg-defects.html#25<br>
</p>

<p>
It looks like Petur is right. The complete corrected text is copied below.
I think we may have have been confused by the reference to 22.2.2.2.2 and
the subsequent description of `n' which actually talks about the second
argument to sputn(), not about the number of fill characters to pad with.
</p>

<p>
So the question is: was the original text correct? If the intent was to
follow classic iostreams then it most likely wasn't, since setting width()
to less than the length of the string doesn't truncate it on output. This
is also the behavior of most implementations (except for SGI's standard
iostreams where the operator does truncate).
</p>



<p><b>Proposed resolution:</b></p>
<p>Change the text in 21.3.7.9, p4 from</p>
    <blockquote><p>
    If bool(k) is true, inserts characters as if by calling
    os.rdbuf()-&gt;sputn(str.data(), n), padding as described in stage 3
    of lib.facet.num.put.virtuals, where n is the larger of os.width()
    and str.size(); 
    </p></blockquote>
<p>to</p>
    <blockquote><p>
    If bool(k) is true, determines padding as described in
    lib.facet.num.put.virtuals, and then inserts the resulting
    sequence of characters <tt>seq</tt> as if by calling
    <tt>os.rdbuf()-&gt;sputn(seq, n)</tt>, where <tt>n</tt> is the larger of
    <tt>os.width()</tt> and <tt>str.size()</tt>;
     </p></blockquote>

<p><i>[Kona: it appears that neither the original wording, DR25, nor the
  proposed resolution, is quite what we want.  We want to say that
  the string will be output, padded to os.width() if necessary.  We
  don't want to duplicate the padding rules in clause 22, because
  they're complicated, but we need to be careful because they weren't
  quite written with quite this case in mind.  We need to say what
  the character sequence is, and then defer to clause 22.  Post-Kona:
  Benjamin provided wording.]</i></p>







<hr>
<h3><a name="436"></a>436. are cv-qualified facet types valid facets?</h3>
<p><b>Section:</b> 22.3.1.1.2 [locale.facet] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2003-10-15 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Is "const std::ctype&lt;char&gt;" a valid template argument to has_facet, use_facet,
and the locale template ctor? And if so, does it designate the same Facet as
the non-const "std::ctype&lt;char&gt;?" What about "volatile std::ctype&lt;char&gt;?"
Different implementations behave differently: some fail to compile, others
accept such types but behave inconsistently.
</p>


<p><b>Proposed resolution:</b></p>
<p>Change 22.1.1.1.2, p1 to read:</p>

<p>Template parameters in this clause which are required to be facets
are those named Facet in declarations. A program that passes a type
that is not a facet, or a type that refers to volatile-qualified
facet, as an (explicit or deduced) template parameter to a locale
function expecting a facet, is ill-formed.  A const-qualified facet is
a valid template argument to any locale function that expects a Facet
template parameter.</p>

<p><i>[Kona: changed the last sentence from a footnote to normative
text.]</i></p>






<hr>
<h3><a name="438"></a>438. Ambiguity in the "do the right thing" clause</h3>
<p><b>Section:</b> 23.2.3 [sequence.reqmts] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2003-10-20 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#sequence.reqmts">issues</a> in [sequence.reqmts].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>

<p>Section 23.2.3 [sequence.reqmts], paragraphs 9-11, fixed up the problem
noticed with statements like:</p>
<pre>vector&lt;int&gt; v(10, 1);
</pre>

<p>The intent of the above statement was to construct with:</p>
<pre>vector(size_type, const value_type&amp;);
</pre>

<p>but early implementations failed to compile as they bound to:</p>
<pre>template &lt;class InputIterator&gt;
vector(InputIterator f, InputIterator l);
</pre>
<p>instead.</p>

<p>Paragraphs 9-11 say that if InputIterator is an integral type, then the
member template constructor will have the same effect as:</p>
<pre>vector&lt;static_cast&lt;size_type&gt;(f), static_cast&lt;value_type&gt;(l));
</pre>
<p>(and similarly for the other member template functions of sequences).</p>

<p>There is also a note that describes one implementation technique:</p>
<blockquote><p>
   One way that sequence implementors can satisfy this requirement is to
   specialize the member template for every integral type.
</p></blockquote>

<p>This might look something like:</p>
<blockquote>
<pre>template &lt;class T&gt;
struct vector
{
     typedef unsigned size_type;

     explicit vector(size_type) {}
     vector(size_type, const T&amp;) {}

     template &lt;class I&gt;
     vector(I, I);

     // ...
};

template &lt;class T&gt;
template &lt;class I&gt;
vector&lt;T&gt;::vector(I, I) { ... }

template &lt;&gt;
template &lt;&gt;
vector&lt;int&gt;::vector(int, int) { ... }

template &lt;&gt;
template &lt;&gt;
vector&lt;int&gt;::vector(unsigned, unsigned) { ... }

//  ...
</pre>
</blockquote>

<p>Label this solution 'A'.</p>

<p>The standard also says:</p>
<blockquote><p>
 Less cumbersome implementation techniques also exist.
</p></blockquote>
<p>
A popular technique is to not specialize as above, but instead catch
every call with the member template, detect the type of InputIterator,
and then redirect to the correct logic.  Something like:
</p>
<blockquote>
<pre>template &lt;class T&gt;
template &lt;class I&gt;
vector&lt;T&gt;::vector(I f, I l)
{
     choose_init(f, l, int2type&lt;is_integral&lt;I&gt;::value&gt;());
}

template &lt;class T&gt;
template &lt;class I&gt;
vector&lt;T&gt;::choose_init(I f, I l, int2type&lt;false&gt;)
{
    // construct with iterators
}

template &lt;class T&gt;
template &lt;class I&gt;
vector&lt;T&gt;::choose_init(I f, I l, int2type&lt;true&gt;)
{
    size_type sz = static_cast&lt;size_type&gt;(f);
    value_type v = static_cast&lt;value_type&gt;(l);
    // construct with sz,v
}
</pre>
</blockquote>

<p>Label this solution 'B'.</p>

<p>Both of these solutions solve the case the standard specifically
mentions:</p>
<pre>vector&lt;int&gt; v(10, 1);  // ok, vector size 10, initialized to 1
</pre>

<p>
However, (and here is the problem), the two solutions have different
behavior in some cases where the value_type of the sequence is not an
integral type.  For example consider:
</p>
<blockquote><pre>     pair&lt;char, char&gt;                     p('a', 'b');
     vector&lt;vector&lt;pair&lt;char, char&gt; &gt; &gt;   d('a', 'b');
</pre></blockquote>
<p>
The second line of this snippet is likely an error.  Solution A catches
the error and refuses to compile.  The reason is that there is no
specialization of the member template constructor that looks like:
</p>
<pre>template &lt;&gt;
template &lt;&gt;
vector&lt;vector&lt;pair&lt;char, char&gt; &gt; &gt;::vector(char, char) { ... }
</pre>

<p>
So the expression binds to the unspecialized member template
constructor, and then fails (compile time) because char is not an
InputIterator.
</p>

<p>
Solution B compiles the above example though.  'a' is casted to an
unsigned integral type and used to size the outer vector.  'b' is
static casted to the inner vector using it's explicit constructor:
</p>

<pre>explicit vector(size_type n);
</pre>

<p>
and so you end up with a static_cast&lt;size_type&gt;('a') by
static_cast&lt;size_type&gt;('b') matrix.
</p>

<p>
It is certainly possible that this is what the coder intended.  But the
explicit qualifier on the inner vector has been thwarted at any rate.
</p>

<p>
The standard is not clear whether the expression:
</p>

<pre>     vector&lt;vector&lt;pair&lt;char, char&gt; &gt; &gt;   d('a', 'b');
</pre>

<p>
(and similar expressions) are:
</p>

<ol>
<li>  undefined behavior.</li>
<li>  illegal and must be rejected.</li>
<li>  legal and must be accepted.</li>
</ol>

<p>My preference is listed in the order presented.</p>

<p>There are still other techniques for implementing the requirements of
paragraphs 9-11, namely the "restricted template technique" (e.g.
enable_if).  This technique is the most compact and easy way of coding
the requirements, and has the behavior of #2 (rejects the above
expression).
</p>

<p>
Choosing 1 would allow all implementation techniques I'm aware of.
Choosing 2 would allow only solution 'A' and the enable_if technique.
Choosing 3 would allow only solution 'B'.
</p>

<p>
Possible wording for a future standard if we wanted to actively reject
the expression above would be to change "static_cast" in paragraphs
9-11 to "implicit_cast" where that is defined by:
</p>

<blockquote>
<pre>template &lt;class T, class U&gt;
inline
T implicit_cast(const U&amp; u)
{
     return u;
}
</pre>
</blockquote>



<p><b>Proposed resolution:</b></p>

<p>Replace 23.2.3 [sequence.reqmts] paragraphs 9 - 11 with:</p>

<p>For every sequence defined in this clause and in clause lib.strings:</p>

<ul>
  <li>
    <p>If the constructor</p>
       <pre>       template &lt;class InputIterator&gt;
       X(InputIterator f, InputIterator l,
         const allocator_type&amp; a = allocator_type())
       </pre>
    <p>is called with a type InputIterator that does not qualify as
    an input iterator, then the constructor will behave as if the
    overloaded constructor:</p>
       <pre>       X(size_type, const value_type&amp; = value_type(),
         const allocator_type&amp; = allocator_type())
       </pre>
    <p>were called instead, with the arguments static_cast&lt;size_type&gt;(f), l and a, respectively.</p>
  </li>

  <li>
    <p>If the member functions of the forms:</p>
       <pre>       template &lt;class InputIterator&gt;          //  such as  insert()
       rt fx1(iterator p, InputIterator f, InputIterator l);

       template &lt;class InputIterator&gt;          //  such as  append(), assign()
       rt fx2(InputIterator f, InputIterator l);

       template &lt;class InputIterator&gt;          //  such as  replace()
       rt fx3(iterator i1, iterator i2, InputIterator f, InputIterator l);
       </pre>
    <p>are called with a type InputIterator that does not qualify as
    an input iterator, then these functions will behave as if the
    overloaded member functions:</p>
       <pre>       rt fx1(iterator, size_type, const value_type&amp;);

       rt fx2(size_type, const value_type&amp;);

       rt fx3(iterator, iterator, size_type, const value_type&amp;);
       </pre>
    <p>were called instead, with the same arguments.</p>
  </li>
</ul>

<p>In the previous paragraph the alternative binding will fail if f 
is not implicitly convertible to X::size_type or if l is not implicitly 
convertible to X::value_type.</p>

<p>
The extent to which an implementation determines that a type cannot be
an input iterator is unspecified, except that as a minimum integral
types shall not qualify as input iterators.
</p>



<p><i>[
Kona: agreed that the current standard requires <tt>v('a', 'b')</tt>
to be accepted, and also agreed that this is surprising behavior.  The
LWG considered several options, including something like
implicit_cast, which doesn't appear to be quite what we want.  We
considered Howards three options: allow acceptance or rejection,
require rejection as a compile time error, and require acceptance.  By
straw poll (1-6-1), we chose to require a compile time error.
Post-Kona: Howard provided wording.
]</i></p>


<p><i>[
Sydney: The LWG agreed with this general direction, but there was some
discomfort with the wording in the original proposed resolution.
Howard submitted new wording, and we will review this again in
Redmond.
]</i></p>


<p><i>[Redmond: one very small change in wording: the first argument
  is cast to size_t.  This fixes the problem of something like
  <tt>vector&lt;vector&lt;int&gt; &gt;(5, 5)</tt>, where int is not 
  implicitly convertible to the value type.]</i></p>




<p><b>Rationale:</b></p>
<p>The proposed resolution fixes:</p>

<pre>  vector&lt;int&gt; v(10, 1);
</pre>

<p>
since as integral types 10 and 1 must be disqualified as input
iterators and therefore the (size,value) constructor is called (as
if).</p>

<p>The proposed resolution breaks:</p>

<pre>  vector&lt;vector&lt;T&gt; &gt; v(10, 1);
</pre>

<p>
because the integral type 1 is not *implicitly* convertible to
vector&lt;T&gt;.  The wording above requires a diagnostic.</p>

<p>
The proposed resolution leaves the behavior of the following code
unspecified.
</p>

<pre>  struct A
  {
    operator int () const {return 10;}
  };

  struct B
  {
    B(A) {}
  };

  vector&lt;B&gt; v(A(), A());
</pre>

<p>
The implementation may or may not detect that A is not an input
iterator and employee the (size,value) constructor.  Note though that
in the above example if the B(A) constructor is qualified explicit,
then the implementation must reject the constructor as A is no longer
implicitly convertible to B.
</p>





<hr>
<h3><a name="441"></a>441. Is fpos::state const?</h3>
<p><b>Section:</b> 27.5.3 [fpos] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Vincent Leloup <b>Opened:</b> 2003-11-17 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#fpos">issues</a> in [fpos].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In section 27.5.3.1 [fpos.members] fpos&lt;stateT&gt;::state() is declared
non const, but in section 27.5.3 [fpos] it is declared const.
</p>


<p><b>Proposed resolution:</b></p>
<p>
In section 27.5.3.1 [fpos.members], change the declaration of 
<tt>fpos&lt;stateT&gt;::state()</tt> to const.
</p>





<hr>
<h3><a name="442"></a>442. sentry::operator bool() inconsistent signature</h3>
<p><b>Section:</b> 27.7.2.4 [ostream::sentry] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Vincent Leloup <b>Opened:</b> 2003-11-18 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#ostream::sentry">issues</a> in [ostream::sentry].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In section 27.7.2.4 [ostream::sentry] paragraph 4, in description part
basic_ostream&lt;charT, traits&gt;::sentry::operator bool() is declared
as non const, but in section 27.6.2.3, in synopsis it is declared
const.
</p>


<p><b>Proposed resolution:</b></p>
<p>
In section 27.7.2.4 [ostream::sentry] paragraph 4, change the declaration
of <tt>sentry::operator bool()</tt> to const.
</p>





<hr>
<h3><a name="443"></a>443. filebuf::close() inconsistent use of EOF</h3>
<p><b>Section:</b> 27.9.1.4 [filebuf.members] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Vincent Leloup <b>Opened:</b> 2003-11-20 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#filebuf.members">issues</a> in [filebuf.members].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In section 27.9.1.4 [filebuf.members] par6, in effects description of
basic_filebuf&lt;charT, traits&gt;::close(), overflow(EOF) is used twice;
should be overflow(traits::eof()).
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change overflow(EOF) to overflow(traits::eof()).
</p>





<hr>
<h3><a name="444"></a>444. Bad use of casts in fstream</h3>
<p><b>Section:</b> 27.9.1 [fstreams] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Vincent Leloup <b>Opened:</b> 2003-11-20 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#fstreams">issues</a> in [fstreams].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
27.9.1.9 [ifstream.members] p1, 27.9.1.13 [ofstream.members] p1, 27.9.1.17 [fstream.members] p1 seems have same problem as exposed in LWG issue
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#252">252</a>.
</p>


<p><b>Proposed resolution:</b></p>

<p><i>[Sydney: Genuine defect. 27.8.1.13 needs a cast to cast away
 constness. The other two places are stylistic: we could change the
 C-style casts to const_cast. Post-Sydney: Howard provided wording.
]</i></p>


<p>Change 27.8.1.7/1 from:</p>
<blockquote><p>
  Returns: (basic_filebuf&lt;charT,traits&gt;*)&amp;sb.
</p></blockquote>

<p>to:</p>
<blockquote><p>
  Returns: const_cast&lt;basic_filebuf&lt;charT,traits&gt;*&gt;(&amp;sb).
</p></blockquote>

<p>Change 27.8.1.10/1 from:</p>
<blockquote><p>
  Returns: (basic_filebuf&lt;charT,traits&gt;*)&amp;sb.
</p></blockquote>

<p>to:</p>
<blockquote><p>
  Returns: const_cast&lt;basic_filebuf&lt;charT,traits&gt;*&gt;(&amp;sb).
</p></blockquote>

<p>Change 27.8.1.13/1 from:</p>
<blockquote><p>
  Returns: &amp;sb.
</p></blockquote>

<p>to:</p>
<blockquote><p>
  Returns: const_cast&lt;basic_filebuf&lt;charT,traits&gt;*&gt;(&amp;sb).
</p></blockquote>








<hr>
<h3><a name="445"></a>445. iterator_traits::reference unspecified for some iterator categories</h3>
<p><b>Section:</b> 24.4.1 [iterator.traits] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Dave Abrahams <b>Opened:</b> 2003-12-09 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#iterator.traits">issues</a> in [iterator.traits].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The standard places no restrictions at all on the reference type
of input, output, or forward iterators (for forward iterators it
only specifies that *x must be value_type&amp; and doesn't mention
the reference type).  Bidirectional iterators' reference type is
restricted only by implication, since the base iterator's
reference type is used as the return type of reverse_iterator's
operator*, which must be T&amp; in order to be a conforming forward
iterator.
</p>

<p>
Here's what I think we ought to be able to expect from an input
or forward iterator's reference type R, where a is an iterator
and V is its value_type
</p>

<ul>
  <li>
      *a is convertible to R
  </li>

  <li>
      R is convertible to V
  </li>

  <li>
      static_cast&lt;V&gt;(static_cast&lt;R&gt;(*a)) is equivalent to
      static_cast&lt;V&gt;(*a) 
  </li>
</ul>

<p>A mutable forward iterator ought to satisfy, for x of type V:</p>
  <pre>      { R r = *a; r = x; } is equivalent to *a = x;
  </pre>

<p>
I think these requirements capture existing container iterators
(including vector&lt;bool&gt;'s), but render istream_iterator invalid;
its reference type would have to be changed to a constant
reference.
</p>


<p>
(Jeremy Siek) During the discussion in Sydney, it was felt that a
simpler long term solution for this was needed. The solution proposed
was to require <tt>reference</tt> to be the same type as <tt>*a</tt>
and <tt>pointer</tt> to be the same type as <tt>a-&gt;</tt>.  Most
iterators in the Standard Library already meet this requirement. Some
iterators are output iterators, and do not need to meet the
requirement, and others are only specified through the general
iterator requirements (which will change with this resolution). The
sole case where there is an explicit definition of the reference type
that will need to change is <tt>istreambuf_iterator</tt> which returns
<tt>charT</tt> from <tt>operator*</tt> but has a reference type of
<tt>charT&amp;</tt>. We propose changing the reference type of
<tt>istreambuf_iterator</tt> to <tt>charT</tt>.
</p>

<p>The other option for resolving the issue with <tt>pointer</tt>,
  mentioned in the note below, is to remove <tt>pointer</tt>
  altogether. I prefer placing requirements on <tt>pointer</tt> to
  removing it for two reasons. First, <tt>pointer</tt> will become
  useful for implementing iterator adaptors and in particular,
  <tt>reverse_iterator</tt> will become more well defined. Second,
  removing <tt>pointer</tt> is a rather drastic and publicly-visible
  action to take.</p>

<p>The proposed resolution technically enlarges the requirements for
iterators, which means there are existing iterators (such as
<tt>istreambuf_iterator</tt>, and potentially some programmer-defined
iterators) that will no longer meet the requirements. Will this break
existing code? The scenario in which it would is if an algorithm
implementation (say in the Standard Library) is changed to rely on
<tt>iterator_traits::reference</tt>, and then is used with one of the
iterators that do not have an appropriately defined
<tt>iterator_traits::reference</tt>.
</p>


<p>The proposed resolution makes one other subtle change. Previously,
it was required that output iterators have a <tt>difference_type</tt>
and <tt>value_type</tt> of <tt>void</tt>, which means that a forward
iterator could not be an output iterator. This is clearly a mistake,
so I've changed the wording to say that those types may be
<tt>void</tt>.
</p>



<p><b>Proposed resolution:</b></p>

<p>In 24.4.1 [iterator.traits], after:</p>

<blockquote><p>
be defined as the iterator's difference type, value type and iterator
category, respectively.
</p></blockquote>

<p>add</p>

<blockquote><p>
In addition, the types</p>
<pre>iterator_traits&lt;Iterator&gt;::reference
iterator_traits&lt;Iterator&gt;::pointer
</pre>
<p>must be defined as the iterator's reference and pointer types, that
is, the same type as the type of <tt>*a</tt> and <tt>a-&gt;</tt>,
respectively.</p>
</blockquote>

<p>In 24.4.1 [iterator.traits], change:</p>

<blockquote><p>
In the case of an output iterator, the types</p>
<pre>iterator_traits&lt;Iterator&gt;::difference_type
iterator_traits&lt;Iterator&gt;::value_type
</pre>
<p>are both defined as <tt>void</tt>.</p>
</blockquote>

<p>to:</p>
<blockquote><p>
In the case of an output iterator, the types</p>
<pre>iterator_traits&lt;Iterator&gt;::difference_type
iterator_traits&lt;Iterator&gt;::value_type
iterator_traits&lt;Iterator&gt;::reference
iterator_traits&lt;Iterator&gt;::pointer
</pre>
<p>may be defined as <tt>void</tt>.</p>
</blockquote>

<p>In 24.6.3 [istreambuf.iterator], change:</p>
<blockquote>
<pre>typename traits::off_type, charT*, charT&amp;&gt;
</pre>
</blockquote>
<p>to:</p>
<blockquote>
<pre>typename traits::off_type, charT*, charT&gt;
</pre>
</blockquote>

<p><i>[
Redmond: there was concern in Sydney that this might not be the only place
where things were underspecified and needed to be changed.  Jeremy
reviewed iterators in the standard and confirmed that nothing else
needed to be changed.
]</i></p>









<hr>
<h3><a name="448"></a>448. Random Access Iterators over abstract classes</h3>
<p><b>Section:</b> 24.2.7 [random.access.iterators] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Dave Abrahams <b>Opened:</b> 2004-01-07 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#random.access.iterators">issues</a> in [random.access.iterators].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Table 76, the random access iterator requirement table, says that the
return type of a[n] must be "convertible to T".  When an iterator's
value_type T is an abstract class, nothing is convertible to T.
Surely this isn't an intended restriction?
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change the return type to "convertible to T const&amp;".
</p>





<hr>
<h3><a name="449"></a>449. Library Issue 306 Goes Too Far</h3>
<p><b>Section:</b> 18.2 [support.types] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2004-01-15 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#support.types">issues</a> in [support.types].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>Original text:</p>
<blockquote><p>
The macro offsetof accepts a restricted set of type arguments in this
International Standard. type shall be a POD structure or a POD union
(clause 9). The result of applying the offsetof macro to a field that
is a static data member or a function member is undefined."
</p></blockquote>

<p>Revised text:</p>
<blockquote><p>
"If type is not a POD structure or a POD union the results are undefined."
</p></blockquote>

<p>
Looks to me like the revised text should have replaced only the second
sentence. It doesn't make sense standing alone.
</p>



<p><b>Proposed resolution:</b></p>
<p>Change 18.1, paragraph 5, to:</p>

<blockquote><p>
The macro offsetof accepts a restricted set of type arguments in this
International Standard.  If type is not a POD structure or a POD union
the results are undefined.  The result of applying the offsetof macro
to a field that is a static data member or a function member is
undefined."
</p></blockquote>





<hr>
<h3><a name="453"></a>453. basic_stringbuf::seekoff need not always fail for an empty stream</h3>
<p><b>Section:</b> 27.8.1.4 [stringbuf.virtuals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Bill Plauger <b>Opened:</b> 2004-01-30 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#stringbuf.virtuals">issues</a> in [stringbuf.virtuals].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<pre>  pos_type basic_stringbuf::seekoff(off_type, ios_base::seekdir,
                                    ios_base::openmode);
</pre>
<p>
is obliged to fail if nothing has been inserted into the stream. This
is unnecessary and undesirable. It should be permissible to seek to
an effective offset of zero.</p>

<p><i>[
 Sydney: Agreed that this is an annoying problem: seeking to zero should be
 legal. Bill will provide wording.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>Change the sentence from:</p>
<blockquote><p>
For a sequence to be positioned, if its next pointer (either
gptr() or pptr()) is a null pointer, the positioning operation
fails.
</p></blockquote>

<p>to:</p>

<blockquote><p>
For a sequence to be positioned, if its next pointer (either
gptr() or pptr()) is a null pointer and the new offset newoff
is nonzero, the positioning operation fails.
</p></blockquote>





<hr>
<h3><a name="455"></a>455. cerr::tie() and wcerr::tie() are overspecified</h3>
<p><b>Section:</b> 27.4 [iostream.objects] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Bill Plauger <b>Opened:</b> 2004-01-30 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#iostream.objects">issues</a> in [iostream.objects].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Both cerr::tie() and wcerr::tie() are obliged to be null at program
startup. This is overspecification and overkill. It is both traditional
and useful to tie cerr to cout, to ensure that standard output is drained
whenever an error message is written. This behavior should at least be
permitted if not required. Same for wcerr::tie().
</p>


<p><b>Proposed resolution:</b></p>

<p>Add to the description of cerr:</p>
<blockquote><p>
After the object cerr is initialized, cerr.tie() returns &amp;cout.
Its state is otherwise the same as required for basic_ios&lt;char&gt;::init
(lib.basic.ios.cons).
</p></blockquote>

<p>Add to the description of wcerr:</p>

<blockquote><p>
After the object wcerr is initialized, wcerr.tie() returns &amp;wcout.
Its state is otherwise the same as required for basic_ios&lt;wchar_t&gt;::init
(lib.basic.ios.cons).
</p></blockquote>

<p><i>[Sydney: straw poll (3-1): we should <i>require</i>, not just
  permit, cout and cerr to be tied on startup.  Pre-Redmond: Bill will
  provide wording.]</i></p>






<hr>
<h3><a name="456"></a>456. Traditional C header files are overspecified</h3>
<p><b>Section:</b> 17.6.1.2 [headers] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Bill Plauger <b>Opened:</b> 2004-01-30 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#headers">issues</a> in [headers].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>

<p>The C++ Standard effectively requires that the traditional C headers
(of the form &lt;xxx.h&gt;) be defined in terms of the newer C++
headers (of the form &lt;cxxx&gt;). Clauses 17.4.1.2/4 and D.5 combine
to require that:</p>

<ul>
 <li>Including the header &lt;cxxx&gt; declares a C name in namespace std.</li>

 <li> Including the header &lt;xxx.h&gt; declares a C name in namespace std
    (effectively by including &lt;cxxx&gt;), then imports it into the global
    namespace with an individual using declaration.</li>
</ul>

<p>
The rules were left in this form despited repeated and heated objections
from several compiler vendors. The C headers are often beyond the direct
control of C++ implementors. In some organizations, it's all they can do
to get a few #ifdef __cplusplus tests added. Third-party library vendors
can perhaps wrap the C headers. But neither of these approaches supports
the drastic restructuring required by the C++ Standard. As a result, it is
still widespread practice to ignore this conformance requirement, nearly
seven years after the committee last debated this topic. Instead, what is
often implemented is:
</p>

<ul>
 <li> Including the header &lt;xxx.h&gt; declares a C name in the
 global namespace.</li> 

 <li> Including the header &lt;cxxx&gt; declares a C name in the
 global namespace (effectively by including &lt;xxx.h&gt;), then
 imports it into namespace std with an individual using declaration.</li>
</ul>

<p>
The practical benefit for implementors with the second approach is that
they can use existing C library headers, as they are pretty much obliged
to do. The practical cost for programmers facing a mix of implementations
is that they have to assume weaker rules:</p>

<ul>
  <li> If you want to assuredly declare a C name in the global
  namespace, include &lt;xxx.h&gt;. You may or may not also get the
  declaration in namespace std.</li>

  <li> If you want to assuredly declare a C name in namespace std,
  include &lt;cxxx&gt;. You may or may not also get the declaration in
  the global namespace.</li>
</ul>

<p>
There also exists the <i>possibility</i> of subtle differences due to
Koenig lookup, but there are so few non-builtin types defined in the C
headers that I've yet to see an example of any real problems in this
area.
</p>

<p>
It is worth observing that the rate at which programmers fall afoul of
these differences has remained small, at least as measured by newsgroup
postings and our own bug reports. (By an overwhelming margin, the
commonest problem is still that programmers include &lt;string&gt; and can't
understand why the typename string isn't defined -- this a decade after
the committee invented namespace std, nominally for the benefit of all
programmers.)
</p>

<p>
We should accept the fact that we made a serious mistake and rectify it,
however belatedly, by explicitly allowing either of the two schemes for
declaring C names in headers.
</p>

<p><i>[Sydney: This issue has been debated many times, and will
  certainly have to be discussed in full committee before any action
  can be taken.  However, the preliminary sentiment of the LWG was in
  favor of the change.  (6 yes, 0 no, 2 abstain) Robert Klarer
  suggests that we might also want to undeprecate the
  C-style <tt>.h</tt> headers.]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
Add to 17.6.1.2 [headers], para. 4:
</p>

<blockquote><p>
Except as noted in clauses 18 through 27 and Annex D, the contents of each
header <i>cname</i> shall be the same as that of the corresponding header
<i>name.h</i>, as specified in ISO/IEC 9899:1990 Programming Languages C (Clause
7), or ISO/IEC:1990 Programming Languages-C AMENDMENT 1: C Integrity, (Clause
7), as appropriate, as if by inclusion. In the C++ Standard Library, however,
the declarations <del>and definitions</del> (except for names which are defined
as macros in C) are within namespace scope (3.3.5) of the namespace std. 
<ins>It is unspecified whether these names are first declared within the global
namespace scope and are then injected into namespace std by explicit
using-declarations (7.3.3 [namespace.udecl]).</ins>
</p></blockquote>

<p>
Change D.7 [depr.c.headers], para. 2-3:
</p>

<blockquote>
<p>
-2- Every C header, each of which has a name of the form <i>name.h</i>, behaves
as if each name placed in the Standard library namespace by the corresponding
<i>cname</i> header is <del>also</del> placed within the <ins>global</ins>
namespace scope<ins>.</ins> <del>of the namespace <tt>std</tt> and is followed
by an explicit <i>using-declaration</i> (7.3.3 [namespace.udecl]).</del>
<ins>It is unspecified whether these names are first declared or defined within
namespace scope (3.3.6 [basic.scope.namespace]) of the namespace
<tt>std</tt> and are then injected into the global namespace scope by explicit
using-declarations (7.3.3 [namespace.udecl]).</ins>
</p>
<p>
-3- [<i>Example:</i> The header <tt>&lt;cstdlib&gt;</tt> <ins>assuredly</ins>
provides its declarations and definitions within the namespace <tt>std</tt>.
<ins>It may also provide these names within the global namespace.</ins> The
header <tt>&lt;stdlib.h&gt;</tt> <del>makes these available also in</del>
<ins>assuredly provides the same declarations and definitions within</ins> the
global namespace, much as in the C Standard. <ins>It may also provide these
names within the namespace <tt>std</tt>.</ins> <i>-- end example</i>]
</p>
</blockquote>





<hr>
<h3><a name="457"></a>457. bitset constructor: incorrect number of initialized bits</h3>
<p><b>Section:</b> 20.5.1 [bitset.cons] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Dag Henriksson <b>Opened:</b> 2004-01-30 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#bitset.cons">issues</a> in [bitset.cons].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The constructor from unsigned long says it initializes "the first M
bit positions to the corresponding bit values in val. M is the smaller
of N and the value CHAR_BIT * sizeof(unsigned long)."
</p>

<p>
Object-representation vs. value-representation strikes again. CHAR_BIT *
sizeof (unsigned long) does not give us the number of bits an unsigned long
uses to hold the value. Thus, the first M bit position above is not
guaranteed to have any corresponding bit values in val.
</p>


<p><b>Proposed resolution:</b></p>
<p>In 20.5.1 [bitset.cons] paragraph 2, change "M is the smaller of
  N and the value CHAR_BIT * sizeof (unsigned long). (249)" to
  "<tt>M</tt> is the smaller of <tt>N</tt> and the number of bits in
  the value representation (section 3.9 [basic.types]) of <tt>unsigned
  long</tt>."
</p>





<hr>
<h3><a name="460"></a>460. Default modes missing from basic_fstream member specifications</h3>
<p><b>Section:</b> 27.9.1 [fstreams] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Ben Hutchings <b>Opened:</b> 2004-04-01 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#fstreams">issues</a> in [fstreams].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The second parameters of the non-default constructor and of the open
member function for basic_fstream, named "mode", are optional
according to the class declaration in 27.8.1.11 [lib.fstream].  The
specifications of these members in 27.8.1.12 [lib.fstream.cons] and
27.8.1.13 lib.fstream.members] disagree with this, though the
constructor declaration has the "explicit" function-specifier implying
that it is intended to be callable with one argument.
</p>


<p><b>Proposed resolution:</b></p>
<p>In 27.9.1.15 [fstream.cons], change</p>
<pre>  explicit basic_fstream(const char* s, ios_base::openmode mode); 
</pre>
<p>to</p>
<pre>  explicit basic_fstream(const char* s,
                         ios_base::openmode mode = ios_base::in|ios_base::out);
</pre>
<p>In 27.9.1.17 [fstream.members], change</p>
<pre>  void open(const char*s, ios_base::openmode mode); 
</pre>
<p>to</p>
<pre>  void open(const char*s,
            ios_base::openmode mode = ios_base::in|ios_base::out);
</pre>





<hr>
<h3><a name="461"></a>461. time_get hard or impossible to implement</h3>
<p><b>Section:</b> 22.4.5.1.2 [locale.time.get.virtuals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Bill Plauger <b>Opened:</b> 2004-03-23 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Template time_get currently contains difficult, if not impossible,
requirements for do_date_order, do_get_time, and do_get_date. All require
the implementation to scan a field generated by the %x or %X conversion
specifier in strftime. Yes, do_date_order can always return no_order, but
that doesn't help the other functions. The problem is that %x can be
nearly anything, and it can vary widely with locales. It's horribly
onerous to have to parse "third sunday after Michaelmas in the year of
our Lord two thousand and three," but that's what we currently ask of
do_get_date. More practically, it leads some people to think that if
%x produces 10.2.04, we should know to look for dots as separators. Still
not easy.
</p>

<p>
Note that this is the <i>opposite</i> effect from the intent stated in the
footnote earlier in this subclause:
</p>

<blockquote><p>
"In other words, user confirmation is required for reliable parsing of
user-entered dates and times, but machine-generated formats can be
parsed reliably. This allows parsers to be aggressive about interpreting
user variations on standard formats."
</p></blockquote>

<p>
We should give both implementers and users an easier and more reliable
alternative: provide a (short) list of alternative delimiters and say
what the default date order is for no_order. For backward compatibility,
and maximum latitude, we can permit an implementation to parse whatever
%x or %X generates, but we shouldn't require it.
</p>


<p><b>Proposed resolution:</b></p>

<p><b>In the description:</b></p>
<pre>iter_type do_get_time(iter_type s, iter_type end, ios_base&amp; str,
        ios_base::iostate&amp; err, tm* t) const;
</pre>

<p>
2 Effects: Reads characters starting at suntil it has extracted those
struct tm members, and remaining format characters, used by
time_put&lt;&gt;::put to produce the format specified by 'X', or until it
encounters an error or end of sequence.
</p>

<p><b>change:</b> 'X'</p>

<p><b>to:</b> "%H:%M:%S"</p>


<p>Change</p>
<pre>iter_type do_get_date(iter_type s, iter_type end, ios_base&amp; str,
        ios_base::iostate&amp; err, tm* t) const;

4 Effects: Reads characters starting at s until it has extracted those
struct tm members, and remaining format characters, used by
time_put&lt;&gt;::put to produce the format specified by 'x', or until it
encounters an error.
</pre>

<p>to</p>
<pre>iter_type do_get_date(iter_type s, iter_type end, ios_base&amp; str,
        ios_base::iostate&amp; err, tm* t) const;
</pre>

<p>
4 Effects: Reads characters starting at s until it has extracted those
struct tm members, and remaining format characters, used by
time_put&lt;&gt;::put to produce one of the following formats, or until it
encounters an error. The format depends on the value returned by
date_order() as follows:
</p>

<pre>        date_order()  format

        no_order      "%m/%d/%y"
        dmy           "%d/%m/%y"
        mdy           "%m/%d/%y"
        ymd           "%y/%m/%d"
        ydm           "%y/%d/%m"
</pre>
<p>
An implementation may also accept additional implementation-defined formats.
</p>

<p><i>[Redmond: agreed that this is a real problem.  The solution is
  probably to match C99's parsing rules.  Bill provided wording.
]</i></p>







<hr>
<h3><a name="464"></a>464. Suggestion for new member functions in standard containers</h3>
<p><b>Section:</b> 23.4.1 [vector], 23.6.1 [map] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Thorsten Ottosen <b>Opened:</b> 2004-05-12 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#vector">issues</a> in [vector].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>

<p>To add slightly more convenience to vector&lt;T&gt; and map&lt;Key,T&gt; we should consider to add</p>
<ol>
<li> add vector&lt;T&gt;::data() member (const and non-const version)
semantics: if( empty() ) return 0; else return buffer_;</li>
<li> add map&lt;Key,T&gt;::at( const Key&amp; k ) member (const and non-const version)
<i>semantics</i>: iterator i = find( k ); if( i != end() ) return *i; else throw range_error();</li>
</ol>

<p>Rationale:</p>

<ul>
<li>To obtain a pointer to the vector's buffer, one must use either operator[]() (which can give undefined  behavior for empty vectors) or at() (which will then throw if the vector is empty).  </li>
<li>tr1::array&lt;T,sz&gt; already has a data() member</li>
<li>e cannot use operator[]() when T is not DefaultDonstructible</li>
<li>Neither when the map is const.</li>
<li>when we want to make sure we don't add an element accidently</li>
<li>when it should be considered an error if a key is not in the map</li>
</ul>



<p><b>Proposed resolution:</b></p>
<p>In 23.4.1 [vector], add the following to the <tt>vector</tt>
  synopsis after "element access" and before "modifiers":</p>
<pre>  // <i>[lib.vector.data] data access</i>
  pointer       data();
  const_pointer data() const;
</pre>

<p>Add a new subsection of 23.4.1 [vector]:</p>
<blockquote>
<p>23.2.4.x <tt>vector</tt> data access</p>
<pre>   pointer       data();
   const_pointer data() const;
</pre>
<p><b>Returns:</b> A pointer such that [data(), data() + size()) is a valid
   range.  For a non-empty vector, data() == &amp;front().</p>
<p><b>Complexity:</b> Constant time.</p>
<p><b>Throws:</b> Nothing.</p>
</blockquote>

<p>In 23.6.1 [map], add the following to the <tt>map</tt>
synopsis immediately after the line for operator[]:</p>
<pre>  T&amp;       at(const key_type&amp; x);
  const T&amp; at(const key_type&amp; x) const;
</pre>

<p>Add the following to 23.6.1.2 [map.access]:</p>
<blockquote>
<pre>  T&amp;       at(const key_type&amp; x);
  const T&amp; at(const key_type&amp; x) const;
</pre>

<p><b>Returns:</b> A reference to the element whose key is equivalent
  to x, if such an element is present in the map.</p>
<p><b>Throws:</b> <tt>out_of_range</tt> if no such element is present.</p>

</blockquote>



<p><b>Rationale:</b></p>
<p>Neither of these additions provides any new functionality but the
  LWG agreed that they are convenient, especially for novices.  The
  exception type chosen for <tt>at</tt>, <tt>std::out_of_range</tt>,
  was chosen to match <tt>vector::at</tt>.</p>





<hr>
<h3><a name="465"></a>465. Contents of &lt;ciso646&gt;</h3>
<p><b>Section:</b> 17.6.1.2 [headers] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Steve Clamage <b>Opened:</b> 2004-06-03 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#headers">issues</a> in [headers].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>C header &lt;iso646.h&gt; defines macros for some operators, such as
not_eq for !=.</p>

<p>Section 17.6.1.2 [headers] "Headers" says that except as noted in
clauses 18 through 27, the &lt;cname&gt; C++ header contents are the same
as the C header &lt;name.h&gt;. In particular, table 12 lists
&lt;ciso646&gt; as a C++ header.</p>

<p>I don't find any other mention of &lt;ciso646&gt;, or any mention of
&lt;iso646.h&gt;, in clauses 17 thorough 27. That implies that the
contents of &lt;ciso646&gt; are the same as C header &lt;iso646.h&gt;.</p>

<p>Annex C (informative, not normative) in [diff.header.iso646.h] C.2.2.2
"Header &lt;iso646.h&gt;" says that the alternative tokens are not
defined as macros in &lt;ciso646&gt;, but does not mention the contents
of &lt;iso646.h&gt;.</p>

<p>I don't find any normative text to support C.2.2.2.</p>



<p><b>Proposed resolution:</b></p>
<p>Add to section 17.4.1.2 Headers [lib.headers] a new paragraph after
  paragraph 6 (the one about functions must be functions):</p> 

<blockquote>
<p>Identifiers that are keywords or operators in C++ shall not be defined
as macros in C++ standard library headers. 
[Footnote:In particular, including the standard header &lt;iso646.h&gt;
or &lt;ciso646&gt; has no effect. </p>
</blockquote>

<p><i>[post-Redmond: Steve provided wording.]</i></p>







<hr>
<h3><a name="467"></a>467. char_traits::lt(), compare(), and memcmp()</h3>
<p><b>Section:</b> 21.2.3.1 [char.traits.specializations.char] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2004-06-28 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Table 37 describes the requirements on Traits::compare() in terms of
those on Traits::lt(). 21.1.3.1, p6 requires char_traits&lt;char&gt;::lt()
to yield the same result as operator&lt;(char, char).
</p>

<p>
Most, if not all, implementations of char_traits&lt;char&gt;::compare()
call memcmp() for efficiency. However, the C standard requires both
memcmp() and strcmp() to interpret characters under comparison as
unsigned, regardless of the signedness of char. As a result, all
these char_traits implementations fail to meet the requirement
imposed by Table 37 on compare() when char is signed.
</p>


<p>Read email thread starting with c++std-lib-13499 for more. </p>


<p><b>Proposed resolution:</b></p>


<p>Change 21.1.3.1, p6 from</p>
<blockquote><p>
    The two-argument members assign, eq, and lt are defined identically
    to the built-in operators =, ==, and &lt; respectively.
</p></blockquote>
<p>to</p>
<blockquote><p>
  The two-argument member assign is defined identically to
  the built-in operator =. The two
  argument members eq and lt are defined identically to
  the built-in operators == and &lt; for type unsigned char.
</p></blockquote>

<p><i>[Redmond: The LWG agreed with this general direction, but we
  also need to change <tt>eq</tt> to be consistent with this change.
  Post-Redmond: Martin provided wording.]</i></p>






<hr>
<h3><a name="468"></a>468. unexpected consequences of ios_base::operator void*()</h3>
<p><b>Section:</b> 27.5.4.3 [iostate.flags] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2004-06-28 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#iostate.flags">issues</a> in [iostate.flags].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>

<p>The program below is required to compile but when run it typically
produces unexpected results due to the user-defined conversion from
std::cout or any object derived from basic_ios to void*.
</p>

<pre>    #include &lt;cassert&gt;
    #include &lt;iostream&gt;

    int main ()
    {
        assert (std::cin.tie () == std::cout);
        // calls std::cout.ios::operator void*()
    }
</pre>


<p><b>Proposed resolution:</b></p>

<p>
Replace std::basic_ios&lt;charT, traits&gt;::operator void*() with another
conversion operator to some unspecified type that is guaranteed not
to be convertible to any other type except for bool (a pointer-to-member
might be one such suitable type). In addition, make it clear that the
pointer type need not be a pointer to a complete type and when non-null,
the value need not be valid.
</p>

<p>Specifically, change in [lib.ios] the signature of</p>
<pre>    operator void*() const;
</pre>
<p>to</p>
<pre>    operator unspecified-bool-type() const;
</pre>
<p>and change [lib.iostate.flags], p1 from</p>
<pre>    operator void*() const;
</pre>
<p>to</p>
<pre>operator unspecified-bool-type() const;

     -1- Returns: if fail() then a value that will evaluate false in a
      boolean context; otherwise a value that will evaluate true in a
      boolean context. The value type returned shall not be
      convertible to int.

     -2- [Note: This conversion can be used in contexts where a bool
      is expected (e.g., an if condition); however, implicit
      conversions (e.g., to int) that can occur with bool are not
      allowed, eliminating some sources of user error. One possible
      implementation choice for this type is pointer-to-member.  - end
      note]
</pre>

<p><i>[Redmond: 5-4 straw poll in favor of doing this.]</i></p>

<p><i>[Lillehammer: Doug provided revised wording for
  "unspecified-bool-type".]</i></p>
 







<hr>
<h3><a name="469"></a>469. vector&lt;bool&gt; ill-formed relational operators</h3>
<p><b>Section:</b> 23.4.1 [vector] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2004-06-28 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#vector">issues</a> in [vector].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>

<p>
The overloads of relational operators for vector&lt;bool&gt; specified
in [lib.vector.bool] are redundant (they are semantically identical
to those provided for the vector primary template) and may even be
diagnosed as ill-formed (refer to Daveed Vandevoorde's explanation
in c++std-lib-13647).
</p>



<p><b>Proposed resolution:</b></p>
<p>
Remove all overloads of overloads of relational operators for
vector&lt;bool&gt; from [lib.vector.bool].
</p>




<hr>
<h3><a name="471"></a>471. result of what() implementation-defined</h3>
<p><b>Section:</b> 18.8.1 [exception] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2004-06-28 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>

<p>[lib.exception] specifies the following:</p>
<pre>    exception (const exception&amp;) throw();
    exception&amp; operator= (const exception&amp;) throw();

    -4- Effects: Copies an exception object.
    -5- Notes: The effects of calling what() after assignment
        are implementation-defined.
</pre>

<p>
First, does the Note only apply to the assignment operator? If so,
what are the effects of calling what() on a copy of an object? Is
the returned pointer supposed to point to an identical copy of
the NTBS returned by what() called on the original object or not?
</p>

<p>
Second, is this Note intended to extend to all the derived classes
in section 19? I.e., does the standard provide any guarantee for
the effects of what() called on a copy of any of the derived class
described in section 19?
</p>

<p>
Finally, if the answer to the first question is no, I believe it
constitutes a defect since throwing an exception object typically
implies invoking the copy ctor on the object. If the answer is yes,
then I believe the standard ought to be clarified to spell out
exactly what the effects are on the copy (i.e., after the copy
ctor was called).
</p>

<p><i>[Redmond: Yes, this is fuzzy.  The issue of derived classes is
  fuzzy too.]</i></p>


<p><i>[
Batavia: Howard provided wording.
]</i></p>


<p><i>[
Bellevue:
]</i></p>


<blockquote>
<p>
Eric concerned this is unimplementable, due to nothrow guarantees.
Suggested implementation would involve reference counting.
</p>
<p>
Is the implied reference counting subtle enough to call out a note on
implementation? Probably not.
</p>
<p>
If reference counting required, could we tighten specification further
to require same pointer value? Probably an overspecification, especially
if exception classes defer evalutation of final string to calls to
what().
</p>
<p>
Remember issue moved open and not resolved at Batavia, but cannot
remember who objected to canvas a disenting opinion - please speak up if
you disagree while reading these minutes!
</p>
<p>
Move to Ready as we are accepting words unmodified.
</p>
</blockquote>

<p><i>[
Sophia Antipolis:
]</i></p>


<blockquote>
The issue was pulled from Ready.  It needs to make clear that only homogenous copying
is intended to be supported, not coping from a derived to a base.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Howard supplied the following replacement wording
for paragraph 7 of the proposed resolution:
</p>
<blockquote>
<ins>-7- <i>Postcondition:</i> <tt>what()</tt> shall return the same NTBS
  as would be obtained by using <tt>static_cast</tt>
  to cast the rhs to the same types as the lhs
  and then calling <tt>what()</tt> on that possibly sliced object.</ins>
</blockquote>
<p>
Pete asks what "the same NTBS" means.
</p>
</blockquote>

<p><i>[
2009-07-30 Niels adds:
]</i></p>


<blockquote>
Further discussion in the thread starting with c++std-lib-24512.
</blockquote>

<p><i>[
2009-09-24 Niels provided updated wording:
]</i></p>


<blockquote>
<p>
I think the resolution should at least guarantee
that the result of <tt>what()</tt> is independent of whether the compiler does
copy-elision. And for any class derived from <tt>std::excepion</tt> that has a
constructor that allows specifying a <tt>what_arg</tt>, it should make sure that
the text of a user-provided <tt>what_arg</tt> is preserved, when the object is
copied. Note that all the implementations I've tested already appear to
satisfy the proposed resolution, including MSVC 2008 SP1, Apache
stdcxx-4.2.1, GCC 4.1.2, GCC 4.3.2, and CodeGear C++ 6.13.
</p>
<p>
The proposed resolution was updated with help from Daniel Krgler;
the update aims to clarify that the proposed postcondition only
applies to homogeneous copying.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Moved to Ready after inserting "publicly accessible" in two places.
</blockquote>



<p><b>Proposed resolution:</b></p>

<p>
Change 18.8.1 [exception] to:
</p>

<blockquote>
<p>
-1- The class <tt>exception</tt> defines the base class for the types of
objects thrown as exceptions by C++ standard library components, and
certain expressions, to report errors detected during program execution.
</p>
<p><ins>
Each standard library class <tt>T</tt> that derives from class
<tt>exception</tt> shall have a publicly accessible copy constructor and a publicly accessible copy assignment
operator that do not exit with an exception. These member functions
shall preserve the following postcondition: If two objects <i>lhs</i>
and <i>rhs</i> both have dynamic type <tt>T</tt>, and <i>lhs</i> is a
copy of <i>rhs</i>, then <tt>strcmp(<i>lhs</i>.what(),
<i>rhs</i>.what()) == 0</tt>.
</ins></p>
<p>
 ...
</p>

<pre>exception(const exception&amp; <ins>rhs</ins>) throw();
exception&amp; operator=(const exception&amp; <ins>rhs</ins>) throw();</pre>

<blockquote>
<p>
-4- <i>Effects:</i> Copies an exception object.
</p>
<p>
<del> -5- <i>Remarks:</i> The effects of calling <tt>what()</tt> after assignment
are implementation-defined.</del>
</p>
<p>
<ins>-5- <i>Postcondition:</i>
	If <tt>*this</tt>
	and <i>rhs</i> both have dynamic type <tt>exception</tt>
	then <tt>strcmp(what(), <i>rhs</i>.what()) == 0</tt>.</ins>
</p>

</blockquote>

</blockquote>





<hr>
<h3><a name="473"></a>473. underspecified ctype calls</h3>
<p><b>Section:</b> 22.4.1.1 [locale.ctype] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2004-07-01 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Most ctype member functions come in two forms: one that operates
on a single character at a time and another form that operates
on a range of characters. Both forms are typically described by
a single Effects and/or Returns clause.
</p>
<p>
The Returns clause of each of the single-character non-virtual forms
suggests that the function calls the corresponding single character
virtual function, and that the array form calls the corresponding
virtual array form. Neither of the two forms of each virtual member
function is required to be implemented in terms of the other.
</p>
<p>
There are three problems:
</p>
<p>
1. One is that while the standard does suggest that each non-virtual
member function calls the corresponding form of the virtual function,
it doesn't actually explicitly require it.
</p>
<p>
Implementations that cache results from some of the virtual member
functions for some or all values of their arguments might want to
call the array form from the non-array form the first time to fill
the cache and avoid any or most subsequent virtual calls. Programs
that rely on each form of the virtual function being called from
the corresponding non-virtual function will see unexpected behavior
when using such implementations.
</p>
<p>
2. The second problem is that either form of each of the virtual
functions can be overridden by a user-defined function in a derived
class to return a value that is different from the one produced by
the virtual function of the alternate form that has not been
overriden.
</p>
<p>
Thus, it might be possible for, say, ctype::widen(c) to return one
value, while for ctype::widen(&amp;c, &amp;c + 1, &amp;wc) to set
wc to another value. This is almost certainly not intended. Both
forms of every function should be required to return the same result
for the same character, otherwise the same program using an
implementation that calls one form of the functions will behave
differently than when using another implementation that calls the
other form of the function "under the hood."
</p>
<p>
3. The last problem is that the standard text fails to specify whether
one form of any of the virtual functions is permitted to be implemented
in terms of the other form or not, and if so, whether it is required
or permitted to call the overridden virtual function or not.
</p>
<p>
Thus, a program that overrides one of the virtual functions so that
it calls the other form which then calls the base member might end
up in an infinite loop if the called form of the base implementation
of the function in turn calls the other form.
</p>
<p>
Lillehammer: Part of this isn't a real problem. We already talk about
caching. 22.1.1/6 But part is a real problem. ctype virtuals may call
each other, so users don't know which ones to override to avoid avoid
infinite loops.</p>

<p>This is a problem for all facet virtuals, not just ctype virtuals,
so we probably want a blanket statement in clause 22 for all
facets. The LWG is leaning toward a blanket prohibition, that a
facet's virtuals may never call each other. We might want to do that
in clause 27 too, for that matter. A review is necessary.  Bill will
provide wording.</p>

<p><i>[
2009-07 Frankfurt, Howard provided wording directed by consensus.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Move to Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add paragraph 3 to 22.4 [locale.categories]:
</p>

<blockquote><ins>
-3- Within this clause it is unspecified if one virtual function calls another
virtual function.
</ins></blockquote>



<p><b>Rationale:</b></p>
<p>
We are explicitly not addressing bullet
item #2, thus giving implementors more latitude. Users will have to
override both virtual functions, not just one.
</p>




<hr>
<h3><a name="474"></a>474. confusing Footnote 297</h3>
<p><b>Section:</b> 27.7.2.6.4 [ostream.inserters.character] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2004-07-01 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#ostream.inserters.character">issues</a> in [ostream.inserters.character].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>

<p>
I think Footnote 297 is confused. The paragraph it applies to seems
quite clear in that widen() is only called if the object is not a char
stream (i.e., not basic_ostream&lt;char&gt;), so it's irrelevant what the
value of widen(c) is otherwise.
</p>


<p><b>Proposed resolution:</b></p>
<p>
I propose to strike the Footnote.
</p>




<hr>
<h3><a name="475"></a>475. May the function object passed to for_each modify the elements of the iterated sequence?</h3>
<p><b>Section:</b> 25.2.4 [alg.foreach] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Stephan T. Lavavej, Jaakko Jarvi <b>Opened:</b> 2004-07-09 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.foreach">issues</a> in [alg.foreach].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It is not clear whether the function object passed to for_each is allowed to
modify the elements of the sequence being iterated over.
</p>

<p>
for_each is classified without explanation in [lib.alg.nonmodifying], "25.1
Non-modifying sequence operations". 'Non-modifying sequence operation' is
never defined.
</p>

<p>
25(5) says: "If an algorithm's Effects section says that a value pointed to
by any iterator passed as an argument is modified, then that algorithm has
an additional type requirement: The type of that argument shall satisfy the
requirements of a mutable iterator (24.1)."
</p>

<p>for_each's Effects section does not mention whether arguments can be
modified:</p>

<blockquote><p>
  "Effects: Applies f to the result of dereferencing every iterator in the
   range [first, last), starting from first and proceeding to last - 1."
</p></blockquote>

<p>
Every other algorithm in [lib.alg.nonmodifying] is "really" non-modifying in
the sense that neither the algorithms themselves nor the function objects
passed to the algorithms may modify the sequences or elements in any way.
This DR affects only for_each.
</p>

<p>
We suspect that for_each's classification in "non-modifying sequence
operations" means that the algorithm itself does not inherently modify the
sequence or the elements in the sequence, but that the function object
passed to it may modify the elements it operates on. 
</p>

<p>
The original STL document by Stepanov and Lee explicitly prohibited the
function object from modifying its argument.
The "obvious" implementation of for_each found in several standard library 
implementations, however, does not impose this restriction.
As a result, we suspect that the use of for_each with function objects that modify
their arguments is wide-spread. 
If the restriction was reinstated, all such code would become non-conforming.
Further, none of the other algorithms in the Standard
could serve the purpose of for_each (transform does not guarantee the order in
which its function object is called). 
</p>

<p>
We suggest that the standard be clarified to explicitly allow the function object 
passed to for_each modify its argument.</p>



<p><b>Proposed resolution:</b></p>
<p>Add a nonnormative note to the Effects in 25.2.4 [alg.foreach]: If
the type of 'first' satisfies the requirements of a mutable iterator,
'f' may apply nonconstant functions through the dereferenced iterators
passed to it.
</p>



<p><b>Rationale:</b></p>
<p>The LWG believes that nothing in the standard prohibits function
  objects that modify the sequence elements. The problem is that
  for_each is in a secion entitled "nonmutating algorithms", and the
  title may be confusing.  A nonnormative note should clarify that.</p>





<hr>
<h3><a name="478"></a>478. Should forward iterator requirements table have a line for r-&gt;m?</h3>
<p><b>Section:</b> 24.2.5 [forward.iterators] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Dave Abrahams <b>Opened:</b> 2004-07-11 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#forward.iterators">issues</a> in [forward.iterators].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#477">477</a></p>
<p><b>Discussion:</b></p>
<p>
The Forward Iterator requirements table contains the following:
</p>
<pre> expression  return type         operational  precondition
                                  semantics
  ==========  ==================  ===========  ==========================
  a-&gt;m        U&amp; if X is mutable, (*a).m       pre: (*a).m is well-defined.
              otherwise const U&amp;

  r-&gt;m        U&amp;                  (*r).m       pre: (*r).m is well-defined.
</pre>

<p>The second line may be unnecessary.  Paragraph 11 of
  [lib.iterator.requirements] says:
</p>

<blockquote><p>
   In the following sections, a and b denote values of type const X, n
   denotes a value of the difference type Distance, u, tmp, and m
   denote identifiers, r denotes a value of X&amp;, t denotes a value of
   value type T, o denotes a value of some type that is writable to
   the output iterator.
</p></blockquote>

<p>
Because operators can be overloaded on an iterator's const-ness, the
current requirements allow iterators to make many of the operations
specified using the identifiers a and b invalid for non-const
iterators.</p>

<p>Related issue: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#477">477</a></p>


<p><b>Proposed resolution:</b></p>

<p>Remove the "r-&gt;m" line from the Forward Iterator requirements
table. Change</p>
<blockquote><p>
    "const X"
</p></blockquote>

<p> to </p>

<blockquote><p>
    "X or const X" 
</p></blockquote>

<p>in paragraph 11 of [lib.iterator.requirements].</p>




<p><b>Rationale:</b></p>
<p>
This is a defect because it constrains an lvalue to returning a modifiable lvalue.
</p>





<hr>
<h3><a name="482"></a>482. Swapping pairs</h3>
<p><b>Section:</b> 20.3.5 [pairs], 20.4 [tuple] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> Andrew Koenig <b>Opened:</b> 2004-09-14 <b>Last modified:</b> 2010-11-20</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#pairs">issues</a> in [pairs].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p>(Based on recent comp.std.c++ discussion)</p>

<p>Pair (and tuple) should specialize std::swap to work in terms of
std::swap on their components.  For example, there's no obvious reason
why swapping two objects of type pair&lt;vector&lt;int&gt;,
list&lt;double&gt; &gt; should not take O(1).</p>

<p><i>[Lillehammer: We agree it should be swappable.  Howard will
  provide wording.]</i></p>


<p><i>[
Post Oxford:  We got <tt>swap</tt> for <tt>pair</tt> but accidently
missed <tt>tuple</tt>.  <tt>tuple::swap</tt> is being tracked by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#522">522</a>.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
Wording provided in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1856.html#20.2.3%20-%20Pairs">N1856</a>.
</p>

<p><b>Rationale:</b></p>
<p>
Recommend <del>NAD</del><ins>Resolved</ins>, fixed by 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1856.html#20.2.3%20-%20Pairs">N1856</a>.
</p>





<hr>
<h3><a name="488"></a>488. rotate throws away useful information</h3>
<p><b>Section:</b> 25.3.11 [alg.rotate] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2004-11-22 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
rotate takes 3 iterators:  first, middle and last which point into a
sequence, and rearranges the sequence such that the subrange [middle,
last) is now at the beginning of the sequence and the subrange [first,
middle) follows.  The return type is void. 
</p>

<p>
In many use cases of rotate, the client needs to know where the
subrange [first, middle) starts after the rotate is performed.  This
might look like: 
</p>
<pre>  rotate(first, middle, last);
  Iterator i = advance(first, distance(middle, last));
</pre>

<p>
Unless the iterators are random access, the computation to find the
start of the subrange [first, middle) has linear complexity.  However,
it is not difficult for rotate to return this information with
negligible additional computation expense.  So the client could code: 
</p>
<pre>  Iterator i = rotate(first, middle, last);
</pre>

<p>
and the resulting program becomes significantly more efficient.
</p>

<p>
While the backwards compatibility hit with this change is not zero, it
is very small (similar to that of lwg <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#130">130</a>), and there is
a significant benefit to the change. 
</p>



<p><b>Proposed resolution:</b></p>
<p>In 25 [algorithms] p2, change:</p>

<blockquote><pre>  template&lt;class ForwardIterator&gt;
    <del>void</del> <ins>ForwardIterator</ins> rotate(ForwardIterator first, ForwardIterator middle,
                ForwardIterator last);
</pre></blockquote>

<p>In 25.3.11 [alg.rotate], change:</p>

<blockquote><pre>  template&lt;class ForwardIterator&gt;
    <del>void</del> <ins>ForwardIterator</ins> rotate(ForwardIterator first, ForwardIterator middle,
                ForwardIterator last);
</pre></blockquote>

<p>In 25.3.11 [alg.rotate] insert a new paragraph after p1:</p>

<blockquote>
<p><b>Returns</b>: <tt>first + (last - middle)</tt>.</p>
</blockquote>

<p><i>[
The LWG agrees with this idea, but has one quibble: we want to make
sure not to give the impression that the function "advance" is
actually called, just that the nth iterator is returned.  (Calling
advance is observable behavior, since users can specialize it for
their own iterators.)  Howard will provide wording.
]</i></p>


<p><i>[Howard provided wording for mid-meeting-mailing Jun. 2005.]</i></p>


<p><i>[
Toronto: moved to Ready.
]</i></p>







<hr>
<h3><a name="495"></a>495. Clause 22 template parameter requirements</h3>
<p><b>Section:</b> 22 [localization] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Beman Dawes <b>Opened:</b> 2005-01-10 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#localization">issues</a> in [localization].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>It appears that there are no requirements specified for many of the
template parameters in clause 22. It looks like this issue has never
come up, except perhaps for Facet.</p>

<p>Clause 22 isn't even listed in 17.3.2.1 [lib.type.descriptions],
either, which is the wording that allows requirements on template
parameters to be identified by name.</p>

<p>So one issue is that 17.3.2.1 [lib.type.descriptions] Should be
changed to cover clause 22. A better change, which will cover us in
the future, would be to say that it applies to all the library
clauses. Then if a template gets added to any library clause we are
covered.</p>

<p>charT, InputIterator, and other names with requirements defined
elsewhere are fine, assuming the 17.3.2.1 [lib.type.descriptions] fix.
But there are a few template arguments names which I don't think have
requirements given elsewhere:</p>

<ul>
<li>internT and externT.  The fix is to add wording saying that internT
and externT must meet the same requirements as template arguments
named charT.</li>

<li>stateT.  I'm not sure about this one. There already is some wording,
but it seems a bit vague.</li>

<li>Intl.  [lib.locale.moneypunct.byname] The fix for this one is to
rename "Intl" to "International". The name is important because other
text identifies the requirements for the name International but not
for Intl.</li>
</ul>

<p><b>Proposed resolution:</b></p>
<p>Change 17.5.2.1 [type.descriptions], paragraph 1, from:</p>
<blockquote><p>
The Requirements subclauses may describe names that are used to
specify constraints on template arguments.153) These names are used in
clauses 20, 23, 25, and 26 to describe the types that may be supplied
as arguments by a C++ program when instantiating template components
from the library. 
</p></blockquote>
<p>to:</p>
<blockquote><p>
The Requirements subclauses may describe names that are used to
specify constraints on template arguments.153) These names are used in
library clauses to describe the types that may be supplied as
arguments by a C++ program when instantiating template components from
the library.
</p></blockquote>

<p>In the front matter of class 22, locales, add:</p>
<blockquote><p>
Template parameter types internT and externT shall meet the
requirements of charT (described in 21 [strings]).
</p></blockquote>


<p><b>Rationale:</b></p>
<p>
 Again, a blanket clause isn't blanket enough. Also, we've got a
 couple of names that we don't have blanket requirement statements
 for. The only issue is what to do about stateT. This wording is
 thin, but probably adequate.</p>





<hr>
<h3><a name="496"></a>496. Illegal use of "T" in vector&lt;bool&gt;</h3>
<p><b>Section:</b> 23.4.1 [vector] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> richard@ex-parrot.com <b>Opened:</b> 2005-02-10 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#vector">issues</a> in [vector].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In the synopsis of the std::vector&lt;bool&gt; specialisation in 23.4.1 [vector],
the non-template assign() function has the signature</p>

<pre>  void assign( size_type n, const T&amp; t );
</pre>

<p>The type, T, is not defined in this context.</p>


<p><b>Proposed resolution:</b></p>
<p>Replace "T" with "value_type".</p>





<hr>
<h3><a name="497"></a>497. meaning of numeric_limits::traps for floating point types</h3>
<p><b>Section:</b> 18.3.1.2 [numeric.limits.members] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2005-03-02 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#numeric.limits.members">issues</a> in [numeric.limits.members].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>

<p>18.2.1.2, p59 says this much about the traps member of numeric_limits:</p>

<blockquote>
<p>static const bool traps;<br>
-59- true if trapping is implemented for the type.204)
<br>
Footnote 204: Required by LIA-1.
</p>
</blockquote>

<p>It's not clear what is meant by "is implemented" here.</p>

<p>
In the context of floating point numbers it seems reasonable to expect
to be able to use traps to determine whether a program can "safely" use
infinity(), quiet_NaN(), etc., in arithmetic expressions, that is
without causing a trap (i.e., on UNIX without having to worry about
getting a signal). When traps is true, I would expect any of the
operations in section 7 of IEEE 754 to cause a trap (and my program
to get a SIGFPE). So, for example, on Alpha, I would expect traps
to be true by default (unless I compiled my program with the -ieee
option), false by default on most other popular architectures,
including IA64, MIPS, PA-RISC, PPC, SPARC, and x86 which require
traps to be explicitly enabled by the program.
</p>

<p>
Another possible interpretation of p59 is that traps should be true
on any implementation that supports traps regardless of whether they
are enabled by default or not. I don't think such an interpretation
makes the traps member very useful, even though that is how traps is
implemented on several platforms. It is also the only way to implement
traps on platforms that allow programs to enable and disable trapping
at runtime.
</p>


<p><b>Proposed resolution:</b></p>
<p>Change p59 to read:</p>
<blockquote><p>True if, at program startup, there exists a value of the type that
  would cause an arithmetic operation using that value to trap.</p></blockquote>


<p><b>Rationale:</b></p>
<p>
 Real issue, since trapping can be turned on and off. Unclear what a
 static query can say about a dynamic issue. The real advice we should
 give users is to use cfenv for these sorts of queries. But this new
 proposed resolution is at least consistent and slightly better than
 nothing.</p>





<hr>
<h3><a name="498"></a>498. Requirements for partition() and stable_partition() too strong</h3>
<p><b>Section:</b> 25.3.13 [alg.partitions] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Sean Parent, Joe Gottman <b>Opened:</b> 2005-05-04 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Problem:
The iterator requirements for partition() and stable_partition() [25.2.12]
are listed as BidirectionalIterator, however, there are efficient algorithms
for these functions that only require ForwardIterator that have been known
since before the standard existed. The SGI implementation includes these (see
<a href="http://www.sgi.com/tech/stl/partition.html">http://www.sgi.com/tech/stl/partition.html</a>
and
<a href="http://www.sgi.com/tech/stl/stable_partition.html">http://www.sgi.com/tech/stl/stable_partition.html</a>).
</p>

<p><i>[
2009-04-30 Alisdair adds:
]</i></p>


<blockquote>
<p>
Now we have concepts this is easier to express!
</p>
<p>
Proposed resolution:
</p>
<p>
Add the following signature to:
</p>
<p>
Header <tt>&lt;algorithm&gt;</tt> synopsis  [algorithms.syn]<br>
p3 Partitions 25.3.13 [alg.partitions]
</p>
<blockquote><pre> template&lt;ForwardIterator Iter, Predicate&lt;auto, Iter::value_type&gt; Pred&gt;
   requires ShuffleIterator&lt;Iter&gt;
         &amp;&amp; CopyConstructible&lt;Pred&gt;
   Iter partition(Iter first, Iter last, Pred pred);
</pre></blockquote>

<p>
Update p3 Partitions 25.3.13 [alg.partitions]:
</p>

<blockquote>
<p>
<i>Complexity:</i> <del>At most <tt>(last - first)/2</tt> swaps. Exactly <tt>last - first</tt>
applications of the predicate
are done.</del>
<ins>
If <tt>Iter</tt> satisfies <tt>BidirectionalIterator</tt>, at most <tt>(last -
first)/2</tt> swaps. Exactly <tt>last - first</tt> applications of the predicate
are done.
</ins>
</p>
<p><ins>
If <tt>Iter</tt> merely satisfied <tt>ForwardIterator</tt> at most <tt>(last - first)</tt> swaps
are done. Exactly <tt>(last - first)</tt> applications of the predicate are done.
</ins></p>
</blockquote>

<p>
[Editorial note: I looked for existing precedent in how we might call out
distinct overloads overloads from a set of constrained templates, but there
is not much existing practice to lean on.   advance/distance were the only
algorithms I could find, and that wording is no clearer.]
</p>

</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
Hinnant: if you want to partition your std::forward_list, you'll need
partition() to accept ForwardIterators.
</p>
<p>
No objection to Ready.
</p>
<p>
Move to Ready.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 25.2.12 from </p>
<blockquote><pre>template&lt;class BidirectionalIterator, class Predicate&gt; 
BidirectionalIterator partition(BidirectionalIterato r first, 
                                BidirectionalIterator last, 
                                Predicate pred); 
</pre></blockquote>
<p>to </p>
<blockquote><pre>template&lt;class ForwardIterator, class Predicate&gt; 
ForwardIterator partition(ForwardIterator first, 
                          ForwardIterator last, 
                          Predicate pred); 
</pre></blockquote>
<p>Change the complexity from </p>

<blockquote><p>
At most (last - first)/2 swaps are done. Exactly (last - first) 
applications of the predicate are done. 
</p></blockquote>

<p>to </p>

<blockquote><p>
If ForwardIterator is a bidirectional_iterator, at most (last - first)/2 
swaps are done; otherwise at most (last - first) swaps are done. Exactly 
(last - first) applications of the predicate are done. 
</p></blockquote>



<p><b>Rationale:</b></p>
<p>
Partition is a "foundation" algorithm useful in many contexts (like sorting
as just one example) - my motivation for extending it to include forward
iterators is foward_list - without this extension you can't partition an foward_list
(without writing your own partition). Holes like this in the standard
library weaken the argument for generic programming (ideally I'd be able
to provide a library that would refine std::partition() to other concepts
without fear of conflicting with other libraries doing the same - but
that is a digression). I consider the fact that partition isn't defined
to work for ForwardIterator a minor embarrassment.
</p>

<p><i>[Mont Tremblant:  Moved to Open, request motivation and use cases by next meeting. Sean provided further rationale by post-meeting mailing.]</i></p>







<hr>
<h3><a name="505"></a>505. Result_type in random distribution requirements</h3>
<p><b>Section:</b> 26.5.1 [rand.req], TR1 5.1.1 [tr.rand.req] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Walter Brown <b>Opened:</b> 2005-07-03 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.req">issues</a> in [rand.req].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Table 17: Random distribution requirements
</p>
<p>
Row 1 requires that each random distribution provide a nested type "input_type";
this type denotes the type of the values that the distribution consumes.
</p>
<p>
Inspection of all distributions in [tr.rand.dist] reveals that each distribution
provides a second typedef ("result_type") that denotes the type of the values the
distribution produces when called.  
</p>


<p><b>Proposed resolution:</b></p>
<p>
It seems to me that this is also a requirement
for all distributions and should therefore be  indicated as such via a new second
row to this table 17:
</p>
<table border="1" cellpadding="5">
<tbody><tr><td>X::result_type</td><td>T</td><td>---</td><td>compile-time</td></tr>
</tbody></table>

<p><i>[
Berlin:  Voted to WP.  N1932 adopts the proposed resolution:  see Table 5 row 1.
]</i></p>







<hr>
<h3><a name="507"></a>507. Missing requirement for variate_generator::operator()</h3>
<p><b>Section:</b> 26.5 [rand], TR1 5.1.3 [tr.rand.var] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Walter Brown <b>Opened:</b> 2005-07-03 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand">issues</a> in [rand].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Paragraph 11 of [tr.rand.var] equires that the member template
</p>
<blockquote><pre>template&lt;class T&gt; result_type operator() (T value);
</pre></blockquote>
<p>
return
</p>
<blockquote><pre>distribution()(e, value)
</pre></blockquote>
<p>
However, not all distributions have an operator() with a corresponding signature.
</p>

<p><i>[
Berlin:  As a working group we voted in favor of N1932 which makes this moot:
variate_generator has been eliminated.  Then in full committee we voted to give
this issue WP status (mistakenly).
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
We therefore  recommend that we insert the following precondition before paragraph 11:
</p>
<blockquote><p>
Precondition:  <tt>distribution().operator()(e,value)</tt> is well-formed.
</p></blockquote>





<hr>
<h3><a name="508"></a>508. Bad parameters for ranlux64_base_01</h3>
<p><b>Section:</b> 26.5.5 [rand.predef], TR1 5.1.5 [tr.rand.predef] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Walter Brown <b>Opened:</b> 2005-07-03 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.predef">issues</a> in [rand.predef].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The fifth of these engines with predefined parameters, ranlux64_base_01,
appears to have an unintentional error for which there is a simple correction.
The two pre-defined  subtract_with_carry_01 engines are given as: 
</p>
<blockquote><pre>typedef subtract_with_carry_01&lt;float,  24, 10, 24&gt; ranlux_base_01;
typedef subtract_with_carry_01&lt;double, 48, 10, 24&gt; ranlux64_base_01;
</pre></blockquote>
<p>
We demonstrate below that ranlux64_base_01 fails to meet the intent of the
random number generation proposal, but that the simple correction to
</p>
<blockquote><pre>typedef subtract_with_carry_01&lt;double, 48,  5, 12&gt; ranlux64_base_01;
</pre></blockquote>
<p>
does meet the intent of defining well-known good parameterizations.
</p>
<p>
The ranlux64_base_01 engine as presented fails to meet the intent for
predefined engines, stated in proposal N1398 (section E):
</p>
<blockquote><p>
In order to make good random numbers available to a large number of library
users, this proposal not only defines generic random-number engines, but also
provides a number of predefined well-known good parameterizations for those.
</p></blockquote>
<p>
The predefined ranlux_base_01 engine has been proven [1,2,3] to have a very
long period and so meets this criterion.  This property makes it suitable for
use in the excellent discard_block  engines defined subsequently.  The proof
of long period relies on the fact (proven in [1]) that 2**(w*r) - 2**(w*s)
+ 1 is prime (w, r, and s are template parameters to subtract_with_carry_01,
as defined in [tr.rand.eng.sub1]).
</p>
<p>
The ranlux64_base_01 engine as presented in [tr.rand.predef] uses w=48, r=24, s=10.
For these numbers, the combination 2**(w*r)-2**(w*s)+1 is non-prime (though
explicit factorization  would be a challenge).  In consequence, while it is
certainly possible for some seeding states that this engine would have a very
long period, it is not at all "well-known" that this is the case. The intent
in the N1398 proposal involved the base of the ranlux64 engine, which finds heavy
use in the physics community.  This is isomorphic to the predefined ranlux_base_01,
but exploits the ability of double variables to hold (at least) 48 bits of mantissa,
to deliver 48 random bits at a time rather than 24.
</p>


<p><b>Proposed resolution:</b></p>
<p>
To achieve this intended behavior, the correct template parameteriztion  would be:
</p>
<blockquote><pre>typedef subtract_with_carry_01&lt;double, 48, 5, 12&gt; ranlux64_base_01;
</pre></blockquote>
<p>
The sequence of mantissa bits delivered by this is isomorphic (treating each
double as having the  bits of two floats) to that delivered by ranlux_base_01.
</p>
<p>
<b>References:</b>
</p>
<ol>
<li>F. James, Comput. Phys. Commun. 60(1990) 329</li>
<li>G. Marsaglia and A. Zaman, Ann. Appl. Prob 1(1991) 462</li>
<li>M. Luscher, Comput. Phys. Commun. 79(1994) 100-110</li>
</ol>

<p><i>[
Berlin: Voted to WP.  N1932 adopts the proposed resolution in 26.3.5,
just above paragraph 5.
]</i></p>







<hr>
<h3><a name="518"></a>518. Are insert and erase stable for unordered_multiset and unordered_multimap?</h3>
<p><b>Section:</b> 23.2.5 [unord.req], TR1 6.3.1 [tr.unord.req] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2005-07-03 <b>Last modified:</b> 2010-10-29</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#unord.req">active issues</a> in [unord.req].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#unord.req">issues</a> in [unord.req].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Issue 371 deals with stability of multiset/multimap under insert and erase
(i.e. do they preserve the relative order in ranges of equal elements).
The same issue applies to unordered_multiset and unordered_multimap.
</p>
<p><i>[
Moved to open (from review):  There is no resolution.
]</i></p>


<p><i>[
Toronto:  We have a resolution now.  Moved to Review.  Some concern was noted
as to whether this conflicted with existing practice or not.  An additional
concern was in specifying (partial) ordering for an unordered container.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
Wording for the proposed resolution is taken from the equivalent text for associative containers.
</p>

<p>
Change 23.2.5 [unord.req], Unordered associative containers, paragraph 6 to:
</p>

<blockquote><p>
An unordered associative container supports <i>unique</i> keys if it may 
contain at most one element for each key. Otherwise, it supports <i>equivalent 
keys</i>. <tt>unordered_set</tt> and <tt>unordered_map</tt> support 
unique keys. <tt>unordered_multiset</tt> and <tt>unordered_multimap</tt> 
support equivalent keys. In containers that support equivalent keys, elements 
with equivalent keys are adjacent to each other. <ins>For
<tt>unordered_multiset</tt> 
and <tt>unordered_multimap</tt>,<tt> insert</tt> and <tt>erase</tt> 
preserve the relative ordering of equivalent elements.</ins>
</p></blockquote>

<p>
Change 23.2.5 [unord.req], Unordered associative containers, paragraph 8 to:
</p>

<blockquote>
<p>The elements of an unordered associative container are organized into <i>
buckets</i>. Keys with the same hash code appear in the same bucket. The number 
of buckets is automatically increased as elements are added to an unordered 
associative container, so that the average number of elements per bucket is kept 
below a bound. Rehashing invalidates iterators, changes ordering between 
elements, and changes which buckets elements appear in, but does not invalidate 
pointers or references to elements. <ins>For <tt>unordered_multiset</tt> 
and <tt>unordered_multimap</tt>, rehashing 
preserves the relative ordering of equivalent elements.</ins></p>
</blockquote>






<hr>
<h3><a name="519"></a>519. Data() undocumented</h3>
<p><b>Section:</b> 23.3.1 [array], TR1 6.2.2 [tr.array.array] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2005-07-03 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#array">issues</a> in [array].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>array&lt;&gt;::data()</tt> is present in the class synopsis, but not documented.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add a new section, after 6.2.2.3:
</p>
<blockquote><pre>T*       data()
const T* data() const;
</pre></blockquote>
<p>
<b>Returns:</b> <tt>elems</tt>.
</p>
<p>
Change 6.2.2.4/2 to:
</p>
<blockquote><p>
In the case where <tt>N == 0</tt>, <tt>begin() == end()</tt>. The return value
of <tt>data()</tt> is unspecified.
</p></blockquote>





<hr>
<h3><a name="520"></a>520. Result_of and pointers to data members</h3>
<p><b>Section:</b> 20.8.10.1 [func.bind], TR1 3.6 [tr.func.bind] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2005-07-03 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In the original proposal for binders, the return type of bind() when
called with a pointer to member data as it's callable object was
defined to be mem_fn(ptr); when Peter Dimov and I  unified the
descriptions of the TR1 function objects we hoisted the descriptions
of return types into the INVOKE pseudo-function and into result_of.
Unfortunately, we left pointer to member data out of result_of, so
bind doesn't have any specified behavior when called with a pointer
to  member data.
</p>


<p><b>Proposed resolution:</b></p>
<p><i>[
Pete and Peter will provide wording.
]</i></p>


<p>
In 20.5.4 [lib.func.ret] ([tr.func.ret]) p3 add the following bullet after bullet 2:
</p>
<ol start="3">
<li>If <tt>F</tt> is a member data pointer type <tt>R T::*</tt>, <tt>type</tt>
shall be <tt><i>cv</i> R&amp;</tt> when <tt>T1</tt> is <tt><i>cv</i> U1&amp;</tt>,
<tt>R</tt> otherwise.</li>
</ol>

<p><i>[
Peter provided wording.
]</i></p>







<hr>
<h3><a name="521"></a>521. Garbled requirements for argument_type in reference_wrapper</h3>
<p><b>Section:</b> 20.8.4 [refwrap], TR1 2.1.2 [tr.util.refwrp.refwrp] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2005-07-03 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#refwrap">issues</a> in [refwrap].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
2.1.2/3, second bullet item currently says that reference_wrapper&lt;T&gt; is
derived from unary_function&lt;T, R&gt; if T is:
</p>
<blockquote><p>
a pointer to member function type with cv-qualifier cv and no arguments;
the type T1 is cv T* and R is the return type of the pointer to member function;
</p></blockquote>
<p>
The type of T1 can't be cv T*, 'cause that's a pointer to a pointer to member
function. It should be a pointer to the class that T is a pointer to member of.
Like this:
</p>
<blockquote><p>
a pointer to a member function R T0::f() cv (where cv represents the member
function's cv-qualifiers); the type T1 is cv T0*
</p></blockquote>
<p>
Similarly, bullet item 2 in 2.1.2/4 should be:
</p>
<blockquote><p>
a pointer to a member function R T0::f(T2) cv (where cv represents the member
function's cv-qualifiers); the type T1 is cv T0*
</p></blockquote>


<p><b>Proposed resolution:</b></p>

<p>
Change bullet item 2 in 2.1.2/3:
</p>

<blockquote>
<ul>
<li>
a pointer to member function <del>type with cv-qualifier <tt><i>cv</i></tt> and no arguments;
the type <tt>T1</tt> is <tt><i>cv</i> T*</tt> and <tt>R</tt> is the return 
type of the pointer to member function</del> <ins><tt>R T0::f() <i>cv</i></tt>
(where <tt><i>cv</i></tt> represents the member function's cv-qualifiers);
the type <tt>T1</tt> is <tt><i>cv</i> T0*</tt></ins>
</li>
</ul>
</blockquote>

<p>
Change bullet item 2 in 2.1.2/4:
</p>

<blockquote>
<ul>
<li>
a pointer to member function <del>with cv-qualifier <tt><i>cv</i></tt> and taking one argument
of type <tt>T2</tt>; the type <tt>T1</tt> is <tt><i>cv</i> T*</tt> and 
<tt>R</tt> is the return type of the pointer to member function</del>
<ins><tt>R T0::f(T2) <i>cv</i></tt> (where <tt><i>cv</i></tt> represents the member
function's cv-qualifiers); the type <tt>T1</tt> is <tt><i>cv</i> T0*</tt></ins>
</li>
</ul>
</blockquote>






<hr>
<h3><a name="522"></a>522. Tuple doesn't define swap</h3>
<p><b>Section:</b> 20.4 [tuple], TR1 6.1 [tr.tuple] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Andy Koenig <b>Opened:</b> 2005-07-03 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#tuple">issues</a> in [tuple].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Tuple doesn't define swap().  It should.
</p>
<p><i>[
Berlin: Doug to provide wording.
]</i></p>

<p><i>[
Batavia: Howard to provide wording.
]</i></p>

<p><i>[
Toronto: Howard to provide wording (really this time).
]</i></p>


<p><i>[
Bellevue:  Alisdair provided wording.
]</i></p>




<p><b>Proposed resolution:</b></p>

<p>
Add these signatures to 20.4 [tuple]
</p>

<blockquote><pre>template &lt;class... Types&gt;
  void swap(tuple&lt;Types...&gt;&amp; x, tuple&lt;Types...&gt;&amp; y);
template &lt;class... Types&gt;
  void swap(tuple&lt;Types...&gt;&amp;&amp; x, tuple&lt;Types...&gt;&amp; y);
template &lt;class... Types&gt;
  void swap(tuple&lt;Types...&gt;&amp; x, tuple&lt;Types...&gt;&amp;&amp; y); 
</pre></blockquote>

<p>
Add this signature to 20.4.2 [tuple.tuple]
</p>

<blockquote><pre>void swap(tuple&amp;&amp;);
</pre></blockquote>

<p>
Add the following two sections to the end of the tuple clauses
</p>

<blockquote>
<p>
20.3.1.7 tuple swap [tuple.swap]
</p>

<pre>void swap(tuple&amp;&amp; rhs); 
</pre>

<blockquote>
<p>
<i>Requires:</i> Each type in <tt>Types</tt> shall be <tt>Swappable</tt>.
</p>
<p>
<i>Effects:</i> Calls <tt>swap</tt> for each element in <tt>*this</tt> and its corresponding element
in <tt>rhs</tt>.
</p>
<p>
<i>Throws:</i> Nothing, unless one of the element-wise <tt>swap</tt> calls throw an
exception. 
</p>
</blockquote>

<p>
20.3.1.8 tuple specialized algorithms [tuple.special]
</p>

<pre>template &lt;class... Types&gt;
  void swap(tuple&lt;Types...&gt;&amp; x, tuple&lt;Types...&gt;&amp; y);
template &lt;class... Types&gt;
  void swap(tuple&lt;Types...&gt;&amp;&amp; x, tuple&lt;Types...&gt;&amp; y);
template &lt;class... Types&gt;
  void swap(tuple&lt;Types...&gt;&amp; x, tuple&lt;Types...&gt;&amp;&amp; y); 
</pre>

<blockquote>
<p>
<i>Effects:</i> x.swap(y)
</p>
</blockquote>
</blockquote>






<hr>
<h3><a name="524"></a>524. regex named character classes and case-insensitivity don't mix</h3>
<p><b>Section:</b> 28 [re] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Eric Niebler <b>Opened:</b> 2005-07-01 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#re">issues</a> in [re].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
This defect is also being discussed on the Boost developers list. The 
full discussion can be found here:
http://lists.boost.org/boost/2005/07/29546.php
</p>
<p>
-- Begin original message --
</p>
<p>
Also, I may have found another issue, closely related to the one under
discussion. It regards case-insensitive matching of named character
classes. The regex_traits&lt;&gt; provides two functions for working with
named char classes: lookup_classname and isctype. To match a char class
such as [[:alpha:]], you pass "alpha" to lookup_classname and get a
bitmask. Later, you pass a char and the bitmask to isctype and get a
bool yes/no answer.
</p>
<p>
But how does case-insensitivity work in this scenario? Suppose we're
doing a case-insensitive match on [[:lower:]]. It should behave as if it
were [[:lower:][:upper:]], right? But there doesn't seem to be enough
smarts in the regex_traits interface to do this.
</p>
<p>
Imagine I write a traits class which recognizes [[:fubar:]], and the
"fubar" char class happens to be case-sensitive. How is the regex engine
to know that? And how should it do a case-insensitive match of a
character against the [[:fubar:]] char class? John, can you confirm this
is a legitimate problem?
</p>
<p>
I see two options:
</p>
<p>
1) Add a bool icase parameter to lookup_classname. Then,
lookup_classname( "upper", true ) will know to return lower|upper
instead of just upper.
</p>
<p>
2) Add a isctype_nocase function
</p>
<p>
I prefer (1) because the extra computation happens at the time the
pattern is compiled rather than when it is executed.
</p>
<p>
-- End original message --
</p>

<p>
For what it's worth, John has also expressed his preference for option 
(1) above.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Adopt the proposed resolution in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2409.pdf">N2409</a>.
</p>


<p><i>[
Kona (2007): The LWG adopted the proposed resolution of N2409 for this issue.
The LWG voted to accelerate this issue to Ready status to be voted into the WP at Kona.
]</i></p>





<hr>
<h3><a name="525"></a>525. type traits definitions not clear</h3>
<p><b>Section:</b> 20.7.4 [meta.unary], TR1 4.5 [tr.meta.unary] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> Robert Klarer <b>Opened:</b> 2005-07-11 <b>Last modified:</b> 2010-11-19</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#meta.unary">issues</a> in [meta.unary].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It is not completely clear how the primary type traits deal with
cv-qualified types.  And several of the secondary type traits
seem to be lacking a definition.
</p>

<p><i>[
Berlin:  Howard to provide wording.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
Wording provided in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2028.html">N2028</a>.
A
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2157.html">revision (N2157)</a>
provides more detail for motivation.
</p>


<p><b>Rationale:</b></p>
Solved by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2157.html">revision (N2157)</a>
in the WP.





<hr>
<h3><a name="527"></a>527. tr1::bind has lost its Throws clause</h3>
<p><b>Section:</b> 20.8.10.1.2 [func.bind.bind], TR1 3.6.3 [tr.func.bind.bind] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Peter Dimov <b>Opened:</b> 2005-10-01 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#func.bind.bind">issues</a> in [func.bind.bind].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The original bind proposal gives the guarantee that tr1::bind(f, t1, ..., tN) does not throw when the copy constructors of f, t1, ..., tN don't.
</p>

<p>
This guarantee is not present in the final version of TR1.
</p>

<p>
I'm pretty certain that we never removed it on purpose. Editorial omission? :-)
</p>

<p><i>[
Berlin: not quite editorial, needs proposed wording.
]</i></p>

<p><i>[
Batavia:  Doug to translate wording to variadic templates.
]</i></p>


<p><i>[
Toronto:  We agree but aren't quite happy with the wording.  The "t"'s no
longer refer to anything.  Alan to provide improved wording.
]</i></p>



<p><i>[
Pre-Bellevue:  Alisdair provided wording.
]</i></p>


<p>
TR1 proposed resolution:
</p>

<blockquote>
<p>
In TR1 3.6.3 [tr.func.bind.bind], add a new paragraph after p2:
</p>
<blockquote><p>
<i>Throws:</i> Nothing unless one of the copy constructors of <tt>f, t1, t2, ..., tN</tt>
throws an exception.
</p></blockquote>

<p>
Add a new paragraph after p4:
</p>
<blockquote><p>
<i>Throws:</i> nothing unless one of the copy constructors of <tt>f, t1, t2, ..., tN</tt>
throws an exception.
</p></blockquote>

</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
In 20.8.10.1.2 [func.bind.bind], add a new paragraph after p2:
</p>

<blockquote>
<i>Throws:</i> Nothing unless the copy constructor of <tt>F</tt> or of one of the types
in the <tt>BoundArgs...</tt> pack expansion throws an exception. 
</blockquote>

<p>
In 20.8.10.1.2 [func.bind.bind], add a new paragraph after p4:
</p>

<blockquote>
<i>Throws:</i> Nothing unless the copy constructor of <tt>F</tt> or of one of the types
in the <tt>BoundArgs...</tt> pack expansion throws an exception. 
</blockquote>






<hr>
<h3><a name="530"></a>530. Must elements of a string be contiguous?</h3>
<p><b>Section:</b> 21.4 [basic.string] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2005-11-15 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#basic.string">issues</a> in [basic.string].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>Issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#69">69</a>, which was incorporated into C++03, mandated
   that the elements of a vector must be stored in contiguous memory.
   Should the same also apply to <tt>basic_string</tt>?</p>

<p>We almost require contiguity already. Clause 23.6.4 [multiset]
  defines <tt>operator[]</tt> as <tt>data()[pos]</tt>. What's missing
  is a similar guarantee if we access the string's elements via the
  iterator interface.</p>

<p>Given the existence of <tt>data()</tt>, and the definition of
  <tt>operator[]</tt> and <tt>at</tt> in terms of <tt>data</tt>,
  I don't believe it's possible to write a useful and standard-
  conforming <tt>basic_string</tt> that isn't contiguous. I'm not
  aware of any non-contiguous implementation. We should just require
  it.
</p>


<p><b>Proposed resolution:</b></p>
<p>Add the following text to the end of 21.4 [basic.string],
paragraph 2. </p>

<blockquote>
  <p>The characters in a string are stored contiguously, meaning that if
  <tt>s</tt> is a <tt>basic_string&lt;charT, Allocator&gt;</tt>, then
  it obeys the identity
  <tt>&amp;*(s.begin() + n) == &amp;*s.begin() + n</tt>
  for all <tt>0 &lt;= n &lt; s.size()</tt>.
  </p>
</blockquote>


<p><b>Rationale:</b></p>
<p>
Not standardizing this existing practice does not give implementors more
freedom.  We thought it might a decade ago.  But the vendors have spoken
both with their implementations, and with their voice at the LWG
meetings.  The implementations are going to be contiguous no matter what
the standard says.  So the standard might as well give string clients
more design choices.
</p>





<hr>
<h3><a name="531"></a>531. array forms of unformatted input functions</h3>
<p><b>Section:</b> 27.7.1.3 [istream.unformatted] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2005-11-23 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#istream.unformatted">issues</a> in [istream.unformatted].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The array forms of unformatted input functions don't seem to have well-defined
semantics for zero-element arrays in a couple of cases. The affected ones
(<tt>istream::get()</tt> and <tt>istream::getline()</tt>) are supposed to
terminate when <tt>(n - 1)</tt> characters are stored, which obviously can
never be true when <tt>(n == 0)</tt> holds to start with. See
c++std-lib-16071.
</p>


<p><b>Proposed resolution:</b></p>
<p>
I suggest changing 27.6.1.3, p7 (<tt>istream::get()</tt>), bullet 1 to read:
</p>
            <ul>
                <li>
                    <tt>(n &lt; 1)</tt> is true or <tt>(n - 1)</tt> characters
                    are stored;
                </li>
            </ul>
<p>
Change 27.6.1.3, p9:
</p>

<blockquote><p>
If the function stores no characters, it calls <tt>setstate(failbit)</tt> (which
may throw <tt>ios_base::failure</tt> (27.4.4.3)).  In any case, <ins>if <tt>(n
&gt; 0)</tt> is true</ins> it then stores a null character into the next
successive location of the array.
</p></blockquote>

        <p>

and similarly p17 (<tt>istream::getline()</tt>), bullet 3 to:

        </p>
            <ul>
                <li>
                    <tt>(n &lt; 1)</tt> is true or <tt>(n - 1)</tt> characters
                    are stored (in which case the function calls
                    <tt>setstate(failbit)</tt>).
                </li>
            </ul>

        <p>

In addition, to clarify that <tt>istream::getline()</tt> must not store the
terminating NUL character unless the the array has non-zero size, Robert
Klarer suggests in c++std-lib-16082 to change 27.6.1.3, p20 to read:

        </p>
            <blockquote><p>

In any case, provided <tt>(n &gt; 0)</tt> is true, it then stores a null character
(using charT()) into the next successive location of the array.

            </p></blockquote>

<p><i>[
post-Redmond:  Pete noticed that the current resolution for <tt>get</tt> requires
writing to out of bounds memory when <tt>n == 0</tt>.  Martin provided fix.
]</i></p>







<hr>
<h3><a name="533"></a>533. typo in 2.2.3.10/1</h3>
<p><b>Section:</b> 20.9.10.2.11 [util.smartptr.getdeleter], TR1 2.2.3.10 [tr.util.smartptr.getdeleter] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Paolo Carlini <b>Opened:</b> 2005-11-09 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#util.smartptr.getdeleter">issues</a> in [util.smartptr.getdeleter].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I'm seeing something that looks like a typo. The Return of <tt>get_deleter</tt>
says:
</p>
<blockquote><p>
If <tt>*this</tt> <i>owns</i> a deleter <tt>d</tt>...
</p></blockquote>
<p>
but <tt>get_deleter</tt> is a free function!
</p>


<p><b>Proposed resolution:</b></p>
<p>
Therefore, I think should be:
</p>
<blockquote><p>
If <tt><del>*this</del> <ins>p</ins></tt> <i>owns</i> a deleter <tt>d</tt>...
</p></blockquote>





<hr>
<h3><a name="534"></a>534. Missing basic_string members</h3>
<p><b>Section:</b> 21.4 [basic.string] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2005-11-16 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#basic.string">issues</a> in [basic.string].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
OK, we all know std::basic_string is bloated and already has way too
many members.  However, I propose it is missing 3 useful members that
are often expected by users believing it is a close approximation of the
container concept.  All 3 are listed in table 71 as 'optional'
</p>

<p>
i/  pop_back.
</p>

<p>
This is the one I feel most strongly about, as I only just discovered it
was missing as we are switching to a more conforming standard library
&lt;g&gt;
</p>

<p>
I find it particularly inconsistent to support push_back, but not
pop_back.
</p>

<p>
ii/ back.
</p>

<p>
There are certainly cases where I want to examine the last character of
a string before deciding to append, or to trim trailing path separators
from directory names etc.  *rbegin() somehow feels inelegant.
</p>

<p>
iii/ front
</p>

<p>
This one I don't feel strongly about, but if I can get the first two,
this one feels that it should be added as a 'me too' for consistency.
</p>

<p>
I believe this would be similarly useful to the data() member recently
added to vector, or at() member added to the maps.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add the following members to definition of class template basic_string, 21.3p7
</p>
<blockquote><pre>void pop_back ()

const charT &amp; front() const
charT &amp; front()

const charT &amp; back() const
charT &amp; back()
</pre></blockquote>
<p>
Add the following paragraphs to basic_string description
</p>

<p>
21.3.4p5
</p>
<blockquote>
<pre>const charT &amp; front() const
charT &amp; front()
</pre>
<p>
<i>Precondition:</i> <tt>!empty()</tt>
</p>
<p>
<i>Effects:</i> Equivalent to <tt>operator[](0)</tt>.
</p>
</blockquote>

<p>
21.3.4p6
</p>
<blockquote>
<pre>const charT &amp; back() const
charT &amp; back()
</pre>
<p>
<i>Precondition:</i> <tt>!empty()</tt>
</p>
<p>
<i>Effects:</i> Equivalent to <tt>operator[]( size() - 1)</tt>.
</p>
</blockquote>

<p>
21.3.5.5p10
</p>
<blockquote>
<pre>void pop_back ()
</pre>
<p>
<i>Precondition:</i> <tt>!empty()</tt>
</p>
<p>
<i>Effects:</i> Equivalent to <tt>erase( size() - 1, 1 )</tt>.
</p>
</blockquote>

<p>
Update Table 71: (optional sequence operations)
Add basic_string to the list of containers for the following operations.
</p>
<blockquote><pre>a.front()
a.back()
a.push_back()
a.pop_back()
a[n]
</pre></blockquote>

<p><i>[
Berlin: Has support.  Alisdair provided wording.
]</i></p>






<hr>
<h3><a name="535"></a>535. std::string::swap specification poorly worded</h3>
<p><b>Section:</b> 21.4.6.8 [string::swap] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Beman Dawes <b>Opened:</b> 2005-12-14 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#string::swap">issues</a> in [string::swap].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
std::string::swap currently says for effects and postcondition:
</p>

<blockquote>
<p>
<i>Effects:</i> Swaps the contents of the two strings.
</p>

<p>
<i>Postcondition:</i> <tt>*this</tt> contains the characters that were in <tt><i>s</i></tt>,
<tt><i>s</i></tt> contains the characters that were in <tt>*this</tt>.
</p>
</blockquote>

<p>
Specifying both Effects and Postcondition seems redundant, and the postcondition
needs to be made stronger. Users would be unhappy if the characters were not in
the same order after the swap.
</p>


<p><b>Proposed resolution:</b></p>
<blockquote>
<p>
<del><i>Effects:</i> Swaps the contents of the two strings.</del>
</p>

<p>
<i>Postcondition:</i> <tt>*this</tt> contains the <ins>same sequence of</ins>
characters that <del>were</del> <ins>was</ins> in <tt><i>s</i></tt>,
<tt><i>s</i></tt> contains the <ins>same sequence of</ins> characters that
<del>were</del> <ins>was</ins> in <tt>*this</tt>.
</p>
</blockquote>





<hr>
<h3><a name="537"></a>537. Typos in the signatures in 27.6.1.3/42-43 and 27.6.2.4</h3>
<p><b>Section:</b> 27.7.1.3 [istream.unformatted] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Paolo Carlini <b>Opened:</b> 2006-02-12 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#istream.unformatted">issues</a> in [istream.unformatted].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In the most recent working draft, I'm still seeing:
</p>

<blockquote><pre>seekg(off_type&amp; off, ios_base::seekdir dir)
</pre></blockquote>

<p>
and
</p>

<blockquote><pre>seekp(pos_type&amp; pos)

seekp(off_type&amp; off, ios_base::seekdir dir)
</pre></blockquote>

<p>
that is, by reference off and pos arguments.
</p>


<p><b>Proposed resolution:</b></p>
<p>
After 27.6.1.3p42 change:
</p>

<blockquote><pre>basic_istream&lt;charT,traits&gt;&amp; seekg(off_type<del>&amp;</del> <i>off</i>, ios_base::seekdir <i>dir</i>);
</pre></blockquote>

<p>
After 27.6.2.4p1 change:
</p>

<blockquote><pre>basic_ostream&lt;charT,traits&gt;&amp; seekp(pos_type<del>&amp;</del> <i>pos</i>);
</pre></blockquote>

<p>
After 27.6.2.4p3 change:
</p>

<blockquote><pre>basic_ostream&lt;charT,traits&gt;&amp; seekp(off_type<del>&amp;</del> <i>off</i>, ios_base::seekdir <i>dir</i>);
</pre></blockquote>





<hr>
<h3><a name="538"></a>538. 241 again: Does unique_copy() require CopyConstructible and Assignable?</h3>
<p><b>Section:</b> 25.3.9 [alg.unique] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2006-02-09 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.unique">issues</a> in [alg.unique].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I believe I botched the resolution of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#241">
241 "Does unique_copy() require CopyConstructible and Assignable?"</a> which now
has WP status.
</p>

<p>
This talks about <tt>unique_copy</tt> requirements and currently reads:
</p>

<blockquote><p>
-5- <i>Requires:</i> The ranges <tt>[<i>first</i>, <i>last</i>)</tt> and
<tt>[<i>result</i>, <i>result</i>+(<i>last</i>-<i>first</i>))</tt>
shall not overlap. The expression <tt>*<i>result</i> = *<i>first</i></tt> shall
be valid. If neither <tt>InputIterator</tt> nor <tt>OutputIterator</tt> meets the
requirements of forward iterator then the value type of <tt>InputIterator</tt>
must be CopyConstructible (20.1.3). Otherwise CopyConstructible is not required.
</p></blockquote>

<p>
The problem (which Paolo discovered) is that when the iterators are at their
most restrictive (<tt>InputIterator</tt>, <tt>OutputIterator</tt>), then we want
<tt>InputIterator::value_type</tt> to be both <tt>CopyConstructible</tt> and
<tt>CopyAssignable</tt> (for the most efficient implementation).  However this
proposed resolution only makes it clear that it is <tt>CopyConstructible</tt>,
and that one can assign from <tt>*<i>first</i></tt> to <tt>*<i>result</i></tt>.
This latter requirement does not necessarily imply that you can:
</p>

<blockquote><pre>*<i>first</i> = *<i>first</i>;
</pre></blockquote>


<p><b>Proposed resolution:</b></p>
<blockquote><p>
-5- <i>Requires:</i> The ranges <tt>[<i>first</i>, <i>last</i>)</tt> and
<tt>[<i>result</i>, <i>result</i>+(<i>last</i>-<i>first</i>))</tt>
shall not overlap. The expression <tt>*<i>result</i> = *<i>first</i></tt>
shall
be valid. If neither <tt>InputIterator</tt> nor <tt>OutputIterator</tt> meets the
requirements of forward iterator then the <del>value type</del> 
<ins><tt>value_type</tt></ins> of <tt>InputIterator</tt>
must be CopyConstructible (20.1.3) <ins>and Assignable</ins>.
Otherwise CopyConstructible is not required.
</p></blockquote>





<hr>
<h3><a name="539"></a>539. partial_sum and adjacent_difference should mention requirements</h3>
<p><b>Section:</b> 26.7.3 [partial.sum] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Marc Schoolderman <b>Opened:</b> 2006-02-06 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There are some problems in the definition of partial_sum and
adjacent_difference in 26.4 [lib.numeric.ops]
</p>

<p>
Unlike <tt>accumulate</tt> and <tt>inner_product</tt>, these functions are not
parametrized on a "type T", instead, 26.4.3 [lib.partial.sum] simply
specifies the effects clause as;
</p>

<blockquote><p>
Assigns to every element referred to by iterator <tt>i</tt> in the range
<tt>[result,result + (last - first))</tt> a value correspondingly equal to
</p>
<blockquote><pre>((...(* first + *( first + 1)) + ...) + *( first + ( i - result )))
</pre></blockquote>
</blockquote>

<p>
And similarly for BinaryOperation. Using just this definition, it seems
logical to expect that:
</p>


<blockquote><pre>char i_array[4] = { 100, 100, 100, 100 };
int  o_array[4];

std::partial_sum(i_array, i_array+4, o_array);
</pre></blockquote>

<p>
Is equivalent to
</p>

<blockquote><pre>int o_array[4] = { 100, 100+100, 100+100+100, 100+100+100+100 };
</pre></blockquote>

<p>
i.e. 100, 200, 300, 400, with addition happening in the <tt>result type</tt>,
<tt>int</tt>.
</p>

<p>
Yet all implementations I have tested produce 100, -56, 44, -112,
because they are using an accumulator of the <tt>InputIterator</tt>'s
<tt>value_type</tt>, which in this case is <tt>char</tt>, not <tt>int</tt>.
</p>

<p>
The issue becomes more noticeable when the result of the expression <tt>*i +
*(i+1)</tt> or <tt>binary_op(*i, *i-1)</tt> can't be converted to the
<tt>value_type</tt>. In a contrived example:
</p>

<blockquote><pre>enum not_int { x = 1, y = 2 };
...
not_int e_array[4] = { x, x, y, y };
std::partial_sum(e_array, e_array+4, o_array);
</pre></blockquote>

<p>
Is it the intent that the operations happen in the <tt>input type</tt>, or in
the <tt>result type</tt>?
</p>

<p>
If the intent is that operations happen in the <tt>result type</tt>, something
like this should be added to the "Requires" clause of 26.4.3/4
[lib.partial.sum]:
</p>

<blockquote><p>
The type of <tt>*i + *(i+1)</tt> or <tt>binary_op(*i, *(i+1))</tt> shall meet the
requirements of <tt>CopyConstructible</tt> (20.1.3) and <tt>Assignable</tt>
(23.1) types.
</p></blockquote>

<p>
(As also required for <tt>T</tt> in 26.4.1 [lib.accumulate] and 26.4.2
[lib.inner.product].)
</p>

<p>
The "auto initializer" feature proposed in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1894.pdf">N1894</a>
is not required to
implement <tt>partial_sum</tt> this way. The 'narrowing' behaviour can still be
obtained by using the <tt>std::plus&lt;&gt;</tt> function object.
</p>

<p>
If the intent is that operations happen in the <tt>input type</tt>, then
something like this should be added instead;
</p>

<blockquote><p>
The type of *first shall meet the requirements of
<tt>CopyConstructible</tt> (20.1.3) and <tt>Assignable</tt> (23.1) types.
The result of <tt>*i + *(i+1)</tt> or <tt>binary_op(*i, *(i+1))</tt> shall be
convertible to this type.
</p></blockquote>

<p>
The 'widening' behaviour can then be obtained by writing a custom proxy
iterator, which is somewhat involved.
</p>

<p>
In both cases, the semantics should probably be clarified.
</p>

<p>
26.4.4 [lib.adjacent.difference] is similarly underspecified, although
all implementations seem to perform operations in the 'result' type:
</p>

<blockquote><pre>unsigned char i_array[4] = { 4, 3, 2, 1 };
int o_array[4];

std::adjacent_difference(i_array, i_array+4, o_array);
</pre></blockquote>

<p>
o_array is 4, -1, -1, -1 as expected, not 4, 255, 255, 255.
</p>

<p>
In any case, <tt>adjacent_difference</tt> doesn't mention the requirements on the
<tt>value_type</tt>; it can be brought in line with the rest of 26.4
[lib.numeric.ops] by adding the following to 26.4.4/2
[lib.adjacent.difference]:
</p>

<blockquote><p>
The type of <tt>*first</tt> shall meet the requirements of
<tt>CopyConstructible</tt> (20.1.3) and <tt>Assignable</tt> (23.1) types."
</p></blockquote>
<p><i>[
Berlin: Giving output iterator's value_types very controversial. Suggestion of
adding signatures to allow user to specify "accumulator".
]</i></p>


<p><i>[
Bellevue:
]</i></p>


<blockquote>
The intent of the algorithms is to perform their calculations using the type of the input iterator.
Proposed wording provided.
</blockquote>

<p><i>[
Sophia Antipolis:
]</i></p>


<blockquote>
We did not agree that the proposed resolution was correct. For example,
when the arguments are types <tt>(float*, float*, double*)</tt>, the
highest-quality solution would use double as the type of the
accumulator. If the intent of the wording is to require that the type of
the accumulator must be the <tt>input_iterator</tt>'s <tt>value_type</tt>, the wording
should specify it.
</blockquote>

<p><i>[
2009-05-09 Alisdair adds:
]</i></p>


<blockquote>
<p>
Now that we have the facility, the 'best' accumulator type could probably be
deduced as:
</p>
<blockquote><pre>std::common_type&lt;InIter::value_type, OutIter::reference&gt;::type
</pre></blockquote>
<p>
This type would then have additional requirements of constructability and
incrementability/assignability.
</p>
<p>
If this extracting an accumulator type from a pair/set of iterators (with
additional requirements on that type) is a problem for multiple functions,
it might be worth extracting into a SharedAccumulator concept or similar.
</p>
<p>
I'll go no further in writing up wording now, until the group gives a
clearer indication of preferred direction.
</p>
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
The proposed resolution isn't quite right. For example, "the type of
*first" should be changed to "iterator::value_type" or similar. Daniel
volunteered to correct the wording.
</blockquote>

<p><i>[
2009-07-29 Daniel corrected wording.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Move to Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>



<ol>
<li>
<p>
Change 26.7.3 [partial.sum]/1 as indicated:
</p>

<blockquote>
<p>
<i>Effects:</i> <ins>Let <tt>VT</tt> be <tt>InputIterator</tt>'s value type. For a nonempty range,
initializes an accumulator <tt>acc</tt> of type <tt>VT</tt> with <tt>*first</tt> and performs
<tt>*result = acc</tt>. For every iterator <tt>i</tt> in <tt>[first + 1, last)</tt> in order, <tt>acc</tt> is then
modified by <tt>acc = acc + *i</tt> or <tt>acc = binary_op(acc, *i)</tt> and is assigned
to <tt>*(result + (i - first))</tt>.</ins> <del>Assigns to every element referred to by
iterator <tt>i</tt> in the range <tt>[result,result + (last - first))</tt> a value
correspondingly
equal to</del>
</p>

<blockquote><pre><del>
((...(*first + *(first + 1)) + ...) + *(first + (i - result)))
</del></pre></blockquote>

<p><del>
or
</del></p>

<blockquote><pre><del>
binary_op(binary_op(...,
   binary_op(*first, *(first + 1)),...), *(first + (i - result)))
</del></pre></blockquote>
</blockquote>
</li>

<li>
<p>
Change 26.7.3 [partial.sum]/3 as indicated:
</p>

<blockquote>
<i>Complexity:</i> Exactly <tt><ins>max(</ins>(last - first) - 1<ins>, 0)</ins></tt>
applications
of <tt><del>binary_op</del></tt><ins>the binary operation</ins>.
</blockquote>
</li>

<li>
<p>
Change 26.7.3 [partial.sum]/4 as indicated:
</p>

<blockquote>
<i>Requires:</i> <ins><tt>VT</tt> shall be constructible from the type of <tt>*first</tt>, the result of
<tt>acc + *i</tt> or <tt>binary_op(acc, *i)</tt> shall be implicitly convertible to <tt>VT</tt>, and
the result of the expression <tt>acc</tt> shall be writable to the <tt>result</tt>
output iterator.</ins> In the ranges <tt>[first,last]</tt> and
<tt>[result,result + (last - first)]</tt> [..]
</blockquote>
</li>

<li>
<p>
Change 26.7.4 [adjacent.difference]/1 as indicated:
</p>

<blockquote>
<p>
<i>Effects:</i> <ins>Let <tt>VT</tt> be <tt>InputIterator</tt>'s value type. For a nonempty range,
initializes an accumulator <tt>acc</tt> of type <tt>VT</tt> with <tt>*first</tt> and performs
<tt>*result = acc</tt>. For every iterator <tt>i</tt> in <tt>[first + 1, last)</tt> in order,
initializes a
value <tt>val</tt> of type <tt>VT</tt> with <tt>*i</tt>, assigns the result of <tt>val - acc</tt> or
<tt>binary_op(val, acc)</tt>
to <tt>*(result + (i - first))</tt> and modifies <tt>acc = std::move(val)</tt>.</ins>
<del>Assigns to every element referred to by iterator <tt>i</tt> in the range
<tt>[result + 1,
result + (last - first))</tt> a value correspondingly equal to</del>
</p>

<blockquote><pre><del>
*(first + (i - result)) - *(first + (i - result) - 1)
</del></pre></blockquote>

<p><del>
or
</del></p>

<blockquote><pre><del>
binary_op(*(first + (i - result)), *(first + (i - result) - 1)).
</del></pre></blockquote>

<p><del>
result gets the value of *first.</del>
</p>
</blockquote>
</li>

<li>
<p>
Change 26.7.4 [adjacent.difference]/2 as indicated:
</p>

<blockquote>
<i>Requires:</i> <ins><tt>VT</tt> shall be <tt>MoveAssignable</tt> ([moveassignable])
and shall be
constructible from the type of <tt>*first</tt>. The result
of the expression <tt>acc</tt> and the result of the expression <tt>val - acc</tt> or
<tt>binary_op(val, acc)</tt>
shall be writable to the <tt>result</tt> output iterator.</ins> In the ranges
<tt>[first,last]</tt> [..]
</blockquote>
</li>

<li>
<p>
Change 26.7.4 [adjacent.difference]/5 as indicated:
</p>

<blockquote>
<i>Complexity:</i> Exactly <tt><ins>max(</ins>(last - first) - 1<ins>, 0)</ins></tt>
applications
of <del><tt>binary_op</tt></del><ins>the binary operation</ins>.
</blockquote>
</li>
</ol>








<hr>
<h3><a name="540"></a>540. shared_ptr&lt;void&gt;::operator*()</h3>
<p><b>Section:</b> 20.9.10.2.5 [util.smartptr.shared.obs], TR1 2.2.3.5 [tr.util.smartptr.shared.obs] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2005-10-15 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#util.smartptr.shared.obs">issues</a> in [util.smartptr.shared.obs].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I'm trying to reconcile the note in tr.util.smartptr.shared.obs, p6
that talks about the operator*() member function of shared_ptr:
</p>

<blockquote><p>
  Notes: When T is void, attempting to instantiate this member function
  renders the program ill-formed. [Note: Instantiating shared_ptr&lt;void&gt;
  does not necessarily result in instantiating this member function.
  --end note]
</p></blockquote>

<p>
with the requirement in temp.inst, p1:
</p>

<blockquote><p>
  The implicit instantiation of a class template specialization causes
  the implicit instantiation of the declarations, but not of the
  definitions...
</p></blockquote>

<p>
I assume that what the note is really trying to say is that
"instantiating shared_ptr&lt;void&gt; *must not* result in instantiating
this member function." That is, that this function must not be
declared a member of shared_ptr&lt;void&gt;. Is my interpretation
correct?
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change 2.2.3.5p6
</p>

<blockquote><p>
-6- <del><i>Notes:</i></del> When <tt>T</tt> is <tt>void</tt>, <del>attempting to instantiate
this member function renders the program ill-formed. [<i>Note:</i>
Instantiating <tt>shared_ptr&lt;void&gt;</tt> does not necessarily result in
instantiating this member function. <i>--end note</i>]</del> <ins>it is
unspecified whether this member function is declared or not, and if so, what its
return type is, except that the declaration (although not necessarily the
definition) of the function shall be well-formed.</ins>
</p></blockquote>






<hr>
<h3><a name="541"></a>541. shared_ptr template assignment and void</h3>
<p><b>Section:</b> 20.9.10.2 [util.smartptr.shared], TR1 2.2.3 [tr.util.smartptr.shared] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2005-10-16 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#util.smartptr.shared">issues</a> in [util.smartptr.shared].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Is the void specialization of the template assignment operator taking
a shared_ptr&lt;void&gt; as an argument supposed be well-formed?
</p>
<p>
I.e., is this snippet well-formed:
</p>
<blockquote><pre>shared_ptr&lt;void&gt; p;
p.operator=&lt;void&gt;(p);
</pre></blockquote>

<p>
Gcc complains about auto_ptr&lt;void&gt;::operator*() returning a reference
to void. I suspect it's because shared_ptr has two template assignment
operators, one of which takes auto_ptr, and the auto_ptr template gets
implicitly instantiated in the process of overload resolution.
</p>

<p>
The only way I see around it is to do the same trick with auto_ptr&lt;void&gt;
operator*() as with the same operator in shared_ptr&lt;void&gt;.
</p>

<p>
PS Strangely enough, the EDG front end doesn't mind the code, even
though in a small test case (below) I can reproduce the error with
it as well.
</p>

<blockquote><pre>template &lt;class T&gt;
struct A { T&amp; operator*() { return *(T*)0; } };

template &lt;class T&gt;
struct B {
    void operator= (const B&amp;) { }
    template &lt;class U&gt;
    void operator= (const B&lt;U&gt;&amp;) { }
    template &lt;class U&gt;
    void operator= (const A&lt;U&gt;&amp;) { }
};

int main ()
{
    B&lt;void&gt; b;
    b.operator=&lt;void&gt;(b);
}
</pre></blockquote>


<p><b>Proposed resolution:</b></p>
<p>
In [lib.memory] change:
</p>
<blockquote><pre>template&lt;class X&gt; class auto_ptr;
<ins>template&lt;&gt; class auto_ptr&lt;void&gt;;</ins>
</pre></blockquote>

<p>
In [lib.auto.ptr]/2 add the following before the last closing brace:
</p>

<blockquote><pre>template&lt;&gt; class auto_ptr&lt;void&gt;
{
public:
    typedef void element_type;
};
</pre></blockquote>






<hr>
<h3><a name="542"></a>542. shared_ptr observers</h3>
<p><b>Section:</b> 20.9.10.2.5 [util.smartptr.shared.obs], TR1 2.2.3.5 [tr.util.smartptr.shared.obs] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2005-10-18 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#util.smartptr.shared.obs">issues</a> in [util.smartptr.shared.obs].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Peter Dimov wrote:
To: C++ libraries mailing list
Message c++std-lib-15614
[...]
The intent is for both use_count() and unique() to work in a threaded environment.
They are intrinsically prone to race conditions, but they never return garbage.
</p>

<p>
This is a crucial piece of information that I really wish were
captured in the text. Having this in a non-normative note would
have made everything crystal clear to me and probably stopped
me from ever starting this discussion :) Instead, the sentence
in p12 "use only for debugging and testing purposes, not for
production code" very strongly suggests that implementations
can and even are encouraged to return garbage (when threads
are involved) for performance reasons.
</p>
<p>
How about adding an informative note along these lines:
</p>
<blockquote><p>
  Note: Implementations are encouraged to provide well-defined
  behavior for use_count() and unique() even in the presence of
  multiple threads.
</p></blockquote>
<p>
I don't necessarily insist on the exact wording, just that we
capture the intent.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change 20.9.10.2.5 [util.smartptr.shared.obs] p12:
</p>
<blockquote><p>
[<i>Note:</i> <tt>use_count()</tt> is not necessarily efficient. <del>Use only for
debugging and testing purposes, not for production code.</del> --<i>end note</i>]
</p></blockquote>

<p>
Change 20.9.10.3.5 [util.smartptr.weak.obs] p3:
</p>
<blockquote><p>
[<i>Note:</i> <tt>use_count()</tt> is not necessarily efficient. <del>Use only for
debugging and testing purposes, not for production code.</del> --<i>end note</i>]
</p></blockquote>





<hr>
<h3><a name="543"></a>543. valarray slice default constructor</h3>
<p><b>Section:</b> 26.6.4 [class.slice] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2005-11-03 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
If one explicitly constructs a slice or glice with the default
constructor, does the standard require this slice to have any usable
state?  It says "creates a slice which specifies no elements", which
could be interpreted two ways:
</p>
<ol>
<li>There are no elements to which the slice refers (i.e. undefined).</li>
<li>The slice specifies an array with no elements in it (i.e. defined).</li>
</ol>
<p>
Here is a bit of code to illustrate:
</p>
<blockquote><pre>#include &lt;iostream&gt;
#include &lt;valarray&gt;

int main()
{
    std::valarray&lt;int&gt; v(10);
    std::valarray&lt;int&gt; v2 = v[std::slice()];
    std::cout &lt;&lt; "v[slice()].size() = " &lt;&lt; v2.size() &lt;&lt; '\n';
}
</pre></blockquote>

<p>
Is the behavior undefined?  Or should the output be:
</p>

<blockquote><pre>v[slice()].size() = 0
</pre></blockquote>

<p>
There is a similar question and wording for gslice at 26.3.6.1p1.
</p>


<p><b>Proposed resolution:</b></p>

<p><i>[Martin suggests removing the second sentence in 26.6.4.1 [cons.slice] as well.]</i></p>


<p>
Change 26.6.4.1 [cons.slice]:
</p>

<blockquote><p>
1 - <del>The default constructor for <tt>slice</tt> creates a <tt>slice</tt>
which specifies no elements.</del> <ins>The default constructor is equivalent to
<tt>slice(0, 0, 0)</tt>.</ins> A default constructor is provided only to permit
the declaration of arrays of slices. The constructor with arguments for a slice
takes a start, length, and stride parameter.
</p></blockquote>

<p>
Change 26.6.6.1 [gslice.cons]:
</p>

<blockquote><p>
1 - <del>The default constructor creates a <tt>gslice</tt> which specifies no
elements.</del> <ins>The default constructor is equivalent to <tt>gslice(0,
valarray&lt;size_t&gt;(), valarray&lt;size_t&gt;())</tt>.</ins> The constructor
with arguments builds a <tt>gslice</tt> based on a specification of start,
lengths, and strides, as explained in the previous section.
</p></blockquote>






<hr>
<h3><a name="545"></a>545. When is a deleter deleted?</h3>
<p><b>Section:</b> 20.9.10.2.11 [util.smartptr.getdeleter], TR1 2.2.3.2 [tr.util.smartptr.shared.dest] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2006-01-10 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#util.smartptr.getdeleter">issues</a> in [util.smartptr.getdeleter].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The description of ~shared_ptr doesn't say when the shared_ptr's deleter, if
any, is destroyed. In principle there are two possibilities: it is destroyed
unconditionally whenever ~shared_ptr is executed (which, from an implementation
standpoint, means that the deleter is copied whenever the shared_ptr is copied),
or it is destroyed immediately after the owned pointer is destroyed (which, from
an implementation standpoint, means that the deleter object is shared between
instances). We should say which it is.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add after the first sentence of 20.9.10.2.11 [util.smartptr.getdeleter]/1:
</p>
<blockquote>
<p>
The returned pointer remains valid as long as there exists a <tt>shared_ptr</tt> instance
that owns <tt><i>d</i></tt>.
</p>
<p>
[<i>Note:</i> it is unspecified whether the pointer remains valid longer than that.
This can happen if the implementation doesn't destroy the deleter until all
<tt>weak_ptr</tt> instances in the ownership group are destroyed. <i>-- end note</i>]
</p>
</blockquote>





<hr>
<h3><a name="550"></a>550. What should the return type of pow(float,int) be?</h3>
<p><b>Section:</b> 26.8 [c.math] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2006-01-12 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#c.math">issues</a> in [c.math].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Assuming we adopt the
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1836.pdf">C
compatibility package from C99</a>  what should be the return type of the
following signature be:
</p>
<blockquote><pre>?  pow(float, int);
</pre></blockquote>
<p>
C++03 says that the return type should be <tt>float</tt>. 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1836.pdf">
TR1</a> and C90/99 say the return type should be <tt>double</tt>.  This can put
clients into a situation where C++03 provides answers that are not as high
quality as C90/C99/TR1.  For example:
</p>
<blockquote><pre>#include &lt;math.h&gt;

int main()
{
    float x = 2080703.375F;
    double y = pow(x, 2);
}
</pre></blockquote>
<p>
Assuming an IEEE 32 bit float and IEEE 64 bit double, C90/C99/TR1 all suggest:
</p>

<blockquote><pre>y = 4329326534736.390625
</pre></blockquote>

<p>
which is exactly right.  While C++98/C++03 demands:
</p>

<blockquote><pre>y = 4329326510080.
</pre></blockquote>

<p>
which is only approximately right.
</p>

<p>
I recommend that C++0X adopt the mixed mode arithmetic already adopted by
Fortran, C and TR1 and make the return type of <tt>pow(float,int)</tt> be
<tt>double</tt>.
</p>

<p><i>[
Kona (2007): Other functions that are affected by this issue include
<tt>ldexp</tt>, <tt>scalbln</tt>, and <tt>scalbn</tt>. We also believe that there is a typo in
26.7/10: <tt>float nexttoward(float, long double);</tt> [sic] should be <tt>float
nexttoward(float, float);</tt> Proposed Disposition: Review (the proposed
resolution appears above, rather than below, the heading "Proposed
resolution")
]</i></p>


<p><i>[
</i></p><p><i>
Howard, post Kona:
</i></p><i>
<blockquote>
<p>
Unfortunately I strongly disagree with a part of the resolution
from Kona.  I am moving from New to Open instead of to Review because I do not believe
we have consensus on the intent of the resolution.
</p>
<p>
This issue does not include <tt>ldexp</tt>, <tt>scalbln</tt>, and <tt>scalbn</tt> because
the second integral parameter in each of these signatures (from C99) is <b>not</b> a
<i>generic parameter</i> according to C99 7.22p2.  The corresponding C++ overloads are
intended (as far as I know) to correspond directly to C99's definition of <i>generic parameter</i>.
</p>
<p>
For similar reasons, I do not believe that the second <tt>long double</tt> parameter of
<tt>nexttoward</tt>, nor the return type of this function, is in error.  I believe the
correct signature is:
</p>
<blockquote>
<pre>float nexttoward(float, long double);
</pre>
</blockquote>
<p>
which is what both the C++0X working paper and C99 state (as far as I currently understand).
</p>
<p>
This is really <b>only</b> about <tt>pow(float, int)</tt>.  And this is because C++98 took one
route (with <tt>pow</tt> only) and C99 took another (with many math functions in <tt>&lt;tgmath.h&gt;</tt>.
The proposed resolution basically says: C++98 got it wrong and C99 got it right; let's go with C99.
</p>
</blockquote>
]</i><p></p>


<p><i>[
Bellevue:
]</i></p>


<blockquote>
This signature was not picked up from C99. Instead, if one types
pow(2.0f,2), the promotion rules will invoke "double pow(double,
double)", which generally gives special treatment for integral
exponents, preserving full accuracy of the result.  New proposed
wording provided.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 26.8 [c.math] p10:
</p>

<blockquote>
<p>
The added signatures are:
</p>
<blockquote><pre>...
<del>float pow(float, int);</del>
...
<del>double pow(double, int);</del>
...
<del>long double pow(long double, int);</del>
</pre></blockquote>
</blockquote>






<hr>
<h3><a name="551"></a>551. &lt;ccomplex&gt;</h3>
<p><b>Section:</b> X [cmplxh], TR1 8.3 [tr.c99.cmplxh] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2006-01-23 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Previously xxx.h was parsable by C++.  But in the case of C99's &lt;complex.h&gt;
it isn't.  Otherwise we could model it just like &lt;string.h&gt;, &lt;cstring&gt;, &lt;string&gt;:
</p>

<ul>
<li>&lt;string&gt;   : C++ API in namespace std</li>
<li>&lt;cstring&gt;  : C API in namespace std</li>
<li>&lt;string.h&gt; : C API in global namespace</li>
</ul>

<p>
In the case of C's complex, the C API won't compile in C++.  So we have:
</p>

<ul>
<li>&lt;complex&gt;   : C++ API in namespace std</li>
<li>&lt;ccomplex&gt;  : ?</li>
<li>&lt;complex.h&gt; : ?</li>
</ul>

<p>
The ? can't refer to the C API.  TR1 currently says:
</p>

<ul>
<li>&lt;complex&gt;   : C++ API in namespace std</li>
<li>&lt;ccomplex&gt;  : C++ API in namespace std</li>
<li>&lt;complex.h&gt; : C++ API in global namespace</li>
</ul>



<p><b>Proposed resolution:</b></p>
<p>
Change 26.3.11 [cmplxh]:
</p>

<blockquote>
<p>
The header behaves as if it includes the header
<tt>&lt;ccomplex&gt;</tt><ins>.</ins><del>, and provides sufficient using
declarations to declare in the global namespace all function and type names
declared or defined in the neader <tt>&lt;complex&gt;</tt>.</del>
<ins>[<i>Note:</i> <tt>&lt;complex.h&gt;</tt> does not promote any interface
into the global namespace as there is no C interface to promote. <i>--end
note</i>]</ins>
</p>
</blockquote>






<hr>
<h3><a name="552"></a>552. random_shuffle and its generator</h3>
<p><b>Section:</b> 25.3.12 [alg.random.shuffle] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2006-01-25 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.random.shuffle">issues</a> in [alg.random.shuffle].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
...is specified to shuffle its range by calling swap but not how
(or even that) it's supposed to use the RandomNumberGenerator
argument passed to it.
</p>
<p>
Shouldn't we require that the generator object actually be used
by the algorithm to obtain a series of random numbers and specify
how many times its operator() should be invoked by the algorithm?
</p>

<p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2391.pdf">N2391</a> and
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2423.pdf">N2423</a>
for some further discussion.
</p>



<p><b>Proposed resolution:</b></p>
<p>
Adopt the proposed resolution in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2423.pdf">N2423</a>.
</p>


<p><i>[
Kona (2007): The LWG adopted the proposed resolution of N2423 for this issue.
The LWG voted to accelerate this issue to Ready status to be voted into the WP at Kona.
]</i></p>





<hr>
<h3><a name="556"></a>556. is Compare a BinaryPredicate?</h3>
<p><b>Section:</b> 25.4 [alg.sorting] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2006-02-05 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.sorting">issues</a> in [alg.sorting].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 25, p8 we allow BinaryPredicates to return a type that's convertible
to bool but need not actually be bool. That allows predicates to return
things like proxies and requires that implementations be careful about
what kinds of expressions they use the result of the predicate in (e.g.,
the expression in if (!pred(a, b)) need not be well-formed since the
negation operator may be inaccessible or return a type that's not
convertible to bool).
</p>
<p>
Here's the text for reference:
</p>
<blockquote><p>
  ...if an algorithm takes BinaryPredicate binary_pred as its argument
 and first1 and first2 as its iterator arguments, it should work
 correctly in the construct if (binary_pred(*first1, first2)){...}.
</p></blockquote>

<p>
In 25.3, p2 we require that the Compare function object return true
of false, which would seem to preclude such proxies. The relevant text
is here:
</p>
<blockquote><p>
  Compare is used as a function object which returns true if the first
  argument is less than the second, and false otherwise...
</p></blockquote>

<p><i>[
Portland:  Jack to define "convertible to bool" such that short circuiting isn't
destroyed.
]</i></p>


<p><i>[
2009-07-28 Reopened by Alisdair.  No longer solved by concepts.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Move to Review once wording received. Stefanus to send proposed wording.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Move to Review once wording received. Stefanus to send proposed wording.
</blockquote>

<p><i>[
2009-10-24 Stefanus supplied wording.
]</i></p>


<blockquote>
Move to Review once wording received. Stefanus to send proposed wording.
Old proposed wording here:
<blockquote>
<p>
I think we could fix this by rewording 25.3, p2 to read somthing like:
</p>
<blockquote><p>
-2- <tt>Compare</tt> is <del>used as a function object which returns
<tt>true</tt> if the first argument</del> <ins>a <tt>BinaryPredicate</tt>. The
return value of the function call operator applied to an object of type
<tt>Compare</tt>, when converted to type <tt>bool</tt>, yields <tt>true</tt>
if the first argument of the call</ins> is less than the second, and
<tt>false</tt> otherwise. <tt>Compare <i>comp</i></tt> is used throughout for
algorithms assuming an ordering relation. It is assumed that <tt><i>comp</i></tt>
will not apply any non-constant function through the dereferenced iterator.
</p></blockquote>
</blockquote>
</blockquote>

<p><i>[
2010-01-17:
]</i></p>


<blockquote>
<p>
Howard expresses concern that the current direction of the proposed
wording outlaws expressions such as:
</p>

<blockquote><pre>if (!comp(x, y))
</pre></blockquote>

<p>
Daniel provides wording which addresses that concern.
</p>

<p>
The previous wording is saved here:
</p>

<blockquote>

<p>
Change 25.4 [alg.sorting] p2:
</p>
<blockquote>
<tt>Compare</tt> is used as a function object<ins>. The return value of
the function call operator applied to an object of type Compare, when
converted to type bool, yields true if the first argument of the
call</ins> <del>which returns <tt>true</tt> if the first argument</del>
is less than the second, and <tt>false</tt> otherwise. <tt>Compare
comp</tt> is used throughout for algorithms assuming an ordering
relation. It is assumed that <tt>comp</tt> will not apply any
non-constant function through the dereferenced iterator.
</blockquote>

</blockquote>

</blockquote>

<p><i>[
2010-01-22 Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>



<p><b>Proposed resolution:</b></p>

<ol>
<li>
<p>
Change 25.1 [algorithms.general]/7+8 as indicated. <i>[This change is
recommended to bring the return value requirements of <tt>BinaryPredicate</tt>
and <tt>Compare</tt> in sync.]</i>
</p>

<blockquote>
<p>
7 The <tt>Predicate</tt> parameter is used whenever an algorithm expects a
function object that when applied to the result of dereferencing the
corresponding iterator returns a value testable as <tt>true</tt>. In other
words, if an algorithm takes <tt>Predicate pred</tt> as its argument and
<tt>first</tt> as its iterator argument, it should work correctly in the
construct <del>if <tt>(pred(*first)){...}</tt></del> <ins><tt>pred(*first)</tt>
contextually converted to <tt>bool</tt> (4 [conv])</ins>. The
function object <tt>pred</tt> shall not apply any nonconstant function through
the dereferenced iterator. This function object may be a pointer to function, or
an object of a type with an appropriate function call operator.
</p>

<p>
8 The <tt>BinaryPredicate</tt> parameter is used whenever an algorithm expects a
function object that when applied to the result of dereferencing two
corresponding iterators or to dereferencing an iterator and type <tt>T</tt> when
<tt>T</tt> is part of the signature returns a value testable as <tt>true</tt>.
In other words, if an algorithm takes <tt>BinaryPredicate</tt>
<tt>binary_pred</tt> as its argument and <tt>first1</tt> and <tt>first2</tt> as
its iterator arguments, it should work correctly in the construct <del><tt>if
(binary_pred(*first1, *first2)){...}</tt></del> <ins><tt>binary_pred(*first1,
*first2)</tt> contextually converted to <tt>bool</tt> (4 [conv])</ins>. <tt>BinaryPredicate</tt> always takes the first iterator
type as its first argument, that is, in those cases when <tt>T value</tt> is
part of the signature, it should work correctly in the <del>context of <tt>if
(binary_pred(*first1, value)){...}</tt></del> <ins>construct
<tt>binary_pred(*first1, value)</tt> contextually converted to <tt>bool</tt>
(4 [conv])</ins>. <tt>binary_pred</tt> shall not apply any
non-constant function through the dereferenced iterators.
</p>
</blockquote>
</li>

<li>
<p>
Change 25.4 [alg.sorting]/2 as indicated:
</p>

<blockquote>
2 <tt>Compare</tt> is <del>used as</del> a function object <ins>type (20.8 [function.objects]). The return value of the function call operation
applied to an object of type <tt>Compare</tt>, when contextually converted to
type <tt>bool</tt> (4 [conv]), yields <tt>true</tt> if the first
argument of the call</ins><del> which returns <tt>true</tt> if the first
argument</del> is less than the second, and <tt>false</tt> otherwise.
<tt>Compare comp</tt> is used throughout for algorithms assuming an ordering
relation. It is assumed that <tt>comp</tt> will not apply any non-constant
function through the dereferenced iterator.
</blockquote>
</li>

</ol>






<hr>
<h3><a name="559"></a>559. numeric_limits&lt;const T&gt;</h3>
<p><b>Section:</b> 18.3.1 [limits] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2006-02-19 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#limits">issues</a> in [limits].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
        <p>

18.3.1 [limits], p2 requires implementations  to provide specializations of the
<code>numeric_limits</code> template for  each scalar type. While this
could be interepreted to include cv-qualified forms of such types such
an  interepretation   is  not  reflected   in  the  synopsis   of  the
<code>&lt;limits&gt;</code> header.

        </p>
        <p>

The absence  of specializations of the template  on cv-qualified forms
of  fundamental types  makes <code>numeric_limits</code>  difficult to
use in generic  code where the constness (or volatility)  of a type is
not  always  immediately  apparent.  In  such  contexts,  the  primary
template  ends   up  being   instantiated  instead  of   the  provided
specialization, typically yielding unexpected behavior.

        </p>
        <p>

Require   that  specializations   of   <code>numeric_limits</code>  on
cv-qualified fundamental types have the same semantics as those on the
unqualifed forms of the same types.

        </p>


<p><b>Proposed resolution:</b></p>
        <p>

Add  to  the   synopsis  of  the  <code>&lt;limits&gt;</code>  header,
immediately  below  the  declaration  of  the  primary  template,  the
following:
</p>

<pre>
template &lt;class T&gt; class numeric_limits&lt;const T&gt;;
template &lt;class T&gt; class numeric_limits&lt;volatile T&gt;;
template &lt;class T&gt; class numeric_limits&lt;const volatile T&gt;;

</pre>

        <p>

Add  a new paragraph  to the  end of  18.3.1.1 [numeric.limits], with  the following
text:

        </p>
        <p>

-new-para- The  value of each member  of a <code>numeric_limits</code>
specialization on a  cv-qualified T is equal to the  value of the same
member of <code>numeric_limits&lt;T&gt;</code>.

        </p>

<p><i>[
Portland: Martin will clarify that user-defined types get cv-specializations
automatically.
]</i></p>







<hr>
<h3><a name="561"></a>561. inserter overly generic</h3>
<p><b>Section:</b> 24.5.2.6.5 [inserter] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2006-02-21 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The declaration of <tt>std::inserter</tt> is:
</p>

<blockquote><pre>template &lt;class Container, class Iterator&gt;
insert_iterator&lt;Container&gt;
inserter(Container&amp; x, Iterator i);
</pre></blockquote>

<p>
The template parameter <tt>Iterator</tt> in this function is completely unrelated
to the template parameter <tt>Container</tt> when it doesn't need to be.  This
causes the code to be overly generic.  That is, any type at all can be deduced
as <tt>Iterator</tt>, whether or not it makes sense.  Now the same is true of
<tt>Container</tt>.  However, for every free (unconstrained) template parameter
one has in a signature, the opportunity for a mistaken binding grows geometrically.
</p>

<p>
It would be much better if <tt>inserter</tt> had the following signature instead:
</p>

<blockquote><pre>template &lt;class Container&gt;
insert_iterator&lt;Container&gt;
inserter(Container&amp; x, typename Container::iterator i);
</pre></blockquote>

<p>
Now there is only one free template parameter.  And the second argument to
<tt>inserter</tt> must be implicitly convertible to the container's iterator,
else the call will not be a viable overload (allowing other functions in the
overload set to take precedence).  Furthermore, the first parameter must have a
nested type named <tt>iterator</tt>, or again the binding to <tt>std::inserter</tt>
is not viable.  Contrast this with the current situation
where any type can bind to <tt>Container</tt> or <tt>Iterator</tt> and those
types need not be anything closely related to containers or iterators.
</p>

<p>
This can adversely impact well written code.  Consider:
</p>

<blockquote><pre>#include &lt;iterator&gt;
#include &lt;string&gt;

namespace my
{

template &lt;class String&gt;
struct my_type {};

struct my_container
{
template &lt;class String&gt;
void push_back(const my_type&lt;String&gt;&amp;);
};

template &lt;class String&gt;
void inserter(const my_type&lt;String&gt;&amp; m, my_container&amp; c) {c.push_back(m);}

}  // my

int main()
{
    my::my_container c;
    my::my_type&lt;std::string&gt; m;
    inserter(m, c);
}
</pre></blockquote>

<p>
Today this code fails because the call to <tt>inserter</tt> binds to
<tt>std::inserter</tt> instead of to <tt>my::inserter</tt>.  However with the
proposed change <tt>std::inserter</tt> will no longer be a viable function which
leaves only <tt>my::inserter</tt> in the overload resolution set.  Everything
works as the client intends.
</p>

<p>
To make matters a little more insidious, the above example works today if you
simply change the first argument to an rvalue:
</p>

<blockquote><pre>    inserter(my::my_type(), c);
</pre></blockquote>

<p>
It will also work if instantiated with some string type other than
<tt>std::string</tt> (or any other <tt>std</tt> type).  It will also work if
<tt>&lt;iterator&gt;</tt> happens to not get included.
</p>

<p>
And it will fail again for such inocuous reaons as <tt>my_type</tt> or
<tt>my_container</tt> privately deriving from any <tt>std</tt> type.
</p>

<p>
It seems unfortunate that such simple changes in the client's code can result
in such radically differing behavior.
</p>



<p><b>Proposed resolution:</b></p>
<p>
Change 24.2:
</p>

<blockquote><p>
<b>24.2 Header</b> <tt>&lt;iterator&gt;</tt> <b>synopsis</b>
</p>
<blockquote><pre>...
template &lt;class Container<del>, class Iterator</del>&gt;
   insert_iterator&lt;Container&gt; inserter(Container&amp; x, <del>Iterator</del> <ins>typename Container::iterator</ins> i);
...
</pre></blockquote>
</blockquote>

<p>
Change 24.4.2.5:
</p>

<blockquote><p>
<b>24.4.2.5 Class template</b> <tt>insert_iterator</tt></p>
<blockquote><pre>...
template &lt;class Container<del>, class Iterator</del>&gt;
   insert_iterator&lt;Container&gt; inserter(Container&amp; x, <del>Iterator</del> <ins>typename Container::iterator</ins> i);
...
</pre></blockquote>
</blockquote>

<p>
Change 24.4.2.6.5:
</p>

<blockquote>
<p>
<b>24.4.2.6.5</b> <tt>inserter</tt>
</p>
<pre>template &lt;class Container<del>, class Inserter</del>&gt;
   insert_iterator&lt;Container&gt; inserter(Container&amp; x, <del>Inserter</del> <ins>typename Container::iterator</ins> i);
</pre>
<blockquote><p>
-1- <i>Returns:</i> <tt>insert_iterator&lt;Container&gt;(x,<del>typename Container::iterator(</del>i<del>)</del>)</tt>.
</p></blockquote>
</blockquote>



<p><i>[
Kona (2007): This issue will probably be addressed as a part of the concepts overhaul of the library anyway, but the proposed resolution is correct in the absence of concepts. 
Proposed Disposition: Ready
]</i></p>





<hr>
<h3><a name="562"></a>562. stringbuf ctor inefficient</h3>
<p><b>Section:</b> 27.8 [string.streams] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2006-02-23 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#string.streams">issues</a> in [string.streams].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
        <p>

For  better efficiency,  the requirement  on the  stringbuf  ctor that
takes  a  string  argument  should  be  loosened  up  to  let  it  set
<code>epptr()</code>  beyond  just   one  past  the  last  initialized
character  just like  <code>overflow()</code> has  been changed  to be
allowed  to  do   (see  issue  432).  That  way   the  first  call  to
<code>sputc()</code> on  an object won't  necessarily cause a  call to
<code>overflow</code>. The corresponding change  should be made to the
string overload of the <code>str()</code> member function.

        </p>


<p><b>Proposed resolution:</b></p>
        <p>

Change 27.7.1.1, p3 of the Working Draft, N1804, as follows:

        </p>

<blockquote><pre>explicit basic_stringbuf(const basic_string&lt;charT,traits,Allocator&gt;&amp; <i>s<del>tr</del></i>,
               ios_base::openmode <i>which</i> = ios_base::in | ios_base::out);
</pre>

<p>
-3- <i>Effects:</i>  Constructs an object of class <tt>basic_stringbuf</tt>,
initializing the base class with <tt>basic_streambuf()</tt>
(27.5.2.1), and initializing <tt><i>mode</i></tt> with <tt><i>which</i></tt>.
Then <ins>calls <tt>str(<i>s</i>)</tt>.</ins> <del>copies the content of
<i>str</i> into the <tt>basic_stringbuf</tt> underlying character
sequence. If <tt><i>which</i> &amp; ios_base::out</tt> is true, initializes the
output sequence such that <tt>pbase()</tt> points to the first underlying
character, <tt>epptr()</tt> points one past the last underlying character, and
<tt>pptr()</tt> is equal to <tt>epptr()</tt> if <tt><i>which</i> &amp; ios_base::ate</tt>
is true, otherwise <tt>pptr()</tt> is equal to <tt>pbase()</tt>. If
<tt>which &amp; ios_base::in</tt> is true, initializes the input sequence such
that <tt>eback()</tt> and <tt>gptr()</tt> point to the first underlying 
character and <tt>egptr()</tt> points one past the last underlying character.</del>
</p>
</blockquote>

        <p>

Change the Effects clause of the <code>str()</code> in 27.7.1.2, p2 to
read:

        </p>
<blockquote>
<p>
-2- <i>Effects:</i> Copies the content<ins>s</ins> of <tt><i>s</i></tt> into the
<tt>basic_stringbuf</tt> underlying character sequence <ins>and
initializes the input and output sequences according to <tt><i>mode</i></tt></ins>.
<del>If
<tt><i>mode</i> &amp; ios_base::out</tt> is true, initializes the output
sequence such that <tt>pbase()</tt> points to the first underlying character, 
<tt>epptr()</tt> points one past the last underlying character, and <tt>pptr()</tt>
is equal to <tt>epptr()</tt> if <tt><i>mode</i> &amp; ios_base::in</tt>
is true, otherwise <tt>pptr()</tt> is equal to <tt>pbase()</tt>. If
<tt>mode &amp; ios_base::in</tt> is true, initializes the input sequence 
such that <tt>eback()</tt> and <tt>gptr()</tt> point to the first underlying
character and <tt>egptr()</tt> points one past the last underlying character.</del>
</p>

        <p>

<ins>-3- <i>Postconditions:</i>  If  <code>mode  &amp; ios_base::out</code>  is  true,
<code>pbase()</code>  points  to the  first  underlying character  and
<code>(epptr() &gt;= pbase() + s.size())</code> holds; in addition, if
<code>mode &amp; ios_base::in</code> is true, <code>(pptr() == pbase()
+ s.data())</code>  holds, otherwise <code>(pptr()  == pbase())</code>
is   true.    If  <code>mode   &amp;   ios_base::in</code>  is   true,
<code>eback()</code>  points to  the first  underlying  character, and
<code>(gptr()  ==  eback())</code>  and  <code>(egptr() ==  eback()  +
s.size())</code> hold.</ins>

        </p>
</blockquote>


<p><i>[
Kona (2007) Moved to Ready.
]</i></p>





<hr>
<h3><a name="563"></a>563. stringbuf seeking from end</h3>
<p><b>Section:</b> 27.8.1.4 [stringbuf.virtuals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2006-02-23 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#stringbuf.virtuals">issues</a> in [stringbuf.virtuals].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
According to  Table 92  (unchanged by issue  432), when  <code>(way ==
end)</code> the  <code>newoff</code> value in out mode  is computed as
the difference between <code>epptr()</code> and <code>pbase()</code>.
</p>
        <p>

This value  isn't meaningful unless the  value of <code>epptr()</code>
can be  precisely controlled by a  program.  That used  to be possible
until  we accepted the  resolution of  issue 432,  but since  then the
requirements on <code>overflow()</code> have  been relaxed to allow it
to  make  more than  1  write  position  available (i.e.,  by  setting
<code>epptr()</code>     to     some     unspecified    value     past
<code>pptr()</code>).      So    after     the    first     call    to
<code>overflow()</code>  positioning the  output sequence  relative to
end will have unspecified results.

        </p>
        <p>

In  addition,  in <code>in|out</code>  mode,  since <code>(egptr()  ==
epptr())</code> need not hold, there are two different possible values
for   <code>newoff</code>:    <code>epptr()   -   pbase()</code>   and
<code>egptr() - eback()</code>.

        </p>


<p><b>Proposed resolution:</b></p>
        <p>

Change the <code>newoff</code>  column in the last row  of Table 94 to
read:

        </p>
<blockquote><p>

the <del>end</del> <ins>high mark</ins> pointer minus the beginning 
pointer (<code><del>xend</del> <ins>high_mark</ins> - xbeg</code>).

</p></blockquote>


<p><i>[
Kona (2007) Moved to Ready.
]</i></p>





<hr>
<h3><a name="564"></a>564. stringbuf seekpos underspecified</h3>
<p><b>Section:</b> 27.8.1.4 [stringbuf.virtuals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2006-02-23 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#stringbuf.virtuals">issues</a> in [stringbuf.virtuals].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The   effects  of  the   <code>seekpos()</code>  member   function  of
<code>basic_stringbuf</code>  simply say  that the  function positions
the  input and/or  output  sequences  but fail  to  spell out  exactly
how. This is in contrast  to the detail in which <code>seekoff()</code>
is described.
</p>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
Move to Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>
        <p>

Change 27.7.1.3, p13 to read:

        </p>
<blockquote>
<p>
-13- <i>Effects:</i> <ins>Equivalent to <tt>seekoff(off_type(<i>sp</i>), ios_base::beg,
<i>which</i>)</tt>.</ins> <del>Alters the stream position within the controlled sequences,
if possible, to correspond to the stream position stored in <tt><i>sp</i></tt>
(as described below).</del>
</p>
<ul>
<li><del>If <tt>(<i>which</i> &amp; ios_base::in) != 0</tt>, positions the input sequence.</del></li>
<li><del>If <tt>(<i>which</i> &amp; ios_base::out) != 0</tt>, positions the output sequence.</del></li>
<li><del>If <tt><i>sp</i></tt> is an invalid stream position, or if the function
positions neither sequence, the positioning operation fails. If <tt><i>sp</i></tt>
has not been obtained by a previous successful call to one of the positioning
functions (<tt>seekoff</tt>, <tt>seekpos</tt>, <tt>tellg</tt>, <tt>tellp</tt>)
the effect is undefined.</del></li>
</ul>
</blockquote>


<p><i>[
Kona (2007): A <tt>pos_type</tt> is a position in a stream by
definition, so there is no ambiguity as to what it means. Proposed
Disposition: NAD
]</i></p>


<p><i>[
Post-Kona Martin adds:
I'm afraid I disagree
with the Kona '07 rationale for marking it NAD. The only text
that describes precisely what it means to position the input
or output sequence is in <tt>seekoff()</tt>. The <tt>seekpos()</tt> Effects
clause is inadequate in comparison and the proposed resolution
plugs the hole by specifying <tt>seekpos()</tt> in terms of <tt>seekoff()</tt>.
]</i></p>





<hr>
<h3><a name="565"></a>565. xsputn inefficient</h3>
<p><b>Section:</b> 27.6.2.4.5 [streambuf.virt.put] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2006-02-23 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
        <p>

<tt>streambuf::xsputn()</tt>  is  specified  to  have  the  effect  of
"writing up to  <tt>n</tt> characters to the output  sequence as if by
repeated calls to <tt>sputc(c)</tt>."

        </p>
        <p>

Since  <tt>sputc()</tt> is required  to call  <tt>overflow()</tt> when
<tt>(pptr()    ==   epptr())</tt>    is   true,    strictly   speaking
<tt>xsputn()</tt>  should do  the same.   However, doing  so  would be
suboptimal in  some interesting cases,  such as in unbuffered  mode or
when the buffer is <tt>basic_stringbuf</tt>.

        </p>
        <p>

Assuming  calling <tt>overflow()</tt>  is  not really  intended to  be
required  and the  wording is  simply  meant to  describe the  general
effect of appending to the end  of the sequence it would be worthwhile
to  mention in  <tt>xsputn()</tt> that  the function  is  not actually
required to cause a call to <tt>overflow()</tt>.

        </p>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
Move to Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>
        <p>

Add the following sentence  to the <tt>xsputn()</tt> Effects clause in
27.5.2.4.5, p1 (N1804):

        </p>
        <blockquote>    
            <p>
-1- <i>Effects:</i> Writes up to <tt><i>n</i></tt> characters to the output
sequence as if by repeated calls to <tt>sputc(<i>c</i>)</tt>. The characters 
written are obtained from successive elements of the array whose first element
is designated by <tt><i>s</i></tt>. Writing stops when either <tt><i>n</i></tt>
characters have been written or a call to <tt>sputc(<i>c</i>)</tt> would return
<tt>traits::eof()</tt>. <ins>It is  uspecified whether the function  calls
<tt>overflow()</tt> when <tt>(pptr() ==  epptr())</tt> becomes true or whether
it achieves the same effects by other means.</ins>
            </p>
        </blockquote>    
        <p>

In addition,  I suggest to  add a footnote  to this function  with the
same text as Footnote 292 to  make it extra clear that derived classes
are permitted to override <tt>xsputn()</tt> for efficiency.

        </p>


<p><i>[
Kona (2007): We want to permit a <tt>streambuf</tt> that streams output directly
to a device without making calls to <tt>sputc</tt> or <tt>overflow</tt>. We believe that
has always been the intention of the committee. We believe that the
proposed wording doesn't accomplish that. Proposed Disposition: Open
]</i></p>





<hr>
<h3><a name="566"></a>566. array forms of unformatted input function undefined for zero-element arrays</h3>
<p><b>Section:</b> 27.7.1.3 [istream.unformatted] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2006-02-23 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#istream.unformatted">issues</a> in [istream.unformatted].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
        <p>

The array forms of unformatted input functions don't have well-defined
semantics for zero-element  arrays in a couple of  cases. The affected
ones (<tt>istream::get()</tt> and  <tt>getline()</tt>) are supposed to
terminate when <tt>(n - 1)</tt> characters are stored, which obviously
can never be true when <tt>(n == 0)</tt> to start with.

        </p>


<p><b>Proposed resolution:</b></p>
        <p>

I  propose  the following  changes  (references  are  relative to  the
Working Draft (document N1804).

        </p>
        <p>

Change 27.6.1.3, p8 (<tt>istream::get()</tt>), bullet 1 as follows:

        </p>
        <blockquote>
            <p>

<ins>if  <tt>(n  &lt; 1)</tt>  is  true  or  </ins> <tt>(n  -  1)</tt>
characters are stored;

            </p>
        </blockquote>
        <p>

Similarly, change  27.6.1.3, p18 (<tt>istream::getline()</tt>), bullet
3 as follows:

        </p>
        <blockquote>
            <p>

<ins><tt>(n &lt; 1)</tt> is  true or </ins><tt>(n - 1)</tt> characters
are     stored     (in    which     case     the    function     calls
<tt>setstate(failbit)</tt>).

            </p>
        </blockquote>
        <p>

Finally, change p21 as follows:

        </p>
        <blockquote>
            <p>

In any  case, <ins>provided  <tt>(n &gt; 0)</tt>  is true,  </ins>it then
stores  a null  character  (using charT())  into  the next  successive
location of the array.

            </p>
        </blockquote>





<hr>
<h3><a name="567"></a>567. streambuf inserter and extractor should be unformatted</h3>
<p><b>Section:</b> 27.7 [iostream.format] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2006-02-25 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#iostream.format">issues</a> in [iostream.format].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
        <p>

Issue  60 explicitly made  the extractor  and inserter  operators that
take a  <tt>basic_streambuf*</tt> argument formatted  input and output
functions,  respectively.  I  believe that's  wrong, certainly  in the
case of  the extractor, since formatted functions  begin by extracting
and  discarding  whitespace.  The  extractor  should  not discard  any
characters.

        </p>


<p><b>Proposed resolution:</b></p>
        <p>

I propose to  change each operator to behave  as unformatted input and
output function,  respectively. The changes below are  relative to the
working draft document number N1804.

        </p>
        <p>

Specifically, change 27.6.1.2.3, p14 as follows:

        </p>

            <blockquote>
        <p>

<i>Effects</i>:  Behaves as  a<ins>n un</ins>formatted  input function
(as   described   in   <del>27.6.1.2.1</del><ins>27.6.1.3,   paragraph
1</ins>).

        </p>
            </blockquote>
        <p>

And change 27.6.2.5.3, p7 as follows:

        </p>

            <blockquote>
        <p>

<i>Effects</i>: Behaves  as a<ins>n un</ins>formatted  output function
(as   described   in   <del>27.6.2.5.1</del><ins>27.6.2.6,   paragraph
1</ins>).

        </p>
            </blockquote>


<p><i>[
Kona (2007): Proposed Disposition: Ready
]</i></p>





<hr>
<h3><a name="574"></a>574. DR 369 Contradicts Text</h3>
<p><b>Section:</b> 27.4 [iostream.objects] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2006-04-18 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#iostream.objects">issues</a> in [iostream.objects].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
lib.iostream.objects requires that the standard stream objects are never
destroyed, and it requires that they be destroyed.
</p>
<p>
DR 369 adds words to say that we really mean for ios_base::Init objects to force
construction of standard stream objects. It ends, though, with the phrase "these
stream objects shall be destroyed after the destruction of dynamically ...".
However, the rule for destruction is stated in the standard: "The objects are
not destroyed during program execution."
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change 27.4 [iostream.objects]/1:
</p>

<blockquote>
<p>
-2- The objects are constructed and the associations are established at
some time prior to or during the first time an object of class
<tt>ios_base::Init</tt> is constructed, and in any case before the body of main
begins execution.<sup>290)</sup> The objects are not destroyed during program
execution.<sup>291)</sup> If a translation unit includes <tt>&lt;iostream&amp;t;</tt> or explicitly
constructs an <tt>ios_base::Init</tt> object, these stream objects shall be
constructed before dynamic initialization of non-local objects defined
later in that translation unit<del>, and these stream objects shall be
destroyed after the destruction of dynamically initialized non-local
objects defined later in that translation unit</del>.
</p>
</blockquote>


<p><i>[
Kona (2007): From 27.4 [iostream.objects]/2, strike the words "...and these stream objects
shall be destroyed after the destruction of dynamically initialized
non-local objects defined later in that translation unit." Proposed
Disposition: Review
]</i></p>





<hr>
<h3><a name="575"></a>575. the specification of ~shared_ptr is MT-unfriendly, makes implementation assumptions</h3>
<p><b>Section:</b> 20.9.10.2.2 [util.smartptr.shared.dest], TR1 2.2.3.2 [tr.util.smartptr.shared.dest] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Peter Dimov <b>Opened:</b> 2006-04-23 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#util.smartptr.shared.dest">issues</a> in [util.smartptr.shared.dest].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
[tr.util.smartptr.shared.dest] says in its second bullet:
</p>

<p>
"If *this shares ownership with another shared_ptr instance (use_count() &gt; 1),
decrements that instance's use count."
</p>

<p>
The problem with this formulation is that it presupposes the existence of an
"use count" variable that can be decremented and that is part of the state of a
shared_ptr instance (because of the "that instance's use count".)
</p>

<p>
This is contrary to the spirit of the rest of the specification that carefully
avoids to require an use count variable. Instead, use_count() is specified to
return a value, a number of instances.
</p>

<p>
In multithreaded code, the usual implicit assumption is that a shared variable
should not be accessed by more than one thread without explicit synchronization,
and by introducing the concept of an "use count" variable, the current wording
implies that two shared_ptr instances that share ownership cannot be destroyed
simultaneously.
</p>

<p>
In addition, if we allow the interpretation that an use count variable is part
of shared_ptr's state, this would lead to other undesirable consequences WRT
multiple threads. For example,
</p>

<blockquote><pre>p1 = p2;
</pre></blockquote>

<p>
would now visibly modify the state of p2, a "write" operation, requiring a lock.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change the first two bullets of [lib.util.smartptr.shared.dest]/1 to:
</p>

<blockquote>
<ul>
<li>If <tt>*this</tt> is <i>empty</i> <ins>or shares ownership with another
<tt>shared_ptr</tt> instance (<tt>use_count() &gt; 1</tt>)</ins>, there are no side effects.</li>
<li><del>If <tt>*this</tt> <i>shares ownership</i> with another <tt>shared_ptr</tt> instance
(<tt>use_count() &gt; 1</tt>), decrements that instance's use count.</del></li>
</ul>
</blockquote>

<p>
Add the following paragraph after [lib.util.smartptr.shared.dest]/1:
</p>

<blockquote><p>
[<i>Note:</i> since the destruction of <tt>*this</tt> decreases the number of instances in
<tt>*this</tt>'s ownership group by one, all <tt>shared_ptr</tt> instances that share ownership
with <tt>*this</tt> will report an <tt>use_count()</tt> that is one lower than its previous value
after <tt>*this</tt> is destroyed. <i>--end note</i>]
</p></blockquote>





<hr>
<h3><a name="576"></a>576. find_first_of is overconstrained</h3>
<p><b>Section:</b> 25.2.7 [alg.find.first.of] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Doug Gregor <b>Opened:</b> 2006-04-25 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.find.first.of">issues</a> in [alg.find.first.of].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 25.1.4 Find First [lib.alg.find.first], the two iterator type parameters to
find_first_of are specified to require Forward Iterators, as follows:
</p>

<blockquote><pre>template&lt;class ForwardIterator1, class ForwardIterator2&gt;
  ForwardIterator1
  find_first_of(ForwardIterator1 first1, ForwardIterator1 last1,
                        ForwardIterator2 first2, ForwardIterator2 last2);
template&lt;class ForwardIterator1, class ForwardIterator2,
                  class BinaryPredicate&gt;
ForwardIterator1
  find_first_of(ForwardIterator1 first1, ForwardIterator1 last1,
                         ForwardIterator2 first2, ForwardIterator2 last2,
                        BinaryPredicate pred);
</pre></blockquote>

<p>
However, ForwardIterator1 need not actually be a Forward Iterator; an Input
Iterator suffices, because we do not need the multi-pass property of the Forward
Iterator or a true reference.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change the declarations of <tt>find_first_of</tt> to:
</p>

<blockquote><pre>template&lt;class <del>ForwardIterator1</del><ins>InputIterator1</ins>, class ForwardIterator2&gt;
  <del>ForwardIterator1</del><ins>InputIterator1</ins>
  find_first_of(<del>ForwardIterator1</del><ins>InputIterator1</ins> first1, <del>ForwardIterator1</del><ins>InputIterator1</ins> last1,
                        ForwardIterator2 first2, ForwardIterator2 last2);
template&lt;class <del>ForwardIterator1</del><ins>InputIterator1</ins>, class ForwardIterator2,
                  class BinaryPredicate&gt;
<del>ForwardIterator1</del><ins>InputIterator1</ins>
  find_first_of(<del>ForwardIterator1</del><ins>InputIterator1</ins> first1, <del>ForwardIterator1</del><ins>InputIterator1</ins> last1,
                         ForwardIterator2 first2, ForwardIterator2 last2,
                        BinaryPredicate pred);
</pre></blockquote>






<hr>
<h3><a name="577"></a>577. upper_bound(first, last, ...) cannot return last</h3>
<p><b>Section:</b> 25.4.3.2 [upper.bound] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Seungbeom Kim <b>Opened:</b> 2006-05-03 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
ISO/IEC 14882:2003 says:
</p>

<blockquote>
<p>
25.3.3.2 upper_bound
</p>
<p>
<i>Returns:</i> The furthermost iterator <tt>i</tt> in the range
<tt>[<i>first</i>, <i>last</i>)</tt> such that
for any iterator <tt>j</tt> in the range <tt>[<i>first</i>, i)</tt> the following corresponding
conditions hold: <tt>!(value &lt; *j)</tt> or <tt><i>comp</i>(<i>value</i>, *j) == false</tt>.
</p>
</blockquote>

<p>
From the description above, upper_bound cannot return last, since it's
not in the interval [first, last). This seems to be a typo, because if
value is greater than or equal to any other values in the range, or if
the range is empty, returning last seems to be the intended behaviour.
The corresponding interval for lower_bound is also [first, last].
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change [lib.upper.bound]:
</p>

<blockquote>
<p>
<i>Returns:</i> The furthermost iterator <tt>i</tt> in the range
<tt>[<i>first</i>, <i>last</i><del>)</del><ins>]</ins></tt> such that
for any iterator <tt>j</tt> in the range <tt>[<i>first</i>, i)</tt> the following corresponding
conditions hold: <tt>!(value &lt; *j)</tt> or <tt><i>comp</i>(<i>value</i>, *j) == false</tt>.
</p>
</blockquote>






<hr>
<h3><a name="578"></a>578. purpose of hint to allocator::allocate()</h3>
<p><b>Section:</b> 20.9.5.1 [allocator.members] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2006-05-17 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#allocator.members">issues</a> in [allocator.members].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
        <p>

The     description    of     the     allocator    member     function
<code>allocate()</code>  requires  that  the <i>hint</i>  argument  be
either 0 or a  value previously returned from <code>allocate()</code>.
Footnote 227 further suggests that  containers may pass the address of
an adjacent element as this argument.

        </p>
        <p>

I  believe  that  either  the  footnote  is  wrong  or  the  normative
requirement that  the argument be  a value previously returned  from a
call to  <code>allocate()</code> is wrong. The latter  is supported by
the resolution  to issue 20-004 proposed in  c++std-lib-3736 by Nathan
Myers. In addition,  the <i>hint</i> is an ordinary  void* and not the
<code>pointer</code>  type returned  by  <code>allocate()</code>, with
the  two  types potentially  being  incompatible  and the  requirement
impossible to satisfy.

        </p>
        <p>

See also c++std-lib-14323 for some  more context on where this came up
(again).

        </p>
    

    <p><b>Proposed resolution:</b></p>
        <p>

Remove  the requirement  in  20.6.1.1, p4  that  the hint  be a  value
previously returned from <code>allocate()</code>. Specifically, change
the paragraph as follows:

        </p>
<p>
<del><i>Requires</i>: <i>hint</i> either 0 or previously obtained  from  member
<code>allocate</code>  and  not  yet passed  to member  <code>deallocate</code>.
The value hint may be used by an implementation to help improve performance
<sup>223)</sup>.</del> <ins>[<i>Note:</i> The value <i>hint</i> may be used by an
implementation to help improve performance. -- <i>end note</i>]</ins>
</p>
<blockquote><p>
<del>[Footnote: <sup>223)</sup>In a container member function, the address of an
adjacent element is often a good choice to pass for this argument.</del>
</p></blockquote>
    



<hr>
<h3><a name="581"></a>581. <code>flush()</code> not unformatted function</h3>
<p><b>Section:</b> 27.7.2.7 [ostream.unformatted] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2006-06-14 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#ostream.unformatted">issues</a> in [ostream.unformatted].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
        <p>

The resolution of issue 60 changed <code>basic_ostream::flush()</code>
so as not  to require it to behave as  an unformatted output function.
That has at least two in my opinion problematic consequences:

        </p>
        <p>

First, <code>flush()</code>  now calls <code>rdbuf()-&gt;pubsync()</code>
unconditionally, without  regard to the  state of the stream.  I can't
think of any reason why <code>flush()</code> should behave differently
from the vast majority of stream functions in this respect.

        </p>
        <p>

Second, <code>flush()</code> is not  required to catch exceptions from
<code>pubsync()</code> or set  <code>badbit</code> in response to such
events. That doesn't seem right either, as most other stream functions
do so.

        </p>
    

    <p><b>Proposed resolution:</b></p>
        <p>

I  propose  to revert  the  resolution of  issue  60  with respect  to
<code>flush()</code>. Specifically,  I propose to  change 27.6.2.6, p7
as follows:

        </p>

<p>
Effects: <ins>Behaves as an  unformatted output function (as described
in 27.6.2.6, paragraph 1). </ins>If <code>rdbuf()</code> is not a null
pointer,  <ins>constructs a  sentry  object.  If  this object  returns
<code>true</code> when converted to a  value of type bool the function
</ins>calls <code>rdbuf()-&gt;pubsync()</code>.  If that function returns
-1    calls    <code>setstate(badbit)</code>    (which    may    throw
<code>ios_base::failure</code>  (27.4.4.3)).   <ins>Otherwise, if  the
sentry object returns <code>false</code>, does nothing.</ins><del>Does
not  behave  as  an  unformatted  output  function  (as  described  in
27.6.2.6, paragraph 1).</del>
</p>

    

<p><i>[
Kona (2007): Proposed Disposition: Ready
]</i></p>





<hr>
<h3><a name="586"></a>586. string inserter not a formatted function</h3>
<p><b>Section:</b> 21.4.8.9 [string.io] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2006-06-22 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#string.io">issues</a> in [string.io].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
        <p>

Section  and paragraph  numbers  in  this paper  are  relative to  the
working draft document number N2009 from 4/21/2006.

        </p>

        <p>

The  <code>basic_string</code> extractor  in 21.3.7.9,  p1  is clearly
required  to  behave  as  a   formatted  input  function,  as  is  the
<code>std::getline()</code> overload for string described in p7.

        </p>
        <p>

However, the <code>basic_string</code> inserter described in p5 of the
same section has no such requirement. This has implications on how the
operator  responds  to  exceptions thrown  from  <code>xsputn()</code>
(formatted  output functions are  required to  set <code>badbit</code>
and swallow  the exception unless  <code>badbit</code> is also  set in
<code>exceptions()</code>; the  string inserter doesn't  have any such
requirement).

        </p>
        <p>

I don't  see anything in the  spec for the string  inserter that would
justify requiring  it to treat  exceptions differently from  all other
similar operators. (If it did, I think it should be made this explicit
by saying  that the  operator "does not  behave as a  formatted output
function" as has been made customary by the adoption of the resolution
of issue 60).

        </p>
    

    <p><b>Proposed resolution:</b></p>
        <p>

I propose to change the Effects clause in 21.3.7.9, p5, as follows:

        </p>
            <blockquote>
        <p>

<i>Effects</i>: <del>Begins by constructing a  sentry object k as if k
were    constructed    by    typename    <code>basic_ostream&lt;charT,
traits&gt;::sentry   k   (os)</code>.    If  <code>bool(k)</code>   is
<code>true</code>, </del><ins>Behaves  as a formatted  output function
(27.6.2.5.1).   After constructing  a  <code>sentry</code> object,  if
this  object returns <code>true</code>  when converted  to a  value of
type   <code>bool</code>,   determines   padding   as   described   in
22.2.2.2.2</ins>,  then inserts the  resulting sequence  of characters
<code><i>seq</i></code> as if by calling <code>os.rdbuf()-&gt;sputn(seq ,
n)</code>,    where   <code><i>n</i></code>    is   the    larger   of
<code>os.width()</code>   and   <code>str.size()</code>;  then   calls
<code>os.width(0)</code>.  <del>If  the  call  to sputn  fails,  calls
<code>os.setstate(ios_base::failbit)</code>.</del>

        </p>
            </blockquote>
        <p>

This proposed  resilution assumes the  resolution of issue  394 (i.e.,
that   all   formatted   output   functions  are   required   to   set
<code>ios_base::badbit</code>  in response  to any  kind  of streambuf
failure),   and   implicitly   assumes   that  a   return   value   of
<code>sputn(seq,  <i>n</i>)</code>  other  than  <code><i>n</i></code>
indicates a failure.

        </p>
    



<hr>
<h3><a name="589"></a>589. Requirements on iterators of member template functions of containers</h3>
<p><b>Section:</b> 23.2 [container.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Peter Dimov <b>Opened:</b> 2006-08-02 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#container.requirements">issues</a> in [container.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#536">536</a></p>
<p><b>Discussion:</b></p>
<p>
There appears to be no requirements on the InputIterators used in sequences in 23.1.1 in
terms of their value_type, and the requirements in 23.1.2 appear to be overly strict
(requires InputIterator::value_type be the same type as the container's value_type).
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change 23.1.1 p3:
</p>

<blockquote><p>
In Tables 82 and 83, <tt>X</tt> denotes a sequence class, <tt>a</tt> denotes a
value of <tt>X</tt>, <tt>i</tt> and <tt>j</tt> denote iterators satisfying input
iterator requirements <ins>and refer to elements <ins>implicitly
convertible to</ins> <tt>value_type</tt></ins>, <tt>[i, j)</tt> denotes a valid
range, <tt>n</tt> denotes a value of <tt>X::size_type</tt>, <tt>p</tt> denotes a
valid iterator to <tt>a</tt>, <tt>q</tt> denotes a valid dereferenceable
iterator to <tt>a</tt>, <tt>[q1, q2)</tt> denotes a valid range in <tt>a</tt>,
and <tt>t</tt> denotes a value of <tt>X::value_type</tt>.
</p></blockquote>

<p>
Change 23.1.2 p7:
</p>

<blockquote><p>
In Table 84, <tt>X</tt> is an associative container class, <tt>a</tt> is a value
of <tt>X</tt>, <tt>a_uniq</tt> is a value of <tt>X</tt> when <tt>X</tt> supports
unique keys, and <tt>a_eq</tt> is a value of <tt>X</tt> when <tt>X</tt> supports
multiple keys, <tt>i</tt> and <tt>j</tt> satisfy input iterator requirements and
refer to elements <del>of</del> <ins>implicitly convertible to</ins>
<tt>value_type</tt>, <tt>[i, j)</tt> is a valid range, <tt>p</tt> is a valid
iterator to <tt>a</tt>, <tt>q</tt> is a valid dereferenceable iterator to
<tt>a</tt>, <tt>[q1, q2)</tt> is a valid range in <tt>a</tt>, <tt>t</tt> is a
value of <tt>X::value_type</tt>, <tt>k</tt> is a value of <tt>X::key_type</tt>
and <tt>c</tt> is a value of type <tt>X::key_compare</tt>.
</p></blockquote>



<p><b>Rationale:</b></p>
<p>
Concepts will probably come in and rewrite this section anyway.  But just in case it is
easy to fix this up as a safety net and as a clear statement of intent.
</p>





<hr>
<h3><a name="593"></a>593. __STDC_CONSTANT_MACROS</h3>
<p><b>Section:</b> 18.4 [cstdint], TR1 8.22 [tr.c99.cstdint] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Walter Brown <b>Opened:</b> 2006-08-28 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#cstdint">issues</a> in [cstdint].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Clause 18.3 of the current Working Paper (N2009) deals with the new C++ headers
&lt;cstdint&gt; and &lt;stdint.h&gt;.  These are of course based on the C99 header
&lt;stdint.h&gt;, and were part of TR1.
</p>

<p>
Per 18.3.1/1, these headers define a number of macros and function macros. 
While the WP does not mention __STDC_CONSTANT_MACROS in this context, C99
footnotes do mention __STDC_CONSTANT_MACROS.  Further, 18.3.1/2 states that "The
header defines all ... macros the same as C99 subclause 7.18."
</p>

<p>
Therefore, if I wish to have the above-referenced macros and function macros
defined, must I #define __STDC_CONSTANT_MACROS before I #include &lt;cstdint&gt;, or
does the C++ header define these macros/function macros unconditionally?
</p>


<p><b>Proposed resolution:</b></p>
<p>
To put this issue to rest for C++0X, I propose the following addition to 
18.3.1/2 of the Working Paper N2009:
</p>

<blockquote><p>
[Note: The macros defined by &lt;cstdint&gt; are provided unconditionally: in
particular, the symbols __STDC_LIMIT_MACROS and __STDC_CONSTANT_MACROS
(mentioned in C99 footnotes 219, 220, and 222) play no role in C++. --end note]
</p></blockquote>





<hr>
<h3><a name="594"></a>594. Disadvantages of defining Swappable in terms of CopyConstructible and Assignable</h3>
<p><b>Section:</b> 20.2.1 [utility.arg.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> Niels Dekker <b>Opened:</b> 2006-11-02 <b>Last modified:</b> 2010-11-19</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#utility.arg.requirements">issues</a> in [utility.arg.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>

<p>
It seems undesirable to define the Swappable requirement in terms of
CopyConstructible and Assignable requirements. And likewise, once the
MoveConstructible and MoveAssignable requirements (N1860) have made it
into the Working Draft, it seems undesirable to define the Swappable
requirement in terms of those requirements. Instead, it appears
preferable to have the Swappable requirement defined exclusively in
terms of the existence of an appropriate swap function.
</p>

<p>
Section 20.1.4 [lib.swappable] of the current Working Draft (N2009)
says:
</p>

<blockquote><p>
The Swappable requirement is met by satisfying one or more of the
following conditions:</p>
<ul>
<li>
T is Swappable if T satisfies the CopyConstructible requirements
(20.1.3) and the Assignable requirements (23.1);
</li>
<li>
T is Swappable if a namespace scope function named swap exists in the
same namespace as the definition of T, such that the expression
swap(t,u) is valid and has the semantics described in Table 33.
</li>
</ul>
</blockquote>

<p>
I can think of three disadvantages of this definition:
</p>

<ol>
<li>
<p>
If a client's type T satisfies the first condition (T is both
CopyConstructible and Assignable), the client cannot stop T from
satisfying the Swappable requirement without stopping T from
satisfying the first condition.
</p>
<p>
A client might want to stop T from satisfying the Swappable
requirement, because swapping by means of copy construction and
assignment might throw an exception, and she might find a throwing
swap unacceptable for her type. On the other hand, she might not feel
the need to fully implement her own swap function for this type. In
this case she would want to be able to simply prevent algorithms that
would swap objects of type T from being used, e.g., by declaring a
swap function for T, and leaving this function purposely undefined.
This would trigger a link error, if an attempt would be made to use
such an algorithm for this type. For most standard library
implementations, this practice would indeed have the effect of
stopping T from satisfying the Swappable requirement.
</p>
</li>
<li>
<p>
A client's type T that does not satisfy the first condition can not be
made Swappable by providing a specialization of std::swap for T.
</p>
<p>
While I'm aware about the fact that people have mixed feelings about
providing a specialization of std::swap, it is well-defined to do so.
It sounds rather counter-intuitive to say that T is not Swappable, if
it has a valid and semantically correct specialization of std::swap.
Also in practice, providing such a specialization will have the same
effect as satisfying the Swappable requirement.
</p>
</li>
<li>
<p>
For a client's type T that satisfies both conditions of the Swappable
requirement, it is not specified which of the two conditions prevails.
After reading section 20.1.4 [lib.swappable], one might wonder whether
objects of T will be swapped by doing copy construction and
assignments, or by calling the swap function of T.
</p>
<p>
I'm aware that the intention of the Draft is to prefer calling the
swap function of T over doing copy construction and assignments. Still
in my opinion, it would be better to make this clear in the wording of
the definition of Swappable. 
</p>
</li>
</ol>

<p>
I would like to have the Swappable requirement defined in such a way
that the following code fragment will correctly swap two objects of a
type T, if and only if T is Swappable:
</p>

<pre>   using std::swap;
   swap(t, u);  // t and u are of type T.
</pre>

<p>
This is also the way Scott Meyers recommends calling a swap function,
in Effective C++, Third Edition, item 25.
</p>

<p>
Most aspects of this issue have been dealt with in a discussion on
comp.std.c++ about the Swappable requirement, from 13 September to 4
October 2006, including valuable input by David Abrahams, Pete Becker,
Greg Herlihy, Howard Hinnant and others.
</p>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
Recommend NAD.  Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2774.pdf">N2774</a>.
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
Moved to Open.  Waiting for non-concepts draft.
</blockquote>

<p><i>[
2009-11-08 Howard adds:
]</i></p>


<blockquote>
This issue is very closely related to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#742">742</a>.
</blockquote>

<p><i>[
2010-02-03 Sean Hunt adds:
]</i></p>


<blockquote>
<p>
While reading N3000, I independently came across Issue 594. Having seen that
it's an issue under discussion, I think the proposed wording needs fixing to
something more like "...function call swap(t,u) that includes std::swap in its
overload set is valid...", because "...is valid within the namespace std..."
does not allow other libraries to simply use the Swappable requirement by
referring to the standard's definition, since they cannot actually perform any
calls within std.
</p>

<p>
This wording I suggested would also make overloads visible in the same scope as
the `using std::swap` valid for Swappable requirements; a more complex wording
limiting the non-ADL overload set to std::swap might be required.
</p>
</blockquote>

<p><i>[
2010 Pittsburgh:
]</i></p>


<blockquote>
Moved to NAD Editorial.  Rationale added.
</blockquote>



<p><b>Rationale:</b></p>
<p>
Solved by N3048.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change section 20.1.4 [lib.swappable] as follows:
</p>
<blockquote><p>
The Swappable requirement is met by satisfying
<del>one or more of the following conditions:</del>
<ins>the following condition:</ins></p>
<ul>

<li>
<del>T is Swappable if T satisfies the CopyConstructible requirements
(20.1.3) and the Assignable requirements (23.1);</del>
</li>
<li>
<del>
T is Swappable if a namespace scope function named swap exists in the
same namespace as the definition of T, such that the expression
swap(t,u) is valid and has the semantics described in Table 33.
</del>
T is Swappable if an unqualified function call swap(t,u) is valid
within the namespace std, and has the semantics described in Table 33.
</li>
</ul>
</blockquote>





<hr>
<h3><a name="595"></a>595. TR1/C++0x: fabs(complex&lt;T&gt;) redundant / wrongly specified</h3>
<p><b>Section:</b> 26.4.7 [complex.value.ops] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Stefan Groe Pawig <b>Opened:</b> 2006-09-24 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#complex.value.ops">issues</a> in [complex.value.ops].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
TR1 introduced, in the C compatibility chapter, the function
fabs(complex&lt;T&gt;):
</p>
<blockquote><pre>----- SNIP -----
8.1.1 Synopsis                                [tr.c99.cmplx.syn]

  namespace std {
  namespace tr1 {
[...]
  template&lt;class T&gt; complex&lt;T&gt; fabs(const complex&lt;T&gt;&amp; x);
  } // namespace tr1
  } // namespace std

[...]

8.1.8 Function fabs                          [tr.c99.cmplx.fabs]

1 Effects: Behaves the same as C99 function cabs, defined in
  subclause 7.3.8.1.
----- SNIP -----
</pre></blockquote>

<p>
The current C++0X draft document (n2009.pdf) adopted this
definition in chapter 26.3.1 (under the comment // 26.3.7 values)
and 26.3.7/7.
</p>
<p>
But in C99 (ISO/IEC 9899:1999 as well as the 9899:TC2 draft document
n1124), the referenced subclause reads
</p>

<blockquote><pre>----- SNIP -----
7.3.8.1 The cabs functions

  Synopsis

1 #include &lt;complex.h&gt;
  double cabs(double complex z);
  float cabsf(float complex z);
  long double cabsl(long double z);

  Description

2 The cabs functions compute the complex absolute value (also called
  norm, modulus, or magnitude) of z.

  Returns

3 The cabs functions return the complex absolute value.
----- SNIP -----
</pre></blockquote>

<p>
Note that the return type of the cabs*() functions is not a complex
type.  Thus, they are equivalent to the already well established
  template&lt;class T&gt; T abs(const complex&lt;T&gt;&amp; x);
(26.2.7/2 in ISO/IEC 14882:1998, 26.3.7/2 in the current draft
document n2009.pdf).
</p>
<p>
So either the return value of fabs() is specified wrongly, or fabs()
does not behave the same as C99's cabs*().
</p>

<b>Possible Resolutions</b>

<p>
This depends on the intention behind the introduction of fabs().
</p>
<p>
If the intention was to provide a /complex/ valued function that
calculates the magnitude of its argument, this should be
explicitly specified.  In TR1, the categorization under "C
compatibility" is definitely wrong, since C99 does not provide
such a complex valued function.
</p>
<p>
Also, it remains questionable if such a complex valued function
is really needed, since complex&lt;T&gt; supports construction and
assignment from real valued arguments.  There is no difference
in observable behaviour between
</p>
<blockquote><pre>  complex&lt;double&gt; x, y;
  y = fabs(x);
  complex&lt;double&gt; z(fabs(x));
</pre></blockquote>
<p>
and
</p>
<blockquote><pre>  complex&lt;double&gt; x, y;
  y = abs(x);
  complex&lt;double&gt; z(abs(x));
</pre></blockquote>
<p>
If on the other hand the intention was to provide the intended
functionality of C99, fabs() should be either declared deprecated
or (for C++0X) removed from the standard, since the functionality
is already provided by the corresponding overloads of abs().
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
Bill believes that abs() is a suitable overload. We should remove fabs().
</blockquote>


<p><b>Proposed resolution:</b></p>

<p>
Change the synopsis in 26.4.1 [complex.syn]:
</p>

<blockquote><pre><del>template&lt;class T&gt; complex&lt;T&gt; fabs(const complex&lt;T&gt;&amp;);</del>
</pre></blockquote>

<p>
Remove 26.4.7 [complex.value.ops], p7:
</p>

<blockquote>
<pre><del>template&lt;class T&gt; complex&lt;T&gt; fabs(const complex&lt;T&gt;&amp; <i>x</i>);</del>
</pre>
<blockquote>
<p>
<del>-7- <i>Effects:</i> Behaves the same as C99 function <tt>cabs</tt>, defined in subclause 7.3.8.1.</del>
</p>
</blockquote>
</blockquote>



<p><i>[
Kona (2007): Change the return type of <tt>fabs(complex)</tt> to <tt>T</tt>. 
Proposed Disposition: Ready
]</i></p>





<hr>
<h3><a name="596"></a>596. 27.8.1.3 Table 112 omits "a+" and "a+b" modes</h3>
<p><b>Section:</b> 27.9.1.4 [filebuf.members] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Thomas Plum <b>Opened:</b> 2006-09-26 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#filebuf.members">issues</a> in [filebuf.members].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In testing 27.9.1.4 [filebuf.members], Table 112 (in the latest N2009 draft), we invoke  
</p>
<blockquote><pre>   ostr.open("somename", ios_base::out | ios_base::in | ios_base::app)
</pre></blockquote>
<p>
and we expect the open to fail, because out|in|app is not listed in
Table 92, and just before the table we see very specific words:
</p>
<blockquote><p>
  If mode is not some combination of flags shown in the table 
  then the open fails.
</p></blockquote>
<p>
But the corresponding table in the C standard, 7.19.5.3, provides two
modes "a+" and "a+b", to which the C++ modes out|in|app and
out|in|app|binary would presumably apply.
</p>
<p>
We would like to argue that the intent of Table 112 was to match the
semantics of 7.19.5.3 and that the omission of "a+" and "a+b" was
unintentional.  (Otherwise there would be valid and useful behaviors
available in C file I/O which are unavailable using C++, for no
valid functional reason.)
</p>
<p>
We further request that the missing modes be explicitly restored to
the WP, for inclusion in C++0x.
</p>

<p><i>[
Martin adds:
]</i></p>


<p>
...besides "a+" and "a+b" the C++ table is also missing a row
for a lone app bit which in at least two current implementation
as well as in Classic Iostreams corresponds to the C stdio "a"
mode and has been traditionally documented as implying ios::out.
Which means the table should also have a row for in|app meaning
the same thing as "a+" already proposed in the issue.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add to the table "File open modes" in 27.9.1.4 [filebuf.members]:
</p>

<blockquote>
<table border="1">
<caption> File open modes</caption>
<tbody><tr>
<th colspan="5"><tt>ios_base</tt> Flag combination</th>
<th><tt>stdio</tt> equivalent</th>
</tr>
<tr>
<th><tt>binary</tt></th><th><tt>in</tt></th><th><tt>out</tt></th><th><tt>trunc</tt></th><th><tt>app</tt></th><th><tt>&nbsp;</tt></th>
</tr>

<tr>
<td>&nbsp;</td> <td>&nbsp;</td> <td><tt>+</tt></td> <td>&nbsp;</td> <td>&nbsp;</td> <td><tt>"w"</tt></td>
</tr>
<tr>
<td>&nbsp;</td> <td>&nbsp;</td> <td><tt>+</tt></td> <td>&nbsp;</td> <td><tt>+</tt></td> <td><tt>"a"</tt></td>
</tr>
<tr>
<td>&nbsp;</td> <td>&nbsp;</td> <td>&nbsp;</td> <td>&nbsp;</td> <td><ins><tt>+</tt></ins></td> <td><ins><tt>"a"</tt></ins></td>
</tr>
<tr>
<td>&nbsp;</td> <td>&nbsp;</td> <td><tt>+</tt></td> <td><tt>+</tt></td> <td>&nbsp;</td> <td><tt>"w"</tt></td>
</tr>
<tr>
<td>&nbsp;</td> <td><tt>+</tt></td> <td>&nbsp;</td> <td>&nbsp;</td> <td>&nbsp;</td> <td><tt>"r"</tt></td>
</tr>
<tr>
<td>&nbsp;</td> <td><tt>+</tt></td> <td><tt>+</tt></td> <td>&nbsp;</td> <td>&nbsp;</td> <td><tt>"r+"</tt></td>
</tr>
<tr>
<td>&nbsp;</td> <td><tt>+</tt></td> <td><tt>+</tt></td> <td><tt>+</tt></td> <td>&nbsp;</td> <td><tt>"w+"</tt></td>
</tr>
<tr>
<td>&nbsp;</td> <td><ins><tt>+</tt></ins></td> <td><ins><tt>+</tt></ins></td> <td>&nbsp;</td> <td><ins><tt>+</tt></ins></td> <td><ins><tt>"a+"</tt></ins></td>
</tr>
<tr>
<td>&nbsp;</td> <td><ins><tt>+</tt></ins></td> <td>&nbsp;</td> <td>&nbsp;</td> <td><ins><tt>+</tt></ins></td> <td><ins><tt>"a+"</tt></ins></td>
</tr>

<tr>
<td><tt>+</tt></td> <td>&nbsp;</td> <td><tt>+</tt></td> <td>&nbsp;</td> <td>&nbsp;</td> <td><tt>"wb"</tt></td>
</tr>
<tr>
<td><tt>+</tt></td> <td>&nbsp;</td> <td><tt>+</tt></td> <td>&nbsp;</td> <td><tt>+</tt></td> <td><tt>"ab"</tt></td>
</tr>
<tr>
<td><ins><tt>+</tt></ins></td> <td>&nbsp;</td> <td>&nbsp;</td> <td>&nbsp;</td> <td><ins><tt>+</tt></ins></td> <td><ins><tt>"ab"</tt></ins></td>
</tr>
<tr>
<td><tt>+</tt></td> <td>&nbsp;</td> <td><tt>+</tt></td> <td><tt>+</tt></td> <td>&nbsp;</td> <td><tt>"wb"</tt></td>
</tr>
<tr>
<td><tt>+</tt></td> <td><tt>+</tt></td> <td>&nbsp;</td> <td>&nbsp;</td> <td>&nbsp;</td> <td><tt>"rb"</tt></td>
</tr>
<tr>
<td><tt>+</tt></td> <td><tt>+</tt></td> <td><tt>+</tt></td> <td>&nbsp;</td> <td>&nbsp;</td> <td><tt>"r+b"</tt></td>
</tr>
<tr>
<td><tt>+</tt></td> <td><tt>+</tt></td> <td><tt>+</tt></td> <td><tt>+</tt></td> <td>&nbsp;</td> <td><tt>"w+b"</tt></td>
</tr><tr>
<td><ins><tt>+</tt></ins></td> <td><ins><tt>+</tt></ins></td> <td><ins><tt>+</tt></ins></td> <td>&nbsp;</td> <td><ins><tt>+</tt></ins></td> <td><ins><tt>"a+b"</tt></ins></td>
</tr>
<tr>
<td><ins><tt>+</tt></ins></td> <td><ins><tt>+</tt></ins></td> <td>&nbsp;</td> <td>&nbsp;</td> <td><ins><tt>+</tt></ins></td> <td><ins><tt>"a+b"</tt></ins></td>
</tr>


</tbody></table>
</blockquote>



<p><i>[
Kona (2007) Added proposed wording and moved to Review.
]</i></p>





<hr>
<h3><a name="598"></a>598. Decimal: Conversion to integral should truncate, not round.</h3>
<p><b>Section:</b> TRDecimal 3.2 [trdec.types.types] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TRDec">TRDec</a>
 <b>Submitter:</b> Daniel Krugler <b>Opened:</b> 2006-05-28 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#trdec.types.types">issues</a> in [trdec.types.types].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TRDec">TRDec</a> status.</p>
<p><b>Discussion:</b></p>

<p>
In a private email, Daniel writes:
</p>
<blockquote>
<p>
I would like to 
ask, what where the reason for the decision to 
define the semantics of the integral conversion of the decimal types, namely
</p>
<pre>"operator long long() const;

     Returns: Returns the result of the 
conversion of *this to the type long long, as if 
performed by the expression llrounddXX(*this)."
</pre>
<p>
where XX stands for either 32, 64, or 128, 
corresponding to the proper decimal type. The 
exact meaning of llrounddXX is not given in that 
paper, so I compared it to the corresponding 
definition given in C99, 2nd edition (ISO 9899), which says in 7.12.9.7 p. 2:
</p>
<p>
"The lround and llround functions round their 
argument to the nearest integer value,
rounding halfway cases away from zero, regardless 
of the current rounding direction. [..]"
</p>
<p>
Now considering the fact that integral conversion 
of the usual floating-point types ("4.9 
Floating-integral conversions") has truncation 
semantic I wonder why this conversion behaviour 
has not been transferred for the decimal types. 
</p>
</blockquote>
<p>
Robert comments:
</p>
<p>
Also, there is a further error in the <b>Returns:</b> clause for converting <code>decimal::decimal128</code> to <code>long long</code>.  It currently calls <code>llroundd64</code>, not <code>llroundd128</code>.
</p>



<p><b>Proposed resolution:</b></p>
<p>
Change the <b>Returns:</b> clause in 3.2.2.4 to:
</p>
<blockquote><p>
<b>Returns:</b> Returns the result of the conversion of <code>*this</code> to the type <code>long long</code>, as if performed by the expression <code>llroundd32(*this)</code> <ins>while the decimal rounding direction mode [3.5.2] <code>FE_DEC_TOWARD_ZERO</code> is in effect</ins>.
</p></blockquote>
<p>
Change the <b>Returns:</b> clause in 3.2.3.4 to:
</p>
<blockquote><p>
<b>Returns:</b> Returns the result of the conversion of <code>*this</code> to the type <code>long long</code>, as if performed by the expression <code>llroundd64(*this)</code> <ins>while the decimal rounding direction mode [3.5.2] <code>FE_DEC_TOWARD_ZERO</code> is in effect</ins>.
</p></blockquote>
<p>
Change the <b>Returns:</b> clause in 3.2.4.4 to:
</p>
<blockquote><p>
<b>Returns:</b> Returns the result of the conversion of <code>*this</code> to the type <code>long long</code>, as if performed by the expression <del><code>llroundd64(*this)</code></del> <ins><code>llroundd128(*this)</code> while the decimal rounding direction mode [3.5.2] <code>FE_DEC_TOWARD_ZERO</code> is in effect</ins>.
</p></blockquote>






<hr>
<h3><a name="599"></a>599. Decimal: Say "octets" instead of "bytes."</h3>
<p><b>Section:</b> TRDecimal 3.1 [trdec.types.encodings] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TRDec">TRDec</a>
 <b>Submitter:</b> Daniel Krugler <b>Opened:</b> 2006-05-28 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TRDec">TRDec</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Daniel writes in a private email:
</p>

<blockquote>
<p>
- 3.1 'Decimal type encodings' says in its note:
</p>
<pre>"this implies that 
sizeof(std::decimal::decimal32) == 4, 
sizeof(std::decimal::decimal64) == 8, and 
sizeof(std::decimal::decimal128) == 16."
</pre>
<p>
This is a wrong assertion, because the definition 
of 'byte' in 1.7 'The C+ + memory model' of ISO 
14882 (2nd edition) does not specify that a byte 
must be necessarily 8 bits large, which would be 
necessary to compare with the specified bit sizes 
of the types decimal32, decimal64, and decimal128.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 3.1 as follows:
</p>
<blockquote>
<p>
The three decimal encoding formats defined in IEEE-754R correspond to the three decimal floating types as follows:
</p>
<ul>
<li>
decimal32 is a <em>decimal32</em> number, which is encoded in four consecutive <del>bytes</del> <ins>octets</ins> (32 bits)
</li>
<li>
decimal64 is a <em>decimal64</em> number, which is encoded in eight consecutive <del>bytes</del> <ins>octets</ins> (64 bits)

</li>
<li>
decimal128 is a <em>decimal128</em> number, which is encoded in 16 consecutive <del>bytes</del> <ins>octets</ins> (128 bits)
</li>
</ul>
<p>
<del>[<i>Note:</i> this implies that <code>sizeof(std::decimal::decimal32) == 4</code>, <code>sizeof(std::decimal::decimal64) == 8</code>, and <code>sizeof(std::decimal::decimal128) == 16</code>.  <i>--end note</i>]</del>
</p>
</blockquote>




<hr>
<h3><a name="600"></a>600. Decimal: Wrong parameters for wcstod* functions</h3>
<p><b>Section:</b> TRDecimal 3.9 [trdec.types.cwchar] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TRDec">TRDec</a>
 <b>Submitter:</b> Daniel Krugler <b>Opened:</b> 2006-05-28 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TRDec">TRDec</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Daniel writes:
</p>
<blockquote><p>
- 3.9.1 'Additions to &lt;cwchar&gt;' provides wrong 
signatures to the wcstod32, wcstod64, and 
wcstod128 functions ([the parameters have type pointer-to-] char instead of wchar_t).
</p></blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change "3.9.1 Additions to <code>&lt;cwchar&gt;</code> synopsis" to:
</p>
<pre>       namespace std {
       namespace decimal {
         // 3.9.2 wcstod functions:
         decimal32  wcstod32  (const <del>char</del> <ins>wchar_t</ins> * nptr, <del>char</del> <ins>wchar_t</ins> ** endptr);
         decimal64  wcstod64  (const <del>char</del> <ins>wchar_t</ins> * nptr, <del>char</del> <ins>wchar_t</ins> ** endptr);
         decimal128 wcstod128 (const <del>char</del> <ins>wchar_t</ins> * nptr, <del>char</del> <ins>wchar_t</ins> ** endptr);
       }
       }
</pre>




<hr>
<h3><a name="601"></a>601. Decimal: numeric_limits typos</h3>
<p><b>Section:</b> TRDecimal 3.3 [trdec.types.limits] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TRDec">TRDec</a>
 <b>Submitter:</b> Daniel Krugler <b>Opened:</b> 2006-05-28 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TRDec">TRDec</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Daniel writes in a private email:
</p>

<blockquote>
<p>
- 3.3 'Additions to header &lt;limits&gt;' contains two 
errors in the specialisation of numeric_limits&lt;decimal::decimal128&gt;:
</p>
<ol>
<li>The static member max() returns DEC128_MIN, this should be DEC128_MAX.</li>
<li>The static member digits is assigned to 384,
this should be 34 (Probably mixed up with the
max. exponent for decimal::decimal64).</li>
</ol>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
In "3.3 Additions to header <code>&lt;limits&gt;</code>" change numeric_limits&lt;decimal::decimal128&gt; as follows:
</p>
<pre>        template&lt;&gt; class numeric_limits&lt;decimal::decimal128&gt; {
          public:
            static const bool is_specialized = true;

            static decimal::decimal128 min() throw() { return DEC128_MIN; }
            static decimal::decimal128 max() throw() { return <del>DEC128_MIN;</del> <ins>DEC128_MAX;</ins> }

            static const int digits       = <del>384</del> <ins>34</ins>;
            /* ... */
</pre>




<hr>
<h3><a name="602"></a>602. Decimal: "generic floating type" not defined.</h3>
<p><b>Section:</b> TRDecimal 3 [trdec.types] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TRDec">TRDec</a>
 <b>Submitter:</b> Daniel Krugler <b>Opened:</b> 2006-05-28 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#trdec.types">issues</a> in [trdec.types].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TRDec">TRDec</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The document uses the term "generic floating types," but defines it nowhere.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change the first paragraph of "3 Decimal floating-point types" as follows:
</p>
<blockquote><p>
This Technical Report introduces three decimal floating-point types, named
decimal32, decimal64, and decimal128. The set of values of type decimal32 is a
subset of the set of values of type decimal64; the set of values of the type
decimal64 is a subset of the set of values of the type decimal128. Support for
decimal128 is optional.  <ins>These types supplement the Standard C++ types
<code>float</code>, <code>double</code>, and <code>long double</code>, which are
collectively described as the <i>basic floating types</i></ins>.
</p></blockquote>




<hr>
<h3><a name="603"></a>603. Decimal: Trivially simplifying decimal classes.</h3>
<p><b>Section:</b> TRDecimal 3 [trdec.types] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TRDec">TRDec</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2006-05-28 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#trdec.types">issues</a> in [trdec.types].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TRDec">TRDec</a> status.</p>
<p><b>Discussion:</b></p>
<p>In c++std-lib-17198, Martin writes:</p>

<blockquote><p>
Each of the three classes proposed in the paper (decimal32, decimal64,
and decimal128) explicitly declares and specifies the semantics of its
copy constructor, copy assignment operator, and destructor. Since the
semantics of all three functions are identical to the trivial versions
implicitly generated by the compiler in the absence of any declarations
it is safe to drop them from the spec. This change would make the
proposed classes consistent with other similar classes already in the
standard (e.g., std::complex).
</p></blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change "3.2.2 Class <code>decimal32</code>" as follows:
</p>
<pre>      namespace std {
      namespace decimal {
        class decimal32 {
          public:
            // 3.2.2.1 construct/copy/destroy:
            decimal32();
            <del>decimal32(const decimal32 &amp; d32);</del>
            <del>decimal32 &amp; operator=(const decimal32 &amp; d32);</del>
            <del>~decimal32();</del>
            /* ... */
</pre>
<p>
Change "3.2.2.1 construct/copy/destroy" as follows:
</p>
<pre>        decimal32();

    Effects: Constructs an object of type decimal32 with the value 0;

        <del>decimal32(const decimal32 &amp; d32);</del>
        <del>decimal32 &amp; operator=(const decimal32 &amp; d32);</del>

    <del>Effects: Copies an object of type decimal32.</del>

        <del>~decimal32();</del>

    <del>Effects: Destroys an object of type decimal32.</del>

</pre>
<p>
Change "3.2.3 Class <code>decimal64</code>" as follows:
</p>
<pre>      namespace std {
      namespace decimal {
        class decimal64 {
          public:
            // 3.2.3.1 construct/copy/destroy:
            decimal64();
            <del>decimal64(const decimal64 &amp; d64);</del>
            <del>decimal64 &amp; operator=(const decimal64 &amp; d64);</del>
            <del>~decimal64();</del>
            /* ... */
</pre>
<p>
Change "3.2.3.1 construct/copy/destroy" as follows:
</p>
<pre>        decimal64();

    Effects: Constructs an object of type decimal64 with the value 0;

        <del>decimal64(const decimal64 &amp; d64);</del>
        <del>decimal64 &amp; operator=(const decimal64 &amp; d64);</del>

    <del>Effects: Copies an object of type decimal64.</del>

        <del>~decimal64();</del>

    <del>Effects: Destroys an object of type decimal64.</del>

</pre>
<p>
Change "3.2.4 Class <code>decimal128</code>" as follows:
</p>
<pre>      namespace std {
      namespace decimal {
        class decimal128 {
          public:
            // 3.2.4.1 construct/copy/destroy:
            decimal128();
            <del>decimal128(const decimal128 &amp; d128);</del>
            <del>decimal128 &amp; operator=(const decimal128 &amp; d128);</del>
            <del>~decimal128();</del>
            /* ... */
</pre>
<p>
Change "3.2.4.1 construct/copy/destroy" as follows:
</p>
<pre>        decimal128();

    Effects: Constructs an object of type decimal128 with the value 0;

        <del>decimal128(const decimal128 &amp; d128);</del>
        <del>decimal128 &amp; operator=(const decimal128 &amp; d128);</del>

    <del>Effects: Copies an object of type decimal128.</del>

        <del>~decimal128();</del>

    <del>Effects: Destroys an object of type decimal128.</del>

</pre>




<hr>
<h3><a name="604"></a>604. Decimal: Storing a reference to a facet unsafe.</h3>
<p><b>Section:</b> TRDecimal 3 [trdec.types] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TRDec">TRDec</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2006-05-28 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#trdec.types">issues</a> in [trdec.types].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TRDec">TRDec</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In c++std-lib-17197, Martin writes:
</p>
<blockquote><p>
The extended_num_get and extended_num_put facets are designed
to store a reference to a num_get or num_put facet which the
extended facets delegate the parsing and formatting of types
other than decimal. One form of the extended facet's ctor (the
default ctor and the size_t overload) obtains the reference
from the global C++ locale while the other form takes this
reference as an argument.
</p></blockquote>
<blockquote><p>
The problem with storing a reference to a facet in another
object (as opposed to storing the locale object in which the
facet is installed) is that doing so bypasses the reference
counting mechanism designed to prevent a facet that is still
being referenced (i.e., one that is still installed in some
locale) from being destroyed when another locale that contains
it is destroyed. Separating a facet reference from the locale
it comes from van make it cumbersome (and in some cases might
even make it impossible) for programs to prevent invalidating
the reference. (The danger of this design is highlighted in
the paper.)
</p></blockquote>
<blockquote><p>
This problem could be easily avoided by having the extended
facets store a copy of the locale from which they would extract
the base facet either at construction time or when needed. To
make it possible, the forms of ctors of the extended facets that
take a reference to the base facet would need to be changed to
take a locale argument instead.
</p></blockquote>


<p><b>Proposed resolution:</b></p>
<p>
1. Change the <code>extended_num_get</code> synopsis in 3.10.2 as follows:
</p>
<pre>            extended_num_get(const <del>std::num_get&lt;charT, InputIterator&gt;</del> <ins>std::locale</ins> &amp; <i>b</i>, size_t <i>refs</i> = 0);

            /* ... */

            <del>// <i>const std::num_get&lt;charT, InputIterator&gt; &amp; <b>base</b></i>;        <i><b>exposition only</b></i></del>
            <ins>// <i>std::locale <b>baseloc</b></i>;                                    <i><b>exposition only</b></i></ins>
</pre>
<p>
2. Change the description of the above constructor in 3.10.2.1:
</p>
<pre>            extended_num_get(const <del>std::num_get&lt;charT, InputIterator&gt;</del> <ins>std::locale</ins> &amp; <i>b</i>, size_t <i>refs</i> = 0);

</pre>
<blockquote>
<p>
<b>Effects:</b> Constructs an <code>extended_num_get</code> facet as if by:
</p>
<pre>       extended_num_get(const <del>std::num_get&lt;charT, InputIterator&gt;</del> <ins>std::locale</ins> &amp; <i>b</i>, size_t <i>refs</i> = 0)
                : facet(<i>refs</i>), <i>base<ins>loc</ins></i>(<i>b</i>)
                { /* ... */ }

</pre>
<p>
<del><b>Notes:</b> Care must be taken by the implementation to ensure that the lifetime of the facet referenced by <i>base</i> exceeds that of the resulting <code>extended_num_get</code> facet.</del>
</p>
</blockquote>
<p>
3. Change the <b>Returns:</b> clause for <code>do_get(iter_type, iter_type, ios_base &amp;, ios_base::iostate &amp;, bool &amp;) const</code>, <i>et al</i> to
</p>
<blockquote><p>
<b>Returns:</b> <code><del><i>base</i></del> <ins>std::use_facet&lt;std::num_get&lt;charT, InputIterator&gt; &gt;(<i>baseloc</i>)</ins>.get(<i>in</i>, <i>end</i>, <i>str</i>, <i>err</i>, <i>val</i>)</code>. 
</p></blockquote>
<p>
4. Change the <code>extended_num_put</code> synopsis in 3.10.3 as follows:
</p>
<pre>            extended_num_put(const <del>std::num_put&lt;charT, OutputIterator&gt;</del> <ins>std::locale</ins> &amp; <i>b</i>, size_t <i>refs</i> = 0);

            /* ... */

            <del>// <i>const std::num_put&lt;charT, OutputIterator&gt; &amp; <b>base</b></i>;       <i><b>exposition only</b></i></del>
            <ins>// <i>std::locale <b>baseloc</b></i>;                                    <i><b>exposition only</b></i></ins>
</pre>
<p>
5. Change the description of the above constructor in 3.10.3.1:
</p>
<pre>            extended_num_put(const <del>std::num_put&lt;charT, OutputIterator&gt;</del> <ins>std::locale</ins> &amp; <i>b</i>, size_t <i>refs</i> = 0);
</pre>
<blockquote>
<p>
<b>Effects:</b> Constructs an <code>extended_num_put</code> facet as if by:
</p>
<pre>       extended_num_put(const <del>std::num_put&lt;charT, OutputIterator&gt;</del> <ins>std::locale</ins> &amp; <i>b</i>, size_t <i>refs</i> = 0)
                : facet(<i>refs</i>), <i>base<ins>loc</ins></i>(<i>b</i>)
                { /* ... */ }

</pre>
<p>
<del><b>Notes:</b> Care must be taken by the implementation to ensure that the lifetime of the facet referenced by <i>base</i> exceeds that of the resulting <code>extended_num_put</code> facet.</del>
</p>
</blockquote>
<p>
6. Change the <b>Returns:</b> clause for <code>do_put(iter_type, ios_base &amp;, char_type, bool &amp;) const</code>, <i>et al</i> to
</p>
<blockquote><p>
<b>Returns:</b> <code><del><i>base</i></del> <ins>std::use_facet&lt;std::num_put&lt;charT, OutputIterator&gt; &gt;(<i>baseloc</i>)</ins>.put(<i>s</i>, <i>f</i>, <i>fill</i>, <i>val</i>)</code>. 
</p></blockquote>

<p><i>[
Redmond:  We would prefer to rename "extended" to "decimal".
]</i></p>






<hr>
<h3><a name="605"></a>605. Decimal: &lt;decfloat.h&gt; doesn't live here anymore.</h3>
<p><b>Section:</b> TRDecimal 3.4 [trdec.types.cdecfloat] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TRDec">TRDec</a>
 <b>Submitter:</b> Robert Klarer <b>Opened:</b> 2006-10-17 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#TRDec">TRDec</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In Berlin, WG14 decided to drop the &lt;decfloat.h&gt; header.  The contents of that header have been moved into &lt;float.h&gt;.  For the sake of C compatibility, we should make corresponding changes.
</p>


<p><b>Proposed resolution:</b></p>
<p>
1. Change the heading of subclause 3.4, "Headers <code>&lt;cdecfloat&gt;</code> and <code>&lt;decfloat.h&gt;</code>" to "Additions to headers <code>&lt;cfloat&gt;</code> and <code>&lt;float.h&gt;</code>."
</p>
<p>
2. Change the text of subclause 3.4 as follows:
</p>
<blockquote>
<p>
<del>The standard C++ headers <code>&lt;cfloat&gt;</code> and <code>&lt;float.h&gt;</code> define characteristics of the floating-point types <code>float</code>, <code>double</code>, and <code>long double</code>.  Their contents remain unchanged by this Technical Report.</del>
</p>
<p>
<del>Headers <code>&lt;cdecfloat&gt;</code> and <code>&lt;decfloat.h&gt;</code> define characteristics of the decimal floating-point types <code>decimal32</code>, <code>decimal64</code>, and <code>decimal128</code>.  As well, <code>&lt;decfloat.h&gt;</code> defines the convenience typedefs <code>_Decimal32</code>, <code>_Decimal64</code>, and <code>_Decimal128</code>, for compatibilty with the C programming language.</del>
</p>
<p>
<ins>The header <code>&lt;cfloat&gt;</code> is described in [tr.c99.cfloat].  The header <code>&lt;float.h&gt;</code> is described in [tr.c99.floath]. These headers are extended by this Technical Report to define characteristics of the decimal floating-point types <code>decimal32</code>, <code>decimal64</code>, and <code>decimal128</code>.  As well, <code>&lt;float.h&gt;</code> is extended to define the convenience typedefs <code>_Decimal32</code>, <code>_Decimal64</code>, and <code>_Decimal128</code> for compatibility with the C programming language.</ins>
</p>
</blockquote>
<p>
3. Change the heading of subclause 3.4.1, "Header <code>&lt;cdecfloat&gt;</code> synopsis"  to "Additions to header <code>&lt;cfloat&gt;</code> synopsis."
</p>
<p>
4. Change the heading of subclause 3.4.2, "Header <code>&lt;decfloat.h&gt;</code> synopsis" to "Additions to header <code>&lt;float.h&gt;</code> synopsis."
</p>
<p>
5. Change the contents of 3.4.2 as follows:
</p>
<pre>      <del>#include &lt;cdecfloat&gt;</del>

      // <i>C-compatibility convenience typedefs:</i>

      typedef std::decimal::decimal32  _Decimal32;
      typedef std::decimal::decimal64  _Decimal64;
      typedef std::decimal::decimal128 _Decimal128;
</pre>





<hr>
<h3><a name="607"></a>607. Concern about short seed vectors</h3>
<p><b>Section:</b> 26.5.7.1 [rand.util.seedseq] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Charles Karney <b>Opened:</b> 2006-10-26 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.util.seedseq">issues</a> in [rand.util.seedseq].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Short seed vectors of 32-bit quantities all result in different states. However
this is not true of seed vectors of 16-bit (or smaller) quantities.  For example
these two seeds
</p>

<blockquote><pre>unsigned short seed = {1, 2, 3};
unsigned short seed = {1, 2, 3, 0};
</pre></blockquote>

<p>
both pack to
</p>

<blockquote><pre>unsigned seed = {0x20001, 0x3};
</pre></blockquote>

<p>
yielding the same state.
</p>

<p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2391.pdf">N2391</a> and
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2423.pdf">N2423</a>
for some further discussion.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Adopt the proposed resolution in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2423.pdf">N2423</a>.
</p>


<p><i>[
Kona (2007): The LWG adopted the proposed resolution of N2423 for this issue.
The LWG voted to accelerate this issue to Ready status to be voted into the WP at Kona.
]</i></p>





<hr>
<h3><a name="608"></a>608. Unclear seed_seq construction details</h3>
<p><b>Section:</b> 26.5.7.1 [rand.util.seedseq] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Charles Karney <b>Opened:</b> 2006-10-26 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.util.seedseq">issues</a> in [rand.util.seedseq].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 26.4.7.1 [rand.util.seedseq] /6, the order of packing the inputs into b and the
treatment of signed quantities is unclear. Better to spell it out.
</p>

<p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2391.pdf">N2391</a> and
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2423.pdf">N2423</a>
for some further discussion.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Adopt the proposed resolution in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2423.pdf">N2423</a>.
</p>


<p><i>[
Kona (2007): The LWG adopted the proposed resolution of N2423 for this issue.
The LWG voted to accelerate this issue to Ready status to be voted into the WP at Kona.
]</i></p>





<hr>
<h3><a name="609"></a>609. missing static const</h3>
<p><b>Section:</b> 26.5.4.2 [rand.adapt.ibits], TR1 5.1 [tr.rand] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Walter E. Brown <b>Opened:</b> 2006-11-02 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In preparing N2111, an error on my part resulted in the omission of the
following line from the template synopsis in the cited section:
</p>

<blockquote><pre>static const size_t word_size = w;
</pre></blockquote>

<p>
(This same constant is found, for example, in 26.4.3.3 [rand.eng.sub].)
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add the above declaration as the first line after the comment in [rand.adapt.ibits] p4:
</p>

<blockquote><pre>// engine characteristics
<ins>static const size_t word_size = w;</ins>
</pre></blockquote>

<p>
and accept my apologies for the oversight.
</p>





<hr>
<h3><a name="610"></a>610. Suggested non-normative note for C++0x</h3>
<p><b>Section:</b> 20.8.14.2.1 [func.wrap.func.con], TR1 3.7.2.1 [tr.func.wrap.func.con] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Scott Meyers <b>Opened:</b> 2006-11-02 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#func.wrap.func.con">issues</a> in [func.wrap.func.con].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
My suggestion is that implementers of both tr1::function and its 
official C++0x successor be explicitly encouraged (but not required) to 
optimize for the cases mentioned above, i.e., function pointers and 
small function objects.  They could do this by using a small internal 
buffer akin to the buffer used by implementations of the small string 
optimization.  (That would make this the small functor optimization -- 
SFO :-})  The form of this encouragement could be a note in the standard 
akin to footnote 214 of the current standard.
</p>

<p>
Dave Abrahams notes:
</p>

<p>
"shall not throw exceptions" should really be "nothing," both to be more
grammatical and to be consistent with existing wording in the standard.
</p>

<p>
Doug Gregor comments: I think this is a good idea. Currently, implementations of
tr1::function are required to have non-throwing constructors and assignment
operators when the target function object is a function pointer or a
reference_wrapper. The common case, however, is for a tr1::function to store
either an empty function object or a member pointer + an object pointer.
</p>
<p>
The function implementation in the upcoming Boost 1.34.0 uses the
"SFO", so that the function objects for typical bind expressions like
</p>
<blockquote><pre>bind(&amp;X::f, this, _1, _2, _3)
</pre></blockquote>

<p>
do not require heap allocation when stored in a boost::function. I
believe Dinkumware's implementation also performs this optimization.
</p>



<p><b>Proposed resolution:</b></p>
<p>
Revise 20.5.14.2.1 p6 [func.wrap.func.con] to add a note as follows:
</p>

<blockquote>
<p>
<i>Throws:</i> shall not throw exceptions if <tt>f</tt>'s target is a function
pointer or a function object passed via <tt>reference_wrapper</tt>. Otherwise,
may throw <tt>bad_alloc</tt> or any exception thrown by the copy constructor of
the stored function object.
</p>
<p>
<ins><i>Note:</i> Implementations are encouraged to avoid the use of dynamically
allocated memory for "small" function objects, e.g., where <tt>f</tt>'s target
is an object holding only a pointer or reference to an object and a member
function pointer (a "bound member function").</ins>
</p>
</blockquote>





<hr>
<h3><a name="611"></a>611. Standard library templates and incomplete types</h3>
<p><b>Section:</b> 17.6.3.8 [res.on.functions] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Nicola Musatti <b>Opened:</b> 2006-11-13 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#res.on.functions">issues</a> in [res.on.functions].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In the latest available draft standard 
(<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2134.pdf">N2134</a>)
 17.4.3.6 [res.on.functions] states:
</p>

<blockquote>
<p>
-1- In certain cases (replacement functions, handler functions, operations on
types used to instantiate standard library template components), the C++
Standard Library depends on components supplied by a C++ program. If these
components do not meet their requirements, the Standard places no requirements
on the implementation.
</p>

<p>
-2- In particular, the effects are undefined in the following cases:
</p>
<p>
[...]
</p>
<ul>
<li>if an incomplete type (3.9) is used as a template argument when
instantiating a template component. </li>
</ul>
</blockquote>

<p>
This is contradicted by  20.6.6.2/2 [util.smartptr.shared] which
states:
</p>

<blockquote>
<p>
[...]
</p>

<p>
The template parameter <tt>T</tt> of <tt>shared_ptr</tt> may be an incomplete type.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Modify the last bullet of  17.4.3.6/2 [res.on.functions] to allow for
exceptions:
</p>

<blockquote>
<ul>
<li>if an incomplete type (3.9) is used as a template argument when
instantiating a template component<ins>, unless specifically allowed for the
component</ins>. </li>
</ul>
</blockquote>






<hr>
<h3><a name="612"></a>612. numeric_limits::is_modulo insufficiently defined</h3>
<p><b>Section:</b> 18.3.1.2 [numeric.limits.members] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Chris Jefferson <b>Opened:</b> 2006-11-10 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#numeric.limits.members">issues</a> in [numeric.limits.members].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
18.2.1.2 55 states that "A type is modulo if it is possible to add two
positive numbers together and have a result that wraps around to a
third number that is less".
This seems insufficient for the following reasons:
</p>

<ol>
<li>Doesn't define what that value received is.</li>
<li>Doesn't state the result is repeatable</li>
<li> Doesn't require that doing addition, subtraction and other
operations on all values is defined behaviour.</li>
</ol>

<p><i>[
Batavia: Related to
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2144.pdf">N2144</a>.
Pete: is there an ISO definition of modulo?  Underflow on signed behavior is undefined.
]</i></p>


<p><i>[
Bellevue:  accept resolution, move to ready status.
Does this mandate that is_modulo be true on platforms for which int
happens to b modulo? A: the standard already seems to require that.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
Suggest 18.3.1.2 [numeric.limits.members], paragraph 57 is amended to:
</p>

<blockquote><p>
A type is modulo if<ins>,</ins> <del>it is possible to add two positive numbers
and have a result that wraps around to a third number that is less.</del>
<ins>given any operation involving +,- or * on values of that type whose value
would fall outside the range <tt>[min(), max()]</tt>, then the value returned
differs from the true value by an integer multiple of <tt>(max() - min() +
1)</tt>.</ins>
</p></blockquote>






<hr>
<h3><a name="613"></a>613. max_digits10 missing from numeric_limits</h3>
<p><b>Section:</b> 18.3.1.5 [numeric.special] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Bo Persson <b>Opened:</b> 2006-11-20 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#numeric.special">issues</a> in [numeric.special].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Section 18.3.1.5 [numeric.special] starts out by saying that "All members shall be provided 
for all specializations."
</p>
<p>
Then it goes on to show specializations for float and bool, where one member 
is missing (max_digits10).
</p>

<p>
Maarten Kronenburg adds:
</p>

<p>
I agree, just adding the comment that the exact number of decimal digits
is digits * ln(radix) / ln(10), where probably this real number is
rounded downward for digits10, and rounded upward for max_digits10
(when radix=10, then digits10=max_digits10).
Why not add this exact definition also to the standard, so the user
knows what these numbers exactly mean.
</p>

<p>
Howard adds:
</p>

<p>
For reference, here are the correct formulas from
<a href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1822.pdf">N1822</a>:
</p>

<blockquote><pre>digits10 = floor((digits-1) * log10(2))
max_digits10 = ceil((1 + digits) * log10(2))
</pre></blockquote>

<p>
We are also missing a statement regarding for what specializations this member has meaning.
</p>



<p><b>Proposed resolution:</b></p>
<p>
Change and add after 18.3.1.2 [numeric.limits.members], p11:
</p>

<blockquote>
<pre>static const int max_digits10;</pre>
<blockquote>
<p>
-11- Number of base 10 digits required to ensure that values which
differ <del>by only one epsilon</del> are always differentiated.
</p>
<p><ins>
-12- Meaningful for all floating point types.
</ins></p>
</blockquote>
</blockquote>

<p>
Change 18.3.1.5 [numeric.special], p2:
</p>

<blockquote><pre>template&lt;&gt; class numeric_limits&lt;float&gt; { 
public: 
  static const bool is_specialized = true; 
  ...
  static const int digits10 = 6;
  <ins>static const int max_digits10 = 9</ins>;
  ...
</pre></blockquote>

<p>
Change 18.3.1.5 [numeric.special], p3:
</p>

<blockquote><pre>template&lt;&gt; class numeric_limits&lt;bool&gt; { 
public: 
  static const bool is_specialized = true; 
  ...
  static const int digits10 = 0;
  <ins>static const int max_digits10 = 0</ins>;
  ...
</pre></blockquote>







<hr>
<h3><a name="616"></a>616. missing 'typename' in ctype_byname</h3>
<p><b>Section:</b> 22.4.1.2 [locale.ctype.byname] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Bo Persson <b>Opened:</b> 2006-12-16 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.ctype.byname">issues</a> in [locale.ctype.byname].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Section 22.2.1.2 defines the ctype_byname class template. It contains the 
line
</p>

<blockquote><pre>typedef ctype&lt;charT&gt;::mask   mask;
</pre></blockquote>



<p><b>Proposed resolution:</b></p>
<p>
as this is a dependent type, it should obviously be
</p>

<blockquote><pre>typedef <ins>typename</ins> ctype&lt;charT&gt;::mask   mask;
</pre></blockquote>





<hr>
<h3><a name="618"></a>618. valarray::cshift() effects on empty array</h3>
<p><b>Section:</b> 26.6.2.7 [valarray.members] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Gabriel Dos Reis <b>Opened:</b> 2007-01-10 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I would respectfully request an issue be opened with the intention to
clarify the wording for <tt>size() == 0</tt> for <tt>cshift</tt>.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change 26.6.2.7 [valarray.members], paragraph 10:
</p>

<blockquote>

<pre>valarray&lt;T&gt; cshift(int <i>n</i>) const;
</pre>

<blockquote>
<p>
This function returns an object of class <tt>valarray&lt;T&gt;</tt>, of
length <tt>size()</tt>, <del>each of whose elements <tt>I</tt> is
<tt>(*this)[(I + n ) % size()]</tt>. Thus, if element zero is taken as
the leftmost element, a positive value of <i>n</i> shifts the elements
circularly left <i>n</i> places.</del> <ins>that is a circular shift of <tt>*this</tt>. If
element zero is taken as the leftmost element, a non-negative value of
<i>n</i> shifts the elements circularly left <i>n</i> places and a
negative value of <i>n</i> shifts the elements circularly right
-<i>n</i> places.</ins>
</p>
</blockquote>
</blockquote>



<p><b>Rationale:</b></p>
<p>
We do not believe that there is any real ambiguity about what happens
when <tt>size() == 0</tt>, but we do believe that spelling this out as a C++
expression causes more trouble that it solves. The expression is
certainly wrong when <tt>n &lt; 0</tt>, since the sign of % with negative arguments
is implementation defined.
</p>


<p><i>[
Kona (2007) Changed proposed wording, added rationale and set to Review.
]</i></p>





<hr>
<h3><a name="619"></a>619. Longjmp wording problem</h3>
<p><b>Section:</b> 18.10 [support.runtime] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Lawrence Crowl <b>Opened:</b> 2007-01-12 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#support.runtime">issues</a> in [support.runtime].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The wording for <tt>longjmp</tt> is confusing.
</p>
<p>
18.10 [support.runtime] -4- Other runtime support
</p>
<blockquote><p>
The function signature <tt>longjmp(jmp_buf jbuf, int val)</tt> has more restricted
behavior in this International Standard.  If any automatic objects would
be destroyed by a thrown exception transferring control to another
(destination) point in the program, then a call to <tt>longjmp(jbuf, val)</tt> that
the throw point that transfers control to the same (destination) point has
undefined behavior.
</p></blockquote>
<p>
Someone at Google thinks that should say "then a call to <tt>longjmp(jbuf, val)</tt>
*at* the throw point that transfers control".
</p>
<p>
Bill Gibbons thinks it should say something like "If any automatic objects
would be destroyed by an exception thrown at the point of the longjmp and
caught only at the point of the setjmp, the behavior is undefined."
</p>


<p><b>Proposed resolution:</b></p>
<p>
In general, accept Bill Gibbons' recommendation,
but add "call" to indicate that the undefined behavior
comes from the dynamic call, not from its presence in the code.
In 18.10 [support.runtime] paragraph 4, change
</p>

<blockquote><p>
The function signature <tt>longjmp(jmp_buf jbuf, int val)</tt> has more
restricted behavior in this International Standard.  <del>If any automatic
objects would be destroyed by a thrown exception transferring control to another
(destination) point in the program, then a call to <tt>longjmp(jbuf, val)</tt>
that the throw point that transfers control to the same (destination) point has
undefined behavior.</del> <ins>A <tt>setjmp</tt>/<tt>longjmp</tt> call pair has
undefined behavior if replacing the <tt>setjmp</tt> and <tt>longjmp</tt> by
<tt>catch</tt> and <tt>throw</tt> would destroy any automatic objects.</ins>
</p></blockquote>





<hr>
<h3><a name="620"></a>620. valid uses of empty valarrays</h3>
<p><b>Section:</b> 26.6.2.1 [valarray.cons] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2007-01-20 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#valarray.cons">issues</a> in [valarray.cons].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
        <p>

The <i>Effects</i>  clause for the  default <code>valarray</code> ctor
suggests  that  it  is possible  to  increase  the  size of  an  empty
<code>valarray</code>  object   by  calling  other   non-const  member
functions of the class besides <code>resize()</code>. However, such an
interpretation would  be contradicted by  the requirement on  the copy
assignment  operator  (and  apparently   also  that  on  the  computed
assignments)  that the  assigned arrays  be  the same  size.  See  the
reflector discussion starting with c++std-lib-17871.

        </p>
        <p>

In  addition,  <i>Footnote</i> 280  uses  some questionable  normative
language.

        </p>


<p><b>Proposed resolution:</b></p>
        <p>

Reword the <i>Effects</i> clause and <i>Footnote 280</i> as follows (26.6.2.1 [valarray.cons]):

        </p>
        <blockquote>
            <p>

<code>valarray();</code>

            </p>
            <p>

<i>Effects</i>:      Constructs      an      object      of      class
<code>valarray&lt;T&gt;</code>,<sup>279)</sup>    which    has    zero
length<del> until it is passed into a library function as a modifiable
lvalue or through a non-constant this pointer</del>.<sup>280)</sup>

            </p>
            <p>

<ins><i>Postcondition</i>: <code>size() == 0</code>.</ins>

            </p>
            <p>

<i>Footnote  280</i>:  This default  constructor  is essential,  since
arrays  of  <code>valarray</code>  <del>are  likely to  prove  useful.
There  shall also  be  a way  to change  the  size of  an array  after
initialization;  this  is  supplied  by the  semantics</del>  <ins>may be
useful.   The  length  of  an  empty  array  can  be  increased  after
initialization  by  means</ins>  of the  <code>resize()</code>  member
function.

            </p>
        </blockquote>





<hr>
<h3><a name="621"></a>621. non-const copy assignment operators of helper arrays</h3>
<p><b>Section:</b> 26.6 [numarray] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2007-01-20 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#numarray">issues</a> in [numarray].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
        <p>

The computed and  "fill" assignment operators of <code>valarray</code>
helper     array     class    templates     (<code>slice_array</code>,
<code>gslice_array</code>,         <code>mask_array</code>,        and
<code>indirect_array</code>) are const  member functions of each class
template     (the     latter    by     the     resolution    of  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#123">123</a>
since  they have reference  semantics and thus do  not affect
the state of  the object on which they are  called.  However, the copy
assignment  operators  of  these  class  templates,  which  also  have
reference semantics,  are non-const.   The absence of  constness opens
the door to speculation about whether they really are intended to have
reference semantics (existing implementations vary widely).

        </p>

<p>
Pre-Kona, Martin adds:
</p>

<p>
I realized that adding the const qualifier to the
functions as I suggested would break the const correctness of the
classes. A few possible solutions come to mind:
</p>

<ol>
<li>Add the const qualifier to the return types of these functions.</li>
<li>Change the return type of all the functions to void to match
the signatures of all the other assignment operators these classes
define.</li>
<li>Prohibit the copy assignment of these classes by declaring the
copy assignment operators private (as is done and documented by
some implementations).</li>
</ol>



<p><b>Proposed resolution:</b></p>
        <p>

Declare  the  copy  assignment  operators  of all  four  helper  array
class templates const.

        </p>
        <p>

Specifically,  make the following edits:

        </p>
        <p>

Change     the    signature     in     26.6.5 [template.slice.array]    and
26.6.5.1 [slice.arr.assign] as follows:

        </p>
        <blockquote><pre>
<code><ins>const</ins> slice_array&amp; operator= (const slice_array&amp;)<ins> const</ins>;</code>

        </pre></blockquote>
        <p>

Change     the     signature     in    26.6.7 [template.gslice.array]     and
26.6.7.1 [gslice.array.assign] as follows:

        </p>
        <blockquote><pre>
<code><ins>const</ins> gslice_array&amp; operator= (const gslice_array&amp;)<ins> const</ins>;</code>

        </pre></blockquote>
        <p>

Change the  signature in 26.6.8 [template.mask.array]  and 26.6.8.1 [mask.array.assign] as
follows:

        </p>
        <blockquote><pre>
<code><ins>const</ins> mask_array&amp; operator= (const mask_array&amp;)<ins> const</ins>;</code>

        </pre></blockquote>
        <p>

Change     the     signature     in    26.6.9 [template.indirect.array] and
26.6.9.1 [indirect.array.assign] as follows:

        </p>
        <blockquote><pre>
<code><ins>const</ins> indirect_array&amp; operator= (const indirect_array&amp;)<ins> const</ins>;</code>

        </pre></blockquote>


<p><i>[
Kona (2007) Added const qualification to the return types and set to Ready.
]</i></p>





<hr>
<h3><a name="622"></a>622. behavior of <code>filebuf</code> dtor and <code>close</code> on error</h3>
<p><b>Section:</b> 27.9.1.17 [fstream.members] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2007-01-20 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
        <p>

<code>basic_filebuf</code>  dtor is  specified to  have  the following
straightforward effects:

        </p>
        <blockquote><p>

<i>Effects</i>:       Destroys      an      object       of      class
<code>basic_filebuf</code>. Calls <code>close()</code>.

        </p></blockquote>
        <p>

<code>close()</code> does a lot of potentially complicated processing,
including calling <code>overflow()</code> to write out the termination
sequence  (to   bring  the  output  sequence  to   its  initial  shift
state). Since  any of the  functions called during the  processing can
throw an exception, what should the  effects of an exception be on the
dtor? Should the  dtor catch and swallow it or  should it propagate it
to the caller?  The text doesn't  seem to provide any guidance in this
regard  other  than  the  general  restriction on  throwing  (but  not
propagating)  exceptions  from   destructors  of  library  classes  in
17.6.4.12 [res.on.exception.handling].

        </p>
        <p>

Further,  the last thing  <code>close()</code> is  specified to  do is
call <code>fclose()</code> to close the <code>FILE</code> pointer. The
last sentence of the <i>Effects</i> clause reads:

        </p>
        <blockquote><p>

...   If    any   of    the   calls   to    <code>overflow</code>   or
<code>std::fclose</code> fails then <code>close</code> fails.

        </p></blockquote>
        <p>

This  suggests that  <code>close()</code>  might be  required to  call
<code>fclose()</code>   if  and  only   if  none   of  the   calls  to
<code>overflow()</code> fails, and avoid closing the <code>FILE</code>
otherwise. This  way, if  <code>overflow()</code> failed to  flush out
the data, the caller  would have  the opportunity to  try to  flush it
again (perhaps  after trying  to deal with  whatever problem  may have
caused the failure), rather than losing it outright.

        </p>
        <p>

On the other hand,  the function's <i>Postcondition</i> specifies that
<code>is_open() ==  false</code>, which  suggests that it  should call
<code>fclose()</code>       unconditionally.       However,      since
<i>Postcondition</i> clauses  are specified for many  functions in the
standard,  including constructors  where they  obviously  cannot apply
after an  exception, it's not clear  whether this <i>Postcondition</i>
clause is intended to apply even after an exception.

        </p>
        <p>

It  might  be worth  noting  that  the  traditional behavior  (Classic
Iostreams  <code>fstream::close()</code> and  C <code>fclose()</code>)
is  to  close  the  <code>FILE</code> unconditionally,  regardless  of
errors.

        </p>

<p><i>[
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#397">397</a> and <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#418">418</a> for related issues.
]</i></p>




<p><b>Proposed resolution:</b></p>
        <p>

After discussing this  on the reflector (see the  thread starting with
c++std-lib-17650) we propose that <code>close()</code> be clarified to
match the traditional behavior, that is to close the <code>FILE</code>
unconditionally,  even after  errors or  exceptions.  In  addition, we
propose the dtor description be amended so as to explicitly require it
to catch and swallow any exceptions thrown by <code>close()</code>.

        </p>
        <p>

Specifically,   we   propose   to   make  the   following   edits   in
27.9.1.4 [filebuf.members]:

        </p>
        <blockquote>
            <pre>
<code>basic_filebuf&lt;charT,traits&gt;* close();</code>

            </pre>
            <p>

<i>Effects</i>:  If <code>is_open()  == false</code>,  returns  a null
pointer.        If      a       put      area       exists,      calls
<code>overflow(traits::eof())</code> to flush  characters. If the last
virtual   member  function   called  on   <code>*this</code>  (between
<code>underflow</code>,  <code>overflow</code>,  <code>seekoff</code>,
and   <code>seekpos</code>)  was   <code>overflow</code>   then  calls
<code>a_codecvt.unshift</code> (possibly several times) to determine a
termination   sequence,    inserts   those   characters    and   calls
<code>overflow(traits::eof())</code>  again.  Finally<ins>, regardless
of whether  any of the preceding  calls fails or  throws an exception,
the  function</ins> <del>it</del>  closes   the  file   ("as   if"  by   calling
<code>std::fclose(file)</code>).<sup>334)</sup>  If any  of  the calls
<ins>made    by   the    function</ins><del>to   <code>overflow</code>
or</del><ins>,  including  </ins><code>std::fclose</code><ins>, </ins>
fails then <code>close</code> fails<ins>  by returning a null pointer.
If one of these calls throws an exception, the exception is caught and
rethrown after closing the file.</ins>

            </p>
        </blockquote>
        <p>

And to make the following edits in 27.9.1.2 [filebuf.cons].

        </p>
        <blockquote>
            <pre>
<code>virtual ~basic_filebuf();</code>

            </pre>
            <p>

<i>Effects</i>:       Destroys      an      object       of      class
<code>basic_filebuf&lt;charT,traits&gt;</code>.                   Calls
<code>close()</code>.    <ins>If  an   exception  occurs   during  the
destruction of the object, including the call to <code>close()</code>,
the     exception    is     caught    but     not     rethrown    (see
17.6.4.12 [res.on.exception.handling]).</ins>

            </p>
        </blockquote>





<hr>
<h3><a name="623"></a>623. <code>pubimbue</code> forbidden to call <code>imbue</code></h3>
<p><b>Section:</b> 27.2.1 [iostream.limits.imbue] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2007-01-20 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
        <p>

27.2.1 [iostream.limits.imbue]  specifies  that  "no  function  described  in
clause 27 except  for <code>ios_base::imbue</code> causes any instance
of                   <code>basic_ios::imbue</code>                  or
<code>basic_streambuf::imbue</code> to be called."

        </p>
        <p>

That      contradicts      the      <i>Effects</i>     clause      for
<code>basic_streambuf::pubimbue()</code>  which requires  the function
to do just that: call <code>basic_streambuf::imbue()</code>.

        </p>


<p><b>Proposed resolution:</b></p>
        <p>

To    fix   this,    rephrase    the   sentence    above   to    allow
<code>pubimbue</code> to do what  it was designed to do. Specifically.
change 27.2.1 [iostream.limits.imbue], p1 to read:

        </p>
        <blockquote><p>

No     function    described     in    clause     27     except    for
<code>ios_base::imbue</code>  <ins>and <code>basic_filebuf::pubimbue</code></ins>
causes    any    instance    of    <code>basic_ios::imbue</code>    or
<code>basic_streambuf::imbue</code> to be called. ...

        </p></blockquote>





<hr>
<h3><a name="624"></a>624. <code>valarray</code> assignment and arrays of unequal length</h3>
<p><b>Section:</b> 26.6.2.2 [valarray.assign] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2007-01-20 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
        <p>

The behavior of the  <code>valarray</code> copy assignment operator is
defined only when both sides have  the same number of elements and the
spec is explicit about assignments of arrays of unequal lengths having
undefined behavior.

        </p>
        <p>

However, the generalized  subscripting assignment operators overloaded
on <code>slice_array</code>  et al (26.6.2.2 [valarray.assign])  don't have any
such restriction, leading  the reader to believe that  the behavior of
these  overloads is  well defined  regardless  of the  lengths of  the
arguments.

        </p>
        <p>

For example,  based on  the reading  of the spec  the behavior  of the
snippet below can be expected to be well-defined:

        </p>
        <pre>    const std::slice from_0_to_3 (0, 3, 1);   // refers to elements 0, 1, 2
    const std::valarray&lt;int&gt; a (1, 3);        // a = { 1, 1, 1 }
    std::valarray&lt;int&gt;       b (2, 4);        // b = { 2, 2, 2, 2 }

    b = a [from_0_to_3];
        </pre>
        <p>

In practice, <code>b</code> may end up being <code>{ 1, 1, 1 }</code>,
<code>{  1,  1, 1,  2  }</code>,  or  anything else,  indicating  that
existing implementations vary.

        </p>

<p>
Quoting from Section 3.4, Assignment operators, of Al Vermeulen's
Proposal for Standard C++ Array Classes (see c++std-lib-704;
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/1993/N0308.asc">N0308</a>):
</p>
<blockquote><p>
  ...if the size of the array on the right hand side of the equal
  sign differs from the size of the array on the left, a run time
  error occurs. How this error is handled is implementation
  dependent; for compilers which support it, throwing an exception
  would be reasonable.
</p></blockquote>

<p>
And see more history in
<a href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/1993/N0280.pdf">N0280</a>.
</p>

        <p>

It has  been argued in  discussions on the committee's  reflector that
the semantics of all <code>valarray</code> assignment operators should
be permitted to be undefined unless  the  length  of the arrays  being
assigned is the same as the length of the one being assigned from. See
the thread starting at c++std-lib-17786.

        </p>
        <p>

In order  to reflect  such views, the  standard must specify  that the
size of the  array referred to by the argument  of the assignment must
match the size of the array  under assignment, for example by adding a
<i>Requires</i> clause to 26.6.2.2 [valarray.assign] as follows:

        </p>
        <blockquote><p>

<i>Requires</i>: The length of the  array to which the argument refers
equals <code>size()</code>.

        </p></blockquote>

        <p>

Note that it's  far from clear that such leeway  is necessary in order
to implement <code>valarray</code> efficiently.

        </p>


<p><b>Proposed resolution:</b></p>
<p>
Insert new paragraph into 26.6.2.2 [valarray.assign]:
</p>

<blockquote>
<pre>valarray&lt;T&gt;&amp; operator=(const slice_array&lt;T&gt;&amp;); 
valarray&lt;T&gt;&amp; operator=(const gslice_array&lt;T&gt;&amp;); 
valarray&lt;T&gt;&amp; operator=(const mask_array&lt;T&gt;&amp;); 
valarray&lt;T&gt;&amp; operator=(const indirect_array&lt;T&gt;&amp;);
</pre>
<blockquote>
<p><ins>
<i>Requires</i>: The length of the  array to which the argument refers
equals <code>size()</code>.
</ins></p>
<p>
These operators allow the results of a generalized subscripting operation to be assigned directly to a <tt>valarray</tt>.
</p>
</blockquote>
</blockquote>





<hr>
<h3><a name="625"></a>625. mixed up <i>Effects</i> and <i>Returns</i> clauses</h3>
<p><b>Section:</b> 17 [library] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2007-01-20 <b>Last modified:</b> 2010-11-19</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#895">895</a></p>
<p><b>Discussion:</b></p>
 <p>

Many member functions of <code>basic_string</code> are overloaded,
with some of the overloads taking a <code>string</code> argument,
others <code>value_type*</code>, others <code>size_type</code>, and
others still <code>iterators</code>. Often, the requirements on one of
the overloads are expressed in the form of <i>Effects</i>,
<i>Throws</i>, and in the Working Paper
(<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2134.pdf">N2134</a>)
also <i>Remark</i> clauses, while those on the rest of the overloads
via a reference to this overload and using a <i>Returns</i> clause.
</p>

<p>
The difference between the two forms of specification is that per
17.5.1.4 [structure.specifications], p3, an <i>Effects</i> clause specifies
<i>"actions performed by the functions,"</i> i.e., its observable
effects, while a <i>Returns</i> clause is <i>"a description of the
return value(s) of a function"</i> that does not impose any
requirements on the function's observable effects.
</p>

<p>
Since only <i>Notes</i> are explicitly defined to be informative and
all other paragraphs are explicitly defined to be normative, like
<i>Effects</i> and <i>Returns</i>, the new <i>Remark</i> clauses also
impose normative requirements.
</p>

<p>
So by this strict reading of the standard there are some member
functions of <code>basic_string</code> that are required to throw an
exception under some conditions or use specific traits members while
many other otherwise equivalent overloads, while obliged to return the
same values, aren't required to follow the exact same requirements
with regards to the observable effects.
</p>

<p>
Here's an example of this problem that was precipitated by the change
from informative Notes to normative <i>Remark</i>s (presumably made to
address <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#424">424</a>):
</p>

<p>
In the Working Paper, <code>find(string, size_type)</code> contains a
<i>Remark</i> clause (which is just a <i>Note</i> in the current
standard) requiring it to use <code>traits::eq()</code>.
</p>

<p>
<code>find(const charT *s, size_type pos)</code> is specified to
return <code>find(string(s), pos)</code> by a <i>Returns</i> clause
and so it is not required to use <code>traits::eq()</code>. However,
the Working Paper has replaced the original informative <i>Note</i>
about the function using <code>traits::length()</code> with a
normative requirement in the form of a <i>Remark</i>. Calling
<code>traits::length()</code> may be suboptimal, for example when the
argument is a very long array whose initial substring doesn't appear
anywhere in <code>*this</code>.
</p>

<p>
Here's another similar example, one that existed even prior to the
introduction of <i>Remark</i>s:
</p>

<p>
<code> insert(size_type pos, string, size_type, size_type)</code> is
required to throw <code>out_of_range</code> if <code>pos &gt;
size()</code>.
</p>

<p>
<code>insert(size_type pos, string str)</code> is specified to return
<code>insert(pos, str, 0, npos)</code> by a <i>Returns</i> clause and
so its effects when <code>pos &gt; size()</code> are strictly speaking
unspecified.
</p><p>

</p>
I believe a careful review of the current <i>Effects</i> and
<i>Returns</i> clauses is needed in order to identify all such
problematic cases. In addition, a review of the Working Paper should
be done to make sure that the newly introduced normative <i>Remark</i>
clauses do not impose any undesirable normative requirements in place
of the original informative <i>Notes</i>.
<p></p>

<p><i>[
Batavia: Alan and Pete to work.
]</i></p>


<p><i>[
Bellevue: Marked as NAD Editorial.
]</i></p>


<p><i>[
Post-Sophia Antipolis:
Martin indicates there is still work to be done on this issue.
Reopened.
]</i></p>


<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Tom proposes we say that, unless specified otherwise,
it is always the caller's responsibility to verify that supplied arguments
meet the called function's requirements.
If further semantics are specified
(e.g., that the function throws under certain conditions),
then it is up to the implementer to check those conditions.
Alan feels strongly that our current use of Requires in this context
is confusing, especially now that <tt>requires</tt> is a new keyword.
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
Move to Tentatively NAD.
</blockquote>

<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote>
Move to Open.  Martin will work on proposed wording.
</blockquote>

<p><i>[
2010 Pittsburgh:
]</i></p>


<blockquote>
Moved to NAD Editorial, solved by revision to N3021.
</blockquote>




<p><b>Rationale:</b></p>
<p>
Solved by revision to N3021.
</p>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="628"></a>628. Inconsistent definition of basic_regex constructor</h3>
<p><b>Section:</b> 28.8 [re.regex] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Bo Persson <b>Opened:</b> 2007-01-23 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#re.regex">issues</a> in [re.regex].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Section 28.8 [re.regex] lists a constructor
</p>

<blockquote><pre>template&lt;class InputIterator&gt;
basic_regex(InputIterator first, InputIterator last,
                       flag_type f = regex_constants::ECMAScript);
</pre></blockquote>

<p>
However, in section 28.8.2 [re.regex.construct], this constructor takes a 
pair of <tt>ForwardIterator</tt>.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change 28.8.2 [re.regex.construct]:
</p>

<blockquote><pre>template &lt;class <del>ForwardIterator</del> <ins>InputIterator</ins>&gt;
  basic_regex(<del>ForwardIterator</del> <ins>InputIterator</ins> first, <del>ForwardIterator</del> <ins>InputIterator</ins> last, 
              flag_type f = regex_constants::ECMAScript);
</pre></blockquote>






<hr>
<h3><a name="629"></a>629. complex<t> insertion and locale dependence</t></h3>
<p><b>Section:</b> 26.4.6 [complex.ops] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Gabriel Dos Reis <b>Opened:</b> 2007-01-28 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#complex.ops">issues</a> in [complex.ops].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
is there an issue opened for (0,3) as complex number with
the French local?  With the English local, the above parses as an
imaginery complex number.  With the French locale it parses as a
real complex number.
</p>

<p>
Further notes/ideas from the lib-reflector, messages 17982-17984:
</p>

<blockquote>
<p>
Add additional entries in num_punct to cover the complex separator (French would be ';').
</p>
<p>
Insert a space before the comma, which should eliminate the ambiguity.
</p>
<p>
Solve the problem for ordered sequences in general, perhaps with a
dedicated facet.  Then complex should use that solution.
</p>
</blockquote>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
<p>
After much discussion, we agreed on the following: Add a footnote:
</p>
<p>
[In a locale in which comma is being used as a decimal point character,
inserting "showbase" into the output stream forces all outputs to show
an explicit decimal point character; then all inserted complex sequences
will extract unambiguously.]
</p>
<p>
And move this to READY status.
</p>
</blockquote>

<p><i>[
Pre-Sophia Antipolis, Howard adds:
]</i></p>


<blockquote>
Changed "showbase" to "showpoint" and changed from Ready to Review.
</blockquote>

<p><i>[
Post-Sophia Antipolis:
]</i></p>


<blockquote>
<p>
I neglected to pull this issue from the formal motions page after the "showbase" to "showpoint" change.
In Sophia Antipolis this change was reviewed by the LWG and the issue was set to Ready.  We subsequently
voted the footnote into the WP with "showbase".
</p>
<p>
I'm changing from WP back to Ready to pick up the "showbase" to "showpoint" change.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add a footnote to 26.4.6 [complex.ops] p16:
</p>

<blockquote>
[In a locale in which comma is being used as a decimal point character,
inserting <tt>showpoint</tt> into the output stream forces all outputs to show
an explicit decimal point character; then all inserted complex sequences
will extract unambiguously.]
</blockquote>





<hr>
<h3><a name="630"></a>630. arrays of valarray</h3>
<p><b>Section:</b> 26.6.2.1 [valarray.cons] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2007-01-28 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#valarray.cons">issues</a> in [valarray.cons].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
        <p>

Section 26.2 [numeric.requirements], p1     suggests     that     a
<code>valarray</code>  specialization on  a  type <code>T</code>  that
satisfies  the requirements enumerated  in the  paragraph is  itself a
valid  type   on  which  <code>valarray</code>   may  be  instantiated
(Footnote       269        makes       this       clear).        I.e.,
<code>valarray&lt;valarray&lt;T&gt;  &gt;</code> is  valid as  long as
<code>T</code>   is   valid.    However,  since   implementations   of
<code>valarray</code> are permitted to initialize storage allocated by
the class by  invoking the default ctor of  <code>T</code> followed by
the    copy    assignment    operator,   such    implementations    of
<code>valarray</code>   wouldn't  work  with   (perhaps  user-defined)
specializations of <code>valarray</code> whose assignment operator had
undefined behavior when the size of its argument didn't match the size
of <code>*this</code>.  By <i>"wouldn't work"</i> I mean that it would
be  impossible  to resize  such  an array  of  arrays  by calling  the
<code>resize()</code> member  function on it if the  function used the
copy  assignment operator  after constructing  all elements  using the
default  ctor (e.g.,  by invoking  <code>new  value_type[N]</code>) to
obtain default-initialized storage) as it's permitted to do.

        </p>
        <p>

Stated      more     generally,      the      problem     is      that
<code>valarray&lt;valarray&lt;T&gt;  &gt;::resize(size_t)</code> isn't
required or  guaranteed to have well-defined semantics  for every type
<code>T</code>     that      satisfies     all     requirements     in
26.2 [numeric.requirements].

        </p>
        <p>

I  believe  this  problem  was  introduced  by  the  adoption  of  the
resolution                outlined                in                <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/1996/N0857.asc">N0857</a>,
<i>Assignment  of  valarrays</i>,  from  1996.   The  copy  assignment
operator  of  the original  numerical  array  classes  proposed in  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/1993/N0280.pdf">N0280</a>,
as      well       as      the      one       proposed      in      <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/1993/N0308.asc">N0308</a>
(both  from 1993), had  well-defined semantics  for arrays  of unequal
size (the  latter explicitly  only when <code>*this</code>  was empty;
assignment of non empty arrays of unequal size was a runtime error).

        </p>
        <p>

The  justification for  the  change given  in  N0857 was the "loss  of
performance [deemed]  only significant  for very simple  operations on
small arrays or for architectures with very few registers."

        </p>
        <p>

Since tiny  arrays on a  limited subset of hardware  architectures are
likely  to  be  an   exceedingly  rare  case  (despite  the  continued
popularity of  x86) I  propose to revert  the resolution and  make the
behavior    of   all   <code>valarray</code>    assignment   operators
well-defined even  for non-conformal  arrays (i.e., arrays  of unequal
size).   I have implemented  this change  and measured  no significant
degradation  in performance in  the common  case (non-empty  arrays of
equal size).  I  have measured a 50% (and in  some cases even greater)
speedup  in the  case of  assignments to  empty arrays  versus calling
<code>resize()</code>  first followed  by  an invocation  of the  copy
assignment operator.

        </p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
If no proposed wording by June meeting, this issue should be closed NAD.
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
Move resolution 1 to Ready.
</p>
<p>
Howard: second resolution has been commented out (made invisible).
Can be brought back on demand.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
        <p>

Change 26.6.2.2 [valarray.assign], p1 as follows:

        </p>
        <blockquote>
            <p>
                <code>

valarray&lt;T&gt;&amp; operator=(const valarray&lt;T&gt;&amp;<ins> x</ins>);

                </code>
            </p>
            <p>

-1- Each element of the <code>*this</code> array is assigned the value
of  the  corresponding  element   of  the  argument  array.   <del>The
resulting behavior is undefined if </del><ins>When </ins>the length of
the  argument  array  is  not   equal  to  the  length  of  the  *this
array<del>.</del><ins>  resizes  <code>*this</code>  to make  the  two
arrays     the      same     length,     as      if     by     calling
<code>resize(x.size())</code>, before performing the assignment.</ins>

            </p>
        </blockquote>
        <p>

And  add a new  paragraph just  below paragraph  1 with  the following
text:

        </p>
        <blockquote>
            <p>

<ins>-2- <i>Postcondition</i>: <code>size() == x.size()</code>.</ins>

            </p>
        </blockquote>
        <p>

Also add the following paragraph to 26.6.2.2 [valarray.assign], immediately after p4:

        </p>
        <blockquote>
            <p>

<ins>-?- When the length,  <i><code>N</code></i> of the array referred
to by the  argument is not equal to  the length of <code>*this</code>,
the  operator resizes <code>*this</code>  to make  the two  arrays the
same  length, as if  by calling  <code>resize(<i>N</i>)</code>, before
performing the assignment.</ins>

            </p>
        </blockquote>

<p><i>[
pre-Sophia Antipolis, Martin adds the following compromise wording, but
prefers the original proposed resolution:
]</i></p>






<p><i>[
Kona (2007): Gaby to propose wording for an alternative resolution in
which you can assign to a <tt>valarray</tt> of size 0, but not to any other
<tt>valarray</tt> whose size is unequal to the right hand side of the assignment.
]</i></p>





<hr>
<h3><a name="634"></a>634. <tt>allocator.address()</tt> doesn't work for types overloading <tt>operator&amp;</tt></h3>
<p><b>Section:</b> 20.9.5.1 [allocator.members] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2007-02-07 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#allocator.members">issues</a> in [allocator.members].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#350">350</a></p>
<p><b>Discussion:</b></p>

<p>
20.9.5.1 [allocator.members] says:
</p>
<blockquote>
<pre>pointer address(reference <i>x</i>) const;</pre>
<blockquote>
<p>
-1- <i>Returns:</i> <tt>&amp;<i>x</i></tt>.
</p>
</blockquote>
</blockquote>

<p>
20.9.5.1 [allocator.members] defines <tt>CopyConstructible</tt> which currently not
only defines the semantics of copy construction, but also restricts what an overloaded
<tt>operator&amp;</tt> may do.  I believe proposals are in the works (such as concepts
and rvalue reference) to decouple these two requirements.  Indeed it is not evident
that we should disallow overloading <tt>operator&amp;</tt> to return something other
than the address of <tt>*this</tt>.
</p>

<p>
An example of when you want to overload <tt>operator&amp;</tt> to return something
other than the object's address is proxy references such as <tt>vector&lt;bool&gt;</tt>
(or its replacement, currently code-named <tt>bit_vector</tt>).  Taking the address of
such a proxy reference should logically yield a proxy pointer, which when dereferenced,
yields a copy of the original proxy reference again.
</p>

<p>
On the other hand, some code truly needs the address of an object, and not a proxy
(typically for determining the identity of an object compared to a reference object).
<a href="http://www.boost.org/">boost</a> has long recognized this dilemma and solved it with 
<a href="http://www.boost.org/libs/utility/utility.htm#addressof"><tt>boost::addressof</tt></a>.
It appears to me that this would be useful functionality for the default allocator.  Adopting
this definition for <tt>allocator::address</tt> would free the standard of requiring
anything special from types which overload <tt>operator&amp;</tt>.  Issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#580">580</a>
is expected to make use of <tt>allocator::address</tt> mandatory for containers.
</p>



<p><b>Proposed resolution:</b></p>
<p>
Change 20.9.5.1 [allocator.members]:
</p>

<blockquote>
<pre>pointer address(reference <i>x</i>) const;</pre>
<blockquote>
<p>
-1- <i>Returns:</i> <del><tt>&amp;<i>x</i></tt>.</del> <ins>The actual address of object referenced by <i>x</i>,
even in the presence of an overloaded <tt>operator&amp;</tt>.</ins>
</p>
</blockquote>

<pre>const_pointer address(address(const_reference <i>x</i>) const;</pre>
<blockquote>
<p>
-2- <i>Returns:</i> <del><tt>&amp;<i>x</i></tt>.</del> <ins>The actual address of object referenced by <i>x</i>,
even in the presence of an overloaded <tt>operator&amp;</tt>.</ins>
</p>
</blockquote>
</blockquote>

<p><i>[
post Oxford:  This would be rendered NAD Editorial by acceptance of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2257.html">N2257</a>.
]</i></p>


<p><i>[
Kona (2007): The LWG adopted the proposed resolution of N2387 for this issue which
was subsequently split out into a separate paper N2436 for the purposes of voting.
The resolution in N2436 addresses this issue.  The LWG voted to accelerate this
issue to Ready status to be voted into the WP at Kona.
]</i></p>







<hr>
<h3><a name="635"></a>635. domain of <tt>allocator::address</tt></h3>
<p><b>Section:</b> 20.2.5 [allocator.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2007-02-08 <b>Last modified:</b> 2010-11-20</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#allocator.requirements">issues</a> in [allocator.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The table of allocator requirements in 20.2.5 [allocator.requirements] describes
<tt>allocator::address</tt> as:
</p>
<blockquote><pre>a.address(r)
a.address(s)
</pre></blockquote>
<p>
where <tt>r</tt> and <tt>s</tt> are described as:
</p>
<blockquote><p>
a value of type <tt>X::reference</tt> obtained by the expression <tt>*p</tt>. 
</p></blockquote>

<p>
and <tt>p</tt> is 
</p>

<blockquote><p>
a value of type <tt>X::pointer</tt>, obtained by calling <tt>a1.allocate</tt>, 
where <tt>a1 == a</tt>
</p></blockquote>

<p>
This all implies that to get the address of some value of type <tt>T</tt> that
value must have been allocated by this allocator or a copy of it.
</p>

<p>
However sometimes container code needs to compare the address of an external value of
type <tt>T</tt> with an internal value.  For example <tt>list::remove(const T&amp; t)</tt>
may want to compare the address of the external value <tt>t</tt> with that of a value
stored within the list.  Similarly <tt>vector</tt> or <tt>deque insert</tt> may
want to make similar comparisons (to check for self-referencing calls).
</p>

<p>
Mandating that <tt>allocator::address</tt> can only be called for values which the
allocator allocated seems overly restrictive.
</p>

<p><i>[
post San Francisco:
]</i></p>


<blockquote>
Pablo recommends NAD Editorial, solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2768.pdf">N2768</a>.
</blockquote>

<p><i>[
2009-04-28 Pablo adds:
]</i></p>


<blockquote>
Tentatively-ready NAD Editorial as fixed by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2768.pdf">N2768</a>.
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
Fixed by N2768.
</blockquote>

<p><i>[
2009-07-28 Reopened by Alisdair.  No longer solved by concepts.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
<del>NAD Editorial</del><ins>Resolved</ins>.  Addressed by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2982.pdf">N2982</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 20.2.5 [allocator.requirements]:
</p>

<blockquote>
<p>
<tt>r</tt> : a value of type <tt>X::reference</tt> <del>obtained by the expression *p</del>.
</p>
<p>
<tt>s</tt> : a value of type <tt>X::const_reference</tt> <del>obtained by the 
expression <tt>*q</tt> or by conversion from a value <tt>r</tt></del>.
</p>
</blockquote>

<p><i>[
post Oxford:  This would be rendered NAD Editorial by acceptance of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2257.html">N2257</a>.
]</i></p>


<p><i>[
Kona (2007):  This issue is section 8 of N2387.  There was some discussion of it but
no resolution to this issue was recorded.  Moved to Open.
]</i></p>







<hr>
<h3><a name="638"></a>638. deque end invalidation during erase</h3>
<p><b>Section:</b> 23.3.2.3 [deque.modifiers] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Steve LoBasso <b>Opened:</b> 2007-02-17 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The standard states at 23.3.2.3 [deque.modifiers]/4:
</p>
<blockquote><pre>deque erase(...)
</pre>
 <p>
<i>Effects:</i> ... An erase at either end of the deque invalidates only
the iterators and the references to the erased elements.
</p>
</blockquote>
<p>
This does not state that iterators to end will be invalidated.
It needs to be amended in such a way as to account for end invalidation.
</p>
<p>
Something like:
</p>
<blockquote><p>
Any time the last element is erased, iterators to end are invalidated.
</p></blockquote>

<p>
This would handle situations like:
</p>
<blockquote><pre>erase(begin(), end())
erase(end() - 1)
pop_back()
resize(n, ...) where n &lt; size()
pop_front() with size() == 1

</pre></blockquote>

<p><i>[
Post Kona, Steve LoBasso notes:
]</i></p>


<blockquote>
My only issue with the proposed resolution is that it might not be clear
that <tt>pop_front()</tt> [where <tt>size() == 1</tt>] can invalidate past-the-end
iterators.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 23.3.2.3 [deque.modifiers], p4:
</p>

<blockquote>
<pre>iterator erase(const_iterator position); 
iterator erase(const_iterator first, const_iterator last);
</pre>

<blockquote>
<p>
-4- <i>Effects:</i> An erase in the middle of the <tt>deque</tt>
invalidates all the iterators and references to elements of the
<tt>deque</tt> <ins>and the past-the-end iterator</ins>. An erase at
either end of the <tt>deque</tt> invalidates only the iterators and the
references to the erased elements<ins>, except that erasing at the end
also invalidates the past-the-end iterator</ins>.
</p>
</blockquote>
</blockquote>



<p><i>[
Kona (2007): Proposed wording added and moved to Review.
]</i></p>


<p><i>[
Bellevue:
]</i></p>


<blockquote>
Note that there is existing code that relies on iterators not being
invalidated, but there are also existing implementations that do
invalidate iterators. Thus, such code is not portable in any case. There
is a pop_front() note, which should possibly be a separate issue. Mike
Spertus to evaluate and, if need be, file an issue.
</blockquote>




<hr>
<h3><a name="640"></a>640. 27.6.2.5.2 does not handle (unsigned) long long</h3>
<p><b>Section:</b> 27.7.2.6.2 [ostream.inserters.arithmetic] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2007-02-17 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#ostream.inserters.arithmetic">issues</a> in [ostream.inserters.arithmetic].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The arithmetic inserters are described in 27.7.2.6.2 [ostream.inserters.arithmetic].
Although the section starts with a listing of the inserters including
the new ones:
</p>

<blockquote><pre>operator&lt;&lt;(long long val );
operator&lt;&lt;(unsigned long long val );
</pre></blockquote>

<p>
the text in paragraph 1, which describes the corresponding effects
of the inserters, depending on the actual type of val, does not
handle the types <tt>long long</tt> and <tt>unsigned long long</tt>.
</p>

<p><i>[
Alisdair: In addition to the (unsigned) long long problem, that whole paragraph
misses any reference to extended integral types supplied by the
implementation - one of the additions by core a couple of working papers
back.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
In 27.7.2.6.2 [ostream.inserters.arithmetic]/1 change the third sentence
</p>

<blockquote>
When val is of type <tt>bool</tt>, <tt>long</tt>, <tt>unsigned
long</tt>, <ins>long long, unsigned long long,</ins> <tt>double</tt>,
<tt>long double</tt>, or <tt>const void*</tt>, the formatting conversion
occurs as if it performed the following code fragment:
</blockquote>





<hr>
<h3><a name="643"></a>643. Impossible "as if" clauses</h3>
<p><b>Section:</b> 27.9.1.1 [filebuf], 22.4.2.2.2 [facet.num.put.virtuals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2007-02-20 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The current standard 14882:2003(E) as well as N2134 have the
following
defects:
</p>

<p>
27.9.1.1 [filebuf]/5 says:
</p>

<blockquote>
<p>
In order to support file I/O and multibyte/wide character conversion, conversions are performed using members of a 
facet, referred to as <tt><i>a_codecvt</i></tt> in following sections, obtained "as if" by
</p>
<blockquote><pre>codecvt&lt;charT,char,typename traits::state_type&gt; <i>a_codecvt</i> =
  use_facet&lt;codecvt&lt;charT,char,typename traits::state_type&gt; &gt;(getloc());
</pre></blockquote>
</blockquote>

<p>
<tt>use_facet</tt> returns a <tt>const facet</tt> reference and no facet is
copyconstructible, so the codecvt construction should fail to compile.
</p>

<p>
A similar issue arises in 22.4.2.2.2 [facet.num.put.virtuals]/15 for <tt>num_punct</tt>.
</p>


<p><b>Proposed resolution:</b></p>
<p>
In 27.9.1.1 [filebuf]/5 change the "as if" code
</p>

<blockquote><pre><ins>const </ins>codecvt&lt;charT,char,typename traits::state_type&gt;<ins>&amp;</ins> <i>a_codecvt</i> =
  use_facet&lt;codecvt&lt;charT,char,typename traits::state_type&gt; &gt;(getloc());
</pre></blockquote>

<p>
In 22.4.2.2.2 [facet.num.put.virtuals]/15 (This is para 5 in N2134) change
</p>

<blockquote>
<p>
A local variable <tt><i>punct</i></tt> is initialized via
</p>
<blockquote><pre><ins>const </ins>numpunct&lt;charT&gt;<ins>&amp;</ins> <i>punct</i> = use_facet&lt; numpunct&lt;charT&gt; &gt;(<i>str</i>.getloc() )<ins>;</ins>
</pre></blockquote>
</blockquote>

<p>
(Please note also the additional provided trailing semicolon)
</p>






<hr>
<h3><a name="646"></a>646. const incorrect match_result members</h3>
<p><b>Section:</b> 28.10.5 [re.results.form] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2007-02-26 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
28.10.5 [re.results.form] (root and para 3) in N2134 defines the two function template
members format as non-const functions, although they are declared
as const in 28.10 [re.results]/3.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add the missing <tt>const</tt> specifier to both <tt>format</tt> overloads described
in section 28.10.5 [re.results.form].
</p>





<hr>
<h3><a name="650"></a>650. regex_token_iterator and const correctness</h3>
<p><b>Section:</b> 28.12.2 [re.tokiter] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2007-03-05 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#re.tokiter">issues</a> in [re.tokiter].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Both the class definition of regex_token_iterator (28.12.2 [re.tokiter]/6) and the latter member specifications (28.12.2.2 [re.tokiter.comp]/1+2) declare both comparison operators as
non-const functions. Furtheron, both dereference operators are
unexpectedly also declared as non-const in 28.12.2 [re.tokiter]/6
as well as in (28.12.2.3 [re.tokiter.deref]/1+2).
</p>


<p><b>Proposed resolution:</b></p>
<p>
1) In (28.12.2 [re.tokiter]/6) change the current declarations
</p>

<blockquote><pre>bool operator==(const regex_token_iterator&amp;) <ins>const</ins>;
bool operator!=(const regex_token_iterator&amp;) <ins>const</ins>;
const value_type&amp; operator*() <ins>const</ins>;
const value_type* operator-&gt;() <ins>const</ins>;
</pre></blockquote>

<p>
2) In 28.12.2.2 [re.tokiter.comp] change the following declarations
</p>

<blockquote><pre>bool operator==(const regex_token_iterator&amp; right) <ins>const</ins>;
bool operator!=(const regex_token_iterator&amp; right) <ins>const</ins>;
</pre></blockquote>

<p>
3) In 28.12.2.3 [re.tokiter.deref] change the following declarations
</p>

<blockquote><pre>const value_type&amp; operator*() <ins>const</ins>;
const value_type* operator-&gt;() <ins>const</ins>;
</pre></blockquote>


<p><i>[
Kona (2007): The LWG adopted the proposed resolution of N2409 for this issue (which
is to adopt the proposed wording in this issue).
The LWG voted to accelerate this issue to Ready status to be voted into the WP at Kona.
]</i></p>





<hr>
<h3><a name="651"></a>651. Missing preconditions for regex_token_iterator c'tors</h3>
<p><b>Section:</b> 28.12.2.1 [re.tokiter.cnstr] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2007-03-05 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#re.tokiter.cnstr">issues</a> in [re.tokiter.cnstr].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The text provided in 28.12.2.1 [re.tokiter.cnstr]/2+3 describes
the effects of the three non-default constructors of class
template regex_token_iterator but is does not clarify which values
are legal values for submatch/submatches. This becomes
an issue, if one takes 28.12.2 [re.tokiter]/9 into account, which explains
the notion of a "current match" by saying:
</p>

<blockquote><p>
The <i>current match</i> is <tt>(*position).prefix()</tt> if <tt>subs[N]
== -1</tt>, or <tt>(*position)[subs[N]]</tt> for any other value of
<tt>subs[N]</tt>.
</p></blockquote>

<p>
It's not clear to me, whether other negative values except -1
are legal arguments or not - it seems they are not.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add the following precondition paragraph just before the current
28.12.2.1 [re.tokiter.cnstr]/2:
</p>

<blockquote><p>
<i>Requires:</i> Each of the initialization values of <tt>subs</tt> must be <tt>&gt;= -1</tt>.
</p></blockquote>


<p><i>[
Kona (2007): The LWG adopted the proposed resolution of N2409 for this issue (which
is to adopt the proposed wording in this issue).
The LWG voted to accelerate this issue to Ready status to be voted into the WP at Kona.
]</i></p>





<hr>
<h3><a name="652"></a>652. regex_iterator and const correctness</h3>
<p><b>Section:</b> 28.12.1 [re.regiter] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2007-03-05 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Both the class definition of regex_iterator (28.12.1 [re.regiter]/1) and the latter member specification (28.12.1.2 [re.regiter.comp]/1+2) declare both comparison operators as
non-const functions. Furtheron, both dereference operators are
unexpectedly also declared as non-const in 28.12.1 [re.regiter]/1
as well as in (28.12.1.3 [re.regiter.deref]/1+2).
</p>


<p><b>Proposed resolution:</b></p>
<p>
1) In (28.12.1 [re.regiter]/1) change the current declarations
</p>

<blockquote><pre>bool operator==(const regex_iterator&amp;) <ins>const</ins>;
bool operator!=(const regex_iterator&amp;) <ins>const</ins>;
const value_type&amp; operator*() <ins>const</ins>;
const value_type* operator-&gt;() <ins>const</ins>;
</pre></blockquote>

<p>
2) In 28.12.1.3 [re.regiter.deref] change the following declarations
</p>

<blockquote><pre>const value_type&amp; operator*() <ins>const</ins>;
const value_type* operator-&gt;() <ins>const</ins>;
</pre></blockquote>

<p>
3) In 28.12.1.2 [re.regiter.comp] change the following declarations
</p>

<blockquote><pre>bool operator==(const regex_iterator&amp; right) <ins>const</ins>;
bool operator!=(const regex_iterator&amp; right) <ins>const</ins>;
</pre></blockquote>


<p><i>[
Kona (2007): The LWG adopted the proposed resolution of N2409 for this issue (which
is to adopt the proposed wording in this issue).
The LWG voted to accelerate this issue to Ready status to be voted into the WP at Kona.
]</i></p>





<hr>
<h3><a name="654"></a>654. Missing IO roundtrip for random number engines</h3>
<p><b>Section:</b> 26.5.1.4 [rand.req.eng] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2007-03-08 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.req.eng">issues</a> in [rand.req.eng].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Table 98 and para 5 in 26.5.1.4 [rand.req.eng] specify
the IO insertion and extraction semantic of random
number engines. It can be shown, v.i., that the specification
of the extractor cannot guarantee to fulfill the requirement
from para 5:
</p>

<blockquote><p>
If a textual representation written via os &lt;&lt; x was
subsequently read via is &gt;&gt; v, then x == v provided that
there have been no intervening invocations of x or of v.
</p></blockquote>

<p>
The problem is, that the extraction process described in
table 98 misses to specify that it will initially set the
if.fmtflags to ios_base::dec, see table 104:
</p>

<blockquote><p>
dec: converts integer input or generates integer output
in decimal base
</p></blockquote>

<p>
Proof: The following small program demonstrates the violation
of requirements (exception safety not fulfilled):
</p>

<blockquote><pre>#include &lt;cassert&gt;
#include &lt;ostream&gt;
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;sstream&gt;

class RanNumEngine {
  int state;
public:
  RanNumEngine() : state(42) {}

  bool operator==(RanNumEngine other) const {
      return state == other.state;
  }

  template &lt;typename Ch, typename Tr&gt;
  friend std::basic_ostream&lt;Ch, Tr&gt;&amp; operator&lt;&lt;(std::basic_ostream&lt;Ch, Tr&gt;&amp; os, RanNumEngine engine) {
    Ch old = os.fill(os.widen(' ')); // Sets space character
    std::ios_base::fmtflags f = os.flags();
    os &lt;&lt; std::dec &lt;&lt; std::left &lt;&lt; engine.state; // Adds ios_base::dec|ios_base::left
    os.fill(old); // Undo
    os.flags(f);
    return os;
  }

  template &lt;typename Ch, typename Tr&gt;
  friend std::basic_istream&lt;Ch, Tr&gt;&amp; operator&gt;&gt;(std::basic_istream&lt;Ch, Tr&gt;&amp; is, RanNumEngine&amp; engine) {
       // Uncomment only for the fix.

    //std::ios_base::fmtflags f = is.flags();
    //is &gt;&gt; std::dec;
    is &gt;&gt; engine.state;
    //is.flags(f);
    return is;
  }
};

int main() {
    std::stringstream s;
    s &lt;&lt; std::setfill('#'); // No problem
        s &lt;&lt; std::oct; // Yikes!
        // Here starts para 5 requirements:
    RanNumEngine x;
    s &lt;&lt; x;
    RanNumEngine v;
    s &gt;&gt; v;
    assert(x == v); // Fails: 42 == 34
}
</pre></blockquote>

<p>
A second, minor issue seems to be, that the insertion
description from table 98 unnecessarily requires the
addition of ios_base::fixed (which only influences floating-point
numbers). Its not entirely clear to me whether the proposed
standard does require that the state of random number engines
is stored in integral types or not, but I have the impression
that this is the indent, see e.g. p. 3
</p>

<blockquote><p>
The specification of each random number engine defines the
size of its state in multiples of the size of its result_type.
</p></blockquote>

<p>
If other types than integrals are supported, then I wonder why
no requirements are specified for the precision of the stream.
</p>

<p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2391.pdf">N2391</a> and
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2423.pdf">N2423</a>
for some further discussion.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Adopt the proposed resolution in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2423.pdf">N2423</a>.
</p>


<p><i>[
Kona (2007): The LWG adopted the proposed resolution of N2423 for this issue.
The LWG voted to accelerate this issue to Ready status to be voted into the WP at Kona.
]</i></p>





<hr>
<h3><a name="655"></a>655. Signature of generate_canonical not useful</h3>
<p><b>Section:</b> 26.5.7.2 [rand.util.canonical] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2007-03-08 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.util.canonical">issues</a> in [rand.util.canonical].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 26.5.2 [rand.synopsis] we have the declaration
</p>

<blockquote><pre>template&lt;class RealType, class UniformRandomNumberGenerator,
  size_t bits&gt;
result_type generate_canonical(UniformRandomNumberGenerator&amp; g);
</pre></blockquote>

<p>
Besides the "result_type" issue (already recognized by Bo Persson
at Sun, 11 Feb 2007 05:26:47 GMT in this group) it's clear, that
the template parameter order is not reasonably choosen: Obviously
one always needs to specify all three parameters, although usually
only two are required, namely the result type RealType and the
wanted bits, because UniformRandomNumberGenerator can usually
be deduced.
</p>

<p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2391.pdf">N2391</a> and
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2423.pdf">N2423</a>
for some further discussion.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Adopt the proposed resolution in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2423.pdf">N2423</a>.
</p>


<p><i>[
Kona (2007): The LWG adopted the proposed resolution of N2423 for this issue.
The LWG voted to accelerate this issue to Ready status to be voted into the WP at Kona.
]</i></p>





<hr>
<h3><a name="658"></a>658. Two unspecified function comparators in [function.objects]</h3>
<p><b>Section:</b> 20.8 [function.objects] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2007-03-19 <b>Last modified:</b> 2010-11-19</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#function.objects">issues</a> in [function.objects].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The header <tt>&lt;functional&gt;</tt> synopsis in 20.8 [function.objects]
contains the following two free comparison operator templates
for the <tt>function</tt> class template
</p>

<blockquote><pre>template&lt;class Function1, class Function2&gt;
void operator==(const function&lt;Function1&gt;&amp;, const function&lt;Function2&gt;&amp;);
template&lt;class Function1, class Function2&gt;
void operator!=(const function&lt;Function1&gt;&amp;, const function&lt;Function2&gt;&amp;);
</pre></blockquote>

<p>
which are nowhere described. I assume that they are relicts before the
corresponding two private and undefined member templates in the function
template (see 20.8.14.2 [func.wrap.func] and  [func.wrap.func.undef]) have been introduced. The original free
function templates should be removed, because using an undefined entity
would lead to an ODR violation of the user.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Remove the above mentioned two function templates from
the header <tt>&lt;functional&gt;</tt> synopsis (20.8 [function.objects])
</p>

<blockquote><pre><del>template&lt;class Function1, class Function2&gt;
void operator==(const function&lt;Function1&gt;&amp;, const function&lt;Function2&gt;&amp;);
template&lt;class Function1, class Function2&gt;
void operator!=(const function&lt;Function1&gt;&amp;, const function&lt;Function2&gt;&amp;);</del>
</pre></blockquote>



<p><b>Rationale:</b></p>
Fixed by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2292.html">N2292</a>
Standard Library Applications for Deleted Functions.





<hr>
<h3><a name="659"></a>659. istreambuf_iterator should have an operator-&gt;()</h3>
<p><b>Section:</b> 24.6.3 [istreambuf.iterator] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Niels Dekker <b>Opened:</b> 2007-03-25 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#istreambuf.iterator">issues</a> in [istreambuf.iterator].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Greg Herlihy has clearly demonstrated that a user defined input
iterator should have an operator-&gt;(), even if its
value type is a built-in type (comp.std.c++, "Re: Should any iterator
have an operator-&gt;() in C++0x?", March 2007).  And as Howard
Hinnant remarked in the same thread that the input iterator
<tt>istreambuf_iterator</tt> doesn't have one, this must be a
defect!
</p>
<p>
Based on Greg's example, the following code demonstrates the issue:
</p><pre> #include &lt;iostream&gt; 
 #include &lt;fstream&gt;
 #include &lt;streambuf&gt; 

 typedef char C;
 int main ()
 {
   std::ifstream s("filename", std::ios::in);
   std::istreambuf_iterator&lt;char&gt; i(s);

   (*i).~C();  // This is well-formed...
   i-&gt;~C();  // ... so this should be supported!
 }
</pre>
<p></p>
<p>
Of course, operator-&gt; is also needed when the value_type of
istreambuf_iterator is a class.
</p>
<p>
The operator-&gt; could be implemented in various ways.  For instance,
by storing the current value inside the iterator, and returning its
address.  Or by returning a proxy, like operator_arrow_proxy, from
<a href="http://www.boost.org/boost/iterator/iterator_facade.hpp">http://www.boost.org/boost/iterator/iterator_facade.hpp</a>
</p>
<p>
I hope that the resolution of this issue will contribute to getting a
clear and consistent definition of iterator concepts.
</p>

<p><i>[
Kona (2007): The proposed resolution is inconsistent because the return
type of <tt>istreambuf_iterator::operator-&gt;()</tt> is specified to be <tt>pointer</tt>,
but the proposed text also states that "<tt>operator-&gt;</tt> may return a proxy."
]</i></p>


<p><i>[
Niels Dekker (mailed to Howard Hinnant):
]</i></p>

<blockquote>
<p>
The proposed resolution does
not seem inconsistent to me. <tt>istreambuf_iterator::operator-&gt;()</tt> should
have <tt>istreambuf_iterator::pointer</tt> as return type, and this return type
may in fact be a proxy.
</p>
<p>
AFAIK, the resolution of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#445">445</a> ("<tt>iterator_traits::reference</tt>
unspecified for some iterator categories") implies that for any iterator
class <tt>Iter</tt>, the return type of <tt>operator-&gt;()</tt> is <tt>Iter::pointer</tt>, by
definition.  I don't think <tt>Iter::pointer</tt> needs to be a raw pointer.
</p>
<p>
Still I wouldn't mind if the text "<tt>operator-&gt;</tt> may return a proxy" would
be removed from the resolution. I think it's up to the library
implementation, how to implement <tt>istreambuf_iterator::operator-&gt;()</tt>.  As
longs as it behaves as expected: <tt>i-&gt;m</tt> should have the same effect as
<tt>(*i).m</tt>. Even for an explicit destructor call, <tt>i-&gt;~C()</tt>.  The main issue
is just: <tt>istreambuf_iterator</tt> should have an <tt>operator-&gt;()</tt>!
</p>
</blockquote>

<p><i>[
2009-04-30 Alisdair adds:
]</i></p>


<blockquote>
Note that operator-&gt; is now a requirement in the <tt>InputIterator</tt> concept, so
this issue cannot be ignored or existing valid programs will break when
compiled with an 0x library.
</blockquote>

<p><i>[
2009-05-29 Alisdair adds:
]</i></p>


<blockquote>
<p>
I agree with the observation that in principle the type 'pointer' may be a
proxy, and the words highlighting this are redundant.
</p>
<p>
However, in the current draught <tt>pointer</tt> is required to be exactly '<tt>charT *</tt>'
by the derivation from <tt>std::iterator</tt>.  At a minimum, the 4th parameter of
this base class template should become unspecified.  That permits the
introduction of a proxy as a nested class in some further undocumented (not
even exposition-only) base.
</p>
<p>
It also permits the <tt>istream_iterator</tt> approach where the cached value is
stored in the iterator itself, and the iterator serves as its own proxy for
post-increment <tt>operator++</tt> - removing the need for the existing
exposition-only nested class <tt>proxy</tt>.
</p>
<p>
Note that the current <tt>proxy</tt> class also has exactly the right properties to
serve as the pointer <tt>proxy</tt> too.  This is likely to be a common case where an
<tt>InputIterator</tt> does not hold internal state but delegates to another class.
</p>
<p>
Proposed Resolution:
</p>
<p>
In addition to the current proposal:
</p>
<p>
24.6.3 [istreambuf.iterator]
</p>
<blockquote><pre>template&lt;class charT, class traits = char_traits&lt;charT&gt; &gt;
class istreambuf_iterator
  : public iterator&lt;input_iterator_tag, charT,
                    typename traits::off_type, <del>charT*</del> <ins><i>unspecified</i></ins>, charT&gt; {
</pre></blockquote>
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
Move the additional part into the proposed resolution, and wrap the
descriptive text in a Note.
</p>
<p><i>[Howard: done.]</i></p>

<p>
Move to Ready.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add to the synopsis in 24.6.3 [istreambuf.iterator]:
</p>

<blockquote><pre>charT operator*() const;
<ins>pointer operator-&gt;() const;</ins>
istreambuf_iterator&lt;charT,traits&gt;&amp; operator++();
</pre></blockquote>

<p>
24.6.3 [istreambuf.iterator]
</p>

<blockquote><pre>template&lt;class charT, class traits = char_traits&lt;charT&gt; &gt;
class istreambuf_iterator
  : public iterator&lt;input_iterator_tag, charT,
                    typename traits::off_type, <del>charT*</del> <ins><i>unspecified</i></ins>, charT&gt; {
</pre></blockquote>

<p>
Change 24.6.3 [istreambuf.iterator], p1:
</p>

<blockquote><p>
The class template <tt>istreambuf_iterator</tt> reads successive
characters from the <tt>streambuf</tt> for which it was constructed.
<tt>operator*</tt> provides access to the current input character, if
any. <ins>[<i>Note:</i> <tt>operator-&gt;</tt> may return a proxy. 
<i>end note</i>]</ins> Each time
<tt>operator++</tt> is evaluated, the iterator advances to the next
input character. If the end of stream is reached
(<tt>streambuf_type::sgetc()</tt> returns <tt>traits::eof()</tt>), the
iterator becomes equal to the end of stream iterator value. The default
constructor <tt>istreambuf_iterator()</tt> and the constructor
<tt>istreambuf_iterator(0)</tt> both construct an end of stream iterator
object suitable for use as an end-of-range.
</p></blockquote>







<hr>
<h3><a name="660"></a>660. Missing Bitwise Operations</h3>
<p><b>Section:</b> 20.8 [function.objects] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Beman Dawes <b>Opened:</b> 2007-04-02 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#function.objects">issues</a> in [function.objects].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>Section 20.8 [function.objects] provides <span id="st" name="st" class="st">function</span>
<span id="st" name="st" class="st">objects</span> for some unary and binary 
operations, but others are missing. In a LWG reflector discussion, beginning 
with c++std-lib-18078, pros and cons of adding some of the missing operations 
were discussed. Bjarne Stroustrup commented "Why standardize what isn't used? 
Yes, I see the chicken and egg problems here, but it would be nice to see a 
couple of genuine uses before making additions."</p>
<p>A number of libraries, including Rogue Wave, GNU, Adobe ASL, and Boost, have 
already added these functions, either publicly or for internal use. For example, 
Doug Gregor commented: "Boost will also add ... (|, &amp;, ^) in 1.35.0, because we 
need those <span id="st" name="st" class="st">function</span>
<span id="st" name="st" class="st">objects</span> to represent various parallel 
collective operations (reductions, prefix reductions, etc.) in the new Message 
Passing Interface (MPI) library."</p>
<p>Because the bitwise operators have the strongest use cases, the proposed 
resolution is limited to them.</p>


<p><b>Proposed resolution:</b></p>
<p>To 20.8 [function.objects], Function objects, paragraph 2, add to the header 
&lt;functional&gt; synopsis:</p>
<blockquote>
  <pre>template &lt;class T&gt; struct bit_and;
template &lt;class T&gt; struct bit_or;
template &lt;class T&gt; struct bit_xor;</pre>
</blockquote>
<p>At a location in clause 20 to be determined by the Project Editor, add:</p>
<blockquote>
  <p>The library provides basic function object classes for all of the bitwise 
  operators in the language ([expr.bit.and], [expr.or], [exp.xor]).</p>
  <pre>template &lt;class T&gt; struct bit_and : binary_function&lt;T,T,T&gt; {
  T operator()(const T&amp; x , const T&amp; y ) const;
};</pre>
  <blockquote>
    <p><code>operator()</code> returns<code> x &amp; y</code> .</p>
  </blockquote>
  <pre>template &lt;class T&gt; struct bit_or : binary_function&lt;T,T,T&gt; {
  T operator()(const T&amp; x , const T&amp; y ) const;
};</pre>
  <blockquote>
    <p><code>operator()</code> returns <code>x | y</code> .</p>
  </blockquote>
  <pre>template &lt;class T&gt; struct bit_xor : binary_function&lt;T,T,T&gt; {
  T operator()(const T&amp; x , const T&amp; y ) const;
};</pre>
  <blockquote>
    <p><code>operator()</code> returns <code>x ^ y</code> .</p>
  </blockquote>
</blockquote>





<hr>
<h3><a name="661"></a>661. New 27.6.1.2.2 changes make special extractions useless</h3>
<p><b>Section:</b> 27.7.1.2.2 [istream.formatted.arithmetic] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2007-04-01 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#istream.formatted.arithmetic">issues</a> in [istream.formatted.arithmetic].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
To the more drastic changes of 27.7.1.2.2 [istream.formatted.arithmetic] in the current draft N2134 belong
the explicit description of the extraction of the types short and int in
terms of as-if code fragments.
</p>

<ol>
<li>
The corresponding as-if extractions in paragraph 2 and 3 will never
result in a change of the operator&gt;&gt; argument val, because the
contents of the local variable lval is in no case written into val.
Furtheron both fragments need a currently missing parentheses in the
beginning of the if-statement to be valid C++.
</li>
<li>
I would like to ask whether the omission of a similar explicit
extraction of unsigned short and unsigned int in terms of long -
compared to their corresponding new insertions, as described in 27.7.2.6.2 [ostream.inserters.arithmetic], is a deliberate decision or an
oversight.
</li>
</ol>


<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>
In 27.7.1.2.2 [istream.formatted.arithmetic]/2 change the current as-if code fragment
</p>
<blockquote><pre>typedef num_get&lt;charT,istreambuf_iterator&lt;charT,traits&gt; &gt; numget;
iostate err = 0;
long lval;
use_facet&lt;numget&gt;(loc).get(*this, 0, *this, err, lval );
if (err == 0) <ins>{</ins>
  <del>&amp;&amp;</del> <ins>if</ins> (lval &lt; numeric_limits&lt;short&gt;::min() || numeric_limits&lt;short&gt;::max() &lt; lval)<del>)</del>
      err = ios_base::failbit;
  <ins>else
    val = static_cast&lt;short&gt;(lval);
}</ins>
setstate(err);
</pre></blockquote>

<p>
Similarily in 27.7.1.2.2 [istream.formatted.arithmetic]/3 change the current as-if fragment
</p>

<blockquote><pre>typedef num_get&lt;charT,istreambuf_iterator&lt;charT,traits&gt; &gt; numget;
iostate err = 0;
long lval;
use_facet&lt;numget&gt;(loc).get(*this, 0, *this, err, lval );
if (err == 0) <ins>{</ins>
  <del>&amp;&amp;</del> <ins>if</ins> (lval &lt; numeric_limits&lt;int&gt;::min() || numeric_limits&lt;int&gt;::max() &lt; lval)<del>)</del>
      err = ios_base::failbit;
  <ins>else
    val = static_cast&lt;int&gt;(lval);
}</ins>
setstate(err);
</pre></blockquote>
</li>
<li>
---
</li>
</ol>


<p><i>[
Kona (2007): Note to the editor: the name lval in the call to <tt>use_facet</tt>
is incorrectly italicized in the code fragments corresponding to
<tt>operator&gt;&gt;(short &amp;)</tt> and <tt>operator &gt;&gt;(int &amp;)</tt>. Also, val -- which appears
twice on the line with the <tt>static_cast</tt> in the proposed resolution --
should be italicized. Also, in response to part two of the issue: this
is deliberate.
]</i></p>





<hr>
<h3><a name="664"></a>664. <tt>do_unshift</tt> for <tt>codecvt&lt;char, char, mbstate_t&gt;</tt></h3>
<p><b>Section:</b> 22.4.1.4.2 [locale.codecvt.virtuals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Thomas Plum <b>Opened:</b> 2007-04-16 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.codecvt.virtuals">issues</a> in [locale.codecvt.virtuals].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
22.4.1.4.2 [locale.codecvt.virtuals], para 7 says (regarding <tt>do_unshift</tt>):
</p>

<blockquote><p>
<i>Effects:</i> Places characters starting at to that should be appended to
terminate a sequence when the current <tt>stateT</tt> is given by
<tt><i>state</i></tt>.<sup>237)</sup> Stores no more than <tt>(<i>to_limit</i> -
<i>to</i>)</tt> destination elements, and leaves the <tt><i>to_next</i></tt>
pointer pointing one beyond the last element successfully stored.
<em><tt>codecvt&lt;char, char, mbstate_t&gt;</tt> stores no characters.</em>
</p></blockquote>

<p>
The following objection has been raised:
</p>

<blockquote><p>
Since the C++ Standard permits a nontrivial conversion for the required
instantiations of <tt>codecvt</tt>, it is overly restrictive to say that
<tt>do_unshift</tt> must store no characters and return <tt>noconv</tt>.
</p></blockquote>

<p>
[Plum ref _222152Y50]
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change 22.4.1.4.2 [locale.codecvt.virtuals], p7:
</p>

<blockquote>
<p>
<i>Effects:</i> Places characters starting at <i>to</i> that should be
appended to terminate a sequence when the current <tt>stateT</tt> is
given by state.<sup>237)</sup> Stores no more than (<i>to_limit -to</i>)
destination elements, and leaves the <i>to_next</i> pointer pointing one
beyond the last element successfully stored. <del><tt>codecvt&lt;char, char,
mbstate_t&gt;</tt> stores no characters.</del>
</p>
</blockquote>





<hr>
<h3><a name="665"></a>665. <tt>do_unshift</tt> return value</h3>
<p><b>Section:</b> 22.4.1.4.2 [locale.codecvt.virtuals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Thomas Plum <b>Opened:</b> 2007-04-16 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.codecvt.virtuals">issues</a> in [locale.codecvt.virtuals].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
22.4.1.4.2 [locale.codecvt.virtuals], para 8 says:
</p>

<blockquote><p>
<tt>codecvt&lt;char,char,mbstate_t&gt;</tt>, returns <tt>noconv</tt>.
</p></blockquote>

<p>
The following objection has been raised:
</p>

<blockquote><p>
Despite what the C++ Standard 
says, <tt>unshift</tt> can't always return <tt>noconv</tt> for the default facets, since 
they can be nontrivial. At least one implementation does whatever the 
C functions do.
</p></blockquote>

<p>
[Plum ref _222152Y62]
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change 22.4.1.4.2 [locale.codecvt.virtuals], p8:
</p>

<blockquote>
<p><i>Returns:</i> An enumeration value, as summarized in Table 76:</p>
<p>...</p>
<p>
<del><tt>codecvt&lt;char,char,mbstate_t&gt;</tt>, returns <tt>noconv</tt>.</del>
</p>
</blockquote>






<hr>
<h3><a name="666"></a>666. <tt>moneypunct::do_curr_symbol()</tt></h3>
<p><b>Section:</b> 22.4.6.3.2 [locale.moneypunct.virtuals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Thomas Plum <b>Opened:</b> 2007-04-16 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.moneypunct.virtuals">issues</a> in [locale.moneypunct.virtuals].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
22.4.6.3.2 [locale.moneypunct.virtuals], para 4 footnote 257 says
</p>

<blockquote><p>
<sup>257)</sup> For international 
specializations (second template parameter <tt>true</tt>) this is always four 
characters long, usually three letters and a space.
</p></blockquote>

<p>
The following objection has been raised:
</p>

<blockquote><p>
The international currency 
symbol is whatever the underlying locale says it is, not necessarily 
four characters long.
</p></blockquote>

<p>
[Plum ref _222632Y41]
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change footnote 253 in 22.4.6.3.2 [locale.moneypunct.virtuals]:
</p>

<blockquote>
<p>
<sup>253)</sup> For international specializations (second template
parameter <tt>true</tt>) this is <del>always</del> <ins>typically</ins>
four characters long, usually three letters and a space.
</p>
</blockquote>





<hr>
<h3><a name="671"></a>671. precision of hexfloat</h3>
<p><b>Section:</b> 22.4.2.2.2 [facet.num.put.virtuals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> John Salmon <b>Opened:</b> 2007-04-20 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#facet.num.put.virtuals">issues</a> in [facet.num.put.virtuals].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I am trying to understand how TR1 supports hex float (%a) output.
</p>
<p>
As far as I can tell, it does so via the following:
</p>
<p>
8.15 Additions to header &lt;locale&gt; [tr.c99.locale]
</p>
<p>
In subclause 22.4.2.2.2 [facet.num.put.virtuals], Table 58 Floating-point conversions, after
the line:
floatfield == ios_base::scientific %E
</p>
<p>
add the two lines:
</p>
<blockquote><pre>floatfield == ios_base::fixed | ios_base::scientific &amp;&amp; !uppercase %a
floatfield == ios_base::fixed | ios_base::scientific %A 2
</pre></blockquote>
<p>
[Note: The additional requirements on print and scan functions, later
in this clause, ensure that the print functions generate hexadecimal
floating-point fields with a %a or %A conversion specifier, and that
the scan functions match hexadecimal floating-point fields with a %g
conversion specifier.  end note]
</p>
<p>
Following the thread, in 22.4.2.2.2 [facet.num.put.virtuals], we find:
</p>
<p>
For conversion from a floating-point type, if (flags &amp; fixed) != 0 or
if str.precision() &gt; 0, then str.precision() is specified in the
conversion specification.
</p>
<p>
This would seem to imply that when floatfield == fixed|scientific, the
precision of the conversion specifier is to be taken from
str.precision().  Is this really what's intended?  I sincerely hope
that I'm either missing something or this is an oversight.  Please
tell me that the committee did not intend to mandate that hex floats
(and doubles) should by default be printed as if by %.6a.
</p>

<p><i>[
Howard: I think the fundamental issue we overlooked was that with %f,
%e, %g, the default precision was always 6.  With %a the default
precision is not 6, it is infinity.  So for the first time, we need to
distinguish between the default value of precision, and the precision
value 6.
]</i></p>


<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
Leave this open for Robert and Daniel to work on.
</p>
<p>
Straw poll: Disposition?
</p>
<ul>
<li>Default is %.6a (i.e. NAD): 2</li>
<li>Always %a (no precision): 6</li>
<li>precision(-1) == %a: 3</li>
</ul>
<p>
Daniel and Robert have direction to write up wording for the "always %a" solution.
</p>

<p><i>[
2009-07-15 Robert provided wording.
]</i></p>

</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Move to Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 22.4.2.2.2 [facet.num.put.virtuals], Stage 1, under p5 (near the end
of Stage 1):
</p>

<blockquote>
For conversion from a floating-point type, <tt>str.precision()</tt> is specified
<ins>as precision</ins> in the conversion specification
<ins>if <tt>floatfield != (ios_base::fixed | ios_base::scientific)</tt>, else no
precision is specified</ins>.
</blockquote>



<p><i>[
Kona (2007): Robert volunteers to propose wording.
]</i></p>





<hr>
<h3><a name="672"></a>672. Swappable requirements need updating</h3>
<p><b>Section:</b> 20.2.1 [utility.arg.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2007-05-04 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#utility.arg.requirements">issues</a> in [utility.arg.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The current <tt>Swappable</tt> is:
</p>

<blockquote>
<table border="1">
<caption>Table 37: <tt>Swappable</tt> requirements <b>[swappable]</b></caption>
<tbody><tr><th>expression</th><th>return type</th><th>post-condition</th></tr>
<tr><td><tt>swap(s,t)</tt></td><td><tt>void</tt></td><td><tt>t</tt> has the value originally held by <tt>u</tt>, and <tt>u</tt> has the value originally 
held by <tt>t</tt></td></tr>
<tr><td colspan="3">
<p>
The Swappable requirement is met by satisfying one or more of the following conditions:
</p>
<ul>
<li>
<tt>T</tt> is Swappable if <tt>T</tt> satisfies the <tt>CopyConstructible</tt> requirements (Table 34) 
and the <tt>CopyAssignable</tt> requirements (Table 36);
</li>
<li>
<tt>T</tt> is Swappable if a namespace scope function named <tt>swap</tt> exists in the same 
namespace as the definition of <tt>T</tt>, such that the expression <tt>swap(t,u)</tt> is valid 
and has the semantics described in this table.
</li>
</ul>
</td></tr>
</tbody></table>
</blockquote>

<p>
With the passage of rvalue reference into the language, <tt>Swappable</tt> needs to be updated to
require only <tt>MoveConstructible</tt> and <tt>MoveAssignable</tt>.  This is a minimum.
</p>

<p>
Additionally we may want to support proxy references such that the following code is acceptable:
</p>

<blockquote><pre>namespace Mine {

template &lt;class T&gt;
struct proxy {...};

template &lt;class T&gt;
struct proxied_iterator
{
   typedef T value_type;
   typedef proxy&lt;T&gt; reference;
   reference operator*() const;
   ...
};

struct A
{
   // heavy type, has an optimized swap, maybe isn't even copyable or movable, just swappable
   void swap(A&amp;);
   ...
};

void swap(A&amp;, A&amp;);
void swap(proxy&lt;A&gt;, A&amp;);
void swap(A&amp;, proxy&lt;A&gt;);
void swap(proxy&lt;A&gt;, proxy&lt;A&gt;);

}  // Mine

...

Mine::proxied_iterator&lt;Mine::A&gt; i(...)
Mine::A a;
swap(*i1, a);
</pre></blockquote>

<p>
I.e. here is a call to <tt>swap</tt> which the user enables swapping between a proxy to a class and the class
itself.  We do not need to anything in terms of implementation except not block their way with overly
constrained concepts.  That is, the <tt>Swappable</tt> concept should be expanded to allow swapping
between two different types for the case that one is binding to a user-defined <tt>swap</tt>.
</p>



<p><b>Proposed resolution:</b></p>

<p>
Change 20.2.1 [utility.arg.requirements]:
</p>

<blockquote>

<p>
-1- The template definitions in the C++ Standard Library refer to various
named requirements whose details are set out in tables 31-38. In these
tables, <tt>T</tt> is a type to be supplied by a C++ program
instantiating a template; <tt>a</tt>, <tt>b</tt>, and <tt>c</tt> are
values of type <tt>const T</tt>; <tt>s</tt> and <tt>t</tt> are modifiable
lvalues of type <tt>T</tt>; <tt>u</tt> is a value of type (possibly
<tt>const</tt>) <tt>T</tt>; and <tt>rv</tt> is a non-<tt>const</tt>
rvalue of type <tt>T</tt>.
</p>

<table border="1">
<caption>Table 37: <tt>Swappable</tt> requirements <b>[swappable]</b></caption>
<tbody><tr><th>expression</th><th>return type</th><th>post-condition</th></tr>
<tr><td><tt>swap(s,t)</tt></td><td><tt>void</tt></td>
<td><tt>t</tt> has the value originally
held by <tt>u</tt>, and
<tt>u</tt> has the value originally held
by <tt>t</tt></td></tr>
<tr><td colspan="3">
<p>
The <tt>Swappable</tt> requirement is met by satisfying one or more of the following conditions:
</p>
<ul>
<li>
<tt>T</tt> is <tt>Swappable</tt> if <tt>T</tt> satisfies the
<del><tt>CopyConstructible</tt></del> <ins>MoveConstructible</ins>
requirements (Table <del>34</del> <ins>33</ins>) and the <del><tt>CopyAssignable</tt></del> <ins>MoveAssignable</ins>
requirements (Table <del>36</del> <ins>35</ins>);
</li>
<li>
<tt>T</tt> is <tt>Swappable</tt> if a namespace scope function named
<tt>swap</tt> exists in the same namespace as the definition of
<tt>T</tt>, such that the expression
<tt>swap(t,u)</tt> is valid and has the
semantics described in this table.
</li>
</ul>
</td></tr>
</tbody></table>
</blockquote>



<p><i>[
Kona (2007): We like the change to the <tt>Swappable</tt> requirements to use
move semantics. The issue relating to the support of proxies is
separable from the one relating to move semantics, and it's bigger than
just swap. We'd like to address only the move semantics changes under
this issue, and open a separated issue (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#742">742</a>) to handle proxies. Also, there
may be a third issue, in that the current definition of <tt>Swappable</tt> does
not permit rvalues to be operands to a swap operation, and Howard's
proposed resolution would allow the right-most operand to be an rvalue,
but it would not allow the left-most operand to be an rvalue (some swap
functions in the library have been overloaded to permit left operands to
swap to be rvalues).
]</i></p>





<hr>
<h3><a name="673"></a>673. <tt>unique_ptr</tt> update</h3>
<p><b>Section:</b> 20.9.9 [unique.ptr] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2007-05-04 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#unique.ptr">issues</a> in [unique.ptr].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Since the publication of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1856.html">N1856</a>
there have been a few small but significant advances which should be included into
<tt>unique_ptr</tt>.  There exists a
<a href="http://home.twcny.rr.com/hinnant/cpp_extensions/unique_ptr.html">example implmenation</a>
for all of these changes.
</p>

<ul>

<li>
<p>
Even though <tt>unique_ptr&lt;void&gt;</tt> is not a valid use case (unlike for <tt>shared_ptr&lt;void&gt;</tt>),
unexpected cases to crop up which require the instantiation of the interface of <tt>unique_ptr&lt;void&gt;</tt>
even if it is never used.  For example see
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#541">LWG 541</a> for how this accidently
happened to <tt>auto_ptr</tt>.  I believe the most robust way to protect <tt>unique_ptr</tt> against this
type of failure is to augment the return type of <tt>unique_ptr&lt;T&gt;:operator*()</tt> with
<tt>add_lvalue_reference&lt;T&gt;::type</tt>.  This means that given an instantiated <tt>unique_ptr&lt;void&gt;</tt>
the act of dereferencing it will simply return <tt>void</tt> instead of causing a compile time failure.
This is simpler than creating a <tt>unique_ptr&lt;void&gt;</tt> specialization which isn't robust in the
face of <tt><i>cv-</i></tt>qualified <tt>void</tt> types.
</p>

<p>
This resolution also supports instantiations such as <tt>unique_ptr&lt;void, free_deleter&gt;</tt>
which could be very useful to the client.
</p>

</li>

<li>
<p>
Efforts have been made to better support containers and smart pointers in shared
memory contexts.  One of the key hurdles in such support is not assuming that a
pointer type is actually a <tt>T*</tt>.  This can easily be accomplished
for <tt>unique_ptr</tt> by having the deleter define the pointer type:
<tt>D::pointer</tt>.  Furthermore this type can easily be defaulted to
<tt>T*</tt> should the deleter <tt>D</tt> choose not to define a pointer
type (example implementation
<a href="http://home.twcny.rr.com/hinnant/cpp_extensions/unique_ptr.html">here</a>).
This change has no run time overhead.  It has no interface overhead on
authors of custom delter types.  It simply allows (but not requires)
authors of custom deleter types to define a smart pointer for the
storage type of <tt>unique_ptr</tt> if they find such functionality
useful.  <tt>std::default_delete</tt> is an example of a deleter which
defaults <tt>pointer</tt> to <tt>T*</tt> by simply ignoring this issue
and not including a <tt>pointer typedef</tt>.
</p>
</li>

<li>
<p>
When the deleter type is a function pointer then it is unsafe to construct
a <tt>unique_ptr</tt> without specifying the function pointer in the constructor.
This case is easy to check for with a <tt>static_assert</tt> assuring that the
deleter is not a pointer type in those constructors which do not accept deleters.
</p>

<blockquote><pre>unique_ptr&lt;A, void(*)(void*)&gt; p(new A);  // error, no function given to delete the pointer!
</pre></blockquote>

</li>

</ul>

<p><i>[
Kona (2007): We don't like the solution given to the first bullet in
light of concepts. The second bullet solves the problem of supporting
fancy pointers for one library component only. The full LWG needs to
decide whether to solve the problem of supporting fancy pointers
piecemeal, or whether a paper addressing the whole library is needed. We
think that the third bullet is correct.
]</i></p>


<p><i>[
Post Kona: Howard adds example user code related to the first bullet:
]</i></p>


<blockquote>
<pre>void legacy_code(void*, std::size_t);

void foo(std::size_t N)
{
    std::unique_ptr&lt;void, void(*)(void*)&gt; ptr(std::malloc(N), std::free);
    legacy_code(ptr.get(), N);
}   // unique_ptr used for exception safety purposes
</pre>
</blockquote>

<p>
I.e. <tt>unique_ptr&lt;void&gt;</tt> <i>is</i> a useful tool that we don't want
to disable with concepts.  The only part of <tt>unique_ptr&lt;void&gt;</tt> we
want to disable (with concepts or by other means) are the two member functions:
</p>

<blockquote><pre>T&amp; operator*() const;
T* operator-&gt;() const;
</pre></blockquote>



<p><b>Proposed resolution:</b></p>

<p><i>[
I am grateful for the generous aid of Peter Dimov and Ion Gaztaaga in helping formulate and review
the proposed resolutions below.
]</i></p>


<ul>
<li>

<p>
Change 20.9.9.2 [unique.ptr.single]:
</p>

<blockquote><pre>template &lt;class T, class D = default_delete&lt;T&gt;&gt; class unique_ptr {
   ...
   <del>T&amp;</del> <ins>typename add_lvalue_reference&lt;T&gt;::type</ins> operator*() const;
   ...
};
</pre></blockquote>

<p>
Change 20.9.9.2.4 [unique.ptr.single.observers]:
</p>

<blockquote><pre><del>T&amp;</del> <ins>typename add_lvalue_reference&lt;T&gt;::type</ins> operator*() const;
</pre></blockquote>

</li>

<li>
<p>
Change 20.9.9.2 [unique.ptr.single]:
</p>

<blockquote><pre>template &lt;class T, class D = default_delete&lt;T&gt;&gt; class unique_ptr {
public:
  <ins>typedef <i>implementation (see description below)</i> pointer;</ins>
   ...
   explicit unique_ptr(<del>T*</del> <ins>pointer</ins> p);
   ...
   unique_ptr(<del>T*</del> <ins>pointer</ins> p, <i>implementation defined (see description below)</i> d);
   unique_ptr(<del>T*</del> <ins>pointer</ins> p, <i>implementation defined (see description below)</i> d);
   ...
   <del>T*</del> <ins>pointer</ins> operator-&gt;() const;
   <del>T*</del> <ins>pointer</ins> get() const;
   ...
   <del>T*</del> <ins>pointer</ins> release();
   void reset(<del>T*</del> <ins>pointer</ins> p = <del>0</del> <ins>pointer()</ins>);
};
</pre></blockquote>

<p>
<ins>
-3- If the type <tt>remove_reference&lt;D&gt;::type::pointer</tt>
exists, then <tt>unique_ptr&lt;T, D&gt;::pointer</tt> is a typedef to
<tt>remove_reference&lt;D&gt;::type::pointer</tt>.  Otherwise
<tt>unique_ptr&lt;T, D&gt;::pointer</tt> is a typedef to <tt>T*</tt>.
The type <tt>unique_ptr&lt;T, D&gt;::pointer</tt> shall be <tt>CopyConstructible</tt>
and <tt>CopyAssignable</tt>.
</ins>
</p>

<p>
Change 20.9.9.2.1 [unique.ptr.single.ctor]:
</p>

<blockquote><pre>unique_ptr(<del>T*</del> <ins>pointer</ins> p);
...
unique_ptr(<del>T*</del> <ins>pointer</ins> p, <i>implementation defined</i> d); 
unique_ptr(<del>T*</del> <ins>pointer</ins> p, <i>implementation defined</i> d); 
...
unique_ptr(<del>T*</del> <ins>pointer</ins> p, const A&amp; d);
unique_ptr(<del>T*</del> <ins>pointer</ins> p, A&amp;&amp; d);
...
unique_ptr(<del>T*</del> <ins>pointer</ins> p, A&amp; d); 
unique_ptr(<del>T*</del> <ins>pointer</ins> p, A&amp;&amp; d);
...
unique_ptr(<del>T*</del> <ins>pointer</ins> p, const A&amp; d); 
unique_ptr(<del>T*</del> <ins>pointer</ins> p, const A&amp;&amp; d);
...
</pre></blockquote>

<p>
-23- <i>Requires:</i> If <tt>D</tt> is not a reference type,
construction of the deleter <tt>D</tt> from an rvalue of type <tt>E</tt>
<del>must</del> <ins>shall</ins> be well formed and not throw an exception. If <tt>D</tt> is a
reference type, then <tt>E</tt> <del>must</del> <ins>shall</ins> be the same type as <tt>D</tt>
(diagnostic required). <del><tt>U*</tt></del> <ins><tt>unique_ptr&lt;U,E&gt;::pointer</tt></ins>
<del>must</del> <ins>shall</ins> be implicitly convertible to <del><tt>T*</tt></del>
<ins>pointer</ins>.
</p>

<p>
-25- <i>Postconditions:</i> <tt>get() == value u.get()</tt> had before
the construction, modulo any required offset adjustments resulting from
the cast from <del><tt>U*</tt></del>
<ins><tt>unique_ptr&lt;U,E&gt;::pointer</tt></ins> to <del><tt>T*</tt></del>
<ins>pointer</ins>. <tt>get_deleter()</tt> returns a reference to the
internally stored deleter which was constructed from
<tt>u.get_deleter()</tt>.
</p>

<p>
Change 20.9.9.2.3 [unique.ptr.single.asgn]:
</p>

<blockquote>
<p>
-8- <i>Requires:</i> Assignment of the deleter <tt>D</tt> from an rvalue
<tt>D</tt> <del>must</del> <ins>shall</ins> not throw an exception. <del><tt>U*</tt></del>
<ins><tt>unique_ptr&lt;U,E&gt;::pointer</tt></ins> <del>must</del> <ins>shall</ins> be implicitly
convertible to <del><tt>T*</tt></del> <ins>pointer</ins>.
</p>
</blockquote>

<p>
Change 20.9.9.2.4 [unique.ptr.single.observers]:
</p>

<blockquote>
<pre><del>T*</del> <ins>pointer</ins> operator-&gt;() const;</pre>
...
<pre><del>T*</del> <ins>pointer</ins> get() const;</pre>
</blockquote>

<p>
Change 20.9.9.2.5 [unique.ptr.single.modifiers]:
</p>

<blockquote>
<pre><del>T*</del> <ins>pointer</ins> release();</pre>
...
<pre>void reset(<del>T*</del> <ins>pointer</ins> p = <del>0</del> <ins>pointer()</ins>);</pre>
</blockquote>

<p>
Change 20.9.9.3 [unique.ptr.runtime]:
</p>

<blockquote><pre>template &lt;class T, class D&gt; class unique_ptr&lt;T[], D&gt; {
public:
  <ins>typedef <i>implementation</i> pointer;</ins>
   ...
   explicit unique_ptr(<del>T*</del> <ins>pointer</ins> p);
   ...
   unique_ptr(<del>T*</del> <ins>pointer</ins> p, <i>implementation defined</i> d);
   unique_ptr(<del>T*</del> <ins>pointer</ins> p, <i>implementation defined</i> d);
   ...
   <del>T*</del> <ins>pointer</ins> get() const;
   ...
   <del>T*</del> <ins>pointer</ins> release();
   void reset(<del>T*</del> <ins>pointer</ins> p = <del>0</del> <ins>pointer()</ins>);
};
</pre></blockquote>

<p>
Change 20.9.9.3.1 [unique.ptr.runtime.ctor]:
</p>

<blockquote>
<pre>unique_ptr(<del>T*</del> <ins>pointer</ins> p);
unique_ptr(<del>T*</del> <ins>pointer</ins> p, <i>implementation defined</i> d);
unique_ptr(<del>T*</del> <ins>pointer</ins> p, <i>implementation defined</i> d);
</pre>

<p>
These constructors behave the same as in the primary template except
that they do not accept pointer types which are convertible to
<del><tt>T*</tt></del> <ins><tt>pointer</tt></ins>. [<i>Note:</i> One
implementation technique is to create private templated overloads of
these members. <i>-- end note</i>]
</p>
</blockquote>

<p>
Change 20.9.9.3.3 [unique.ptr.runtime.modifiers]:
</p>

<blockquote>
<pre>void reset(<del>T*</del> <ins>pointer</ins> p = <del>0</del> <ins>pointer()</ins>);
</pre>

<p>
-1- <i>Requires:</i> Does not accept pointer types which are convertible
to <del><tt>T*</tt></del> <ins><tt>pointer</tt></ins> (diagnostic
required). [<i>Note:</i> One implementation technique is to create a private
templated overload. <i>-- end note</i>]
</p>
</blockquote>

</li>

<li>

<p>
Change 20.9.9.2.1 [unique.ptr.single.ctor]:
</p>

<blockquote>
<pre>unique_ptr();</pre>
<blockquote>
<p>
<i>Requires:</i> <tt>D</tt> <del>must</del> <ins>shall</ins> be default constructible, and that
construction <del>must</del> <ins>shall</ins> not throw an exception. <tt>D</tt> <del>must</del> <ins>shall</ins> not be a
reference type <ins>or pointer type (diagnostic required)</ins>.
</p>
</blockquote>
<pre>unique_ptr(<del>T*</del> <ins>pointer</ins> p);</pre>
<blockquote>
<p>
<i>Requires:</i>  The expression <tt>D()(p)</tt> <del>must</del> <ins>shall</ins> be well formed.
The default constructor of <tt>D</tt> <del>must</del> <ins>shall</ins> not throw an exception.
<tt>D</tt> <del>must</del> <ins>shall</ins> not be a reference type <ins>or pointer type (diagnostic
required)</ins>.
</p>
</blockquote>
</blockquote>

</li>

</ul>






<hr>
<h3><a name="674"></a>674. <tt>shared_ptr</tt> interface changes for consistency with N1856</h3>
<p><b>Section:</b> 20.9.10.2 [util.smartptr.shared] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Peter Dimov <b>Opened:</b> 2007-05-05 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#util.smartptr.shared">issues</a> in [util.smartptr.shared].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1856.html">N1856</a> does not propose
any changes to <tt>shared_ptr</tt>. It needs to be updated to use a rvalue reference where appropriate
and to interoperate with <tt>unique_ptr</tt> as it does with <tt>auto_ptr</tt>.
</p>


<p><b>Proposed resolution:</b></p>

<p>
Change 20.9.10.2 [util.smartptr.shared] as follows:
</p>

<blockquote>
<pre>template&lt;class Y&gt; explicit shared_ptr(auto_ptr&lt;Y&gt;<del>&amp;</del><ins>&amp;&amp;</ins> r);
<ins>template&lt;class Y, class D&gt; explicit shared_ptr(const unique_ptr&lt;Y,D&gt;&amp; r) = delete;
template&lt;class Y, class D&gt; explicit shared_ptr(unique_ptr&lt;Y,D&gt;&amp;&amp; r);</ins>
...
template&lt;class Y&gt; shared_ptr&amp; operator=(auto_ptr&lt;Y&gt;<del>&amp;</del><ins>&amp;&amp;</ins> r);
<ins>template&lt;class Y, class D&gt; shared_ptr&amp; operator=(const unique_ptr&lt;Y,D&gt;&amp; r) = delete;
template&lt;class Y, class D&gt; shared_ptr&amp; operator=(unique_ptr&lt;Y,D&gt;&amp;&amp; r);</ins></pre>
</blockquote>

<p>
Change 20.9.10.2.1 [util.smartptr.shared.const] as follows:
</p>

<blockquote>
<pre><ins>template&lt;class Y&gt; shared_ptr(auto_ptr&lt;Y&gt;<del>&amp;</del><ins>&amp;&amp;</ins> r);</ins></pre>
</blockquote>

<p>
Add to 20.9.10.2.1 [util.smartptr.shared.const]:
</p>

<blockquote>
<pre><ins>template&lt;class Y, class D&gt; shared_ptr(unique_ptr&lt;Y, D&gt;&amp;&amp; r);</ins></pre>
<blockquote>

<p><ins>
<i>Effects:</i> Equivalent to <tt>shared_ptr( r.release(), r.get_deleter() )</tt> when <tt>D</tt> is
          not a reference type, <tt>shared_ptr( r.release(), ref( r.get_deleter() ) )</tt>
          otherwise.
</ins></p>

<p><ins>
<i>Exception safety:</i> If an exception is thrown, the constructor has no effect.
</ins></p>
</blockquote>

</blockquote>

<p>
Change 20.9.10.2.3 [util.smartptr.shared.assign] as follows:
</p>

<blockquote>
<pre>template&lt;class Y&gt; shared_ptr&amp; operator=(auto_ptr&lt;Y&gt;<del>&amp;</del><ins>&amp;&amp;</ins> r);</pre>
</blockquote>

<p>
Add to 20.9.10.2.3 [util.smartptr.shared.assign]:
</p>

<blockquote>
<pre><ins>template&lt;class Y, class D&gt; shared_ptr&amp; operator=(unique_ptr&lt;Y,D&gt;&amp;&amp; r);</ins></pre>

<blockquote>
<p><ins>
-4- <i>Effects:</i> Equivalent to <tt>shared_ptr(std::move(r)).swap(*this)</tt>.
</ins></p>
<p><ins>
-5- <i>Returns:</i> <tt>*this</tt>.
</ins></p>
</blockquote>

</blockquote>



<p><i>[
Kona (2007): We may need to open an issue (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#743">743</a>) to deal with the question of
whether <tt>shared_ptr</tt> needs an rvalue <tt>swap</tt>.
]</i></p>





<hr>
<h3><a name="675"></a>675. Move assignment of containers</h3>
<p><b>Section:</b> 23.2 [container.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2007-05-05 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#container.requirements">issues</a> in [container.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
James Hopkin pointed out to me that if <tt>vector&lt;T&gt;</tt> move assignment is O(1)
(just a <tt>swap</tt>) then containers such as <tt>vector&lt;shared_ptr&lt;ostream&gt;&gt;</tt> might have
the wrong semantics under move assignment when the source is not truly an rvalue, but a
moved-from lvalue (destructors could run late).
</p>

<blockquote><pre><tt>vector&lt;shared_ptr&lt;ostream&gt;&gt;</tt> v1;
<tt>vector&lt;shared_ptr&lt;ostream&gt;&gt;</tt> v2;
...
v1 = v2;               // #1
v1 = std::move(v2);    // #2
</pre></blockquote>

<p>
Move semantics means not caring what happens to the source (<tt>v2</tt> in this example).
It doesn't mean not caring what happens to the target (<tt>v1</tt>).  In the above example
both assignments should have the same effect on <tt>v1</tt>.  Any non-shared <tt>ostream</tt>'s
<tt>v1</tt> owns before the assignment should be closed, whether <tt>v1</tt> is undergoing
copy assignment or move assignment.
</p>

<p>
This implies that the semantics of move assignment of a generic container should be
<tt>clear, swap</tt> instead of just swap.  An alternative which could achieve the same
effect would be to move assign each element.  In either case, the complexity of move
assignment needs to be relaxed to <tt>O(v1.size())</tt>.
</p>

<p>
The performance hit of this change is not nearly as drastic as it sounds. 
In practice, the target of a move assignment has always just been move constructed
or move assigned <i>from</i>.  Therefore under <tt>clear, swap</tt> semantics (in
this common use case) we are still achieving O(1) complexity.
</p>



<p><b>Proposed resolution:</b></p>
<p>
Change 23.2 [container.requirements]:
</p>

<blockquote>
<table border="1">
<caption>Table 89: Container requirements</caption>
<tbody><tr>
<th>expression</th><th>return type</th><th>operational semantics</th>
<th>assertion/note pre/post-condition</th><th>complexity</th>
</tr>
<tr>
<td><tt>a = rv;</tt></td><td><tt>X&amp;</tt></td>
<td>All existing elements of <tt>a</tt> are either move assigned or destructed</td>
<td><tt>a</tt> shall be equal to the 
value that <tt>rv</tt> had 
before this construction
</td>
<td><del>(Note C)</del> <ins>linear</ins></td>
</tr>
</tbody></table>

<p>
Notes: the algorithms <tt>swap()</tt>, <tt>equal()</tt> and
<tt>lexicographical_compare()</tt> are defined in clause 25. Those
entries marked "(Note A)" should have constant complexity. Those entries
marked "(Note B)" have constant complexity unless
<tt>allocator_propagate_never&lt;X::allocator_type&gt;::value</tt> is
<tt>true</tt>, in which case they have linear complexity.
<del>Those entries
marked "(Note C)" have constant complexity if <tt>a.get_allocator() ==
rv.get_allocator()</tt> or if either
<tt>allocator_propagate_on_move_assignment&lt;X::allocator_type&gt;::value</tt>
is <tt>true</tt> or
<tt>allocator_propagate_on_copy_assignment&lt;X::allocator_type&gt;::value</tt>
is <tt>true</tt> and linear complexity otherwise.</del>
</p>
</blockquote>



<p><i>[
post Bellevue Howard adds:
]</i></p>


<blockquote>
<p>
This issue was voted to WP in Bellevue, but accidently got stepped on by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2525.pdf">N2525</a>
which was voted to WP simulataneously.  Moving back to Open for the purpose of getting
the wording right.  The intent of this issue and N2525 are not in conflict.
</p>
</blockquote>

<p><i>[
post Sophia Antipolis Howard updated proposed wording:
]</i></p>





<hr>
<h3><a name="676"></a>676. Moving the unordered containers</h3>
<p><b>Section:</b> 23.7 [unord] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2007-05-05 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#unord">issues</a> in [unord].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Move semantics are missing from the <tt>unordered</tt> containers.  The proposed
resolution below adds move-support consistent with
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1858.html">N1858</a>
and the current working draft.
</p>

<p>
The current proposed resolution simply lists the requirements for each function.
These might better be hoisted into the requirements table for unordered associative containers.
Futhermore a mild reorganization of the container requirements could well be in order.
This defect report is purposefully ignoring these larger issues and just focusing
on getting the unordered containers "moved".
</p>

<p><i>[
2009-07-28 Reopened by Alisdair.  No longer solved by concepts.
]</i></p>


<p><i>[
2009-10-17 Removed rvalue-swaps from wording.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Move to Review. Alisdair will review proposed wording.
</blockquote>

<p><i>[
2009-10-29 Daniel updates wording.
]</i></p>


<p><i>[
2010-01-26 Alisdair updates wording.
]</i></p>


<p><i>[
2010-02-10 Howard updates wording to reference the unordered container
requirements table (modified by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#704">704</a>) as much as possible.
]</i></p>


<p><i>[
Voted to WP in Bellevue.
]</i></p>


<p><i>[
post Bellevue, Pete notes:
]</i></p>


<blockquote>
<p>
Please remind people who are reviewing issues to check that the text
modifications match the current draft. Issue 676, for example, adds two
overloads for unordered_map::insert taking a hint. One takes a
const_iterator and returns a const_iterator, and the other takes an
iterator and returns an iterator. This was correct at the time the issue
was written, but was changed in Toronto so there is only one hint
overload, taking a const_iterator and returning an iterator.
</p>
<p>
This issue is not ready. In addition to the relatively minor signature
problem I mentioned earlier, it puts requirements in the wrong places.
Instead of duplicating requirements throughout the template
specifications, it should put them in the front matter that talks about
requirements for unordered containers in general. This presentation
problem is editorial, but I'm not willing to do the extensive rewrite
that it requires. Please put it back into Open status.
</p>
</blockquote>

<p><i>[
2010-02-11 Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>


<p><i>[
2010-02-24 Pete moved to Open:
]</i></p>


<blockquote>
The descriptions of the semantics of the added <tt>insert</tt> functions belong
in the requirements table. That's where the rest of the <tt>insert</tt>
functions are.
</blockquote>

<p><i>[
2010 Pittsburgh:
]</i></p>


<blockquote>
Move issue 676 to Ready for Pittsburgh. Nico to send Howard an issue for
the broader problem.
</blockquote>



<p><b>Rationale:</b></p>
<p><i>[
San Francisco:
]</i></p>


<blockquote>
Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2776.pdf">N2776</a>.
</blockquote>

<p><i>[
Rationale is obsolete.
]</i></p>





<p><b>Proposed resolution:</b></p>

<p><b><tt>unordered_map</tt></b></p>

<p>
Change 23.7.1 [unord.map]:
</p>

<blockquote><pre>class unordered_map
{
    ...
    unordered_map(const unordered_map&amp;);
    <ins>unordered_map(unordered_map&amp;&amp;);</ins>
    unordered_map(const Allocator&amp;);
    unordered_map(const unordered_map&amp;, const Allocator&amp;);
    unordered_map(unordered_map&amp;&amp;, const Allocator&amp;);
    ...
    unordered_map&amp; operator=(const unordered_map&amp;);
    <ins>unordered_map&amp; operator=(unordered_map&amp;&amp;);</ins>
    ...
    // modifiers
    ...
    <del>std::</del>pair&lt;iterator, bool&gt; insert(const value_type&amp; obj); 
    <ins>template &lt;class P&gt; pair&lt;iterator, bool&gt; insert(P&amp;&amp; obj);</ins>
    iterator       insert(const_iterator hint, const value_type&amp; obj);
    <ins>template &lt;class P&gt; iterator       insert(const_iterator hint, P&amp;&amp; obj);</ins>
    ...
    mapped_type&amp; operator[](const key_type&amp; k);
    <ins>mapped_type&amp; operator[](key_type&amp;&amp; k);</ins>
    ...
};

</pre></blockquote>

<p>
Add to 23.7.1.2 [unord.map.elem]:
</p>

<blockquote>

<pre>mapped_type&amp; operator[](const key_type&amp; k);</pre>

<blockquote>
<p>...</p>
<p><ins>
<i>Requires:</i> <tt>key_type</tt> shall be <tt>CopyConstructible</tt>
and <tt>mapped_type</tt> shall be <tt>DefaultConstructible</tt>.
</ins></p>

<p><ins>
<i>Complexity:</i> Average case <tt>O(1)</tt>, worst case <tt>O(size())</tt>.
</ins></p>

</blockquote>

<pre><ins>mapped_type&amp; operator[](key_type&amp;&amp; k);</ins></pre>

<blockquote>
<p><ins>
<i>Requires:</i> <tt>key_type</tt> shall be <tt>MoveConstructible</tt> and
<tt>mapped_type</tt> shall be <tt>DefaultConstructible</tt>.
</ins></p>

<p><ins>
<i>Effects:</i> If the <tt>unordered_map</tt> does not already contain an
element whose key is equivalent to <tt>k</tt> , inserts the value
<tt>value_type(std::move(k), mapped_type())</tt>.
</ins></p>

<p><ins>
<i>Returns:</i> A reference to <tt>x.second</tt>, where <tt>x</tt> is the
(unique) element whose key is equivalent to <tt>k</tt>.
</ins></p>

<p><ins>
<i>Complexity:</i> Average case <tt>O(1)</tt>, worst case <tt>O(size())</tt>.
</ins></p>

</blockquote>

</blockquote>

<p>
Add new section [unord.map.modifiers]:
</p>

<blockquote>
<pre><ins>template &lt;class P&gt;
  pair&lt;iterator, bool&gt; insert(P&amp;&amp; x);</ins>
</pre>

<blockquote>

<p><ins>
<i>Requires:</i> <tt>value_type</tt> is constructible from
<tt>std::forward&lt;P&gt;(x)</tt>.
</ins></p>

<p><ins>
<i>Effects:</i>  Inserts <tt>x</tt> converted to <tt>value_type</tt> if and only
if there is no element in the container with key equivalent to the key of
<tt>value_type(x)</tt>.
</ins></p>

<p><ins>
<i>Returns:</i> The <tt>bool</tt> component of the returned
<tt>pair</tt> indicates whether the insertion takes place, and the iterator
component points to the element with key equivalent to the key of
<tt>value_type(x)</tt>.
</ins></p>

<p><ins>
<i>Complexity:</i> Average case <tt>O(1)</tt>, worst case <tt>O(size())</tt>.
</ins></p>

<p><ins>
<i>Remarks:</i> <tt>P</tt> shall be implicitly convertible to
<tt>value_type</tt>, else this signature shall not participate in overload
resolution.
</ins></p>

</blockquote>


<pre><ins>template &lt;class P&gt;
  iterator insert(const_iterator hint, P&amp;&amp; x);</ins>
</pre>

<blockquote>

<p><ins>
<i>Requires:</i> <tt>value_type</tt> is constructible from
<tt>std::forward&lt;P&gt;(x)</tt>.
</ins></p>

<p><ins>
<i>Effects:</i>  Inserts <tt>x</tt> converted to <tt>value_type</tt> if and only
if there is no element in the container with key equivalent to the key of
<tt>value_type(x)</tt>.  The iterator <tt>hint</tt> is a hint pointing to where
the search should start. Implementations are permitted to ignore the hint.
</ins></p>

<p><ins>
<i>Returns:</i> An iterator pointing to the element with key equivalent to the
key of <tt>value_type(x)</tt>.
</ins></p>

<p><ins>
<i>Complexity:</i> Average case <tt>O(1)</tt>, worst case <tt>O(size())</tt>.
</ins></p>

<p><ins>
<i>Remarks:</i> <tt>P</tt> shall be implicitly convertible to
<tt>value_type</tt>, else this signature shall not participate in overload
resolution.
</ins></p>

</blockquote>

</blockquote>

<p><b><tt>unordered_multimap</tt></b></p>

<p>
Change 23.7.2 [unord.multimap]:
</p>

<blockquote><pre>class unordered_multimap
{
    ...
    unordered_multimap(const unordered_multimap&amp;);
    <ins>unordered_multimap(unordered_multimap&amp;&amp;);</ins>
    unordered_multimap(const Allocator&amp;);
    unordered_multimap(const unordered_multimap&amp;, const Allocator&amp;);
    unordered_multimap(unordered_multimap&amp;&amp;, const Allocator&amp;);
    ...
    unordered_multimap&amp; operator=(const unordered_multimap&amp;);
    <ins>unordered_multimap&amp; operator=(unordered_multimap&amp;&amp;);</ins>
    ...
    // modifiers
    ...
    iterator insert(const value_type&amp; obj); 
    <ins>template &lt;class P&gt; iterator insert(P&amp;&amp; obj);</ins>
    iterator       insert(const_iterator hint, const value_type&amp; obj);
    <ins>template &lt;class P&gt; iterator       insert(const_iterator hint, P&amp;&amp; obj);</ins>
    ...
};

</pre></blockquote>

<p>
Add new section [unord.multimap.modifiers]:
</p>

<blockquote>
<pre><ins>template &lt;class P&gt;
  iterator insert(P&amp;&amp; x);</ins>
</pre>

<blockquote>

<p><ins>
<i>Requires:</i> <tt>value_type</tt> is constructible from
<tt>std::forward&lt;P&gt;(x)</tt>.
</ins></p>

<p><ins>
<i>Effects:</i>  Inserts <tt>x</tt> converted to <tt>value_type</tt>.
</ins></p>

<p><ins>
<i>Returns:</i> An iterator pointing to the element with key equivalent to the
key of <tt>value_type(x)</tt>.
</ins></p>

<p><ins>
<i>Complexity:</i> Average case <tt>O(1)</tt>, worst case <tt>O(size())</tt>.
</ins></p>

<p><ins>
<i>Remarks:</i> <tt>P</tt> shall be implicitly convertible to
<tt>value_type</tt>, else this signature shall not participate in overload
resolution.
</ins></p>

</blockquote>

<pre><ins>template &lt;class P&gt;
  iterator insert(const_iterator hint, P&amp;&amp; x);</ins>
</pre>

<blockquote>

<p><ins>
<i>Requires:</i> <tt>value_type</tt> is constructible from
<tt>std::forward&lt;P&gt;(x)</tt>.
</ins></p>

<p><ins>
<i>Effects:</i>  Inserts <tt>x</tt> converted to <tt>value_type</tt> if and only
if there is no element in the container with key equivalent to the key of
<tt>value_type(x)</tt>.  The iterator <tt>hint</tt> is a hint pointing to where
the search should start. Implementations are permitted to ignore the hint.
</ins></p>

<p><ins>
<i>Returns:</i> An iterator pointing to the element with key equivalent to the
key of <tt>value_type(x)</tt>.
</ins></p>

<p><ins>
<i>Complexity:</i> Average case <tt>O(1)</tt>, worst case <tt>O(size())</tt>.
</ins></p>

<p><ins>
<i>Remarks:</i> <tt>P</tt> shall be implicitly convertible to
<tt>value_type</tt>, else this signature shall not participate in overload
resolution.
</ins></p>

</blockquote>

</blockquote>

<p><b><tt>unordered_set</tt></b></p>

<p>
Change 23.7.3 [unord.set]:
</p>

<blockquote><pre>class unordered_set
{
    ...
    unordered_set(const unordered_set&amp;);
    <ins>unordered_set(unordered_set&amp;&amp;);</ins>
    unordered_set(const Allocator&amp;);
    unordered_set(const unordered_set&amp;, const Allocator&amp;);
    unordered_set(unordered_set&amp;&amp;, const Allocator&amp;);
    ...
    unordered_set&amp; operator=(const unordered_set&amp;);
    <ins>unordered_set&amp; operator=(unordered_set&amp;&amp;);</ins>
    ...
    // modifiers 
    ...
    <del>std::</del>pair&lt;iterator, bool&gt; insert(const value_type&amp; obj); 
    <ins>pair&lt;iterator, bool&gt; insert(value_type&amp;&amp; obj);</ins>
    iterator       insert(const_iterator hint, const value_type&amp; obj);
    <ins>iterator       insert(const_iterator hint, value_type&amp;&amp; obj);</ins>
    ...
};
</pre></blockquote>

<p><b><tt>unordered_multiset</tt></b></p>

<p>
Change 23.7.4 [unord.multiset]:
</p>

<blockquote><pre>class unordered_multiset
{
    ...
    unordered_multiset(const unordered_multiset&amp;);
    <ins>unordered_multiset(unordered_multiset&amp;&amp;);</ins>
    unordered_multiset(const Allocator&amp;);
    unordered_multiset(const unordered_multiset&amp;, const Allocator&amp;);
    unordered_multiset(unordered_multiset&amp;&amp;, const Allocator&amp;);
    ...
    unordered_multiset&amp; operator=(const unordered_multiset&amp;);
    <ins>unordered_multiset&amp; operator=(unordered_multiset&amp;&amp;);</ins>
    ...
    // modifiers
    ...
    iterator insert(const value_type&amp; obj); 
    <ins>iterator insert(value_type&amp;&amp; obj);</ins>
    iterator       insert(const_iterator hint, const value_type&amp; obj);
    <ins>iterator       insert(const_iterator hint, value_type&amp;&amp; obj);</ins>
    ...
};

</pre></blockquote>






<hr>
<h3><a name="677"></a>677. Weaknesses in seed_seq::randomize [rand.util.seedseq]</h3>
<p><b>Section:</b> 26.5.7.1 [rand.util.seedseq] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Charles Karney <b>Opened:</b> 2007-05-15 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.util.seedseq">issues</a> in [rand.util.seedseq].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>seed_seq::randomize</tt> provides a mechanism for initializing random number
engines which ideally would yield "distant" states when given "close"
seeds.  The algorithm for <tt>seed_seq::randomize</tt> given in the current
Working Draft for C++,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2284.pdf">N2284</a>
(2007-05-08), has 3 weaknesses
</p>

<ol>
<li>
<p> Collisions in state.  Because of the way the state is initialized,
    seeds of different lengths may result in the same state.  The
    current version of seed_seq has the following properties:</p>
<ul>
<li>  For a given <tt>s &lt;= n</tt>, each of the 2^(32s) seed vectors results in a
      distinct state.</li>
</ul>
<p>
    The proposed algorithm (below) has the considerably stronger
    properties:</p>
<ul>
<li>   All of the <tt>(2^(32n)-1)/(2^32-1)</tt> seed vectors of lengths <tt>s &lt; n</tt>
      result in distinct states.
</li>
<li>  All of the <tt>2^(32n)</tt> seed vectors of length <tt>s == n</tt> result in
      distinct states.
</li>
</ul>
</li>
<li>
<p> Poor mixing of <tt>v'</tt>s entropy into the state.  Consider <tt>v.size() == n</tt>
    and hold <tt>v[n/2]</tt> thru <tt>v[n-1]</tt> fixed while varying <tt>v[0]</tt> thru <tt>v[n/2-1]</tt>,
    a total of <tt>2^(16n)</tt> possibilities.  Because of the simple recursion
    used in <tt>seed_seq</tt>, <tt>begin[n/2]</tt> thru <tt>begin[n-1]</tt> can take on only 2^64
    possible states.</p>

<p> The proposed algorithm uses a more complex recursion which results
    in much better mixing.</p>
</li>
<li> <tt>seed_seq::randomize</tt> is undefined for <tt>v.size() == 0</tt>.  The proposed
    algorithm remedies this.
</li>
</ol>
<p>
The current algorithm for <tt>seed_seq::randomize</tt> is adapted by me from the
initialization procedure for the Mersenne Twister by Makoto Matsumoto
and Takuji Nishimura.  The weakness (2) given above was communicated to
me by Matsumoto last year.
</p>
<p>
The proposed replacement for <tt>seed_seq::randomize</tt> is due to Mutsuo Saito,
a student of Matsumoto, and is given in the implementation of the
SIMD-oriented Fast Mersenne Twister random number generator SFMT.
<a href="http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/SFMT/index.html">http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/SFMT/index.html</a>
<a href="http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/SFMT/SFMT-src-1.2.tar.gz">http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/SFMT/SFMT-src-1.2.tar.gz</a>
</p>
<p>
See
Mutsuo Saito,
An Application of Finite Field: Design and Implementation of 128-bit
Instruction-Based Fast Pseudorandom Number Generator,
Master's Thesis, Dept. of Math., Hiroshima University (Feb. 2007)
<a href="http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/SFMT/M062821.pdf">http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/SFMT/M062821.pdf</a>
</p>
<p>
One change has been made here, namely to treat the case of small <tt>n</tt>
(setting <tt>t = (n-1)/2</tt> for <tt>n &lt; 7</tt>).
</p>
<p>
Since <tt>seed_seq</tt> was introduced relatively recently there is little cost
in making this incompatible improvement to it.
</p>

<p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2391.pdf">N2391</a> and
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2423.pdf">N2423</a>
for some further discussion.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Adopt the proposed resolution in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2423.pdf">N2423</a>.
</p>


<p><i>[
Kona (2007): The LWG adopted the proposed resolution of N2423 for this issue.
The LWG voted to accelerate this issue to Ready status to be voted into the WP at Kona.
]</i></p>





<hr>
<h3><a name="678"></a>678. Changes for [rand.req.eng]</h3>
<p><b>Section:</b> 26.5.1.4 [rand.req.eng] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Charles Karney <b>Opened:</b> 2007-05-15 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.req.eng">issues</a> in [rand.req.eng].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Section 26.5.1.4 [rand.req.eng] Random number engine requirements:
</p>

<p>
This change follows naturally from the proposed change to
<tt>seed_seq::randomize</tt> in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#677">677</a>.
</p>

<p>
In table 104 the description of <tt>X(q)</tt> contains a special treatment of
the case <tt>q.size() == 0</tt>.  This is undesirable for 4 reasons:
</p>

<ol>
<li>It replicates the functionality provided by <tt>X()</tt>.</li>
<li>It leads to the possibility of a collision in the state provided
    by some other <tt>X(q)</tt> with <tt>q.size() &gt; 0</tt>.</li>
<li>It is inconsistent with the description of the <tt>X(q)</tt> in
paragraphs 26.5.3.1 [rand.eng.lcong] p5, 26.5.3.2 [rand.eng.mers] p8, and 26.5.3.3 [rand.eng.sub] p10 where
there is no special treatment of <tt>q.size() == 0</tt>.</li>
<li>The proposed replacement for <tt>seed_seq::randomize</tt> given above
    allows for the case <tt>q.size() == 0</tt>.</li>
</ol>

<p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2391.pdf">N2391</a> and
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2423.pdf">N2423</a>
for some further discussion.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Adopt the proposed resolution in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2423.pdf">N2423</a>.
</p>


<p><i>[
Kona (2007): The LWG adopted the proposed resolution of N2423 for this issue.
The LWG voted to accelerate this issue to Ready status to be voted into the WP at Kona.
]</i></p>





<hr>
<h3><a name="679"></a>679. resize parameter by value</h3>
<p><b>Section:</b> 23.3 [sequences] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2007-06-11 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#sequences">issues</a> in [sequences].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The C++98 standard specifies that one member function alone of the containers
passes its parameter (<tt>T</tt>) by value instead of by const reference:
</p>

<blockquote><pre>void resize(size_type sz, T c = T());
</pre></blockquote>

<p>
This fact has been discussed / debated repeatedly over the years, the first time
being even before C++98 was ratified.  The rationale for passing this parameter by
value has been:
</p>

<blockquote>
<p>
So that self referencing statements are guaranteed to work, for example:
</p>
<blockquote><pre>v.resize(v.size() + 1, v[0]);
</pre></blockquote>
</blockquote>

<p>
However this rationale is not convincing as the signature for <tt>push_back</tt> is:
</p>

<blockquote><pre>void push_back(const T&amp; x);
</pre></blockquote>

<p>
And <tt>push_back</tt> has similar semantics to <tt>resize</tt> (append).
And <tt>push_back</tt> must also work in the self referencing case:
</p>

<blockquote><pre>v.push_back(v[0]);  // must work
</pre></blockquote>

<p>
The problem with passing <tt>T</tt> by value is that it can be significantly more
expensive than passing by reference.  The converse is also true, however when it is
true it is usually far less dramatic (e.g. for scalar types).
</p>

<p>
Even with move semantics available, passing this parameter by value can be expensive.
Consider for example <tt>vector&lt;vector&lt;int&gt;&gt;</tt>:
</p>

<blockquote><pre>std::vector&lt;int&gt; x(1000);
std::vector&lt;std::vector&lt;int&gt;&gt; v;
...
v.resize(v.size()+1, x);
</pre></blockquote>

<p>
In the pass-by-value case, <tt>x</tt> is copied once to the parameter of
<tt>resize</tt>.  And then internally, since the code can not know at compile
time by how much <tt>resize</tt> is growing the <tt>vector</tt>, <tt>x</tt> is
usually copied (not moved) a second time from <tt>resize</tt>'s parameter into its proper place
within the <tt>vector</tt>.
</p>

<p>
With pass-by-const-reference, the <tt>x</tt> in the above example need be copied
only once.  In this case, <tt>x</tt> has an expensive copy constructor and so any
copies that can be saved represents a significant savings.
</p>

<p>
If we can be efficient for <tt>push_back</tt>, we should be efficient for <tt>resize</tt>
as well.  The resize taking a reference parameter has been coded and shipped in the
CodeWarrior library with no reports of problems which I am aware of.
</p>



<p><b>Proposed resolution:</b></p>
<p>
Change 23.3.2 [deque], p2:
</p>

<blockquote><pre>class deque {
   ...
   void resize(size_type sz, <ins>const </ins>T<ins>&amp;</ins> c);
</pre></blockquote>

<p>
Change 23.3.2.2 [deque.capacity], p3:
</p>

<blockquote><pre>void resize(size_type sz, <ins>const </ins>T<ins>&amp;</ins> c);
</pre></blockquote>

<p>
Change 23.3.4 [list], p2:
</p>

<blockquote><pre>class list {
   ...
   void resize(size_type sz, <ins>const </ins>T<ins>&amp;</ins> c);
</pre></blockquote>

<p>
Change 23.3.4.2 [list.capacity], p3:
</p>

<blockquote><pre>void resize(size_type sz, <ins>const </ins>T<ins>&amp;</ins> c);
</pre></blockquote>

<p>
Change 23.4.1 [vector], p2:
</p>

<blockquote><pre>class vector {
   ...
   void resize(size_type sz, <ins>const </ins>T<ins>&amp;</ins> c);
</pre></blockquote>

<p>
Change 23.4.1.2 [vector.capacity], p11:
</p>

<blockquote><pre>void resize(size_type sz, <ins>const </ins>T<ins>&amp;</ins> c);
</pre></blockquote>






<hr>
<h3><a name="680"></a>680. move_iterator operator-&gt; return</h3>
<p><b>Section:</b> 24.5.3.1 [move.iterator] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2007-06-11 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#move.iterator">issues</a> in [move.iterator].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>move_iterator</tt>'s <tt>operator-&gt;</tt> return type <tt>pointer</tt>
does not consistently match the type which is returned in the description
in 24.5.3.3.5 [move.iter.op.ref].
</p>

<blockquote><pre>template &lt;class Iterator&gt;
class move_iterator {
public:
    ...
    typedef typename iterator_traits&lt;Iterator&gt;::pointer pointer;
    ...
    pointer operator-&gt;() const {return current;}
    ...
private: 
    Iterator current; // exposition only
};
</pre></blockquote>


<p>
There are two possible fixes.
</p>

<ol>
<li><tt>pointer operator-&gt;() const {return &amp;*current;}</tt></li>
<li><tt>typedef Iterator pointer;</tt></li>
</ol>

<p>
The first solution is the one chosen by <tt>reverse_iterator</tt>.  A potential
disadvantage of this is it may not work well with iterators which return a
proxy on dereference and that proxy has overloaded <tt>operator&amp;()</tt>.  Proxy
references often need to overloaad <tt>operator&amp;()</tt> to return a proxy
pointer.  That proxy pointer may or may not be the same type as the iterator's
<tt>pointer</tt> type.
</p>

<p>
By simply returning the <tt>Iterator</tt> and taking advantage of the fact that
the language forwards calls to <tt>operator-&gt;</tt> automatically until it
finds a non-class type, the second solution avoids the issue of an overloaded
<tt>operator&amp;()</tt> entirely.
</p>

<p><b>Proposed resolution:</b></p>
<p>
Change the synopsis in 24.5.3.1 [move.iterator]:
</p>

<blockquote><pre>typedef <del>typename iterator_traits&lt;</del>Iterator<del>&gt;::pointer</del> pointer;
</pre></blockquote>






<hr>
<h3><a name="681"></a>681. Operator functions impossible to compare are defined in [re.submatch.op]</h3>
<p><b>Section:</b> 28.9.2 [re.submatch.op] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Nozomu Katoo <b>Opened:</b> 2007-05-27 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#re.submatch.op">issues</a> in [re.submatch.op].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 28.9.2 [re.submatch.op] of N2284, 
operator functions numbered 31-42 seem impossible to compare. E.g.: 
</p>

<blockquote>
<pre>template &lt;class BiIter&gt;
   bool operator==(typename iterator_traits&lt;BiIter&gt;::value_type const&amp; lhs,
                    const sub_match&lt;BiIter&gt;&amp; rhs);
</pre>
<blockquote>
<p>
-31- <i>Returns:</i> <tt>lhs == rhs.str()</tt>.
</p>
</blockquote>
</blockquote>

<p>
When <tt>char*</tt> is used as <tt>BiIter</tt>, <tt>iterator_traits&lt;BiIter&gt;::value_type</tt> would be 
<tt>char</tt>, so that <tt>lhs == rhs.str()</tt> ends up comparing a <tt>char</tt> value and an object 
of <tt>std::basic_string&lt;char&gt;</tt>.  However, the behaviour of comparison between 
these two types is not defined in 21.4.8 [string.nonmembers] of N2284.
 This applies when <tt>wchar_t*</tt> is used as <tt>BiIter</tt>. 
</p>


<p><b>Proposed resolution:</b></p>
<p>
Adopt the proposed resolution in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2409.pdf">N2409</a>.
</p>


<p><i>[
Kona (2007): The LWG adopted the proposed resolution of N2409 for this issue.
The LWG voted to accelerate this issue to Ready status to be voted into the WP at Kona.
]</i></p>





<hr>
<h3><a name="682"></a>682. basic_regex ctor takes InputIterator or ForwardIterator?</h3>
<p><b>Section:</b> 28.8.2 [re.regex.construct] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Eric Niebler <b>Opened:</b> 2007-06-03 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#re.regex.construct">issues</a> in [re.regex.construct].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Looking at N2284, 28.8 [re.regex], p3 <tt>basic_regex</tt> class template synopsis shows this 
constructor: 
</p>
<blockquote><pre>template &lt;class InputIterator&gt;
     basic_regex(InputIterator first, InputIterator last, 
                 flag_type f = regex_constants::ECMAScript);
</pre></blockquote>

<p>
In 28.8.2 [re.regex.construct], p15, the constructor appears with this signature: 
</p>

<blockquote><pre>template &lt;class ForwardIterator&gt;
     basic_regex(ForwardIterator first, ForwardIterator last, 
                 flag_type f = regex_constants::ECMAScript);
</pre></blockquote>

<p>
<tt>ForwardIterator</tt> is probably correct, so the synopsis is wrong.
</p>

<p><i>[
John adds:
]</i></p>


<blockquote>
<p>
I think either could be implemented?  Although an input iterator would 
probably require an internal copy of the string being made.
</p>
<p>
I have no strong feelings either way, although I think my original intent 
was <tt>InputIterator</tt>. 
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Adopt the proposed resolution in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2409.pdf">N2409</a>.
</p>


<p><i>[
Kona (2007): The LWG adopted the proposed resolution of N2409 for this issue.
The LWG voted to accelerate this issue to Ready status to be voted into the WP at Kona.
]</i></p>





<hr>
<h3><a name="685"></a>685. reverse_iterator/move_iterator difference has invalid signatures</h3>
<p><b>Section:</b> 24.5.1.3.19 [reverse.iter.opdiff], 24.5.3.3.14 [move.iter.nonmember] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Bo Persson <b>Opened:</b> 2007-06-10 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In C++03 the difference between two <tt>reverse_iterators</tt>
</p>
<blockquote><pre>ri1 - ri2
</pre></blockquote>
<p>
is possible to compute only if both iterators have the same base 
iterator. The result type is the <tt>difference_type</tt> of the base iterator. 
</p>
<p>
In the current draft, the operator is defined as 24.5.1.3.19 [reverse.iter.opdiff] 
</p>
<blockquote><pre>template&lt;class Iterator1, class Iterator2&gt; 
typename reverse_iterator&lt;Iterator&gt;::difference_type 
   operator-(const reverse_iterator&lt;Iterator1&gt;&amp; x, 
                    const reverse_iterator&lt;Iterator2&gt;&amp; y);
</pre></blockquote>
<p>
The return type is the same as the C++03 one, based on the no longer 
present <tt>Iterator</tt> template parameter. 
</p>
<p>
Besides being slightly invalid, should this operator work only when 
<tt>Iterator1</tt> and <tt>Iterator2</tt> has the same <tt>difference_type</tt>? Or should the 
implementation choose one of them? Which one? 
</p>
<p>
The same problem now also appears in <tt>operator-()</tt> for <tt>move_iterator</tt>
24.5.3.3.14 [move.iter.nonmember]. 
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change the synopsis in 24.5.1.1 [reverse.iterator]:
</p>

<blockquote>
<pre>template &lt;class Iterator1, class Iterator2&gt; 
  <del>typename reverse_iterator&lt;Iterator&gt;::difference_type</del> <ins>auto</ins> operator-( 
    const reverse_iterator&lt;Iterator1&gt;&amp; x, 
    const reverse_iterator&lt;Iterator2&gt;&amp; y)<ins> -&gt; decltype(y.current - x.current)</ins>;
</pre>
</blockquote>

<p>
Change 24.5.1.3.19 [reverse.iter.opdiff]:
</p>

<blockquote>
<pre>template &lt;class Iterator1, class Iterator2&gt; 
  <del>typename reverse_iterator&lt;Iterator&gt;::difference_type</del> <ins>auto</ins> operator-( 
    const reverse_iterator&lt;Iterator1&gt;&amp; x, 
    const reverse_iterator&lt;Iterator2&gt;&amp; y)<ins> -&gt; decltype(y.current - x.current)</ins>;
</pre>
<blockquote>
<p>
<i>Returns:</i> <tt>y.current - x.current</tt>.
</p>
</blockquote>
</blockquote>


<p>
Change the synopsis in 24.5.3.1 [move.iterator]:
</p>

<blockquote>
<pre>template &lt;class Iterator1, class Iterator2&gt; 
  <del>typename move_iterator&lt;Iterator&gt;::difference_type</del> <ins>auto</ins> operator-( 
    const move_iterator&lt;Iterator1&gt;&amp; x, 
    const move_iterator&lt;Iterator2&gt;&amp; y)<ins> -&gt; decltype(x.base() - y.base())</ins>;
</pre>
</blockquote>

<p>
Change 24.5.3.3.14 [move.iter.nonmember]:
</p>

<blockquote>
<pre>template &lt;class Iterator1, class Iterator2&gt; 
  <del>typename move_iterator&lt;Iterator&gt;::difference_type</del> <ins>auto</ins> operator-( 
    const move_iterator&lt;Iterator1&gt;&amp; x, 
    const move_iterator&lt;Iterator2&gt;&amp; y)<ins> -&gt; decltype(x.base() - y.base())</ins>;
</pre>
<blockquote>
<p>
<i>Returns:</i> <tt>x.base() - y.base()</tt>.
</p>
</blockquote>
</blockquote>

<p><i>[
Pre Bellevue:  This issue needs to wait until the <tt>auto -&gt; return</tt> language feature
goes in.
]</i></p>







<hr>
<h3><a name="687"></a>687. shared_ptr conversion constructor not constrained</h3>
<p><b>Section:</b> 20.9.10.2.1 [util.smartptr.shared.const], 20.9.10.3.1 [util.smartptr.weak.const] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Peter Dimov <b>Opened:</b> 2007-05-10 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#util.smartptr.shared.const">issues</a> in [util.smartptr.shared.const].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Since all conversions from <tt>shared_ptr&lt;T&gt;</tt> to <tt>shared_ptr&lt;U&gt;</tt> have the same
rank regardless of the relationship between <tt>T</tt> and <tt>U</tt>, reasonable user
code that works with raw pointers fails with <tt>shared_ptr</tt>:
</p>

<blockquote><pre>void f( shared_ptr&lt;void&gt; );
void f( shared_ptr&lt;int&gt; );

int main()
{
  f( shared_ptr&lt;double&gt;() ); // ambiguous
}
</pre></blockquote>

<p>
Now that we officially have <tt>enable_if</tt>, we can constrain the constructor
and the corresponding assignment operator to only participate in the
overload resolution when the pointer types are compatible.
</p>


<p><b>Proposed resolution:</b></p>
<p>
In 20.9.10.2.1 [util.smartptr.shared.const], change:
</p>

<blockquote><p>
-14- <i>Requires:</i> <del>For the second constructor</del> <ins>The
second constructor shall not participate in the overload resolution
unless</ins> <tt>Y*</tt> <del>shall be</del> <ins>is implicitly</ins> convertible
to <tt>T*</tt>.
</p></blockquote>

<p>
In 20.9.10.3.1 [util.smartptr.weak.const], change:
</p>

<blockquote>
<pre><del>template&lt;class Y&gt; weak_ptr(shared_ptr&lt;Y&gt; const&amp; r);</del>
<del>weak_ptr(weak_ptr const&amp; r);</del>
<del>template&lt;class Y&gt; weak_ptr(weak_ptr&lt;Y&gt; const&amp; r);</del>
<ins>weak_ptr(weak_ptr const&amp; r);</ins>
<ins>template&lt;class Y&gt; weak_ptr(weak_ptr&lt;Y&gt; const&amp; r);</ins>
<ins>template&lt;class Y&gt; weak_ptr(shared_ptr&lt;Y&gt; const&amp; r);</ins>
</pre>
<blockquote><p>
-4- <i>Requires:</i> <del>For</del> <del>t</del><ins>T</ins>he second and
third constructors<del>,</del> <ins>shall not participate in the
overload resolution unless</ins> <tt>Y*</tt> <del>shall be</del>
<ins>is implicitly</ins> convertible to <tt>T*</tt>.
</p></blockquote>
</blockquote>






<hr>
<h3><a name="688"></a>688. reference_wrapper, cref unsafe, allow binding to rvalues</h3>
<p><b>Section:</b> 20.8.4.1 [refwrap.const] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Peter Dimov <b>Opened:</b> 2007-05-10 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#refwrap.const">issues</a> in [refwrap.const].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
A <tt>reference_wrapper</tt> can be constructed from an rvalue, either by using
the constructor, or via <tt>cref</tt> (and <tt>ref</tt> in some corner cases). This leads
to a dangling reference being stored into the <tt>reference_wrapper</tt> object.
Now that we have a mechanism to detect an rvalue, we can fix them to
disallow this source of undefined behavior.
</p>

<p>
Also please see the thread starting at c++std-lib-17398 for some good discussion on this subject.
</p>

<p><i>[
2009-05-09 Alisdair adds:
]</i></p>


<blockquote>
<p>
Now that <tt>ref/cref</tt> are constained that <tt>T</tt> must be an <tt>ObjectType</tt>, I do not
believe there is any risk of binding <tt>ref</tt> to a temporary (which would rely on
deducing <tt>T</tt> to be an rvalue reference type)
</p>
<p>
However, the problem for <tt>cref</tt> remains, so I recommend retaining that deleted
overload.
</p>
</blockquote>

<p><i>[
2009-05-10 Howard adds:
]</i></p>


<blockquote>
<p>
Without:
</p>

<blockquote><pre>template &lt;class T&gt; void ref(const T&amp;&amp; t) = delete;
</pre></blockquote>
<p>
I believe this program will compile:
</p>

<blockquote><pre>#include &lt;functional&gt;

struct A {};

const A source() {return A();}

int main()
{
   std::reference_wrapper&lt;const A&gt; r = std::ref(source());
}
</pre></blockquote>
<p>
I.e. in:
</p>
<blockquote><pre>template &lt;ObjectType T&gt; reference_wrapper&lt;T&gt; ref(T&amp; t);
</pre></blockquote>

<p>
this:
</p>

<blockquote><pre>ref(source())
</pre></blockquote>
<p>
deduces <tt>T</tt> as <tt>const A</tt>, and so:
</p>

<blockquote><pre>ref(const A&amp; t)
</pre></blockquote>

<p>
will bind to a temporary (tested with a pre-concepts rvalue-ref enabled compiler).
</p>
<p>
Therefore I think we still need the ref-protection.  I respectfully disagree with Alisdair's
comment and am in favor of the proposed wording as it stands.  Also, CWG 606
(noted below) has now been "favorably" resolved.
</p>

</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution.
Move to Tentatively Ready.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
In 20.8 [function.objects], add the following two signatures to the synopsis:
</p>

<blockquote><pre>template &lt;class T&gt; void ref(const T&amp;&amp; t) = delete;
template &lt;class T&gt; void cref(const T&amp;&amp; t) = delete;
</pre></blockquote>



<p><i>[
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2292.html">N2292</a>
addresses the first part of the resolution but not the second.
]</i></p>


<p><i>[
Bellevue:  Doug noticed problems with the current wording.
]</i></p>


<p><i>[
post Bellevue:  Howard and Peter provided revised wording.
]</i></p>


<p><i>[
This resolution depends on a "favorable" resolution of CWG 606:  that is,
the "special deduction rule" is disabled with the const T&amp;&amp; pattern.
]</i></p>





<hr>
<h3><a name="689"></a>689. reference_wrapper constructor overly constrained</h3>
<p><b>Section:</b> 20.8.4.1 [refwrap.const] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Peter Dimov <b>Opened:</b> 2007-05-10 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#refwrap.const">issues</a> in [refwrap.const].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The constructor of <tt>reference_wrapper</tt> is currently <tt>explicit</tt>. The primary
motivation behind this is the safety problem with respect to rvalues,
which is addressed by the proposed resolution of the previous issue.
Therefore we should consider relaxing the requirements on the
constructor since requests for the implicit conversion keep resurfacing.
</p>
<p>
Also please see the thread starting at c++std-lib-17398 for some good discussion on this subject.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Remove the <tt>explicit</tt> from the constructor of <tt>reference_wrapper</tt>. If the
proposed resolution of the previous issue is accepted, remove the
<tt>explicit</tt> from the <tt>T&amp;&amp;</tt> constructor as well to keep them in sync.
</p>





<hr>
<h3><a name="691"></a>691. const_local_iterator cbegin, cend missing from TR1</h3>
<p><b>Section:</b> 23.7 [unord], TR1 6.3 [tr.hash] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Joaqun M Lpez Muoz <b>Opened:</b> 2007-06-14 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#unord">issues</a> in [unord].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The last version of TR1 does not include the following member
functions
for unordered containers:
</p>

<blockquote><pre>const_local_iterator cbegin(size_type n) const;
const_local_iterator cend(size_type n) const;
</pre></blockquote>

<p>
which looks like an oversight to me. I've checked th TR1 issues lists
and the latest working draft of the C++0x std (N2284) and haven't
found any mention to these menfuns or to their absence.
</p>
<p>
Is this really an oversight, or am I missing something?
</p>



<p><b>Proposed resolution:</b></p>
<p>
Add the following two rows to table 93 (unordered associative container
requirements) in section 23.2.5 [unord.req]:
</p>

<blockquote>
<table border="1">
<caption>Unordered associative container requirements (in addition to container)</caption>
<tbody><tr>
<th>expression</th> <th>return type</th> <th>assertion/note pre/post-condition</th> <th>complexity</th>
</tr>
<tr>
<td><ins><tt>b.cbegin(n)</tt></ins></td> <td><ins><tt>const_local_iterator</tt></ins></td> <td><ins><tt>n</tt> shall be in the range <tt>[0, bucket_count())</tt>. Note: <tt>[b.cbegin(n), b.cend(n))</tt> is a valid range containing all of the elements in the <tt>n</tt><sup><i>th</i></sup> bucket.</ins></td> <td><ins>Constant</ins></td> 
</tr>
<tr>
<td><ins><tt>b.cend(n)</tt></ins></td> <td><ins><tt>const_local_iterator</tt></ins></td> <td><ins><tt>n</tt> shall be in the range <tt>[0, bucket_count())</tt>.</ins></td> <td><ins>Constant</ins></td> 
</tr>
</tbody></table>
</blockquote>

<p>
Add to the synopsis in 23.7.1 [unord.map]:
</p>

<blockquote><pre><ins>const_local_iterator cbegin(size_type n) const;
const_local_iterator cend(size_type n) const;</ins>
</pre></blockquote>

<p>
Add to the synopsis in 23.7.2 [unord.multimap]:
</p>

<blockquote><pre><ins>const_local_iterator cbegin(size_type n) const;
const_local_iterator cend(size_type n) const;</ins>
</pre></blockquote>

<p>
Add to the synopsis in 23.7.3 [unord.set]:
</p>

<blockquote><pre><ins>const_local_iterator cbegin(size_type n) const;
const_local_iterator cend(size_type n) const;</ins>
</pre></blockquote>

<p>
Add to the synopsis in 23.7.4 [unord.multiset]:
</p>

<blockquote><pre><ins>const_local_iterator cbegin(size_type n) const;
const_local_iterator cend(size_type n) const;</ins>
</pre></blockquote>






<hr>
<h3><a name="692"></a>692. <code>get_money</code> and <code>put_money</code> should be formatted I/O functions</h3>
<p><b>Section:</b> 27.7.4 [ext.manip] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2007-06-22 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#ext.manip">issues</a> in [ext.manip].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In a private email Bill Plauger notes:
</p>
<blockquote><p>
I  believe that  the function  that  implements <code>get_money</code>
[from <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2072.html">N2072</a>]
should behave  as a  formatted input function,  and the  function that
implements <code>put_money</code> should  behave as a formatted output
function. This  has implications regarding the  skipping of whitespace
and the handling of errors, among other things.
</p>
<p>
The words  don't say that  right now and  I'm far from  convinced that
such a change is editorial.
</p></blockquote>
<p>
Martin's response:
</p>
<blockquote><p>
I agree that the manipulators should handle exceptions the same way as
formatted I/O functions do. The text in N2072 assumes so but the
<i>Returns</i> clause explicitly omits exception handling for the sake
of brevity. The spec should be clarified to that effect.
</p>
<p>
As for dealing  with whitespace, I also agree it  would make sense for
the extractors  and inserters involving the new  manipulators to treat
it the same way as formatted I/O.
</p></blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Add  a new  paragraph immediately  above  p4 of 27.7.4 [ext.manip] with  the
following text:
</p>
<blockquote><p>
<i>Effects</i>:  The   expression  <code><i>in</i> &gt;&gt; get_money(mon, intl)</code>
described below behaves as a formatted input function (as
described in 27.7.1.2.1 [istream.formatted.reqmts]).
</p></blockquote>
<p>
Also change p4 of 27.7.4 [ext.manip] as follows:
</p>
<blockquote><p>
<i>Returns</i>: An object <code>s</code> of unspecified type such that
if <code>in</code> is  an object of type <code>basic_istream&lt;charT,
traits&gt;</code>    then    the    expression   <code><i>in</i> &gt;&gt; get_money(mon, intl)</code> behaves as <ins>a formatted input function
that    calls    </ins><code>f(in, mon, intl)</code><del>    were
called</del>. The function <code>f</code> can be defined as...
</p></blockquote>


<p><i>[
post Bellevue:
]</i></p>


<blockquote>
We recommend moving immediately to Review. We've looked at the issue and
have a consensus that the proposed resolution is correct, but want an
iostream expert to sign off. Alisdair has taken the action item to putt
this up on the reflector for possible movement by Howard to Tenatively
Ready.
</blockquote>




<hr>
<h3><a name="693"></a>693. <code>std::bitset::all()</code> missing</h3>
<p><b>Section:</b> 20.5 [template.bitset] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2007-06-22 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#template.bitset">issues</a> in [template.bitset].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The  <code>bitset</code> class template  provides the  member function
<code>any()</code> to determine whether an  object of the type has any
bits  set, and  the member  function <code>none()</code>  to determine
whether all of an object's  bits are clear. However, the template does
not   provide  a   corresponding  function   to  discover   whether  a
<code>bitset</code>  object  has  all  its  bits  set.   While  it  is
possible,  even easy,  to  obtain this  information  by comparing  the
result of <code>count()</code>  with the result of <code>size()</code>
for  equality  (i.e.,  via  <code>b.count()  ==  b.size()</code>)  the
operation  is   less  efficient   than  a  member   function  designed
specifically  for that purpose  could be.   (<code>count()</code> must
count  all non-zero bits  in a  <code>bitset</code> a  word at  a time
while <code>all()</code> could stop counting as soon as it encountered
the first word with a zero bit).
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add  a declaration of the new  member function <code>all()</code> to the
defintion of the <code>bitset</code> template in 20.5 [template.bitset], p1,
right above the declaration of <code>any()</code> as shown below:
</p>

<blockquote><pre>bool operator!=(const bitset&lt;N&gt;&amp; rhs) const;
bool test(size_t pos) const;
<ins>bool all() const;</ins>
bool any() const;
bool none() const;
</pre></blockquote>

<p>
Add a description of the new member function to the end of 20.5.2 [bitset.members] with the following text:
</p>
<blockquote><p>
<code>bool all() const;</code>
</p>
<blockquote>
<i>Returns</i>: <code>count() == size()</code>.
</blockquote>
</blockquote>

<p>
In  addition,   change  the  description   of  <code>any()</code>  and
<code>none()</code>   for  consistency   with   <code>all()</code>  as
follows:
</p>
<blockquote><p>
<code>bool any() const;</code>
</p>
<blockquote>
<p>
<i>Returns</i>: <del><code>true</code> if any bit in <code>*this</code>
is one</del><ins><code>count() != 0</code></ins>.
</p>
</blockquote>
<p>
<code>bool none() const;</code>
</p>
<blockquote>
<p>
<i>Returns</i>: <del><code>true</code> if no bit in <code>*this</code>
is one</del><ins><code>count() == 0</code></ins>.
</p>
</blockquote>
</blockquote>





<hr>
<h3><a name="694"></a>694. <code>std::bitset</code> and <code>long long</code></h3>
<p><b>Section:</b> 20.5 [template.bitset] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2007-06-22 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#template.bitset">issues</a> in [template.bitset].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Objects of the  <code>bitset</code> class template specializations can
be constructed from  and explicitly converted to values  of the widest
C++ integer  type, <code>unsigned long</code>.   With the introduction
of  <code>long long</code> into  the language  the template  should be
enhanced to make it possible  to interoperate with values of this type
as well, or  perhaps <code>uintmax_t</code>.  See c++std-lib-18274 for
a brief discussion in support of this change.
</p>


<p><b>Proposed resolution:</b></p>
<p>
For simplicity,  instead of  adding overloads for  <code>unsigned long
long</code> and dealing with possible ambiguities in the spec, replace
the <code>bitset</code> ctor  that takes an <code>unsigned long</code>
argument  with  one  taking  <code>unsigned long  long</code>  in  the
definition  of the  template as  shown below.   (The  standard permits
implementations  to add  overloads on  other integer  types  or employ
template tricks to  achieve the same effect provided  they don't cause
ambiguities or changes in behavior.)
</p>
<blockquote>
<pre>// [bitset.cons] constructors:
bitset();
bitset(unsigned <ins>long</ins> long val);
template&lt;class charT, class traits, class Allocator&gt;
explicit bitset(
                const basic_string&lt;charT,traits,Allocator&gt;&amp; str,
                typename basic_string&lt;charT,traits,Allocator&gt;::size_type pos = 0,
                typename basic_string&lt;charT,traits,Allocator&gt;::size_type n =
                    basic_string&lt;charT,traits,Allocator&gt;::npos);
</pre>
</blockquote>
<p>
Make a corresponding change in 20.5.1 [bitset.cons], p2:
</p>
<blockquote>
<p>
<code>bitset(unsigned <ins>long</ins> long val);</code>
</p>
<blockquote>
<i>Effects</i>:  Constructs   an  object  of   class  bitset&lt;N&gt;,
initializing  the  first <code><i>M</i></code>  bit  positions to  the
corresponding      bit     values      in     <code><i>val</i></code>.
<code><i>M</i></code> is the  smaller of <code><i>N</i></code> and the
number of bits in  the value representation (section [basic.types]) of
<code>unsigned  <ins> long</ins> long</code>.   If  <code><i>M</i> &lt;
<i>N</i></code>  <ins>is  <code>true</code></ins>,  the remaining  bit
positions are initialized to zero.
</blockquote>
</blockquote>

<p>
Additionally, introduce a new member function <code>to_ullong()</code>
to make  it possible to  convert <code>bitset</code> to values  of the
new  type. Add  the following  declaration  to the  definition of  the
template, immediate  after the declaration  of <code>to_ulong()</code>
in 20.5 [template.bitset], p1, as shown below:
</p>
<blockquote>
<pre>// element access:
bool operator[](size_t pos) const; // for b[i];
reference operator[](size_t pos); // for b[i];
unsigned long to_ulong() const;
<ins>unsigned long long to_ullong() const;</ins>
template &lt;class charT, class traits, class Allocator&gt;
basic_string&lt;charT, traits, Allocator&gt; to_string() const;
</pre>
</blockquote>
<p>
And add a description of  the new member function to 20.5.2 [bitset.members],
below  the  description of  the  existing <code>to_ulong()</code>  (if
possible), with the following text:
</p>
<blockquote>
<p>
<code>unsigned long long to_ullong() const;</code>
</p>
<blockquote>
<i>Throws</i>:  <code>overflow_error</code>   if  the  integral  value
<code><i>x</i></code> corresponding to  the bits in <code>*this</code>
cannot be represented as type <code>unsigned long long</code>.
</blockquote>
<blockquote>
<i>Returns:</i> <code><i>x</i></code>.
</blockquote>
</blockquote>





<hr>
<h3><a name="695"></a>695. ctype&lt;char&gt;::classic_table() not accessible</h3>
<p><b>Section:</b> 22.4.1.3 [facet.ctype.special] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2007-06-22 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The   <code>ctype&lt;char&gt;::classic_table()</code>   static  member
function    returns    a    pointer    to   an    array    of    const
<code>ctype_base::mask</code>    objects    (enums)   that    contains
<code>ctype&lt;char&gt;::table_size</code>    elements.    The   table
describes the properties of the character set in the "C" locale (i.e.,
whether a  character at an index  given by its value  is alpha, digit,
punct,   etc.),   and   is    typically   used   to   initialize   the
<code>ctype&lt;char&gt;</code>  facet in the  classic "C"  locale (the
protected      <code>ctype&lt;char&gt;</code>      member     function
<code>table()</code>    then    returns     the    same    value    as
<code>classic_table()</code>).
</p>
<p>
However, while <code>ctype&lt;char&gt;::table_size</code> (the size of
the   table)    is   a   public    static   const   member    of   the
<code>ctype&lt;char&gt;</code>           specialization,           the
<code>classic_table()</code> static member function is protected. That
makes getting at the classic  data less than convenient (i.e., one has
to create  a whole derived class just  to get at the  masks array). It
makes  little sense  to expose  the size  of the  table in  the public
interface while making the table itself protected, especially when the
table is a constant object.
</p>
<p>
The  same argument  can be  made for  the non-static  protected member
function <code>table()</code>.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Make     the    <code>ctype&lt;char&gt;::classic_table()</code>    and
<code>ctype&lt;char&gt;::table()</code>  member  functions  public  by
moving their declarations into the public section of the definition of
specialization in 22.4.1.3 [facet.ctype.special] as shown below:
</p>
<blockquote>
<pre>  static locale::id id;
  static const size_t table_size = IMPLEMENTATION_DEFINED;
<del>protected:</del>
  const mask* table() const throw();
  static const mask* classic_table() throw();
<ins>protected:</ins>

~ctype(); // virtual
virtual char do_toupper(char c) const;
</pre>
</blockquote>





<hr>
<h3><a name="696"></a>696. <code>istream::operator&gt;&gt;(int&amp;)</code> broken</h3>
<p><b>Section:</b> 27.7.1.2.2 [istream.formatted.arithmetic] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2007-06-23 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#istream.formatted.arithmetic">issues</a> in [istream.formatted.arithmetic].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
From message c++std-lib-17897:
</p>
<p>
The code shown in 27.7.1.2.2 [istream.formatted.arithmetic] as the "as if"
implementation of the two arithmetic extractors that don't have a
corresponding <code>num_get</code> interface (i.e., the
<code>short</code> and <code>int</code> overloads) is subtly buggy in
how it deals with <code>EOF</code>, overflow, and other similar
conditions (in addition to containing a few typos).
</p>
<p>
One problem is that if <code>num_get::get()</code> reaches the EOF
after reading in an otherwise valid value that exceeds the limits of
the narrower type (but not <code>LONG_MIN</code> or
<code>LONG_MAX</code>), it will set <code><i>err</i></code> to
<code>eofbit</code>. Because of the if condition testing for
<code>(<i>err</i> == 0)</code>, the extractor won't set
<code>failbit</code> (and presumably, return a bogus value to the
caller).
</p>
<p>
Another problem with the code is that it never actually sets the
argument to the extracted value. It can't happen after the call to
<code>setstate()</code> since the function may throw, so we need to
show when and how it's done (we can't just punt as say: "it happens
afterwards"). However, it turns out that showing how it's done isn't
quite so easy since the argument is normally left unchanged by the
facet on error except when the error is due to a misplaced thousands
separator, which causes <code>failbit</code> to be set but doesn't
prevent the facet from storing the value.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We believe this part of the Standard has been recently adjusted
and that this issue was addressed during that rewrite.
</p>
<p>
Move to NAD.
</p>
</blockquote>

<p><i>[
2009-05-28 Howard adds:
]</i></p>


<blockquote>
<p>
I've moved this issue from Tentatively NAD to Open.
</p>

<p>
The current wording of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2857.pdf">N2857</a>
in 22.4.2.1.2 [facet.num.get.virtuals] p3, stage 3 appears to indicate that
in parsing arithmetic types, the value is always set, but sometimes in addition
to setting <tt>failbit</tt>.
</p>

<ul>
<li>
If there is a range error, the value is set to min or max, else
</li>
<li>
if there is a conversion error, the value is set to 0, else
</li>
<li>
if there is a grouping error, the value is set to whatever it would be if grouping were ignored, else
</li>
<li>
the value is set to its error-free result.
</li>
</ul>

<p>
However there is a contradictory sentence in 22.4.2.1.2 [facet.num.get.virtuals] p1.
</p>

<p>
27.7.1.2.2 [istream.formatted.arithmetic] should mimic the behavior of 22.4.2.1.2 [facet.num.get.virtuals]
(whatever we decide that behavior is) for
<tt>int</tt> and <tt>short</tt>, and currently does not.  I believe that the
correct code fragment should look like:
</p>

<blockquote><pre>typedef num_get&lt;charT,istreambuf_iterator&lt;charT,traits&gt; &gt; numget;
iostate err = ios_base::goodbit;
long lval;
use_facet&lt;numget&gt;(loc).get(*this, 0, *this, err, lval);
if (lval &lt; numeric_limits&lt;int&gt;::min())
{
  err |= ios_base::failbit;
  val = numeric_limits&lt;int&gt;::min();
}
else if (lval &gt; numeric_limits&lt;int&gt;::max())
{
  err |= ios_base::failbit;
  val = numeric_limits&lt;int&gt;::max();
}
else
  val = static_cast&lt;int&gt;(lval);
setstate(err);
</pre></blockquote>
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
Move to Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 22.4.2.1.2 [facet.num.get.virtuals], p1:
</p>

<blockquote>
-1- <i>Effects:</i> Reads characters from <tt>in</tt>, interpreting them
according to <tt>str.flags()</tt>, <tt>use_facet&lt;ctype&lt;charT&gt;
&gt;(loc)</tt>, and <tt>use_facet&lt; numpunct&lt;charT&gt;
&gt;(loc)</tt>, where <tt>loc</tt> is <tt>str.getloc()</tt>. <del>If an error
occurs, <tt>val</tt> is unchanged; otherwise it is set to the resulting value.</del>
</blockquote>

<p>
Change 27.7.1.2.2 [istream.formatted.arithmetic], p2 and p3:
</p>

<blockquote>
<pre>operator&gt;&gt;(short&amp; val);
</pre>
<blockquote>
<p>
-2- The conversion occurs as if performed by the following code fragment (using the same notation as for 
the preceding code fragment):
</p>

<blockquote><pre>typedef num_get&lt;charT,istreambuf_iterator&lt;charT,traits&gt; &gt; numget;
iostate err = ios<del>tate</del><ins>_base</ins>::goodbit;
long lval;
use_facet&lt;numget&gt;(loc).get(*this, 0, *this, err, lval);
<del>if (err != 0)
  ;
else if (lval &lt; numeric_limits&lt;short&gt;::min()
  || numeric_limits&lt;short&gt;::max() &lt; lval)
     err = ios_base::failbit;</del>
<ins>if (lval &lt; numeric_limits&lt;short&gt;::min())
{
  err |= ios_base::failbit;
  val = numeric_limits&lt;short&gt;::min();
}
else if (lval &gt; numeric_limits&lt;short&gt;::max())
{
  err |= ios_base::failbit;
  val = numeric_limits&lt;short&gt;::max();
}</ins>
else
  val = static_cast&lt;short&gt;(lval);
setstate(err);
</pre></blockquote>

</blockquote>

<pre>operator&gt;&gt;(int&amp; val);
</pre>
<blockquote>
<p>
-3- The conversion occurs as if performed by the following code fragment (using the same notation as for 
the preceding code fragment):
</p>

<blockquote><pre>typedef num_get&lt;charT,istreambuf_iterator&lt;charT,traits&gt; &gt; numget;
iostate err = ios<del>tate</del><ins>_base</ins>::goodbit;
long lval;
use_facet&lt;numget&gt;(loc).get(*this, 0, *this, err, lval);
<del>if (err != 0)
  ;
else if (lval &lt; numeric_limits&lt;int&gt;::min()
  || numeric_limits&lt;int&gt;::max() &lt; lval)
     err = ios_base::failbit;</del>
<ins>if (lval &lt; numeric_limits&lt;int&gt;::min())
{
  err |= ios_base::failbit;
  val = numeric_limits&lt;int&gt;::min();
}
else if (lval &gt; numeric_limits&lt;int&gt;::max())
{
  err |= ios_base::failbit;
  val = numeric_limits&lt;int&gt;::max();
}</ins>
else
  val = static_cast&lt;int&gt;(lval);
setstate(err);
</pre></blockquote>

</blockquote>

</blockquote>





<hr>
<h3><a name="697"></a>697. New <tt>&lt;system_error&gt;</tt> header leads to name clashes</h3>
<p><b>Section:</b> 19.5 [syserr] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2007-06-24 <b>Last modified:</b> 2010-11-19</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#syserr">issues</a> in [syserr].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The most recent state of 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2241.html">N2241</a>
as well as the current draft
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2284.pdf">N2284</a>
(section 19.5 [syserr], p.2) proposes a
new
enumeration type <tt>posix_errno</tt> immediatly in the namespace <tt>std</tt>. One of
the enumerators has the name <tt>invalid_argument</tt>, or fully qualified:
<tt>std::invalid_argument</tt>. This name clashes with the exception type
<tt>std::invalid_argument</tt>, see 19.2 [std.exceptions]/p.3. This clash makes
e.g. the following snippet invalid:
</p>

<blockquote><pre>#include &lt;system_error&gt;
#include &lt;stdexcept&gt;

void foo() { throw std::invalid_argument("Don't call us - we call you!"); }
</pre></blockquote>

<p>
I propose that this enumeration type (and probably the remaining parts
of
<tt>&lt;system_error&gt;</tt> as well) should be moved into one additional inner
namespace, e.g. <tt>sys</tt> or <tt>system</tt> to reduce foreseeable future clashes
due
to the great number of members that <tt>std::posix_errno</tt> already contains
(Btw.: Why has the already proposed <tt>std::sys</tt> sub-namespace from
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2066.html">N2066</a>
been rejected?). A further clash <em>candidate</em> seems to be
<tt>std::protocol_error</tt>
(a reasonable name for an exception related to a std network library,
I guess).
</p>

<p>
Another possible resolution would rely on the proposed strongly typed
enums,
as described in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2213.pdf">N2213</a>.
But maybe the forbidden implicit conversion to integral types would
make
these enumerators less attractive in this special case?
</p>


<p><b>Proposed resolution:</b></p>
<p>
Fixed by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2422.htm#Issue7">issue 7 of N2422</a>.
</p>






<hr>
<h3><a name="698"></a>698. <tt>system_error</tt> needs <tt>const char*</tt> constructors</h3>
<p><b>Section:</b> 19.5.6.1 [syserr.syserr.overview] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2007-06-24 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 19.5.6.1 [syserr.syserr.overview] we have the class definition of
<tt>std::system_error</tt>. In contrast to all exception classes, which
are constructible with a <tt>what_arg string</tt> (see 19.2 [std.exceptions],
or <tt>ios_base::failure</tt> in 27.5.2.1.1 [ios::failure]), only overloads with with
<tt>const string&amp;</tt> are possible. For consistency with the re-designed
remaining exception classes this class should also provide
c'tors which accept a const <tt>char* what_arg</tt> string.
</p>
<p>
Please note that this proposed addition makes sense even
considering the given implementation hint for <tt>what()</tt>, because
<tt>what_arg</tt> is required to be set as <tt>what_arg</tt> of the base class
<tt>runtime_error</tt>, which now has the additional c'tor overload
accepting a <tt>const char*</tt>.
</p>


<p><b>Proposed resolution:</b></p>
<p>
This proposed wording assumes issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#832">832</a> has been accepted and applied to the working paper.
</p>

<p>
Change 19.5.6.1 [syserr.syserr.overview] Class system_error overview, as indicated:
</p>

<blockquote><pre>public:
  system_error(error_code ec, const string&amp; what_arg);
  <ins>system_error(error_code ec, const char* what_arg);</ins>
  system_error(error_code ec);
  system_error(int ev, const error_category* ecat,
      const string&amp; what_arg);
  <ins>system_error(int ev, const error_category* ecat,
      const char* what_arg);</ins>
  system_error(int ev, const error_category* ecat);
</pre></blockquote>

<p>
To 19.5.6.2 [syserr.syserr.members] Class system_error members add:
</p>

<blockquote>
<pre>system_error(error_code ec, const char* what_arg);
</pre>
<blockquote>
<p>
<i>Effects:</i> Constructs an object of class <tt>system_error</tt>.
</p>
<p>
<i>Postconditions:</i> <tt>code() == ec</tt> and <tt>strcmp(runtime_error::what(), what_arg) == 0</tt>.
</p>
</blockquote>

<pre>system_error(int ev, const error_category* ecat, const char* what_arg);
</pre>

<blockquote>
<p>
<i>Effects:</i> Constructs an object of class <tt>system_error</tt>.
</p>
<p>
<i>Postconditions:</i> <tt>code() == error_code(ev, ecat)</tt> and <tt>strcmp(runtime_error::what(), what_arg) == 0</tt>.
</p>
</blockquote>
</blockquote>






<hr>
<h3><a name="699"></a>699. N2111 changes min/max</h3>
<p><b>Section:</b> 26.5 [rand] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> P.J. Plauger <b>Opened:</b> 2007-07-01 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand">issues</a> in [rand].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2111.pdf">N2111</a>
changes <tt>min/max</tt> in several places in random from member
functions to static data members. I believe this introduces
a needless backward compatibility problem between C++0X and
TR1. I'd like us to find new names for the static data members,
or perhaps change <tt>min/max</tt> to <tt>constexpr</tt>s in C++0X.
</p>

<p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2391.pdf">N2391</a> and
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2423.pdf">N2423</a>
for some further discussion.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Adopt the proposed resolution in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2423.pdf">N2423</a>.
</p>


<p><i>[
Kona (2007): The LWG adopted the proposed resolution of N2423 for this issue.
The LWG voted to accelerate this issue to Ready status to be voted into the WP at Kona.
]</i></p>





<hr>
<h3><a name="700"></a>700. N1856 defines struct <tt>identity</tt></h3>
<p><b>Section:</b> 20.3.3 [forward] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> P.J. Plauger <b>Opened:</b> 2007-07-01 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#forward">issues</a> in [forward].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1856.html">N1856</a>
defines struct <tt>identity</tt> in <tt>&lt;utility&gt;</tt> which clashes with
the traditional definition of struct <tt>identity</tt> in <tt>&lt;functional&gt;</tt>
(not standard, but a common extension from old STL). Be nice
if we could avoid this name clash for backward compatibility.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change 20.3.3 [forward]:
</p>

<blockquote>
<pre>template &lt;class T&gt; struct identity
{
    typedef T type;
    <ins>const T&amp; operator()(const T&amp; x) const;</ins>
};
</pre>
<blockquote>
<pre><ins>const T&amp; operator()(const T&amp; x) const;</ins>
</pre>
<blockquote>
<p>
<ins><i>Returns:</i> <tt>x</tt>.</ins>
</p>
</blockquote>
</blockquote>

</blockquote>






<hr>
<h3><a name="703"></a>703. <tt>map::at()</tt> need a complexity specification</h3>
<p><b>Section:</b> 23.6.1.2 [map.access] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Joe Gottman <b>Opened:</b> 2007-07-03 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#map.access">issues</a> in [map.access].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>map::at()</tt> need a complexity specification.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add the following to the specification of <tt>map::at()</tt>, 23.6.1.2 [map.access]:
</p>
<blockquote>
<p>
<i>Complexity:</i> logarithmic.
</p>
</blockquote>





<hr>
<h3><a name="704"></a>704. MoveAssignable requirement for container value type overly strict</h3>
<p><b>Section:</b> 23.2 [container.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2007-05-20 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#container.requirements">issues</a> in [container.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The move-related changes inadvertently overwrote the intent of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#276">276</a>.
Issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#276">276</a> removed the requirement of <tt>CopyAssignable</tt> from
most of the member functions of node-based containers.  But the move-related changes
unnecessarily introduced the <tt>MoveAssignable</tt> requirement for those members which used to
require <tt>CopyAssignable</tt>.
</p>

<p>
We also discussed (c++std-lib-18722) the possibility of dropping <tt>MoveAssignable</tt>
from some of the sequence requirements.  Additionally the <i>in-place</i> construction
work may further reduce requirements.  For purposes of an easy reference, here are the
minimum sequence requirements as I currently understand them.  Those items in requirements
table in the working draft which do not appear below have been purposefully omitted for
brevity as they do not have any requirements of this nature.  Some items which do not
have any requirements of this nature are included below just to confirm that they were
not omitted by mistake.
</p>

<table border="1">
<caption>Container Requirements</caption>
<tbody><tr><td><tt>X u(a)</tt></td><td><tt>value_type</tt> must be <tt>CopyConstructible</tt></td></tr>
<tr><td><tt>X u(rv)</tt></td><td><tt>array</tt> requires <tt>value_type</tt> to be <tt>CopyConstructible</tt></td></tr>
<tr><td><tt>a = u</tt></td><td>Sequences require <tt>value_type</tt> to be <tt>CopyConstructible</tt> and <tt>CopyAssignable</tt>.
                               Associative containers require <tt>value_type</tt> to be <tt>CopyConstructible</tt>.</td></tr>
<tr><td><tt>a = rv</tt></td><td><tt>array</tt> requires <tt>value_type</tt> to be <tt>CopyAssignable</tt>.
                                Sequences containers with <tt>propagate_on_container_move_assignment == false</tt> allocators require <tt>value_type</tt> to be <tt>MoveConstructible</tt> and <tt>MoveAssignable</tt>.
                                Associative containers with <tt>propagate_on_container_move_assignment == false</tt> allocators require <tt>value_type</tt> to be <tt>MoveConstructible</tt>.</td></tr>
<tr><td><tt>swap(a,u)</tt></td><td><tt>array</tt> requires <tt>value_type</tt> to be <tt>Swappable</tt>.</td></tr>
</tbody></table>

<p>
</p>

<table border="1">
<caption>Sequence Requirements</caption>
<tbody><tr><td><tt>X(n)</tt></td><td><tt>value_type</tt> must be <tt>DefaultConstructible</tt></td></tr>
<tr><td><tt>X(n, t)</tt></td><td><tt>value_type</tt> must be <tt>CopyConstructible</tt></td></tr>
<tr><td><tt>X(i, j)</tt></td><td>Sequences require <tt>value_type</tt> to be constructible from <tt>*i</tt>.  Additionally if input_iterators
                                 are used, <tt>vector</tt> and <tt>deque</tt> require <tt>MoveContructible</tt> and <tt>MoveAssignable</tt>.</td></tr>
<tr><td><tt>a.insert(p, t)</tt></td><td>The <tt>value_type</tt> must be <tt>CopyConstructible</tt>.
                                        The sequences <tt>vector</tt> and <tt>deque</tt> also require the <tt>value_type</tt> to be <tt>CopyAssignable</tt>.</td></tr>
<tr><td><tt>a.insert(p, rv)</tt></td><td>The <tt>value_type</tt> must be <tt>MoveConstructible</tt>.
                                        The sequences <tt>vector</tt> and <tt>deque</tt> also require the <tt>value_type</tt> to be <tt>MoveAssignable</tt>.</td></tr>
<tr><td><tt>a.insert(p, n, t)</tt></td><td>The <tt>value_type</tt> must be <tt>CopyConstructible</tt>.
                                        The sequences <tt>vector</tt> and <tt>deque</tt> also require the <tt>value_type</tt> to be <tt>CopyAssignable</tt>.</td></tr>
<tr><td><tt>a.insert(p, i, j)</tt></td><td>If the iterators return an lvalue the <tt>value_type</tt> must be <tt>CopyConstructible</tt>.
                                        The sequences <tt>vector</tt> and <tt>deque</tt> also require the <tt>value_type</tt> to be <tt>CopyAssignable</tt> when the iterators return an lvalue.
                                        If the iterators return an rvalue the <tt>value_type</tt> must be <tt>MoveConstructible</tt>.
                                        The sequences <tt>vector</tt> and <tt>deque</tt> also require the <tt>value_type</tt> to be <tt>MoveAssignable</tt> when the iterators return an rvalue.</td></tr>
<tr><td><tt>a.erase(p)</tt></td><td>The sequences <tt>vector</tt> and <tt>deque</tt> require the <tt>value_type</tt> to be <tt>MoveAssignable</tt>.</td></tr>
<tr><td><tt>a.erase(q1, q2)</tt></td><td>The sequences <tt>vector</tt> and <tt>deque</tt> require the <tt>value_type</tt> to be <tt>MoveAssignable</tt>.</td></tr>
<tr><td><tt>a.clear()</tt></td><td></td></tr>
<tr><td><tt>a.assign(i, j)</tt></td><td>If the iterators return an lvalue the <tt>value_type</tt> must be <tt>CopyConstructible</tt> and <tt>CopyAssignable</tt>.
                                        If the iterators return an rvalue the <tt>value_type</tt> must be <tt>MoveConstructible</tt> and <tt>MoveAssignable</tt>.</td></tr>
<tr><td><tt>a.assign(n, t)</tt></td><td>The <tt>value_type</tt> must be <tt>CopyConstructible</tt> and <tt>CopyAssignable</tt>.</td></tr>
<tr><td><tt>a.resize(n)</tt></td><td>The <tt>value_type</tt> must be <tt>DefaultConstructible</tt>.
                                     The sequence <tt>vector</tt> also requires the <tt>value_type</tt> to be <tt>MoveConstructible</tt>.</td></tr>
<tr><td><tt>a.resize(n, t)</tt></td><td>The <tt>value_type</tt> must be <tt>CopyConstructible</tt>.</td></tr>
</tbody></table>

<p>
</p>

<table border="1">
<caption>Optional Sequence Requirements</caption>
<tbody><tr><td><tt>a.front()</tt></td><td></td></tr>
<tr><td><tt>a.back()</tt></td><td></td></tr>
<tr><td><tt>a.push_front(t)</tt></td><td>The <tt>value_type</tt> must be <tt>CopyConstructible</tt>.</td></tr>
<tr><td><tt>a.push_front(rv)</tt></td><td>The <tt>value_type</tt> must be <tt>MoveConstructible</tt>.</td></tr>
<tr><td><tt>a.push_back(t)</tt></td><td>The <tt>value_type</tt> must be <tt>CopyConstructible</tt>.</td></tr>
<tr><td><tt>a.push_back(rv)</tt></td><td>The <tt>value_type</tt> must be <tt>MoveConstructible</tt>.</td></tr>
<tr><td><tt>a.pop_front()</tt></td><td></td></tr>
<tr><td><tt>a.pop_back()</tt></td><td></td></tr>
<tr><td><tt>a[n]</tt></td><td></td></tr>
<tr><td><tt>a.at[n]</tt></td><td></td></tr>
</tbody></table>

<p>
</p>

<table border="1">
<caption>Associative Container Requirements</caption>
<tbody><tr><td><tt>X(i, j)</tt></td><td>If the iterators return an lvalue the <tt>value_type</tt> must be <tt>CopyConstructible</tt>.
                                 If the iterators return an rvalue the <tt>value_type</tt> must be <tt>MoveConstructible</tt>.</td></tr>
<tr><td><tt>a_uniq.insert(t)</tt></td><td>The <tt>value_type</tt> must be <tt>CopyConstructible</tt>.</td></tr>
<tr><td><tt>a_uniq.insert(rv)</tt></td><td>The <tt>key_type</tt> and the <tt>mapped_type</tt> (if it exists) must be <tt>MoveConstructible</tt>.</td></tr>
<tr><td><tt>a_eq.insert(t)</tt></td><td>The <tt>value_type</tt> must be <tt>CopyConstructible</tt>.</td></tr>
<tr><td><tt>a_eq.insert(rv)</tt></td><td>The <tt>key_type</tt> and the <tt>mapped_type</tt> (if it exists) must be <tt>MoveConstructible</tt>.</td></tr>
<tr><td><tt>a.insert(p, t)</tt></td><td>The <tt>value_type</tt> must be <tt>CopyConstructible</tt>.</td></tr>
<tr><td><tt>a.insert(p, rv)</tt></td><td>The <tt>key_type</tt> and the <tt>mapped_type</tt> (if it exists) must be <tt>MoveConstructible</tt>.</td></tr>
<tr><td><tt>a.insert(i, j)</tt></td><td>If the iterators return an lvalue the <tt>value_type</tt> must be <tt>CopyConstructible</tt>.
                                        If the iterators return an rvalue the <tt>key_type</tt> and the <tt>mapped_type</tt> (if it exists) must be <tt>MoveConstructible</tt>..</td></tr>
</tbody></table>

<p>
</p>

<table border="1">
<caption>Unordered Associative Container Requirements</caption>
<tbody><tr><td><tt>X(i, j, n, hf, eq)</tt></td><td>If the iterators return an lvalue the <tt>value_type</tt> must be <tt>CopyConstructible</tt>.
                                 If the iterators return an rvalue the <tt>value_type</tt> must be <tt>MoveConstructible</tt>.</td></tr>
<tr><td><tt>a_uniq.insert(t)</tt></td><td>The <tt>value_type</tt> must be <tt>CopyConstructible</tt>.</td></tr>
<tr><td><tt>a_uniq.insert(rv)</tt></td><td>The <tt>key_type</tt> and the <tt>mapped_type</tt> (if it exists) must be <tt>MoveConstructible</tt>.</td></tr>
<tr><td><tt>a_eq.insert(t)</tt></td><td>The <tt>value_type</tt> must be <tt>CopyConstructible</tt>.</td></tr>
<tr><td><tt>a_eq.insert(rv)</tt></td><td>The <tt>key_type</tt> and the <tt>mapped_type</tt> (if it exists) must be <tt>MoveConstructible</tt>.</td></tr>
<tr><td><tt>a.insert(p, t)</tt></td><td>The <tt>value_type</tt> must be <tt>CopyConstructible</tt>.</td></tr>
<tr><td><tt>a.insert(p, rv)</tt></td><td>The <tt>key_type</tt> and the <tt>mapped_type</tt> (if it exists) must be <tt>MoveConstructible</tt>.</td></tr>
<tr><td><tt>a.insert(i, j)</tt></td><td>If the iterators return an lvalue the <tt>value_type</tt> must be <tt>CopyConstructible</tt>.
                                        If the iterators return an rvalue the <tt>key_type</tt> and the <tt>mapped_type</tt> (if it exists) must be <tt>MoveConstructible</tt>..</td></tr>
</tbody></table>

<p>
</p>

<table border="1">
<caption>Miscellaneous Requirements</caption>
<tbody><tr><td><tt>map[lvalue-key]</tt></td><td>The <tt>key_type</tt> must be <tt>CopyConstructible</tt>.
                                         The <tt>mapped_type</tt> must be <tt>DefaultConstructible</tt> and <tt>MoveConstructible</tt>.</td></tr>
<tr><td><tt>map[rvalue-key]</tt></td><td>The <tt>key_type</tt> must be <tt>MoveConstructible</tt>.
                                         The <tt>mapped_type</tt> must be <tt>DefaultConstructible</tt> and <tt>MoveConstructible</tt>.</td></tr>
</tbody></table>

<p><i>[
Kona (2007): Howard and Alan to update requirements table in issue with emplace signatures.
]</i></p>


<p><i>[
Bellevue: This should be handled as part of the concepts work.
]</i></p>


<p><i>[
2009-07-20 Reopened by Howard:
]</i></p>


<blockquote>
<p>
This is one of the issues that was "solved by concepts" and is now no longer solved.
</p>

<p>
In a nutshell, concepts adopted the "minimum requirements" philosophy outlined
in the discussion of this issue, and enforced it.  My strong suggestion is that
we translate the concepts specification into documentation for the containers.
</p>

<p>
What this means for vendors is that they will have to implement container members
being careful to only use those characteristics of a type that the concepts specification
formally allowed.  Note that I <em>am not</em> talking about <tt>enable_if</tt>'ing
everything.  I am simply suggesting that (for example) we tell the vendor he can't call <tt>T's</tt>
copy constructor or move constructor within the <tt>emplace</tt> member function, etc.
</p>

<p>
What this means for customers is that they will be able to use types within C++03
containers which are sometimes not CopyConstructible, and sometimes not even
MoveConstructible, etc.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Leave open. Howard to provide wording.
</blockquote>

<p><i>[
2010-02-06 Howard provides wording.
]</i></p>


<p><i>[
2010-02-08 Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>


<p><i>[
2010-02-10 Howard opened.  I neglected to reduce the requirements on value_type
for the insert function of the ordered and unordered associative containers when
the argument is an rvalue.  Fixed it.
]</i></p>


<p><i>[
2010-02-11 Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>


<p><i>[
2010-03-08 Nico opens:
]</i></p>


<blockquote>
<p>
I took the task to see whether <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#868">868</a> is covered by 704
already.
However, by doing that I have the impression that
704 is a big mistake.
</p>

<p>
Take e.g. the second change of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#868">868</a>:
</p>

<blockquote>
<p>
Change 23.3.2.1 [deque.cons] para 5:
</p>
<blockquote>
<i>Effects:</i> Constructs a <tt>deque</tt> with <tt>n</tt> default constructed
elements.
</blockquote>
<p>
where "default constructed" should be replaced by "value-initialized".
This is the constructor out of a number of elements:
</p>
<blockquote><pre>ContType c(num)
</pre></blockquote>

<p>
704 says:
</p>

<blockquote>
<p>
Remove the entire section 23.3.2.1 [deque.cons].
</p>
<blockquote>
[ This section is already specified by the requirements tables. ]
</blockquote>
</blockquote>

<p>
BUT, there is no requirement table that lists this constructor at all,
which means that we would lose the entire specification of this function
!!!
</p>

<p>
In fact, I found with further investigation, if we follow
704 to remove 23.3.2.1 we
</p>
<ul>
<li>
have no semantics for
  <tt>ContType c(num)</tt>
</li>
<li>
have no complexity and no allocator specification for
  <tt>ContType c(num,val)</tt>
</li>
<li>
have no semantics for
  <tt>ContType c(num,val,alloc)</tt>
</li>
<li>
- have no complexity and no allocator specification for
  <tt>ContType c(beg,end)</tt>
</li>
<li>
- have no semantics for
  <tt>ContType c(beg,end,alloc)</tt>
</li>
<li>
- have different wording (which might or might not give
 the same guarantees) for the <tt>assign</tt> functions
</li>
</ul>

<p>
because all these guarantees are given in the removed
section but nowhere else (as far as I saw).
</p>
<p>
Looks to me that 704 need a significant review before we
take that change, because chances are high that there
are similar flaws in other proposed changes there
(provided I am not missing anything).
</p>
</blockquote>
</blockquote>

<p><i>[
2010 Pittsburgh:
]</i></p>


<blockquote>
<p>
Removed the parts from the proposed wording that removed existing sections,
and set to Ready for Pittsburgh.
</p>
</blockquote>



<p><b>Rationale:</b></p>
<p><i>[
post San Francisco:
]</i></p>


<blockquote>
Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2776.pdf">N2776</a>.
</blockquote>

<p>
This rationale is obsolete. 
</p>



<p><b>Proposed resolution:</b></p>


 
<p>
Change 23.2.1 [container.requirements.general]/4:
</p>

<blockquote>
4 In Tables 91 and 92, <tt>X</tt> denotes a container class containing objects
of type <tt>T</tt>, <tt>a</tt> and <tt>b</tt> denote values of type <tt>X</tt>,
<tt>u</tt> denotes an identifier, <tt>r</tt> denotes <del>an lvalue or a const
rvalue</del> <ins>a non-const value</ins> of type <tt>X</tt>, and <tt>rv</tt>
denotes a non-const rvalue of type <tt>X</tt>.
</blockquote>

<p>
Change the following rows in Table 91  Container requirements
23.2.1 [container.requirements.general]:
</p>

<blockquote>
<table border="1">
<caption>Table 91  Container requirements</caption>

<tbody><tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion/note<br>pre-/post-condition</th>
<th>Complexity</th>
</tr>

<tr>
<td><tt>X::value_type</tt></td>
<td><tt>T</tt></td>
<td><ins><i>Requires:</i> <tt>T</tt> is <tt>Destructible</tt>.</ins></td>
<td>compile time</td>
</tr>

</tbody></table>

</blockquote>

<p>
Change 23.2.1 [container.requirements.general]/10:
</p>

<blockquote>
<p>
Unless otherwise specified (see 23.2.4.1, 23.2.5.1, 23.3.2.3, and 23.3.6.4) all
container types defined in this Clause meet the following additional
requirements:
</p>

<ul>
<li>
..
</li>

<li>
no <tt>erase()</tt>, <ins><tt>clear()</tt>,</ins> <tt>pop_back()</tt> or
<tt>pop_front()</tt> function throws an exception.
</li>

<li>
...
</li>
</ul>

</blockquote>

<p>
Insert a new paragraph prior to 23.2.1 [container.requirements.general]/14:
</p>

<blockquote>
<p><ins>
The descriptions of the requirements of the type <tt>T</tt> in this section
use the terms <tt>CopyConstructible</tt>, <tt>MoveConstructible</tt>, <i>constructible
from <tt>*i</tt></i>, and <i>constructible from <tt>args</tt></i>.  These terms
are equivalent to the following expression using the appropriate arguments:
</ins></p>

<blockquote><pre><ins>
allocator_traits&lt;allocator_type&gt;::construct(x.get_allocator(), q, args...);
</ins></pre></blockquote>

<p><ins>
where <tt>x</tt> is a non-const lvalue of some container type <tt>X</tt> and
<tt>q</tt> has type <tt>X::value_type*</tt>.
</ins></p>

<p><ins>
[<i>Example:</i> The container is going to move construct a <tt>T</tt>, so will
call:
</ins></p>

<blockquote><pre><ins>
allocator_traits&lt;allocator_type&gt;::construct(get_allocator(), q, std::move(t));
</ins></pre></blockquote>

<p><ins>
The default implementation of construct will call:
</ins></p>

<blockquote><pre><ins>
::new (q) T(std::forward&lt;T&gt;(t)); // where forward is the same as move here, cast to rvalue
</ins></pre></blockquote>

<p><ins>
But the allocator author may override the above definition of <tt>construct</tt>
and do the construction of <tt>T</tt> by some other means.  <i>end
example</i>]
</ins></p>

<p>
14 ...
</p>
</blockquote>

<p>
Add to 23.2.1 [container.requirements.general]/14:
</p>

<blockquote>
14 In Table 93, <tt>X</tt> denotes an allocator-aware container class with a
<tt>value_type</tt> of <tt>T</tt> using allocator of type <tt>A</tt>, <tt>u</tt>
denotes a variable, <ins><tt>a</tt> and <tt>b</tt> denote non-const lvalues of
type <tt>X</tt>,</ins> <tt>t</tt> denotes an lvalue or a const rvalue of type
<tt>X</tt>, <tt>rv</tt> denotes a non-const rvalue of type <tt>X</tt>,
<tt>m</tt> is a value of type <tt>A</tt>, and <tt>Q</tt> is an allocator type.
</blockquote>

<p>
Change or add the following rows in Table 93  Allocator-aware container
requirements in 23.2.1 [container.requirements.general]:
</p>

<blockquote>
<table border="1">
<caption>Table 93  Allocator-aware container requirements</caption>

<tbody><tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion/note<br>pre-/post-condition</th>
<th>Complexity</th>
</tr>

<tr>
<td><tt>X(t, m)<br>X u(t, m);</tt></td>
<td></td>
<td><ins><i>Requires:</i> <tt>T</tt> is <tt>CopyConstructible</tt>.</ins><br>
post: <tt>u == t</tt>,<br>
<tt>get_allocator() == m</tt></td>
<td>linear</td>
</tr>

<tr>
<td><tt>X(rv, m)<br>X u(rv, m);</tt></td>
<td></td>
<td><ins><i>Requires:</i> <tt>T</tt> is <tt>MoveConstructible</tt>.</ins><br>
post: <tt>u</tt> shall have the same elements, or copies of the elements, that
<tt>rv</tt> had before this construction,<br>
<tt>get_allocator() == m</tt></td>
<td>constant if <tt>m == rv.get_allocator()</tt>, otherwise linear</td>
</tr>

<tr>
<td><ins><tt>a = t</tt></ins></td>
<td><ins><tt>X&amp;</tt></ins></td>
<td><ins><i>Requires:</i> <tt>T</tt> is <tt>CopyConstructible</tt> and
<tt>CopyAssignable</tt><br>
post: <tt>a == t</tt>.</ins></td>
<td><ins>linear</ins></td>
</tr>

<tr>
<td><ins><tt>a = rv</tt></ins></td>
<td><ins><tt>X&amp;</tt></ins></td>
<td><ins><i>Requires:</i> If <tt>allocator_traits&lt; allocator_type &gt;
::propagate_on_container_move_assignment ::value</tt> is <tt>false</tt>,
<tt>T</tt> is <tt>MoveConstructible</tt> and <tt>MoveAssignable</tt>.<br>
All existing elements of <tt>a</tt> are either move assigned
<ins>to</ins> or destroyed.<br>
<tt>a</tt> shall be equal to the value that <tt>rv</tt> had before this
assignment</ins></td>
<td><ins>linear</ins></td>
</tr>

<tr>
<td><ins><tt>a.swap(b);</tt></ins></td>
<td><ins><tt>void</tt></ins></td>
<td><ins>exchanges the contents of <tt>a</tt> and <tt>b</tt></ins></td>
<td><ins>constant</ins></td>
</tr>

</tbody></table>

</blockquote>

<p>
Change the following rows in Table 94  Sequence container requirements
(in addition to container) in 23.2.3 [sequence.reqmts]:
</p>

<blockquote>
<table border="1">
<caption>Table 94  Sequence container requirements (in addition to
container)</caption>

<tbody><tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion/note<br>pre-/post-condition</th>
</tr>

<tr>
<td><tt>X(i, j)<br>X a(i, j)</tt></td>
<td></td>
<td><i>Requires:</i> <del>If the iterator's dereference operation returns an
lvalue or a const rvalue, <tt>T</tt> shall be <tt>CopyConstructible</tt>.</del>
<ins><tt>T</tt> shall be constructible from <tt>*i</tt>.</ins><br>
<ins>If the iterator does not meet the forward iterator requirements (24.2.5 [forward.iterators]), then <tt>vector</tt> also requires <tt>T</tt> to
be <tt>MoveConstructible</tt>.</ins><br>
Each iterator in the range <tt>[i,j)</tt> shall be dereferenced exactly
once.<br>
post: <tt>size() ==</tt> distance between <tt>i</tt> and <tt>j</tt><br>
Constructs a sequence container equal to the range <tt>[i, j)</tt></td>
</tr>

<tr>
<td><tt>a = il;</tt></td>
<td><tt>X&amp;</tt></td>
<td><ins><i>Requires:</i> <tt>T</tt> is <tt>CopyConstructible</tt> and
<tt>CopyAssignable</tt>.</ins><br>
<del><tt>a = X(il);</tt></del><br>
<ins>Assigns the range <tt>[il.begin(), il.end())</tt> into <tt>a</tt>.  All
existing elements of <tt>a</tt> are either assigned or destroyed.</ins><br>
<del>r</del><ins>R</ins>eturn<ins>s</ins> <tt>*this;</tt></td>
</tr>

<tr>
<td><tt>a.emplace(p, args);</tt></td>
<td><tt>iterator</tt></td>
<td><i>Requires:</i> <del><tt>ConstructibleAsElement&lt;A, T,
Args&gt;</tt>.</del> <ins><tt>T</tt> is constructible from <tt>args</tt>. 
<tt>vector</tt> and <tt>deque</tt> also require <tt>T</tt> to be
<tt>MoveConstructible</tt> and <tt>MoveAssignable</tt>.</ins> Inserts an object
of type <tt>T</tt> constructed with
<tt>std::forward&lt;Args&gt;(args)...</tt> <ins>before <tt>p</tt></ins>.</td>
</tr>

<tr>
<td><tt>a.insert(p, t);</tt></td>
<td><tt>iterator</tt></td>
<td><i>Requires:</i> <del><tt>ConstructibleAsElement&lt;A, T, Args&gt;</tt> and
<tt>T</tt> shall be <tt>CopyAssignable</tt>.</del> <ins><tt>T</tt> shall be
<tt>CopyConstructible</tt>. <tt>vector</tt> and <tt>deque</tt> also require
<tt>T</tt> to be <tt>CopyAssignable</tt>.</ins> Inserts a copy <tt>t</tt> before
<tt>p</tt>.</td>
</tr>

<tr>
<td><tt>a.insert(p, rv);</tt></td>
<td><tt>iterator</tt></td>
<td><i>Requires:</i> <del><tt>ConstructibleAsElement&lt;A, T,
T&amp;&amp;&gt;</tt> and <tt>T</tt> shall be <tt>MoveAssignable</tt>.</del>
<ins><tt>T</tt> shall be <tt>MoveConstructible</tt>. <tt>vector</tt> and
<tt>deque</tt> also require <tt>T</tt> to be <tt>MoveAssignable</tt>.</ins>
Inserts a copy <tt>rv</tt> before <tt>p</tt>.</td>
</tr>

<tr>
<td><tt>a.insert(p, i, j)</tt></td>
<td><tt>iterator</tt></td>
<td><i>Requires:</i> <del>If the iterator's dereference operation returns an
lvalue or a const rvalue, <tt>T</tt> shall be <tt>CopyConstructible</tt>.</del>
<ins><tt>T</tt> shall be constructible from <tt>*i</tt>.</ins><br> <ins>If the
iterator does not meet the forward iterator requirements (24.2.5 [forward.iterators]), then <tt>vector</tt> also requires <tt>T</tt> to
be <tt>MoveConstructible</tt> and  <tt>MoveAssignable</tt>.</ins><br> Each
iterator in the range <tt>[i,j)</tt> shall be dereferenced exactly once.<br>
pre: <tt>i</tt> and <tt>j</tt> are not iterators into <tt>a</tt>.<br> Inserts
copies of elements in <tt>[i, j)</tt> before <tt>p</tt></td>
</tr>

<tr>
<td><tt>a.erase(q);</tt></td>
<td><tt>iterator</tt></td>
<td><i>Requires:</i> <del><tt>T</tt> and <tt>T</tt> shall be
<tt>MoveAssignable</tt>.</del> <ins><tt>vector</tt> and <tt>deque</tt> require
<tt>T</tt> to be <tt>MoveAssignable</tt>.</ins> Erases the element pointed to by
<tt>q</tt>.</td>
</tr>

<tr>
<td><tt>a.erase(q1, q2);</tt></td>
<td><tt>iterator</tt></td>
<td><i>Requires:</i> <del><tt>T</tt> and <tt>T</tt> shall be
<tt>MoveAssignable</tt>.</del> <ins><tt>vector</tt> and <tt>deque</tt> require
<tt>T</tt> to be <tt>MoveAssignable</tt>.</ins> Erases the elements in the range
<tt>[q1, q2)</tt>.</td>
</tr>

<tr>
<td><tt>a.clear();</tt></td>
<td><tt>void</tt></td>
<td><del><tt>erase(begin(), end())</tt></del><br>
<ins>Destroys all elements in <tt>a</tt>. <ins>Invalidates all references,
pointers, and iterators referring to the elements of <tt>a</tt> and may
invalidate the past-the-end iterator.</ins><br></ins>
post: <tt><del>size() == 0</del> <ins>a.empty() == true</ins></tt></td>
</tr>

<tr>
<td><tt>a.assign(i, j)</tt></td>
<td><tt>void</tt></td>
<td><i>Requires:</i> <del>If the iterator's dereference operation returns an
lvalue or a const rvalue, <tt>T</tt> shall be <tt>CopyConstructible</tt> and
<tt>CopyAssignable</tt>.</del>
<ins><tt>T</tt> shall be constructible and assignable from <tt>*i</tt>.  If the
iterator does not meet the forward iterator requirements (24.2.5 [forward.iterators]), then <tt>vector</tt> also requires <tt>T</tt> to
be <tt>MoveConstructible</tt>.</ins><br>
Each iterator in the range <tt>[i,j)</tt> shall be dereferenced exactly
once.<br>
pre: <tt>i</tt>, <tt>j</tt> are not iterators into <tt>a</tt>.<br>
Replaces elements in <tt>a</tt> with a copy of <tt>[i, j)</tt>.</td>
</tr>

</tbody></table>

</blockquote>

<p>
Change the following rows in Table 95  Optional sequence container operations
in 23.2.3 [sequence.reqmts]:
</p>

<blockquote>
<table border="1">
<caption>Table 95  Optional sequence container operations</caption>

<tbody><tr>
<th>Expression</th>
<th>Return type</th>
<th>Operational semantics</th>
<th>Container</th>
</tr>

<tr>
<td><tt>a.emplace_front(args)</tt></td>
<td><tt>void</tt></td>
<td><del><tt>a.emplace(a.begin(), std::forward&lt;Args&gt;(args)...)</tt></del><br>
<ins>Prepends an object of type <tt>T</tt> constructed with
<tt>std::forward&lt;Args&gt;(args)...</tt>.</ins><br>
<i>Requires:</i> <del><tt>ConstructibleAsElement&lt;A, T, Args&gt;</tt></del>
<ins><tt>T</tt> shall be constructible from <tt>args</tt>.</ins></td>
<td><tt>list</tt>, <tt>deque</tt>, <tt>forward_list</tt></td>
</tr>

<tr>
<td><tt>a.emplace_back(args)</tt></td>
<td><tt>void</tt></td>
<td><del><tt>a.emplace(a.end(), std::forward&lt;Args&gt;(args)...)</tt></del><br>
<ins>Appends an object of type <tt>T</tt> constructed with
<tt>std::forward&lt;Args&gt;(args)...</tt>.</ins><br>
<i>Requires:</i> <del><tt>ConstructibleAsElement&lt;A, T, Args&gt;</tt></del>
<ins><tt>T</tt> shall be constructible from <tt>args</tt>. <tt>vector</tt> also
requires <tt>T</tt> to be <tt>MoveConstructible</tt>.</ins></td>
<td><tt>list</tt>, <tt>deque</tt>, <tt>vector</tt></td>
</tr>

<tr>
<td><tt>a.push_front(t)</tt></td>
<td><tt>void</tt></td>
<td><del><tt>a.insert(a.begin(), t)</tt></del><br>
<ins>Prepends a copy of <tt>t</tt>.</ins><br>
<i>Requires:</i> <del><tt>ConstructibleAsElement&lt;A, T, T&gt;</tt> and
<tt>T</tt> shall be <tt>CopyAssignable</tt>.</del>
<ins><tt>T</tt> shall be <tt>CopyConstructible</tt>.</ins></td>
<td><tt>list</tt>, <tt>deque</tt>, <tt>forward_list</tt></td>
</tr>

<tr>
<td><tt>a.push_front(rv)</tt></td>
<td><tt>void</tt></td>
<td><del><tt>a.insert(a.begin(), t)</tt></del><br>
<ins>Prepends a copy of <tt>rv</tt>.</ins><br>
<i>Requires:</i> <del><tt>ConstructibleAsElement&lt;A, T, T&amp;&amp;&gt;</tt> and
<tt>T</tt> shall be <tt>MoveAssignable</tt>.</del>
<ins><tt>T</tt> shall be <tt>MoveConstructible</tt>.</ins></td>
<td><tt>list</tt>, <tt>deque</tt>, <tt>forward_list</tt></td>
</tr>

<tr>
<td><tt>a.push_back(t)</tt></td>
<td><tt>void</tt></td>
<td><del><tt>a.insert(a.end(), t)</tt></del><br>
<ins>Appends a copy of <tt>t</tt>.</ins><br>
<i>Requires:</i> <del><tt>ConstructibleAsElement&lt;A, T, T&gt;</tt> and
<tt>T</tt> shall be <tt>CopyAssignable</tt>.</del>
<ins><tt>T</tt> shall be <tt>CopyConstructible</tt>.</ins></td>
<td><tt>vector</tt>, <tt>list</tt>, <tt>deque</tt>, <tt>basic_string</tt></td>
</tr>

<tr>
<td><tt>a.push_back(rv)</tt></td>
<td><tt>void</tt></td>
<td><del><tt>a.insert(a.end(), t)</tt></del><br>
<ins>Appends a copy of <tt>rv</tt>.</ins><br>
<i>Requires:</i> <del><tt>ConstructibleAsElement&lt;A, T, T&amp;&amp;&gt;</tt> and
<tt>T</tt> shall be <tt>MoveAssignable</tt>.</del>
<ins><tt>T</tt> shall be <tt>MoveConstructible</tt>.</ins></td>
<td><tt>vector</tt>, <tt>list</tt>, <tt>deque</tt>, <tt>basic_string</tt></td>
</tr>

<tr>
<td><tt>a.pop_front()</tt></td>
<td><tt>void</tt></td>
<td><del><tt>a.erase(a.begin())</tt></del><br>
<ins>Destroys the first element.</ins><br>
<ins><i>Requires:</i> <tt>a.empty()</tt> shall be <tt>false</tt>.</ins></td>
<td><tt>list</tt>, <tt>deque</tt>, <tt>forward_list</tt></td>
</tr>

<tr>
<td><tt>a.pop_back()</tt></td>
<td><tt>void</tt></td>
<td><del><tt>{ iterator tmp = a.end();<br>--tmp;<br>a.erase(tmp); }</tt></del><br>
<ins>Destroys the last element.</ins><br>
<ins><i>Requires:</i> <tt>a.empty()</tt> shall be <tt>false</tt>.</ins></td>
<td><tt>vector</tt>, <tt>list</tt>, <tt>deque</tt>, <tt>basic_string</tt></td>
</tr>

</tbody></table>

</blockquote>

<p>
Insert a new paragraph prior to 23.2.4 [associative.reqmts]/7, and
edit paragraph 7:
</p>

<blockquote>
<p><ins>
The associative containers meet all of the requirements of Allocator-aware
containers (23.2.1 [container.requirements.general]), except for the
containers <tt>map</tt> and <tt>multimap</tt>, the requirements placed on
<tt>value_type</tt> in Table 93 apply instead directly to <tt>key_type</tt> and
<tt>mapped_type</tt>. [<i>Note:</i> For example <tt>key_type</tt> and
<tt>mapped_type</tt> are sometimes required to be <tt>CopyAssignable</tt> even
though the <tt>value_type</tt> (<tt>pair&lt;const key_type,
mapped_type&gt;</tt>) is not <tt>CopyAssignable</tt>.  <i>end note</i>]
</ins></p>

<p>
7 In Table 96, <tt>X</tt> denotes an associative container class, a denotes a
value of <tt>X</tt>, <tt>a_uniq</tt> denotes a value of <tt>X</tt> when
<tt>X</tt> supports unique keys, <tt>a_eq</tt> denotes a value of <tt>X</tt>
when <tt>X</tt> supports multiple keys, <tt>u</tt> denotes an identifier,
<del><tt>r</tt> denotes an lvalue or a const rvalue of type <tt>X</tt>,
<tt>rv</tt> denotes a non-const rvalue of type <tt>X</tt>,</del> <tt>i</tt> and
<tt>j</tt> satisfy input iterator requirements and refer to elements implicitly
convertible to <tt>value_type</tt>, <tt>[i,j)</tt> denotes a valid range,
<tt>p</tt> denotes a valid const iterator to <tt>a</tt>, <tt>q</tt> denotes a
valid dereferenceable const iterator to <tt>a</tt>, <tt>[q1, q2)</tt> denotes a
valid range of const iterators in <tt>a</tt>, <tt>il</tt> designates an object
of type <tt>initializer_list&lt;value_type&gt;</tt>, <tt>t</tt> denotes a value
of <tt>X::value_type</tt>, <tt>k</tt> denotes a value of <tt>X::key_type</tt>
and <tt>c</tt> denotes a value of type <tt>X::key_compare</tt>. <tt>A</tt>
denotes the storage allocator used by <tt>X</tt>, if any, or
<tt>std::allocator&lt;X::value_type&gt;</tt> otherwise, and <tt>m</tt> denotes
an allocator of a type convertible to <tt>A</tt>. </p>
</blockquote>

<p>
Change or add the following rows in Table 96  Associative container
requirements (in addition to container) in 23.2.4 [associative.reqmts]:
</p>

<blockquote>
<table border="1">
<caption>Table 96  Associative container requirements (in addition to
container)</caption>

<tbody><tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion/note<br>pre-/post-condition</th>
<th>Complexity</th>
</tr>

<tr>
<td><tt>X::key_type</tt></td>
<td><tt>Key</tt></td>
<td><ins><i>Requires:</i></ins> <tt>Key</tt> is <del><tt>CopyConstructible</tt> and
<tt>CopyAssignable</tt></del> <ins><tt>Destructible</tt></ins></td>
<td>compile time</td>
</tr>

<tr>
<td><ins><tt>X::mapped_type</tt> (<tt>map</tt> and <tt>multimap</tt> only)</ins></td>
<td><ins><tt>T</tt></ins></td>
<td><ins><i>Requires:</i> <tt>T</tt> is <tt>Destructible</tt></ins></td>
<td><ins>compile time</ins></td>
</tr>

<tr>
<td><tt>X(c)<br>X a(c);</tt></td>
<td></td>
<td><i>Requires:</i> <del><tt>ConstructibleAsElement&lt;A, key_compare,
key_compare&gt;</tt></del>.<br>
<ins><tt>key_compare</tt> is <tt>CopyConstructible</tt>.</ins><br>
Constructs an empty container.<br>
Uses a copy of <tt>c</tt> as a comparison object.</td>
<td>constant</td>
</tr>

<tr>
<td><tt>X()<br>X a;</tt></td>
<td></td>
<td><i>Requires:</i> <del><tt>ConstructibleAsElement&lt;A, key_compare,
key_compare&gt;</tt></del>.<br>
<ins><tt>key_compare</tt> is <tt>DefaultConstructible</tt>.</ins><br>
Constructs an empty container.<br>
Uses <tt>Compare()</tt> as a comparison object.</td>
<td>constant</td>
</tr>

<tr>
<td><tt>X(i, j, c)<br>X a(i, j, c);</tt></td>
<td></td>
<td><i>Requires:</i> <del><tt>ConstructibleAsElement&lt;A, key_compare,
key_compare&gt;</tt></del>.<br>
<ins><tt>key_compare</tt> is <tt>CopyConstructible</tt>. <tt>value_type</tt>
shall be constructible from <tt>*i</tt>.</ins><br>
Constructs an empty container ans inserts elements from the range <tt>[i,
j)</tt> into it; uses <tt>c</tt> as a comparison object.</td>
<td><tt>N</tt> log <tt>N</tt> in general (<tt>N</tt> is the distance from
<tt>i</tt> to <tt>j</tt>); linear if <tt>[i, j)</tt> is sorted with
<tt>value_comp()</tt></td>
</tr>

<tr>
<td><tt>X(i, j)<br>X a(i, j);</tt></td>
<td></td>
<td><i>Requires:</i> <del><tt>ConstructibleAsElement&lt;A, key_compare,
key_compare&gt;</tt></del>.<br> <ins><tt>value_type</tt> shall be constructible
from <tt>*i</tt>. <tt>key_compare</tt> is
<tt>DefaultConstructible</tt>.</ins><br> Same as above, but uses
<tt>Compare()</tt> as a comparison object.</td>
<td>same as above</td>
</tr>

<tr>
<td><tt>a = il</tt></td>
<td><tt>X&amp;</tt></td>
<td><del><tt>a = X(il);<br>
return *this;</tt></del><br>
<ins><i>Requires:</i> <tt>T</tt> is <tt>CopyConstructible</tt> and
<tt>CopyAssignable</tt>.</ins><br>
<ins>Assigns the range <tt>[il.begin(), il.end())</tt> into <tt>a</tt>.  All
existing elements of <tt>a</tt> are either assigned or destroyed.</ins></td>
<td><del>Same as <tt><tt>a = X(il)</tt></tt>.</del>
<ins><tt>N</tt> log <tt>N</tt> in general (<tt>N</tt> is 
<tt>il.size()</tt> added to the existing size of <tt>a</tt>); linear if
<tt>[il.begin(), il.end())</tt> is sorted with <tt>value_comp()</tt></ins></td>
</tr>

<tr>
<td><tt>a_uniq.emplace(args)</tt></td>
<td><tt>pair&lt;iterator, bool&gt;</tt></td>
<td><ins><i>Requires:</i> <tt>T</tt> shall be constructible from
<tt>args</tt></ins><br>
inserts a <tt>T</tt> object <tt>t</tt> constructed with
<tt>std::forward&lt;Args&gt;(args)...</tt> if and only if there is no element in
the container with key equivalent to the key of <tt>t</tt>. The <tt>bool</tt>
component of the returned pair is true if and only if the insertion takes place,
and the iterator component of the pair points to the element with key equivalent
to the key of <tt>t</tt>.</td>
<td>logarithmic</td>
</tr>

<tr>
<td><tt>a_eq.emplace(args)</tt></td>
<td><tt>iterator</tt></td>
<td><ins><i>Requires:</i> <tt>T</tt> shall be constructible from
<tt>args</tt></ins><br>
inserts a <tt>T</tt> object <tt>t</tt> constructed with
<tt>std::forward&lt;Args&gt;(args)...</tt> and returns the iterator pointing to
the newly inserted element.</td>
<td>logarithmic</td>
</tr>

<tr>
<td><tt>a_uniq.insert(t)</tt></td>
<td><tt>pair&lt;iterator, bool&gt;</tt></td>
<td><ins><i>Requires:</i> <tt>T</tt> shall be <tt>MoveConstructible</tt> if
<tt>t</tt> is a non-const rvalue expression, else <tt>T</tt> shall be
<tt>CopyConstructible</tt>.</ins><br>
inserts <tt>t</tt> if and only if there is no element in the container with key
equivalent to the key of <tt>t</tt>. The <tt>bool</tt> component of the returned
pair is true if and only if the insertion takes place, and the iterator
component of the pair points to the element with key equivalent to the key of
<tt>t</tt>.</td>
<td>logarithmic</td>
</tr>

<tr>
<td><tt>a_eq.insert(t)</tt></td>
<td><tt>iterator</tt></td>
<td><ins><i>Requires:</i> <tt>T</tt> shall be <tt>MoveConstructible</tt> if
<tt>t</tt> is a non-const rvalue expression, else <tt>T</tt> shall be
<tt>CopyConstructible</tt>.</ins><br>
inserts <tt>t</tt> and returns the iterator pointing to the newly inserted
element. If a range containing elements equivalent to <tt>t</tt> exists in
<tt>a_eq</tt>, <tt>t</tt> is inserted at the end of that range.</td>
<td>logarithmic</td>
</tr>

<tr>
<td><tt>a.insert(p, t)</tt></td>
<td><tt>iterator</tt></td>
<td><ins><i>Requires:</i> <tt>T</tt> shall be <tt>MoveConstructible</tt> if
<tt>t</tt> is a non-const rvalue expression, else <tt>T</tt> shall be
<tt>CopyConstructible</tt>.</ins><br>
inserts <tt>t</tt> if and only if there is no element with key equivalent to the
key of <tt>t</tt> in containers with unique keys; always inserts <tt>t</tt> in
containers with equivalent keys; always returns the iterator pointing to the
element with key equivalent to the key of <tt>t</tt>. <tt>t</tt> is inserted as
close as possible to the position just prior to <tt>p</tt>.</td>
<td>logarithmic in general, but amortized constant if <tt>t</tt> is inserted
right before <tt>p</tt>.</td>
</tr>

<tr>
<td><tt>a.insert(i, j)</tt></td>
<td><tt>void</tt></td>
<td><ins><i>Requires:</i> <tt>T</tt> shall be
constructible from <tt>*i</tt>.</ins><br>
pre: <tt>i</tt>, <tt>j</tt> are not iterators into <tt>a</tt>. inserts each
element from the range <tt>[i,j)</tt> if and only if there is no element with
key equivalent to the key of that element in containers with unique keys; always
inserts that element in containers with equivalent keys.</td>
<td>N log(size() + N ) (N is the distance from i to j)</td>
</tr>

</tbody></table>

</blockquote>

<p>
Insert a new paragraph prior to 23.2.5 [unord.req]/9:
</p>

<blockquote>
<p><ins>
The unordered associative containers meet all of the requirements of
Allocator-aware containers (23.2.1 [container.requirements.general]),
except for the containers <tt>unordered_map</tt> and <tt>unordered_multimap</tt>,
the requirements placed on <tt>value_type</tt> in Table 93 apply instead
directly to <tt>key_type</tt> and <tt>mapped_type</tt>. [<i>Note:</i> For
example <tt>key_type</tt> and <tt>mapped_type</tt> are sometimes required to be
<tt>CopyAssignable</tt> even though the <tt>value_type</tt> (<tt>pair&lt;const
key_type, mapped_type&gt;</tt>) is not <tt>CopyAssignable</tt>.  <i>end
note</i>]
</ins></p>

<p>
9 ...
</p>
</blockquote>

<p>
Change or add the following rows in Table 98  Unordered associative
container requirements (in addition to container) in 23.2.5 [unord.req]:
</p>

<blockquote>
<table border="1">
<caption>Table 98  Unordered associative
container requirements (in addition to container)</caption>

<tbody><tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion/note<br>pre-/post-condition</th>
<th>Complexity</th>
</tr>

<tr>
<td><tt>X::key_type</tt></td>
<td><tt>Key</tt></td>
<td><ins><i>Requires:</i></ins> <tt>Key</tt> shall be <del><tt>CopyAssignable</tt> and
<tt>CopyConstructible</tt></del> <ins><tt>Destructible</tt></ins></td>
<td>compile time</td>
</tr>

<tr>
<td><ins><tt>X::mapped_type</tt> (<tt>unordered_map</tt> and
<tt>unordered_multimap</tt> only)</ins></td>
<td><ins><tt>T</tt></ins></td>
<td><ins><i>Requires:</i><tt>T</tt> is <tt>Destructible</tt></ins></td>
<td><ins>compile time</ins></td>
</tr>

<tr>
<td><tt>X(n, hf, eq)<br>X a(n, hf, eq)</tt></td>
<td><tt>X</tt></td>
<td><ins><i>Requires:</i> <tt>hasher</tt>  and <tt>key_equal</tt> are
<tt>CopyConstructible</tt>.</ins> Constructs an empty container with at least
<tt>n</tt> buckets, using <tt>hf</tt> as the hash function and <tt>eq</tt> as
the key equality predicate. </td>
<td><tt>O(N)</tt></td>
</tr>

<tr>
<td><tt>X(n, hf)<br>X a(n, hf)</tt></td>
<td><tt>X</tt></td>
<td><ins><i>Requires:</i> <tt>hasher</tt> is <tt>CopyConstructible</tt> and 
<tt>key_equal</tt> is <tt>DefaultConstructible</tt>.</ins> Constructs an empty
container with at least <tt>n</tt> buckets, using <tt>hf</tt> as the hash
function and <tt>key_equal()</tt> as the key equality predicate.</td>
<td><tt>O(N)</tt></td>
</tr>

<tr>
<td><tt>X(n)<br>X a(n)</tt></td>
<td><tt>X</tt></td>
<td><ins><i>Requires:</i> <tt>hasher</tt>  and <tt>key_equal</tt> are
<tt>DefaultConstructible</tt>.</ins> Constructs an empty container with at least
<tt>n</tt> buckets, using <tt>hasher()</tt> as the hash function and <tt>key_equal()</tt> as
the key equality predicate. </td>
<td><tt>O(N)</tt></td>
</tr>

<tr>
<td><tt>X()<br>X a</tt></td>
<td><tt>X</tt></td>
<td><ins><i>Requires:</i> <tt>hasher</tt>  and <tt>key_equal</tt> are
<tt>DefaultConstructible</tt>.</ins> Constructs an empty container an unspecified number of buckets,
using <tt>hasher()</tt> as the hash function and <tt>key_equal()</tt> as
the key equality predicate. </td>
<td>constant</td>
</tr>

<tr>
<td><tt>X(i, j, n, hf, eq)<br>X a(i, j, n, hf, eq)</tt></td>
<td><tt>X</tt></td>
<td><ins><i>Requires:</i> <tt>value_type</tt> is constructible from
<tt>*i</tt>. <tt>hasher</tt>  and <tt>key_equal</tt> are
<tt>CopyConstructible</tt>.</ins><br>
Constructs an empty container with at least <tt>n</tt> buckets, using
<tt>hf</tt> as the hash function and <tt>eq</tt> as the key equality predicate,
and inserts elements from <tt>[i, j)</tt> into it.</td>
<td>Average case <tt>O(N)</tt> (<tt>N</tt> is <tt>distance(i, j)</tt>), worst
case <tt>O(N<sup>2</sup>)</tt></td>
</tr>

<tr>
<td><tt>X(i, j, n, hf)<br>X a(i, j, n, hf)</tt></td>
<td><tt>X</tt></td>
<td><ins><i>Requires:</i> <tt>value_type</tt> is constructible from <tt>*i</tt>.
<tt>hasher</tt> is <tt>CopyConstructible</tt> and <tt>key_equal</tt> is
<tt>DefaultConstructible</tt>.</ins><br> Constructs an empty container with at
least <tt>n</tt> buckets, using <tt>hf</tt> as the hash function and
<tt>key_equal()</tt> as the key equality predicate, and inserts elements from
<tt>[i, j)</tt> into it.</td>
<td>Average case <tt>O(N)</tt> (<tt>N</tt> is <tt>distance(i, j)</tt>), worst
case <tt>O(N<sup>2</sup>)</tt></td>
</tr>

<tr>
<td><tt>X(i, j, n)<br>X a(i, j, n)</tt></td>
<td><tt>X</tt></td>
<td><ins><i>Requires:</i> <tt>value_type</tt> is constructible from <tt>*i</tt>.
<tt>hasher</tt> and <tt>key_equal</tt> are
<tt>DefaultConstructible</tt>.</ins><br> Constructs an empty container with at
least <tt>n</tt> buckets, using <tt>hasher()</tt> as the hash function and
<tt>key_equal()</tt> as the key equality predicate, and inserts elements from
<tt>[i, j)</tt> into it.</td>
<td>Average case <tt>O(N)</tt> (<tt>N</tt> is <tt>distance(i, j)</tt>), worst
case <tt>O(N<sup>2</sup>)</tt></td>
</tr>

<tr>
<td><tt>X(i, j)<br>X a(i, j)</tt></td>
<td><tt>X</tt></td>
<td><ins><i>Requires:</i> <tt>value_type</tt> is constructible from <tt>*i</tt>.
<tt>hasher</tt> and <tt>key_equal</tt> are
<tt>DefaultConstructible</tt>.</ins><br> Constructs an empty container with an
unspecified number of buckets, using <tt>hasher()</tt> as the hash function and
<tt>key_equal()</tt> as the key equality predicate, and inserts elements from
<tt>[i, j)</tt> into it.</td>
<td>Average case <tt>O(N)</tt> (<tt>N</tt> is <tt>distance(i, j)</tt>), worst
case <tt>O(N<sup>2</sup>)</tt></td>
</tr>

<tr>
<td><tt>X(b)<br>X a(b)</tt></td>
<td><tt>X</tt></td>
<td>Copy constructor. In addition to the <del>contained elements</del>
<ins>requirements of Table 93 (23.2.1 [container.requirements.general])</ins>, copies the hash function,
predicate, and maximum load factor.</td>
<td>Average case linear in <tt>b.size()</tt>, worst case quadratic.</td>
</tr>

<tr>
<td><tt>a = b</tt></td>
<td><tt>X&amp;</tt></td>
<td>Copy assignment operator. In addition to the <del>contained elements</del>
<ins>requirements of Table 93 (23.2.1 [container.requirements.general])</ins>, copies the hash function,
predicate, and maximum load factor.</td>
<td>Average case linear in <tt>b.size()</tt>, worst case quadratic.</td>
</tr>

<tr>
<td><tt>a = il</tt></td>
<td><tt>X&amp;</tt></td>
<td><del><tt>a = X(il); return *this;</tt></del><br>
<ins><i>Requires:</i> <tt>T</tt> is <tt>CopyConstructible</tt> and
<tt>CopyAssignable</tt>.</ins><br>
<ins>Assigns the range <tt>[il.begin(), il.end())</tt> into <tt>a</tt>.  All
existing elements of <tt>a</tt> are either assigned or destroyed.</ins></td>
<td>Average case linear in <tt>il.size()</tt>, worst case quadratic.</td>
</tr>

<tr>
<td><tt>a_uniq.emplace(args)</tt></td>
<td><tt>pair&lt;iterator, bool&gt;</tt></td>
<td><ins><i>Requires:</i> <tt>T</tt> shall be constructible from
<tt>args</tt></ins><br>
inserts a <tt>T</tt> object <tt>t</tt> constructed with
<tt>std::forward&lt;Args&gt;(args)...</tt> if and only if there is no element in
the container with key equivalent to the key of <tt>t</tt>. The <tt>bool</tt>
component of the returned pair is true if and only if the insertion takes place,
and the iterator component of the pair points to the element with key equivalent
to the key of <tt>t</tt>.</td>
<td>Average case O(1), worst case O(<tt>a_uniq.size()</tt>).</td>
</tr>

<tr>
<td><tt>a_eq.emplace(args)</tt></td>
<td><tt>iterator</tt></td>
<td><ins><i>Requires:</i> <tt>T</tt> shall be constructible from
<tt>args</tt></ins><br>
inserts a <tt>T</tt> object <tt>t</tt> constructed with
<tt>std::forward&lt;Args&gt;(args)...</tt> and returns the iterator pointing to
the newly inserted element.</td>
<td>Average case O(1), worst case O(<tt>a_eq.size()</tt>).</td>
</tr>

<tr>
<td><tt>a.emplace_hint(p, args)</tt></td>
<td><tt>iterator</tt></td>
<td><ins><i>Requires:</i> <tt>T</tt> shall be constructible from
<tt>args</tt></ins><br>
equivalent to <tt>a.emplace( std::forward&lt;Args&gt;(args)...)</tt>. Return
value is an iterator pointing to the element with the key equivalent to the
newly inserted element. The <tt>const_iterator p</tt> is a hint pointing to
where the search should start. Implementations are permitted to ignore the
hint.</td>
<td>Average case O(1), worst case O(<tt>a.size()</tt>).</td>
</tr>

<tr>
<td><tt>a_uniq.insert(t)</tt></td>
<td><tt>pair&lt;iterator, bool&gt;</tt></td>
<td><ins><i>Requires:</i> <tt>T</tt> shall be <tt>MoveConstructible</tt> if
<tt>t</tt> is a non-const rvalue expression, else <tt>T</tt> shall be
<tt>CopyConstructible</tt>.</ins><br>
Inserts <tt>t</tt> if and only if there is no element in the container with key
equivalent to the key of <tt>t</tt>. The <tt>bool</tt> component of the returned
pair indicates whether the insertion takes place, and the iterator component
points to the element with key equivalent to the key of <tt>t</tt>.</td>
<td>Average case O(1), worst case O(<tt>a_uniq.size()</tt>).</td>
</tr>

<tr>
<td><tt>a_eq.insert(t)</tt></td>
<td><tt>iterator</tt></td>
<td><ins><i>Requires:</i> <tt>T</tt> shall be <tt>MoveConstructible</tt> if
<tt>t</tt> is a non-const rvalue expression, else <tt>T</tt> shall be
<tt>CopyConstructible</tt>.</ins><br>
Inserts <tt>t</tt>, and returns an iterator pointing to the newly inserted
element.</td>
<td>Average case O(1), worst case O(<tt>a_uniq.size()</tt>).</td>
</tr>

<tr>
<td><tt>a.insert(q, t)</tt></td>
<td><tt>iterator</tt></td>
<td><ins><i>Requires:</i> <tt>T</tt> shall be <tt>MoveConstructible</tt> if
<tt>t</tt> is a non-const rvalue expression, else <tt>T</tt> shall be
<tt>CopyConstructible</tt>.</ins><br>
Equivalent to <tt>a.insert(t)</tt>. Return value is an iterator pointing to the
element with the key equivalent to that of <tt>t</tt>. The iterator <tt>q</tt>
is a hint pointing to where the search should start. Implementations are
permitted to ignore the hint.</td>
<td>Average case O(1), worst case O(<tt>a_uniq.size()</tt>).</td>
</tr>

<tr>
<td><tt>a.insert(i, j)</tt></td>
<td><tt>void</tt></td>
<td><ins><i>Requires:</i> <tt>T</tt> shall be
constructible from <tt>*i</tt>.</ins><br>
Pre: <tt>i</tt> and <tt>j</tt> are not iterators in <tt>a</tt>. Equivalent to
<tt>a.insert(t)</tt> for each element in <tt>[i,j)</tt>.</td>
<td>Average case O(<tt>N</tt>), where <tt>N</tt> is <tt>distance(i, j)</tt>.
Worst case O(<tt>N * a.size()</tt>).</td>
</tr>

</tbody></table>

</blockquote>

<p>
Change 23.3.3 [forwardlist]/2:
</p>

<blockquote>
2 A <tt>forward_list</tt> satisfies all of the requirements of a container
(table 91), except that the <tt>size()</tt> member function is not provided.
<ins>A <tt>forward_list</tt> also satisfies all of the requirements of an
allocator-aware container (table 93).  And <tt>forward_list</tt> provides the
<tt>assign</tt> member functions as specified in Table 94, Sequence container
requirements, and several of the optional sequence container requirements (Table
95).</ins>
Descriptions are provided here only for operations on <tt>forward_list</tt> that
are not described in that table or for operations where there is additional
semantic information.
</blockquote>

<p>
Add a new paragraph after 23.3.3.4 [forwardlist.modifiers]/23:
</p>

<blockquote><pre>void clear();
</pre>

<blockquote>
<p>
23 <i>Effects:</i> Erases all elements in the range <tt>[begin(),end())</tt>.
</p>
<p><ins>
<i>Remarks:</i> Does not invalidate past-the-end iterators.
</ins></p>
</blockquote>
</blockquote>

<p>
Change 23.4.1.2 [vector.capacity]/13:
</p>

<blockquote><pre>void resize(size_type sz, const T&amp; c);
</pre>
<blockquote>
13 <i>Requires:</i> <ins><tt>T</tt> shall be <tt>CopyConstructible</tt>.</ins>
If <tt>value_type</tt> has a move constructor, that constructor shall not throw
any exceptions.
</blockquote>
</blockquote>

<p>
In 23.7.3 [unord.set] and 23.7.4 [unord.multiset] substitute
"<tt>Key</tt>" for "<tt>Value</tt>".
</p>

<blockquote>
<p><i>[
The above substitution is normative as it ties into the requirements table.
]</i></p>

</blockquote>






<hr>
<h3><a name="705"></a>705. type-trait <tt>decay</tt> incompletely specified</h3>
<p><b>Section:</b> 20.7.7.6 [meta.trans.other] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Thorsten Ottosen <b>Opened:</b> 2007-07-08 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#meta.trans.other">issues</a> in [meta.trans.other].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The current working draft has a type-trait <tt>decay</tt> in 20.7.7.6 [meta.trans.other].
</p>

<p>
Its use is to turn C++03 pass-by-value parameters into efficient C++0x
pass-by-rvalue-reference parameters. However, the current definition
introduces an incompatible change where the cv-qualification of the
parameter type is retained. The deduced type should loose such
cv-qualification, as pass-by-value does.
</p>


<p><b>Proposed resolution:</b></p>
<p>
In 20.7.7.6 [meta.trans.other] change the last sentence:
</p>

<blockquote><p>
Otherwise the  member typedef <tt>type</tt> equals <tt><ins>remove_cv&lt;</ins>U<ins>&gt;::type</ins></tt>.
</p></blockquote>

<p>
In 20.4.2.4 [tuple.creation]/1 change:
</p>

<blockquote><p>
<del>where each <tt>Vi</tt> in <tt>VTypes</tt> is <tt>X&amp;</tt> if, for the
corresponding type <tt>Ti</tt> in <tt>Types</tt>,
<tt>remove_cv&lt;remove_reference&lt;Ti&gt;::type&gt;::type</tt> equals
<tt>reference_wrapper&lt;X&gt;</tt>, otherwise <tt>Vi</tt> is
<tt>decay&lt;Ti&gt;::type</tt>.</del>
<ins>Let <tt>Ui</tt> be <tt>decay&lt;Ti&gt;::type</tt> for each
<tt>Ti</tt> in <tt>Types</tt>. Then each <tt>Vi</tt> in <tt>VTypes</tt>
is <tt>X&amp;</tt> if <tt>Ui</tt> equals
<tt>reference_wrapper&lt;X&gt;</tt>, otherwise <tt>Vi</tt> is
<tt>Ui</tt>.</ins>
</p></blockquote>






<hr>
<h3><a name="706"></a>706. <tt>make_pair()</tt> should behave as <tt>make_tuple()</tt> wrt. <tt>reference_wrapper()</tt></h3>
<p><b>Section:</b> 20.3.5 [pairs] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Thorsten Ottosen <b>Opened:</b> 2007-07-08 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#pairs">issues</a> in [pairs].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The current draft has <tt>make_pair()</tt> in 20.3.5 [pairs]/16
and <tt>make_tuple()</tt> in 20.4.2.4 [tuple.creation].
<tt>make_tuple()</tt> detects the presence of
<tt>reference_wrapper&lt;X&gt;</tt> arguments and "unwraps" the reference in
such cases. <tt>make_pair()</tt> would OTOH create a
<tt>reference_wrapper&lt;X&gt;</tt> member. I suggest that the two
functions are made to behave similar in this respect to minimize
confusion.
</p>


<p><b>Proposed resolution:</b></p>
<p>
In 20.3 [utility] change the synopsis for make_pair() to read
</p>

<blockquote><pre>template &lt;class T1, class T2&gt;
  pair&lt;<del>typename decay&lt;T1&gt;::type</del> <ins>V1</ins>, <del>typename decay&lt;T2&gt;::type</del> <ins>V2</ins>&gt; make_pair(T1&amp;&amp;, T2&amp;&amp;);
</pre></blockquote>

<p>
In 20.3.5 [pairs]/16 change the declaration to match the above synopsis.
Then change the 20.3.5 [pairs]/17 to:
</p>

<blockquote>
<p>
<i>Returns:</i> <tt>pair&lt;<del>typename decay&lt;T1&gt;::type</del> <ins>V1</ins>,<del>typename decay&lt;T2&gt;::type</del> <ins>V2</ins>&gt;(forward&lt;T1&gt;(x),forward&lt;T2&gt;(y))</tt> <ins>where <tt>V1</tt> and
<tt>V2</tt> are determined as follows: Let <tt>Ui</tt> be
<tt>decay&lt;Ti&gt;::type</tt> for each <tt>Ti</tt>. Then each
<tt>Vi</tt> is <tt>X&amp;</tt> if <tt>Ui</tt> equals
<tt>reference_wrapper&lt;X&gt;</tt>, otherwise <tt>Vi</tt> is
<tt>Ui</tt>.</ins>
</p>
</blockquote>






<hr>
<h3><a name="709"></a>709. <tt>char_traits::not_eof</tt> has wrong signature</h3>
<p><b>Section:</b> 21.2.3 [char.traits.specializations] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Bo Persson <b>Opened:</b> 2007-08-13 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#char.traits.specializations">issues</a> in [char.traits.specializations].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The changes made for <tt>constexpr</tt> in 21.2.3 [char.traits.specializations] have 
not only changed the <tt>not_eof</tt> function from pass by const reference to 
pass by value, it has also changed the parameter type from <tt>int_type</tt> to 
<tt>char_type</tt>.
</p>
<p>
This doesn't work for type <tt>char</tt>, and is inconsistent with the 
requirements in Table 56, Traits requirements, 21.2.1 [char.traits.require].
</p>

<p>
Pete adds:
</p>

<blockquote><p>
For what it's worth, that may not have been an intentional change. 
N2349, which detailed the changes for adding constant expressions to 
the library, has strikeout bars through the <tt>const</tt> and the <tt>&amp;</tt> that 
surround the <tt>char_type</tt> argument, but none through <tt>char_type</tt> itself. 
So the intention may have been just to change to pass by value, with 
text incorrectly copied from the standard.
</p></blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change the signature in 21.2.3.1 [char.traits.specializations.char],
21.2.3.2 [char.traits.specializations.char16_t], 21.2.3.3 [char.traits.specializations.char32_t],
and 21.2.3.4 [char.traits.specializations.wchar.t] to
</p>

<blockquote><pre>static constexpr int_type not_eof(<del>char_type</del> <ins>int_type</ins> c);
</pre></blockquote>



<p><i>[
Bellevue:
]</i></p>


<blockquote>
Resolution: NAD editorial - up to Pete's judgment
</blockquote>

<p><i>[
Post Sophia Antipolis
]</i></p>


<blockquote>
Moved from Pending NAD Editorial to Review.  The proposed wording appears to be correct but non-editorial.
</blockquote>




<hr>
<h3><a name="710"></a>710. Missing postconditions</h3>
<p><b>Section:</b> 20.9.10.2 [util.smartptr.shared] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Peter Dimov <b>Opened:</b> 2007-08-24 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#util.smartptr.shared">issues</a> in [util.smartptr.shared].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
A discussion on
<a href="http://groups.google.com/group/comp.std.c++/browse_frm/thread/8e89dceb35cd7971">comp.std.c++</a>
has identified a contradiction in the <tt>shared_ptr</tt> specification.
The <tt>shared_ptr</tt> move constructor and the cast functions are
missing postconditions for the <tt>get()</tt> accessor.
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
<p>
Move to "ready", adopting the first (Peter's) proposed resolution.
</p>
<p>
Note to the project editor: there is an editorial issue here. The
wording for the postconditions of the casts is slightly awkward, and the
editor should consider rewording "If w is the return value...", e. g. as
"For a return value w...".
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Add to 20.9.10.2.1 [util.smartptr.shared.const]:
</p>

<blockquote>
<pre>shared_ptr(shared_ptr&amp;&amp; r);
template&lt;class Y&gt; shared_ptr(shared_ptr&lt;Y&gt;&amp;&amp; r);
</pre>
<blockquote>
<p>
<i>Postconditions:</i>  <tt>*this</tt> shall contain the old value of <tt>r</tt>. <tt>r</tt>
shall be empty. <ins><tt>r.get() == 0</tt>.</ins>
</p>
</blockquote>
</blockquote>

<p>
Add to 20.9.10.2.10 [util.smartptr.shared.cast]:
</p>

<blockquote>
<pre>template&lt;class T, class U&gt; shared_ptr&lt;T&gt; static_pointer_cast(shared_ptr&lt;U&gt; const&amp; r);
</pre>
<blockquote>
<p>
<ins><i>Postconditions:</i> If <tt>w</tt> is the return value,
<tt>w.get() == static_cast&lt;T*&gt;(r.get()) &amp;&amp; w.use_count() == r.use_count()</tt>.</ins>
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>template&lt;class T, class U&gt; shared_ptr&lt;T&gt; dynamic_pointer_cast(shared_ptr&lt;U&gt; const&amp; r);
</pre>
<blockquote>
<p>
<ins><i>Postconditions:</i> If <tt>w</tt> is the return value, <tt>w.get() == dynamic_cast&lt;T*&gt;(r.get())</tt>.</ins>
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>template&lt;class T, class U&gt; shared_ptr&lt;T&gt; const_pointer_cast(shared_ptr&lt;U&gt; const&amp; r);
</pre>
<blockquote>
<p>
<ins><i>Postconditions:</i> If <tt>w</tt> is the return value,
<tt>w.get() == const_cast&lt;T*&gt;(r.get()) &amp;&amp; w.use_count() == r.use_count()</tt>.</ins>
</p>
</blockquote>
</blockquote>

<p>
Alberto Ganesh Barbati has written an
<a href="http://barbati.net/c++/shared_ptr.pdf">alternative proposal</a>
where he suggests (among other things) that the casts be respecified in terms of
the aliasing constructor as follows:
</p>

<p>
Change 20.9.10.2.10 [util.smartptr.shared.cast]:
</p>

<blockquote>
<p>
-2- <i>Returns:</i> <del>If <tt>r</tt> is empty, an <tt>empty
shared_ptr&lt;T&gt;;</tt> otherwise, a <tt>shared_ptr&lt;T&gt;</tt>
object that stores <tt>static_cast&lt;T*&gt;(r.get())</tt> and shares ownership with
<tt>r</tt>.</del> <ins><tt>shared_ptr&lt;T&gt;(r, static_cast&lt;T*&gt;(r.get())</tt>.</ins>
</p>
</blockquote>

<blockquote>
<p>
-6- <i>Returns:</i>
</p>
<ul>
<li><del>When <tt>dynamic_cast&lt;T*&gt;(r.get())</tt> returns a nonzero value,
a <tt>shared_ptr&lt;T&gt;</tt> object that stores a copy 
of it and <i>shares ownership</i> with <tt>r</tt>;</del></li>
<li><del>Otherwise, an <i>empty</i> <tt>shared_ptr&lt;T&gt;</tt> object.</del></li>
<li><ins>If <tt>p = dynamic_cast&lt;T*&gt;(r.get())</tt> is a non-null pointer, <tt>shared_ptr&lt;T&gt;(r, p);</tt></ins></li>
<li><ins>Otherwise, <tt>shared_ptr&lt;T&gt;()</tt>.</ins></li>
</ul>
</blockquote>

<blockquote>
<p>
-10- <i>Returns:</i> <del>If <tt>r</tt> is empty, an <tt>empty
shared_ptr&lt;T&gt;;</tt> otherwise, a <tt>shared_ptr&lt;T&gt;</tt>
object that stores <tt>const_cast&lt;T*&gt;(r.get())</tt> and shares ownership with
<tt>r</tt>.</del> <ins><tt>shared_ptr&lt;T&gt;(r, const_cast&lt;T*&gt;(r.get())</tt>.</ins>
</p>
</blockquote>

<p>
This takes care of the missing postconditions for the casts by bringing
in the aliasing constructor postcondition "by reference".
</p>






<hr>
<h3><a name="711"></a>711. Contradiction in empty <tt>shared_ptr</tt></h3>
<p><b>Section:</b> 20.9.10.2.5 [util.smartptr.shared.obs] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Peter Dimov <b>Opened:</b> 2007-08-24 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#util.smartptr.shared.obs">issues</a> in [util.smartptr.shared.obs].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
A discussion on
<a href="http://groups.google.com/group/comp.std.c++/browse_frm/thread/8e89dceb35cd7971">comp.std.c++</a>
has identified a contradiction in the <tt>shared_ptr</tt> specification.
The note:
</p>

<blockquote><p>
[ <i>Note:</i> this constructor allows creation of an empty shared_ptr instance with a non-NULL stored pointer.
-end note ]
</p></blockquote>

<p>
after the aliasing constructor
</p>

<blockquote><pre>template&lt;class Y&gt; shared_ptr(shared_ptr&lt;Y&gt; const&amp; r, T *p);
</pre></blockquote>

<p>
reflects the intent of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2351.htm">N2351</a>
to, well, allow the creation of an empty <tt>shared_ptr</tt>
with a non-NULL stored pointer.
</p>

<p>
This is contradicted by the second sentence in the Returns clause of 20.9.10.2.5 [util.smartptr.shared.obs]:
</p>

<blockquote>
<pre>T* get() const;
</pre>
<blockquote><p>
<i>Returns:</i> the stored pointer. Returns a null pointer if <tt>*this</tt> is empty.
</p></blockquote>
</blockquote>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
<p>
Adopt option 1 and move to review, not ready.
</p>
<p>
There was a lot of confusion about what an empty <tt>shared_ptr</tt> is (the term
isn't defined anywhere), and whether we have a good mental model for how
one behaves. We think it might be possible to deduce what the definition
should be, but the words just aren't there. We need to open an issue on
the use of this undefined term. (The resolution of that issue might
affect the resolution of issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#711">711</a>.)
</p>
<p>
The LWG is getting more uncomfortable with the aliasing proposal (N2351)
now that we realize some of its implications, and we need to keep an eye
on it, but there isn't support for removing this feature at this time.
</p>
</blockquote>

<p><i>[
Sophia Antipolis:
]</i></p>


<blockquote>
<p>
We heard from Peter Dimov, who explained his reason for preferring solution 1.
</p>
<p>
Because it doesn't seem to add anything. It simply makes the behavior
for p = 0 undefined. For programmers who don't create empty pointers
with p = 0, there is no difference. Those who do insist on creating them
presumably have a good reason, and it costs nothing for us to define the
behavior in this case.
</p>
<p>
The aliasing constructor is sharp enough as it is, so "protecting" users
doesn't make much sense in this particular case.
</p>
<p>
&gt; Do you have a use case for r being empty and r being non-null? 
</p>
<p>
I have received a few requests for it from "performance-conscious"
people (you should be familiar with this mindset) who don't like the
overhead of allocating and maintaining a control block when a null
deleter is used to approximate a raw pointer. It is obviously an "at
your own risk", low-level feature; essentially a raw pointer behind a
shared_ptr facade.
</p>
<p>
We could not agree upon a resolution to the issue; some of us thought
that Peter's description above is supporting an undesirable behavior.
</p>
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
<p>
We favor option 1, move to Ready.
</p>
<p><i>[
Howard:  Option 2 commented out for clarity, and can be brought back.
]</i></p>

</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
In keeping the N2351 spirit and obviously my preference, change 20.9.10.2.5 [util.smartptr.shared.obs]:
</p>

<blockquote>
<pre>T* get() const;
</pre>
<blockquote><p>
<i>Returns:</i> the stored pointer. <del>Returns a null pointer if <tt>*this</tt> is empty.</del>
</p></blockquote>
</blockquote>








<hr>
<h3><a name="712"></a>712. <tt>seed_seq::size</tt> no longer useful</h3>
<p><b>Section:</b> 26.5.7.1 [rand.util.seedseq] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Marc Paterno <b>Opened:</b> 2007-08-25 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.util.seedseq">issues</a> in [rand.util.seedseq].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
One of the motivations for incorporating <tt>seed_seq::size()</tt>
was to simplify the wording
in other parts of 26.5 [rand].
As a side effect of resolving related issues,
all such references
to <tt>seed_seq::size()</tt> will have been excised.
More importantly,
the present specification is contradictory,
as "The number of 32-bit units the object can deliver"
is not the same as "the result of <tt>v.size()</tt>."
</p>

<p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2391.pdf">N2391</a> and
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2423.pdf">N2423</a>
for some further discussion.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Adopt the proposed resolution in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2423.pdf">N2423</a>.
</p>


<p><i>[
Kona (2007): The LWG adopted the proposed resolution of N2423 for this issue.
The LWG voted to accelerate this issue to Ready status to be voted into the WP at Kona.
]</i></p>





<hr>
<h3><a name="713"></a>713. <tt>sort()</tt> complexity is too lax</h3>
<p><b>Section:</b> 25.4.1.1 [sort] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2007-08-30 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The complexity of <tt>sort()</tt> is specified as "Approximately <tt>N
log(N)</tt> (where <tt>N == last - first</tt> ) comparisons on the
average", with no worst case complicity specified. The intention was to
allow a median-of-three quicksort implementation, which is usually <tt>O(N
log N)</tt> but can be quadratic for pathological inputs. However, there is
no longer any reason to allow implementers the freedom to have a
worst-cast-quadratic sort algorithm. Implementers who want to use
quicksort can use a variant like David Musser's "Introsort" (Software
Practice and Experience 27:983-993, 1997), which is guaranteed to be <tt>O(N
log N)</tt> in the worst case without incurring additional overhead in the
average case. Most C++ library implementers already do this, and there
is no reason not to guarantee it in the standard.
</p>


<p><b>Proposed resolution:</b></p>
<p>
In 25.4.1.1 [sort], change the complexity to "O(N log N)", and remove footnote 266:
</p>

<blockquote>
<p>
<i>Complexity:</i> <del>Approximately</del> <ins>O(</ins><i>N</i> log(<i>N</i>)<ins>)</ins> (where <i>N</i> == <i>last</i> - <i>first</i> )
comparisons<del> on the average</del>.<del><sup>266)</sup></del>
</p>
<p>
<del><sup>266)</sup>
If the worst case behavior is important <tt>stable_sort()</tt> (25.3.1.2) or <tt>partial_sort()</tt>
(25.3.1.3) should be used.</del>
</p>
</blockquote>






<hr>
<h3><a name="714"></a>714. <tt>search_n</tt> complexity is too lax</h3>
<p><b>Section:</b> 25.2.13 [alg.search] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2007-08-30 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.search">issues</a> in [alg.search].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The complexity for <tt>search_n</tt> (25.2.13 [alg.search] par 7) is specified as "At most
(last - first ) * count applications of the corresponding predicate if
count is positive, or 0 otherwise." This is unnecessarily pessimistic.
Regardless of the value of count, there is no reason to examine any
element in the range more than once.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change the complexity to "At most (last - first) applications of the corresponding predicate".
</p>

<blockquote>
<pre>template&lt;class ForwardIterator, class Size, class T&gt; 
  ForwardIterator 
    search_n(ForwardIterator first , ForwardIterator last , Size count , 
             const T&amp; value ); 

template&lt;class ForwardIterator, class Size, class T, 
         class BinaryPredicate&gt; 
  ForwardIterator 
    search_n(ForwardIterator first , ForwardIterator last , Size count , 
             const T&amp; value , BinaryPredicate pred );
</pre>
<blockquote>
<p>
<i>Complexity:</i> At most <tt>(last - first ) <del>* count</del></tt> applications of the corresponding predicate
<del>if <tt>count</tt> is positive, or 0 otherwise</del>.
</p>
</blockquote>
</blockquote>






<hr>
<h3><a name="715"></a>715. <tt>minmax_element</tt> complexity is too lax</h3>
<p><b>Section:</b> 25.4.7 [alg.min.max] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2007-08-30 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.min.max">issues</a> in [alg.min.max].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The complexity for <tt>minmax_element</tt> (25.4.7 [alg.min.max] par 16) says "At most <tt>max(2 *
(last - first ) - 2, 0)</tt> applications of the corresponding comparisons",
i.e. the worst case complexity is no better than calling <tt>min_element</tt> and
<tt>max_element</tt> separately. This is gratuitously inefficient. There is a
well known technique that does better: see section 9.1 of CLRS
(Introduction to Algorithms, by Cormen, Leiserson, Rivest, and Stein).
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change 25.4.7 [alg.min.max] to:
</p>

<blockquote>
<pre>template&lt;class ForwardIterator&gt; 
  pair&lt;ForwardIterator, ForwardIterator&gt; 
    minmax_element(ForwardIterator first , ForwardIterator last); 
template&lt;class ForwardIterator, class Compare&gt; 
  pair&lt;ForwardIterator, ForwardIterator&gt; 
    minmax_element(ForwardIterator first , ForwardIterator last , Compare comp);
</pre>
<blockquote>
<p>
<i>Returns:</i> <tt>make_pair(m, M)</tt>, where <tt>m</tt> is
<del><tt>min_element(first, last)</tt> or <tt>min_element(first, last,
comp)</tt></del> <ins>the first iterator in <tt>[first,
last)</tt> such that no iterator in the range refers to a smaller element,</ins> and
<ins>where</ins> <tt>M</tt> is <del><tt>max_element(first, last)</tt> or
<tt>max_element(first, last, comp)</tt></del> <ins>the last iterator
in <tt>[first, last)</tt> such that no iterator in the range refers to a larger element</ins>.
</p>
<p>
<i>Complexity:</i> At most <del><tt>max(2 * (last - first ) - 2, 0)</tt></del>
<ins><tt>max(&#8970;(3/2) (N-1)&#8971;, 0)</tt></ins> applications of the
corresponding <del>comparisons</del> <ins>predicate, where <tt>N</tt> is <tt>distance(first, last)</tt></ins>.
</p>
</blockquote>
</blockquote>






<hr>
<h3><a name="716"></a>716. Production in [re.grammar] not actually modified</h3>
<p><b>Section:</b> 28.13 [re.grammar] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2007-08-31 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
TR1 7.13 [tr.re.grammar]/3 and C++0x WP 28.13 [re.grammar]/3 say:
</p>

<blockquote>
<p>
The following productions within the ECMAScript grammar are modified as follows:
</p>

<blockquote><pre>CharacterClass ::
[ [lookahead &#8713; {^}] ClassRanges ]
[ ^ ClassRanges ]
</pre></blockquote>

</blockquote>

<p>
This definition for <tt>CharacterClass</tt> appears to be exactly identical to that in ECMA-262.
</p>

<p>
Was an actual modification intended here and accidentally omitted, or was this production accidentally included?
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We agree that what is specified is identical to what ECMA-262 specifies.
Pete would like to take a bit of time to assess whether we had intended,
but failed, to make a change.
It would also be useful to hear from John Maddock on the issue.
</p>
<p>
Move to Open.
</p>
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
Move to Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Remove this mention of the CharacterClass production.
</p>

<blockquote><pre><del>CharacterClass ::
[ [lookahead &#8713; {^}] ClassRanges ]
[ ^ ClassRanges ]</del>
</pre></blockquote>






<hr>
<h3><a name="719"></a>719. <tt>std::is_literal</tt> type traits should be provided</h3>
<p><b>Section:</b> 20.7 [meta] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2007-08-25 <b>Last modified:</b> 2010-11-20</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#meta">issues</a> in [meta].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#750">750</a></p>
<p><b>Discussion:</b></p>
<p>
Since the inclusion of <tt>constexpr</tt> in the standard draft N2369 we have
a new type category "literal", which is defined in 3.9 [basic.types]/p.11:
</p>

<blockquote>
<p>
-11- A type is a <i>literal</i> type if it is:
</p>
<ul>
<li>a scalar type; or</li>
<li><p>a class type (clause 9) with</p>
<ul>
<li>a trivial copy constructor,</li>
<li>a trivial destructor,</li>
<li>at least one constexpr constructor other than the copy constructor,</li>
<li>no virtual base classes, and</li>
<li>all non-static data members and base classes of literal types; or</li>
</ul>
</li>
<li>an array of literal type.</li>
</ul>
</blockquote>

<p>
I strongly suggest that the standard provides a type traits for
literal types in 20.7.4.3 [meta.unary.prop] for several reasons:
</p>

<ol type="a">
<li>To keep the traits in sync with existing types.</li>
<li>I see many reasons for programmers to use this trait in template
   code to provide optimized template definitions for these types,
   see below.</li>
<li>A user-provided definition of this trait is practically impossible
to write portably.</li>
</ol>

<p>
The special problem of reason (c) is that I don't see currently a
way to portably test the condition for literal class types:
</p>

<blockquote>
<ul>
<li>at least one constexpr constructor other than the copy constructor,</li>
</ul>
</blockquote>

<p><i>[
Alisdair is considering preparing a paper listing a number of missing
type traits, and feels that it might be useful to handle them all
together rather than piecemeal. This would affect issue 719 and 750.
These two issues should move to OPEN pending AM paper on type traits.
]</i></p>


<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
Beman, Daniel, and Alisdair will work on a paper proposing new type traits.
</blockquote>

<p><i>[
Addressed in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2947.html">N2947</a>.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
<del>NAD Editorial</del><ins>Resolved</ins>.  Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2984.htm">N2984</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
In 20.7.2 [meta.type.synop] in the group "type properties",
just below the line
</p>

<blockquote><pre>template &lt;class T&gt; struct is_pod;
</pre></blockquote>

<p>
add a new one:
</p>

<blockquote><pre>template &lt;class T&gt; struct is_literal;
</pre></blockquote>

<p>
In 20.7.4.3 [meta.unary.prop], table Type Property Predicates, just
below the line for the <tt>is_pod</tt> property add a new line:
</p>

<table border="1">
<tbody><tr>
<th>Template</th><th>Condition</th><th>Preconditions</th>
</tr>
<tr>
<td><tt>template &lt;class T&gt; struct is_literal;</tt></td>
<td><tt>T</tt> is a literal type (3.9)</td>
<td><tt>T</tt> shall be a complete type, an
array of unknown bound, or
(possibly cv-qualified) <tt>void</tt>.</td>
</tr>
</tbody></table>






<hr>
<h3><a name="720"></a>720. Omissions in constexpr usages</h3>
<p><b>Section:</b> 23.3.1 [array], 20.5 [template.bitset] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2007-08-25 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#array">issues</a> in [array].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<ol>
<li>
The member function <tt>bool array&lt;T,N&gt;::empty() const</tt> should be a
<tt>constexpr</tt> because this is easily to proof and to implement following it's operational
semantics defined by Table 87 (Container requirements) which says: <tt>a.size() == 0</tt>.
</li>
<li>
The member function <tt>bool bitset&lt;N&gt;::test() const</tt> must be a
<tt>constexpr</tt> (otherwise it would violate the specification of <tt>constexpr
bitset&lt;N&gt;::operator[](size_t) const</tt>, because it's return clause delegates to <tt>test()</tt>).
</li>
<li>
I wonder how the constructor <tt>bitset&lt;N&gt;::bitset(unsigned long)</tt> can
be declared as a <tt>constexpr</tt>. Current implementations usually have no such <tt>bitset</tt>
c'tor which would fulfill the requirements of a <tt>constexpr</tt> c'tor because they have a
non-empty c'tor body that typically contains for-loops or <tt>memcpy</tt> to compute the
initialisation. What have I overlooked here?
</li>
</ol>

<p><i>[
Sophia Antipolis:
]</i></p>


<blockquote>
<p>
We handle this as two parts
</p>
<ol>
<li>
The proposed resolution is correct; move to ready.
</li>
<li>
The issue points out a real problem, but the issue is larger than just
this solution. We believe a paper is needed, applying the full new
features of C++ (including extensible literals) to update <tt>std::bitset</tt>.
We note that we do not consider this new work, and that is should be
handled by the Library Working Group.
</li>
</ol>
<p>
In order to have a consistent working paper, Alisdair and Daniel produced a new wording for the resolution.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>In the class template definition of 23.3.1 [array]/p. 3 change</p>
<blockquote><pre><ins>constexpr</ins> bool empty() const;
</pre></blockquote>
</li>

<li>
<p>In the class template definition of 20.5 [template.bitset]/p. 1 change</p>
<blockquote><pre><ins>constexpr</ins> bool test(size_t pos ) const;
</pre></blockquote>

<p>
and in 20.5.2 [bitset.members] change
</p>

<blockquote><pre><ins>constexpr</ins> bool test(size_t pos ) const;
</pre></blockquote>

</li>
</ol>





<hr>
<h3><a name="722"></a>722. Missing [c.math] functions <tt>nanf</tt> and <tt>nanl</tt></h3>
<p><b>Section:</b> 26.8 [c.math] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2007-08-27 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#c.math">issues</a> in [c.math].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In the listing of 26.8 [c.math], table 108: Header <tt>&lt;cmath&gt;</tt> synopsis I miss
the following C99 functions (from 7.12.11.2):
</p>

<blockquote><pre>float nanf(const char *tagp);
long double nanl(const char *tagp);
</pre></blockquote>

<p>
(Note: These functions cannot be overloaded and they are also not
listed anywhere else)
</p>


<p><b>Proposed resolution:</b></p>
<p>
In 26.8 [c.math], table 108, section "Functions", add <tt>nanf</tt> and <tt>nanl</tt>
just after the existing entry <tt>nan</tt>.
</p>





<hr>
<h3><a name="723"></a>723. <tt>basic_regex</tt> should be moveable</h3>
<p><b>Section:</b> 28.8 [re.regex] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2007-08-29 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#re.regex">issues</a> in [re.regex].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 316</b></p>

<p>
According to the current state of the standard draft, the class
template <tt>basic_regex</tt>, as described in 28.8 [re.regex]/3, is
neither <tt>MoveConstructible</tt> nor <tt>MoveAssignable</tt>.
IMO it should be, because typical regex state machines tend
to have a rather large data quantum and I have seen several
use cases, where a factory function returns regex values,
which would take advantage of moveabilities.
</p>

<p><i>[
Sophia Antipolis:
]</i></p>


<blockquote>
Needs wording for the semantics, the idea is agreed upon.
</blockquote>

<p><i>[
Post Summit Daniel updated wording to reflect new "swap rules".
]</i></p>


<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
Move to Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
In the class definition of <tt>basic_regex</tt>, just below 28.8 [re.regex]/3,
perform the following changes:
</p>

<ol type="a">
<li>
<p>
Just after <tt>basic_regex(const basic_regex&amp;);</tt> insert:
</p>

<blockquote><pre>basic_regex(basic_regex&amp;&amp;);
</pre></blockquote>
</li>
<li>
<p>
Just after <tt>basic_regex&amp; operator=(const basic_regex&amp;);</tt> insert:
</p>
<blockquote><pre>basic_regex&amp; operator=(basic_regex&amp;&amp;);
</pre></blockquote>
</li>
<li>
<p>
Just after <tt>basic_regex&amp; assign(const basic_regex&amp; that);</tt> insert:
</p>
<blockquote><pre>basic_regex&amp; assign(basic_regex&amp;&amp; that);
</pre></blockquote>
</li>
<li>
<p>
In 28.8.2 [re.regex.construct], just after p.11 add the following
new member definition:
</p>
<blockquote><pre>basic_regex(basic_regex&amp;&amp; e);
</pre>
<blockquote>
<p>
<i>Effects:</i> Move-constructs a <tt>basic_regex</tt> instance from <tt>e</tt>.
</p>
<p>
<i>Postconditions:</i> <tt>flags()</tt> and <tt>mark_count()</tt> return <tt>e.flags()</tt> and
<tt>e.mark_count()</tt>, respectively,
that <tt>e</tt> had before construction, leaving
<tt>e</tt> in a valid state with an unspecified value.
</p>
<p>
<i>Throws:</i> nothing.
</p>
</blockquote>
</blockquote>
</li>
<li>
<p>
Also in 28.8.2 [re.regex.construct], just after p.18 add the
following new member definition:
</p>

<blockquote><pre>basic_regex&amp; operator=(basic_regex&amp;&amp; e);
</pre>
<blockquote>
<i>Effects:</i> Returns the result of <tt>assign(std::move(e))</tt>.
</blockquote>
</blockquote>
</li>
<li>
<p>
In 28.8.3 [re.regex.assign], just after p. 2 add the following new
member definition:
</p>
<blockquote><pre>basic_regex&amp; assign(basic_regex&amp;&amp; rhs);
</pre>
<blockquote>
<p>
<i>Effects:</i> Move-assigns a <tt>basic_regex</tt> instance from <tt>rhs</tt> and returns <tt>*this</tt>.
</p>
<p>
<i>Postconditions:</i> <tt>flags()</tt> and <tt>mark_count()</tt> return <tt>rhs.flags()</tt>
and <tt>rhs.mark_count()</tt>, respectively, that
<tt>rhs</tt> had before assignment, leaving <tt>rhs</tt>
in a valid state with an unspecified value.
</p>
<p>
<i>Throws:</i> nothing.
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="724"></a>724. <tt>DefaultConstructible</tt> is not defined</h3>
<p><b>Section:</b> 20.2.1 [utility.arg.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Pablo Halpern <b>Opened:</b> 2007-09-12 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#utility.arg.requirements">issues</a> in [utility.arg.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <tt>DefaultConstructible</tt> requirement is referenced in
several places in the August 2007 working draft
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2369.pdf">N2369</a>,
but is not defined anywhere.
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
<p>
Walking into the default/value-initialization mess...
</p>
<p>
Why two lines? Because we need both expressions to be valid.
</p>
<p>
AJM not sure what the phrase "default constructed" means. This is
unfortunate, as the phrase is already used 24 times in the library!
</p>
<p>
Example: const int would not accept first line, but will accept the second.
</p>
<p>
This is an issue that must be solved by concepts, but we might need to solve it independantly first.
</p>
<p>
It seems that the requirements are the syntax in the proposed first
column is valid, but not clear what semantics we need.
</p>
<p>
A table where there is no post-condition seems odd, but appears to sum up our position best.
</p>
<p>
At a minimum an object is declared and is destuctible.
</p>
<p>
Move to open, as no-one happy to produce wording on the fly.
</p>
</blockquote>

<p><i>[
2009-07-28 Reopened by Alisdair.  No longer solved by concepts.
]</i></p>


<p><i>[
2009-08-17 Daniel adds "[defaultconstructible]" to table title.  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#408">408</a>
depends upon this issue.
]</i></p>


<p><i>[
2009-08-18 Alisdair adds:
]</i></p>


<blockquote>
<p>
Looking at the proposed table in this issue, it really needs two rows:
</p>

<blockquote>
<table border="1">
<caption>Table 33: <tt>DefaultConstructible</tt> requirements [defaultconstructible]</caption>
<tbody><tr>
<th>expression</th><th>post-condition</th>
</tr>

<tr>
<td><tt>T t;</tt></td><td><tt>t</tt> is default-initialized.</td>
</tr>

<tr>
<td><tt>T{}</tt></td><td>Object of type <tt>T</tt> is value-initialized.</td>
</tr>
</tbody></table>
</blockquote>

<p>
Note I am using the new brace-initialization syntax that is unambiguous
in all use cases (no most vexing parse.)
</p>
</blockquote>

<p><i>[
2009-10-03 Daniel adds:
]</i></p>


<blockquote>
<p>
The suggested definition <tt>T{}</tt> describing it as
value-initialization is wrong, because it belongs to list-initialization
which would - as the current rules are - always prefer a
initializer-list constructor over a default-constructor. I don't
consider this as an appropriate definition of
<tt>DefaultConstructible</tt>. My primary suggestion is to ask core,
whether the special case <tt>T{}</tt> (which also easily leads to
ambiguity situations for more than one initializer-list in a class)
would always prefer a default-constructor - if any - before considering
an initializer-list constructor or to provide another syntax form to
prefer value-initialization over list-initialization. If that fails I
would fall back to suggest to use the expression <tt>T()</tt> instead of
<tt>T{}</tt> with all it's disadvantages for the meaning of the
expression
</p>

<blockquote><pre>T t();
</pre></blockquote>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Leave Open. Core is looking to make Alisdair's proposed
resolution correct.
</blockquote>

<p><i>[
2010-01-24 At Alisdiar's request, moved his proposal into the proposed wording
seciton.  The old wording is preserved here:
]</i></p>


<blockquote>
<p>
In section 20.2.1 [utility.arg.requirements], before table 33, add the
following table:
</p>

<p align="center" style="text-align:center">Table 33: <tt>DefaultConstructible</tt> requirements [defaultconstructible]</p>

<div align="center">

<table border="0" cellspacing="0" cellpadding="0" style="border-collapse:collapse">
 <tbody><tr>
  <td width="114" valign="top" style="width:85.5pt;border-top:solid navy 1.0pt;
  border-left:solid navy 1.0pt;border-bottom:double navy 1.5pt;border-right:
  none;padding:0in 5.4pt 0in 5.4pt">
  <p align="center" style="margin:0in;margin-bottom:.0001pt;text-align:center">expression</p>
  </td>
  <td width="324" valign="top" style="width:243.0pt;border-top:solid navy 1.0pt;
  border-left:none;border-bottom:double navy 1.5pt;border-right:solid navy 1.0pt;
  padding:0in 5.4pt 0in 5.4pt">
  <p align="center" style="margin:0in;margin-bottom:.0001pt;text-align:center">post-condition</p>
  </td>
 </tr>
 <tr>
  <td width="114" valign="top" style="width:85.5pt;border-top:none;border-left:
  solid navy 1.0pt;border-bottom:solid navy 1.0pt;border-right:none;padding:
  0in 5.4pt 0in 5.4pt">
  <p style="margin:0in;margin-bottom:.0001pt"><tt>T
  t;</tt><br>
  <tt>T()</tt></p>
  </td>
  <td width="324" valign="top" style="width:243.0pt;border-top:none;border-left:
  none;border-bottom:solid navy 1.0pt;border-right:solid navy 1.0pt;padding:
  0in 5.4pt 0in 5.4pt">
  <p style="margin:0in;margin-bottom:.0001pt"><tt>T</tt>
  is <i>default constructed.</i></p>
  </td>
 </tr>
</tbody></table>

</div>

</blockquote>

<p><i>[
2010-02-04: Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>




<p><b>Rationale:</b></p>
<p><i>[
San Francisco:
]</i></p>

<blockquote>
We believe concepts will solve this problem
(<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2774.pdf">N2774</a>).
</blockquote>

<p><i>[
Rationale is obsolete.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
In section 20.2.1 [utility.arg.requirements], before table 33, add the
following table:
</p>

<blockquote>
<table border="1">
<caption>Table 33: <tt>DefaultConstructible</tt> requirements [defaultconstructible]</caption>
<tbody><tr>
<th>expression</th><th>post-condition</th>
</tr>

<tr>
<td><tt>T t;</tt></td><td>Object <tt>t</tt> is default-initialized.</td>
</tr>

<tr>
<td><tt>T u{};</tt></td><td>Object <tt>u</tt> is value-initialized.</td>
</tr>

<tr>
<td><tt>T()<br>T{}</tt></td><td>A temporary object of type <tt>T</tt> is value-initialized.</td>
</tr>

</tbody></table>
</blockquote>






<hr>
<h3><a name="727"></a>727. <tt>regex_replace()</tt> doesn't accept <tt>basic_string</tt>s with custom traits and allocators</h3>
<p><b>Section:</b> 28.11.4 [re.alg.replace] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2007-09-22 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#re.alg.replace">issues</a> in [re.alg.replace].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>regex_match()</tt> and <tt>regex_search()</tt> take <tt>const basic_string&lt;charT, ST,
SA&gt;&amp;</tt>.  <tt>regex_replace()</tt> takes <tt>const basic_string&lt;charT&gt;&amp;</tt>.  This prevents
<tt>regex_replace()</tt> from accepting <tt>basic_string</tt>s with custom traits and
allocators.
</p>

<p>
Overloads of <tt>regex_replace()</tt> taking <tt>basic_string</tt> should be additionally
templated on <tt>class ST, class SA</tt> and take <tt>const basic_string&lt;charT, ST,
SA&gt;&amp;</tt>.  Consistency with <tt>regex_match()</tt> and <tt>regex_search()</tt> would place
<tt>class ST, class SA</tt> as the first template arguments; compatibility with
existing code using TR1 and giving explicit template arguments to
<tt>regex_replace()</tt> would place <tt>class ST, class SA</tt> as the last template
arguments.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Bill comments, "We need to look at the depth of this change."
</p>
<p>
Pete remarks that we are here dealing with a convenience function
that saves a user from calling the iterato-based overload.
</p>
<p>
Move to Open.
</p>
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
Howard to ask Stephan Lavavej to provide wording.
</blockquote>

<p><i>[
2009-07-17 Stephan provided wording.
]</i></p>


<p><i>[
2009-07-25 Daniel tweaks both this issue and <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#726">726</a>.
]</i></p>


<blockquote>
<p>
One relevant part of the proposed resolution below suggests
to add a new overload of the format member function in the
<tt>match_results</tt> class template that accepts two character pointers
defining the <tt>begin</tt> and <tt>end</tt> of a format range. A more general
approach could have proposed a pair of iterators instead, but
the used pair of char pointers reflects existing practice. If the
committee strongly favors an iterator-based signature, this
could be simply changed. I think that the minimum requirement
should be a <tt>BidirectionalIterator</tt>, but current implementations
take advantage (at least partially) of the <tt>RandomAccessIterator</tt>
sub interface of the char pointers.
</p>

<p><b>Suggested Resolution:</b></p>

<p><i>[Moved into the proposed resloution]</i></p>



</blockquote>

<p><i>[
2009-07-30 Stephan agrees with Daniel's wording.  Howard places Daniel's wording
in the Proposed Resolution.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Move to Review. Chair is anxious to move this to Ready in Pittsburgh.
</blockquote>

<p><i>[
2010-01-27 Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>




<p><b>Proposed resolution:</b></p>

<ol>
<li>
<p>
Change 28.4 [re.syn] as indicated:
</p>

<blockquote><pre>// 28.11.4, function template regex_replace:
template &lt;class OutputIterator, class BidirectionalIterator,
          class traits, class charT<ins>, class ST, class SA</ins>&gt;
  OutputIterator
  regex_replace(OutputIterator out,
                BidirectionalIterator first, BidirectionalIterator last,
                const basic_regex&lt;charT, traits&gt;&amp; e,
                const basic_string&lt;charT<ins>, ST, SA</ins>&gt;&amp; fmt,
                regex_constants::match_flag_type flags =
                  regex_constants::match_default);

<ins>
template &lt;class OutputIterator, class BidirectionalIterator,
          class traits, class charT&gt;
  OutputIterator
  regex_replace(OutputIterator out,
                BidirectionalIterator first, BidirectionalIterator last,
                const basic_regex&lt;charT, traits&gt;&amp; e,
                const charT* fmt,
                regex_constants::match_flag_type flags =
                  regex_constants::match_default);
</ins>

template &lt;class traits, class charT<ins>, class ST, class SA,
          class FST, class FSA</ins>&gt;
  basic_string&lt;charT<ins>, ST, SA</ins>&gt;
  regex_replace(const basic_string&lt;charT<ins>, ST, SA</ins>&gt;&amp; s,
                const basic_regex&lt;charT, traits&gt;&amp; e,
                const basic_string&lt;charT<ins>, FST, FSA</ins>&gt;&amp; fmt,
                regex_constants::match_flag_type flags =
                  regex_constants::match_default);

<ins>
template &lt;class traits, class charT, class ST, class SA&gt;
  basic_string&lt;charT, ST, SA&gt;
  regex_replace(const basic_string&lt;charT, ST, SA&gt;&amp; s,
                const basic_regex&lt;charT, traits&gt;&amp; e,
                const charT* fmt,
                regex_constants::match_flag_type flags =
                  regex_constants::match_default);
</ins>

<ins>
template &lt;class traits, class charT, class ST, class SA&gt;
  basic_string&lt;charT&gt;
  regex_replace(const charT* s,
                const basic_regex&lt;charT, traits&gt;&amp; e,
                const basic_string&lt;charT, ST, SA&gt;&amp; fmt,
                regex_constants::match_flag_type flags =
                  regex_constants::match_default);
</ins>

<ins>
template &lt;class traits, class charT&gt;
  basic_string&lt;charT&gt;
  regex_replace(const charT* s,
                const basic_regex&lt;charT, traits&gt;&amp; e,
                const charT* fmt,
                regex_constants::match_flag_type flags =
                  regex_constants::match_default);
</ins>
</pre></blockquote>
</li>

<li>
<p>
Change 28.10 [re.results]/3, class template <tt>match_results</tt> as
indicated:
</p>

<blockquote><pre><ins>
template &lt;class OutputIter&gt;
  OutputIter
  format(OutputIter out,
         const char_type* fmt_first, const char_type* fmt_last,
         regex_constants::match_flag_type flags =
           regex_constants::format_default) const;
</ins>

template &lt;class OutputIter<ins>, class ST, class SA</ins>&gt;
  OutputIter
  format(OutputIter out,
         const <del>string_type</del><ins>basic_string&lt;char_type, ST, SA&gt;</ins>&amp; fmt,
         regex_constants::match_flag_type flags =
           regex_constants::format_default) const;

<ins>template &lt;class ST, class SA&gt;</ins>
  <del>string_type</del><ins>basic_string&lt;char_type, ST, SA&gt;</ins>
  format(const <del>string_type</del><ins>basic_string&lt;char_type, ST, SA&gt;</ins>&amp; fmt,
         regex_constants::match_flag_type flags =
           regex_constants::format_default) const;

<ins>
string_type
format(const char_type* fmt,
       regex_constants::match_flag_type flags =
         regex_constants::format_default) const;
</ins>
</pre></blockquote>
</li>

<li>
<p>
Insert at the very beginning of 28.10.5 [re.results.form] the following:
</p>

<blockquote><pre><ins>
template &lt;class OutputIter&gt;
  OutputIter
  format(OutputIter out,
         const char_type* fmt_first, const char_type* fmt_last,
         regex_constants::match_flag_type flags =
           regex_constants::format_default) const;
</ins>
</pre>
<blockquote>

<p><ins>
1 <i>Requires:</i> The type <tt>OutputIter</tt> shall satisfy the requirements for an
Output Iterator (24.2.4 [output.iterators]).
</ins></p>

<p><ins>
2 <i>Effects:</i> Copies the character sequence <tt>[fmt_first,fmt_last)</tt> to
<tt>OutputIter out</tt>. Replaces each format specifier or escape sequence in
the copied range with either the character(s) it represents or the sequence of
characters within <tt>*this</tt> to which it refers.  The bitmasks specified in
<tt>flags</tt> determine which format specifiers and escape sequences are
recognized.
</ins></p>

<p><ins>
3 <i>Returns:</i> <tt>out</tt>.
</ins></p>
</blockquote>
</blockquote>
</li>

<li>
<p>
Change 28.10.5 [re.results.form], before p. 1 until p. 3 as indicated:
</p>

<blockquote><pre>template &lt;class OutputIter<ins>, class ST, class SA</ins>&gt;
  OutputIter
  format(OutputIter out,
         const <del>string_type</del><ins>basic_string&lt;char_type, ST, SA&gt;</ins>&amp; fmt,
         regex_constants::match_flag_type flags =
           regex_constants::format_default) const;
</pre>

<blockquote>
<p>
<del>1 <i>Requires:</i> The type <tt>OutputIter</tt> shall satisfy the requirements for
an Output Iterator (24.2.3).</del>
</p>

<p>
2 <i>Effects:</i> <del>Copies the character sequence
<tt>[fmt.begin(),fmt.end())</tt> to <tt>OutputIter out</tt>. Replaces each
format specifier or escape sequence in <tt>fmt</tt> with either the character(s)
it represents or the sequence of characters within <tt>*this</tt> to which it
refers. The bitmasks specified in <tt>flags</tt> determines what format
specifiers and escape sequences are recognized</del> <ins>Equivalent to
<tt>return format(out, fmt.data(), fmt.data() + fmt.size(), flags)</tt></ins>.
</p>

<p>
<del>3 <i>Returns:</i> <tt>out</tt>.</del>
</p>
</blockquote>
</blockquote>
</li>

<li>
<p>
Change 28.10.5 [re.results.form], before p. 4 until p. 4 as indicated:
</p>

<blockquote><pre><ins>template &lt;class ST, class SA&gt;</ins>
  <del>string_type</del><ins>basic_string&lt;char_type, ST, SA&gt;</ins>
  format(const <del>string_type</del><ins>basic_string&lt;char_type, ST, SA&gt;</ins>&amp; fmt,
         regex_constants::match_flag_type flags =
           regex_constants::format_default) const;
</pre>

<blockquote>
<p>
<i>Effects:</i> <del>Returns a copy of the string <tt>fmt</tt>. Replaces each format
specifier or escape sequence
in <tt>fmt</tt> with either the character(s) it represents or the sequence of
characters within <tt>*this</tt> to which
it refers. The bitmasks specified in flags determines what format
specifiers and escape sequences are
recognized.</del> <ins>Constructs an empty string <tt>result</tt> of type
<tt>basic_string&lt;char_type, ST, SA&gt;</tt>,
and calls <tt>format(back_inserter(result), fmt, flags)</tt>.</ins>
</p>

<p>
<ins><i>Returns:</i> <tt>result</tt></ins>
</p>
</blockquote>
</blockquote>
</li>

<li>
<p>
At the end of 28.10.5 [re.results.form] insert as indicated:
</p>

<blockquote><pre><ins>
string_type
  format(const char_type* fmt,
         regex_constants::match_flag_type flags =
           regex_constants::format_default) const;
</ins></pre>

<blockquote>
<p>
<ins><i>Effects:</i> Constructs an empty string <tt>result</tt> of type <tt>string_type</tt>, and calls
<tt>format(back_inserter(result), fmt, fmt +
char_traits&lt;char_type&gt;::length(fmt), flags)</tt>.</ins>
</p>
<p>
<ins><i>Returns:</i> <tt>result</tt></ins>
</p>
</blockquote>
</blockquote>

</li>

<li>
<p>
Change 28.11.4 [re.alg.replace] before p. 1 as indicated:
</p>

<blockquote><pre>template &lt;class OutputIterator, class BidirectionalIterator,
          class traits, class charT<ins>, class ST, class SA</ins>&gt;
  OutputIterator
  regex_replace(OutputIterator out,
                BidirectionalIterator first, BidirectionalIterator last,
                const basic_regex&lt;charT, traits&gt;&amp; e,
                const basic_string&lt;charT<ins>, ST, SA</ins>&gt;&amp; fmt,
                regex_constants::match_flag_type flags =
                  regex_constants::match_default);

<ins>
template &lt;class OutputIterator, class BidirectionalIterator,
          class traits, class charT&gt;
  OutputIterator
  regex_replace(OutputIterator out,
                BidirectionalIterator first, BidirectionalIterator last,
                const basic_regex&lt;charT, traits&gt;&amp; e,
                const charT* fmt,
                regex_constants::match_flag_type flags =
                  regex_constants::match_default);
</ins></pre>

<blockquote>
<i>Effects:</i> [..]. If any matches are found then, for each such match, if <tt>!(flags &amp;
 regex_constants::format_no_copy)</tt> calls <tt>std::copy(m.prefix().first,
m.prefix().second,
 out)</tt>, and then calls <tt>m.format(out, fmt, flags)</tt> <ins>for the first
form of the function
 and <tt>m.format(out, fmt, fmt + char_traits&lt;charT&gt;::length(fmt), flags)</tt>
for the second
 form</ins>. [..].
</blockquote>
</blockquote>
</li>

<li>
<p>
Change 28.11.4 [re.alg.replace] before p. 3 as indicated:
</p>

<blockquote><pre>template &lt;class traits, class charT<ins>, class ST, class SA,
          class FST, class FSA</ins>&gt;
  basic_string&lt;charT<ins>, ST, SA</ins>&gt;
  regex_replace(const basic_string&lt;charT<ins>, ST, SA</ins>&gt;&amp; s,
                const basic_regex&lt;charT, traits&gt;&amp; e,
                const basic_string&lt;charT<ins>, FST, FSA</ins>&gt;&amp; fmt,
                regex_constants::match_flag_type flags =
                  regex_constants::match_default);

<ins>
template &lt;class traits, class charT, class ST, class SA&gt;
  basic_string&lt;charT, ST, SA&gt;
  regex_replace(const basic_string&lt;charT, ST, SA&gt;&amp; s,
                const basic_regex&lt;charT, traits&gt;&amp; e,
                const charT* fmt,
                regex_constants::match_flag_type flags =
                  regex_constants::match_default);
</ins></pre>

<blockquote>
<i>Effects:</i> Constructs an empty string <tt>result</tt> of type <tt>basic_string&lt;charT<ins>,
ST, SA</ins>&gt;</tt>, calls <tt>regex_replace(back_inserter(result), s.begin(), s.end(),
e, fmt, flags)</tt>, and then returns <tt>result</tt>.
</blockquote>
</blockquote>
</li>

<li>
<p>
At the end of 28.11.4 [re.alg.replace] add the following new prototype description:
</p>

<blockquote><pre><ins>
template &lt;class traits, class charT, class ST, class SA&gt;
  basic_string&lt;charT&gt;
  regex_replace(const charT* s,
                const basic_regex&lt;charT, traits&gt;&amp; e,
                const basic_string&lt;charT, ST, SA&gt;&amp; fmt,
                regex_constants::match_flag_type flags =
                  regex_constants::match_default);
</ins>

<ins>
template &lt;class traits, class charT&gt;
  basic_string&lt;charT&gt;
  regex_replace(const charT* s,
                const basic_regex&lt;charT, traits&gt;&amp; e,
                const charT* fmt,
                regex_constants::match_flag_type flags =
                  regex_constants::match_default);
</ins></pre>

<blockquote>
<ins>
<i>Effects:</i> Constructs an empty string <tt>result</tt> of type <tt>basic_string&lt;charT&gt;</tt>,
calls <tt>regex_replace(back_inserter(result), s, s +
char_traits&lt;charT&gt;::length(s),
e, fmt, flags)</tt>, and then returns <tt>result</tt>.
</ins>
</blockquote>
</blockquote>
</li>

</ol>







<hr>
<h3><a name="728"></a>728. Problem in [rand.eng.mers]/6</h3>
<p><b>Section:</b> 26.5.3.2 [rand.eng.mers] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Stephan Tolksdorf <b>Opened:</b> 2007-09-21 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.eng.mers">issues</a> in [rand.eng.mers].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <tt>mersenne_twister_engine</tt> is required to use a seeding method that is given 
as an algorithm parameterized over the number of bits <tt>W</tt>. I doubt whether the given generalization 
of an algorithm that was originally developed only for unsigned 32-bit integers is appropriate 
for other bit widths. For instance, <tt>W</tt> could be theoretically 16 and <tt>UIntType</tt> a 16-bit integer, in 
which case the given multiplier would not fit into the <tt>UIntType</tt>. Moreover, T. Nishimura and M. 
Matsumoto have chosen a dif ferent multiplier for their 64 bit Mersenne Twister
[<a href="http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/VERSIONS/C-LANG/mt19937-64.c">reference</a>].
</p>

<p>
I see two possible resolutions: 
</p>

<ol type="a">
<li>Restrict the parameter <tt>W</tt> of the <tt>mersenne_twister_template</tt> to values of 32 or 64 and use the 
multiplier from [the above reference] for the 64-bit case (my preference)</li>
<li>Interpret the state array for any <tt>W</tt> as a 32-bit array of appropriate length (and a specified byte 
order) and always employ the 32-bit algorithm for seeding
</li>
</ol>

<p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2424.pdf">N2424</a>
for further discussion.
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
<p>
Stephan Tolksdorf has additional comments on N2424. He comments: "there
is a typo in the required behaviour for mt19937_64: It should be the
10000th (not 100000th) invocation whose value is given, and the value
should be 9981545732273789042 (not 14002232017267485025)." These values
need checking.
</p>
<p>
Take the proposed recommendation in N2424 and move to REVIEW.
</p>
</blockquote>




<p><b>Proposed resolution:</b></p>

<p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2424.pdf">N2424</a>
for the proposed resolution.
</p>

<p><i>[
Stephan Tolksdorf adds pre-Bellevue:
]</i></p>


<blockquote>
I support the proposed resolution in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2424.pdf">N2424</a>,
but there is a typo in the
required behaviour for <tt>mt19937_64</tt>: It should be the 10000<sup>th</sup> (not
100000<sup>th</sup>) invocation whose value is given, and the value should be
9981545732273789042 (not 14002232017267485025). The change to para. 8
proposed by Charles Karney should also be included in the proposed
wording.
</blockquote>

<p><i>[
Sophia Antipolis:
]</i></p>


<blockquote>
Note the main part of the issue is resolved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2424.pdf">N2424</a>.
</blockquote>






<hr>
<h3><a name="734"></a>734. Unnecessary restriction in [rand.dist.norm.chisq]</h3>
<p><b>Section:</b> 26.5.8.4.3 [rand.dist.norm.chisq] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Stephan Tolksdorf <b>Opened:</b> 2007-09-21 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>chi_squared_distribution</tt>, <tt>fisher_f_distribution</tt> and <tt>student_t_distribution</tt>
have parameters for the "degrees of freedom" <tt>n</tt> and <tt>m</tt> that are specified as integers. For the 
following two reasons this is an unnecessary restriction: First, in many applications such as 
Bayesian inference or Monte Carlo simulations it is more convenient to treat the respective param- 
eters as continuous variables. Second, the standard non-naive algorithms (i.e. 
O(1) algorithms) 
for simulating from these distributions work with floating-point parameters anyway (all three 
distributions could be easily implemented using the Gamma distribution, for instance).
</p>

<p>
Similar arguments could in principle be made for the parameters <tt>t</tt> and <tt>k</tt> of the discrete 
<tt>binomial_distribution</tt> and <tt>negative_binomial_distribution</tt>, though in both cases continuous
parameters are less frequently used in practice and in case of the <tt>binomial_distribution</tt>
the implementation would be significantly complicated by a non-discrete parameter (in most 
implementations one would need an approximation of the log-gamma function instead of just the 
log-factorial function).
</p>

<p>
<b>Possible resolution:</b> For these reasons, I propose to change the type of the respective parameters 
to double.
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
In N2424. Not wildly enthusiastic, not really felt necessary. Less
frequently used in practice. Not terribly bad either. Move to OPEN.
</blockquote>

<p><i>[
Sophia Antipolis:
]</i></p>


<blockquote>
<p>
Marc Paterno: The generalizations were explicitly left out when designing the facility. It's harder to test.
</p>
<p>
Marc Paterno: Ask implementers whether floating-point is a significant burden.
</p>
<p>
Alisdair: It's neater to do it now, do ask Bill Plauger.
</p>
<p>
Disposition: move to review with the option for "NAD" if it's not straightforward to implement; unanimous consent.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2424.pdf">N2424</a>
for the proposed resolution.
</p>

<p><i>[
Stephan Tolksdorf adds pre-Bellevue:
]</i></p>


<blockquote>
<p>
In 26.5.8.4.3 [rand.dist.norm.chisq]:
</p>

<blockquote>
<p>
Delete ", where <tt>n</tt> is a positive integer" in the first paragraph.
</p>

<p>
Replace both occurrences of "<tt>explicit chi_squared_distribution(int n = 1);</tt>"
with "<tt>explicit chi_squared_distribution(RealType n = 1);</tt>".
</p>

<p>
Replace both occurrences of "<tt>int n() const;</tt>" with "<tt>RealType n() const;</tt>".
</p>

</blockquote>

<p>
In 26.5.8.4.5 [rand.dist.norm.f]:
</p>
<blockquote>
<p>
Delete ", where <tt>m</tt> and <tt>n</tt> are positive integers" in the first paragraph.
</p>

<p>
Replace both occurrences of
</p>
<blockquote><pre>explicit fisher_f_distribution(int m = 1, int n = 1);
</pre></blockquote>
<p>
with
</p>
<blockquote><pre>explicit fisher_f_distribution(RealType m = 1, RealType n = 1);
</pre></blockquote>

<p>
Replace both occurrences of "<tt>int m() const;" with "RealType m() const;</tt>".
</p>

<p>
Replace both occurrences of "<tt>int n() const;" with "RealType n() const;</tt>".
</p>
</blockquote>

<p>
In 26.5.8.4.6 [rand.dist.norm.t]:
</p>

<blockquote>
<p>
Delete ", where <tt>n</tt> is a positive integer" in the first paragraph.
</p>

<p>
Replace both occurrences of "<tt>explicit student_t_distribution(int n = 1);</tt>"
with "<tt>explicit student_t_distribution(RealType n = 1);</tt>".
</p>

<p>
Replace both occurrences of "<tt>int n() const;</tt>" with "<tt>RealType n() const;</tt>".
</p>
</blockquote>

</blockquote>





<hr>
<h3><a name="740"></a>740. Please remove <tt>*_ptr&lt;T[N]&gt;</tt></h3>
<p><b>Section:</b> X [unique.ptr.compiletime] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Herb Sutter <b>Opened:</b> 2007-10-04 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Please don't provide <tt>*_ptr&lt;T[N]&gt;</tt>. It doesn't enable any useful
bounds-checking (e.g., you could imagine that doing <tt>op++</tt> on a
<tt>shared_ptr&lt;T[N]&gt;</tt> yields a <tt>shared_ptr&lt;T[N-1]&gt;</tt>, but that promising path
immediately falters on <tt>op--</tt> which can't reliably dereference because we
don't know the lower bound). Also, most buffers you'd want to point to
don't have a compile-time known size.
</p>

<p>
To enable any bounds-checking would require run-time information, with
the usual triplet: base (lower bound), current offset, and max offset
(upper  bound). And I can sympathize with the point of view that you
wouldn't want to require this on <tt>*_ptr</tt> itself. But please let's not
follow the <tt>&lt;T[N]&gt;</tt> path, especially not with additional functions to
query the bounds etc., because this sets wrong user expectations by
embarking on a path that doesn't go all the way to bounds checking as it
seems to imply.
</p>

<p>
If bounds checking is desired, consider a <tt>checked_*_ptr</tt> instead (e.g.,
<tt>checked_shared_ptr</tt>). And make the interfaces otherwise identical so that
user code could easily <tt>#define/typedef</tt> between prepending <tt>checked_</tt> on
debug builds and not doing so on release builds (for example).
</p>

<p>
Note that some may object that <tt>checked_*_ptr</tt> may seem to make the smart
pointer more like <tt>vector</tt>, and we don't want two ways to spell <tt>vector</tt>. I
don't agree, but if that were true that would be another reason to
remove <tt>*_ptr&lt;T[N]&gt;</tt> which equally makes the smart pointer more like
<tt>std::array.</tt> :-)
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
<p>
Suggestion that fixed-size array instantiations are going to fail at compile time anyway (if we remove specialization) due to pointer decay, at least that appears to be result from available compilers.
</p>
<p>
So concerns about about requiring static_assert seem unfounded.
</p>
<p>
After a little more experimentation with compiler, it appears that fixed size arrays would only work at all if we supply these explicit specialization. So removing them appears less breaking than originally thought.
</p>
<p>
straw poll unanimous move to Ready.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change the synopsis under 20.9.9 [unique.ptr] p2:
</p>

<blockquote><pre>...
template&lt;class T&gt; struct default_delete; 
template&lt;class T&gt; struct default_delete&lt;T[]&gt;; 
<del>template&lt;class T, size_t N&gt; struct default_delete&lt;T[N]&gt;;</del>

template&lt;class T, class D = default_delete&lt;T&gt;&gt; class unique_ptr; 
template&lt;class T, class D&gt; class unique_ptr&lt;T[], D&gt;; 
<del>template&lt;class T, class D, size_t N&gt; class unique_ptr&lt;T[N], D&gt;;</del>
...
</pre></blockquote>

<p>
Remove the entire section  [unique.ptr.dltr.dflt2] <b><tt>default_delete&lt;T[N]&gt;</tt></b>.
</p>

<p>
Remove the entire section X [unique.ptr.compiletime] <b><tt>unique_ptr</tt> for array objects with a compile time length</b>
and its subsections:  [unique.ptr.compiletime.dtor],  [unique.ptr.compiletime.observers],
 [unique.ptr.compiletime.modifiers].
</p>






<hr>
<h3><a name="742"></a>742. Enabling <tt>swap</tt> for proxy iterators</h3>
<p><b>Section:</b> 20.2.1 [utility.arg.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2007-10-10 <b>Last modified:</b> 2010-11-20</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#utility.arg.requirements">issues</a> in [utility.arg.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p>
This issue was split from <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#672">672</a>. <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#672">672</a> now just
deals with changing the requirements of <tt>T</tt> in the <tt>Swappable</tt>
requirement from <tt>CopyConstructible</tt> and <tt>CopyAssignable</tt> to
<tt>MoveConstructible</tt> and <tt>MoveAssignable</tt>.
</p>

<p>
This issue seeks to widen the <tt>Swappable</tt> requirement to support proxy iterators.  Here
is example code:
</p>

<blockquote><pre>namespace Mine {

template &lt;class T&gt;
struct proxy {...};

template &lt;class T&gt;
struct proxied_iterator
{
   typedef T value_type;
   typedef proxy&lt;T&gt; reference;
   reference operator*() const;
   ...
};

struct A
{
   // heavy type, has an optimized swap, maybe isn't even copyable or movable, just swappable
   void swap(A&amp;);
   ...
};

void swap(A&amp;, A&amp;);
void swap(proxy&lt;A&gt;, A&amp;);
void swap(A&amp;, proxy&lt;A&gt;);
void swap(proxy&lt;A&gt;, proxy&lt;A&gt;);

}  // Mine

...

Mine::proxied_iterator&lt;Mine::A&gt; i(...)
Mine::A a;
<b>swap(*i1, a);</b>
</pre></blockquote>

<p>
The key point to note in the above code is that in the call to <tt>swap</tt>, <tt>*i1</tt>
and <tt>a</tt> are different types (currently types can only be <tt>Swappable</tt> with the
same type).  A secondary point is that to support proxies, one must be able to pass rvalues
to <tt>swap</tt>.  But note that I am not stating that the general purpose <tt>std::swap</tt>
should accept rvalues!  Only that overloaded <tt>swap</tt>s, as in the example above, be allowed
to take rvalues.
</p>

<p>
That is, no standard library code needs to change.  We simply need to have a more flexible
definition of <tt>Swappable</tt>.
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
<p>
While we believe Concepts work will define a swappable concept, we
should still resolve this issue if possible to give guidance to the
Concepts work.
</p>
<p>
Would an ambiguous swap function in two namespaces found by ADL break
this wording? Suggest that the phrase "valid expression" means such a
pair of types would still not be swappable.
</p>
<p>
Motivation is proxy-iterators, but facility is considerably more
general. Are we happy going so far?
</p>
<p>
We think this wording is probably correct and probably an improvement on
what's there in the WP. On the other hand, what's already there in the
WP is awfully complicated. Why do we need the two bullet points? They're
too implementation-centric. They don't add anything to the semantics of
what swap() means, which is there in the post-condition. What's wrong
with saying that types are swappable if you can call swap() and it
satisfies the semantics of swapping?
</p>
</blockquote>

<p><i>[
2009-07-28 Reopened by Alisdair.  No longer solved by concepts.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Leave as Open. Dave to provide wording.
</blockquote>

<p><i>[
2009-11-08 Howard adds:
]</i></p>


<blockquote>
Updated wording to sync with
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n3000.pdf">N3000</a>.
Also this issue is very closely related to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#594">594</a>.
</blockquote>

<p><i>[
2010 Pittsburgh:
]</i></p>


<blockquote>
Moved to <del>NAD Editorial</del><ins>Resolved</ins>.  Rationale added.
</blockquote>



<p><b>Rationale:</b></p>
<p>
Solved by N3048.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change 20.2.1 [utility.arg.requirements]:
</p>

<blockquote>

<p>
-1- The template definitions in the C++ Standard Library refer to various
named requirements whose details are set out in tables 31-38. In these
tables, <tt>T</tt> <ins>and <tt>V</tt> are</ins> <del>is a</del> type<ins>s</ins> to be supplied by a C++ program
instantiating a template; <tt>a</tt>, <tt>b</tt>, and <tt>c</tt> are
values of type <tt>const T</tt>; <tt>s</tt> and <tt>t</tt> are modifiable
lvalues of type <tt>T</tt>; <tt>u</tt> is a value of type (possibly
<tt>const</tt>) <tt>T</tt>; <del>and</del> <tt>rv</tt> is a non-<tt>const</tt>
rvalue of type <tt>T</tt><ins>; <tt>w</tt> is a value of type <tt>T</tt>; and <tt>v</tt> is a value of type <tt>V</tt></ins>.
</p>

<table border="1">
<caption>Table 37: <tt>Swappable</tt> requirements <b>[swappable]</b></caption>
<tbody><tr><th>expression</th><th>Return type</th><th>Post-condition</th></tr>
<tr><td><tt>swap(<del>s</del><ins>w</ins>,<del>t</del><ins>v</ins>)</tt></td><td><tt>void</tt></td>
<td><del><tt>t</tt></del><ins><tt>w</tt></ins> has the value originally
held by <del><tt>u</tt></del><ins><tt>v</tt></ins>, and
<del><tt>u</tt></del><ins><tt>v</tt></ins> has the value originally held
by <del><tt>t</tt></del><ins><tt>w</tt></ins></td></tr>
<tr><td colspan="3">
<p>
The <tt>Swappable</tt> requirement is met by satisfying one or more of the following conditions:
</p>
<ul>
<li>
<tt>T</tt> is <tt>Swappable</tt> if <ins><tt>T</tt> and <tt>V</tt> are
the same type and </ins> <tt>T</tt> satisfies the
<tt>MoveConstructible</tt> requirements (Table 
33) and the 
<tt>MoveAssignable</tt> requirements (Table 
35);
</li>
<li>
<tt>T</tt> is <tt>Swappable</tt> <ins>with <tt>V</tt></ins> if a namespace scope function named
<tt>swap</tt> exists in the same namespace as the definition of
<tt>T</tt> <ins>or <tt>V</tt></ins>, such that the expression
<tt>swap(<del>s</del><ins>w</ins>,<del>t</del> <ins>v</ins>)</tt> is valid and has the
semantics described in this table.
</li>
<li>
<tt>T</tt> is <tt>Swappable</tt> if <tt>T</tt> is an array type whose
element type is <tt>Swappable</tt>.
</li>
</ul>
</td></tr>
</tbody></table>
</blockquote>



<p><b>Rationale:</b></p>
<p><i>[
post San Francisco:
]</i></p>


<blockquote>
Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2758.pdf">N2758</a>.
</blockquote>






<hr>
<h3><a name="743"></a>743. rvalue <tt>swap</tt> for <tt>shared_ptr</tt></h3>
<p><b>Section:</b> 20.9.10.2.9 [util.smartptr.shared.spec] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2007-10-10 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
When the LWG looked at <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#674">674</a> in Kona the following note was made:
</p>

<blockquote><p>
We may need to open an issue to deal with the question of
whether <tt>shared_ptr</tt> needs an rvalue <tt>swap</tt>.
</p></blockquote>

<p>
This issue was opened in response to that note.
</p>

<p>
I believe allowing rvalue <tt>shared_ptr</tt>s to <tt>swap</tt> is both
appropriate, and consistent with how other library components are currently specified.
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
<p>
Concern that the three signatures for swap is needlessly complicated,
but this issue merely brings shared_ptr into equal complexity with the
rest of the library. Will open a new issue for concern about triplicate
signatures.
</p>
<p>
Adopt issue as written.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change the synopsis in 20.9.10.2 [util.smartptr.shared]:
</p>

<blockquote><pre>void swap(shared_ptr&amp;<ins>&amp;</ins> r);
...
template&lt;class T&gt; void swap(shared_ptr&lt;T&gt;&amp; a, shared_ptr&lt;T&gt;&amp; b);
<ins>template&lt;class T&gt; void swap(shared_ptr&lt;T&gt;&amp;&amp; a, shared_ptr&lt;T&gt;&amp; b);
template&lt;class T&gt; void swap(shared_ptr&lt;T&gt;&amp; a, shared_ptr&lt;T&gt;&amp;&amp; b);</ins>
</pre></blockquote>

<p>
Change 20.9.10.2.4 [util.smartptr.shared.mod]:
</p>

<blockquote><pre>void swap(shared_ptr&amp;<ins>&amp;</ins> r);
</pre></blockquote>

<p>
Change 20.9.10.2.9 [util.smartptr.shared.spec]:
</p>

<blockquote><pre>template&lt;class T&gt; void swap(shared_ptr&lt;T&gt;&amp; a, shared_ptr&lt;T&gt;&amp; b);
<ins>template&lt;class T&gt; void swap(shared_ptr&lt;T&gt;&amp;&amp; a, shared_ptr&lt;T&gt;&amp; b);
template&lt;class T&gt; void swap(shared_ptr&lt;T&gt;&amp; a, shared_ptr&lt;T&gt;&amp;&amp; b);</ins>
</pre></blockquote>





<hr>
<h3><a name="744"></a>744. What is the lifetime of an exception pointed to by an exception_ptr?</h3>
<p><b>Section:</b> 18.8.5 [propagation] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2007-10-10 <b>Last modified:</b> 2010-10-29</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#propagation">active issues</a> in [propagation].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#propagation">issues</a> in [propagation].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Without some lifetime guarantee, it is hard to know how this type can be
used.  Very specifically, I don't see how the current wording would
guarantee and exception_ptr caught at the end of one thread could be safely
stored and rethrown in another thread - the original motivation for this
API.
</p>
<p>
(Peter Dimov agreed it should be clearer, maybe a non-normative note to
explain?)
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
<p>
Agree the issue is real.
</p>
<p>
Intent is lifetime is similar to a shared_ptr (and we might even want to
consider explicitly saying that it is a shared_ptr&lt; unspecified type &gt;).
</p>
<p>
We expect that most implementations will use shared_ptr, and the
standard should be clear that the exception_ptr type is intended to be
something whose semantics are smart-pointer-like so that the user does
not need to worry about lifetime management. We still need someone to
draught those words - suggest emailing Peter Dimov.
</p>
<p>
Move to Open.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 18.8.5 [propagation]/7:
</p>

<blockquote>
-7- Returns: An <tt>exception_ptr</tt> object that refers to the currently
handled exception or a copy of the currently handled exception, or a
null <tt>exception_ptr</tt> object if no exception is being handled.
<ins>The referenced object remains valid at least as long as there is an
<tt>exception_ptr</tt> that refers to it.</ins>
If the function needs to allocate memory and the attempt
fails, it returns an <tt>exception_ptr</tt> object that refers to an instance of
<tt>bad_alloc</tt>. It is unspecified whether the return values of two successive
calls to <tt>current_exception</tt> refer to the same exception object. [<i>Note:</i>
that is, it is unspecified whether <tt>current_exception</tt> creates a new copy
each time it is called. <i>--end note</i>]
</blockquote>





<hr>
<h3><a name="746"></a>746. current_exception may fail with bad_alloc</h3>
<p><b>Section:</b> 18.8.5 [propagation] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2007-10-10 <b>Last modified:</b> 2010-10-29</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#propagation">active issues</a> in [propagation].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#propagation">issues</a> in [propagation].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I understand that the attempt to copy an exception may run out of memory,
but I believe this is the only part of the standard that mandates failure
with specifically <tt>bad_alloc</tt>, as opposed to allowing an
implementation-defined type derived from <tt>bad_alloc</tt>.  For instance, the Core
language for a failed new expression is:
</p>
<blockquote>
<p>
Any other allocation function that fails to allocate storage shall indicate
failure only by throwing an exception of a type that would match a handler
(15.3) of type <tt>std::bad_alloc</tt> (18.5.2.1).
</p>
</blockquote>
<p>
I think we should allow similar freedom here (or add a blanket
compatible-exception freedom paragraph in 17)
</p>
<p>
I prefer the clause 17 approach myself, and maybe clean up any outstanding
wording that could also rely on it.
</p>
<p>
Although filed against a specific case, this issue is a problem throughout
the library. 
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
<p>
Is issue bigger than library?
</p>
<p>
No - Core are already very clear about their wording, which is inspiration for the issue.
</p>
<p>
While not sold on the original 18.7.5 use case, the generalised 17.4.4.8 wording is the real issue.
</p>
<p>
Accept the broad view and move to ready
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Add the following exemption clause to 17.6.4.12 [res.on.exception.handling]:
</p>

<blockquote>
A function may throw a type not listed in its <i>Throws</i> clause so long as it is
derived from a class named in the <i>Throws</i> clause, and would be caught by an
exception handler for the base type.
</blockquote>





<hr>
<h3><a name="749"></a>749. Currently <tt>has_nothrow_copy_constructor&lt;T&gt;::value</tt> is true if T has 'a' nothrow copy constructor.</h3>
<p><b>Section:</b> 20.7.4.3 [meta.unary.prop] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2007-10-10 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#meta.unary.prop">issues</a> in [meta.unary.prop].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Unfortunately a class can have multiple copy constructors, and I believe to
be useful this trait should only return true is ALL copy constructors are
no-throw.
</p>
<p>
For instance:
</p>
<blockquote>
<pre>struct awkward {
 awkward( const awkward &amp; ) throw() {}
 awkward( awkward &amp; ) { throw "oops"; } };
</pre>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 20.7.4.3 [meta.unary.prop]:
</p>

<blockquote>
<pre>has_trivial_copy_constructor</pre>
<blockquote>
<tt>T</tt> is a trivial type (3.9) or a reference type or a class type <del>with a trivial copy constructor</del>
<ins>where all copy constructors are trivial</ins> (12.8).
</blockquote>
</blockquote>

<blockquote>
<pre>has_trivial_assign</pre>
<blockquote>
<tt>T</tt> is neither <tt>const</tt> nor a reference type, and <tt>T</tt> is a trivial type (3.9)
or a class type <del>with a trivial copy assignment operator</del> <ins>where all copy assignment operators are trivial</ins> (12.8).
</blockquote>
</blockquote>

<blockquote>
<pre>has_nothrow_copy_constructor</pre>
<blockquote>
<tt>has_trivial_copy_constructor&lt;T&gt;::value</tt> is <tt>true</tt> or <tt>T</tt> is a class type <del>with
a</del> <ins>where all</ins> copy constructor<ins>s</ins> <del>that is</del> <ins>are</ins> 
known not to throw any exceptions or <tt>T</tt> is an
array of such a class type
</blockquote>
</blockquote>

<blockquote>
<pre>has_nothrow_assign</pre>
<blockquote>
<tt>T</tt> is neither <tt>const</tt> nor a reference type, and
<tt>has_trivial_assign&lt;T&gt;::value</tt> is <tt>true</tt> or <tt>T</tt> is a class type <del>with a</del>
<ins>where all</ins> copy
assignment operator<ins>s</ins> tak<ins>e</ins><del>ing</del> an lvalue of type <tt>T</tt> that is known not to
throw any exceptions or <tt>T</tt> is an array of such a class type.
</blockquote>
</blockquote>






<hr>
<h3><a name="752"></a>752. Allocator complexity requirement</h3>
<p><b>Section:</b> 20.2.5 [allocator.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Hans Boehm <b>Opened:</b> 2007-10-11 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#allocator.requirements">issues</a> in [allocator.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Did LWG recently discuss 20.2.5 [allocator.requirements]-2, which states that "All the operations
on the allocators are expected to be amortized constant time."?
</p>
<p>
As I think I pointed out earlier, this is currently fiction for
<tt>allocate()</tt> if it has to obtain memory from the OS, and it's unclear to
me how to interpret this for <tt>construct()</tt> and <tt>destroy()</tt> if they deal with
large objects.  Would it be controversial to officially let these take
time linear in the size of the object, as they already do in real life?
</p>
<p>
<tt>Allocate()</tt> more blatantly takes time proportional to the size of the
object if you mix in GC.  But it's not really a new problem, and I think
we'd be confusing things by leaving the bogus requirements there.  The
current requirement on <tt>allocate()</tt> is generally not important anyway,
since it takes O(size) to construct objects in the resulting space.
There are real performance issues here, but they're all concerned with
the constants, not the asymptotic complexity.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change 20.2.5 [allocator.requirements]/2:
</p>

<blockquote>
<p>
-2- Table 39 describes the requirements on types manipulated through
allocators. <del>All the operations on the allocators are expected to be
amortized constant time.</del> Table 40 describes the
requirements on allocator types.
</p>
</blockquote>





<hr>
<h3><a name="753"></a>753. Move constructor in draft</h3>
<p><b>Section:</b> 20.2.1 [utility.arg.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Yechezkel Mett <b>Opened:</b> 2007-10-14 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#utility.arg.requirements">issues</a> in [utility.arg.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The draft standard n2369 uses the term <i>move constructor</i> in a few
places, but doesn't seem to define it.
</p>

<p>
<tt>MoveConstructible</tt> requirements are defined in Table 33 in 20.2.1 [utility.arg.requirements] as
follows:
</p>

<blockquote>
<table border="1">
<caption><tt>MoveConstructible</tt> requirements</caption>
<tbody><tr>
<th>expression</th> <th>post-condition</th>
</tr>
<tr>
<td><tt>T t = rv</tt></td> <td><tt>t</tt> is equivalent to the value of <tt>rv</tt> before the construction</td>
</tr>
<tr>
<td colspan="2">[<i>Note:</i> There is no requirement on the value of <tt>rv</tt> after the 
construction. <i>-- end note</i>]</td>
</tr>
</tbody></table>
</blockquote>

<p>
(where <tt>rv</tt> is a non-const rvalue of type <tt>T</tt>).
</p>

<p>
So I assume the move constructor is the constructor that would be used
in filling the above requirement.
</p>

<p>
For <tt>vector::reserve</tt>, <tt>vector::resize</tt> and the <tt>vector</tt> modifiers given in
23.4.1.4 [vector.modifiers] we have
</p>

<blockquote>
<i>Requires:</i> If <tt>value_type</tt> has a move constructor, that constructor shall
not throw any exceptions.
</blockquote>

<p>
Firstly "If <tt>value_type</tt> has a move constructor" is superfluous; every
type which can be put into a <tt>vector</tt> has a move constructor (a copy
constructor is also a move constructor). Secondly it means that for
any <tt>value_type</tt> which has a throwing copy constructor and no other move
constructor these functions cannot be used -- which I think will come
as a shock to people who have been using such types in <tt>vector</tt> until
now!
</p>

<p>
I can see two ways to correct this. The simpler, which is presumably
what was intended, is to say "If <tt>value_type</tt> has a move constructor and
no copy constructor, the move constructor shall not throw any
exceptions" or "If <tt>value_type</tt> has a move constructor which changes the
value of its parameter,".
</p>

<p>
The other alternative is add to <tt>MoveConstructible</tt> the requirement that
the expression does not throw. This would mean that not every type
that satisfies the <tt>CopyConstructible</tt> requirements also satisfies the
<tt>MoveConstructible</tt> requirements. It would mean changing requirements in
various places in the draft to allow either <tt>MoveConstructible</tt> or
<tt>CopyConstructible</tt>, but I think the result would be clearer and
possibly more concise too.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add new defintions to 17.3 [definitions]:
</p>

<blockquote>
<p>
<b>move constructor</b>
</p>
<p>
a constructor which accepts only rvalue arguments of that type, and modifies the rvalue as a
side effect during the construction.
</p>
<p>
<b>move assignment operator</b>
</p>
<p>
an assignment operator which accepts only rvalue arguments of that type, and modifies the rvalue as a
side effect during the assignment.
</p>
<p>
<b>move assignment</b>
</p>
<p>
use of the move assignment operator.
</p>
</blockquote>

<p><i>[
Howard adds post-Bellevue:
]</i></p>


<blockquote>
<p>
Unfortunately I believe the wording recommended by the LWG in Bellevue is incorrect.  <tt>reserve</tt> et. al. will use a move constructor
if one is available, else it will use a copy constructor.  A type may have both.  If the move constructor is
used, it must not throw.  If the copy constructor is used, it can throw.  The sentence in the proposed wording
is correct without the recommended insertion.  The Bellevue LWG recommended moving this issue to Ready.  I am
unfortunately pulling it back to Open.  But I'm drafting wording to atone for this egregious action. :-)
</p>
</blockquote>






<hr>
<h3><a name="755"></a>755. <tt>std::vector</tt> and <tt>std:string</tt> lack explicit shrink-to-fit operations</h3>
<p><b>Section:</b> 23.4.1.2 [vector.capacity], 21.4.4 [string.capacity] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Beman Dawes <b>Opened:</b> 2007-10-31 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#vector.capacity">issues</a> in [vector.capacity].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
A <tt>std::vector</tt> can be shrunk-to-fit via the swap idiom:
</p>

<blockquote><pre>vector&lt;int&gt; v;
...
v.swap(vector&lt;int&gt;(v));  // shrink to fit
</pre>
<blockquote><p>
or:
</p></blockquote>
<pre>vector&lt;int&gt;(v).swap(v);  // shrink to fit
</pre>
<blockquote><p>
or:
</p></blockquote>
<pre>swap(v, vector&lt;int&gt;(v));  // shrink to fit
</pre>
</blockquote>

<p>
A non-binding request for shrink-to-fit can be made to a <tt>std::string</tt> via:
</p>

<blockquote><pre>string s;
...
s.reserve(0);
</pre></blockquote>

<p>
Neither of these is at all obvious to beginners, and even some
experienced C++ programmers are not aware that shrink-to-fit is
trivially available.
</p>
<p>
Lack of explicit functions to perform these commonly requested
operations makes vector and string less usable for non-experts. Because
the idioms are somewhat obscure, code readability is impaired. It is
also unfortunate that two similar vector-like containers use different
syntax for the same operation.
</p>
<p>
The proposed resolution addresses these concerns. The proposed function
takes no arguments to keep the solution simple and focused.
</p>


<p><b>Proposed resolution:</b></p>
<p>
To Class template basic_string 21.4 [basic.string] synopsis,
Class template vector 23.4.1 [vector] synopsis, and Class
vector&lt;bool&gt; 23.4.2 [vector.bool] synopsis, add:
</p>

<blockquote><pre>    
void shrink_to_fit();
</pre></blockquote>

<p>
To basic_string capacity 21.4.4 [string.capacity] and vector
capacity 23.4.1.2 [vector.capacity], add:
</p>

<blockquote>
<pre>void shrink_to_fit();
</pre>
<blockquote>
<i>Remarks:</i> <tt>shrink_to_fit</tt> is a non-binding request to reduce
<tt>capacity()</tt> to <tt>size()</tt>. [<i>Note:</i> The request is non-binding to
allow latitude for implementation-specific optimizations.
<i>-- end note</i>]
</blockquote>
</blockquote>

<p><i>[
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#850">850</a> has been added to deal with this issue with respect to <tt>deque</tt>.
]</i></p>






<hr>
<h3><a name="758"></a>758. <tt>shared_ptr</tt> and <tt>nullptr</tt></h3>
<p><b>Section:</b> 20.9.10.2 [util.smartptr.shared] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Joe Gottman <b>Opened:</b> 2007-10-31 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#util.smartptr.shared">issues</a> in [util.smartptr.shared].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Consider the following program:
</p>

<blockquote><pre>int main() {
   shared_ptr&lt;int&gt; p(nullptr); 
   return 0;
}
</pre></blockquote>

<p>
This program will fail to compile because <tt>shared_ptr</tt> uses the following 
template constructor to construct itself from pointers:
</p>

<blockquote><pre>template &lt;class Y&gt; shared_ptr(Y *);
</pre></blockquote>

<p>
According
to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2431.pdf">N2431</a>,
the conversion from <tt>nullptr_t</tt> to <tt>Y *</tt> is not
deducible, so the above constructor will not be found.  There are similar problems with the
constructors that take a pointer and a <tt>deleter</tt> or a
pointer, a <tt>deleter</tt> and an allocator, as well as the
corresponding forms of <tt>reset()</tt>. Note that <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2435.htm">N2435</a>
will solve this problem for constructing from just <tt>nullptr</tt>, but not for constructors that use
<tt>deleters</tt> or allocators or for <tt>reset()</tt>.
</p>

<p>
In the case of the functions that take deleters, there is the additional
question of what argument should be passed to the deleter when it is
eventually called.  There are two reasonable possibilities: <tt>nullptr</tt> or
<tt>static_cast&lt;T *&gt;(0)</tt>, where <tt>T</tt> is the template argument of the
<tt>shared_ptr</tt>.  It is not immediately clear which of these is better.  If
<tt>D::operator()</tt> is a template function similar to <tt>shared_ptr</tt>'s
constructor, then <tt>d(static_cast&lt;T*&gt;(0))</tt> will compile and <tt>d(nullptr)</tt>
will not.  On the other hand, if <tt>D::operator()()</tt> takes a parameter that
is a pointer to some type other that <tt>T</tt> (for instance <tt>U*</tt> where <tt>U</tt> derives
from <tt>T</tt>) then <tt>d(nullptr)</tt> will compile and <tt>d(static_cast&lt;T *&gt;(0))</tt> may not.
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
<p>
The general idea is right, we need to be able to pass a nullptr to a
shared_ptr, but there are a few borderline editorial issues here. (For
example, the single-argument nullptr_t constructor in the class synopsis
isn't marked explicit, but it is marked explicit in the proposed wording
for 20.6.6.2.1. There is a missing empty parenthesis in the form that
takes a nullptr_t, a deleter, and an allocator.)
</p>
<p>
More seriously: this issue says that a shared_ptr constructed from a
nullptr is empty. Since "empty" is undefined, it's hard to know whether
that's right. This issue is pending on handling that term better.
</p>
<p>
Peter suggests definition of empty should be "does not own anything"
</p>
<p>
Is there an editorial issue that post-conditions should refer to get() =
nullptr, rather than get() = 0?
</p>
<p>
No strong feeling towards accept or NAD, but prefer to make a decision than leave it open.
</p>
<p>
Seems there are no technical merits between NAD and Ready, comes down to
"Do we intentially want to allow/disallow null pointers with these
functions". Staw Poll - support null pointers 5 - No null pointers 0
</p>
<p>
Move to Ready, modulo editorial comments
</p>
</blockquote>

<p><i>[
post Bellevue Peter adds:
]</i></p>


<blockquote>
<p>
The following wording changes are less intrusive:
</p>

<p>
In 20.9.10.2.1 [util.smartptr.shared.const], add:
</p>

<blockquote><pre>shared_ptr(nullptr_t);
</pre></blockquote>

<p>
after:
</p>

<blockquote><pre>shared_ptr();
</pre></blockquote>

<p>
(Absence of explicit intentional.)
</p>

<p>
<tt>px.reset( nullptr )</tt> seems a somewhat contrived way to write <tt>px.reset()</tt>, so
I'm not convinced of its utility.
</p>
<p>
It's similarly not clear to me whether the deleter constructors need to be
extended to take <tt>nullptr</tt>, but if they need to:
</p>
<p>
Add
</p>

<blockquote><pre>template&lt;class D&gt; shared_ptr(nullptr_t p, D d);
template&lt;class D, class A&gt; shared_ptr(nullptr_t p, D d, A a);
</pre></blockquote>

<p>
after
</p>

<blockquote><pre>template&lt;class Y, class D&gt; shared_ptr(Y* p, D d);
template&lt;class Y, class D, class A&gt; shared_ptr(Y* p, D d, A a);
</pre></blockquote>

<p>
Note that this changes the semantics of the new constructors such that they
consistently call <tt>d(p)</tt> instead of <tt>d((T*)0)</tt> when <tt>p</tt> is <tt>nullptr</tt>.
</p>
<p>
The ability to be able to pass <tt>0/NULL</tt> to a function that takes a <tt>shared_ptr</tt>
has repeatedly been requested by users, but the other additions that the
proposed resolution makes are not supported by real world demand or
motivating examples.
</p>
<p>
It might be useful to split the obvious and non-controversial <tt>nullptr_t</tt>
constructor into a separate issue. Waiting for "empty" to be clarified is
unnecessary; this is effectively an alias for the default constructor.
</p>
</blockquote>

<p><i>[
Sophia Antipolis:
]</i></p>


<blockquote>
<p>
We want to remove the reset functions from the proposed resolution.
</p>
<p>
The remaining proposed resolution text (addressing the constructors) are wanted.
</p>
<p>
Disposition: move to review. The review should check the wording in the then-current working draft.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
In 20.9.10.2 [util.smartptr.shared] p4, add to the definition/synopsis
of <tt>shared_ptr</tt>:
</p>

<blockquote><pre>template&lt;class D&gt; shared_ptr(nullptr_t p, D d);
template&lt;class D, class A&gt; shared_ptr(nullptr_t p, D d, A a);
</pre></blockquote>

<p>
after
</p>

<blockquote><pre>template&lt;class Y, class D&gt; shared_ptr(Y* p, D d);
template&lt;class Y, class D, class A&gt; shared_ptr(Y* p, D d, A a);
</pre></blockquote>

<p>
In 20.9.10.2.1 [util.smartptr.shared.const] add:
</p>

<blockquote><pre>template&lt;class D&gt; shared_ptr(nullptr_t p, D d);
template&lt;class D, class A&gt; shared_ptr(nullptr_t p, D d, A a);
</pre></blockquote>

<p>
after
</p>

<blockquote><pre>template&lt;class Y, class D&gt; shared_ptr(Y* p, D d);
template&lt;class Y, class D, class A&gt; shared_ptr(Y* p, D d, A a);
</pre></blockquote>

<p>
(reusing the following paragraphs 20.9.10.2.1 [util.smartptr.shared.const]/9-13 that speak of p.)
</p>

<p>
In 20.9.10.2.1 [util.smartptr.shared.const]/10,  change
</p>

<blockquote>
<i>Effects:</i> Constructs a <tt>shared_ptr</tt> object that <i>owns</i> the
<del>pointer</del> <ins>object</ins> <tt>p</tt> and the deleter <tt>d</tt>. The second 
constructor shall use a copy of <tt>a</tt> to allocate memory for internal use.
</blockquote>


<p><b>Rationale:</b></p>
<p><i>[
San Francisco:
]</i></p>


<blockquote>
"pointer" is changed to "object" to handle the fact that nullptr_t isn't a pointer.
</blockquote>






<hr>
<h3><a name="759"></a>759. A reference is not an object</h3>
<p><b>Section:</b> 23.2 [container.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Jens Maurer <b>Opened:</b> 2007-11-06 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#container.requirements">issues</a> in [container.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
23.2 [container.requirements] says:
</p>

<blockquote>
-12- Objects passed to member functions of a container as rvalue references shall not be elements of that container. No 
diagnostic required.
</blockquote>

<p>
A reference is not an object, but this sentence appears to claim so.
</p>

<p>
What is probably meant here:
</p>
<blockquote>
An object bound to an rvalue
reference parameter of a member function of a container shall not be
an element of that container; no diagnostic required.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 23.2 [container.requirements]:
</p>

<blockquote>
-12- <del>Objects passed to member functions of a container as rvalue references shall not be elements</del>
<ins>An object bound to an rvalue
reference parameter of a member function of a container shall not be
an element</ins>
of that container<del>.</del><ins>;</ins> <del>N</del><ins>n</ins>o 
diagnostic required.
</blockquote>






<hr>
<h3><a name="761"></a>761. <tt>unordered_map</tt> needs an <tt>at()</tt> member function</h3>
<p><b>Section:</b> 23.7.1.2 [unord.map.elem] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Joe Gottman <b>Opened:</b> 2007-11-15 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The new member function <tt>at()</tt> was recently added to <tt>std::map()</tt>.  It acts 
like <tt>operator[]()</tt>, except it throws an exception when the input key is 
not found.  It is useful when the <tt>map</tt> is <tt>const</tt>, the <tt>value_type</tt> of the 
key doesn't have  a default constructor, it is an error if the key is 
not found, or the user wants to avoid accidentally adding an element to 
the map.  For exactly these same reasons, <tt>at()</tt> would be equally useful 
in <tt>std::unordered_map</tt>.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add the following functions to the definition of <tt>unordered_map</tt> under "lookup" (23.7.1 [unord.map]):
</p>

<blockquote><pre>mapped_type&amp; at(const key_type&amp; k);
const mapped_type &amp;at(const key_type &amp;k) const;
</pre></blockquote>

<p>
Add the following definitions to 23.7.1.2 [unord.map.elem]:
</p>

<blockquote>
<pre>mapped_type&amp; at(const key_type&amp; k);
const mapped_type &amp;at(const key_type &amp;k) const;
</pre>
<blockquote>
<p>
<i>Returns:</i> A reference to <tt>x.second</tt>, where <tt>x</tt> is the (unique) element 
whose key is equivalent to <tt>k</tt>.
</p>
<p>
<i>Throws:</i> An exception object of type <tt>out_of_range</tt> if no such element 
is present.
</p>
</blockquote>
</blockquote>

<p><i>[
Bellevue:  Editorial note: the "(unique)" differs from map.
]</i></p>







<hr>
<h3><a name="762"></a>762. <tt>std::unique_ptr</tt> requires complete type?</h3>
<p><b>Section:</b> 20.9.9 [unique.ptr] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2007-11-30 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#unique.ptr">issues</a> in [unique.ptr].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In contrast to the proposed <tt>std::shared_ptr</tt>, <tt>std::unique_ptr</tt>
does currently not support incomplete types, because it
gives no explicit grant - thus instantiating <tt>unique_ptr</tt> with
an incomplete pointee type <tt>T</tt> automatically belongs to
undefined behaviour according to 17.6.3.8 [res.on.functions]/2, last
bullet. This is an unnecessary restriction and prevents
many well-established patterns - like the bridge pattern -
for <tt>std::unique_ptr</tt>.
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
Move to open. The LWG is comfortable with the intent of allowing
incomplete types and making <tt>unique_ptr</tt> more like <tt>shared_ptr</tt>, but we are
not comfortable with the wording. The specification for <tt>unique_ptr</tt>
should be more like that of <tt>shared_ptr</tt>. We need to know, for individual
member functions, which ones require their types to be complete. The
<tt>shared_ptr</tt> specification is careful to say that for each function, and
we need the same level of care here. We also aren't comfortable with the
"part of the operational semantic" language; it's not used elsewhere in
the standard, and it's not clear what it means. We need a volunteer to
produce new wording.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
The proposed changes in the following revision refers to the current state of
N2521 including the assumption that X [unique.ptr.compiletime] will be removed
according to the current state of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#740">740</a>.
</p>
<p>
The specialization <tt>unique_ptr&lt;T[]&gt;</tt> has some more restrictive constraints on
type-completeness on <tt>T</tt> than <tt>unique_ptr&lt;T&gt;</tt>. The following proposed wordings
try to cope with that. If the committee sees less usefulness on relaxed
constraints on <tt>unique_ptr&lt;T[]&gt;</tt>, the alternative would be to stop this relaxation
e.g. by adding one further bullet to 20.9.9.3 [unique.ptr.runtime]/1:
"<tt>T</tt> shall be a complete type, if used as template argument of
<tt>unique_ptr&lt;T[], D&gt;</tt>
</p>
<p>
This issue has some overlap with <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#673">673</a>, but it seems not to cause any
problems with this one,
because <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#673">673</a> adds only optional requirements on <tt>D</tt> that do not conflict
with the here discussed
ones, provided that <tt>D::pointer</tt>'s operations (including default
construction, copy construction/assignment,
and pointer conversion) are specified <em>not</em> to throw, otherwise this
would have impact on the
current specification of <tt>unique_ptr</tt>.
</p>

<ol>
<li>
<p>
In 20.9.9 [unique.ptr]/2 add as the last sentence to the existing para:
</p>

<blockquote>
The <tt>unique_ptr</tt> provides a semantics of strict ownership. A
<tt>unique_ptr</tt> owns the object it holds a pointer to. A
<tt>unique_ptr</tt> is not <tt>CopyConstructible</tt>, nor
<tt>CopyAssignable</tt>, however it is <tt>MoveConstructible</tt> and
<tt>MoveAssignable</tt>. <ins>The template parameter <tt>T</tt> of
<tt>unique_ptr</tt> may be an incomplete type.</ins> [ <i>Note:</i> The
uses of <tt>unique_ptr</tt> include providing exception safety for
dynamically allcoated memory, passing ownership of dynamically allocated
memory to a function, and returning dynamically allocated memory from a
function. -- <i>end note</i> ]
</blockquote>
</li>

<li>
<p>
20.9.9.2.1 [unique.ptr.single.ctor]/1: No changes necessary.
</p>

<blockquote>
<p><i>[
N.B.: We only need the requirement that <tt>D</tt> is <tt>DefaultConstructible</tt>.
The current wording says just this.
]</i></p>

</blockquote>
</li>

<li>
<p>
In 20.9.9.2.1 [unique.ptr.single.ctor]/5 change the requires clause to say:
</p>

<blockquote>
<p>
<i>Requires:</i> <del>The expression <tt>D()(p)</tt> shall be well formed. The default constructor
of <tt>D</tt> shall not throw an exception.</del>
<del><tt>D</tt> must not be a reference type.</del>
<ins>
<tt>D</tt> shall be default constructible, and that construction
shall not throw an exception.
</ins>
</p>
<p><i>[
N.B.: There is no need that the expression <tt>D()(p)</tt> is well-formed at
this point. I assume that the current wording is based on the
corresponding <tt>shared_ptr</tt> wording. In case of <tt>shared_ptr</tt> this
requirement is necessary, because the corresponding c'tor *can* fail
and must invoke delete <tt>p/d(p)</tt> in this case. <tt>Unique_ptr</tt> is simpler in
this regard. The *only* functions that must insist on well-formedness
and well-definedness of the expression <tt>get_deleter()(get())</tt> are (1)
the destructor and (2) <tt>reset</tt>. The reasoning for the wording change to
explicitly require <tt>DefaultConstructible</tt> of <tt>D</tt> is to guarantee that
invocation of
<tt>D</tt>'s default c'tor is both well-formed and well-defined. Note also that
we do *not* need the
requirement that <tt>T</tt> must be complete, also in contrast to <tt>shared_ptr</tt>.
<tt>Shared_ptr</tt> needs this, because it's c'tor is a template c'tor which
potentially requires <tt>Convertible&lt;Y*, X*&gt;</tt>, which
again requires Completeness of <tt>Y</tt>, if <tt>!SameType&lt;X, Y&gt;</tt>
]</i></p>

</blockquote>
</li>

<li>
<p>
Merge 20.9.9.2.1 [unique.ptr.single.ctor]/12+13 thereby removing the sentence
of 12, but transferring the "requires" to 13:
</p>

<blockquote>
<p>
<i>Requires:</i> If <tt>D</tt> is not an lvalue-reference type then[..]
</p>
<p><i>[
N.B.: For the same reasons as for (3), there is no need that <tt>d(p)</tt> is
well-formed/well-defined at this point. The current wording guarantees
all what we need, namely that the initialization of both the <tt>T*</tt>
pointer and the <tt>D</tt> deleter are well-formed and well-defined.
]</i></p>

</blockquote>
</li>

<li>
20.9.9.2.1 [unique.ptr.single.ctor]/17: No changes necessary.
</li>
<li>
<p>20.9.9.2.1 [unique.ptr.single.ctor]/21:</p>

<blockquote>
<i>Requires:</i> If <tt>D</tt> is not a reference type, construction of
the deleter <tt>D</tt> from an rvalue of type <tt>E</tt> shall be well
formed and shall not throw an exception. If <tt>D</tt> is a reference
type, then <tt>E</tt> shall be the same type as <tt>D</tt> (diagnostic
required). <tt>U*</tt> shall be implicitly convertible to <tt>T*</tt>.
<ins>[<i>Note:</i> These requirements imply that <tt>T</tt> and <tt>U</tt>
be complete types. <i>-- end note</i>]</ins>
</blockquote>

<p><i>[
N.B.: The current wording of 21 already implicitly guarantees that <tt>U</tt>
is completely defined, because it requires that <tt>Convertible&lt;U*, T*&gt;</tt> is
true. If the committee wishes this explicit requirement can be added,
e.g. "<tt>U</tt> shall be a complete type."
]</i></p>

</li>

<li>
<p>
20.9.9.2.2 [unique.ptr.single.dtor]: Just before p1 add a new paragraph:
</p>
<blockquote>
<p>
<i>Requires:</i> The expression <tt>get_deleter()(get())</tt> shall be well-formed,
shall have well-defined behavior, and shall not throw exceptions.
<ins>[<i>Note:</i> The use of <tt>default_delete</tt> requires <tt>T</tt> to
be a complete type. <i>-- end note</i>]</ins>
</p>
<p><i>[
N.B.: This requirement ensures that the whole responsibility on
type-completeness of <tt>T</tt> is delegated to this expression.
]</i></p>

</blockquote>
</li>

<li>
<p>
20.9.9.2.3 [unique.ptr.single.asgn]/1: No changes necessary, except the
current editorial issue, that "must shall" has to be changed to
"shall", but this change is not a special part of this resolution.
</p>

<p><i>[
N.B. The current wording is sufficient, because we can delegate all
further requirements on the requirements of the effects clause
]</i></p>

</li>

<li>
<p>
20.9.9.2.3 [unique.ptr.single.asgn]/6:
</p>

<blockquote>
<i>Requires:</i> Assignment of the deleter <tt>D</tt> from an rvalue
<tt>D</tt> shall not throw an exception. <tt>U*</tt> shall be implicitly
convertible to <tt>T*</tt>.
<ins>[<i>Note:</i> These requirements imply that <tt>T</tt> and <tt>U</tt>
be complete types. <i>-- end note</i>]</ins>
</blockquote>

<p><i>[
N.B.: The current wording of p. 6 already implicitly guarantees that
<tt>U</tt> is completely defined, because it requires that <tt>Convertible&lt;U*, T*&gt;</tt>
is true, see (6)+(8).
]</i></p>

</li>

<li>
<p>
20.9.9.2.3 [unique.ptr.single.asgn]/11: No changes necessary.
</p>
<p><i>[
N.B.: Delegation to requirements of effects clause is sufficient.
]</i></p>

</li>

<li>
20.9.9.2.4 [unique.ptr.single.observers]/1+4+7+9+11:
</li>

<blockquote>
<pre>T* operator-&gt;() const;</pre>
<blockquote>
<ins><i>Note:</i> Use typically requires <tt>T</tt> shall be complete. <i>-- end note</i>]</ins>
</blockquote>
</blockquote>

<li>
20.9.9.2.5 [unique.ptr.single.modifiers]/1: No changes necessary.
</li>

<li>
<p>
20.9.9.2.5 [unique.ptr.single.modifiers]/4: Just before p. 4 add a new paragraph:
</p>
<blockquote>
<i>Requires:</i> The expression <tt>get_deleter()(get())</tt> shall be well-formed,
shall have well-defined behavior, and shall not throw exceptions.
</blockquote>
</li>

<li>
20.9.9.2.5 [unique.ptr.single.modifiers]/7: No changes necessary.
</li>

<li>
<p>
20.9.9.3 [unique.ptr.runtime]: Add one additional bullet on paragraph 1:
</p>

<blockquote>
<p>
A specialization for array types is provided with a slightly altered interface.
</p>

<ul>
<li>
...
</li>
<li>
<ins><tt>T</tt> shall be a complete type.</ins>
</li>
</ul>
</blockquote>
</li>
</ol>

<p><i>[
post Bellevue: Daniel provided revised wording.
]</i></p>







<hr>
<h3><a name="765"></a>765. more on iterator validity</h3>
<p><b>Section:</b> X [iterator.concepts] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2007-12-14 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#iterator.concepts">issues</a> in [iterator.concepts].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
       <p>

Issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#278">278</a>
defines the meaning of the term "invalid iterator" as one that may be
singular.

       </p>
       <p>

Consider the following code:

       </p>
       <pre>   std::deque&lt;int&gt; x, y;
   std::deque&lt;int&gt;::iterator i = x.end(), j = y.end();
   x.swap(y);
       </pre>
       <p>

Given that <code>swap()</code> is required not to invalidate iterators
and using the definition above, what should be the expected result of
comparing <code>i</code> and <code>j</code> to <code>x.end()</code>
and <code>y.end()</code>, respectively, after the <code>swap()</code>?

       </p>
       <p>

I.e., is the expression below required to evaluate
to <code>true</code>?

       </p>
       <pre>   i == y.end() &amp;&amp; j == x.end()
       </pre>
       <p>

(There are at least two implementations where the expression
returns <code>false</code>.)

       </p>
       <p>

More generally, is the definition introduced in issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#278">278</a> meant to
make any guarantees about whether iterators actually point to the same
elements or be associated with the same containers after a
non-invalidating operation as they did before?

       </p>
       <p>

Here's a motivating example intended to demonstrate the importance of
the question:

       </p>
       <pre>   Container x, y ({ 1, 2});   // pseudocode to initialize y with { 1, 2 }
   Container::iterator i = y.begin() + 1;
   Container::iterator j = y.end();
   std::swap(x, y);
   std::find(i, j, 3);
       </pre>
       <p>

<code>swap()</code> guarantees that <code>i</code> and <code>j</code>
continue to be valid. Unless the spec says that even though they are
valid they may no longer denote a valid range the code above must be
well-defined. Expert opinions on this differ as does the behavior of
popular implementations for some standard <code>Containers</code>.

       </p>
<p><i>[
San Francisco:
]</i></p>


<blockquote>
<p>
Pablo: add a note to the last bullet of paragraph 11 of 23.1.1 clarifying that the end() iterator doesn't refer to an element and that it can therefore be invalidated.
</p>
<p>
Proposed wording:
</p>
<blockquote>
[<i>Note:</i> The <tt>end()</tt> iterator does not refer to any element and can
therefore be invalidated. <i>-- end note</i>]
</blockquote>
<p>
Howard will add this proposed wording to the issue and then move it to Review.
</p>
</blockquote>

<p><i>[
Post Summit:
]</i></p>


<blockquote>
<p>
Lawrence: suggestion: "Note: The <tt>end()</tt> iterator does not refer to any element"
</p>
<p>
Walter: "Note: The <tt>end()</tt> iterator can nevertheless be invalidated,
because it does not refer to any element."
</p>
<p>
Nick: "The <tt>end()</tt> iterator does not refer to any element. It is therefore
subject to being invalidated."
</p>
<p>
Consensus: go with Nick
</p>
<p>
With that update, Recommend Tentatively Ready.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add to 23.2.1 [container.requirements.general], p11:
</p>

<blockquote>
<p>
Unless otherwise specified (see 23.1.4.1, 23.1.5.1, 23.2.2.3, and
23.2.6.4) all container types defined in this Clause meet the following
additional requirements:
</p>
<ul>
<li>...</li>
<li>
no <tt>swap()</tt> function invalidates any references, pointers, or
iterators referring to the elements of the containers being swapped.
<ins>[<i>Note:</i> The <tt>end()</tt> iterator does not refer to any element. It is therefore
subject to being invalidated. <i>-- end note</i>]</ins>
</li>
</ul>
</blockquote>





<hr>
<h3><a name="766"></a>766. Inconsistent exception guarantees between ordered and unordered associative containers</h3>
<p><b>Section:</b> 23.2 [container.requirements], 23.2.5.1 [unord.req.except] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Ion Gaztaaga <b>Opened:</b> 2007-12-22 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#container.requirements">issues</a> in [container.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
23.2 [container.requirements]p10 states:
</p>

<blockquote>
<p>
Unless otherwise specified (see 23.2.2.3 and 23.2.5.4) all container types defined in this clause meet the following
additional requirements:
</p>
<ul>

<li>[...]</li>

<li>no <tt>erase()</tt>, <tt>pop_back()</tt> or <tt>pop_front()</tt> function throws an exception.</li>

</ul>
</blockquote>

<p>
23.3.2.3 [deque.modifiers] and 23.4.1.4 [vector.modifiers] offer
additional guarantees for <tt>deque</tt>/<tt>vector insert()</tt> and
<tt>erase()</tt> members. However, 23.2 [container.requirements]p10 does not mention 23.2.5.1 [unord.req.except] that specifies exception safety guarantees
for unordered containers. In addition,  23.2.5.1 [unord.req.except]p1 offers the following guaratee for
<tt>erase()</tt>:
</p>

<blockquote>
No <tt>erase()</tt> function throws an exception unless that exception
is thrown by the container's Hash or Pred object (if any).
</blockquote>

<p>
Summary:
</p>

<p>
According to 23.2 [container.requirements]p10 no
<tt>erase()</tt> function should throw an exception unless otherwise
specified. Although does not explicitly mention 23.2.5.1 [unord.req.except], this section offers additional guarantees
for unordered containers, allowing <tt>erase()</tt> to throw if
predicate or hash function throws.
</p>

<p>
In contrast, associative containers have no exception safety guarantees
section so no <tt>erase()</tt> function should throw, <em>including
<tt>erase(k)</tt></em> that needs to use the predicate function to
perform its work. This means that the predicate of an associative
container is not allowed to throw.
</p>

<p>
So:
</p>

<ol>
<li>
<tt>erase(k)</tt> for associative containers is not allowed to throw. On
the other hand, <tt>erase(k)</tt> for unordered associative containers
is allowed to throw.
</li>
<li>
<tt>erase(q)</tt> for associative containers is not allowed to throw. On
the other hand, <tt>erase(q)</tt> for unordered associative containers
is allowed to throw if it uses the hash or predicate.
</li>
<li>
To fulfill 1), predicates of associative containers are not allowed to throw.
Predicates of unordered associative containers are allowed to throw.
</li>
<li>
2) breaks a widely used programming pattern (flyweight pattern) for
unordered containers, where objects are registered in a global map in
their constructors and unregistered in their destructors. If <tt>erase(q)</tt> is
allowed to throw, the destructor of the object would need to rethrow the
exception or swallow it, leaving the object registered.
</li>
</ol>


<p><b>Proposed resolution:</b></p>
<p>
Create a new sub-section of 23.2.4 [associative.reqmts] (perhaps [associative.req.except]) titled "Exception
safety guarantees".
</p>

<blockquote>
<p>
1 For associative containers, no <tt>clear()</tt> function throws an exception.
<tt>erase(k)</tt> does not throw an exception unless that exception is thrown by
the container's Pred object (if any).
</p>

<p>
2 For associative containers, if an exception is thrown by any operation
from within an <tt>insert()</tt> function inserting a single element, the
<tt>insert()</tt> function has no effect.
</p>

<p>
3 For associative containers, no <tt>swap</tt> function throws an exception
unless that exception is thrown by the copy constructor or copy
assignment operator of the container's Pred object (if any).
</p>
</blockquote>

<p>
Change 23.2.5.1 [unord.req.except]p1:
</p>

<blockquote>
For unordered associative containers, no <tt>clear()</tt> function
throws an exception. <del>No</del> <tt>erase(<ins>k</ins>)</tt>
<del>function</del> <ins>does not</ins> throw<del>s</del> an exception
unless that exception is thrown by the container's Hash or Pred object
(if any).
</blockquote>

<p>
Change 23.2 [container.requirements]p10 to add references to new sections:
</p>

<blockquote>
Unless otherwise specified (see [deque.modifiers]<ins>,</ins>
<del>and</del> [vector.modifiers]<ins>, [associative.req.except],
[unord.req.except]</ins>) all container types defined in this clause meet
the following additional requirements:
</blockquote>

<p>
Change 23.2 [container.requirements]p10 referring to <tt>swap</tt>:
</p>

<blockquote>
<ul>
<li>
no <tt>swap()</tt> function throws an exception<del> unless that exception is thrown
by the copy constructor or assignment operator of the container's
Compare object (if any; see [associative.reqmts])</del>.
</li>
</ul>
</blockquote>






<hr>
<h3><a name="768"></a>768. Typos in [atomics]?</h3>
<p><b>Section:</b> 29.5 [atomics.types.generic] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Alberto Ganesh Barbati <b>Opened:</b> 2007-12-28 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#atomics.types.generic">issues</a> in [atomics.types.generic].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
in the latest publicly available draft, paper
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2461.pdf">N2641</a>,
in section 29.5 [atomics.types.generic], the following specialization of the template
<tt>atomic&lt;&gt;</tt> is provided for pointers:
</p>

<blockquote><pre>template &lt;class T&gt; struct atomic&lt;T*&gt; : atomic_address { 
  T* fetch_add(ptrdiff_t, memory_order = memory_order_seq_cst) volatile; 
  T* fetch_sub(ptrdiff_t, memory_order = memory_order_seq_cst) volatile; 

  atomic() = default; 
  constexpr explicit atomic(T); 
  atomic(const atomic&amp;) = delete; 
  atomic&amp; operator=(const atomic&amp;) = delete; 

  T* operator=(T*) volatile; 
  T* operator++(int) volatile; 
  T* operator--(int) volatile; 
  T* operator++() volatile; 
  T* operator--() volatile; 
  T* operator+=(ptrdiff_t) volatile;
  T* operator-=(ptrdiff_t) volatile; 
};
</pre></blockquote>

<p>
First of all, there is a typo in the non-default constructor which
should take a <tt>T*</tt> rather than a <tt>T</tt>.
</p>

<p>
As you can see, the specialization redefine and therefore hide a few
methods from the base class <tt>atomic_address</tt>, namely <tt>fetch_add</tt>, <tt>fetch_sub</tt>,
<tt>operator=</tt>, <tt>operator+=</tt> and <tt>operator-=</tt>. That's good, but... what happened
to the other methods, in particular these ones:
</p>

<blockquote><pre>void store(T*, memory_order = memory_order_seq_cst) volatile;
T* load( memory_order = memory_order_seq_cst ) volatile;
T* swap( T*, memory_order = memory_order_seq_cst ) volatile;
bool compare_swap( T*&amp;, T*, memory_order, memory_order ) volatile;
bool compare_swap( T*&amp;, T*, memory_order = memory_order_seq_cst ) volatile;
</pre></blockquote>

<p>
By reading paper
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2427.html">N2427 "C++ Atomic Types and Operations"</a>,
I see that the
definition of the specialization <tt>atomic&lt;T*&gt;</tt> matches the one in the
draft, but in the example implementation the methods <tt>load()</tt>, <tt>swap()</tt>
and <tt>compare_swap()</tt> are indeed present.
</p>

<p>
Strangely, the example implementation does not redefine the method
<tt>store()</tt>. It's true that a <tt>T*</tt> is always convertible to <tt>void*</tt>, but not
hiding the <tt>void*</tt> signature from the base class makes the class
error-prone to say the least: it lets you assign pointers of any type to
a <tt>T*</tt>, without any hint from the compiler.
</p>

<p>
Is there a true intent to remove them from the specialization or are
they just missing from the definition because of a mistake?
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
<p>
The proposed revisions are accepted.
</p>
<p>
Further discussion: why is the ctor labeled "constexpr"? Lawrence said
this permits the object to be statically initialized, and that's
important because otherwise there would be a race condition on
initialization.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change the synopsis in 29.5 [atomics.types.generic]:
</p>

<blockquote><pre>template &lt;class T&gt; struct atomic&lt;T*&gt; : atomic_address { 
  <ins>void store(T*, memory_order = memory_order_seq_cst) volatile;</ins>
  <ins>T* load( memory_order = memory_order_seq_cst ) volatile;</ins>
  <ins>T* swap( T*, memory_order = memory_order_seq_cst ) volatile;</ins>
  <ins>bool compare_swap( T*&amp;, T*, memory_order, memory_order ) volatile;</ins>
  <ins>bool compare_swap( T*&amp;, T*, memory_order = memory_order_seq_cst ) volatile;</ins>

  T* fetch_add(ptrdiff_t, memory_order = memory_order_seq_cst) volatile; 
  T* fetch_sub(ptrdiff_t, memory_order = memory_order_seq_cst) volatile; 

  atomic() = default; 
  constexpr explicit atomic(T<ins>*</ins>); 
  atomic(const atomic&amp;) = delete; 
  atomic&amp; operator=(const atomic&amp;) = delete; 

  T* operator=(T*) volatile; 
  T* operator++(int) volatile; 
  T* operator--(int) volatile; 
  T* operator++() volatile; 
  T* operator--() volatile; 
  T* operator+=(ptrdiff_t) volatile;
  T* operator-=(ptrdiff_t) volatile; 
};
</pre></blockquote>






<hr>
<h3><a name="769"></a>769. std::function should use nullptr_t instead of "unspecified-null-pointer-type"</h3>
<p><b>Section:</b> 20.8.14.2 [func.wrap.func] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2008-01-10 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#func.wrap.func">issues</a> in [func.wrap.func].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
N2461 already replaced in 20.8.14.2 [func.wrap.func] it's originally proposed
(implicit) conversion operator to "unspecified-bool-type" by the new
explicit bool conversion, but the inverse conversion should also
use the new <tt>std::nullptr_t</tt> type instead of "unspecified-null-pointer-
type".
</p>


<p><b>Proposed resolution:</b></p>

<p>
In 20.8 [function.objects], header <tt>&lt;functional&gt;</tt> synopsis replace:
</p>

<blockquote><pre>template&lt;class R, class... ArgTypes&gt;
  bool operator==(const function&lt;R(ArgTypes...)&gt;&amp;, <del>unspecified-null-pointer-type</del> <ins>nullptr_t</ins>);
template&lt;class R, class... ArgTypes&gt;
  bool operator==(<del>unspecified-null-pointer-type</del> <ins>nullptr_t</ins> , const function&lt;R(ArgTypes...)&gt;&amp;);
template&lt;class R, class... ArgTypes&gt;
  bool operator!=(const function&lt;R(ArgTypes...)&gt;&amp;, <del>unspecified-null-pointer-type</del> <ins>nullptr_t</ins>);
template&lt;class R, class... ArgTypes&gt;
  bool operator!=(<del>unspecified-null-pointer-type</del> <ins>nullptr_t</ins> , const function&lt;R(ArgTypes...)&gt;&amp;);
</pre></blockquote>

<p>
In the class function synopsis of 20.8.14.2 [func.wrap.func] replace
</p>

<blockquote><pre>function(<del>unspecified-null-pointer-type</del> <ins>nullptr_t</ins>);
...
function&amp; operator=(<del>unspecified-null-pointer-type</del> <ins>nullptr_t</ins>);
</pre></blockquote>

<p>
In 20.8.14.2 [func.wrap.func], "Null pointer comparisons" replace:
</p>

<blockquote><pre>template &lt;class R, class... ArgTypes&gt;
  bool operator==(const function&lt;R(ArgTypes...)&gt;&amp;, <del>unspecified-null-pointer-type</del> <ins>nullptr_t</ins>);
template &lt;class R, class... ArgTypes&gt;
  bool operator==(<del>unspecified-null-pointer-type</del> <ins>nullptr_t</ins> , const function&lt;R(ArgTypes...)&gt;&amp;);
template &lt;class R, class... ArgTypes&gt;
  bool operator!=(const function&lt;R(ArgTypes...)&gt;&amp;, <del>unspecified-null-pointer-type</del> <ins>nullptr_t</ins>);
template &lt;class R, class... ArgTypes&gt;
  bool operator!=(<del>unspecified-null-pointer-type</del> <ins>nullptr_t</ins> , const function&lt;R(ArgTypes...)&gt;&amp;);
</pre></blockquote>

<p>
In 20.8.14.2.1 [func.wrap.func.con], replace
</p>

<blockquote><pre>function(<del>unspecified-null-pointer-type</del> <ins>nullptr_t</ins>);
...
function&amp; operator=(<del>unspecified-null-pointer-type</del> <ins>nullptr_t</ins>);
</pre></blockquote>

<p>
In 20.8.14.2.6 [func.wrap.func.nullptr], replace
</p>

<blockquote><pre>template &lt;class R, class... ArgTypes&gt;
  bool operator==(const function&lt;R(ArgTypes...)&gt;&amp; f, <del>unspecified-null-pointer-type</del> <ins>nullptr_t</ins>);
template &lt;class R, class... ArgTypes&gt;
  bool operator==(<del>unspecified-null-pointer-type</del> <ins>nullptr_t</ins> , const function&lt;R(ArgTypes...)&gt;&amp; f);
</pre></blockquote>

<p>
and replace
</p>

<blockquote><pre>template &lt;class R, class... ArgTypes&gt;
  bool operator!=(const function&lt;R(ArgTypes...)&gt;&amp; f, <del>unspecified-null-pointer-type</del> <ins>nullptr_t</ins>);
template &lt;class R, class... ArgTypes&gt;
  bool operator!=(<del>unspecified-null-pointer-type</del> <ins>nullptr_t</ins> , const function&lt;R(ArgTypes...)&gt;&amp; f);
</pre></blockquote>






<hr>
<h3><a name="770"></a>770. std::function should use rvalue swap</h3>
<p><b>Section:</b> 20.8.14 [func.wrap] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2008-01-10 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It is expected that typical implementations of <tt>std::function</tt> will
use dynamic memory allocations at least under given conditions,
so it seems appropriate to change the current lvalue swappabilty of
this class to rvalue swappability.
</p>


<p><b>Proposed resolution:</b></p>
<p>
In 20.8 [function.objects], header <tt>&lt;functional&gt;</tt> synopsis, just below of
</p>

<blockquote><pre>template&lt;class R, class... ArgTypes&gt;
  void swap(function&lt;R(ArgTypes...)&gt;&amp;, function&lt;R(ArgTypes...)&gt;&amp;);
<ins>template&lt;class R, class... ArgTypes&gt;
  void swap(function&lt;R(ArgTypes...)&gt;&amp;&amp;, function&lt;R(ArgTypes...)&gt;&amp;);
template&lt;class R, class... ArgTypes&gt;
  void swap(function&lt;R(ArgTypes...)&gt;&amp;, function&lt;R(ArgTypes...)&gt;&amp;&amp;);</ins>
</pre></blockquote>

<p>
In 20.8.14.2 [func.wrap.func] class <tt>function</tt> definition, change
</p>

<blockquote><pre>void swap(function&amp;<ins>&amp;</ins>);
</pre></blockquote>

<p>
In 20.8.14.2 [func.wrap.func], just below of
</p>

<blockquote><pre>template &lt;class R, class... ArgTypes&gt;
  void swap(function&lt;R(ArgTypes...)&gt;&amp;, function&lt;R(ArgTypes...)&gt;&amp;);
<ins>template &lt;class R, class... ArgTypes&gt;
  void swap(function&lt;R(ArgTypes...)&gt;&amp;&amp;, function&lt;R(ArgTypes...)&gt;&amp;);
template &lt;class R, class... ArgTypes&gt;
  void swap(function&lt;R(ArgTypes...)&gt;&amp;, function&lt;R(ArgTypes...)&gt;&amp;&amp;);</ins>
</pre></blockquote>

<p>
In 20.8.14.2.2 [func.wrap.func.mod] change
</p>

<blockquote><pre>void swap(function&amp;<ins>&amp;</ins> other);
</pre></blockquote>

<p>
In 20.8.14.2.7 [func.wrap.func.alg] add the two overloads
</p>

<blockquote><pre><ins>template&lt;class R, class... ArgTypes&gt;
  void swap(function&lt;R(ArgTypes...)&gt;&amp;&amp; f1, function&lt;R(ArgTypes...)&gt;&amp; f2);
template&lt;class R, class... ArgTypes&gt;
  void swap(function&lt;R(ArgTypes...)&gt;&amp; f1, function&lt;R(ArgTypes...)&gt;&amp;&amp; f2);</ins>
</pre></blockquote>






<hr>
<h3><a name="771"></a>771. Impossible throws clause in [string.conversions]</h3>
<p><b>Section:</b> 21.5 [string.conversions] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2008-01-13 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#string.conversions">issues</a> in [string.conversions].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The new <tt>to_string</tt> and <tt>to_wstring</tt> functions described in 21.5 [string.conversions]
have throws clauses (paragraphs 8 and 16) which say:
</p>

<blockquote>
<i>Throws:</i> nothing
</blockquote>

<p>
Since all overloads return either a <tt>std::string</tt> or a <tt>std::wstring</tt> by value
this throws clause is impossible to realize in general, since the <tt>basic_string</tt>
constructors can fail due to out-of-memory conditions. Either these throws
clauses should be removed or should be more detailled like:
</p>

<blockquote>
<i>Throws:</i> Nothing if the string construction throws nothing
</blockquote>

<p>
Further there is an editorial issue in p. 14: All three <tt>to_wstring</tt>
overloads return a <tt>string</tt>, which should be <tt>wstring</tt> instead (The
header <tt>&lt;string&gt;</tt> synopsis of 21.3 [string.classes] is correct in this
regard).
</p>



<p><b>Proposed resolution:</b></p>
<p>
In 21.5 [string.conversions], remove the paragraphs 8 and 16.
</p>

<blockquote>
<pre>string to_string(long long val); 
string to_string(unsigned long long val); 
string to_string(long double val); 
</pre>
<blockquote>
<del><i>Throws:</i> nothing</del>
</blockquote>
</blockquote>

<blockquote>
<pre><ins>w</ins>string to_wstring(long long val); 
<ins>w</ins>string to_wstring(unsigned long long val); 
<ins>w</ins>string to_wstring(long double val); 
</pre>
<blockquote>
<del><i>Throws:</i> nothing</del>
</blockquote>
</blockquote>






<hr>
<h3><a name="772"></a>772.  Impossible return clause in [string.conversions]</h3>
<p><b>Section:</b> 21.5 [string.conversions] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2008-01-13 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#string.conversions">issues</a> in [string.conversions].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The return clause 21.5 [string.conversions]/paragraph 15 of the new <tt>to_wstring</tt>
overloads says:
</p>

<blockquote>
<i>Returns:</i> each function returns a <tt>wstring</tt> object holding the character
representation of the value of its argument that would be generated by
calling <tt>wsprintf(buf, fmt, val)</tt> with a format specifier of <tt>L"%lld"</tt>, <tt>L"%ulld"</tt>,
or <tt>L"%f"</tt>, respectively.
</blockquote>

<p>
Problem is: There does not exist any <tt>wsprintf</tt> function in C99 (I checked
the 2nd edition of ISO 9899, and the first and the second corrigenda from
2001-09-01 and 2004-11-15). What probably meant here is the function
<tt>swprintf</tt> from <tt>&lt;wchar.h&gt;/&lt;cwchar&gt;</tt>, but this has the non-equivalent
declaration:
</p>

<blockquote><pre>int swprintf(wchar_t * restrict s, size_t n,
const wchar_t * restrict format, ...);
</pre></blockquote>

<p>
therefore the paragraph needs to mention the <tt>size_t</tt> parameter <tt>n</tt>.
</p>



<p><b>Proposed resolution:</b></p>
<p>
Change the current wording of 21.5 [string.conversions]/p. 15 to:
</p>

<blockquote>
<i>Returns:</i> <del>e</del><ins>E</ins>ach function returns a
<tt>wstring</tt> object holding the character representation of the
value of its argument that would be generated by calling
<tt><del>ws</del><ins>sw</ins>printf(buf, <ins>bufsz,</ins> fmt,
val)</tt> with a format specifier <ins><tt>fmt</tt></ins> of <tt>L"%lld"</tt>,
<tt>L"%ulld"</tt>, or <tt>L"%f"</tt>, respectively<ins>, where <tt>buf</tt>
designates an internal character buffer of sufficient size <tt>bufsz</tt></ins>.
</blockquote>

<p>
[Hint to the editor: The resolution also adds to mention the name of
the format specifier "fmt"]
</p>

<p>
I also would like to remark that the current wording of it's equivalent
paragraph 7 should also mention the meaning of <tt>buf</tt> and <tt>fmt</tt>.
</p>

<p>
Change the current wording of 21.5 [string.conversions]/p. 7 to:
</p>

<blockquote>
<i>Returns:</i> <del>e</del><ins>E</ins>ach function returns a string object holding the
character representation of the value of its argument that would be
generated by calling <tt>sprintf(buf, fmt, val)</tt> with a format specifier <ins><tt>fmt</tt></ins> of
<tt>"%lld"</tt>, <tt>"%ulld"</tt>, or <tt>"%f"</tt>, respectively<ins>, where <tt>buf</tt> designates an internal
character buffer of sufficient size</ins>.
</blockquote>






<hr>
<h3><a name="774"></a>774. Member swap undefined for most containers</h3>
<p><b>Section:</b> 23 [containers] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2008-01-14 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#containers">issues</a> in [containers].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It appears most containers declare but do not define a member-swap
function.
</p>

<p>
This is unfortunate, as all overload the <tt>swap</tt> algorithm to call the
member-swap function!
(required for <tt>swappable</tt> guarantees [Table 37] and Container Requirements
[Table 87])
</p>

<p>
Note in particular that Table 87 gives semantics of <tt>a.swap(b)</tt> as <tt>swap(a,b)</tt>,
yet for all containers we define <tt>swap(a,b)</tt> to call <tt>a.swap(b)</tt> - a circular
definition.
</p>

<p>
A quick survey of clause 23 shows that the following containers provide a
definition for member-swap:
</p>

<blockquote><pre>array
queue
stack
vector
</pre></blockquote>

<p>
Whereas the following declare it, but do not define the semantics:
</p>

<blockquote><pre>deque
list
map
multimap
multiset
priority_queue
set
unordered_map
unordered_multi_map
unordered_multi_set
unordered_set
</pre></blockquote>

<p>
Suggested resolution:
</p>
<blockquote>
Provide a definition for each of the affected containers...
</blockquote>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
Move to Open and ask Alisdair to provide wording.
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
Daniel to provide wording.
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2590.pdf">N2590</a>
is no longer applicable.
</blockquote>

<p><i>[
2009-07-28 Daniel provided wording.
]</i></p>


<blockquote>
<ol>
<li>
It assumes that the proposed resolution for <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#883">883</a> is applied,
which breaks the circularity of definition between member
<tt>swap</tt> and free <tt>swap</tt>.
</li>

<li>
It uses the notation of the pre-concept allocator trait
<tt>allocator_propagation_map</tt>, which might be renamed after the
next refactoring phase of generalized allocators.
</li>

<li>
It requires that compare objects, key equal functions and
hash functions in containers are swapped via unqualified free
<tt>swap</tt> according to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#594">594</a>.
</li>
</ol>
</blockquote>

<p><i>[
2009-09-30 Daniel adds:
]</i></p>


<blockquote>
The outcome of this issue should be considered with the outcome of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1198">1198</a> both in style and in content (e.g. bullet 9 suggests to
define the semantic of <tt>void
priority_queue::swap(priority_queue&amp;)</tt> in terms of the member
<tt>swap</tt> of the container).
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Looked at, but took no action on as it overlaps too much with
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2982.pdf">N2982</a>.
Waiting for a new draft WP.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Leave as open. Pablo to provide wording.
</blockquote>

<p><i>[
2009-10-26 Pablo updated wording.  Here is the wording he replaced:
]</i></p>


<blockquote class="note">
<ol>
<li>
<p>
Add a new Throws clause just after X [allocator.propagation.map]/5:
</p>

<blockquote><pre>static void swap(Alloc&amp; a, Alloc&amp; b);
</pre>
<blockquote>
<p>
<i>Effects:</i> [..]
</p>

<p>
<ins><i>Throws:</i> Nothing.</ins>
</p>
</blockquote>
</blockquote>
<p><i>[
This exception requirement is added, such that it's combination with the
general container requirements of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2723.pdf">N2723</a>
[container.requirements.general]/9
make it unambiguously clear that the following descriptions of "swaps the
allocators" have the following meaning: (a) This swap is done by calling
<tt>allocator_propagation_map&lt;allocator_type&gt;::swap</tt> and (b) This allocator
swap does never propagate an exception
]</i></p>

</li>

<li>
<p>
Change 23.2.4.1 [associative.reqmts.except]/3 as indicated:
</p>

<blockquote>
For associative containers, no <tt>swap</tt> function throws an exception unless that
exception is thrown by the <del>copy constructor or copy assignment
operator</del>
<ins><tt>swap</tt></ins> of the container's <tt>Pred</tt> object<ins>s</ins><del> (if any)</del>.
</blockquote>
</li>

<li>
<p>
Change 23.2.5.1 [unord.req.except]/3 as indicated:
</p>

<blockquote>
For unordered associative containers, no <tt>swap</tt> function throws an
exception unless
that exception is thrown by the <del>copy constructor or copy
assignment operator</del>
<ins><tt>swap</tt></ins> of the container's <tt>Hash</tt> or <tt>Pred</tt> object<ins>s,
respectively</ins><del> (if any)</del>.
</blockquote>
</li>

<li>
<p>
Insert a new paragraph just after 23.3 [sequences]/1:
</p>

<blockquote>
<ins>In addition to being available via inclusion of the <tt>&lt;algorithm&gt;</tt> header,
the <tt>swap</tt> function templates in 25.3.3 [alg.swap] are also available when the
header <tt>&lt;queue&gt;</tt> is included.</ins>
</blockquote>

<p><i>[
There is a new issue in process that will suggest a minimum header for <tt>swap</tt>
and <tt>move</tt>. If this one is provided, this text can be removed and the header
dependency should be added to <tt>&lt;queue&gt;</tt>
]</i></p>


</li>

<li>
<p>
Add one further clause at the end of 23.3.1.2 [array.special]:
</p>
<p><i>[This part is added, because otherwise <tt>array::swap</tt> would otherwise
contradict the
general contract of 23.2.1 [container.requirements.general] p. 10 b. 5]</i></p>


<blockquote>
<ins><i>Throws:</i> Nothing, unless one of the element-wise <tt>swap</tt> calls throws
an exception.</ins>
</blockquote>
</li>

<li>
<ol type="a">
<li>
<p>
In 23.3.2 [deque], class template deque synopsis change as indicated:
</p>
<blockquote><pre>void swap(deque<del>&lt;T,Alloc&gt;</del>&amp;);
</pre></blockquote>
</li>

<li>
<p>
At the end of 23.3.2.3 [deque.modifiers] add as indicated:
</p>

<blockquote><pre><ins>void swap(deque&amp; x);</ins>
</pre>
<blockquote>
<p>
<ins><i>Effects:</i> Exchanges the contents and swaps the allocators of <tt>*this</tt>
with that of <tt>x</tt>.</ins>
</p>
<p>
<ins><i>Complexity:</i> Constant time.</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>
</li>

<li>
<ol type="a">
<li>
<p>
In 23.3.3 [forwardlist], class template <tt>forward_list</tt> synposis change as indicated:
</p>

<blockquote><pre>void swap(forward_list<del>&lt;T,Allocator&gt;</del>&amp;);
</pre></blockquote>
</li>

<li>
<p>
At the end of 23.3.3.4 [forwardlist.modifiers] add as indicated:
</p>

<blockquote><pre><ins>void swap(forward_list&amp; x);</ins>
</pre>
<blockquote>
<p>
<ins><i>Effects:</i> Exchanges the contents and swaps the allocators of <tt>*this</tt>
with that of <tt>x</tt>.</ins>
</p>
<p>
<ins><i>Complexity:</i> Constant time.</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>
</li>

<li>
<ol type="a">
<li>
<p>
In 23.3.4 [list], class template <tt>list</tt> synopsis change as indicated:
</p>

<blockquote><pre>void swap(list<del>&lt;T,Allocator&gt;</del>&amp;);
</pre></blockquote>
</li>

<li>
<p>
At the end of 23.3.4.3 [list.modifiers] add as indicated:
</p>

<blockquote><pre><ins>void swap(list&amp; x);</ins>
</pre>

<blockquote>
<p>
<ins><i>Effects:</i> Exchanges the contents and swaps the allocators of <tt>*this</tt>
with that of <tt>x</tt>.</ins>
</p>

<p>
<ins><i>Complexity:</i> Constant time.</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>
</li>

<li>
<p>
At the end of 23.5.2.3 [priqueue.members] add a new prototype description:
</p>

<blockquote><pre><ins>void swap(priority_queue&amp; q);</ins>
</pre>
<blockquote>
<p>
<ins><i>Requires:</i> <tt>Compare</tt> shall satisfy the <tt>Swappable</tt> requirements
( [swappable]).</ins>
</p>

<p><i>[
This requirement is added to ensure that even a user defined <tt>swap</tt>
which is found by
ADL for <tt>Compare</tt> satisfies the <tt>Swappable</tt> requirements
]</i></p>


<p>
<ins><i>Effects:</i> <tt>this-&gt;c.swap(q.c); swap(this-&gt;comp, q.comp);</tt></ins>
</p>
<p>
<ins><i>Throws:</i> What and if <tt>c.swap(q.c)</tt> and <tt>swap(comp, q.comp)</tt> throws.</ins>
</p>
</blockquote>
</blockquote>
<p><i>[
This part is added, because otherwise <tt>priority_queue::swap</tt> would otherwise
contradict the general contract of 23.2.1 [container.requirements.general] p. 10 b. 5
]</i></p>

</li>

<li>
<ol type="a">
<li>
<p>
In 23.4.1 [vector], class template <tt>vector</tt> synopsis change as indicated:
</p>

<blockquote><pre>void swap(vector<del>&lt;T,Allocator&gt;</del>&amp;);
</pre></blockquote>
</li>

<li>
<p>
Change 23.4.1.2 [vector.capacity]/8 as indicated:
</p>

<blockquote><pre>void swap(vector<del>&lt;T,Allocator&gt;</del>&amp; x);
</pre>

<blockquote>
<i>Effects:</i> Exchanges the contents and <tt>capacity()</tt> <ins>and swaps the
allocators</ins>
of <tt>*this</tt> with that of <tt>x</tt>.
</blockquote>
</blockquote>
</li>
</ol>
</li>

<li>
<p>
Insert a new paragraph just before 23.6 [associative]/1:
</p>

<blockquote>
<ins>In addition to being available via inclusion of the <tt>&lt;algorithm&gt;</tt> header,
the <tt>swap</tt> function templates in 25.3.3 [alg.swap] are also available when any of the
headers <tt>&lt;map&gt;</tt> or <tt>&lt;set&gt;</tt> are included.</ins>
</blockquote>
</li>

<li>
<ol type="a">
<li>
<p>
In 23.6.1 [map], class template <tt>map</tt> synopsis change as indicated:
</p>

<blockquote><pre>void swap(map<del>&lt;Key,T,Compare,Allocator&gt;</del>&amp;);
</pre></blockquote>
</li>

<li>
<p>
At the end of 23.6.1.3 [map.modifiers] add as indicated:
</p>

<blockquote><pre><ins>void swap(map&amp; x);</ins>
</pre>

<blockquote>
<p>
<ins><i>Requires:</i> Compare shall satisfy the <tt>Swappable</tt> requirements
( [swappable]).</ins>
</p>

<p><i>[
This requirement is added to ensure that even a user defined <tt>swap</tt>
which is found by ADL for <tt>Compare</tt> satisfies the <tt>Swappable</tt>
requirements
]</i></p>


<p>
<ins><i>Effects:</i> Exchanges the contents and swaps the allocators of <tt>*this</tt>
with that of <tt>x</tt>, followed by an unqualified <tt>swap</tt> of the comparison objects
of <tt>*this</tt> and <tt>x</tt>.</ins>
</p>

<p>
<ins><i>Complexity:</i> Constant time</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>
</li>

<li>
<ol type="a">
<li>
<p>
In 23.6.2 [multimap], class template <tt>multimap</tt> synopsis change as indicated:
</p>

<blockquote><pre>void swap(multimap<del>&lt;Key,T,Compare,Allocator&gt;</del>&amp;);
</pre></blockquote>
</li>

<li>
<p>
At the end of 23.6.2.2 [multimap.modifiers] add as indicated:
</p>

<blockquote><pre><ins>void swap(multimap&amp; x);</ins>
</pre>

<blockquote>
<p>
<ins><i>Requires:</i> Compare shall satisfy the <tt>Swappable</tt> requirements
( [swappable]).</ins>
</p>
<p>
<ins><i>Effects:</i> Exchanges the contents and swaps the allocators of <tt>*this</tt>
with that of <tt>x</tt>, followed by an unqualified <tt>swap</tt> of the comparison objects
of <tt>*this</tt> and <tt>x</tt>.</ins>
</p>
<p>
<ins><i>Complexity:</i> Constant time</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>
</li>

<li>
<ol type="a">
<li>
<p>
In 23.6.3 [set], class template <tt>set</tt> synopsis change as indicated:
</p>

<blockquote><pre>void swap(set<del>&lt;Key,Compare,Allocator&gt;</del>&amp;);
</pre></blockquote>
</li>

<li>
<p>
After section 23.6.3.1 [set.cons] add a new section <ins><tt>set</tt> modifiers
 [set.modifiers]</ins>
and add the following paragraphs:
</p>

<blockquote><pre><ins>void swap(set&amp; x);</ins>
</pre>

<blockquote>
<p>
<ins><i>Requires:</i> Compare shall satisfy the <tt>Swappable</tt> requirements
( [swappable]).</ins>
</p>

<p>
<ins><i>Effects:</i> Exchanges the contents and swaps the allocators of <tt>*this</tt>
with that of <tt>x</tt>, followed by an unqualified <tt>swap</tt> of the comparison objects
of <tt>*this</tt> and <tt>x</tt>.</ins>
</p>

<p>
<ins>Complexity: Constant time</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>
</li>

<li>
<ol type="a">
<li>
<p>
In 23.6.4 [multiset], class template <tt>multiset</tt> synosis, change as indicated:
</p>

<blockquote><pre>void swap(multiset<del>&lt;Key,Compare,Allocator&gt;</del>&amp;);
</pre></blockquote>
</li>

<li>
<p>
After section 23.6.4.1 [multiset.cons] add a new section <ins><tt>multiset</tt> modifiers
 [multiset.modifiers]</ins> and add the following paragraphs:
</p>

<blockquote><pre><ins>void swap(multiset&amp; x);</ins>
</pre>

<blockquote>
<p>
<ins><i>Requires:</i> Compare shall satisfy the <tt>Swappable</tt> requirements
( [swappable]).</ins>
</p>

<p>
<ins><i>Effects:</i> Exchanges the contents and swaps the allocators of <tt>*this</tt>
with that of <tt>x</tt>, followed by an unqualified <tt>swap</tt> of the comparison objects
of <tt>*this</tt> and <tt>x</tt>.</ins>
</p>

<p>
<ins><i>Complexity:</i> Constant time</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>
</li>

<li>
<p>
Insert a new paragraph just before 23.7 [unord]/1:
</p>

<blockquote>
<ins>In addition to being available via inclusion of the <tt>&lt;algorithm&gt;</tt> header,
the <tt>swap</tt> function templates in 25.3.3 [alg.swap] are also available when any of the
headers <tt>&lt;unordered_map&gt;</tt> or <tt>&lt;unordered_set&gt;</tt> are included.</ins>
</blockquote>

</li>

<li>
<p>
After section 23.7.1.2 [unord.map.elem] add a new section <ins>unordered_map
modifiers  [unord.map.modifiers]</ins> and add the following paragraphs:
</p>

<blockquote><pre><ins>void swap(unordered_map&amp; x);</ins>
</pre>

<blockquote>
<p>
<ins><i>Requires:</i> <tt>Hash</tt> and <tt>Pred</tt> shall satisfy the <tt>Swappable</tt> requirements
( [swappable]).</ins>
</p>

<p><i>[
This requirement is added to ensure that even a user defined <tt>swap</tt>
which is found by ADL for <tt>Hash</tt> and <tt>Pred</tt> satisfies the <tt>Swappable</tt>
requirements
]</i></p>


<p>
<ins><i>Effects:</i> Exchanges the contents and hash policy and swaps the
allocators of <tt>*this</tt>
with that of <tt>x</tt>, followed by an unqualified <tt>swap</tt> of the <tt>Pred</tt> objects
and an unqualified <tt>swap</tt> of the <tt>Hash</tt> objects of <tt>*this</tt> and <tt>x</tt>.</ins>
</p>

<p>
<ins><i>Complexity:</i> Constant time</ins>
</p>
</blockquote>
</blockquote>
</li>

<li>
<p>
After section 23.7.2.1 [unord.multimap.cnstr] add a new section
<ins>unordered_multimap
modifiers  [unord.multimap.modifiers]</ins> and add the following paragraphs:
</p>

<blockquote><pre><ins>void swap(unordered_multimap&amp; x);</ins>
</pre>

<blockquote>
<p>
<ins><i>Requires:</i> <tt>Hash</tt> and <tt>Pred</tt> shall satisfy the <tt>Swappable</tt> requirements
( [swappable]).</ins>
</p>

<p>
<ins><i>Effects:</i> Exchanges the contents and hash policy and swaps the
allocators of <tt>*this</tt>
with that of <tt>x</tt>, followed by an unqualified <tt>swap</tt> of the <tt>Pred</tt> objects
and an unqualified <tt>swap</tt> of the <tt>Hash</tt> objects of <tt>*this</tt> and <tt>x</tt></ins>
</p>
<p>
<ins><i>Complexity:</i> Constant time</ins>
</p>
</blockquote>
</blockquote>
</li>

<li>
<p>
After section 23.7.3.1 [unord.set.cnstr] add a new section
<ins>unordered_set modifiers
 [unord.set.modifiers]</ins> and add the following paragraphs:
</p>

<blockquote><pre><ins>void swap(unordered_set&amp; x);</ins>
</pre>

<blockquote>
<p>
<ins><i>Requires:</i> <tt>Hash</tt> and <tt>Pred</tt> shall satisfy the <tt>Swappable</tt> requirements
( [swappable]).</ins>
</p>

<p>
<ins><i>Effects:</i> Exchanges the contents and hash policy and swaps the
allocators of <tt>*this</tt>
with that of <tt>x</tt>, followed by an unqualified <tt>swap</tt> of the <tt>Pred</tt> objects
and an unqualified <tt>swap</tt> of the <tt>Hash</tt> objects of <tt>*this</tt> and <tt>x</tt></ins>
</p>

<p>
<ins><i>Complexity:</i> Constant time</ins>
</p>
</blockquote>
</blockquote>
</li>

<li>
<p>
After section 23.7.4.1 [unord.multiset.cnstr] add a new section
<ins>unordered_multiset
modifiers  [unord.multiset.modifiers]</ins> and add the following paragraphs:
</p>

<blockquote><pre><ins>void swap(unordered_multiset&amp; x);</ins>
</pre>

<blockquote>
<p>
<ins><i>Requires:</i> <tt>Hash</tt> and <tt>Pred</tt> shall satisfy the <tt>Swappable</tt> requirements
( [swappable]).</ins>
</p>

<p>
<ins><i>Effects:</i> Exchanges the contents and hash policy and swaps the
allocators of <tt>*this</tt>
with that of <tt>x</tt>, followed by an unqualified <tt>swap</tt> of the <tt>Pred</tt> objects
and an unqualified <tt>swap</tt> of the <tt>Hash</tt> objects of <tt>*this</tt> and <tt>x</tt></ins>
</p>
<p>
<ins><i>Complexity:</i> Constant time</ins>
</p>
</blockquote>
</blockquote>
</li>

</ol>

</blockquote>

<p><i>[
2009-10-30 Pablo and Daniel updated wording.
]</i></p>


<p><i>[
2010 Pittsburgh:  Ready for Pittsburgh.
]</i></p>




<p><b>Proposed resolution:</b></p>

<p><i>[
This resolution is based on the September 2009 WP,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2960.pdf">N2960</a>,
except that it
assumes that
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2982.pdf">N2982</a>
and issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#883">883</a> and <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1232">1232</a> have already been applied.  Note in
particular that Table 91 in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2960.pdf">N2960</a>
is refered to as Table 90 because
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2982.pdf">N2982</a>
removed the old Table 90.  This resolution also addresses issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#431">431</a>.
]</i></p>

<p>
In 23.2.1 [container.requirements.general], replace the a.swap(b) row in table 90,
"container requirements" (was table 91 before the application of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2982.pdf">N2982</a> to the
WP):
</p>
<blockquote>
<table border="1">
  <tbody><tr>
    <td><code>a.swap(b)</code></td>
    <td><code>void</code></td>
    <td>&nbsp;&nbsp;&nbsp;</td>
    <td><code><del>swap(a,b)</del><ins>Exchange the contents of <tt>a</tt> and <tt>b</tt>.</ins></code></td>
    <td>(Note A)</td>
  </tr>
  <tr>
    <td><ins><code>swap(a,b)</code></ins></td>
    <td><ins><code>void</code></ins></td>
    <td><code>&nbsp;&nbsp;&nbsp;</code></td>
    <td><ins><code>a.swap(b)</code></ins></td>
    <td><ins>(Note A)</ins></td>
  </tr>
</tbody></table>
</blockquote>
<p>
Modify the notes immediately following Table 90 in
23.2.1 [container.requirements.general] as follows (The wording below is after the
application of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2982.pdf">N2982</a> to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2960.pdf">N2960</a>.  The editor might also want to combine Notes
A and B into one.):
</p>
<blockquote><p>
Notes: the algorithms<del> swap(),</del> equal() and lexicographical_compare()
are defined in Clause 25.  Those entries marked "(Note A)" or "(Note B)"
<del>should</del> have <ins>linear complexity for array and</ins> constant
complexity <ins>for all other standard containers</ins>.
</p></blockquote>
<p>
In 23.2.1 [container.requirements.general], before paragraph 8, add:
</p>
<blockquote><p><ins>
The expression <code>a.swap(b)</code>, for containers <code>a</code>
and <code>b</code> of a standard container type other than <code>array</code>,
exchanges the values of <code>a</code> and <code>b</code> without invoking any
move, copy, or swap operations on the individual container elements.
Any <code>Compare</code>, <code>Pred</code>, or <code>Hash</code> function
objects belonging to <code>a</code> and <code>b</code> shall be
<code>swappable</code> and are exchanged by unqualified calls
to non-member <code>swap</code>.  If
<code>allocator_traits&lt;allocator_type&gt;::propagate_on_container_swap::value
== true</code>, then the allocators of <code>a</code> and <code>b</code> are
also exchanged using an unqualified call to non-member <code>swap</code>.
Otherwise, the behavior is undefined unless <code>a.get_allocator() ==
b.get_allocator()</code>.  Each iterator refering to an element in one
container before the swap shall refer to the same element in the other
container after the swap.  It is unspecified whether an iterator with
value <code>a.end()</code> before the swap will have
value <code>b.end()</code> after the swap.  In addition to being available via
inclusion of the <code>&lt;utility&gt;</code> header, the <code>swap</code>
function template in 25.3.3 [alg.swap] is also available within the definition of
every standard container's <code>swap</code> function.
</ins></p></blockquote>
<p><i>[
Note to the editor: Paragraph 2 starts with a sentence fragment,
clearly from an editing or source-control error.
]</i></p>

<p>
Modify 23.2.4.1 [associative.reqmts.except] as follows:
</p>
<blockquote>
<p>
<b>23.2.4.1 Exception safety guarantees 23.2.4.1 [associative.reqmts.except]</b>
</p>
<p>
For associative containers, no <code>clear()</code> function throws an
exception. <code>erase(k)</code> does not throw an exception unless that
exception is thrown by the
container's <code><del>Pred</del><ins>Compare</ins></code> object (if any).
</p>
<p>
For associative containers, if an exception is thrown by any operation from
within an <code>insert()</code> function inserting a single element,
the <code>insert()</code> function has no effect.
</p>
<p>
For associative containers, no <code>swap</code> function throws an exception
unless that exception is thrown by the <del>copy constructor
or copy assignment operator</del><ins>swap</ins> of the
container's <code><del>Pred</del><ins>Compare</ins></code> object (if any).
</p></blockquote>
<p>
Modify 23.2.5.1 [unord.req.except], paragraph 3 as follows:
</p>
<blockquote><p>
For unordered associative containers, no <code>swap</code> function throws an
exception unless that exception is thrown by the <del>copy constructor or copy
assignment operator</del><ins>swap</ins> of the container's <code>Hash</code>
or <code>Pred</code> object (if any).
</p></blockquote>
<p>
Modify section 23.3.1.2 [array.special]:
</p>
<blockquote>
<p>
<b>array specialized algorithms 23.3.1.2 [array.special]</b>
</p>
<p>
<code>template &lt;class T, size_t N&gt; void swap(array&lt;T,N&gt;&amp; x,array&lt;T,N&gt;&amp; y);</code>
</p>
<blockquote>
<p>
<i>Effects:</i> <code><del>swap_ranges(x.begin(), x.end(), y.begin() );</del><ins>x.swap(y);</ins></code>
</p>
</blockquote>
</blockquote>
<p>
Add a new section after 23.3.1.5 [array.fill] (Note to the editor: array::fill make use
of a concept requirement that must be removed or changed to text.):
</p>
<blockquote>
<p>
<ins><b>array::swap [array.swap]</b></ins>
</p>
<p>
<ins><code>void swap(array&amp; y);</code></ins>
</p>
<blockquote>
<p><ins>
<i>Effects:</i> <code>swap_ranges(this-&gt;begin(), this-&gt;end(), y.begin() );</code>
</ins></p>
<p><ins>
<i>Throws:</i> Nothing unless one of the element-wise swap calls throws an
exception.
</ins></p>
<p><ins>
[<i>Note</i>: Unlike other containers' <code>swap</code> functions,
<code>array::swap</code> takes linear, not constant, time, may exit via an
exception, and does not cause iterators to become associated with the other
container.  <i>end note</i>]
</ins></p>
</blockquote>
</blockquote>

<p>
Insert a new paragraph just after 23.5 [container.adaptors]/1:
</p>
<blockquote><p><ins>
For container adaptors, no <code>swap</code> function throws an exception
unless that exception is thrown by the swap of the
adaptor's <code>Container</code> or <code>Compare</code> object (if any).
</ins></p></blockquote>












<hr>
<h3><a name="775"></a>775. Tuple indexing should be unsigned?</h3>
<p><b>Section:</b> 20.4.2.5 [tuple.helper] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2008-01-16 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#tuple.helper">issues</a> in [tuple.helper].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The tuple element access API identifies the element in the sequence
using signed integers, and then goes on to enforce the requirement that
I be &gt;= 0.  There is a much easier way to do this - declare I as
<tt>unsigned</tt>.
</p>
<p>
In fact the proposal is to use <code>std::size_t</code>, matching the type used in the <tt>tuple_size</tt> API.
</p>
<p>
A second suggestion is that it is hard to imagine an API that deduces
and index at compile time and returns a reference throwing an exception.
Add a specific <em>Throws:</em> Nothing paragraph to each element
access API.
</p>
<p>
In addition to <code>tuple</code>, update the API applies to
<code>pair</code> and <code>array</code>, and should be updated
accordingly.
</p>

<p>
A third observation is that the return type of the <code>get</code>
functions for <code>std::pair</code> is pseudo-code, but it is not
clearly marked as such.  There is actually no need for pseudo-code as
the return type can be specified precisely with a call to
<code>tuple_element</code>.  This is already done for
<code>std::tuple</code>, and <code>std::array</code> does not have a
problem as all elements are of type <code>T</code>.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Update header &lt;utility&gt; synopsis in 20.3 [utility]
</p>
<pre><em>// 20.2.3, tuple-like access to pair:</em>
template &lt;class T&gt; class tuple_size;
template &lt;<del>int</del><ins>size_t</ins> I, class T&gt; class tuple_element;

template &lt;class T1, class T2&gt; struct tuple_size&lt;std::pair&lt;T1, T2&gt; &gt;;
template &lt;class T1, class T2&gt; struct tuple_element&lt;0, std::pair&lt;T1, T2&gt; &gt;;
template &lt;class T1, class T2&gt; struct tuple_element&lt;1, std::pair&lt;T1, T2&gt; &gt;;

template&lt;<del>int</del><ins>size_t</ins> I, class T1, class T2&gt;
  <del>P</del><ins>typename tuple_element&lt;I, std::pair&lt;T1, T2&gt; &gt;::type </ins>&amp; get(std::pair&lt;T1, T2&gt;&amp;);
template&lt;<del>int</del><ins>size_t</ins> I, class T1, class T2&gt;
  const <del>P</del><ins>typename tuple_element&lt;I, std::pair&lt;T1, T2&gt; &gt;::type </ins>&amp; get(const std::pair&lt;T1, T2&gt;&amp;);
</pre>
<p>
Update <strong>20.3.5 [pairs] Pairs</strong>
</p>
<pre>template&lt;<del>int</del><ins>size_t</ins> I, class T1, class T2&gt;
  <del>P</del><ins>typename tuple_element&lt;I, std::pair&lt;T1, T2&gt; &gt;::type </ins>&amp; get(pair&lt;T1, T2&gt;&amp;);
template&lt;<del>int</del><ins>size_t</ins> I, class T1, class T2&gt;
  const <del>P</del><ins>typename tuple_element&lt;I, std::pair&lt;T1, T2&gt; &gt;::type </ins>&amp; get(const pair&lt;T1, T2&gt;&amp;);
</pre>
<p>
<del>24 <em>Return type:</em> If <code>I == 0</code> then <code>P</code> is <code>T1</code>, if <code>I == 1</code> then <code>P</code> is <code>T2</code>, and otherwise the program is ill-formed.</del>
</p>
<p>
25 <em>Returns:</em> If <code>I == 0</code> returns <code>p.first</code>, <del>otherwise</del> <ins>if <code>I == 1</code></ins> returns <code>p.second</code><ins>, and otherwise the program is ill-formed</ins>.
</p>
<p>
<ins><em>Throws:</em> Nothing.</ins>
</p>


<p>
Update header &lt;tuple&gt; synopsis in 20.4 [tuple] with a APIs as below:
</p>
<pre>template &lt;<del>int</del><ins>size_t</ins> I, class T&gt; class tuple_element; <em>// undefined</em>
template &lt;<del>int</del><ins>size_t</ins> I, class... Types&gt; class tuple_element&lt;I, tuple&lt;Types...&gt; &gt;;

<em>// 20.3.1.4, element access:</em>
template &lt;<del>int</del><ins>size_t</ins> I, class... Types&gt;
  typename tuple_element&lt;I, tuple&lt;Types...&gt; &gt;::type&amp; get(tuple&lt;Types...&gt;&amp;);
template &lt;<del>int</del><ins>size_t</ins> I, class ... types&gt;
  typename tuple_element&lt;I, tuple&lt;Types...&gt; &gt;::type const&amp; get(const tuple&lt;Types...&gt;&amp;);
</pre>

<p>
Update <strong>20.4.2.5 [tuple.helper] Tuple helper classes</strong>
</p>
<pre>template &lt;<del>int</del><ins>size_t</ins> I, class... Types&gt;
class tuple_element&lt;I, tuple&lt;Types...&gt; &gt; {
public:
  typedef TI type;
};</pre>
<p>
1 <em>Requires:</em> <code><del>0 &lt;= I and </del>I &lt; sizeof...(Types)</code>. The program is ill-formed if <code>I</code> is out of bounds.
</p>
<p>
2 <em>Type:</em> <code>TI</code> is the type of the <code>I</code>th element of <code>Types</code>, where indexing is zero-based.
</p>
<p>
Update <strong>20.4.2.6 [tuple.elem] Element access</strong>
</p>
<pre>template &lt;<del>int</del><ins>size_t</ins> I, class... types &gt;
typename tuple_element&lt;I, tuple&lt;Types...&gt; &gt;::type&amp; get(tuple&lt;Types...&gt;&amp; t);
</pre>
1 <em>Requires:</em> <code><del>0 &lt;= I and </del>I &lt; sizeof...(Types)</code>. The program is ill-formed if <code>I</code> is out of bounds.
<p>
2 <em>Returns:</em> A reference to the <code>I</code>th element of <code>t</code>, where indexing is zero-based.
</p>
<ins><em>Throws:</em> Nothing.</ins>
<pre>template &lt;<del>int</del><ins>size_t</ins> I, class... types&gt;
typename tuple_element&lt;I, tuple&lt;Types...&gt; &gt;::type const&amp; get(const tuple&lt;Types...&gt;&amp; t);
</pre>
<p>
3 <em>Requires:</em> <code><del>0 &lt;= I and </del>I &lt; sizeof...(Types)</code>. The program is ill-formed if <code>I</code> is out of bounds.
</p>
<p>
4 <em>Returns:</em> A const reference to the <code>I</code>th element of <code>t</code>, where indexing is zero-based.
</p>
<p>
<ins><em>Throws:</em> Nothing.</ins>
</p>


<p>
Update header &lt;array&gt; synopsis in 20.3 [utility]
</p>
<pre>template &lt;class T&gt; class tuple_size; <em>// forward declaration</em>
template &lt;<del>int</del><ins>size_t</ins> I, class T&gt; class tuple_element; <em>// forward declaration</em>
template &lt;class T, size_t N&gt;
  struct tuple_size&lt;array&lt;T, N&gt; &gt;;
template &lt;<del>int</del><ins>size_t</ins> I, class T, size_t N&gt;
  struct tuple_element&lt;I, array&lt;T, N&gt; &gt;;
template &lt;<del>int</del><ins>size_t</ins> I, class T, size_t N&gt;
  T&amp; get(array&lt;T, N&gt;&amp;);
template &lt;<del>int</del><ins>size_t</ins> I, class T, size_t N&gt;
  const T&amp; get(const array&lt;T, N&gt;&amp;);
</pre>

<p>
Update <strong>23.3.1.8 [array.tuple] Tuple interface to class template array</strong>
</p>
<pre>tuple_element&lt;<ins>size_t </ins>I, array&lt;T, N&gt; &gt;::type
</pre>
<p>
3 <em>Requires:</em> <code><del>0 &lt;= </del>I &lt; N.</code> The program is ill-formed if <code>I</code> is out of bounds.
</p>
<p>
4 <em>Value:</em> The type <code>T</code>.
</p>
<pre>template &lt;<del>int</del><ins>size_t</ins> I, class T, size_t N&gt; T&amp; get(array&lt;T, N&gt;&amp; a);
</pre>
<p>
5 <em>Requires:</em> <code><del>0 &lt;= </del>I &lt; N</code>. The program is ill-formed if <code>I</code> is out of bounds.
</p>
<p>
<em>Returns:</em> A reference to the <code>I</code>th element of <code>a</code>, where indexing is zero-based.
</p>
<p>
<ins><em>Throws:</em> Nothing.</ins>
</p>
<pre>template &lt;<del>int</del><ins>size_t</ins> I, class T, size_t N&gt; const T&amp; get(const array&lt;T, N&gt;&amp; a);
</pre>
<p>
6 <em>Requires:</em> <code><del>0 &lt;= </del>I &lt; N</code>. The program is ill-formed if <code>I</code> is out of bounds.
</p>
<p>
7 <em>Returns:</em> A const reference to the <code>I</code>th element of <code>a</code>, where indexing is zero-based.
</p>
<p>
<ins><em>Throws:</em> Nothing.</ins>
</p>


<p><i>[
Bellevue: Note also that the phrase "The program is ill-formed if I is
out of bounds" in the requires clauses are probably unnecessary, and
could be removed at the editor's discretion. Also std:: qualification
for pair is also unnecessary.
]</i></p>




<hr>
<h3><a name="776"></a>776. Undescribed assign function of std::array</h3>
<p><b>Section:</b> 23.3.1 [array] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2008-01-20 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#array">issues</a> in [array].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The class template array synopsis in 23.3.1 [array]/3 declares a member
function
</p>

<blockquote><pre>void assign(const T&amp; u);
</pre></blockquote>

<p>
which's semantic is no-where described. Since this signature is
not part of the container requirements, such a semantic cannot
be derived by those.
</p>

<p>
I found only one reference to this function in the issue list,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#588">588</a> where the question is raised:
</p>

<blockquote>
what's the effect of calling <tt>assign(T&amp;)</tt> on a zero-sized array?
</blockquote>

<p>
which does not answer the basic question of this issue.
</p>

<p>
If this function shall be part of the <tt>std::array</tt>, it's probable
semantic should correspond to that of <tt>boost::array</tt>, but of
course such wording must be added.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Just after the section 23.3.1.4 [array.data] add the following new section:
</p>

<p>
23.2.1.5 array::fill [array.fill]
</p>

<blockquote>
<pre>void fill(const T&amp; u);
</pre>

<p>
1: <i>Effects:</i> <tt>fill_n(begin(), N, u)</tt>
</p>
</blockquote>

<p>
[N.B: I wonder, why class <tt>array</tt> does not have a "modifiers"
section. If it had, then <tt>assign</tt> would naturally belong to it]
</p>

<p>
Change the synopsis in 23.3.1 [array]/3:
</p>

<blockquote><pre>template &lt;class T, size_t N&gt;
struct array { 
  ...
  void <del>assign</del> <ins>fill</ins>(const T&amp; u);
  ...
</pre></blockquote>


<p><i>[
Bellevue:
]</i></p>


<blockquote>
<p>
Suggest substituting "fill" instead of "assign".
</p>
<p>
Set state to Review given substitution of "fill" for "assign".
</p>
</blockquote>




<hr>
<h3><a name="777"></a>777. Atomics Library Issue</h3>
<p><b>Section:</b> 29.6 [atomics.types.operations] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Lawrence Crowl <b>Opened:</b> 2008-01-21 <b>Last modified:</b> 2010-10-29</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#atomics.types.operations">active issues</a> in [atomics.types.operations].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#atomics.types.operations">issues</a> in [atomics.types.operations].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The load functions are defined as
</p>

<blockquote><pre>C atomic_load(volatile A* object);
C atomic_load_explicit(volatile A* object, memory_order);
C A::load(memory_order order = memory_order_seq_cst) volatile;
</pre></blockquote>

<p>
which prevents their use in <tt>const</tt> contexts.
</p>

<p><i>[
post Bellevue Peter adds:
]</i></p>


<blockquote>
<p>
Issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#777">777</a> suggests making <tt>atomic_load</tt> operate on <tt>const</tt> objects. There is a
subtle point here. Atomic loads do not generally write to the object, except
potentially for the <tt>memory_order_seq_cst</tt> constraint. Depending on the
architecture, a dummy write with the same value may be required to be issued
by the atomic load to maintain sequential consistency. This, in turn, may
make the following code:
</p>

<blockquote><pre>const atomic_int x{};

int main()
{
  x.load();
}
</pre></blockquote>

<p>
dump core under a straightforward implementation that puts const objects in
a read-only section.
</p>
<p>
There are ways to sidestep the problem, but it needs to be considered.
</p>
<p>
The tradeoff is between making the data member of the atomic types
mutable and requiring the user to explicitly mark atomic members as
mutable, as is already the case with mutexes.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add the <tt>const</tt> qualifier to <tt>*object</tt> and <tt>*this</tt>.
</p>

<blockquote><pre>C atomic_load(<ins>const</ins> volatile A* object);
C atomic_load_explicit(<ins>const</ins> volatile A* object, memory_order);
C A::load(memory_order order = memory_order_seq_cst) <ins>const</ins> volatile;
</pre></blockquote>






<hr>
<h3><a name="778"></a>778. std::bitset does not have any constructor taking a string literal</h3>
<p><b>Section:</b> 20.5.1 [bitset.cons] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Thorsten Ottosen <b>Opened:</b> 2008-01-24 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#bitset.cons">issues</a> in [bitset.cons].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#116">116</a></p>
<p><b>Discussion:</b></p>
<p>
A small issue with <tt>std::bitset</tt>: it does not have any constructor
taking a string literal, which is clumsy and looks like an oversigt when
we tried to enable uniform use of <tt>string</tt> and <tt>const char*</tt> in the library.
</p>

<p>
Suggestion: Add
</p>

<blockquote><pre>explicit bitset( const char* str );
</pre></blockquote>

<p>
to std::bitset.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add to synopsis in 20.5 [template.bitset]
</p>

<blockquote><pre>explicit bitset( const char* str );
</pre></blockquote>

<p>
Add to synopsis in 20.5.1 [bitset.cons]
</p>

<blockquote><pre>explicit bitset( const char* str );
</pre>
<p>
<i>Effects:</i> Constructs a <tt>bitset</tt> as if <tt>bitset(string(str))</tt>.
</p>
</blockquote>






<hr>
<h3><a name="779"></a>779. Resolution of #283 incomplete</h3>
<p><b>Section:</b> 25.3.8 [alg.remove] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2008-01-25 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.remove">issues</a> in [alg.remove].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The resolution of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#283">283</a> did not resolve similar necessary changes for algorithm
<tt>remove_copy[_if]</tt>,
which seems to be an oversight.
</p>


<p><b>Proposed resolution:</b></p>
<p>
In 25.3.8 [alg.remove]/p.6, replace the N2461 requires clause with:
</p>

<blockquote>
<i>Requires:</i> <del>Type <tt>T</tt> is <tt>EqualityComparable</tt> (31).</del> The ranges <tt>[first,last)</tt>
and <tt>[result,result + (last - first))</tt> shall not overlap. <ins>The expression <tt>*result = *first</tt> shall be
valid.</ins>
</blockquote>






<hr>
<h3><a name="780"></a>780. <tt>std::merge()</tt> specification incorrect/insufficient</h3>
<p><b>Section:</b> 25.4.4 [alg.merge] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2008-01-25 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Though issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#283">283</a> has fixed many open issues, it seems that some are still open:
</p>

<p>
Both 25.3.4 [lib.alg.merge] in 14882:2003 and 25.4.4 [alg.merge] in N2461
have no Requires element and the Effects element contains some requirements,
which is probably editorial. Worse is that:
</p>

<ul>
<li>
no assignment requirements are specified (neither implicit nor explicit).
</li>

<li>
the effects clause just speaks of "merges", which is badly worded
near to a circular definition.
</li>

<li>
p. 2 mentions a range <tt>[first, last)</tt>, which is not defined by the
function arguments or otherwise.
</li>

<li>
p. 2 says "according to the ordering defined by comp" which is both
incomplete (because
this excludes the first variant with &lt;) and redundant (because the
following subordinate
clause mentions comp again)
</li>
</ul>

<p><i>[
Post Summit Alisdair adds:
]</i></p>


<blockquote>
<p>
Suggest:
</p>
<blockquote>
(where <tt>last</tt> is equal to <tt>next(result, distance(first1, last1) +
distance(first2, last2))</tt>, such that resulting range will be sorted in
non-decreasing order; that is, for every iterator <tt>i</tt> in <tt>[result,last)</tt> other
than <tt>result</tt>, the condition <tt>*i &lt; *prev(i)</tt> or, respectively, <tt>comp(*i,
*prev(i))</tt> will be <tt>false</tt>.
</blockquote>

<p>
Note that this might still not be technically accurate in the case of
<tt>InputIterators</tt>, depending on other resolutions working their way through the
system (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1011">1011</a>).
</p>
</blockquote>

<p><i>[
Post Summit Daniel adds:
]</i></p>


<blockquote>
If we want to use <tt>prev</tt> and <tt>next</tt> here (Note: <tt>merge</tt>
is sufficiently satisfied with <tt>InputIterator</tt>) we should instead *add* more to
25 [algorithms]/6, but I can currently not propose any good wording for this.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Pete points out the existing wording in [algorithms]/4
that permits the use of + in algorithm specifications.
</p>
<p>
Alisdair points out that that wording may not apply to input iterators.
</p>
<p>
Move to Review.
</p>
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
Move to Ready.
</blockquote>

<p><i>[
2009-08-23 Daniel reopens:
]</i></p>


<blockquote>
<p>
The proposed wording must be rephrased, because the part
</p>

<blockquote>
for every iterator <tt>i</tt> in <tt>[result,last)</tt> other than <tt>result</tt>, the condition
<tt>*i &lt; *(i - 1)</tt> or, respectively, <tt>comp(*i, *(i - 1))</tt> will be <tt>false</tt>"
</blockquote>

<p>
isn't meaningful, because the range <tt>[result,last)</tt> is that of a pure
<tt>OutputIterator</tt>, which is not <em>readable</em> in general.
</p>

<p><i>[Howard:  Proposed wording updated by Daniel, status moved from Ready to Review.]</i></p>

</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
<p>
Matt has some different words to propose.  Those words have been moved into
the proposed wording section, and the original proposed wording now appears
here:
</p>
<blockquote>
<p>
In 25.4.4 [alg.merge] replace p.1+ 2:
</p>

<blockquote>
<p>
<i>Effects:</i> <del>Merges</del><ins>Copies all the elements of the</ins>
two sorted ranges
<tt>[first1,last1)</tt> and <tt>[first2,last2)</tt> into the range <tt>[result,result +
(last1 - first1) + (last2 - first2))</tt>
<ins>, such that resulting range will be sorted in non-decreasing
order; that is for every
pair of iterators <tt>i</tt> and <tt>j</tt> of either input ranges, where <tt>*i</tt> was copied
to the output range
before <tt>*j</tt> was copied to the output range, the condition <tt>*j &lt; *i</tt> or,
respectively, <tt>comp(*j, *i)</tt>
will be <tt>false</tt>.</ins>
</p>

<p>
<ins><i>Requires:</i></ins>The resulting range shall not overlap with either
of the original ranges.
<del>The list will be sorted in non-decreasing order according to the
ordering defined by
<tt>comp</tt>; that is, for every iterator <tt>i</tt> in <tt>[first,last)</tt> other than <tt>first</tt>,
the condition <tt>*i &lt; *(i - 1)</tt> or
<tt>comp(*i, *(i - 1))</tt> will be <tt>false</tt>.</del>
</p>
</blockquote>
</blockquote>
</blockquote>

<p><i>[
2010-02-10 Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>




<p><b>Proposed resolution:</b></p>

<p>
Change 25.4.4 [alg.merge] 1 and 2:
</p>

<blockquote>
<p>1 <del>
<i>Effects:</i> Merges two sorted ranges <tt>[first1,last1)</tt> and
<tt>[first2,last2)</tt> into the range <tt>[result, result + (last1 -
first1) + (last2 - first2))</tt>.
</del></p>
<p><ins>
<i>Effects:</i> Copies all the elements of the two ranges
<tt>[first1,last1)</tt> and <tt>[first2,last2)</tt> into the range
<tt>[result, result_last)</tt>, where <tt>result_last</tt> is <tt>result
+ (last1 - first1) + (last2 - first2)</tt>, such that the resulting
range satisfies <tt>is_sorted(result, result_last)</tt> or
<tt>is_sorted(result, result_last, comp)</tt>, respectively.
</ins></p>

<p>
2 <ins><i>Requires:</i></ins> <ins>The ranges <tt>[first1,last1)</tt> and
<tt>[first2,last2)</tt> shall be sorted with respect to <tt>operator&lt;</tt> or
<tt>comp</tt>.</ins> The resulting range shall not overlap with either of the
original ranges.  <del>The list will be sorted in non-decreasing order according
to the ordering defined by <tt>comp</tt>; that is, for every iterator <tt>i</tt>
in <tt>[first,last)</tt> other than <tt>first</tt>, the condition <tt>*i &lt;
*(i - 1)</tt> or <tt>comp(*i, *(i - 1))</tt> will be <tt>false</tt>.</del>
</p>

</blockquote>

<p>
Change 25.4.4 [alg.merge]/6+7 as indicated <i>[This ensures harmonization
between <tt>inplace_merge</tt> and <tt>merge</tt>]</i>
</p>

<blockquote>
<p>
6 <i>Effects:</i> Merges two <del>sorted</del> consecutive ranges
<tt>[first,middle)</tt> and <tt>[middle,last)</tt>, putting the result of the
merge into the range <tt>[first,last)</tt>. The resulting range will be in
non-decreasing order; that is, for every iterator <tt>i</tt> in
<tt>[first,last)</tt> other than <tt>first</tt>, the condition <tt>*i &lt; *(i -
1)</tt> or, respectively, <tt>comp(*i, *(i - 1))</tt> will be false.
</p>

<p>
7 <i>Requires:</i> <ins>The ranges <tt>[first,middle)</tt> and
<tt>[middle,last)</tt> shall be sorted with respect to <tt>operator&lt;</tt> or
<tt>comp</tt>.</ins> The type of <tt>*first</tt> shall satisfy the
<tt>Swappable</tt> requirements (37), the <tt>MoveConstructible</tt>
requirements (Table 33), and the the <tt>MoveAssignable</tt> requirements (Table
35).
</p>
</blockquote>






<hr>
<h3><a name="781"></a>781. <tt>std::complex</tt> should add missing C99 functions</h3>
<p><b>Section:</b> 26.4.7 [complex.value.ops] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2008-01-26 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#complex.value.ops">issues</a> in [complex.value.ops].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
A comparision of the N2461 header <tt>&lt;complex&gt;</tt> synopsis ([complex.syn])
with the C99 standard (ISO 9899, 2nd edition and the two corrigenda) show
some complex functions that are missing in C++. These are:
</p>

<ol>
<li>
7.3.9.4: (required elements of the C99 library)<br>
The <tt>cproj</tt> functions
</li>
<li>
7.26.1: (optional elements of the C99 library)<br>
<pre>cerf    cerfc    cexp2
cexpm1  clog10   clog1p
clog2   clgamma  ctgamma
</pre>
</li>
</ol>

<p>
I propose that at least the required <tt>cproj</tt> overloads are provided as equivalent
C++ functions. This addition is easy to do in one sentence (delegation to C99
function).
</p>

<p>
Please note also that the current entry <tt>polar</tt>
in 26.4.9 [cmplx.over]/1
should be removed from the mentioned overload list. It does not make sense to require that a
function already expecting <em>scalar</em> arguments
should cast these arguments into corresponding
<tt>complex&lt;T&gt;</tt> arguments, which are not accepted by
this function.
</p>


<p><b>Proposed resolution:</b></p>
<p>
In 26.4.1 [complex.syn] add just between the declaration of <tt>conj</tt> and <tt>fabs</tt>:
</p>

<blockquote><pre>template&lt;class T&gt; complex&lt;T&gt; conj(const complex&lt;T&gt;&amp;);
<ins>template&lt;class T&gt; complex&lt;T&gt; proj(const complex&lt;T&gt;&amp;);</ins>
template&lt;class T&gt; complex&lt;T&gt; fabs(const complex&lt;T&gt;&amp;);
</pre></blockquote>

<p>
In 26.4.7 [complex.value.ops] just after p.6 (return clause of <tt>conj</tt>) add:
</p>

<blockquote>
<pre>template&lt;class T&gt; complex&lt;T&gt; proj(const complex&lt;T&gt;&amp; x);
</pre>
<blockquote>

<i>Effects:</i> Behaves the same as C99 function <tt>cproj</tt>, defined in
subclause 7.3.9.4."
</blockquote>
</blockquote>

<p>
In 26.4.9 [cmplx.over]/1, add one further entry <tt>proj</tt> to
the overload list.
</p>

<blockquote>
<p>
The following function templates shall have additional overloads:
</p>
<blockquote><pre>arg           norm 
conj          <del>polar</del> <ins>proj</ins>
imag          real
</pre></blockquote>
</blockquote>






<hr>
<h3><a name="782"></a>782. Extended <tt>seed_seq</tt> constructor is useless</h3>
<p><b>Section:</b> 26.5.7.1 [rand.util.seedseq] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2008-01-27 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.util.seedseq">issues</a> in [rand.util.seedseq].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Part of the resolution of n2423, issue 8 was the proposal to
extend the <tt>seed_seq</tt> constructor accepting an input range
as follows (which is now part of N2461):
</p>

<blockquote><pre>template&lt;class InputIterator,
size_t u = numeric_limits&lt;iterator_traits&lt;InputIterator&gt;::value_type&gt;::digits&gt;
seed_seq(InputIterator begin, InputIterator end);
</pre></blockquote>

<p>
First, the expression <tt>iterator_traits&lt;InputIterator&gt;::value_type</tt>
is invalid due to missing <tt>typename</tt> keyword, which is easy to
fix.
</p>

<p>
Second (and worse), while the language now supports default
template arguments of function templates, this customization
point via the second <tt>size_t</tt> template parameter is of no advantage,
because <tt>u</tt> can never be deduced, and worse - because it is a
constructor function template - it can also never be explicitly
provided (14.8.1 [temp.arg.explicit]/7).
</p>

<p>
The question arises, which advantages result from a compile-time
knowledge of <tt>u</tt> versus a run time knowledge? If run time knowledge
suffices, this parameter should be provided as normal function
default argument [Resolution marked (A)], if compile-time knowledge
is important, this could be done via a tagging template or more
user-friendly via a standardized helper generator function
(<tt>make_seed_seq</tt>), which allows this [Resolution marked (B)].
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
<p>
Fermilab does not have a strong opinion. Would prefer to go with
solution A. Bill agrees that solution A is a lot simpler and does the
job.
</p>
<p>
Proposed Resolution: Accept Solution A.
</p>
</blockquote>

<p>
Issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#803">803</a> claims to make this issue moot.
</p>



<p><b>Proposed resolution:</b></p>
<ol type="A">
<li>
<p>
In 26.5.7.1 [rand.util.seedseq]/2, class <tt>seed_seq</tt> synopsis replace:
</p>

<blockquote><pre>class seed_seq 
{ 
public:
   ...
   template&lt;class InputIterator<del>,
      size_t u = numeric_limits&lt;iterator_traits&lt;InputIterator&gt;::value_type&gt;::digits</del>&gt;
          seed_seq(InputIterator begin, InputIterator end<ins>,
          size_t u = numeric_limits&lt;typename iterator_traits&lt;InputIterator&gt;::value_type&gt;::digits</ins>);
   ...
};
</pre></blockquote>

<p>
and do a similar replacement in the member description between
p.3 and p.4.
</p>
</li>

<li>
<p>
In 26.5.7.1 [rand.util.seedseq]/2, class <tt>seed_seq</tt> synopsis <em>and</em> in the
member description between p.3 and p.4 replace:
</p>

<blockquote><pre>template&lt;class InputIterator<del>,
  size_t u = numeric_limits&lt;iterator_traits&lt;InputIterator&gt;::value_type&gt;::digits</del>&gt;
      seed_seq(InputIterator begin, InputIterator end);
<ins>template&lt;class InputIterator, size_t u&gt;
seed_seq(InputIterator begin, InputIterator end, <i>implementation-defined</i> s);</ins>
</pre></blockquote>

<p>
In 26.5.2 [rand.synopsis], header <tt>&lt;random&gt;</tt> synopsis, immediately after the
class <tt>seed_seq</tt> declaration <em>and</em> in 26.5.7.1 [rand.util.seedseq]/2, immediately
after the class <tt>seed_seq</tt> definition add:
</p>

<blockquote><pre>template&lt;size_t u, class InputIterator&gt;
  seed_seq make_seed_seq(InputIterator begin, InputIterator end);
</pre></blockquote>

<p>
In 26.5.7.1 [rand.util.seedseq], just before p.5 insert two paragraphs:
</p>

<blockquote>
<p>
The first constructor behaves as if it would provide an
integral constant expression <tt>u</tt> of type <tt>size_t</tt> of value
<tt>numeric_limits&lt;typename iterator_traits&lt;InputIterator&gt;::value_type&gt;::digits</tt>.
</p>
<p>
The second constructor uses an implementation-defined mechanism
to provide an integral constant expression <tt>u</tt> of type <tt>size_t</tt> and
is called by the function <tt>make_seed_seq</tt>.
</p>
</blockquote>

<p>
In 26.5.7.1 [rand.util.seedseq], just after the last paragraph add:
</p>

<blockquote>
<pre>template&lt;size_t u, class InputIterator&gt;
   seed_seq make_seed_seq(InputIterator begin, InputIterator end);
</pre>
<blockquote>
<p>
where <tt>u</tt> is used to construct an object <tt>s</tt> of implementation-defined type.
</p>
<p>
<i>Returns:</i> <tt>seed_seq(begin, end, s)</tt>;
</p>
</blockquote>
</blockquote>

</li>
</ol>






<hr>
<h3><a name="783"></a>783. <tt>thread::id</tt> reuse</h3>
<p><b>Section:</b> 30.3.1.1 [thread.thread.id] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Hans Boehm <b>Opened:</b> 2008-02-01 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.thread.id">issues</a> in [thread.thread.id].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The current working paper 
(<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2497.html">N2497</a>,
integrated just before Bellevue) is
not completely clear whether a given <tt>thread::id</tt> value may be reused once
a thread has exited and has been joined or detached.  Posix allows
thread ids (<tt>pthread_t</tt> values) to be reused in this case.  Although it is
not completely clear whether this originally was the right decision, it
is clearly the established practice, and we believe it was always the
intent of the C++ threads API to follow Posix and allow this.  Howard
Hinnant's example implementation implicitly relies on allowing reuse
of ids, since it uses Posix thread ids directly.
</p>

<p>
It is important to be clear on this point, since it the reuse of thread
ids often requires extra care in client code, which would not be
necessary if thread ids were unique across all time.  For example, a
hash table indexed by thread id may have to be careful not to associate
data values from an old thread with a new one that happens to reuse the
id.  Simply removing the old entry after joining a thread may not be
sufficient, if it creates a visible window between the join and removal
during which a new thread with the same id could have been created and
added to the table.
</p>

<p><i>[
post Bellevue Peter adds:
]</i></p>


<blockquote>
<p>
There is a real issue with <tt>thread::id</tt> reuse, but I urge the LWG to
reconsider fixing this by disallowing reuse, rather than explicitly allowing
it. Dealing with thread id reuse is an incredibly painful exercise that
would just force the world to reimplement a non-conflicting <tt>thread::id</tt> over
and over.
</p>
<p>
In addition, it would be nice if a <tt>thread::id</tt> could be manipulated
atomically in a lock-free manner, as motivated by the recursive lock
example:
</p>

<p>
<a href="http://www.decadentplace.org.uk/pipermail/cpp-threads/2006-August/001091.html">http://www.decadentplace.org.uk/pipermail/cpp-threads/2006-August/001091.html</a>
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add a sentence to 30.3.1.1 [thread.thread.id]/p1:
</p>

<blockquote>
<p>
An object of type <code>thread::id</code> provides
a unique identifier for each thread of execution
and a single distinct value for all thread objects
that do not represent a thread of execution ([thread.threads.class]).
Each thread of execution has a <code>thread::id</code>
that is not equal to the <code>thread::id</code>
of other threads of execution
and that is not equal to
the <code>thread::id</code> of <code>std::thread</code> objects
that do not represent threads of execution.
<ins>The library may reuse the value of a <code>thread::id</code> of a
terminated thread that can no longer be joined.</ins>
</p>
</blockquote>





<hr>
<h3><a name="786"></a>786. Thread library timed waits, UTC and monotonic clocks</h3>
<p><b>Section:</b> 20.11 [time] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> Christopher Kohlhoff, Jeff Garland <b>Opened:</b> 2008-02-03 <b>Last modified:</b> 2010-11-19</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#time">issues</a> in [time].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The draft C++0x thread library requires that the time points of type
<tt>system_time</tt> and returned by <tt>get_system_time()</tt> represent Coordinated
Universal Time (UTC) (section  [datetime.system]). This can lead to
surprising behavior when a library user performs a duration-based wait,
such as <tt>condition_variable::timed_wait()</tt>. A complete explanation of the
problem may be found in the
<a href="http://www.opengroup.org/onlinepubs/009695399/xrat/xsh_chap02.html#tag_03_02_08_19">Rationale for the Monotonic Clock</a>
section in POSIX, but in summary:
</p>

<ul>
<li>
Operations such as <tt>condition_variable::timed_wait()</tt> (and its POSIX
equivalent, <tt>pthread_cond_timedwait()</tt>) are specified using absolute times
to address the problem of spurious wakeups.
</li>

<li>
The typical use of the timed wait operations is to perform a relative
wait. This may be achieved by first calculating an absolute time as the
sum of the current time and the desired duration. In fact, the C++0x
thread library includes duration-based overloads of
<tt>condition_variable::timed_wait()</tt> that behave as if by calling the
corresponding absolute time overload with a time point value of
<tt>get_system_time() + rel_time</tt>.
</li>

<li>
A UTC clock may be affected by changes to the system time, such as
synchronization with an external source, leap seconds, or manual changes
to the clock.
</li>

<li>
Should the clock change during a timed wait operation, the actual
duration of the wait will not be the expected length. For example, a
user may intend a timed wait of one second duration but, due to an
adjustment of the system clock backwards by a minute, the wait instead
takes 61 seconds.
</li>
</ul>

<p>
POSIX solves the problem by introducing a new monotonic clock, which is
unaffected by changes to the system time. When a condition variable is
initialized, the user may specify whether the monotonic clock is to be
used. (It is worth noting that on POSIX systems it is not possible to
use <tt>condition_variable::native_handle()</tt> to access this facility, since
the desired clock type must be specified during construction of the
condition variable object.)
</p>

<p>
In the context of the C++0x thread library, there are added dimensions
to the problem due to the need to support platforms other than POSIX:
</p>

<ul>
<li>
Some environments (such as embedded systems) do not have a UTC clock, but do have a monotonic clock.
</li>

<li>
Some environments do not have a monotonic clock, but do have a UTC clock.
</li>

<li>
The Microsoft Windows API's synchronization functions use relative
timeouts based on an implied monotonic clock. A program that switches
from the Windows API to the C++0x thread library will now find itself
susceptible to clock changes.
</li>
</ul>

<p>
One possible minimal solution:
</p>

<ul>
<li>
Strike normative references to UTC and an epoch based on 1970-01-01.
</li>

<li>
Make the semantics of <tt>system_time</tt> and <tt>get_system_time()</tt>
implementation-defined (i.e standard library implementors may choose the
appropriate underlying clock based on the capabilities of the target
platform).
</li>

<li>
Add a non-normative note encouraging use of a monotonic clock.
</li>

<li>
Remove <tt>system_time::seconds_since_epoch()</tt>.
</li>

<li>
Change the constructor <tt>explicit system_time(time_t secs, nanoseconds ns
= 0)</tt> to <tt>explicit system_time(nanoseconds ns)</tt>.
</li>
</ul>



<p><b>Proposed resolution:</b></p>
<p>
</p>


<p><b>Rationale:</b></p>
Addressed by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2661.html">N2661: A Foundation to Sleep On</a>.





<hr>
<h3><a name="787"></a>787. complexity of <tt>binary_search</tt></h3>
<p><b>Section:</b> 25.4.3.4 [binary.search] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2007-09-08 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 25.4.3.4 [binary.search]/3 the complexity of <tt>binary_search</tt> is described as
</p>

<blockquote>
At most <tt>log(last - first) + 2</tt> comparisons.
</blockquote>

<p>
This should be precised and brought in line with the nomenclature used for
<tt>lower_bound</tt>, <tt>upper_bound</tt>, and <tt>equal_range</tt>.
</p>

<p>
All existing libraries I'm aware of, delegate to
<tt>lower_bound</tt> (+ one further comparison). Since
issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#384">384</a>
has now WP status, the resolution of #787 should
be brought in-line with <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#384">384</a> by changing the <tt>+ 2</tt>
to <tt>+ O(1)</tt>.
</p>

<p><i>[
Sophia Antipolis:
]</i></p>


<blockquote>
Alisdair prefers to apply an upper bound instead of O(1), but that would
require fixing for <tt>lower_bound</tt>, <tt>upper_bound</tt> etc. as well. If he really
cares about it, he'll send an issue to Howard.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 25.4.3.4 [binary.search]/3
</p>

<blockquote>
<i>Complexity:</i> At most <tt>log<ins><sub>2</sub></ins>(last - first) + <del>2</del> <ins><i>O</i>(1)</ins></tt> comparisons.
</blockquote>





<hr>
<h3><a name="788"></a>788. ambiguity in [istream.iterator]</h3>
<p><b>Section:</b> 24.6.1 [istream.iterator] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2008-02-06 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#istream.iterator">issues</a> in [istream.iterator].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 287</b></p>

<blockquote>
<p>
It is not clear what the initial state of an <tt>istream_iterator</tt> should be. Is
_value_ initialized by reading the stream, or default/value initialized? If
it is initialized by reading the stream, what happens if the initialization
is deferred until first dereference, when ideally the iterator value should
have been that of an end-of-stream iterator which is not safely
dereferencable?
</p>

<p>
Recommendation: Specify _value_ is initialized by reading the stream, or
the iterator takes on the end-of-stream value if the stream is empty.
</p>
</blockquote>

<p>
The description of how an istream_iterator object becomes an
end-of-stream iterator is a) ambiguous and b) out of date WRT
issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#468">468</a>:
</p>

<blockquote>
<tt>istream_iterator</tt> reads (using <tt>operator&gt;&gt;</tt>) successive elements from the
input stream for which it was constructed. After it is constructed, and
every time <tt>++</tt> is used, the iterator reads and stores a value of <tt>T</tt>. If
the end of stream is reached (<tt>operator void*()</tt> on the stream returns
<tt>false</tt>), the iterator becomes equal to the <i>end-of-stream</i> iterator value.
The constructor with no arguments <tt>istream_iterator()</tt> always constructs
an end of stream input iterator object, which is the only legitimate
iterator to be used for the end condition. The result of <tt>operator*</tt> on an
end of stream is not defined. For any other iterator value a <tt>const T&amp;</tt> is
returned. The result of <tt>operator-&gt;</tt> on an end of stream is not defined.
For any other iterator value a <tt>const T*</tt> is returned. It is impossible to
store things into istream iterators. The main peculiarity of the istream
iterators is the fact that <tt>++</tt> operators are not equality preserving,
that is, <tt>i == j</tt> does not guarantee at all that <tt>++i == ++j</tt>. Every time <tt>++</tt>
is used a new value is read.
</blockquote>

<p>
<tt>istream::operator void*()</tt> returns null if <tt>istream::fail()</tt> is <tt>true</tt>,
otherwise non-null. <tt>istream::fail()</tt> returns <tt>true</tt> if <tt>failbit</tt> or
<tt>badbit</tt> is set in <tt>rdstate()</tt>. Reaching the end of stream doesn't
necessarily imply that <tt>failbit</tt> or <tt>badbit</tt> is set (e.g., after
extracting an <tt>int</tt> from <tt>stringstream("123")</tt> the stream object will
have reached the end of stream but <tt>fail()</tt> is <tt>false</tt> and <tt>operator
void*()</tt> will return a non-null value).
</p>

<p>
Also I would prefer to be explicit about calling <tt>fail()</tt> here
(there is no <tt>operator void*()</tt> anymore.)
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Moved from Ready to Open for the purposes of using this issue to address NB UK 287.
Martin to handle.
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
<p>
This improves the wording.
</p>
<p>
Move to Ready.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 24.6.1 [istream.iterator]/1:
</p>

<blockquote>
<tt>istream_iterator</tt> reads (using <tt>operator&gt;&gt;</tt>) successive elements from the
input stream for which it was constructed. After it is constructed, and
every time <tt>++</tt> is used, the iterator reads and stores a value of <tt>T</tt>. If
<del>the end of stream is reached</del> <ins>the iterator fails to read and store a value of <tt>T</tt></ins>
(<tt><del>operator void*()</del> <ins>fail()</ins></tt> on the stream returns
<tt><del>false</del> <ins>true</ins></tt>), the iterator becomes equal to the <i>end-of-stream</i> iterator value.
The constructor with no arguments <tt>istream_iterator()</tt> always constructs
an end of stream input iterator object, which is the only legitimate
iterator to be used for the end condition. The result of <tt>operator*</tt> on an
end of stream is not defined. For any other iterator value a <tt>const T&amp;</tt> is
returned. The result of <tt>operator-&gt;</tt> on an end of stream is not defined.
For any other iterator value a <tt>const T*</tt> is returned. It is impossible to
store things into istream iterators. The main peculiarity of the istream
iterators is the fact that <tt>++</tt> operators are not equality preserving,
that is, <tt>i == j</tt> does not guarantee at all that <tt>++i == ++j</tt>. Every time <tt>++</tt>
is used a new value is read.
</blockquote>





<hr>
<h3><a name="789"></a>789. <tt>xor_combine_engine(result_type)</tt> should be explicit</h3>
<p><b>Section:</b> X [rand.adapt.xor] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> P.J. Plauger <b>Opened:</b> 2008-02-09 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.adapt.xor">issues</a> in [rand.adapt.xor].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>xor_combine_engine(result_type)</tt> should be <tt>explicit</tt>. (Obvious oversight.)
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
Non-controversial. Bill is right, but Fermilab believes that this is
easy to use badly and hard to use right, and so it should be removed
entirely. Got into TR1 by well defined route, do we have permission to
remove stuff? Should probably check with Jens, as it is believed he is
the originator. Broad consensus that this is not a robust engine
adapter.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Remove xor_combine_engine from synopsis of 26.5.2 [rand.synopsis].
</p>
<p>
Remove X [rand.adapt.xor] <tt>xor_combine_engine</tt>.
</p>





<hr>
<h3><a name="792"></a>792. <tt>piecewise_constant_distribution</tt> is undefined for a range with just one endpoint</h3>
<p><b>Section:</b> 26.5.8.5.2 [rand.dist.samp.pconst] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> P.J. Plauger <b>Opened:</b> 2008-02-09 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.dist.samp.pconst">issues</a> in [rand.dist.samp.pconst].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>piecewise_constant_distribution</tt> is undefined for a range with just one
endpoint. (Probably should be the same as an empty range.)
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change 26.5.8.5.2 [rand.dist.samp.pconst] paragraph 3b:
</p>

<blockquote>
b) If <tt>firstB == lastB</tt> <ins>or the sequence <tt>w</tt> has the length zero</ins>,
</blockquote>





<hr>
<h3><a name="798"></a>798. Refactoring of binders lead to interface breakage</h3>
<p><b>Section:</b> D.11 [depr.lib.binders] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2008-02-14 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#depr.lib.binders">issues</a> in [depr.lib.binders].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2521.pdf">N2521</a>
and its earlier predecessors have moved the old binders from
[lib.binders] to D.11 [depr.lib.binders] thereby introducing some renaming
of the template parameter names (<tt>Operation -&gt; Fn</tt>). During this
renaming process the <em>protected</em> data member <tt>op</tt> was also renamed to
<tt>fn</tt>, which seems as an unnecessary interface breakage to me - even if
this user access point is probably rarely used.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change D.11.1 [depr.lib.binder.1st]:
</p>

<blockquote>
<pre>template &lt;class Fn&gt; 
class binder1st 
  : public unary_function&lt;typename Fn::second_argument_type, 
                          typename Fn::result_type&gt; { 
protected: 
  Fn <del>fn</del> <ins>op</ins>; 
  typename Fn::first_argument_type value; 
public: 
  binder1st(const Fn&amp; x, 
            const typename Fn::first_argument_type&amp; y); 
  typename Fn::result_type 
    operator()(const typename Fn::second_argument_type&amp; x) const; 
  typename Fn::result_type 
    operator()(typename Fn::second_argument_type&amp; x) const; 
};
</pre>

<blockquote>
<p>
-1- The constructor initializes <del><tt>fn</tt></del> <ins><tt>op</tt></ins> with <tt>x</tt> and <tt>value</tt> with <tt>y</tt>.
</p>
<p>
-2- <tt>operator()</tt> returns <tt><del>fn</del><ins>op</ins>(value,x)</tt>.
</p>
</blockquote>
</blockquote>

<p>
Change D.11.3 [depr.lib.binder.2nd]:
</p>

<blockquote>
<pre>template &lt;class Fn&gt; 
class binder2nd
  : public unary_function&lt;typename Fn::first_argument_type, 
                          typename Fn::result_type&gt; { 
protected: 
  Fn <del>fn</del> <ins>op</ins>; 
  typename Fn::second_argument_type value; 
public: 
  binder2nd(const Fn&amp; x, 
            const typename Fn::second_argument_type&amp; y); 
  typename Fn::result_type 
    operator()(const typename Fn::first_argument_type&amp; x) const; 
  typename Fn::result_type 
    operator()(typename Fn::first_argument_type&amp; x) const; 
};
</pre>

<blockquote>
<p>
-1- The constructor initializes <del><tt>fn</tt></del> <ins><tt>op</tt></ins> with <tt>x</tt> and <tt>value</tt> with <tt>y</tt>.
</p>
<p>
-2- <tt>operator()</tt> returns <tt><del>fn</del><ins>op</ins>(value,x)</tt>.
</p>
</blockquote>
</blockquote>






<hr>
<h3><a name="801"></a>801. <tt>tuple</tt> and <tt>pair</tt> trivial members</h3>
<p><b>Section:</b> 20.4 [tuple] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> Lawrence Crowl <b>Opened:</b> 2008-02-18 <b>Last modified:</b> 2010-11-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#tuple">issues</a> in [tuple].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Classes with trivial special member functions are inherently more
efficient than classes without such functions.  This efficiency is
particularly pronounced on modern ABIs that can pass small classes
in registers.  Examples include value classes such as complex numbers
and floating-point intervals.  Perhaps more important, though, are
classes that are simple collections, like <tt>pair</tt> and <tt>tuple</tt>.  When the
parameter types of these classes are trivial, the <tt>pair</tt>s and <tt>tuple</tt>s
themselves can be trivial, leading to substantial performance wins.
</p>
<p>
The current working draft make specification of trivial functions
(where possible) much easer through <tt>default</tt>ed and <tt>delete</tt>d functions.
As long as the semantics of defaulted and deleted functions match
the intended semantics, specification of defaulted and deleted
functions will yield more efficient programs.
</p>
<p>
There are at least two cases where specification of an explicitly
defaulted function may be desirable.
</p>
<p>
First, the <tt>std::pair</tt> template has a non-trivial default constructor,
which prevents static initialization of the pair even when the
types are statically initializable.  Changing the definition to
</p>

<blockquote><pre>pair() = default;
</pre></blockquote>

<p>
would enable such initialization.  Unfortunately, the change is
not semantically neutral in that the current definition effectively
forces value initialization whereas the change would not value
initialize in some contexts.
</p>

<p>
** Does the committee confirm that forced value initialization
was the intent?  If not, does the committee wish to change the
behavior of <tt>std::pair</tt> in C++0x?
</p>
<p>
Second, the same default constructor issue applies to <tt>std::tuple</tt>.
Furthermore, the <tt>tuple</tt> copy constructor is current non-trivial,
which effectively prevents passing it in registers.  To enable
passing <tt>tuples</tt> in registers, the copy constructor should be
make explicitly <tt>default</tt>ed.  The new declarations are:
</p>

<blockquote><pre>tuple() = default;
tuple(const tuple&amp;) = default;
</pre></blockquote>

<p>
This changes is not implementation neutral.  In particular, it
prevents implementations based on pointers to the parameter
types.  It does however, permit implementations using the
parameter types as bases.
</p>
<p>
** How does the committee wish to trade implementation
efficiency versus implementation flexibility?
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
<p>
General agreement; the first half of the issue is NAD.
</p>
<p>
Before voting on the second half, it was agreed that a "Strongly Favor"
vote meant support for trivial tuples (assuming usual requirements met),
even at the expense of other desired qualities. A "Weakly Favor" vote
meant support only if not at the expense of other desired qualities.
</p>
<p>
Concensus: Go forward, but not at expense of other desired qualities.
</p>
<p>
It was agreed to Alisdair should fold this work in with his other
pair/tuple action items, above, and that issue 801 should be "open", but
tabled until Alisdair's proposals are disposed of.
</p>
</blockquote>

<p><i>[
2009-05-27 Daniel adds:
]</i></p>


<blockquote>
This is partly solved by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1117">1117</a>.
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
Wait for dust to settle from fixing exception safety problem
with rvalue refs.
</blockquote>

<p><i>[
2009-07-20 Alisdair adds:
]</i></p>


<blockquote>
<p>
Basically, this issue is what should we do with the default constructor
for pairs and tuples of trivial types.  The motivation of the issue was
to force static initialization rather than dynamic initialization, and
was rejected in the case of pair as it would change the meaning of
existing programs.  The advice was "do the best we can" for tuple
without changing existing meaning.
</p>

<p>
Frankfurt seems to simply wait and see the resolution on no-throw move
constructors, which (I believe) is only tangentially related to this
issue, but as good as any to defer until Santa Cruz.
</p>

<p>
Looking again now, I think constant (static) initialization for pair can
be salvaged by making the default construct constexpr.  I have a
clarification from Core that this is intended to work, even if the
constructor is not trivial/constexpr, so long as no temporaries are
implied in the process (even if elided).
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Leave as open. Alisdair to provide wording.
</blockquote>

<p><i>[
2010 Pittsburgh:
]</i></p>


<blockquote>
<p>
We believe this may be NAD Editorial since both pair and tuple now have
constexpr default constructors, but we're not sure.
</p>
</blockquote>


<p><i>[
2010 Rapperswil:
]</i></p>


<blockquote>
Daniel believes his pair/tuple paper will resolve this issue. <tt>constexpr</tt> will allow static initialization, and he is already changing the move and copy constructors to be defaulted.
</blockquote>

<p><i>[
2010-10-24 Daniel adds:
]</i></p>


<blockquote>
The proposed resolution of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3140.html">n3140</a> should resolve this issue.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3140.html">n3140</a>.
</p>





<hr>
<h3><a name="804"></a>804. Some problems with classes <tt>error_code</tt>/<tt>error_condition</tt></h3>
<p><b>Section:</b> 19.5 [syserr] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2008-02-24 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#syserr">issues</a> in [syserr].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<ol type="A">
<li>
<p>
19.5.2.1 [syserr.errcode.overview]/1, class <tt>error_code</tt> and
19.5.3.1 [syserr.errcondition.overview]/, class <tt>error_condition</tt> synopses
declare an expository data member <tt>cat_</tt>:
</p>
<blockquote><pre>const error_category&amp; cat_; // exposition only
</pre></blockquote>
<p>
which is used to define the semantics of several members. The decision
to use a member of reference type lead to several problems:
</p>
<ol>
<li>
The classes are not <tt>(Copy)Assignable</tt>, which is probably not the intent.
</li>
<li>
The post conditions of all modifiers from
19.5.2.3 [syserr.errcode.modifiers] and 19.5.3.3 [syserr.errcondition.modifiers], resp.,
cannot be fulfilled.
</li>
</ol>
<p>
The simple fix would be to replace the reference by a pointer member.
</p>
</li>

<li>
I would like to give the editorial remark that in both classes the
constrained <tt>operator=</tt>
overload (template with <tt>ErrorCodeEnum</tt> argument) makes in invalid
usage of <tt>std::enable_if</tt>: By using the default value for the second <tt>enable_if</tt>
parameter the return type would be defined to be <tt>void&amp;</tt> even in otherwise
valid circumstances - this return type must be explicitly provided (In
<tt>error_condition</tt> the first declaration uses an explicit value, but of wrong
type).
</li>

<li>
The member function <tt>message</tt> throws clauses (
19.5.1.2 [syserr.errcat.virtuals]/10, 19.5.2.4 [syserr.errcode.observers]/8, and
19.5.3.4 [syserr.errcondition.observers]/6) guarantee "throws nothing",
although
they return a <tt>std::string</tt> by value, which might throw in out-of-memory
conditions (see related issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#771">771</a>).
</li>
</ol>

<p><i>[
Sophia Antipolis:
]</i></p>


<blockquote>
<p>
Part A: NAD (editorial), cleared by the resolution of issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#832">832</a>.
</p>
<p>
Part B: Technically correct, save for typo. Rendered moot by the concept proposal 
(<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2620.html">N2620</a>) NAD (editorial).
</p>
<p>
Part C: We agree; this is consistent with the resolution of issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#721">721</a>.
</p>
<p>
Howard: please ping Beman, asking him to clear away parts A and B from
the wording in the proposed resolution, so it is clear to the editor
what needs to be applied to the working paper.
</p>
<p>
Beman provided updated wording. Since issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#832">832</a> is not going
forward, the provided wording includes resolution of part A.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>

<p>
Resolution of part A:
</p>
<blockquote>
<p>
Change 19.5.2.1 [syserr.errcode.overview] Class error_code overview synopsis as indicated:
</p>

<blockquote><pre>private:
  int val_;                    // exposition only
  const error_category<del>&amp;</del><ins>*</ins> cat_; // exposition only
</pre></blockquote>

<p>
Change 19.5.2.2 [syserr.errcode.constructors] Class error_code constructors as indicated:
</p>

<blockquote>
<pre>error_code();
</pre>
<blockquote>
<p>
<i>Effects:</i> Constructs an object of type <tt>error_code</tt>.
</p>
<p>
<i>Postconditions:</i> <tt>val_ == 0</tt> and <tt>cat_ == <ins>&amp;</ins>system_category</tt>.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
<pre>error_code(int val, const error_category&amp; cat);
</pre>
<blockquote>
<p>
<i>Effects:</i> Constructs an object of type <tt>error_code</tt>.
</p>
<p>
<i>Postconditions:</i> <tt>val_ == val</tt> and <tt>cat_ == <ins>&amp;</ins>cat</tt>.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<p>
Change 19.5.2.3 [syserr.errcode.modifiers] Class error_code modifiers as indicated:
</p>

<blockquote>
<pre>void assign(int val, const error_category&amp; cat);
</pre>
<blockquote>
<p>
<i>Postconditions:</i> <tt>val_ == val</tt> and <tt>cat_ == <ins>&amp;</ins>cat</tt>.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<p>
Change 19.5.2.4 [syserr.errcode.observers] Class error_code observers as indicated:
</p>

<blockquote>
const error_category&amp; category() const;
<blockquote>
<p>
<i>Returns:</i> <tt><ins>*</ins>cat_</tt>.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<p>
Change 19.5.3.1 [syserr.errcondition.overview] Class error_condition overview synopsis as indicated:
</p>

<blockquote><pre>private:
  int val_;                    // exposition only
  const error_category<del>&amp;</del><ins>*</ins> cat_; // exposition only
</pre></blockquote>

<p>
Change 19.5.3.2 [syserr.errcondition.constructors] Class error_condition constructors as indicated:
</p>
<p><i>[
(If the proposed resolution of issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#805">805</a> has already been applied, the
name <tt>posix_category</tt> will have been changed to <tt>generic_category</tt>. That has
no effect on this resolution.)
]</i></p>


<blockquote>
<pre>error_condition();
</pre>
<blockquote>
<p>
<i>Effects:</i> Constructs an object of type <tt>error_condition</tt>.
</p>
<p>
<i>Postconditions:</i> <tt>val_ == 0</tt> and <tt>cat_ == <ins>&amp;</ins>posix_category</tt>.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
<pre>error_condition(int val, const error_category&amp; cat);
</pre>
<blockquote>
<p>
<i>Effects:</i> Constructs an object of type <tt>error_condition</tt>.
</p>
<p>
<i>Postconditions:</i> <tt>val_ == val</tt> and <tt>cat_ == <ins>&amp;</ins>cat</tt>.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<p>
Change 19.5.3.3 [syserr.errcondition.modifiers] Class error_condition modifiers as indicated:
</p>

<blockquote>
void assign(int val, const error_category&amp; cat);
<blockquote>
<p>
<i>Postconditions:</i> <tt>val_ == val</tt> and <tt>cat_ == <ins>&amp;</ins>cat</tt>.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<p>
Change 19.5.3.4 [syserr.errcondition.observers] Class error_condition observers as indicated:
</p>

<blockquote>
const error_category&amp; category() const;
<blockquote>
<p>
<i>Returns:</i> <tt><ins>*</ins>cat_</tt>.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>
</blockquote>

<p>
Resolution of part C:
</p>

<blockquote>

<p>
In 19.5.1.2 [syserr.errcat.virtuals], remove the throws clause p. 10.
</p>

<blockquote>
<pre>virtual string message(int ev) const = 0;
</pre>

<blockquote>
<p>
<i>Returns:</i> A string that describes the error condition denoted by <tt>ev</tt>.
</p>
<p>
<del><i>Throws:</i> Nothing.</del>
</p>
</blockquote>
</blockquote>

<p>
In 19.5.2.4 [syserr.errcode.observers], remove the throws clause p. 8.
</p>

<blockquote>
<pre>string message() const;
</pre>
<blockquote>
<p>
<i>Returns:</i> <tt>category().message(value())</tt>.
</p>
<p>
<del><i>Throws:</i> Nothing.</del>
</p>
</blockquote>
</blockquote>

<p>
In 19.5.3.4 [syserr.errcondition.observers], remove the throws clause p. 6.
</p>

<blockquote>
<pre>string message() const;
</pre>
<blockquote>
<p>
<i>Returns:</i> <tt>category().message(value())</tt>.
</p>
<p>
<del><i>Throws:</i> Nothing.</del>
</p>
</blockquote>
</blockquote>

</blockquote>






<hr>
<h3><a name="805"></a>805. <tt>posix_error::posix_errno</tt> concerns</h3>
<p><b>Section:</b> 19.5 [syserr] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Jens Maurer <b>Opened:</b> 2008-02-24 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#syserr">issues</a> in [syserr].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
19.5 [syserr]
</p>

<blockquote><pre>namespace posix_error {
  enum posix_errno {
    address_family_not_supported, // EAFNOSUPPORT
    ...
</pre></blockquote>

<p>
should rather use the new scoped-enum  facility (7.2 [dcl.enum]),
which would avoid the necessity for a new <tt>posix_error</tt>
namespace, if I understand correctly.
</p>

<p><i>[
Further discussion:
]</i></p>


<blockquote>
<p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2347.pdf">N2347</a>,
Strongly Typed Enums, since renamed Scoped Enums.
</p>
<p>
Alberto Ganesh Barbati also raised this issue in private email, and also proposed the scoped-enum solution.
</p>
<p>
Nick Stoughton asked in Bellevue that <tt>posix_error</tt> and <tt>posix_errno</tt> not be used as names. The LWG agreed.
</p>
<p>
The wording for the Proposed resolution was provided by Beman Dawes.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change System error support 19.5 [syserr] as indicated:
</p>

<blockquote><pre><del>namespace posix_error {</del>
  enum <del>posix_errno</del> <ins>class errc</ins> {
    address_family_not_supported, // EAFNOSUPPORT
    ...
    wrong_protocol_type, // EPROTOTYPE
  };
<del>} // namespace posix_error</del>

template &lt;&gt; struct is_error_condition_enum&lt;<del>posix_error::posix_errno</del> <ins>errc</ins>&gt;
  : public true_type {}

<del>namespace posix_error {</del>
  error_code make_error_code(<del>posix_errno</del> <ins>errc</ins> e);
  error_condition make_error_condition(<del>posix_errno</del> <ins>errc</ins> e);
<del>} // namespace posix_error</del>
</pre></blockquote>

<p>
Change System error support 19.5 [syserr] :
</p>

<blockquote>
<del>The <tt>is_error_code_enum</tt> and <tt>is_error_condition_enum</tt> templates may be
specialized for user-defined types to indicate that such a type is
eligible for class <tt>error_code</tt> and class <tt>error_condition</tt> automatic
conversions, respectively.</del>
</blockquote>

<p>
Change System error support 19.5 [syserr] and its subsections:
</p>

<blockquote>
<ul>
<li>
remove all occurrences of <tt>posix_error::</tt>
</li>
<li>
change all instances of <tt>posix_errno</tt> to <tt>errc</tt>
</li>
<li>
change all instances of <tt>posix_category</tt> to <tt>generic_category</tt>
</li>
<li>
change all instances of <tt>get_posix_category</tt> to <tt>get_generic_category</tt>
</li>
</ul>
</blockquote>

<p>
Change Error category objects 19.5.1.5 [syserr.errcat.objects], paragraph 2:
</p>

<blockquote>
<i>Remarks:</i> The object's <tt>default_error_condition</tt> and equivalent virtual
functions shall behave as specified for the class <tt>error_category</tt>. The
object's name virtual function shall return a pointer to the string
<del>"POSIX"</del> <ins>"generic"</ins>.
</blockquote>

<p>
Change 19.5.2.5 [syserr.errcode.nonmembers] Class <tt>error_code</tt> non-member functions as indicated:
</p>

<blockquote>
<pre>error_code make_error_code(<del>posix_errno</del> <ins>errc</ins> e);
</pre>

<blockquote>
<i>Returns:</i> <tt>error_code(<ins>static_cast&lt;int&gt;(</ins>e<ins>)</ins>, <del>posix</del><ins>generic</ins>_category)</tt>.
</blockquote>
</blockquote>

<p>
Change 19.5.3.5 [syserr.errcondition.nonmembers] Class <tt>error_condition</tt> non-member functions as indicated:
</p>

<blockquote>
<pre>error_condition make_error_condition(<del>posix_errno</del> <ins>errc</ins> e);
</pre>

<blockquote>
<i>Returns:</i> <tt>error_condition(<ins>static_cast&lt;int&gt;(</ins>e<ins>)</ins>, <del>posix</del><ins>generic</ins>_category)</tt>.
</blockquote>
</blockquote>



<p><b>Rationale:</b></p>
<table border="1">
<tbody><tr>
<th colspan="2">Names Considered</th>
</tr>

<tr>
<td><tt>portable</tt></td>
<td>
Too non-specific. Did not wish to reserve such a common word in
namespace std. Not quite the right meaning, either.
</td>
</tr>

<tr>
<td><tt>portable_error</tt></td>
<td>
Too long. Explicit qualification is always required for scoped enums, so
a short name is desirable. Not quite the right meaning, either. May be
misleading because <tt>*_error</tt> in the std lib is usually an exception class
name.
</td>
</tr>

<tr>
<td><tt>std_error</tt></td>
<td>
Fairly short, yet explicit. But in fully qualified names like
<tt>std::std_error::not_enough_memory</tt>, the std_ would be unfortunate. Not
quite the right meaning, either. May be misleading because <tt>*_error</tt> in
the std lib is usually an exception class name.
</td>
</tr>

<tr>
<td><tt>generic</tt></td>
<td>
Short enough. The category could be <tt>generic_category</tt>. Fully qualified
names like <tt>std::generic::not_enough_memory</tt> read well. Reserving in
namespace std seems dicey.
</td>
</tr>

<tr>
<td><tt>generic_error</tt></td>
<td>
Longish. The category could be <tt>generic_category</tt>. Fully qualified names
like <tt>std::generic_error::not_enough_memory</tt> read well. Misleading because
<tt>*_error</tt> in the std lib is usually an exception class name.
</td>
</tr>

<tr>
<td><tt>generic_err</tt></td>
<td>
A bit less longish. The category could be <tt>generic_category</tt>. Fully
qualified names like <tt>std::generic_err::not_enough_memory</tt> read well.
</td>
</tr>

<tr>
<td><tt>gen_err</tt></td>
<td>
Shorter still. The category could be <tt>generic_category</tt>. Fully qualified
names like <tt>std::gen_err::not_enough_memory</tt> read well.
</td>
</tr>

<tr>
<td><tt>generr</tt></td>
<td>
Shorter still. The category could be <tt>generic_category</tt>. Fully qualified
names like <tt>std::generr::not_enough_memory</tt> read well.
</td>
</tr>

<tr>
<td><tt>error</tt></td>
<td>
Shorter still. The category could be <tt>generic_category</tt>. Fully qualified
names like <tt>std::error::not_enough_memory</tt> read well. Do we want to use
this general a name?
</td>
</tr>

<tr>
<td><tt>err</tt></td>
<td>
Shorter still. The category could be <tt>generic_category</tt>. Fully qualified
names like <tt>std::err::not_enough_memory</tt> read well. Although alone it
looks odd as a name, given the existing <tt>errno</tt> and <tt>namespace std</tt> names,
it seems fairly intuitive.
Problem: <tt>err</tt> is used throughout the standard library as an argument name
and in examples as a variable name; it seems too confusing to add yet
another use of the name.
</td>
</tr>

<tr>
<td><tt>errc</tt></td>
<td>
Short enough. The "c" stands for "constant". The category could be
<tt>generic_category</tt>. Fully qualified names like
<tt>std::errc::not_enough_memory</tt> read well. Although alone it looks odd as a
name, given the existing <tt>errno</tt> and <tt>namespace std</tt> names, it seems fairly
intuitive. There are no uses of <tt>errc</tt> in the current C++ standard.
</td>
</tr>
</tbody></table>





<hr>
<h3><a name="806"></a>806. <tt>unique_ptr::reset</tt> effects incorrect, too permissive</h3>
<p><b>Section:</b> 20.9.9.2.5 [unique.ptr.single.modifiers] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Peter Dimov <b>Opened:</b> 2008-03-13 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#unique.ptr.single.modifiers">issues</a> in [unique.ptr.single.modifiers].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>void unique_ptr::reset(T* p = 0)</tt> is currently specified as:
</p>

<blockquote>
<i>Effects:</i> If <tt>p == get()</tt> there are no effects. Otherwise <tt>get_deleter()(get())</tt>.
</blockquote>

<p>
There are two problems with this. One, if <tt>get() == 0</tt> and <tt>p != 0</tt>, the
deleter is called with a NULL pointer, and this is probably not what's
intended (the destructor avoids calling the deleter with 0.)
</p>

<p>
Two, the special check for <tt>get() == p</tt> is generally not needed and such a
situation usually indicates an error in the client code, which is being
masked. As a data point, <tt>boost::shared_ptr</tt> was changed to assert on such
self-resets in 2001 and there were no complaints.
</p>

<p>
One might think that self-resets are necessary for operator= to work; it's specified to perform
</p>

<blockquote><pre>reset( u.release() );
</pre></blockquote>

<p>
and the self-assignment
</p>

<blockquote><pre>p = move(p);
</pre></blockquote>

<p>
might appear to result in a self-reset. But it doesn't; the <tt>release()</tt> is
performed first, zeroing the stored pointer. In other words, <tt>p.reset(
q.release() )</tt> works even when <tt>p</tt> and <tt>q</tt> are the same <tt>unique_ptr</tt>, and there
is no need to special-case <tt>p.reset( q.get() )</tt> to work in a similar
scenario, as it definitely doesn't when <tt>p</tt> and <tt>q</tt> are separate.
</p>



<p><b>Proposed resolution:</b></p>

<p>
Change 20.9.9.2.5 [unique.ptr.single.modifiers]:
</p>

<blockquote>
<pre>void reset(T* p = 0);
</pre>
<blockquote>
-4- <i>Effects:</i> If <tt><del>p ==</del> get()<ins> == 0</ins></tt> there are no effects. Otherwise <tt>get_deleter()(get())</tt>.
</blockquote>
</blockquote>

<p>
Change 20.9.9.3.3 [unique.ptr.runtime.modifiers]:
</p>

<blockquote>
<pre>void reset(T* p = 0);
</pre>
<blockquote>
<p>...</p>
<p>
-2- <i>Effects:</i> If <tt><del>p ==</del> get()<ins> == 0</ins></tt> there are no effects. Otherwise <tt>get_deleter()(get())</tt>.
</p>
</blockquote>
</blockquote>






<hr>
<h3><a name="807"></a>807. <tt>tuple</tt> construction should not fail unless its element's construction fails</h3>
<p><b>Section:</b> 20.4.2.1 [tuple.cnstr] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2008-03-13 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#tuple.cnstr">issues</a> in [tuple.cnstr].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#527">527</a> Added a throws clause to <tt>bind</tt> constructors.  I believe the same throws clause
should be added to <tt>tuple</tt> except it ought to take into account move constructors as well.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add to 20.4.2.1 [tuple.cnstr]:
</p>

<blockquote>
<p>
For each <tt>tuple</tt> constructor and assignment operator, an exception is thrown only if the construction
or assignment of one of the types in <tt>Types</tt> throws an exception.
</p>
</blockquote>





<hr>
<h3><a name="808"></a>808. [forward] incorrect redundant specification</h3>
<p><b>Section:</b> 20.3.3 [forward] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Jens Maurer <b>Opened:</b> 2008-03-13 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#forward">issues</a> in [forward].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
p4 (forward) says:
</p>
<blockquote>
<i>Return type:</i> If <tt>T</tt> is an lvalue-reference type, an lvalue; otherwise, an rvalue.
</blockquote>

<p>
First of all, lvalue-ness and rvalue-ness are properties of an expression,
not of a type (see 3.10 [basic.lval]).  Thus, the phrasing "Return type" is wrong.
Second, the phrase says exactly what the core language wording says for
folding references in 14.3.1 [temp.arg.type]/p4  and for function return values
in 5.2.2 [expr.call]/p10.  (If we feel the wording should be retained, it should
at most be a note with cross-references to those sections.)
</p>
<p>
The prose after the example talks about "forwarding as an <tt>int&amp;</tt> (an lvalue)" etc.
In my opinion, this is a category error:  "<tt>int&amp;</tt>" is a type, "lvalue" is a
property of an expression, orthogonal to its type.  (Btw, expressions cannot
have reference type, ever.)
</p>
<p>
Similar with move:
</p>
<blockquote>
Return type: an rvalue.
</blockquote>
<p>
is just wrong and also redundant.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change 20.3.3 [forward] as indicated:
</p>

<blockquote>
<pre>template &lt;class T&gt; T&amp;&amp; forward(typename identity&lt;T&gt;::type&amp;&amp; t);
</pre>

<blockquote>
<p>...</p>
<p>
<del><i>Return type:</i> If <tt>T</tt> is an lvalue-reference type, an lvalue; otherwise, an rvalue.</del>
</p>
<p>...</p>
<p>
-7- In the first call to <tt>factory</tt>, <tt>A1</tt> is deduced as <tt>int</tt>, so 2 is forwarded to <tt>A</tt>'s constructor
as <del>an <tt>int&amp;&amp;</tt> (</del>an rvalue<del>)</del>. In the second call to factory, <tt>A1</tt> is deduced
as <tt>int&amp;</tt>, so <tt>i</tt> is forwarded to <tt>A</tt>'s constructor as <del>an <tt>int&amp;</tt> (</del>an lvalue<del>)</del>.
In both cases, <tt>A2</tt> is deduced as double, so 1.414 is forwarded to <tt>A</tt>'s constructor as
<del><tt>double&amp;&amp;</tt> (</del>an rvalue<del>)</del>.
</p>
</blockquote>

<pre>template &lt;class T&gt; typename remove_reference&lt;T&gt;::type&amp;&amp; move(T&amp;&amp; t);
</pre>

<blockquote>
<p>...</p>
<p>
<del><i>Return type:</i>  an rvalue.</del>
</p>
</blockquote>

</blockquote>






<hr>
<h3><a name="809"></a>809. std::swap should be overloaded for array types</h3>
<p><b>Section:</b> 25.3.3 [alg.swap] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Niels Dekker <b>Opened:</b> 2008-02-28 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.swap">issues</a> in [alg.swap].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
For the sake of generic programming, the header <code>&lt;algorithm&gt;</code> should provide an
overload of <code>std::swap</code> for array types:
</p><pre>template&lt;class T, size_t N&gt; void swap(T (&amp;a)[N], T (&amp;b)[N]);
</pre>
<p></p>

<p>
It became apparent to me that this overload is missing, when I considered how to write a swap
function for a generic wrapper class template.
(Actually I was thinking of Boost's <a href="http://www.boost.org/libs/utility/value_init.htm">value_initialized</a>.)
Please look at the following template, <code>W</code>, and suppose that is intended to be a very
<em>generic</em> wrapper:
</p><pre>template&lt;class T&gt; class W {
public:
   T data;
};
</pre>
Clearly <code>W&lt;T&gt;</code> is <em>CopyConstructible and CopyAssignable</em>, and therefore
<em>Swappable</em>, whenever <code>T</code> is <em>CopyConstructible and CopyAssignable</em>.
Moreover, <code>W&lt;T&gt;</code> is <em>also</em> Swappable when <code>T</code> is an array type
whose element type is CopyConstructible and CopyAssignable.
Still it is recommended to add a <em>custom</em> swap function template to such a class template,
for the sake of efficiency and exception safety.
(E.g., <em>Scott Meyers, Effective C++, Third Edition, item 25: Consider support for a non-throwing
swap</em>.)
This function template is typically written as follows:
<pre>template&lt;class T&gt; void swap(W&lt;T&gt;&amp; x, W&lt;T&gt;&amp; y) {
  using std::swap;
  swap(x.data, y.data);
}
</pre>
Unfortunately, this will introduce an undesirable inconsistency, when <code>T</code> is an array.
For instance, <code>W&lt;std::string[8]&gt;</code> is Swappable, but the current Standard does not
allow calling the custom swap function that was especially written for <code>W</code>!
<pre>W&lt;std::string[8]&gt; w1, w2;  // Two objects of a Swappable type.
std::swap(w1, w2);  // Well-defined, but inefficient.
using std::swap;
swap(w1, w2);  // Ill-formed, just because ADL finds W's swap function!!!
</pre>

<code>W</code>'s <code>swap</code> function would try to call <code>std::swap</code> for an array,
<code>std::string[8]</code>, which is not supported by the Standard Library.
This issue is easily solved by providing an overload of <code>std::swap</code> for array types.
This swap function should be implemented in terms of swapping the elements of the arrays, so that
it would be non-throwing for arrays whose element types have a non-throwing swap.
<p></p>

<p>
Note that such an overload of <code>std::swap</code> should also support <em>multi-dimensional</em>
arrays. Fortunately that isn't really an issue, because it would do so <i>automatically</i>, by
means of recursion.
</p>

<p>
For your information, there was a discussion on this issue at comp.lang.c++.moderated: <a href="http://groups.google.com/group/comp.lang.c++.moderated/browse_thread/thread/9341ebd3635c9c74">[Standard
Library] Shouldn't std::swap be overloaded for C-style arrays?</a>
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add an extra condition to the definition of Swappable requirements [swappable] in 20.2.1 [utility.arg.requirements]:
</p>
<blockquote>
- <tt>T</tt> is <tt>Swappable</tt> if <tt>T</tt> is an array type whose element type is <tt>Swappable</tt>.
</blockquote>
<p>
Add the following to 25.3.3 [alg.swap]:
</p>
<blockquote>
<pre>template&lt;class T, size_t N&gt; void swap(T (&amp;a)[N], T (&amp;b)[N]);
</pre>
<blockquote>
<i>Requires:</i> Type <code>T</code> shall be <tt>Swappable</tt>.
</blockquote>
<blockquote>
<i>Effects:</i> <code>swap_ranges(a, a + N, b);</code>
</blockquote>
</blockquote>





<hr>
<h3><a name="810"></a>810. Missing traits dependencies in operational semantics of extended manipulators</h3>
<p><b>Section:</b> 27.7.4 [ext.manip] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2008-03-01 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#ext.manip">issues</a> in [ext.manip].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The recent draft (as well as the original proposal n2072) uses an
operational semantic
for <tt>get_money</tt> ([ext.manip]/4) and <tt>put_money</tt> ([ext.manip]/6), which uses
</p>

<blockquote><pre>istreambuf_iterator&lt;charT&gt;
</pre></blockquote>

<p>
and
</p>

<blockquote><pre>ostreambuf_iterator&lt;charT&gt;
</pre></blockquote>

<p>
resp, instead of the iterator instances, with explicitly provided
traits argument (The operational semantic defined by <tt>f</tt> is also traits
dependent). This is an obvious oversight because both <tt>*stream_buf</tt>
c'tors expect a <tt>basic_streambuf&lt;charT,traits&gt;</tt> as argument.
</p>
<p>
The same problem occurs within the <tt>get_time</tt> and <tt>put_time</tt> semantic 
where additional to the problem we
have an editorial issue in <tt>get_time</tt> (<tt>streambuf_iterator</tt> instead of
<tt>istreambuf_iterator</tt>).
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
This appears to be an issue of presentation.
</p>
<p>
We agree with the proposed resolution.
Move to Tentatively Ready.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
In 27.7.4 [ext.manip]/4 within function <tt>f</tt> replace the first line
</p>

<blockquote><pre>template &lt;class charT, class traits, class moneyT&gt; 
void f(basic_ios&lt;charT, traits&gt;&amp; str, moneyT&amp; mon, bool intl) { 
   typedef istreambuf_iterator&lt;charT<ins>, traits</ins>&gt; Iter;
   ...
</pre></blockquote>

<p>
In 27.7.4 [ext.manip]/5 remove the first template <tt>charT</tt> parameter:
</p>

<blockquote><pre>template &lt;<del>class charT, </del>class moneyT&gt; unspecified put_money(const moneyT&amp; mon, bool intl = false<ins>)</ins>;
</pre></blockquote>

<p>
In 27.7.4 [ext.manip]/6 within function <tt>f</tt> replace the first line
</p>

<blockquote><pre>template &lt;class charT, class traits, class moneyT&gt; 
void f(basic_ios&lt;charT, traits&gt;&amp; str, const moneyT&amp; mon, bool intl) { 
  typedef ostreambuf_iterator&lt;charT<ins>, traits</ins>&gt; Iter;
  ...
</pre></blockquote>

<p>
In 27.7.4 [ext.manip]/8 within function <tt>f</tt> replace the first line
</p>

<blockquote><pre>template &lt;class charT, class traits&gt; 
void f(basic_ios&lt;charT, traits&gt;&amp; str, struct tm *tmb, const charT *fmt) { 
  typedef <ins>i</ins>streambuf_iterator&lt;charT<ins>, traits</ins>&gt; Iter;
  ...
</pre></blockquote>

<p>
In 27.7.4 [ext.manip]/10 within function <tt>f</tt> replace the first line
</p>

<blockquote><pre>template &lt;class charT, class traits&gt; 
void f(basic_ios&lt;charT, traits&gt;&amp; str, const struct tm *tmb, const charT *fmt) { 
  typedef ostreambuf_iterator&lt;charT<ins>, traits</ins>&gt; Iter;
  ...
</pre></blockquote>

<p>
In 27.7 [iostream.format], Header <tt>&lt;iomanip&gt;</tt> synopsis change:
</p>

<blockquote><pre>template &lt;<del>class charT, </del>class moneyT&gt; T8 put_money(const moneyT&amp; mon, bool intl = false);
</pre></blockquote>





<hr>
<h3><a name="811"></a>811. <tt>pair</tt> of pointers no longer works with literal 0</h3>
<p><b>Section:</b> 20.3.5 [pairs] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Doug Gregor <b>Opened:</b> 2008-03-14 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#pairs">issues</a> in [pairs].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<blockquote><pre>#include &lt;utility&gt;

int main()
{
   std::pair&lt;char *, char *&gt; p (0,0);
}
</pre></blockquote>

<p>
I just got a bug report about that, because it's valid C++03, but not
C++0x. The important realization, for me, is that the emplace
proposal---which made <tt>push_back</tt> variadic, causing the <tt>push_back(0)</tt>
issue---didn't cause this break in backward compatibility. The break
actually happened when we added this pair constructor as part of adding
rvalue references into the language, long before variadic templates or
emplace came along:
</p>

<blockquote><pre>template&lt;class U, class V&gt; pair(U&amp;&amp; x, V&amp;&amp; y);
</pre></blockquote>

<p>
Now, concepts will address this issue by constraining that <tt>pair</tt>
constructor to only <tt>U</tt>'s and <tt>V</tt>'s that can properly construct "first" and
"second", e.g. (from
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2322.pdf">N2322</a>):
</p>

<blockquote><pre>template&lt;class U , class V &gt;
requires Constructible&lt;T1, U&amp;&amp;&gt; &amp;&amp; Constructible&lt;T2, V&amp;&amp;&gt;
pair(U&amp;&amp; x , V&amp;&amp; y );
</pre></blockquote>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
<p>
Suggested to resolve using pass-by-value for that case.
</p>
<p>
Side question: Should pair interoperate with tuples? Can construct a
tuple of a pair, but not a pair from a two-element tuple.
</p>
<p>
Related to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#885">885</a>.
</p>
</blockquote>

<p><i>[
2009-07-28 Reopened by Alisdair.  No longer solved by concepts.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Leave as open. Howard to provide wording.
</blockquote>

<p><i>[
2010-02-06 Howard provided wording.
]</i></p>


<p><i>[
2010-02-09 Moved to Tentatively Ready after 6 positive votes on c++std-lib.
]</i></p>




<p><b>Rationale:</b></p>
<p><i>[
San Francisco:
]</i></p>


<blockquote>
Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2770.pdf">N2770</a>.
</blockquote>

<p><i>[
The rationale is obsolete.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
Add a paragraph to 20.3.5 [pairs]:
</p>

<blockquote>
<pre>template&lt;class U, class V&gt; pair(U&amp;&amp; x, V&amp;&amp; y);
</pre>
<blockquote>
<p>
6 <i>Effects:</i> The constructor initializes <tt>first</tt> with
<tt>std::forward&lt;U&gt;(x)</tt> and second with
<tt>std::forward&lt;V&gt;(y)</tt>.
</p>

<p>
<ins><i>Remarks:</i> <tt>U</tt> shall be implicitly convertible to
<tt>first_type</tt> and <tt>V</tt> shall be implicitly convertible to
<tt>second_type</tt>, else this constructor shall not participate in overload
resolution.</ins>
</p>
</blockquote>
</blockquote>






<hr>
<h3><a name="813"></a>813. "empty" undefined for <tt>shared_ptr</tt></h3>
<p><b>Section:</b> 20.9.10.2 [util.smartptr.shared] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2008-02-26 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#util.smartptr.shared">issues</a> in [util.smartptr.shared].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Several places in 20.9.10.2 [util.smartptr.shared] refer to an "empty" <tt>shared_ptr</tt>.
However, that term is nowhere defined. The closest thing we have to a
definition is that the default constructor creates an empty <tt>shared_ptr</tt>
and that a copy of a default-constructed <tt>shared_ptr</tt> is empty. Are any
other <tt>shared_ptr</tt>s empty? For example, is <tt>shared_ptr((T*) 0)</tt> empty? What
are the properties of an empty <tt>shared_ptr</tt>? We should either clarify this
term or stop using it.
</p><p>
</p>
One reason it's not good enough to leave this term up to the reader's
intuition is that, in light of
<a href="http://www.open-std.org/JTC1/sc22/WG21/docs/papers/2007/n2351.htm">N2351</a>
and issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#711">711</a>, most readers'
intuitive understanding is likely to be wrong. Intuitively one might
expect that an empty <tt>shared_ptr</tt> is one that doesn't store a pointer,
but, whatever the definition is, that isn't it.
<p></p>

<p><i>[
Peter adds:
]</i></p>


<blockquote>
<p>
Or, what is an "empty" <tt>shared_ptr</tt>?
</p>

<ul>
<li>
<p>
Are any other <tt>shared_ptrs</tt> empty?
</p>
<p>
Yes. Whether a given <tt>shared_ptr</tt> instance is empty or not is (*)
completely specified by the last mutating operation on that instance.
Give me an example and I'll tell you whether the <tt>shared_ptr</tt> is empty or
not.
</p>
<blockquote>
(*) If it isn't, this is a legitimate defect.
</blockquote>
</li>

<li>
<p>
For example, is <tt>shared_ptr((T*) 0)</tt> empty?
</p>
<p>
No. If it were empty, it would have a <tt>use_count()</tt> of 0, whereas it is
specified to have an <tt>use_count()</tt> of 1.
</p>
</li>

<li>
<p>
What are the properties of an empty <tt>shared_ptr</tt>?
</p>
<p>
The properties of an empty <tt>shared_ptr</tt> can be derived from the
specification. One example is that its destructor is a no-op. Another is
that its <tt>use_count()</tt> returns 0. I can enumerate the full list if you
really like.
</p>
</li>

<li>
<p>
We should either clarify this term or stop using it.
</p>
<p>
I don't agree with the imperative tone
</p>
<p>
A clarification would be either a no-op - if it doesn't contradict the
existing wording - or a big mistake if it does.
</p>
<p>
I agree that a clarification that is formally a no-op may add value.
</p>
</li>

<li>
<p>
However, that term is nowhere defined.
</p>
<p>
Terms can be useful without a definition. Consider the following
simplistic example. We have a type <tt>X</tt> with the following operations
defined:
</p>
<blockquote><pre>X x;
X x2(x);
X f(X x);
X g(X x1, X x2);
</pre></blockquote>
<p>
A default-constructed value is green.<br>
A copy has the same color as the original.<br>
<tt>f(x)</tt> returns a red value if the argument is green, a green value otherwise.<br>
<tt>g(x1,x2)</tt> returns a green value if the arguments are of the same color, a red value otherwise.
</p>

<p>
Given these definitions, you can determine the color of every instance
of type <tt>X</tt>, even if you have absolutely no idea what green and red mean.
</p>

<p>
Green and red are "nowhere defined" and completely defined at the same time.
</p>
</li>
</ul>

<p>
Alisdair's wording is fine.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Append the following sentance to 20.9.10.2 [util.smartptr.shared]
</p>
<blockquote>
The <code>shared_ptr</code> class template stores a pointer, usually obtained
via <code>new</code>. <code>shared_ptr</code> implements semantics of
shared ownership; the last remaining owner of the pointer is responsible for
destroying the object, or otherwise releasing  the resources associated with
the stored pointer. <ins>A <code>shared_ptr</code> object that does not own
a pointer is said to be <i>empty</i>.</ins>
</blockquote>





<hr>
<h3><a name="814"></a>814. <tt>vector&lt;bool&gt;::swap(reference, reference)</tt> not defined</h3>
<p><b>Section:</b> 23.4.2 [vector.bool] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2008-03-17 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#vector.bool">issues</a> in [vector.bool].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>vector&lt;bool&gt;::swap(reference, reference)</tt> has no definition.
</p>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
Move to Open. Alisdair to provide a resolution.
</blockquote>

<p><i>[
Post Summit Daniel provided wording.
]</i></p>


<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution.
Move to Tentatively Ready.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Just after 23.4.2 [vector.bool]/5 add the following prototype and description:
</p>

<blockquote>
<p>
<ins>static void swap(reference x, reference y);</ins>
</p>
<blockquote>
<p>
<ins>-6- <i>Effects:</i> Exchanges the contents of <tt>x</tt> and <tt>y</tt> as-if</ins> by:
</p>
<blockquote><pre><ins>
bool b = x;
x = y;
y = b;
</ins></pre></blockquote>
</blockquote>
</blockquote>





<hr>
<h3><a name="815"></a>815. <tt>std::function</tt> and <tt>reference_closure</tt> do not use perfect forwarding</h3>
<p><b>Section:</b> 20.8.14.2.4 [func.wrap.func.inv] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2008-03-16 <b>Last modified:</b> 2010-11-19</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#func.wrap.func.inv">issues</a> in [func.wrap.func.inv].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>std::function</tt> and <tt>reference_closure</tt> should use "perfect forwarding" as
described in the rvalue core proposal.
</p>

<p><i>[
Sophia Antipolis:
]</i></p>


<blockquote>
According to Doug Gregor, as far as <tt>std::function</tt> is concerned, perfect
forwarding can not be obtained because of type erasure. Not everyone
agreed with this diagnosis of forwarding.
</blockquote>

<p><i>[
2009-05-01 Howard adds:
]</i></p>


<blockquote>
<p>
Sebastian Gesemann brought to my attention that the <tt>CopyConstructible</tt>
requirement on <tt>function</tt>'s <tt>ArgTypes...</tt> is an unnecessary
restriction.
</p>

<blockquote><pre>template&lt;Returnable R, <b>CopyConstructible</b>... ArgTypes&gt;
class function&lt;R(ArgTypes...)&gt;
...
</pre></blockquote>

<p>
On further investigation, this complaint seemed to be the same
issue as this one.  I believe the reason <tt>CopyConstructible</tt> was put
on <tt>ArgTypes</tt> in the first place was because of the nature of the
<i>invoke</i> member:
</p>

<blockquote><pre>template&lt;class R, class ...ArgTypes&gt;
R
function&lt;R(ArgTypes...)&gt;::operator()(ArgTypes... arg) const
{
    if (f_ == 0)
        throw bad_function_call();
    return (*f_)(arg...);
}
</pre></blockquote>

<p>
However now with rvalue-refs, "by value" no longer implies <tt>CopyConstructible</tt>
(as Sebastian correctly points out).  If rvalue arguments are supplied, <tt>MoveConstructible</tt>
is sufficient.  Furthermore, the constraint need not be applied in <tt>function</tt>
if I understand correctly.  Rather the client must apply the proper constraints
at the call site.  Therefore, at the very least, I recommend that <tt>CopyConstructible</tt>
be removed from the template class <tt>function</tt>.
</p>

<p>
Furthermore we need to mandate that the <i>invoker</i> is coded as:
</p>

<blockquote><pre>template&lt;class R, class ...ArgTypes&gt;
R
function&lt;R(ArgTypes...)&gt;::operator()(ArgTypes... arg) const
{
    if (f_ == 0)
        throw bad_function_call();
    return (*f_)(<b>std::forward&lt;ArgTypes&gt;(</b>arg<b>)</b>...);
}
</pre></blockquote>

<p>
Note that <tt>ArgTypes&amp;&amp;</tt> (the "perfect forwarding signature") is not 
appropriate here as this is not a deduced context for <tt>ArgTypes</tt>.  Instead
the client's arguments must implicitly convert to the non-deduced <tt>ArgType</tt>
type.  Catching these arguments by value makes sense to enable decay.
</p>

<p>
Next <tt>forward</tt> is used to move the <tt>ArgTypes</tt> as efficiently as
possible, and also with minimum requirements (not <tt>CopyConstructible</tt>)
to the type-erased functor.  For object types, this will be a <tt>move</tt>.  For
reference type <tt>ArgTypes</tt>, this will be a copy.  The end result <em>must</em> be
that the following is a valid program:
</p>

<blockquote><pre>#include &lt;functional&gt;
#include &lt;memory&gt;
#include &lt;cassert&gt;

std::unique_ptr&lt;int&gt;
f(std::unique_ptr&lt;int&gt; p, int&amp; i)
{
    ++i;
    return std::move(p);
}

int main()
{
    int i = 2;
    std::function&lt;std::unique_ptr&lt;int&gt;(std::unique_ptr&lt;int&gt;,
                                       int&amp;&gt; g(f);
    std::unique_ptr&lt;int&gt; p = g(std::unique_ptr&lt;int&gt;(new int(1)), i);
    assert(*p == 1);
    assert(i == 3);
}
</pre></blockquote>

<p><i>[
Tested in pre-concepts rvalue-ref-enabled compiler.
]</i></p>


<p>
In the example above, the first <tt>ArgType</tt> is <tt>unique_ptr&lt;int&gt;</tt>
and the second <tt>ArgType</tt> is <tt>int&amp;</tt>.  Both <em>must</em> work!
</p>

</blockquote>

<p><i>[
2009-05-27 Daniel adds:
]</i></p>


<blockquote>
<p>
in the 2009-05-01 comment of above mentioned issue Howard
</p>

<ol type="a">
<li>
Recommends to replace the <tt>CopyConstructible</tt> requirement by a
<tt>MoveConstructible</tt> requirement
</li>
<li>
Says: "Furthermore, the constraint need not be applied in <tt>function</tt> if I
understand correctly. Rather the client must apply the proper constraints
at the call site"
</li>
</ol>
<p>
I'm fine with (a), but I think comment (b) is incorrect, at least in the
sense I read these sentences. Let's look at Howard's example code:
</p>

<blockquote><pre>function&lt;R(ArgTypes...)&gt;::operator()(ArgTypes... arg) const
{
   if (f_ == 0)
       throw bad_function_call();
   return (*f_)(std::forward&lt;ArgTypes&gt;(arg)...);
}
</pre></blockquote>

<p>
In the constrained scope of this <tt>operator()</tt> overload the expression
"<tt>(*f_)(std::forward&lt;ArgTypes&gt;(arg)...)</tt>" must be valid. How can it
do so, if <tt>ArgTypes</tt> aren't at least <tt>MoveConstructible</tt>?
</p>
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
Leave this open and wait until concepts are removed from the Working
Draft so that we know how to write the proposed resolution in terms of
diffs to otherwise stable text.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Leave as open. Howard to provide wording. Howard welcomes any help.
</blockquote>

<p><i>[
2009-12-12 Jonathan Wakely adds:
]</i></p>


<blockquote>
<p>
20.8.14.2 [func.wrap.func] says
</p>

<blockquote>
2  A function object <tt>f</tt> of type <tt>F</tt> is Callable for argument
types <tt>T1, T2, ..., TN</tt> in <tt>ArgTypes</tt> and a return type
<tt>R</tt>, if, given lvalues <tt>t1, t2, ..., tN</tt> of types <tt>T1, T2, ...,
TN</tt>, respectively, <tt>INVOKE (f, t1, t2, ..., tN)</tt> is well formed
(20.7.2) and, if <tt>R</tt> is not <tt>void</tt>, convertible to <tt>R</tt>.
</blockquote>

<p>
N.B. lvalues, which means you can't use <tt>function&lt;R(T&amp;&amp;)&gt;</tt>
or <tt>function&lt;R(unique_ptr&lt;T&gt;)&gt;</tt>
</p>

<p>
I recently implemented rvalue arguments in GCC's <tt>std::function</tt>, all
that was needed was to use <tt>std::forward&lt;ArgTypes&gt;</tt> in a few
places. The example in issue 815 works.
</p>

<p>
I think 815 could be resolved by removing the requirement that the target
function be callable with lvalues.  Saying <tt>ArgTypes</tt> need to be
<tt>CopyConstructible</tt> is wrong, and IMHO saying <tt>MoveConstructible</tt>
is unnecessary, since the by-value signature implies that already, but if it is
needed it should only be on <tt>operator()</tt>, not the whole class (you could
in theory instantiate <tt>std::function&lt;R(noncopyable)&gt;</tt> as long as
you don't invoke the call operator.)
</p>

<p>
I think defining invocation in terms of <tt>INVOKE</tt> already implies perfect
forwarding, so we don't need to say explicitly that <tt>std::forward</tt> should
be used (N.B. the types that are forwarded are those in <tt>ArgTypes</tt>, which
can differ from the actual parameter types of the target function.  The actual
parameter types have gone via type erasure, but that's not a problem - IMHO
forwarding the arguments as <tt>ArgTypes</tt> is the right thing to do anyway.)
</p>

<p>
Is it sufficient to simply replace "lvalues" with "values"? or do we need to say
something like "lvalues when <tt>Ti</tt> is an lvalue-reference and rvalues
otherwise"?  I prefer the former, so I propose the following resolution for 815:
</p>

<p>
Edit 20.8.14.2 [func.wrap.func] paragraph 2:
</p>

<blockquote>
2  A function object <tt>f</tt> of type <tt>F</tt> is Callable for argument
types <tt>T1, T2, ..., TN</tt> in <tt>ArgTypes</tt> and a return type
<tt>R</tt>, if, given <del>l</del>values <tt>t1, t2, ..., tN</tt> of types
<tt>T1, T2, ..., TN</tt>, respectively, <tt>INVOKE (f, t1, t2, ..., tN)</tt> is
well formed (20.7.2) and, if <tt>R</tt> is not <tt>void</tt>, convertible to
<tt>R</tt>.
</blockquote>
</blockquote>

<p><i>[
2009-12-12 Daniel adds:
]</i></p>


<blockquote>
I don't like the reduction to "values" and prefer the alternative solution
suggested using "lvalues when Ti is an lvalue-reference and rvalues otherwise".
The reason why I dislike the shorter version is based on different usages of
"values" as part of defining the semantics of requirement tables via
expressions. E.g. 20.2.1 [utility.arg.requirements]/1 says "<tt>a</tt>,
<tt>b</tt>, and <tt>c</tt> are values of type <tt>const T;</tt>" or similar in
23.2.1 [container.requirements.general]/4 or /14 etc. My current reading
of all these parts is that <em>both</em> rvalues and lvalues are required to be
supported, but this interpretation would violate the intention of the suggested
fix of #815, if I correctly understand Jonathan's rationale.
</blockquote>

<p><i>[
2009-12-12 Howard adds:
]</i></p>


<blockquote>
<blockquote>
"lvalues when Ti is an lvalue-reference and rvalues otherwise"
</blockquote>
<p>
doesn't quite work here because the <tt>Ti</tt> aren't deduced.  They are
specified by the <tt>function</tt> type.  <tt>Ti</tt> might be <tt>const
int&amp;</tt> (an lvalue reference) and a valid <tt>ti</tt> might be <tt>2</tt>
(a non-const rvalue).  I've taken another stab at the wording using
"expressions" and "bindable to".
</p>
</blockquote>

<p><i>[
2010-02-09 Wording updated by Jonathan, Ganesh and Daniel.
]</i></p>


<p><i>[
2010-02-09 Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>


<p><i>[
2010-02-10 Daniel opens to improve wording.
]</i></p>


<p><i>[
2010-02-11 This issue is now addressed by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#870">870</a>.
]</i></p>


<p><i>[
2010-02-12 Moved to Tentatively NAD Editorial after 5 positive votes on
c++std-lib.  Rationale added below.
]</i></p>




<p><b>Rationale:</b></p>
<p>
Addressed by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#870">870</a>.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Edit 20.8.14.2 [func.wrap.func] paragraph 2:
</p>

<blockquote>
<p>
2  A function object <tt>f</tt> of type <tt>F</tt> is Callable for argument
types <del><tt>T1, T2, ..., TN</tt> in</del> <tt>ArgTypes</tt> and <del>a</del>
return type <tt>R</tt><del>,</del> if<del>, given lvalues <tt>t1, t2, ...,
tN</tt> of types <tt>T1, T2, ..., TN</tt>, respectively,</del> <ins>the
expression</ins> <tt><i>INVOKE</i>(f, <ins>declval&lt;ArgTypes&gt;()...,
R</ins><del>t1, t2, ..., tN</del>)</tt><ins>, considered as an unevaluated
operand (5 [expr]),</ins> is well formed (20.7.2)<del> and, if
<tt>R</tt> is not <tt>void</tt>, convertible to <tt>R</tt></del>.
</p>

</blockquote>





<hr>
<h3><a name="816"></a>816. Should <tt>bind()</tt>'s returned functor have a nofail copy ctor when <tt>bind()</tt> is nofail?</h3>
<p><b>Section:</b> 20.8.10.1.2 [func.bind.bind] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2008-02-08 <b>Last modified:</b> 2010-11-19</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#func.bind.bind">issues</a> in [func.bind.bind].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Library Issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#527">527</a> notes that <tt>bind(f, t1, ..., tN)</tt>
should be nofail when <tt>f, t1, ..., tN</tt> have nofail copy ctors.
</p>
<p>
However, no guarantees are provided for the copy ctor of the functor
returned by <tt>bind()</tt>.  (It's guaranteed to have a copy ctor, which can
throw implementation-defined exceptions: <tt>bind()</tt> returns a forwarding
call wrapper, TR1 3.6.3/2.  A forwarding call wrapper is a call wrapper,
TR1 3.3/4.  Every call wrapper shall be CopyConstructible, TR1 3.3/4.
Everything without an exception-specification may throw
implementation-defined exceptions unless otherwise specified, C++03
17.4.4.8/3.)
</p>
<p>
Should the nofail guarantee requested by Library Issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#527">527</a> be extended
to cover both calling <tt>bind()</tt> and copying the returned functor?
</p>

<p><i>[
Howard adds:
]</i></p>


<blockquote>
<tt>tuple</tt> construction should probably have a similar guarantee.
</blockquote>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
Howard to provide wording.
</blockquote>

<p><i>[
Post Summit, Anthony provided wording.
]</i></p>


<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Part of all of this issue appears to be rendered moot
by the proposed resolution to issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#817">817</a> (q.v.).
We recommend the issues be considered simultaneously
(or possibly even merged)
to ensure there is no overlap.
Move to Open, and likewise for issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#817">817</a>.
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
Related to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#817">817</a> (see below). Leave Open.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Move to Ready. Decoupling from issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#817">817</a>.
</blockquote>

<p><i>[
2010-02-11 Moved from Ready to Tentatively NAD Editorial, rationale added below.
]</i></p>




<p><b>Rationale:</b></p>
<p>
This issue is solved as proposed by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#817">817</a>.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add a new sentence to the end of paragraphs 2 and 4 of 20.8.10.1.2 [func.bind.bind]:
</p>

<blockquote>
<p>
-2- <i>Returns:</i> A forwarding call wrapper <tt>g</tt> with a weak result type (20.6.2). The effect of <tt>g(u1, u2,
..., uM)</tt> shall be <tt><i>INVOKE</i>(f, v1, v2, ..., vN, Callable&lt;F cv,V1, V2, ..., VN&gt;::result_type)</tt>, where <i>cv</i>
represents the <i>cv</i>-qualifiers of <tt>g</tt> and the values and types of the bound arguments
<tt>v1, v2, ..., vN</tt> are determined as specified below.
<ins>The copy constructor and move constructor of the forwarding call wrapper shall throw an
exception if and only if the corresponding constructor of <tt>F</tt> or any of the types
in <tt>BoundArgs...</tt> throw an exception.</ins>
</p>
<p>...</p>
<p>
-5- <i>Returns:</i> A forwarding call wrapper <tt>g</tt> with a nested type <tt>result_type</tt> defined as a synonym
for <tt>R</tt>. The effect of <tt>g(u1, u2, ..., uM)</tt> shall be <tt><i>INVOKE</i>(f, v1, v2, ..., vN, R)</tt>, where the
values and types of the bound arguments <tt>v1, v2, ..., vN</tt> are determined as specified below.
<ins>The copy constructor and move constructor of the forwarding call wrapper shall throw an
exception if and only if the corresponding constructor of <tt>F</tt> or any of the types
in <tt>BoundArgs...</tt> throw an exception.</ins>
</p>

</blockquote>





<hr>
<h3><a name="817"></a>817. <tt>bind</tt> needs to be moved</h3>
<p><b>Section:</b> 20.8.10.1.2 [func.bind.bind] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2008-03-17 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#func.bind.bind">issues</a> in [func.bind.bind].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US 72, JP 38 and DE 21</b></p>

<p>
The functor returned by <tt>bind()</tt> should have a move constructor that
requires only move construction of its contained functor and bound arguments.
That way move-only functors can be passed to objects such as <tt>thread</tt>.
</p>
<p>
This issue is related to issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#816">816</a>.
</p>

<p>
US 72:
</p>

<blockquote>
<tt>bind</tt> should support move-only functors and bound arguments.
</blockquote>

<p>
JP 38:
</p>

<blockquote>
<p>
add the move requirement for bind's return type.
</p>
<p>
For example, assume following <tt>th1</tt> and <tt>th2</tt>,
</p>

<blockquote><pre>void f(vector&lt;int&gt; v) { }

vector&lt;int&gt; v{ ... };
thread th1([v]{ f(v); });
thread th2(bind(f, v));
</pre></blockquote>

<p>
When function object are set to thread, <tt>v</tt> is moved to <tt>th1</tt>'s lambda
expression in a Move Constructor of lambda expression because <tt>th1</tt>'s lambda
expression has a Move Constructor. But <tt>bind</tt> of <tt>th2</tt>'s
return type doesn't have the requirement of Move, so it may not
moved but copied.
</p>
<p>
Add the requirement of move to get rid of this useless copy.
</p>
<p>
And also, add the <tt>MoveConstructible</tt> as well as <tt>CopyConstructible</tt>.
</p>
</blockquote>

<p>
DE 21
</p>

<blockquote>
The specification for bind claims twice that "the values and types for
the bound arguments v1, v2, ..., vN are determined as specified below".
No such specification appears to exist.
</blockquote>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
Howard to provide wording.
</blockquote>

<p><i>[
Post Summit Alisdair and Howard provided wording.
]</i></p>


<blockquote>
<p>
Several issues are being combined in this resolution.  They are all touching the
same words so this is an attempt to keep one issue from stepping on another, and
a place to see the complete solution in one place.
</p>

<ol>
<li>
<tt>bind</tt> needs to be "moved".
</li>
<li>
20.8.10.1.2 [func.bind.bind]/p3, p6 and p7 were accidently removed from N2798.
</li>
<li>
Issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#929">929</a> argues for a way to pass by &amp;&amp; for
efficiency but retain the decaying behavior of pass by value for the
<tt>thread</tt> constructor.  That same solution is applicable here.
</li>
</ol>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We were going to recommend moving this issue to Tentatively Ready
until we noticed potential overlap with issue 816 (q.v.).
</p>
<p>
Move to Open,
and recommend both issues be considered together
(and possibly merged).
</p>
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
The proposed resolution uses concepts. Leave Open.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Leave as Open. Howard to provide deconceptified wording.
</blockquote>

<p><i>[
2009-11-07 Howard updates wording.
]</i></p>


<p><i>[
2009-11-15 Further updates by Peter, Chris and Daniel.
]</i></p>


<p><i>[
Moved to Tentatively Ready after 6 positive votes on c++std-lib.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
Change 20.8 [function.objects] p2:
</p>

<blockquote><pre>template&lt;class F<del>n</del>, class... <del>Types</del> <ins>BoundArgs</ins>&gt;
  <i>unspecified</i> bind(F<del>n</del><ins>&amp;&amp;</ins>, <del>Types</del> <ins>BoundArgs&amp;&amp;</ins>...);
template&lt;class R, class F<del>n</del>, class... <del>Types</del> <ins>BoundArgs</ins>&gt;
  <i>unspecified</i> bind(F<del>n</del><ins>&amp;&amp;</ins>, <del>Types</del> <ins>BoundArgs&amp;&amp;</ins>...);
</pre></blockquote>

<p>
Change 20.8.2 [func.require]:
</p>

<blockquote>
<p>
4 Every call wrapper (20.8.1 [func.def]) shall be
<tt><del>Copy</del><ins>Move</ins>Constructible</tt>. A <i>simple call
wrapper</i> is a call wrapper that is <ins><tt>CopyConstructible</tt> and</ins>
<tt>CopyAssignable</tt> and whose copy constructor<ins>, move constructor</ins> and assignment operator do not
throw exceptions. A <i>forwarding call wrapper</i> is a call wrapper that can be
called with an argument list. [<i>Note:</i> in a typical implementation
forwarding call wrappers have an overloaded function call operator of the form
</p>
<blockquote><pre>template&lt;class... <del>ArgTypes</del><ins>UnBoundsArgs</ins>&gt;
R operator()(<del>ArgTypes</del><ins>UnBoundsArgs</ins>&amp;&amp;... <ins>unbound_</ins>args) cv-qual;
</pre></blockquote>
<p>
 <i>end note</i>]
</p>
</blockquote>

<p>
Change 20.8.10.1.2 [func.bind.bind]:
</p>

<blockquote>
<p><ins>
Within this clause:
</ins></p>

<ul>
<li><ins>
Let <tt>FD</tt> be a synonym for the type <tt>decay&lt;F&gt;::type</tt>.
</ins></li>
<li><ins>
Let <tt>fd</tt> be an lvalue of type <tt>FD</tt> constructed from
<tt>std::forward&lt;F&gt;(f)</tt>.
</ins></li>
<li><ins>
Let <tt>Ti</tt> be a synonym for the i<sup><i>th</i></sup> type in the
template parameter pack <tt>BoundArgs</tt>.
</ins></li>
<li><ins>
Let <tt>TiD</tt> be a synonym for the type <tt>decay&lt;Ti&gt;::type</tt>.
</ins></li>
<li><ins>
Let <tt>ti</tt> be the i<sup><i>th</i></sup> argument in the function parameter
pack <tt>bound_args</tt>.
</ins></li>
<li><ins>
Let <tt>tid</tt> be an lvalue of type <tt>TiD</tt> constructed from
<tt>std::forward&lt;Ti&gt;(ti)</tt>.
</ins></li>
<li><ins>
Let <tt>Uj</tt> be the j<sup><i>th</i></sup> deduced type of the <tt>UnBoundArgs&amp;&amp;...</tt>
parameter of the <tt>operator()</tt> of the forwarding call wrapper.
</ins></li>
<li><ins>
Let <tt>uj</tt> be the j<sup><i>th</i></sup> argument associated with <tt>Uj</tt>.
</ins></li>
</ul>

<pre>template&lt;class F, class... BoundArgs&gt;
  <i>unspecified</i> bind(F<ins>&amp;&amp;</ins> f, BoundArgs<ins>&amp;&amp;</ins>... bound_args);
</pre>

<blockquote>
<p>
-1- <i>Requires:</i>
<ins><tt>is_constructible&lt;FD, F&gt;::value</tt>
shall be <tt>true</tt>.</ins>
<ins>For each <tt>Ti</tt> in <tt>BoundArgs</tt>,
<tt>is_constructible&lt;TiD, Ti&gt;::value</tt> shall be
<tt>true</tt></ins>.
<del><tt>F</tt> and each <tt>Ti</tt> in
<tt>BoundArgs</tt> shall be CopyConstructible.</del>
<tt><i>INVOKE</i>(f<ins>d</ins>, w1, w2, ..., wN)</tt> (20.8.2 [func.require]) shall be a valid expression for some values
<i>w1, w2, ..., wN</i>, where <tt>N == sizeof...(bound_args)</tt>.
</p>
<p>
-2- <i>Returns:</i> A forwarding call wrapper <tt>g</tt> with a weak
result type (20.8.2 [func.require]). The effect of <tt>g(u1, u2,
..., uM)</tt> shall be <tt><i>INVOKE</i>(f<ins>d</ins>, v1, v2, ..., vN,
result_of&lt;F<ins>D</ins> <i>cv</i> (V1, V2, ..., VN)&gt;::type)</tt>, where
<i>cv</i> represents the <i>cv</i>-qualifiers of <tt>g</tt> and the
values and types of the bound arguments <tt>v1, v2, ..., vN</tt> are
determined as specified below.
<ins>The copy constructor and move constructor of the forwarding call wrapper shall throw an
exception if and only if the corresponding constructor of <tt>FD</tt> or of any of the types
<tt>TiD</tt> throws an exception.</ins>
</p>
<p>
-3- <i>Throws:</i> Nothing unless the <del>copy</del>
construct<ins>ion</ins><del>or</del> of
<tt><del>F</del><ins>fd</ins></tt> or of one of the <ins>values
<tt>tid</tt></ins> <del>types in the <tt>BoundArgs...</tt> pack
expansion</del> throws an exception.
</p>
<p>
<ins>
<i>Remarks:</i> The <i>unspecified</i> return type shall satisfy the
requirements of <tt>MoveConstructible</tt>.  If all of <tt>FD</tt> and
<tt>TiD</tt> satisfy the requirements of <tt>CopyConstructible</tt> then
the <i>unspecified</i> return type shall satisfy the requirements of
<tt>CopyConstructible</tt>. [<i>Note:</i> This implies that all of
<tt>FD</tt> and <tt>TiD</tt> shall be <tt>MoveConstructible</tt> 
<i>end note</i>]
</ins>
</p>
</blockquote>

<pre>template&lt;class R, class F, class... BoundArgs&gt;
  <i>unspecified</i> bind(F<ins>&amp;&amp;</ins> f, BoundArgs<ins>&amp;&amp;</ins>... bound_args);
</pre>

<blockquote>
<p>
-4- <i>Requires:</i>
<ins><tt>is_constructible&lt;FD, F&gt;::value</tt>
shall be <tt>true</tt>.</ins>
<ins>For each <tt>Ti</tt> in <tt>BoundArgs</tt>,
<tt>is_constructible&lt;TiD, Ti&gt;::value</tt> shall be
<tt>true</tt></ins>.
<del><tt>F</tt> and each <tt>Ti</tt> in
<tt>BoundArgs</tt> shall be CopyConstructible.</del>
<tt><i>INVOKE</i>(f<ins>d</ins>, w1,
w2, ..., wN)</tt> shall be a valid expression for some values <i>w1, w2,
..., wN</i>, where <tt>N == sizeof...(bound_args)</tt>.
</p>
<p>
-5- <i>Returns:</i> A forwarding call wrapper <tt>g</tt> with a nested
type <tt>result_type</tt> defined as a synonym for <tt>R</tt>. The
effect of <tt>g(u1, u2, ..., uM)</tt> shall be <tt><i>INVOKE</i>(f<ins>d</ins>, v1,
v2, ..., vN, R)</tt>, where the values and types of the bound arguments
<tt>v1, v2, ..., vN</tt> are determined as specified below.
<ins>The copy constructor and move constructor of the forwarding call wrapper shall throw an
exception if and only if the corresponding constructor of <tt>FD</tt> or of any of the types
<tt>TiD</tt> throws an exception.</ins>
</p>
<p>
-6- <i>Throws:</i> Nothing unless the <del>copy</del>
construct<ins>ion</ins><del>or</del> of
<tt><del>F</del><ins>fd</ins></tt> or of one of the <ins>values
<tt>tid</tt></ins> <del>types in the <tt>BoundArgs...</tt> pack
expansion</del> throws an exception.
</p>
<p>
<ins>
<i>Remarks:</i> The <i>unspecified</i> return type shall satisfy the
requirements of <tt>MoveConstructible</tt>.  If all of <tt>FD</tt> and
<tt>TiD</tt> satisfy the requirements of <tt>CopyConstructible</tt> then
the <i>unspecified</i> return type shall satisfy the requirements of
<tt>CopyConstructible</tt>. [<i>Note:</i> This implies that all of
<tt>FD</tt> and <tt>TiD</tt> shall be <tt>MoveConstructible</tt> 
<i>end note</i>]
</ins>
</p>
</blockquote>

<p>
-7- The values of the <i>bound arguments</i> <tt>v1, v2, ..., vN</tt> and
their corresponding types <tt>V1, V2, ..., VN</tt> depend on the type<ins>s
<tt>TiD</tt> derived from</ins>
<del>of the corresponding argument <tt>ti</tt> in <tt>bound_args</tt> of type
<tt>Ti</tt> in <tt>BoundArgs</tt> in</del>
the call to <tt>bind</tt> and the
<i>cv</i>-qualifiers <i>cv</i> of the call wrapper <tt>g</tt> as
follows:
</p>

<ul>
<li>
if <tt><del>ti</del> <ins>TiD</ins></tt> is <del>of type</del>
<tt>reference_wrapper&lt;T&gt;</tt> the argument is
<tt>ti<ins>d</ins>.get()</tt> and its type <tt>Vi</tt> is <tt>T&amp;</tt>;
</li>
<li>
if the value of
<tt><del>std::</del>is_bind_expression&lt;Ti<ins>D</ins>&gt;::value</tt> is
<tt>true</tt> the argument is <tt>ti<ins>d</ins>(<ins>std::forward&lt;Uj&gt;(uj)...</ins> <del>u1, u2, ..., uM</del>)</tt>
and its type <tt>Vi</tt> is <tt>result_of&lt;Ti<ins>D</ins> <i>cv</i>
(<ins>Uj...</ins> <del>U1&amp;, U2&amp;, ..., UM&amp;</del>)&gt;::type</tt>;
</li>
<li>
if the value <tt>j</tt> of
<tt><del>std::</del>is_placeholder&lt;Ti<ins>D</ins>&gt;::value</tt> is not zero
the argument is <tt>std::forward&lt;Uj&gt;(uj)</tt> and its type
<tt>Vi</tt> is <tt>Uj&amp;&amp;</tt>;
</li>
<li>
otherwise the value is <tt>ti<ins>d</ins></tt> and its type <tt>Vi</tt>
is <tt>Ti<ins>D</ins> <i>cv</i> &amp;</tt>.
</li>
</ul>

</blockquote>






<hr>
<h3><a name="818"></a>818. wording for memory ordering</h3>
<p><b>Section:</b> 29.3 [atomics.order] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Jens Maurer <b>Opened:</b> 2008-03-22 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#atomics.order">issues</a> in [atomics.order].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
29.3 [atomics.order] p1 says in the table that
</p>

<blockquote>
<table border="1">
<tbody><tr>
<th>Element</th><th>Meaning</th>
</tr>
<tr>
<td><tt>memory_order_acq_rel</tt></td>
<td>the operation has both acquire and release semantics</td>
</tr>
</tbody></table>
</blockquote>

<p>
To my naked eye, that seems to imply that even an atomic read has both
acquire and release semantics.
</p>

<p>
Then, p1 says in the table:
</p>

<blockquote>
<table border="1">
<tbody><tr>
<th>Element</th><th>Meaning</th>
</tr>
<tr>
<td><tt>memory_order_seq_cst</tt></td>
<td>the operation has both acquire and release semantics,
    and, in addition, has sequentially-consistent operation ordering</td>
</tr>
</tbody></table>
</blockquote>

<p>
So that seems to be "the same thing" as <tt>memory_order_acq_rel</tt>, with additional
constraints.
</p>

<p>
I'm then reading p2, where it says:
</p>

<blockquote>
The <tt>memory_order_seq_cst</tt> operations that load a value are acquire operations
on the affected locations. The <tt>memory_order_seq_cst</tt> operations that store a value
are release operations on the affected locations.
</blockquote>

<p>
That seems to imply that atomic reads only have acquire semantics.  If that
is intended, does this also apply to <tt>memory_order_acq_rel</tt> and the individual
load/store operations as well?
</p>

<p>
Also, the table in p1 contains phrases with "thus" that seem to indicate
consequences of normative wording in 1.10 [intro.multithread].  That shouldn't be in
normative text, for the fear of redundant or inconsistent specification with
the other normative text.
</p>

<p>
Double-check 29.6 [atomics.types.operations] that each
operation clearly says whether it's a load or a store operation, or
both.  (It could be clearer, IMO.  Solution not in current proposed resolution.)
</p>

<p>
29.3 [atomics.order] p2:  What's a "consistent execution"?  It's not defined in
1.10 [intro.multithread], it's just used in notes there.
</p>

<p>
And why does 29.6 [atomics.types.operations] p9 for "load" say:
</p>


<blockquote>
<i>Requires:</i> The order argument shall not be <tt>memory_order_acquire</tt>
nor <tt>memory_order_acq_rel</tt>.
</blockquote>

<p>
(Since this is exactly the same restriction as for "store", it seems to be a typo.)
</p>

<p>
And then: 29.6 [atomics.types.operations] p12:
</p>

<blockquote>
These operations are read-modify-write operations in the sense of the
"synchronizes with" definition (1.10 [intro.multithread]), so both such an operation and the
evaluation that produced the input value synchronize with any evaluation
that reads the updated value.
</blockquote>

<p>
This is redundant with 1.10 [intro.multithread], see above for the reasoning.
</p>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
<p>
Boehm: "I don't think that this changes anything terribly substantive,
but it improves the text."
</p>
<p>
Note that "Rephrase the table in as [sic] follows..." should read
"Replace the table in [atomics.order] with the following...."
</p>
<p>
The proposed resolution needs more work. Crowl volunteered to address
all of the atomics issues in one paper.
</p>

<p>
This issue is addressed in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2783.html">N2783</a>.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
edit 29.3 [atomics.order], paragraph 1 as follows.
</p>

<blockquote>
<p>
The enumeration <code>memory_order</code>
specifies the detailed regular (non-atomic) memory synchronization order
as defined in <del>Clause 1.7</del> <ins>section 1.10</ins>
and may provide for operation ordering.
Its enumerated values and their meanings are as follows:
</p>
<blockquote>
<dl>
<dt><ins>For <code>memory_order_relaxed</code>,</ins></dt>
<dd><ins>no operation orders memory.</ins></dd>
<dt><ins>For <code>memory_order_release</code>,
<code>memory_order_acq_rel</code>,
and <code>memory_order_seq_cst</code>,</ins></dt>
<dd><ins>a store operation performs a release operation
on the affected memory location.</ins></dd>
<dt><ins>For <code>memory_order_consume</code>,</ins></dt>
<dd><ins>a load operation performs a consume operation
on the affected memory location.</ins></dd>
<dt><ins>For <code>memory_order_acquire</code>,
<code>memory_order_acq_rel</code>,
and <code>memory_order_seq_cst</code>,</ins></dt>
<dd><ins>a load operation performs an acquire operation
on the affected memory location.</ins></dd>
</dl>
</blockquote>
</blockquote>

<p>
remove table 136 in 29.3 [atomics.order].
</p>

<blockquote>
<table border="1">
<caption><del>Table 136  memory_order effects</del></caption>
<tbody><tr><th><del>Element</del></th><th><del>Meaning</del></th></tr>
<tr><td valign="top"><del><code>memory_order_relaxed</code></del></td>
<td valign="top"><del>the operation does not order memory</del></td></tr>
<tr><td valign="top"><del><code>memory_order_release</code></del></td>
<td valign="top"><del>the operation
performs a release operation on the affected memory location,
thus making regular memory writes visible to other threads
through the atomic variable to which it is applied</del></td></tr>
<tr><td valign="top"><del><code>memory_order_acquire</code></del></td>
<td valign="top"><del>the operation
performs an acquire operation on the affected memory location,
thus making regular memory writes in other threads
released through the atomic variable to which it is applied
visible to the current thread</del></td></tr>
<tr><td valign="top"><del><code>memory_order_consume</code></del></td>
<td valign="top"><del>the operation
performs a consume operation on the affected memory location,
thus making regular memory writes in other threads
released through the atomic variable to which it is applied
visible to the regular memory reads
that are dependencies of this consume operation.</del></td></tr>
<tr><td valign="top"><del><code>memory_order_acq_rel</code></del></td>
<td valign="top"><del>the operation has both acquire and release semantics</del></td></tr>
<tr><td valign="top"><del><code>memory_order_seq_cst</code></del></td>
<td valign="top"><del>the operation has both acquire and release semantics,
and, in addition, has sequentially-consistent operation ordering</del></td></tr>
</tbody></table>
</blockquote>

<p>
edit 29.3 [atomics.order], paragraph 2 as follows.
</p>

<blockquote>
<p>
<del>The <code>memory_order_seq_cst</code> operations that load a value
are acquire operations on the affected locations.
The <code>memory_order_seq_cst</code> operations that store a value
are release operations on the affected locations.
In addition, in a consistent execution,
there</del> <ins>There</ins> <del>must be</del> <ins>is</ins>
a single total order <var>S</var>
on all <code>memory_order_seq_cst</code> operations,
consistent with the happens before order
and modification orders for all affected locations,
such that each <code>memory_order_seq_cst</code> operation
observes either the last preceding modification
according to this order <var>S</var>,
or the result of an operation that is not <code>memory_order_seq_cst</code>.
[<i>Note:</i>
Although it is not explicitly required that <var>S</var> include locks,
it can always be extended to an order
that does include lock and unlock operations,
since the ordering between those
is already included in the happens before ordering.
<i>end note</i>]
</p>
</blockquote>






<hr>
<h3><a name="819"></a>819. rethrow_if_nested</h3>
<p><b>Section:</b> 18.8.6 [except.nested] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2008-03-25 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#except.nested">issues</a> in [except.nested].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Looking at the wording I submitted for <tt>rethrow_if_nested</tt>, I don't think I
got it quite right.
</p>

<p>
The current wording says:
</p>

<blockquote>
<pre>template &lt;class E&gt; void rethrow_if_nested(const E&amp; e);
</pre>
<blockquote>
<p>
<i>Effects:</i> Calls <tt>e.rethrow_nested()</tt> only if <tt>e</tt>
is publicly derived from <tt>nested_exception</tt>.
</p>
</blockquote>
</blockquote>

<p>
This is trying to be a bit subtle, by requiring <tt>e</tt> (not <tt>E</tt>) to be publicly
derived from <tt>nested_exception</tt> the idea is that a <tt>dynamic_cast</tt> would be
required to be sure.  Unfortunately, if <tt>e</tt> is dynamically but not statically
derived from <tt>nested_exception</tt>, <tt>e.rethrow_nested()</tt> is ill-formed.
</p>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
Alisdair was volunteered to provide wording.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Leave as Open. Alisdair to provide wording.
</blockquote>

<p><i>[
2009-11-09 Alisdair provided wording.
]</i></p>


<p><i>[
2010-03-10 Dietmar updated wording.
]</i></p>


<p><i>[
2010 Pittsburgh:
]</i></p>


<blockquote>
Moved to Ready for Pittsburgh.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 18.8.6 [except.nested], p8:
</p>

<blockquote><pre>template &lt;class E&gt; void rethrow_if_nested(const E&amp; e);
</pre>
<blockquote>
-8- <i>Effects:</i> <del>Calls <tt>e.rethrow_nested()</tt>
o</del><ins>O</ins>nly if <ins>the dynamic type of</ins> <tt>e</tt> is
publicly <ins>and unambiguously</ins> derived from
<tt>nested_exception</tt> <ins>this calls
<tt>dynamic_cast&lt;const nested_exception&amp;&gt;(e).rethrow_nested()</tt></ins>.
</blockquote>
</blockquote>






<hr>
<h3><a name="820"></a>820. <tt>current_exception()</tt>'s interaction with throwing copy ctors</h3>
<p><b>Section:</b> 18.8.5 [propagation] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2008-03-26 <b>Last modified:</b> 2010-10-29</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#propagation">active issues</a> in [propagation].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#propagation">issues</a> in [propagation].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
As of N2521, the Working Paper appears to be silent about what
<tt>current_exception()</tt> should do if it tries to copy the currently handled
exception and its copy constructor throws.  18.8.5 [propagation]/7 says "If the
function needs to allocate memory and the attempt fails, it returns an
<tt>exception_ptr</tt> object that refers to an instance of <tt>bad_alloc</tt>.", but
doesn't say anything about what should happen if memory allocation
succeeds but the actual copying fails.
</p>

<p>
I see three alternatives: (1) return an <tt>exception_ptr</tt> object that refers
to an instance of some fixed exception type, (2) return an <tt>exception_ptr</tt>
object that refers to an instance of the copy ctor's thrown exception
(but if that has a throwing copy ctor, an infinite loop can occur), or
(3) call <tt>terminate()</tt>.
</p>

<p>
I believe that <tt>terminate()</tt> is the most reasonable course of action, but
before we go implement that, I wanted to raise this issue.
</p>

<p><i>[
Peter's summary:
]</i></p>


<blockquote>
<p>
The current practice is to not have throwing copy constructors in
exception classes, because this can lead to <tt>terminate()</tt> as described in
15.5.1 [except.terminate]. Thus calling <tt>terminate()</tt> in this situation seems
consistent and does not introduce any new problems.
</p>

<p>
However, the resolution of core issue 475 may relax this requirement:
</p>

<blockquote>
The CWG agreed with the position that <tt>std::uncaught_exception()</tt> should
return <tt>false</tt> during the copy to the exception object and that <tt>std::terminate()</tt>
should not be called if that constructor exits with an exception.
</blockquote>

<p>
Since throwing copy constructors will no longer call <tt>terminate()</tt>, option
(3) doesn't seem reasonable as it is deemed too drastic a response in a
recoverable situation.
</p>

<p>
Option (2) cannot be adopted by itself, because a potential infinite
recursion will need to be terminated by one of the other options.
</p>

</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Add the following paragraph after 18.8.5 [propagation]/7:
</p>

<blockquote>
<p>
<i>Returns (continued):</i> If the attempt to copy the current exception
object throws an exception, the function returns an <tt>exception_ptr</tt> that
refers to the thrown exception or, if this is not possible, to an
instance of <tt>bad_exception</tt>.
</p>
<p>
[<i>Note:</i> The copy constructor of the thrown exception may also fail, so
the implementation is allowed to substitute a <tt>bad_exception</tt> to avoid
infinite recursion. <i>-- end note.</i>]
</p>
</blockquote>



<p><b>Rationale:</b></p>
<p><i>[
San Francisco:
]</i></p>


<blockquote>
<p>
Pete: there may be an implied assumption in the proposed wording that
current_exception() copies the existing exception object; the
implementation may not actually do that.
</p>
<p>
Pete will make the required editorial tweaks to rectify this.
</p>
</blockquote>





<hr>
<h3><a name="821"></a>821. Minor cleanup : <tt>unique_ptr</tt></h3>
<p><b>Section:</b> 20.9.9.3.3 [unique.ptr.runtime.modifiers] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2008-03-30 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Reading resolution of LWG issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#673">673</a> I noticed the following:
</p>

<blockquote>
<pre>void reset(<del>T*</del> <ins>pointer</ins> p = <del>0</del> <ins>pointer()</ins>);
</pre>

<p>
-1- <i>Requires:</i> Does not accept pointer types which are convertible
to <del><tt>T*</tt></del> <ins><tt>pointer</tt></ins> (diagnostic
required). [<i>Note:</i> One implementation technique is to create a private
templated overload. <i>-- end note</i>]
</p>
</blockquote>

<p>
This could be cleaned up by mandating the overload as a public deleted
function.  In addition, we should probably overload <tt>reset</tt> on <tt>nullptr_t</tt>
to be a stronger match than the deleted overload. Words...
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add to class template definition in 20.9.9.3 [unique.ptr.runtime]
</p>

<blockquote>
<pre>// modifiers 
pointer release(); 
void reset(pointer p = pointer()); 
<ins>void reset( nullptr_t );</ins>
<ins>template&lt; typename U &gt; void reset( U ) = delete;</ins>
void swap(unique_ptr&amp;&amp; u);
</pre>
</blockquote>

<p>
Update 20.9.9.3.3 [unique.ptr.runtime.modifiers]
</p>

<blockquote>
<pre>void reset(pointer p = pointer());
<ins>void reset(nullptr_t);</ins>
</pre>

<p>
<del>-1- <i>Requires:</i> Does not accept pointer types which are convertible
to <tt>pointer</tt> (diagnostic
required). [<i>Note:</i> One implementation technique is to create a private
templated overload. <i>-- end note</i>]</del>
</p>
<p>
<i>Effects:</i> If <tt>get() == nullptr</tt> there are no effects. Otherwise <tt>get_deleter()(get())</tt>. 
</p>
<p>...</p>
</blockquote>

<p><i>[
Note this wording incorporates resolutions for <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#806">806</a> (New) and <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#673">673</a> (Ready).
]</i></p>






<hr>
<h3><a name="823"></a>823. <tt>identity&lt;void&gt;</tt> seems broken</h3>
<p><b>Section:</b> 20.3.3 [forward] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> Walter Brown <b>Opened:</b> 2008-04-09 <b>Last modified:</b> 2010-11-20</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#forward">issues</a> in [forward].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p>
N2588 seems to have added an <tt>operator()</tt> member function to the
<tt>identity&lt;&gt;</tt> helper in 20.3.3 [forward].  I believe this change makes it no
longer possible to instantiate <tt>identity&lt;void&gt;</tt>, as it would require
forming a reference-to-<tt>void</tt> type as this <tt>operator()</tt>'s parameter type.
</p>

<p>
Suggested resolution:  Specialize <tt>identity&lt;void&gt;</tt> so as not to require
the member function's presence.
</p>

<p><i>[
Sophia Antipolis:
]</i></p>


<blockquote>
<p>
Jens: suggests to add a requires clause to avoid specializing on <tt>void</tt>.
</p>
<p>
Alisdair: also consider cv-qualified <tt>void</tt>.
</p>
<p>
Alberto provided proposed wording.
</p>
</blockquote>

<p><i>[
2009-07-30 Daniel reopens:
]</i></p>


<blockquote>
<p>
This issue became closed, because the <tt>ReferentType</tt> requirement
fixed the problem - this is no longer the case. In retrospective it seems
to be that the root of current issues around <tt>std::identity</tt> (823, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#700">700</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#939">939</a>)
is that it was standardized as something very different (an unconditional
type mapper) than traditional usage indicated (a function object that should
derive from <tt>std::unary_function)</tt>, as the SGI definition does. This issue could
be solved, if <tt>std::identity</tt> is removed (one proposal of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#939">939</a>), but until this
has been decided, this issue should remain open. An alternative for
removing it, would be, to do the following:
</p>

<ol type="a">
<li>
<p>
Let <tt>identity</tt> stay as a <em>real</em> function object, which would
now properly
derive from <tt>unary_function</tt>:
</p>

<blockquote><pre>template &lt;class T&gt; struct identity : unary_function&lt;T, T&gt; {
  const T&amp; operator()(const T&amp;) const;
};
</pre></blockquote>
</li>

<li>
<p>
Invent (if needed) a generic type wrapper (corresponding to concept
<tt>IdentityOf</tt>),
e.g. <tt>identity_of</tt>, and move it's prototype description back to 20.3.3 [forward]:
</p>

<blockquote><pre>template &lt;class T&gt; struct identity_of {
  typedef T type;
};
</pre></blockquote>

<p>
and adapt the <tt>std::forward</tt> signature to use <tt>identity_of</tt>
instead of <tt>identity</tt>.
</p>
</li>
</ol>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Mark as <del>NAD Editorial</del><ins>Resolved</ins>, fixed by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#939">939</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change definition of <tt>identity</tt> in 20.3.3 [forward], paragraph 2, to:
</p>

<blockquote><pre>template &lt;class T&gt;  struct identity {
    typedef T type;

    <ins>requires ReferentType&lt;T&gt;</ins>
      const T&amp; operator()(const T&amp; x) const;
  };
</pre></blockquote>
<p>...</p>
<blockquote><pre>  <ins>requires ReferentType&lt;T&gt;</ins>
    const T&amp; operator()(const T&amp; x) const;
</pre></blockquote>


<p><b>Rationale:</b></p>
<p>
The point here is to able to write <tt>T&amp;</tt> given <tt>T</tt> and <tt>ReferentType</tt> is
precisely the concept that guarantees so, according to N2677
(Foundational concepts). Because of this, it seems preferable than an
explicit check for <tt>cv void</tt> using <tt>SameType/remove_cv</tt> as it was suggested
in Sophia. In particular, Daniel remarked that there may be types other
than <tt>cv void</tt> which aren't referent types (<tt>int[]</tt>, perhaps?).
</p>





<hr>
<h3><a name="824"></a>824. rvalue ref issue with <tt>basic_string</tt> inserter</h3>
<p><b>Section:</b> 21.4.8.9 [string.io] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2008-04-10 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#string.io">issues</a> in [string.io].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In the current working paper, the <tt>&lt;string&gt;</tt> header synopsis at the end of
21.3 [string.classes] lists a single <tt>operator&lt;&lt;</tt> overload
for <tt>basic_string</tt>.
</p>

<blockquote><pre>template&lt;class charT, class traits, class Allocator&gt;
 basic_ostream&lt;charT, traits&gt;&amp;
   operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp;&amp; os,
              const basic_string&lt;charT,traits,Allocator&gt;&amp; str);
</pre></blockquote>

<p>
The definition in 21.4.8.9 [string.io] lists two:
</p>

<blockquote><pre>template&lt;class charT, class traits, class Allocator&gt;
 basic_ostream&lt;charT, traits&gt;&amp;
   operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp; os,
              const basic_string&lt;charT,traits,Allocator&gt;&amp; str);

template&lt;class charT, class traits, class Allocator&gt;
 basic_ostream&lt;charT, traits&gt;&amp;
   operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp;&amp; os,
              const basic_string&lt;charT,traits,Allocator&gt;&amp; str);
</pre></blockquote>

<p>
I believe the synopsis in 21.3 [string.classes] is correct, and the first of the two
signatures in 21.4.8.9 [string.io] should be deleted.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Delete the first of the two signatures in 21.4.8.9 [string.io]:
</p>

<blockquote><pre><del>template&lt;class charT, class traits, class Allocator&gt;
 basic_ostream&lt;charT, traits&gt;&amp;
   operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp; os,
              const basic_string&lt;charT,traits,Allocator&gt;&amp; str);</del>

template&lt;class charT, class traits, class Allocator&gt;
 basic_ostream&lt;charT, traits&gt;&amp;
   operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp;&amp; os,
              const basic_string&lt;charT,traits,Allocator&gt;&amp; str);
</pre></blockquote>





<hr>
<h3><a name="827"></a>827. <tt>constexpr shared_ptr::shared_ptr()?</tt></h3>
<p><b>Section:</b> 20.9.10.2.1 [util.smartptr.shared.const] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> Peter Dimov <b>Opened:</b> 2008-04-11 <b>Last modified:</b> 2010-11-20</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#util.smartptr.shared.const">issues</a> in [util.smartptr.shared.const].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Would anyone object to making the default constructor of <tt>shared_ptr</tt> (and
<tt>weak_ptr</tt> and <tt>enable_shared_from_this</tt>) <tt>constexpr</tt>? This would enable
static initialization for <tt>shared_ptr</tt> variables, eliminating another
unfair advantage of raw pointers.
</p>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
<p>
It's not clear to us that you can initialize a pointer with the literal
0 in a constant expression. We need to ask CWG to make sure this works.
Bjarne has been appointed to do this.
</p>
<p>
Core got back to us and assured as that <tt>nullptr</tt> would do the job
nicely here.
</p>
</blockquote>

<p><i>[
2009-05-01 Alisdair adds:
]</i></p>


<blockquote>
<p>
I don't believe that <tt>constexpr</tt> will buy anything in this case.
<tt>shared_ptr/weak_ptr/enable_shared_from_this</tt> cannot be literal types as they
have a non-trivial copy constructor.  As they do not produce literal types,
then the <tt>constexpr</tt> default constructor will <em>not</em> guarantee constant
initialization, and so not buy the hoped for optimization.
</p>
<p>
I recommend referring this back to Core to see if we can get static
initialization for types with <tt>constexpr</tt> constructors, even if they are not
literal types.  Otherwise this should be closed as NAD.
</p>
</blockquote>

<p><i>[
2009-05-26 Daniel adds:
]</i></p>


<blockquote>
If Alisdair's 2009-05-01 comment is correct, wouldn't that also make
<tt>constexpr mutex()</tt> useless, because this class has a non-trivial
destructor? (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#828">828</a>)
</blockquote>

<p><i>[
2009-07-21 Alisdair adds:
]</i></p>


<blockquote>
<p>
The feedback from core is that this and similar uses of <tt>constexpr</tt>
constructors to force static initialization should be supported.  If
there are any problems with this in the working draught, we should file
core issues.
</p>

<p>
Recommend we declare the default constructor <tt>constexpr</tt> as the issue suggests
(proposed wording added).
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
<del>NAD Editorial</del><ins>Resolved</ins>.  Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2994.html">N2994</a>.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 20.9.10.2 [util.smartptr.shared] and 20.9.10.2.1 [util.smartptr.shared.const]:
</p>

<blockquote><pre><ins>constexpr</ins> shared_ptr();
</pre></blockquote>

<p>
Change 20.9.10.3 [util.smartptr.weak] and 20.9.10.3.1 [util.smartptr.weak.const]:
</p>

<blockquote><pre><ins>constexpr</ins> weak_ptr();
</pre></blockquote>

<p>
Change 20.9.10.4 [util.smartptr.enab] (2 places):
</p>

<blockquote><pre><ins>constexpr</ins> enable_shared_from_this();
</pre></blockquote>






<hr>
<h3><a name="829"></a>829. current_exception wording unclear about exception type</h3>
<p><b>Section:</b> 18.8.5 [propagation] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Beman Dawes <b>Opened:</b> 2008-04-20 <b>Last modified:</b> 2010-10-29</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#propagation">active issues</a> in [propagation].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#propagation">issues</a> in [propagation].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>Consider this code:</p>

<blockquote>
<pre>exception_ptr xp;</pre>
<pre>try {do_something(); }

catch (const runtime_error&amp; ) {xp = current_exception();}

...

rethrow_exception(xp);</pre>
</blockquote>

<p>
Say <code>do_something()</code> throws an exception object of type <code>
range_error</code>. What is the type of the exception object thrown by <code>
rethrow_exception(xp)</code> above? It must have a type of <code>range_error</code>; 
if it were of type <code>runtime_error</code> it still isn't possible to 
propagate an exception and the exception_ptr/current_exception/rethrow_exception 
machinery serves no useful purpose.
</p>

<p>
Unfortunately, the current wording does not explicitly say that. Different 
people read the current wording and come to different conclusions. While it may 
be possible to deduce the correct type from the current wording, it would be 
much clearer to come right out and explicitly say what the type of the referred 
to exception is.
</p>

<p><i>[
Peter adds:
]</i></p>


<blockquote>
<p>
I don't like the proposed resolution of 829. The normative text is
unambiguous that the <tt>exception_ptr</tt> refers to the <em>currently handled
exception</em>. This term has a standard meaning, see 15.3 [except.handle]/8; this is the
exception that <tt>throw;</tt> would rethrow, see 15.1 [except.throw]/7.
</p>
<p>
A better way to address this is to simply add the non-normative example
in question as a clarification. The term <i>currently handled exception</i>
should be italicized and cross-referenced. A [<i>Note:</i> the currently
handled exception is the exception that a throw expression without an
operand (15.1 [except.throw]/7) would rethrow. <i>--end note</i>] is also an option.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>

<p>
After 18.8.5 [propagation] , paragraph 7, add the indicated text:
</p>

<blockquote>
<pre>exception_ptr current_exception();</pre>

<blockquote>
<p>
<i>Returns:</i> <code>exception_ptr</code> object that refers 
to the currently handled exception <ins>(15.3 [except.handle])</ins> or a copy of the currently handled 
exception, or a null <code>exception_ptr</code> object if no exception is being handled. If 
the function needs to allocate memory and the attempt fails, it returns an
<code>exception_ptr</code> object that refers to an instance of <code>bad_alloc</code>. 
It is unspecified whether the return values of two successive calls to
<code>current_exception</code> refer to the same exception object. 
[<i>Note:</i> that is, it 
is unspecified whether <code>current_exception</code>
creates a new copy each time it is called.
<i>-- end note</i>]
</p>

<p>
<i>Throws:</i> nothing.
</p>

</blockquote>
</blockquote>






<hr>
<h3><a name="834"></a>834. Unique_ptr::pointer requirements underspecified</h3>
<p><b>Section:</b> 20.9.9.2 [unique.ptr.single] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2008-05-14 <b>Last modified:</b> 2010-11-19</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#unique.ptr.single">issues</a> in [unique.ptr.single].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#673">673</a> (including recent updates by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#821">821</a>) proposes a useful
extension point for <tt>unique_ptr</tt> by granting support for an optional
<tt>deleter_type::pointer</tt> to act as pointer-like replacement for <tt>element_type*</tt>
(In the following: <tt>pointer</tt>).
</p>
<p>
Unfortunately no requirements are specified for the type <tt>pointer</tt> which has
impact on at least two key features of <tt>unique_ptr</tt>:
</p>

<ol>
<li>Operational fail-safety.</li>
<li>(Well-)Definedness of expressions.</li>
</ol>

<p>
<tt>Unique_ptr</tt> specification makes great efforts to require that essentially *all*
operations cannot throw and therefore adds proper wording to the affected
operations of the deleter as well. If user-provided <tt>pointer</tt>-emulating types
("smart pointers") will be allowed, either *all* throw-nothing clauses have to
be replaced by weaker "An exception is thrown only if <tt>pointer</tt>'s {op} throws
an exception"-clauses or it has to be said explicitly that all used
operations of
<tt>pointer</tt> are required *not* to throw. I understand the main focus of <tt>unique_ptr</tt>
to be as near as possible to the advantages of native pointers which cannot
fail and thus strongly favor the second choice. Also, the alternative position
would make it much harder to write safe and simple template code for
<tt>unique_ptr</tt>. Additionally, I assume that a general statement need to be given
that all of the expressions of <tt>pointer</tt> used to define semantics are required to
be well-formed and well-defined (also as back-end for <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#762">762</a>).
</p>

<p><i>[
Sophia Antipolis:
]</i></p>


<blockquote>
<p>
Howard: We maybe need a core concept <tt>PointerLike</tt>, but we don't need the
arithmetic (see <tt>shared_ptr</tt> vs. <tt>vector&lt;T&gt;::iterator</tt>.
</p>
<p>
Howard will go through and enumerate the individual requirements wrt. <tt>pointer</tt> for each member function.
</p>
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
Move to Ready.
</blockquote>

<p><i>[
2009-10-15 Alisdair pulls from Ready:
]</i></p>


<blockquote>
<p>
I hate to pull an issue out of Ready status, but I don't think 834 is
fully baked yet.
</p>

<p>
For reference the proposed resolution is to add the following words:
</p>

<blockquote>
<tt>unique_ptr&lt;T, D&gt;::pointer</tt>'s operations shall be
well-formed, shall have well defined behavior, and shall not throw
exceptions.
</blockquote>

<p>
This leaves me with a big question : which operations?
</p>

<p>
Are all pointer operations required to be nothrow, including operations
that have nothing to do with interactions with <tt>unique_ptr</tt>?  This was
much simpler with concepts where we could point to operations within a
certain concept, and so nail down the interactions.
</p>
</blockquote>

<p><i>[
2009-10-15 Daniel adds:
]</i></p>


<blockquote>
I volunteer to prepare a more fine-grained solution, but I would like
to ask for feedback that helps me doing so. If this question is asked
early in the meeting I might be able to fix it within the week, but I
cannot promise that now.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Leave in open. Daniel to provide wording as already suggested.
</blockquote>

<p><i>[
2009-12-22 Daniel provided wording and rationale.
]</i></p>


<p><i>[
2010 Pittsburgh:  Moved to NAD Editorial.  Rationale added below.
]</i></p>




<p><b>Rationale:</b></p>
<p>
The here proposed resolution has considerable overlap with the requirements that
are used in the allocator requirements.
</p>

<p>
This might be a convincing argument to isolate the common subset into one
requirement. The reason I did not do that is basically because we might find out
that they are either over-constraining or under-constraining at this late point
of specification. Note also that as a result of the idea of a general
requirement set I added the requirement
</p>

<blockquote>
A default-initialized object may have a singular value
</blockquote>

<p>
even though this does not play a relevant role for <tt>unique_ptr</tt>.
</p>

<p>
One further characteristics of the resolution is that availability of relational
operators of <tt>unique_ptr&lt;T, D&gt;::pointer</tt> is not part of the basic
requirements, which is in sync with the allocator requirements on pointer-like
(this means that <tt>unique_ptr</tt> can hold a <tt>void_pointer</tt> or
<tt>const_void_pointer</tt>).
</p>

<p>
Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3073.html">N3073</a>.
</p>



<p><b>Proposed resolution:</b></p>

<ol>

<li>
<p>
Change 20.9.9.2 [unique.ptr.single]/1 as indicated: <i>[The intent is to
replace the coupling between <tt>T*</tt> and the deleter's <tt>operator()</tt>
by a coupling between <tt>unique_ptr&lt;T, D&gt;::pointer</tt> and this
<tt>operator()</tt>]</i>
</p>

<blockquote>
1 - The default type for the template parameter <tt>D</tt> is
<tt>default_delete</tt>. A client-supplied template argument <tt>D</tt> shall be
a function pointer or functor for which, given a value <tt>d</tt> of type
<tt>D</tt> and a <del>pointer</del> <ins>value</ins> <tt>ptr</tt> of type
<tt><del>T*</del> <ins>unique_ptr&lt;T, D&gt;::pointer</ins></tt>, the
expression <tt>d(ptr)</tt> is valid and has the effect of deallocating the
pointer as appropriate for that deleter. <tt>D</tt> may also be an
lvalue-reference to a deleter.
</blockquote>
</li>

<li>
<p>
Change 20.9.9.2 [unique.ptr.single]/3 as indicated:
</p>

<blockquote>
<p>
3 - If the type <tt>remove_reference&lt;D&gt;::type::pointer</tt> exists, then
<tt>unique_ptr&lt;T, D&gt;::pointer</tt> shall be a synonym for
<tt>remove_reference&lt;D&gt;::type::pointer</tt>. Otherwise
<tt>unique_ptr&lt;T, D&gt;::pointer</tt> shall be a synonym for <tt>T*</tt>. The
type <tt>unique_ptr&lt;T, D&gt;::pointer</tt> shall <del>be</del> <ins>satisfy
the requirements of <tt>EqualityComparable</tt>,
<tt>DefaultConstructible</tt>,</ins> <tt>CopyConstructible</tt> <del>(Table 34)
and</del><ins>,</ins> <tt>CopyAssignable</tt> <del>(Table 36)</del><ins>,
<tt>Swappable</tt>, and <tt>Destructible</tt> (20.2.1 [utility.arg.requirements]). A default-initialized object may have a
singular value.  A value-initialized object produces the null value of the type.
The null value shall be equivalent only to itself. An object of this type can be
copy-initialized with a value of type <tt>nullptr_t</tt>, compared for equality
with a value of type <tt>nullptr_t</tt>, and assigned a value of type
<tt>nullptr_t</tt>. The effect shall be as if a value-initialized object had
been used in place of the null pointer constant. An object <tt>p</tt> of this
type can be contextually converted to <tt>bool</tt>. The effect shall be as if
<tt>p != nullptr</tt> had been evaluated in place of <tt>p</tt>. No operation on
this type which is part of the above mentioned requirements shall exit via an
exception.
</ins>
</p>
<p><ins>
[<i>Note:</i> Given an allocator type <tt>X</tt> (20.2.5 [allocator.requirements]), the types <tt>X::pointer</tt>,
<tt>X::const_pointer</tt>, <tt>X::void_pointer</tt>, and
<tt>X::const_void_pointer</tt> may be used as <tt>unique_ptr&lt;T,
D&gt;::pointer</tt>  <i>end note</i>]
</ins></p>

<p><ins>
In addition to being available via inclusion of the <tt>&lt;utility&gt;</tt>
header, the <tt>swap</tt> function template in 20.3.2 [utility.swap] is
also available within the definition of <tt>unique_ptr</tt>'s <tt>swap</tt>
function.
</ins></p>
</blockquote>
</li>

<li>
<p>
Change 20.9.9.2.1 [unique.ptr.single.ctor]/2+3 as indicated: <i>[The first
change ensures that we explicitly say, how the stored pointer is initialized.
This is important for a <tt>constexpr</tt> function, because this may make a
difference for user-defined pointer-like types]</i>
</p>

<blockquote><pre>constexpr unique_ptr();
</pre>
<blockquote>
<p>...</p>
<p>
2 - <i>Effects:</i> Constructs a <tt>unique_ptr</tt> which owns nothing<ins>,
value-initializing the stored pointer</ins>.
</p>

<p>
3 - <i>Postconditions:</i> <tt>get() == <del>0</del> <ins>nullptr</ins></tt>.
</p>
</blockquote>
</blockquote>
</li>

<li>
<p>
Change 20.9.9.2.1 [unique.ptr.single.ctor]/6+7 as indicated: <i>[This is a
step-by-fix to ensure consistency to the changes of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2976.html">N2976</a>]</i>
</p>

<blockquote><pre>unique_ptr(pointer p);
</pre>
<blockquote>
<p>...</p>
<p>
6 - <i>Effects:</i> Constructs a <tt>unique_ptr</tt> which owns <tt>p</tt><ins>,
initializing the stored pointer with <tt>p</tt></ins>.
</p>

<p>
7 - <i>Postconditions:</i> <tt>get() == p</tt>. <tt>get_deleter()</tt> returns a
reference to a <del>default constructed</del> <ins>value-initialized</ins>
deleter <tt>D</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li>
<p>
Insert a new effects clause in 20.9.9.2.1 [unique.ptr.single.ctor] just
before p. 14: <i>[The intent is to fix the current lack of specification in
which way the stored pointer is initialized]</i>
</p>

<blockquote><pre>unique_ptr(pointer p, <i><del>implementation-defined</del> <ins>see below</ins></i> d1);
unique_ptr(pointer p, <i><del>implementation-defined</del> <ins>see below</ins></i> d2);
</pre>
<blockquote>
<p>...</p>
<p><ins>
<i>Effects:</i> Constructs a <tt>unique_ptr</tt> which owns <tt>p</tt>,
initializing the stored pointer with <tt>p</tt> and the initializing the deleter
as described above.
</ins></p>

<p>
14 - <i>Postconditions:</i> <tt>get() == p</tt>. <tt>get_deleter()</tt> returns a
reference to the internally stored deleter. If <tt>D</tt> is a reference type
then <tt>get_deleter()</tt> returns a reference to the lvalue <tt>d</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li>
<p>
Change 20.9.9.2.1 [unique.ptr.single.ctor]/18+22 as indicated: <i>[The intent
is to clarify that the moved-from source must contain a null pointer, there is
no other choice left]</i>
</p>

<blockquote><pre>unique_ptr(unique_ptr&amp;&amp; u);
</pre>
<blockquote>
<p>
[..]
</p>

<p>
18 - <i>Postconditions:</i> <tt>get() == value u.get()</tt> had before the
construction<ins> and <tt>u.get() == nullptr</tt></ins>. <tt>get_deleter()</tt>
returns a reference to the internally stored deleter which was constructed from
<tt>u.get_deleter()</tt>. If <tt>D</tt> is a reference type then
<tt>get_deleter()</tt> and <tt>u.get_deleter()</tt> both reference the same
lvalue deleter.
</p>

</blockquote>

<pre>template &lt;class U, class E&gt; unique_ptr(unique_ptr&lt;U, E&gt;&amp;&amp; u);
</pre>

<blockquote>

<p>
[..]
</p>

<p>
22 - <i>Postconditions:</i> <tt>get() == value u.get()</tt> had before the
construction, modulo any required offset adjustments resulting from the cast
from <tt>unique_ptr&lt;U, E&gt;::pointer</tt> to <tt>pointer</tt><ins> and
<tt>u.get() == nullptr</tt></ins>. <tt>get_deleter()</tt> returns a reference to
the internally stored deleter which was constructed from
<tt>u.get_deleter()</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li>
<p>
Change 20.9.9.2.1 [unique.ptr.single.ctor]/20 as indicated: <i>[With the
possibility of user-defined pointer-like types the implication does only exist,
if those are built-in pointers. Note that this change should also be applied
with the acceptance of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#950">950</a>]</i>
</p>

<blockquote><pre>template &lt;class U, class E&gt; unique_ptr(unique_ptr&lt;U, E&gt;&amp;&amp; u);
</pre>
<blockquote>
20 - <i>Requires:</i> If <tt>D</tt> is not a reference type, construction of the
deleter <tt>D</tt> from an rvalue of type <tt>E</tt> shall be well formed and
shall not throw an exception. If <tt>D</tt> is a reference type, then <tt>E</tt>
shall be the same type as <tt>D</tt> (diagnostic required). <tt>unique_ptr&lt;U,
E&gt;::pointer</tt> shall be implicitly convertible to <tt>pointer</tt>.
<del>[<i>Note:</i> These requirements imply that <tt>T</tt> and <tt>U</tt> are
complete types.  <i>end note</i>]</del>
</blockquote>
</blockquote>
</li>

<li>
<p>
Change 20.9.9.2.2 [unique.ptr.single.dtor]/2 as indicated:
</p>

<blockquote><pre>~unique_ptr();
</pre>
<blockquote>
<p>...</p>
<p>
2 - <i>Effects:</i> If <tt>get() == <del>0</del> <ins>nullptr</ins></tt> there
are no effects. Otherwise <tt>get_deleter()(get())</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li>
<p>
Change 20.9.9.2.3 [unique.ptr.single.asgn]/3+8 as indicated: <i>[The intent is to
clarify that the moved-from source must contain a null pointer, there
is no other choice left]</i>
</p>

<blockquote><pre>unique_ptr&amp; operator=(unique_ptr&amp;&amp; u);
</pre>
<blockquote>
<p>[..]</p>
<p>
3 - <i>Postconditions:</i> This <tt>unique_ptr</tt> now owns the pointer which <tt>u</tt>
owned, and <tt>u</tt> no longer owns it<ins>, <tt>u.get() == nullptr</tt></ins>.
[<i>Note:</i> If <tt>D</tt> is a reference type, then the referenced lvalue deleters
are move assigned.  <i>end note</i>]
</p>
</blockquote>

<pre>template &lt;class U, class E&gt; unique_ptr&amp; operator=(unique_ptr&lt;U, E&gt;&amp;&amp; u);
</pre>

<blockquote>
<p>[..]</p>

<p>
8 - <i>Postconditions:</i> This <tt>unique_ptr</tt> now owns the pointer which
<tt>u</tt> owned, and <tt>u</tt> no longer owns it<ins>, <tt>u.get() ==
nullptr</tt></ins>.
</p>
</blockquote>
</blockquote>
</li>

<li>
<p>
Change 20.9.9.2.3 [unique.ptr.single.asgn]/6 as indicated: <i>[With the
possibility of user-defined pointer-like types the implication does only exist,
if those are built-in pointers. Note that this change should also be applied
with the acceptance of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#950">950</a>]</i>
</p>

<blockquote><pre>template &lt;class U, class E&gt; unique_ptr&amp; operator=(unique_ptr&lt;U, E&gt;&amp;&amp; u);
</pre>
<blockquote>
<p>[..]</p>
<p>
6 - <i>Requires:</i> Assignment of the deleter <tt>D</tt> from an rvalue
<tt>D</tt> shall not throw an exception. <tt>unique_ptr&lt;U,
E&gt;::pointer</tt> shall be implicitly convertible to <tt>pointer</tt>.
<del>[<i>Note:</i> These requirements imply that <tt>T</tt> and <tt>U</tt> are
complete types.  <i>end note</i>]</del>
</p>
</blockquote>
</blockquote>
</li>

<li>
<p>
Change 20.9.9.2.3 [unique.ptr.single.asgn] before p. 11 and p. 12 as
indicated: <i>[The first change is a simple typo fix]</i>
</p>

<blockquote><pre>unique_ptr&amp; operator=(nullptr_t<del>}</del><ins>)</ins>;
</pre>

<blockquote>
<p>
11 - <i>Effects:</i> <tt>reset()</tt>.
</p>

<p>
12 - <i>Postcondition:</i> <tt>get() == <del>0</del> <ins>nullptr</ins></tt>
</p>
</blockquote>
</blockquote>
</li>

<li>
<p>
Change 20.9.9.2.4 [unique.ptr.single.observers]/1+4+12 as indicated:
</p>

<blockquote><pre>typename add_lvalue_reference&lt;T&gt;::type operator*() const;
</pre>
<blockquote>
<p>
1 - <i>Requires:</i> <tt>get() != <del>0</del> <ins>nullptr</ins></tt>. <ins>The
variable definition <tt>add_lvalue_reference&lt;T&gt;::type t = *get()</tt>
shall be well formed, shall have well-defined behavior, and shall not exit via
an exception.</ins>
</p>
<p>
[..]
</p>

</blockquote>

<pre>pointer operator-&gt;() const;
</pre>

<blockquote>
<p>
4 - <i>Requires:</i> <tt>get() != <del>0</del> <ins>nullptr</ins></tt>.
</p>

<p>
[..]
</p>

</blockquote>

<pre>explicit operator bool() const;
</pre>

<blockquote>
12 - <i>Returns:</i> <tt>get() != <del>0</del><ins>nullptr</ins></tt>.
</blockquote>
</blockquote>
</li>

<li>
<p>
Change 20.9.9.2.5 [unique.ptr.single.modifiers]/1 as indicated:
</p>

<blockquote><pre>pointer release();
</pre>

<blockquote>
1 - <i>Postcondition:</i> <tt>get() == <del>0</del> <ins>nullptr</ins></tt>.
</blockquote>
</blockquote>
</li>

<li>
<p>
Change 20.9.9.2.5 [unique.ptr.single.modifiers]/9 as indicated: <i>[The
intent is to ensure that potentially user-defined swaps are used. A side-step
fix and harmonization with the specification of the the deleter is realized.
Please note the additional requirement in bullet 2 of this proposed resolution
regarding the availability of the generic <tt>swap</tt> templates within the
member <tt>swap</tt> function.]</i>
</p>

<blockquote><pre>void swap(unique_ptr&amp; u);
</pre>

<blockquote>
<p>
8 - <i>Requires:</i> The deleter <tt>D</tt> shall be <tt>Swappable</tt> and
shall not throw an exception under <tt>swap</tt>.
</p>

<p>
9 - <i>Effects:</i> The stored pointers of <tt><ins>*</ins>this</tt> and
<tt>u</tt> are exchanged <ins>by an unqualified call to non-member
<tt>swap</tt></ins>. The stored deleters are <del><tt>swap</tt>'d
(unqualified)</del> <ins>exchanged by an unqualified call to non-member
<tt>swap</tt></ins>.
</p>
</blockquote>
</blockquote>
</li>

<li>
<p>
Change 20.9.9.3.2 [unique.ptr.runtime.observers]/1 as indicated:
</p>

<blockquote><pre>T&amp; operator[](size_t i) const;
</pre>
<blockquote>
<i>Requires:</i> <tt>i &lt;</tt> the size of the array to which the stored
pointer points. <ins>The variable definition <tt>T&amp; t = get()[i]</tt> shall
be well formed, shall have well-defined behavior, and shall not exit via an
exception.</ins>
</blockquote>
</blockquote>
</li>

<li>
<p>
Change 20.9.9.3.3 [unique.ptr.runtime.modifiers]/1 as indicated:
</p>

<blockquote><pre>void reset(pointer p = pointer());
void reset(nullptr_t p);
</pre>

<blockquote>
1 - <i>Effects:</i> If <tt>get() == <del>0</del> <ins>nullptr</ins></tt> there
are no effects. Otherwise <tt>get_deleter()(get())</tt>.
</blockquote>
</blockquote>
</li>

<li>
<p>
Change 20.9.9.4 [unique.ptr.special] as indicated: <i>[We don't add the
relational operators to the basic requirement set, therefore we need special
handling here]</i>
</p>

<blockquote>
<pre>template &lt;class T1, class D1, class T2, class D2&gt;
  bool operator==(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);
</pre>

<blockquote>
<p>
<ins><i>Requires:</i> The variable definition <tt>bool b = x.get() ==
y.get();</tt> shall be well formed, shall have well-defined behavior, and shall
not exit via an exception.</ins>
</p>

<p>
2 - <i>Returns:</i> <tt>x.get() == y.get()</tt>.
</p>

<p><ins>
<i>Throws:</i> nothing.
</ins></p>
</blockquote>

<pre>template &lt;class T1, class D1, class T2, class D2&gt;
  bool operator!=(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);
</pre>

<blockquote>
<p>
<ins>Requires: The variable definition <tt>bool b = x.get() != y.get();</tt>
shall be well formed, shall have well-defined behavior, and shall not exit via
an exception.</ins>
</p>

<p>
3 - <i>Returns:</i> <tt>x.get() != y.get()</tt>.
</p>

<p><ins>
<i>Throws:</i> nothing.
</ins></p>
</blockquote>

<pre>template &lt;class T1, class D1, class T2, class D2&gt;
  bool operator&lt;(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);
</pre>

<blockquote>
<p>
<ins>Requires: The variable definition <tt>bool b = x.get() &lt; y.get()</tt>;
shall be well formed, shall have well-defined behavior, and shall not exit via
an exception.</ins>
</p>

<p>
4 - <i>Returns:</i> <tt>x.get() &lt; y.get()</tt>.
</p>

<p><ins>
<i>Throws:</i> nothing.
</ins></p>
</blockquote>

<pre>template &lt;class T1, class D1, class T2, class D2&gt;
  bool operator&lt;=(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);
</pre>

<blockquote>
<p>
<ins>Requires: The variable definition <tt>bool b = x.get() &lt;= y.get();</tt>
shall be well formed, shall have well-defined behavior, and shall not exit via
an exception.</ins>
</p>

<p>
5 - <i>Returns:</i> <tt>x.get() &lt;= y.get()</tt>.
</p>

<p><ins>
<i>Throws:</i> nothing.
</ins></p>
</blockquote>

<pre>template &lt;class T1, class D1, class T2, class D2&gt;
  bool operator&gt;(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);
</pre>

<blockquote>
<p>
<ins>Requires: The variable definition <tt>bool b = x.get() &gt; y.get();</tt>
shall be well formed, shall have well-defined behavior, and shall not exit via
an exception.</ins>
</p>

<p>
6 - <i>Returns:</i> <tt>x.get() &gt; y.get()</tt>.
</p>

<p><ins>
<i>Throws:</i> nothing.
</ins></p>
</blockquote>

<pre>template &lt;class T1, class D1, class T2, class D2&gt;
  bool operator&gt;=(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);
</pre>

<blockquote>
<p>
<ins>Requires: The variable definition <tt>bool b = x.get() &gt;= y.get();</tt>
shall be well formed, shall have well-defined behavior, and shall not exit via
an exception.</ins>
</p>

<p>
7 - <i>Returns:</i> <tt>x.get() &gt;= y.get()</tt>.
</p>

<p><ins>
<i>Throws:</i> nothing.
</ins></p>
</blockquote>

</blockquote>
</li>

</ol>







<hr>
<h3><a name="835"></a>835. tying two streams together (correction to DR 581)</h3>
<p><b>Section:</b> 27.5.4.2 [basic.ios.members] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2008-05-17 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#basic.ios.members">issues</a> in [basic.ios.members].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
       <p>

The fix for
issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#581">581</a>,
now integrated into the working paper, overlooks a couple of minor
problems.

       </p>
       <p>

First, being an unformatted function once again, <code>flush()</code>
is required to create a sentry object whose constructor must, among
other things, flush the tied stream. When two streams are tied
together, either directly or through another intermediate stream
object, flushing one will also cause a call to <code>flush()</code> on
the other tied stream(s) and vice versa, ad infinitum. The program
below demonstrates the problem.

       </p>
       <p>

Second, as Bo Persson notes in his
comp.lang.c++.moderated <a href="http://groups.google.com/group/comp.lang.c++.moderated/tree/browse_frm/thread/f2187794e9cc036d/305df31dc583054a">post</a>,
for streams with the <code>unitbuf</code> flag set such
as <code>std::stderr</code>, the destructor of the sentry object will
again call <code>flush()</code>. This seems to create an infinite
recursion for <code>std::cerr &lt;&lt; std::flush;</code>

       </p>
       <blockquote>
           <pre>#include &lt;iostream&gt;

int main ()
{
   std::cout.tie (&amp;std::cerr);
   std::cerr.tie (&amp;std::cout);
   std::cout &lt;&lt; "cout\n";
   std::cerr &lt;&lt; "cerr\n";
} 
</pre>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution.
Move to Review.
</blockquote>

<p><i>[
2009-05-26 Daniel adds:
]</i></p>


<blockquote>
<p>
I think that the most recently suggested change in
27.7.2.4 [ostream::sentry] need some further word-smithing. As
written, it would make the behavior undefined, if under
conditions when <tt>pubsync()</tt> should be called, but when
in this scenario <tt>os.rdbuf()</tt> returns 0.
</p>
<p>
This case is explicitly handled in <tt>flush()</tt> and needs to be
taken care of. My suggested fix is:
</p>

<blockquote>
If <tt>((os.flags() &amp; ios_base::unitbuf) &amp;&amp; !uncaught_exception()</tt>
<ins><tt>&amp;&amp; os.rdbuf() != 0</tt></ins>) is true, calls <del><tt>os.flush()</tt></del>
<ins><tt>os.rdbuf()-&gt;pubsync()</tt></ins>.
</blockquote>

<p>
Two secondary questions are:
</p>

<ol>
<li>
Should <tt>pubsync()</tt> be invoked in any case or shouldn't a
base requirement for this trial be that <tt>os.good() == true</tt>
as required in the original <tt>flush()</tt> case?
</li>
<li>
Since <tt>uncaught_exception()</tt> is explicitly tested, shouldn't
a return value of -1 of <tt>pubsync()</tt> produce <tt>setstate(badbit)</tt>
(which may throw <tt>ios_base::failure</tt>)?
</li>
</ol>
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
<p>
Daniel volunteered to modify the proposed resolution to address his two questions.
</p>
<p>
Move back to Open.
</p>
</blockquote>

<p><i>[
2009-07-26 Daniel provided wording.  Moved to Review.
]</i></p>


<p><i>[
2009-10-13 Daniel adds:
]</i></p>


<blockquote>
This proposed wording is written to match the outcome
of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#397">397</a>.
</blockquote>

<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote>
Move to Open. Martin to propose updated wording that will also resolve
issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#397">397</a> consistently.
</blockquote>

<p><i>[
2010-02-15 Martin provided wording.
]</i></p>


<p><i>[
2010 Pittsburgh:
]</i></p>


<blockquote>
Moved to Ready for Pittsburgh.
</blockquote>



<p><b>Proposed resolution:</b></p>

<ol>
<li>
<p>
Just before 27.5.4.2 [basic.ios.members]/2 insert a new paragraph:
</p>

<blockquote>
<ins><i>Requires:</i> If <tt>(tiestr != 0)</tt> is <tt>true</tt>,
<tt>tiestr</tt> must not be reachable by traversing the linked list of tied
stream objects starting from <tt>tiestr-&gt;tie()</tt>.</ins>
</blockquote>
</li>

<li>
<p>
Change 27.7.2.4 [ostream::sentry]/4 as indicated:
</p>

<blockquote>
If <tt>((os.flags() &amp; ios_base::unitbuf) &amp;&amp; !uncaught_exception()
<ins>&amp;&amp; os.good()</ins>)</tt> is <tt>true</tt>, calls
<del><tt>os.flush()</tt></del> <ins><tt>os.rdbuf()-&gt;pubsync()</tt>. If that
function returns -1 sets <tt>badbit</tt> in <tt>os.rdstate()</tt> without
propagating an exception</ins>.
</blockquote>
</li>

<li>
<p>
Add after 27.7.2.4 [ostream::sentry] p17, the following paragraph:
</p>

<blockquote>
<ins><i>Throws:</i> Nothing.</ins>
</blockquote>

</li>

</ol>


   



<hr>
<h3><a name="836"></a>836. 
       effects of <code>money_base::space</code> and
       <code>money_base::none</code> on <code>money_get</code>
   </h3>
<p><b>Section:</b> 22.4.6.1.2 [locale.money.get.virtuals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2008-05-17 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.money.get.virtuals">issues</a> in [locale.money.get.virtuals].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#670">670</a></p>
<p><b>Discussion:</b></p>

       <p>

In paragraph 2, 22.4.6.1.2 [locale.money.get.virtuals] specifies the following:

       </p>
       <blockquote>

Where <code>space</code> or <code>none</code> appears in the format
pattern, except at the end, optional white space (as recognized
by <code>ct.is</code>) is consumed after any required space.

       </blockquote>
       <p>

This requirement can be (and has been) interpreted two mutually
exclusive ways by different readers. One possible interpretation
is that:

       </p>
       <blockquote>
           <ol>
               <li>

where <code>money_base::space</code> appears in the format, at least
one space is required, and

               </li>
               <li>

where <code>money_base::none</code> appears in the format, space is
allowed but not required.

               </li>
           </ol>
       </blockquote>
       <p>

The other is that:

       </p>
       <blockquote>

where either <code>money_base::space</code> or <code>money_base::none</code> appears in the format, white space is optional.

       </blockquote>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
Martin will revise the proposed resolution.
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
<p>
There is a noun missing from the proposed resolution. It's not clear
that the last sentence would be helpful, even if the word were not
missing:
</p>
<blockquote>
In either case, any required MISSINGWORD followed by all optional whitespace (as recognized by ct.is()) is consumed.
</blockquote>
<p>
Strike this sentence and move to Review.
</p>

<p><i>[
Howard: done.
]</i></p>

</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Move to Ready.
</blockquote>

   

   <p><b>Proposed resolution:</b></p>
       <p>

I propose to change the text to make it clear that the first
interpretation is intended, that is, to make following change to
22.4.6.1.2 [locale.money.get.virtuals], p2:

       </p>

       <blockquote>

When <code><ins>money_base::</ins>space</code>
or <code><ins>money_base::</ins>none</code> appears <ins>as the last
element </ins>in the format pattern, <del>except at the end, optional
white space (as recognized by <code>ct.is</code>) is consumed after
any required space.</del> <ins>no white space is consumed. Otherwise,
where <code>money_base::space</code> appears in any of the initial
elements of the format pattern, at least one white space character is
required. Where <code>money_base::none</code> appears in any of the
initial elements of the format pattern, white space is allowed but not
required.</ins>
If <code>(str.flags() &amp; str.showbase)</code> is <code>false</code>, ...

       </blockquote>
   



<hr>
<h3><a name="838"></a>838. 
   can an <i>end-of-stream</i> iterator become a <i>non-end-of-stream</i> one?
 </h3>
<p><b>Section:</b> 24.6.1 [istream.iterator] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2008-05-17 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#istream.iterator">issues</a> in [istream.iterator].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
   <p>

From message c++std-lib-20003...

   </p>
   <p>

The description of <code>istream_iterator</code> in
24.6.1 [istream.iterator], p1 specifies that objects of the
class become the <i>end-of-stream</i> (EOS) iterators under the
following condition (see also issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#788">788</a> another problem
with this paragraph):

   </p>
   <blockquote>

If the end of stream is reached (<code>operator void*()</code> on the
stream returns <code>false</code>), the iterator becomes equal to
the <i>end-of-stream</i> iterator value.

   </blockquote>
   <p>

One possible implementation approach that has been used in practice is
for the iterator to set its <code>in_stream</code> pointer to 0 when
it reaches the end of the stream, just like the default ctor does on
initialization. The problem with this approach is that
the <i>Effects</i> clause for <code>operator++()</code> says the
iterator unconditionally extracts the next value from the stream by
evaluating <code>*in_stream &gt;&gt; value</code>, without checking
for <code>(in_stream == 0)</code>.

   </p>
   <p>

Conformance to the requirement outlined in the <i>Effects</i> clause
can easily be verified in programs by setting <code>eofbit</code>
or <code>failbit</code> in <code>exceptions()</code> of the associated
stream and attempting to iterate past the end of the stream: each
past-the-end access should trigger an exception. This suggests that
some other, more elaborate technique might be intended.

   </p>
   <p>

Another approach, one that allows <code>operator++()</code> to attempt
to extract the value even for EOS iterators (just as long
as <code>in_stream</code> is non-0) is for the iterator to maintain a
flag indicating whether it has reached the end of the stream. This
technique would satisfy the presumed requirement implied by
the <i>Effects</i> clause mentioned above, but it isn't supported by
the exposition-only members of the class (no such flag is shown). This
approach is also found in existing practice.

   </p>
   <p>

The inconsistency between existing implementations raises the question
of whether the intent of the specification is that a non-EOS iterator
that has reached the EOS become a non-EOS one again after the
stream's <code>eofbit</code> flag has been cleared? That is, are the
assertions in the program below expected to pass?

   </p>
   <blockquote>
     <pre>   sstream strm ("1 ");
   istream_iterator eos;
   istream_iterator it (strm);
   int i;
   i = *it++
   assert (it == eos);
   strm.clear ();
   strm &lt;&lt; "2 3 ";
   assert (it != eos);
   i = *++it;
   assert (3 == i);
     </pre>
   </blockquote>
   <p>

Or is it intended that once an iterator becomes EOS it stays EOS until
the end of its lifetime?

   </p>
 
 <p><i>[
San Francisco:
]</i></p>


<blockquote>
<p>
We like the direction of the proposed resolution. We're not sure about
the wording, and we need more time to reflect on it,
</p>
<p>
Move to Open. Detlef to rewrite the proposed resolution in such a way
that no reference is made to exposition only members of
<tt>istream_iterator</tt>.
</p>
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
Move to Ready.
</blockquote>



 <p><b>Proposed resolution:</b></p>
   <p>

The discussion of this issue on the reflector suggests that the intent
of the standard is for an <code>istreambuf_iterator</code> that has
reached the EOS to remain in the EOS state until the end of its
lifetime. Implementations that permit EOS iterators to return to a
non-EOS state may only do so as an extension, and only as a result of
calling <code>istream_iterator</code> member functions on EOS
iterators whose behavior is in this case undefined.

   </p>
   <p>

To this end we propose to change 24.6.1 [istream.iterator], p1,
as follows:

   </p>
   <blockquote>

The result of operator-&gt; on an end<ins>-</ins>of<ins>-</ins>stream
is not defined. For any other iterator value a <code>const T*</code>
is returned.<ins> Invoking <code>operator++()</code> on
an <i>end-of-stream</i> iterator is undefined.</ins> It is impossible
to store things into istream iterators...

   </blockquote>
   <p>

Add pre/postconditions to the member function descriptions of <code>istream_iterator</code> like so:

   </p>
   <blockquote>

<pre>istream_iterator();</pre>

<i>Effects</i>: Constructs the <i>end-of-stream</i> iterator.<br>
<ins><i>Postcondition</i>: <code>in_stream == 0</code>.</ins>

<pre>istream_iterator(istream_type &amp;s);</pre>

<i>Effects</i>: Initializes <code>in_stream</code> with &amp;s. value
may be initialized during construction or the first time it is
referenced.<br>
<ins><i>Postcondition</i>: <code>in_stream == &amp;s</code>.</ins>

<pre>istream_iterator(const istream_iterator &amp;x);</pre>

<i>Effects</i>: Constructs a copy of <code>x</code>.<br>
<ins><i>Postcondition</i>: <code>in_stream == x.in_stream</code>.</ins>

<pre>istream_iterator&amp; operator++();</pre>

<ins><i>Requires</i>: <code>in_stream != 0</code>.</ins><br>
<i>Effects</i>: <code>*in_stream &gt;&gt; value</code>.

<pre>istream_iterator&amp; operator++(int);</pre>

<ins><i>Requires</i>: <code>in_stream != 0</code>.</ins><br>
<i>Effects</i>:
   <blockquote><pre>istream_iterator tmp (*this);
*in_stream &gt;&gt; value;
return tmp;
     </pre>
     </blockquote>
   </blockquote>
 



<hr>
<h3><a name="842"></a>842. ConstructibleAsElement and bit containers</h3>
<p><b>Section:</b> 23.2 [container.requirements], 23.4.2 [vector.bool], 20.5 [template.bitset] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2008-06-03 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#container.requirements">issues</a> in [container.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
23.2 [container.requirements]/p3 says:
</p>

<blockquote>
Objects stored in these components shall be constructed using
<tt>construct_element</tt> (20.6.9). For each operation that inserts an
element of type <tt>T</tt> into a container (<tt>insert</tt>,
<tt>push_back</tt>, <tt>push_front</tt>, <tt>emplace</tt>, etc.) with
arguments <tt>args... T</tt> shall be <tt>ConstructibleAsElement</tt>,
as described in table 88. [<i>Note:</i> If the component is instantiated
with a scoped allocator of type <tt>A</tt> (i.e., an allocator for which
<tt>is_scoped_allocator&lt;A&gt;::value</tt> is <tt>true</tt>), then
<tt>construct_element</tt> may pass an inner allocator argument to
<tt>T</tt>'s constructor. <i>-- end note</i>]
</blockquote>

<p>
However <tt>vector&lt;bool, A&gt;</tt> (23.4.2 [vector.bool]) and <tt>bitset&lt;N&gt;</tt> 
(20.5 [template.bitset]) store bits, not <tt>bool</tt>s, and <tt>bitset&lt;N&gt;</tt>
does not even have an allocator.  But these containers are governed by this clause.  Clearly this
is not implementable.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change 23.2 [container.requirements]/p3:
</p>

<blockquote>
Objects stored in these components shall be constructed using
<tt>construct_element</tt> (20.6.9)<ins>, unless otherwise specified</ins>.
For each operation that inserts an
element of type <tt>T</tt> into a container (<tt>insert</tt>,
<tt>push_back</tt>, <tt>push_front</tt>, <tt>emplace</tt>, etc.) with
arguments <tt>args... T</tt> shall be <tt>ConstructibleAsElement</tt>,
as described in table 88. [<i>Note:</i> If the component is instantiated
with a scoped allocator of type <tt>A</tt> (i.e., an allocator for which
<tt>is_scoped_allocator&lt;A&gt;::value</tt> is <tt>true</tt>), then
<tt>construct_element</tt> may pass an inner allocator argument to
<tt>T</tt>'s constructor. <i>-- end note</i>]
</blockquote>

<p>
Change 23.4.2 [vector.bool]/p2:
</p>

<blockquote>
Unless described below, all operations have the same requirements and semantics as the primary <tt>vector</tt> template, 
except that operations dealing with the <tt>bool</tt> value type map to bit values in the container storage<ins>,
and <tt>construct_element</tt> (23.2 [container.requirements]) is not used to construct these values</ins>.
</blockquote>

<p>
Move 20.5 [template.bitset] to clause 20.
</p>






<hr>
<h3><a name="843"></a>843.  Reference Closure</h3>
<p><b>Section:</b> X [func.referenceclosure.cons] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Lawrence Crowl <b>Opened:</b> 2008-06-02 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <tt>std::reference_closure</tt> type has a deleted copy assignment operator
under the theory that references cannot be assigned, and hence the
assignment of its reference member must necessarily be ill-formed.
</p>
<p>
However, other types, notably <tt>std::reference_wrapper</tt> and <tt>std::function</tt>
provide for the "copying of references", and thus the current definition
of <tt>std::reference_closure</tt> seems unnecessarily restrictive.  In particular,
it should be possible to write generic functions using both <tt>std::function</tt>
and <tt>std::reference_closure</tt>, but this generality is much harder when
one such type does not support assignment.
</p>
<p>
The definition of <tt>reference_closure</tt> does not necessarily imply direct
implementation via reference types.  Indeed, the <tt>reference_closure</tt> is
best implemented via a frame pointer, for which there is no standard
type.
</p>
<p>
The semantics of assignment are effectively obtained by use of the
default destructor and default copy assignment operator via
</p>

<blockquote><pre>x.~reference_closure(); new (x) reference_closure(y);
</pre></blockquote>

<p>
So the copy assignment operator generates no significant real burden
to the implementation.
</p>


<p><b>Proposed resolution:</b></p>
<p>
In  [func.referenceclosure] Class template reference_closure,
replace the <tt>=delete</tt> in the copy assignment operator in the synopsis
with <tt>=default</tt>.
</p>

<blockquote><pre>template&lt;class R , class... ArgTypes &gt; 
  class reference_closure&lt;R (ArgTypes...)&gt; { 
  public:
     ...
     reference_closure&amp; operator=(const reference_closure&amp;) = <del>delete</del> <ins>default</ins>;
     ...
</pre></blockquote>

<p>
In X [func.referenceclosure.cons] Construct, copy, destroy,
add the member function description
</p>

<blockquote>
<pre>reference_closure&amp; operator=(const reference_closure&amp; f)
</pre>
<blockquote>
<p>
<i>Postcondition:</i> <tt>*this</tt> is a copy of <tt>f</tt>.
</p>
<p>
<i>Returns:</i> <tt>*this</tt>.
</p>
</blockquote>
</blockquote>







<hr>
<h3><a name="844"></a>844. <tt>complex pow</tt> return type is ambiguous</h3>
<p><b>Section:</b> 26.4.9 [cmplx.over] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2008-06-03 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#cmplx.over">issues</a> in [cmplx.over].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The current working draft is in an inconsistent state.
</p>

<p>
26.4.8 [complex.transcendentals] says that:
</p>

<blockquote>
<tt>pow(complex&lt;float&gt;(), int())</tt> returns a <tt>complex&lt;float&gt;</tt>.
</blockquote>

<p>
26.4.9 [cmplx.over] says that:
</p>

<blockquote>
<tt>pow(complex&lt;float&gt;(), int())</tt> returns a <tt>complex&lt;double&gt;</tt>.
</blockquote>

<p><i>[
Sophia Antipolis:
]</i></p>


<blockquote>
<p>
Since <tt>int</tt> promotes to <tt>double</tt>, and C99 doesn't have an <tt>int</tt>-based
overload for <tt>pow</tt>, the C99 result is <tt>complex&lt;double&gt;</tt>, see also C99
7.22, see also library issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#550">550</a>.
</p>
<p>
Special note: ask P.J. Plauger.
</p>
<blockquote>
Looks fine.
</blockquote>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Strike this <tt>pow</tt> overload in 26.4.1 [complex.syn] and in 26.4.8 [complex.transcendentals]:
</p>

<blockquote><pre><del>template&lt;class T&gt; complex&lt;T&gt; pow(const complex&lt;T&gt;&amp; x, int y);</del>
</pre></blockquote>





<hr>
<h3><a name="845"></a>845. atomics cannot support aggregate initialization</h3>
<p><b>Section:</b> X [atomics.types] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2008-06-03 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#atomics.types">issues</a> in [atomics.types].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The atomic classes (and class templates) are required to support aggregate
initialization (29.5.1 [atomics.types.integral]p2 / 29.5.2 [atomics.types.address]p1)
yet also have user declared constructors, so cannot be aggregates.
</p>
<p>
This problem might be solved with the introduction of the proposed
initialization syntax at Antipolis, but the wording above should be altered.
Either strike the sentence as redundant with new syntax, or refer to 'brace
initialization'.
</p>

<p><i>[
Jens adds:
]</i></p>


<blockquote>
<p>
Note that
</p>
<blockquote><pre>atomic_itype a1 = { 5 };
</pre></blockquote>
<p>
would be aggregate-initialization syntax (now coming under the disguise
of brace initialization), but would be ill-formed, because the corresponding
constructor for atomic_itype is explicit.  This works, though:
</p>
<blockquote><pre>atomic_itype a2 { 6 };
</pre></blockquote>

</blockquote>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
<p>
The preferred approach to resolving this is to remove the explicit
specifiers from the atomic integral type constructors.
</p>
<p>
Lawrence will provide wording.
</p>
<p>
This issue is addressed in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2783.html">N2783</a>.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
within the synopsis in 29.5.1 [atomics.types.integral] edit as follows.
</p>

<blockquote><pre><code>
....
typedef struct atomic_bool {
....
  constexpr <del>explicit</del> atomic_bool(bool);
....
typedef struct atomic_<var>itype</var> {
....
  constexpr <del>explicit</del> atomic_<var>itype</var>(<var>integral</var>);
....
</code></pre></blockquote>

<p>
edit 29.5.1 [atomics.types.integral] paragraph 2 as follows.
</p>

<blockquote>
The atomic integral types shall have standard layout.
They shall each have a trivial default constructor,
a constexpr <del>explicit</del> value constructor,
a deleted copy constructor,
a deleted copy assignment operator,
and a trivial destructor.
They shall each support aggregate initialization syntax.
</blockquote>

<p>
within the synopsis of 29.5.2 [atomics.types.address] edit as follows.
</p>

<blockquote><pre><code>
....
typedef struct atomic_address {
....
  constexpr <del>explicit</del> atomic_address(void*);
....
</code></pre></blockquote>

<p>
edit 29.5.2 [atomics.types.address] paragraph 1 as follows.
</p>

<blockquote>
The type <code>atomic_address</code> shall have standard layout.
It shall have a trivial default constructor,
a constexpr <del>explicit</del> value constructor,
a deleted copy constructor,
a deleted copy assignment operator,
and a trivial destructor.
It shall support aggregate initialization syntax.
</blockquote>

<p>
within the synopsis of 29.5 [atomics.types.generic] edit as follows.
</p>

<blockquote><pre><code>
....
template &lt;class T&gt; struct atomic {
....
  constexpr <del>explicit</del> atomic(T);
....
template &lt;&gt; struct atomic&lt;<var>integral</var>&gt; : atomic_<var>itype</var> {
....
  constexpr <del>explicit</del> atomic(<var>integral</var>);
....
template &lt;&gt; struct atomic&lt;T*&gt; : atomic_address {
....
  constexpr <del>explicit</del> atomic(T*);
....
</code></pre></blockquote>

<p>
edit 29.5 [atomics.types.generic] paragraph 2 as follows.
</p>

<blockquote>
Specializations of the <code>atomic</code> template
shall have a deleted copy constructor,
a deleted copy assignment operator,
and a constexpr <del>explicit</del> value constructor.
</blockquote>






<hr>
<h3><a name="846"></a>846. No definition for constructor</h3>
<p><b>Section:</b> X [atomics.types] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2008-06-03 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#atomics.types">issues</a> in [atomics.types].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The atomic classes and class templates (29.5.1 [atomics.types.integral] /
29.5.2 [atomics.types.address]) have a constexpr
constructor taking a value of the appropriate type for that atomic.
However, neither clause provides semantics or a definition for this
constructor.  I'm not sure if the initialization is implied by use of
constexpr keyword (which restricts the form of a constructor) but even if
that is the case, I think it is worth spelling out explicitly as the
inference would be far too subtle in that case.
</p>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
<p>
Lawrence will provide wording.
</p>
<p>
This issue is addressed in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2783.html">N2783</a>.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>

<p>
before the description of ...<code>is_lock_free</code>,
that is before 29.6 [atomics.types.operations] paragraph 4,
add the following description.
</p>

<blockquote>
<pre><code>
constexpr <var>A</var>::<var>A</var>(<var>C</var> desired);
</code></pre>
<dl>
<dt><i>Effects:</i></dt>
<dd>
Initializes the object with the value <code>desired</code>.
[<i>Note:</i>
Construction is not atomic.
<i>end note</i>]
</dd>
</dl>
</blockquote>





<hr>
<h3><a name="847"></a>847. string exception safety guarantees</h3>
<p><b>Section:</b> 21.4.1 [string.require] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Herv Brnnimann <b>Opened:</b> 2008-06-05 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#string.require">issues</a> in [string.require].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In March, on comp.lang.c++.moderated, I asked what were the
string exception safety guarantees are, because I cannot see
*any* in the working paper, and any implementation I know offers
the strong exception safety guarantee (string unchanged if a
member throws exception). The closest the current draft comes to
offering any guarantees is 21.4 [basic.string], para 3:
</p>

<blockquote>
The class template <tt>basic_string</tt> conforms to the requirements
for a Sequence Container (23.1.1), for a Reversible Container (23.1),
and for an Allocator-aware container (91). The iterators supported by
<tt>basic_string</tt> are random access iterators (24.1.5).
</blockquote>

<p>
However, the chapter 23 only says, on the topic of exceptions:  23.2 [container.requirements],
para 10:
</p>

<blockquote>
<p>
Unless otherwise specified (see 23.2.2.3 and 23.2.6.4) all container types defined in this clause meet the following 
additional requirements:
</p>

<ul>
<li>if an exception is thrown by...</li>
</ul>
</blockquote>

<p>
I take it  as saying that this paragraph has *no* implication on
<tt>std::basic_string</tt>, as <tt>basic_string</tt> isn't defined in Clause 23 and
this paragraph does not define a *requirement* of Sequence
nor Reversible Container, just of the models defined in Clause 23.
In addition, LWG Issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#718">718</a> proposes to remove 23.2 [container.requirements], para 3.
</p>

<p>
Finally, the fact that no operation on Traits should throw
exceptions has no bearing, except to suggest (since the only
other throws should be allocation, <tt>out_of_range</tt>, or <tt>length_error</tt>)
that the strong exception guarantee can be achieved.
</p>

<p>
The reaction in that group by Niels Dekker, Martin Sebor, and
Bo Persson, was all that this would be worth an LWG issue.
</p>

<p>
A related issue is that <tt>erase()</tt> does not throw.  This should be
stated somewhere (and again, I don't think that the 23.2 [container.requirements], para 1
applies here).
</p>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
Implementors will study this to confirm that it is actually possible.
</blockquote>

<p><i>[
Daniel adds 2009-02-14:
]</i></p>


<blockquote>
The proposed resolution of paper
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2815.html">N2815</a>
interacts with this issue (the paper does not refer to this issue).
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
Move to Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add a blanket statement in 21.4.1 [string.require]:
</p>

<blockquote>
<p>
- if any member function or operator of <tt>basic_string&lt;charT, traits, Allocator&gt;</tt>
throws, that function or operator has no effect.
</p>
<p>
- no <tt>erase()</tt> or <tt>pop_back()</tt> function throws.
</p>
</blockquote>

<p>
As far as I can tell, this is achieved by any implementation.  If I made a
mistake and it is not possible to offer this guarantee, then
either state all the functions for which this is possible
(certainly at least <tt>operator+=</tt>, <tt>append</tt>, <tt>assign</tt>, and <tt>insert</tt>),
or add paragraphs to Effects clauses wherever appropriate.
</p>





<hr>
<h3><a name="848"></a>848. missing <tt>std::hash</tt> specializations for <tt>std::bitset/std::vector&lt;bool&gt;</tt></h3>
<p><b>Section:</b> 20.8.15 [unord.hash] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Thorsten Ottosen <b>Opened:</b> 2008-06-05 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#unord.hash">issues</a> in [unord.hash].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In the current working draft, <tt>std::hash&lt;T&gt;</tt> is specialized for builtin
types and a few other types. Bitsets seems like one that is missing from
the list, not because it cannot not be done by the user, but because it
is hard or impossible to write an efficient implementation that works on
32bit/64bit chunks at a time. For example, <tt>std::bitset</tt> is too much
encapsulated in this respect.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add the following to the synopsis in 20.8 [function.objects]/2:
</p>

<blockquote><pre>template&lt;class Allocator&gt; struct hash&lt;std::vector&lt;bool,Allocator&gt;&gt;;
template&lt;size_t N&gt; struct hash&lt;std::bitset&lt;N&gt;&gt;;
</pre></blockquote>

<p>
Modify the last sentence of 20.8.15 [unord.hash]/1 to end with:
</p>

<blockquote>
... and <tt>std::string</tt>, <tt>std::u16string</tt>, <tt>std::u32string</tt>, <tt>std::wstring</tt>,
<tt>std::error_code</tt>, <tt>std::thread::id</tt>, <tt>std::bitset</tt>, <tt>and std::vector&lt;bool&gt;</tt>.
</blockquote>






<hr>
<h3><a name="850"></a>850. Should <tt>shrink_to_fit</tt> apply to <tt>std::deque</tt>?</h3>
<p><b>Section:</b> 23.3.2.2 [deque.capacity] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Niels Dekker <b>Opened:</b> 2008-06-05 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#deque.capacity">issues</a> in [deque.capacity].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#755">755</a> added a <tt>shrink_to_fit</tt> function to <tt>std::vector</tt> and <tt>std::string</tt>.
It did not yet deal with <tt>std::deque</tt>, because of the fundamental
difference between <tt>std::deque</tt> and the other two container types. The
need for <tt>std::deque</tt> may seem less evident, because one might think that
for this container, the overhead is a small map, and some number of
blocks that's bounded by a small constant.
</p>
<p>
The container overhead can in fact be arbitrarily large (i.e. is not
necessarily O(N) where N is the number of elements currently held by the
<tt>deque</tt>).  As Bill Plauger noted in a reflector message, unless the map of
block pointers is shrunk, it must hold at least maxN/B pointers where
maxN is the maximum of N over the lifetime of the <tt>deque</tt> since its
creation.  This is independent of how the map is implemented
(<tt>vector</tt>-like circular buffer and all), and maxN bears no relation to N,
the number of elements it currently holds.
</p>
<p>
Herv Brnnimann reports a situation where a <tt>deque</tt> of requests grew very
large due to some temporary backup (the front request hanging), and the
map of the <tt>deque</tt> grew quite large before getting back to normal.  Just
to put some color on it, assuming a <tt>deque</tt> with 1K pointer elements in
steady regime, that held, at some point in its lifetime, maxN=10M
pointers, with one block holding 128 elements, the spine must be at
least (maxN / 128), in that case 100K.   In that case, shrink-to-fit
would allow to reuse about 100K which would otherwise never be reclaimed
in the lifetime of the <tt>deque</tt>.
</p>
<p>
An added bonus would be that it *allows* implementations to hang on to
empty blocks at the end (but does not care if they do or not).  A
<tt>shrink_to_fit</tt> would take care of both shrinks, and guarantee that at
most O(B) space is used in addition to the storage to hold the N
elements and the N/B block pointers.
</p>


<p><b>Proposed resolution:</b></p>
<p>
To Class template deque 23.3.2 [deque] synopsis, add:
</p>
<blockquote><pre>void shrink_to_fit();
</pre></blockquote>

<p>
To deque capacity 23.3.2.2 [deque.capacity], add:
</p>
<blockquote><pre>void shrink_to_fit();
</pre>

<blockquote>
<i>Remarks:</i> <tt>shrink_to_fit</tt> is a non-binding request to reduce memory
use. [<i>Note:</i> The request is non-binding to allow latitude for
implementation-specific optimizations. -- <i>end note</i>]
</blockquote>
</blockquote>





<hr>
<h3><a name="852"></a>852. unordered containers <tt>begin(n)</tt> mistakenly <tt>const</tt></h3>
<p><b>Section:</b> 23.7 [unord] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Robert Klarer <b>Opened:</b> 2008-06-12 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#unord">issues</a> in [unord].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 3 of the four unordered containers the local <tt>begin</tt> member is mistakenly declared <tt>const</tt>:
</p>

<blockquote><pre>local_iterator begin(size_type n) const;
</pre></blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change the synopsis in 23.7.1 [unord.map], 23.7.2 [unord.multimap], and 23.7.4 [unord.multiset]:
</p>

<blockquote><pre>local_iterator begin(size_type n)<del> const</del>;
</pre></blockquote>





<hr>
<h3><a name="853"></a>853. <tt>to_string</tt> needs updating with <tt>zero</tt> and <tt>one</tt></h3>
<p><b>Section:</b> 20.5 [template.bitset] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2008-06-18 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#template.bitset">issues</a> in [template.bitset].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#396">396</a> adds defaulted arguments to the <tt>to_string</tt> member, but neglects to update
the three newer <tt>to_string</tt> overloads.
</p>

<p><i>[
post San Francisco:
]</i></p>


<blockquote>
Daniel found problems with the wording and provided fixes.  Moved from Ready
to Review.
</blockquote>

<p><i>[
Post Summit:
]</i></p>


<blockquote>
<p>
Alisdair: suggest to not repeat the default arguments in B, C, D
(definition of to_string members)
</p>
<p>
Walter: This is not really a definition.
</p>
<p>
Consensus: Add note to the editor: Please apply editor's judgement
whether default arguments should be repeated for B, C, D changes.
</p>
<p>
Recommend Tentatively Ready.
</p>
</blockquote>

<p><i>[
2009-05-09:  See alternative solution in issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1113">1113</a>.
]</i></p>




<p><b>Proposed resolution:</b></p>
<ol type="A">
<li>
<p>replace in 20.5 [template.bitset]/1 (class <tt>bitset</tt>)
</p>
<blockquote><pre>template &lt;class charT, class traits&gt;
  basic_string&lt;charT, traits, allocator&lt;charT&gt; &gt;
  to_string(<ins>charT zero = charT('0'), charT one = charT('1')</ins>) const;
template &lt;class charT&gt;
  basic_string&lt;charT, char_traits&lt;charT&gt;, allocator&lt;charT&gt; &gt;
  to_string(<ins>charT zero = charT('0'), charT one = charT('1')</ins>) const;
basic_string&lt;char, char_traits&lt;char&gt;, allocator&lt;char&gt; &gt;
  to_string(<ins>char zero = '0', char one = '1'</ins>) const;
</pre></blockquote>
</li>
<li>
<p>
replace in 20.5.2 [bitset.members]/37
</p>
<blockquote><pre>template &lt;class charT, class traits&gt;
  basic_string&lt;charT, traits, allocator&lt;charT&gt; &gt;
  to_string(<ins>charT zero = charT('0'), charT one = charT('1')</ins>) const;
</pre>
<blockquote>
37 <i>Returns:</i> <tt>to_string&lt;charT, traits, allocator&lt;charT&gt; &gt;(<ins>zero, one</ins>)</tt>.
</blockquote>
</blockquote>
</li>
<li>
<p>
replace in 20.5.2 [bitset.members]/38
</p>

<blockquote><pre>template &lt;class charT&gt;
  basic_string&lt;charT, char_traits&lt;charT&gt;, allocator&lt;charT&gt; &gt;
  to_string(<ins>charT zero = charT('0'), charT one = charT('1')</ins>) const;
</pre>
<blockquote>
38 <i>Returns:</i> <tt>to_string&lt;charT, char_traits&lt;charT&gt;, allocator&lt;charT&gt; &gt;(<ins>zero, one</ins>)</tt>.
</blockquote>
</blockquote>
</li>

<li>
<p>
replace in 20.5.2 [bitset.members]/39
</p>

<blockquote><pre>basic_string&lt;char, char_traits&lt;char&gt;, allocator&lt;char&gt; &gt;
  to_string(<ins>char zero = '0', char one = '1'</ins>) const;
</pre>
<blockquote>
39 <i>Returns:</i> <tt>to_string&lt;char, char_traits&lt;char&gt;, allocator&lt;char&gt; &gt;(<ins>zero, one</ins>)</tt>.
</blockquote>
</blockquote>
</li>

</ol>






<hr>
<h3><a name="854"></a>854. <tt>default_delete</tt> converting constructor underspecified</h3>
<p><b>Section:</b> 20.9.9.1.2 [unique.ptr.dltr.dflt] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2008-06-18 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#unique.ptr.dltr.dflt">issues</a> in [unique.ptr.dltr.dflt].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
No relationship between <tt>U</tt> and <tt>T</tt> in the converting constructor for <tt>default_delete</tt> template.
</p>
<p>
Requirements: <tt>U*</tt> is convertible to <tt>T*</tt> and <tt>has_virtual_destructor&lt;T&gt;</tt>;
the latter should also become a concept.
</p>
<p>
Rules out cross-casting.
</p>
<p>
The requirements for <tt>unique_ptr</tt> conversions should be the same as those on the deleter.
</p>

<p><i>[
Howard adds 2008-11-26:
]</i></p>


<blockquote>
<p>
I believe we need to be careful to not outlaw the following use case, and
I believe the current proposed wording
(<tt>requires Convertible&lt;U*, T*&gt; &amp;&amp; HasVirtualDestructor&lt;T&gt;</tt>) does so:
</p>

<blockquote><pre>#include &lt;memory&gt;

int main()
{
    std::unique_ptr&lt;int&gt; p1(new int(1));
    std::unique_ptr&lt;const int&gt; p2(move(p1));
    int i = *p2;
<font color="#C80000">//    *p2 = i;  // should not compile</font>
}
</pre></blockquote>

<p>
I've removed "<tt>&amp;&amp; HasVirtualDestructor&lt;T&gt;</tt>" from the
<tt>requires</tt> clause in the proposed wording.
</p>

</blockquote>

<p><i>[
Post Summit:
]</i></p>


<blockquote>
<p>
Alisdair: This issue has to stay in review pending a paper constraining
<tt>unique_ptr</tt>.
</p>
<p>
Consensus: We agree with the resolution, but <tt>unique_ptr</tt> needs
to be constrained, too.
</p>
<p>
Recommend Keep in Review.
</p>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Keep in Review status for the reasons cited.
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
<p>
The proposed resolution uses concepts. Howard needs to rewrite the
proposed resolution.
</p>
<p>
Move back to Open.
</p>
</blockquote>

<p><i>[
2009-07-26 Howard provided rewritten proposed wording and moved to Review.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Move to Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add after 20.9.9.1.2 [unique.ptr.dltr.dflt], p1:
</p>

<blockquote><pre>template &lt;class U&gt; default_delete(const default_delete&lt;U&gt;&amp; other);
</pre>
<blockquote>
<p>
-1- <i>Effects:</i> ...
</p>
<p><ins>
<i>Remarks:</i> This constructor shall participate in overload resolution
if and only if <tt>U*</tt> is implicitly convertible to <tt>T*</tt>.
</ins></p>
</blockquote>
</blockquote>






<hr>
<h3><a name="856"></a>856. Removal of <tt>aligned_union</tt></h3>
<p><b>Section:</b> 20.7.7.6 [meta.trans.other] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Jens Maurer <b>Opened:</b> 2008-06-12 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#meta.trans.other">issues</a> in [meta.trans.other].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
With the arrival of extended unions 
(<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2544.pdf">N2544</a>),
there is no
known use of <tt>aligned_union</tt> that couldn't be handled by
the "extended unions" core-language facility.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Remove the following signature from 20.7.2 [meta.type.synop]:
</p>
<blockquote><pre>template &lt;std::size_t Len, class... Types&gt; struct aligned_union;
</pre></blockquote>

<p>
Remove the second row from table 51 in 20.7.7.6 [meta.trans.other],
starting with:
</p>

<blockquote><pre>template &lt;std::size_t Len,
class... Types&gt;
struct aligned_union;
</pre></blockquote>





<hr>
<h3><a name="857"></a>857. <tt>condition_variable::time_wait</tt> return <tt>bool</tt> error prone</h3>
<p><b>Section:</b> 30.5.1 [thread.condition.condvar] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Beman Dawes <b>Opened:</b> 2008-06-13 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.condition.condvar">issues</a> in [thread.condition.condvar].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The meaning of the <tt>bool</tt> returned by <tt>condition_variable::timed_wait</tt> is so
obscure that even the class' designer can't deduce it correctly. Several
people have independently stumbled on this issue.
</p>
<p>
It might be simpler to change the return type to a scoped enum:
</p>
<blockquote><pre>enum class timeout { not_reached, reached };
</pre></blockquote>

<p>
That's the same cost as returning a <tt>bool</tt>, but not subject to mistakes. Your example below would be:
</p>

<blockquote><pre>if (cv.wait_until(lk, time_limit) == timeout::reached )
  throw time_out();
</pre></blockquote>

<p><i>[
Beman to supply exact wording.
]</i></p>


<p><i>[
San Francisco:
]</i></p>


<blockquote>
<p>
There is concern that the enumeration names are just as confusing, if
not more so, as the bool. You might have awoken because of a signal or a
spurious wakeup, for example.
</p>
<p>
Group feels that this is a defect that needs fixing.
</p>
<p>
Group prefers returning an enum over a void return.
</p>
<p>
Howard to provide wording.
</p>
</blockquote>

<p><i>[
2009-06-14 Beman provided wording.
]</i></p>


<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
Move to Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change Condition variables 30.5 [thread.condition], Header
condition_variable synopsis, as indicated:
</p>

<blockquote><pre>namespace std {
  class condition_variable;
  class condition_variable_any;

  <ins>enum class cv_status { no_timeout, timeout };</ins>
}
</pre></blockquote>

<p>
Change Class condition_variable 30.5.1 [thread.condition.condvar] as indicated:
</p>

<blockquote><pre>class condition_variable { 
public:
  ...
  template &lt;class Clock, class Duration&gt;
    <del>bool</del> <ins>cv_status</ins> wait_until(unique_lock&lt;mutex&gt;&amp; lock,
                    const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time);
  template &lt;class Clock, class Duration, class Predicate&gt;
    bool wait_until(unique_lock&lt;mutex&gt;&amp; lock,
                    const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time,
                    Predicate pred);

  template &lt;class Rep, class Period&gt;
    <del>bool</del> <ins>cv_status</ins> wait_for(unique_lock&lt;mutex&gt;&amp; lock,
                  const chrono::duration&lt;Rep, Period&gt;&amp; rel_time);
  template &lt;class Rep, class Period, class Predicate&gt;
    bool wait_for(unique_lock&lt;mutex&gt;&amp; lock,
                  const chrono::duration&lt;Rep, Period&gt;&amp; rel_time,
                  Predicate pred);
  ...
};

...

template &lt;class Clock, class Duration&gt;
  <del>bool</del> <ins>cv_status</ins> wait_until(unique_lock&lt;mutex&gt;&amp; lock,
                  const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time);
</pre>
<blockquote>
<p>
-15- <i>Precondition:</i> <tt>lock</tt> is locked by the calling thread, and either
</p>
<ul>
<li>
no other thread is waiting on this <tt>condition_variable</tt> object or
</li>
<li>
<tt>lock.mutex()</tt> returns the same value for each of the <tt>lock</tt>
arguments supplied by all concurrently waiting threads (via <tt>wait</tt>,
<tt>wait_for</tt> or <tt>wait_until</tt>.).
</li>
</ul>

<p>
-16- <i>Effects:</i>
</p>

<ul>
<li>
Atomically calls <tt>lock.unlock()</tt> and blocks on <tt>*this</tt>.
</li>
<li>
When unblocked, calls <tt>lock.lock()</tt> (possibly blocking on the lock) and returns.
</li>
<li>
The function will unblock when signaled by a call to <tt>notify_one()</tt>,
a call to <tt>notify_all()</tt>, <del>by 
the current time exceeding <tt>abs_time</tt></del> <ins>if <tt>Clock::now() &gt;= abs_time</tt></ins>,
or spuriously.
</li>
<li>
If the function exits via an exception, <tt>lock.unlock()</tt> shall be called prior
to exiting the function scope.
</li>
</ul>

<p>
-17- <i>Postcondition:</i> <tt>lock</tt> is locked by the calling thread.
</p>

<p>
-18- <i>Returns:</i> <del><tt>Clock::now() &lt; abs_time</tt></del>
<ins><tt>cv_status::timeout</tt> if the function unblocked because <tt>abs_time</tt>
was reached, otherwise <tt>cv_status::no_timeout</tt></ins>.
</p>

<p>
-19- <i>Throws:</i> <tt>std::system_error</tt> when the effects or postcondition
cannot be achieved.
</p>

<p>
-20- <i>Error conditions:</i>
</p>

<ul>
<li>
<tt>operation_not_permitted</tt>  if the thread does not own the lock.
</li>
<li>
equivalent error condition from <tt>lock.lock()</tt> or <tt>lock.unlock()</tt>.
</li>
</ul>
</blockquote>

<pre>template &lt;class Rep, class Period&gt;
  <del>bool</del> <ins>cv_status</ins> wait_for(unique_lock&lt;mutex&gt;&amp; lock,
                const chrono::duration&lt;Rep, Period&gt;&amp; rel_time);

</pre>
<blockquote>
<p>
-21- <i><del>Effects</del> <ins>Returns</ins>:</i>
</p>
<blockquote><pre>wait_until(lock, chrono::monotonic_clock::now() + rel_time)
</pre></blockquote>
<p>
<del>-22- <i>Returns:</i> <tt>false</tt> if the call is returning because the time
duration specified by <tt>rel_time</tt> has elapsed, 
otherwise <tt>true</tt>.</del>
</p>

<p><i>[
This part of the wording may conflict with <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#859">859</a> in detail, but does
not do so in spirit.  If both issues are accepted, there is a logical merge.
]</i></p>

</blockquote>

<pre>template &lt;class Clock, class Duration, class Predicate&gt; 
  bool wait_until(unique_lock&lt;mutex&gt;&amp; lock, 
                  const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time, 
                  Predicate pred);
</pre>

<blockquote>
<p>
-23- <i>Effects:</i>
</p>
<blockquote><pre>while (!pred()) 
  if (<del>!</del>wait_until(lock, abs_time) <ins>== cv_status::timeout</ins>) 
    return pred(); 
return true;
</pre></blockquote>

<p>
-24- <i>Returns:</i> <tt>pred()</tt>.
</p>

<p>
-25- [<i>Note:</i>
The returned value indicates whether the predicate evaluates to
<tt>true</tt> regardless of whether the timeout was triggered.
 <i>end note</i>].
</p>
</blockquote>
</blockquote>

<p>
Change Class condition_variable_any 30.5.2 [thread.condition.condvarany] as indicated:
</p>

<blockquote><pre>class condition_variable_any {
public:
  ...
  template &lt;class Lock, class Clock, class Duration&gt;
    <del>bool</del> <ins>cv_status</ins> wait_until(Lock&amp; lock,
                    const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time);
  template &lt;class Lock, class Clock, class Duration, class Predicate&gt;
    bool wait_until(Lock&amp; lock,
                    const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time,
                    Predicate pred);

  template &lt;class Lock, class Rep, class Period&gt;
    <del>bool</del> <ins>cv_status</ins> wait_for(Lock&amp; lock,
                  const chrono::duration&lt;Rep, Period&gt;&amp; rel_time);
  template &lt;class Lock, class Rep, class Period, class Predicate&gt;
    bool wait_for(Lock&amp; lock,
                  const chrono::duration&lt;Rep, Period&gt;&amp; rel_time,
                  Predicate pred);
  ...
};

...

template &lt;class Lock, class Clock, class Duration&gt;
  <del>bool</del> <ins>cv_status</ins> wait_until(Lock&amp; lock,
                  const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time);
</pre>

<blockquote>

<p>
-13- <i>Effects:</i>
</p>

<ul>
<li>
Atomically calls <tt>lock.unlock()</tt> and blocks on <tt>*this</tt>.
</li>
<li>
When unblocked, calls <tt>lock.lock()</tt> (possibly blocking on the lock) and returns.
</li>
<li>
The function will unblock when signaled by a call to <tt>notify_one()</tt>,
a call to <tt>notify_all()</tt>, <del>by 
the current time exceeding <tt>abs_time</tt></del> <ins>if <tt>Clock::now() &gt;= abs_time</tt></ins>,
or spuriously.
</li>
<li>
If the function exits via an exception, <tt>lock.unlock()</tt> shall be called prior
to exiting the function scope.
</li>
</ul>

<p>
-14- <i>Postcondition:</i> <tt>lock</tt> is locked by the calling thread.
</p>

<p>
-15- <i>Returns:</i> <del><tt>Clock::now() &lt; abs_time</tt></del>
<ins><tt>cv_status::timeout</tt> if the function unblocked because <tt>abs_time</tt>
was reached, otherwise <tt>cv_status::no_timeout</tt></ins>.
</p>

<p>
-16- <i>Throws:</i> <tt>std::system_error</tt> when the effects or postcondition
cannot be achieved.
</p>

<p>
-17- <i>Error conditions:</i>
</p>

<ul>
<li>
equivalent error condition from <tt>lock.lock()</tt> or <tt>lock.unlock()</tt>.
</li>
</ul>
</blockquote>

<pre>template &lt;class Lock, class Rep, class Period&gt;
  <del>bool</del> <ins>cv_status</ins> wait_for(Lock&amp; lock,
                const chrono::duration&lt;Rep, Period&gt;&amp; rel_time);

</pre>

<blockquote>
<p>
-18- <i><del>Effects</del> <ins>Returns</ins>:</i>
</p>
<blockquote><pre>wait_until(lock, chrono::monotonic_clock::now() + rel_time)
</pre></blockquote>

<p>
<del>-19- <i>Returns:</i> <tt>false</tt> if the call is returning because the time
duration specified by <tt>rel_time</tt> has elapsed, 
otherwise <tt>true</tt>.</del>
</p>

<p><i>[
This part of the wording may conflict with <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#859">859</a> in detail, but does
not do so in spirit.  If both issues are accepted, there is a logical merge.
]</i></p>


</blockquote>

<pre>template &lt;class Lock, class Clock, class Duration, class Predicate&gt; 
  bool wait_until(Lock&amp; lock, 
                  const chrono::time_point&lt;Clock, Duration&gt;&amp; <del>rel_time</del> <ins>abs_time</ins>, 
                  Predicate pred);
</pre>

<blockquote>
<p>
-20- <i>Effects:</i>
</p>
<blockquote><pre>while (!pred()) 
  if (<del>!</del>wait_until(lock, abs_time) <ins>== cv_status::timeout</ins>) 
    return pred(); 
return true;
</pre></blockquote>

<p>
-21- <i>Returns:</i> <tt>pred()</tt>.
</p>

<p>
-22- [<i>Note:</i>
The returned value indicates whether the predicate evaluates to
<tt>true</tt> regardless of whether the timeout was triggered.
 <i>end note</i>].
</p>
</blockquote>

</blockquote>






<hr>
<h3><a name="858"></a>858. Wording for Minimal Support for Garbage Collection</h3>
<p><b>Section:</b> 20.9.11 [util.dynamic.safety] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Pete Becker  <b>Opened:</b> 2008-06-21 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#util.dynamic.safety">issues</a> in [util.dynamic.safety].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The first sentence of the Effects clause for <tt>undeclare_reachable</tt> seems
to be missing some words. I can't parse
</p>
<blockquote>
... for all non-null <tt>p</tt> referencing the argument is no longer declared reachable...
</blockquote>
<p>
I take it the intent is that <tt>undeclare_reachable</tt> should be called only
when there has been a corresponding call to <tt>declare_reachable</tt>. In
particular, although the wording seems to allow it, I assume that code
shouldn't call <tt>declare_reachable</tt> once then call <tt>undeclare_reachable</tt>
twice.
</p>
<p>
I don't know what "shall be live" in the Requires clause means.
</p>
<p>
In the final Note for <tt>undeclare_reachable</tt>, what does "cannot be
deallocated" mean? Is this different from "will not be able to collect"?
</p>

<p>
For the wording on nesting of <tt>declare_reachable</tt> and
<tt>undeclare_reachable</tt>, the words for locking and unlocking recursive
mutexes probably are a good model.
</p>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
<p>
Nick: what does "shall be live" mean?
</p>
<p>
Hans: I can provide an appropriate cross-reference to the Project Editor
to clarify the intent.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
In 20.9.11 [util.dynamic.safety]
(<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2670.htm">N2670</a>,
Minimal Support for Garbage Collection)
</p>
<p>
Add at the beginning, before paragraph 39
</p>

<blockquote>
A complete object is <i>declared reachable</i> while the number of calls
to <tt>declare_reachable</tt> with an argument referencing the object exceeds the
number of <tt>undeclare_reachable</tt> calls with pointers to the same complete
object.
</blockquote>

<p>
Change paragraph 42 (Requires clause for <tt>undeclare_reachable</tt>)
</p>

<blockquote>
If <tt>p</tt> is not null, <del><tt>declare_reachable(p)</tt> was previously called</del>
<ins>the complete object referenced by <tt>p</tt> shall have
been previously declared reachable</ins>, and shall
be live <ins>(3.8 [basic.life])</ins> from the time of the call until the last <tt>undeclare_reachable(p)</tt>
call on the object.
</blockquote>

<p>
Change the first sentence in paragraph 44 (Effects clause for
<tt>undeclare_reachable</tt>):
</p>

<blockquote>
<i>Effects:</i> 
<del>Once the number of calls to
<tt>undeclare_reachable(p)</tt> equals the number of calls to
<tt>declare_reachable(p)</tt>
for all non-null <tt>p</tt> referencing
the argument is no longer declared reachable.  When this happens,
pointers to the object referenced by p may not be subsequently
dereferenced.</del>
<ins>
After a call to <tt>undeclare_reachable(p)</tt>, if <tt>p</tt> is not null and the object <tt>q</tt>
referenced by <tt>p</tt> is no longer declared reachable, then
dereferencing any pointer to <tt>q</tt> that is not safely derived
results in undefined behavior.
</ins> ...
</blockquote>

<p>
Change the final note:
</p>
<p>
[<i>Note:</i> It is expected that calls to <tt>declare_reachable(p)</tt>
will consume a small amount of memory<ins>, in addition to that occupied
by the referenced object, </ins> until the matching call to
<tt>undeclare_reachable(p)</tt> is encountered. <del>In addition, the
referenced object cannot be deallocated during this period, and garbage
collecting implementations will not be able to collect the object while
it is declared reachable.</del> Long running programs should arrange
that calls <ins>for short-lived objects</ins> are matched. <i>--end
note</i>]
</p>






<hr>
<h3><a name="859"></a>859. Monotonic Clock is Conditionally Supported?</h3>
<p><b>Section:</b> 30.5 [thread.condition] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2008-06-23 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.condition">issues</a> in [thread.condition].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>

<p>Related to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#958">958</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#959">959</a>.</p>

<p>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2661.html">N2661</a>
says that there is a class named <tt>monotonic_clock</tt>. It also says that this
name may be a synonym for <tt>system_clock</tt>, and that it's conditionally
supported. So the actual requirement is that it can be monotonic or not,
and you can tell by looking at <tt>is_monotonic</tt>, or it might not exist at
all (since it's conditionally supported). Okay, maybe too much
flexibility, but so be it.
</p>
<p>
A problem comes up in the threading specification, where several
variants of <tt>wait_for</tt> explicitly use <tt>monotonic_clock::now()</tt>. What is the
meaning of an effects clause that says
</p>

<blockquote><pre>wait_until(lock, chrono::monotonic_clock::now() + rel_time)
</pre></blockquote>

<p>
when <tt>monotonic_clock</tt> is not required to exist?
</p>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
<p>
Nick: maybe instead of saying that chrono::monotonic_clock is
conditionally supported, we could say that it's always there, but not
necessarily supported..
</p>
<p>
Beman: I'd prefer a typedef that identifies the best clock to use for
wait_for locks.
</p>
<p>
Tom: combine the two concepts; create a duration clock type, but keep
the is_monotonic test.
</p>
<p>
Howard: if we create a duration_clock type, is it a typedef or an
entirely true type?
</p>
<p>
There was broad preference for a typedef.
</p>
<p>
Move to Open. Howard to provide wording to add a typedef for
duration_clock and to replace all uses of monotonic_clock in function
calls and signatures with duration_clock.
</p>
</blockquote>

<p><i>[
Howard notes post-San Francisco:
]</i></p>


<blockquote>
<p>
After further thought I do not believe that creating a <tt>duration_clock typedef</tt>
is the best way to proceed.  An implementation may not need to use a
<tt>time_point</tt> to implement the <tt>wait_for</tt> functions.
</p>

<p>
For example, on POSIX systems <tt>sleep_for</tt> can be implemented in terms of
<tt>nanosleep</tt> which takes only a duration in terms of nanoseconds.  The current
working paper does not describe <tt>sleep_for</tt> in terms of <tt>sleep_until</tt>.
And paragraph 2 of 30.2.4 [thread.req.timing] has the words strongly encouraging
implementations to use monotonic clocks for <tt>sleep_for</tt>:
</p>

<blockquote>
2 The member functions whose names end in <tt>_for</tt> take an argument that
specifies a relative time. Implementations should use a monotonic clock to
measure time for these functions.
</blockquote>

<p>
I believe the approach taken in describing the effects of <tt>sleep_for</tt>
and <tt>try_lock_for</tt> is also appropriate for <tt>wait_for</tt>.  I.e. these
are not described in terms of their <tt>_until</tt> variants.
</p>

</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
<p>
Beman will send some suggested wording changes to Howard.
</p>
<p>
Move to Ready.
</p>
</blockquote>

<p><i>[
2009-07-21 Beman added the requested wording changes to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#962">962</a>.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
Change 30.5.1 [thread.condition.condvar], p21-22:
</p>

<blockquote>
<pre>template &lt;class Rep, class Period&gt; 
  bool wait_for(unique_lock&lt;mutex&gt;&amp; lock, 
                const chrono::duration&lt;Rep, Period&gt;&amp; rel_time);
</pre>
<blockquote>
<p><ins>
<i>Precondition:</i> <tt>lock</tt> is locked by the calling thread, and either
</ins></p>
<ul>
<li><ins>no other thread is waiting on this <tt>condition_variable</tt> object or</ins></li>
<li><ins><tt>lock.mutex()</tt> returns the same value for each of the <tt>lock</tt>
arguments supplied by all concurrently waiting threads (via <tt>wait</tt>,
<tt>wait_for</tt> or <tt>wait_until</tt>).</ins></li>
</ul>
<p>
21 <i>Effects:</i>
</p>
<blockquote><pre><del>wait_until(lock, chrono::monotonic_clock::now() + rel_time)</del>
</pre></blockquote>
<ul>
<li><ins>
Atomically calls <tt>lock.unlock()</tt> and blocks on <tt>*this</tt>.
</ins></li>

<li><ins>
When unblocked, calls <tt>lock.lock()</tt> (possibly blocking on the lock) and returns.
</ins></li>

<li><ins>
The function will unblock when signaled by a call to <tt>notify_one()</tt>, a call
to <tt>notify_all()</tt>, by 
the elapsed time <tt>rel_time</tt> passing (30.2.4 [thread.req.timing]),
or spuriously.
</ins></li>

<li><ins>
If the function exits via an exception, <tt>lock.unlock()</tt> shall be called 
prior to exiting the function scope.
</ins></li>
</ul>

<p><ins>
<i>Postcondition:</i> <tt>lock</tt> is locked by the calling thread.
</ins></p>


<p>
22 <i>Returns:</i> <tt>false</tt> if the call is returning because the time
duration specified by <tt>rel_time</tt> has elapsed, otherwise <tt>true</tt>.
</p>

<p><i>[
This part of the wording may conflict with <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#857">857</a> in detail, but does
not do so in spirit.  If both issues are accepted, there is a logical merge.
]</i></p>


<p><ins>
<i>Throws:</i> <tt>std::system_error</tt> when the effects or postcondition cannot be achieved.
</ins></p>

<p><ins>
<i>Error conditions:</i>
</ins></p>

<ul>
<li><ins>
<tt>operation_not_permitted</tt> -- if the thread does not own the lock.
</ins></li>
<li><ins>
equivalent error condition from <tt>lock.lock()</tt> or <tt>lock.unlock()</tt>.
</ins></li>
</ul>

</blockquote>
</blockquote>

<p>
Change 30.5.1 [thread.condition.condvar], p26-p29:
</p>

<blockquote>
<pre>template &lt;class Rep, class Period, class Predicate&gt; 
  bool wait_for(unique_lock&lt;mutex&gt;&amp; lock, 
                const chrono::duration&lt;Rep, Period&gt;&amp; rel_time, 
                Predicate pred);
</pre>
<blockquote>
<p><ins>
<i>Precondition:</i> <tt>lock</tt> is locked by the calling thread, and either
</ins></p>
<ul>
<li><ins>no other thread is waiting on this <tt>condition_variable</tt> object or</ins></li>
<li><ins><tt>lock.mutex()</tt> returns the same value for each of the <tt>lock</tt>
arguments supplied by all concurrently waiting threads (via <tt>wait</tt>,
<tt>wait_for</tt> or <tt>wait_until</tt>).</ins></li>
</ul>
<p>
<i>26 Effects:</i>
</p>
<blockquote><pre><del>wait_until(lock, chrono::monotonic_clock::now() + rel_time, std::move(pred))</del>
</pre>
<ul>
<li><ins>
Executes a loop:  Within the loop the function first evaluates <tt>pred()</tt>
and exits the loop if the result of <tt>pred()</tt> is <tt>true</tt>.
</ins></li>
<li><ins>
Atomically calls <tt>lock.unlock()</tt>
and blocks on <tt>*this</tt>.
</ins></li>
<li><ins>
When unblocked, calls <tt>lock.lock()</tt> (possibly blocking on the lock).
</ins></li>
<li><ins>
The function will unblock when signaled by a call to <tt>notify_one()</tt>, a
call to <tt>notify_all()</tt>, by the elapsed time <tt>rel_time</tt> passing (30.1.4
[thread.req.timing]), or spuriously.
</ins></li>
<li><ins>
If the function exits via an exception, <tt>lock.unlock()</tt> shall be called
prior to exiting the function scope.
</ins></li>
<li><ins>
The loop terminates when <tt>pred()</tt> returns <tt>true</tt> or when the time
duration specified by <tt>rel_time</tt> has elapsed.
</ins></li>
</ul>
</blockquote>

<p>
27 [<i>Note:</i> There is no blocking if <tt>pred()</tt> is initially <tt>true</tt>,
even if the timeout has already expired. <i>-- end note</i>]
</p>

<p><ins>
<i>Postcondition:</i> <tt>lock</tt> is locked by the calling thread.
</ins></p>

<p>
28 <i>Returns:</i> <tt>pred()</tt>
</p>

<p>
29 [<i>Note:</i> The returned value indicates whether the predicate evaluates to
<tt>true</tt> regardless of whether the timeout was triggered. <i>-- end note</i>]
</p>

<p><ins>
<i>Throws:</i> <tt>std::system_error</tt> when the effects or postcondition cannot be achieved.
</ins></p>

<p><ins>
<i>Error conditions:</i>
</ins></p>

<ul>
<li><ins>
<tt>operation_not_permitted</tt> -- if the thread does not own the lock.
</ins></li>
<li><ins>
equivalent error condition from <tt>lock.lock()</tt> or <tt>lock.unlock()</tt>.
</ins></li>
</ul>

</blockquote>
</blockquote>

<p>
Change 30.5.2 [thread.condition.condvarany], p18-19:
</p>

<blockquote>
<pre>template &lt;class Lock, class Rep, class Period&gt; 
  bool wait_for(Lock&amp; lock, const chrono::duration&lt;Rep, Period&gt;&amp; rel_time);
</pre>
<blockquote>
<p>
18 <i>Effects:</i>
</p>
<blockquote><pre><del>wait_until(lock, chrono::monotonic_clock::now() + rel_time)</del>
</pre></blockquote>

<ul>
<li><ins>
Atomically calls <tt>lock.unlock()</tt> and blocks on <tt>*this</tt>.
</ins></li>

<li><ins>
When unblocked, calls <tt>lock.lock()</tt> (possibly blocking on the lock) and returns.
</ins></li>

<li><ins>
The function will unblock when signaled by a call to <tt>notify_one()</tt>, a call to
<tt>notify_all()</tt>, by
the elapsed time <tt>rel_time</tt> passing (30.2.4 [thread.req.timing]),
or spuriously.
</ins></li>

<li><ins>
If the function exits via an exception, <tt>lock.unlock()</tt> shall be called
prior to exiting the function scope.
</ins></li>
</ul>

<p><ins>
<i>Postcondition:</i> <tt>lock</tt> is locked by the calling thread.
</ins></p>

<p>
19 <i>Returns:</i> <tt>false</tt> if the call is returning because the time duration
specified by <tt>rel_time</tt> has elapsed, otherwise <tt>true</tt>.
</p>

<p><ins>
<i>Throws:</i> <tt>std::system_error</tt> when the returned value, effects,
or postcondition cannot be achieved.
</ins></p>

<p><ins>
<i>Error conditions:</i>
</ins></p>

<ul>
<li><ins>
equivalent error condition from <tt>lock.lock()</tt> or <tt>lock.unlock()</tt>.
</ins></li>
</ul>
</blockquote>
</blockquote>

<p>
Change 30.5.2 [thread.condition.condvarany], p23-p26:
</p>

<blockquote>
<pre>template &lt;class Lock, class Rep, class Period, class Predicate&gt; 
  bool wait_for(Lock&amp; lock, const chrono::duration&lt;Rep, Period&gt;&amp; rel_time, Predicate pred);
</pre>
<blockquote>
<p><ins>
<i>Precondition:</i> <tt>lock</tt> is locked by the calling thread, and either
</ins></p>
<ul>
<li><ins>no other thread is waiting on this <tt>condition_variable</tt> object or</ins></li>
<li><ins><tt>lock.mutex()</tt> returns the same value for each of the <tt>lock</tt>
arguments supplied by all concurrently waiting threads (via <tt>wait</tt>,
<tt>wait_for</tt> or <tt>wait_until</tt>).</ins></li>
</ul>
<p>
<i>23 Effects:</i>
</p>
<blockquote><pre><del>wait_until(lock, chrono::monotonic_clock::now() + rel_time, std::move(pred))</del>
</pre>
<ul>
<li><ins>
Executes a loop:  Within the loop the function first evaluates <tt>pred()</tt>
and exits the loop if the result of <tt>pred()</tt> is <tt>true</tt>.
</ins></li>
<li><ins>
Atomically calls <tt>lock.unlock()</tt>
and blocks on <tt>*this</tt>.
</ins></li>
<li><ins>
When unblocked, calls <tt>lock.lock()</tt> (possibly blocking on the lock).
</ins></li>
<li><ins>
The function will unblock when signaled by a call to <tt>notify_one()</tt>, a
call to <tt>notify_all()</tt>, by the elapsed time <tt>rel_time</tt> passing (30.1.4
[thread.req.timing]), or spuriously.
</ins></li>
<li><ins>
If the function exits via an exception, <tt>lock.unlock()</tt> shall be called
prior to exiting the function scope.
</ins></li>
<li><ins>
The loop terminates when <tt>pred()</tt> returns <tt>true</tt> or when the time
duration specified by <tt>rel_time</tt> has elapsed.
</ins></li>
</ul>
</blockquote>

<p>
24 [<i>Note:</i> There is no blocking if <tt>pred()</tt> is initially <tt>true</tt>,
even if the timeout has already expired. <i>-- end note</i>]
</p>

<p><ins>
<i>Postcondition:</i> <tt>lock</tt> is locked by the calling thread.
</ins></p>

<p>
25 <i>Returns:</i> <tt>pred()</tt>
</p>

<p>
26 [<i>Note:</i> The returned value indicates whether the predicate evaluates to
<tt>true</tt> regardless of whether the timeout was triggered. <i>-- end note</i>]
</p>

<p><ins>
<i>Throws:</i> <tt>std::system_error</tt> when the effects or postcondition cannot be achieved.
</ins></p>

<p><ins>
<i>Error conditions:</i>
</ins></p>

<ul>
<li><ins>
<tt>operation_not_permitted</tt> -- if the thread does not own the lock.
</ins></li>
<li><ins>
equivalent error condition from <tt>lock.lock()</tt> or <tt>lock.unlock()</tt>.
</ins></li>
</ul>

</blockquote>
</blockquote>







<hr>
<h3><a name="860"></a>860. Floating-Point State</h3>
<p><b>Section:</b> 26 [numerics] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Lawrence Crowl <b>Opened:</b> 2008-06-23 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#numerics">issues</a> in [numerics].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There are a number of functions that affect the floating point state.
These function need to be thread-safe, but I'm unsure of the right
approach in the standard, as we inherit them from C.
</p>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
<p>
Nick: I think we already say that these functions do not introduce data
races; see 17.6.5.6/20
</p>
<p>
Pete: there's more to it than not introducing data races; are these
states maintained per thread?
</p>
<p>
Howard: 21.5/14 says that strtok and strerror are not required to avoid
data races, and 20.9/2 says the same about asctime, gmtime, ctime, and
gmtime.
</p>
<p>
Nick: POSIX has a list of not-safe functions. All other functions are
implicitly thread safe.
</p>
<p>
Lawrence is to form a group between meetings to attack this issue. Nick
and Tom volunteered to work with Lawrence.
</p>
<p>
Move to Open.
</p>
</blockquote>

<p><i>[
Post Summit:
]</i></p>


<blockquote>
<p>
Hans: Sane oses seem ok. Sensible thing is implementable and makes sense.
</p>
<p>
Nick: Default wording seems to cover this? Hole in POSIX, these
functions need to be added to list of thread-unsafe functions.
</p>
<p>
Lawrence: Not sufficient, not "thread-safe" per our definition, but
think of state as a thread-local variable. Need something like "these
functions only affect state in the current thread."
</p>
<p>
Hans: Suggest the following wording: "The floating point environment is
maintained per-thread."
</p>
<p>
Walter: Any other examples of state being thread safe that are not
already covered elsewhere?
</p>
<p>
Have thread unsafe functions paper which needs to be updated. Should
just fold in 26.3 [cfenv] functions.
</p>
<p>
Recommend Open. Lawrence instead suggests leaving it open until we have
suitable wording that may or may not include the thread local
commentary.
</p>
</blockquote>

<p><i>[
2009-09-23 Hans provided wording.
]</i></p>


<blockquote>
If I understand the history correctly, Nick, as the Posix liaison,
should probably get a veto on this, since I think it came from Posix (?)
via WG14 and should probably really be addressed there (?).  But I think
we are basically in agreement that there is no other sane way to do
this, and hence we don't have to worry too much about stepping on toes. 
As far as I can tell, this same issue also exists in the latest Posix
standard (?).
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Moved to Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add at the end of 26.3.1 [cfenv.syn]:
</p>

<blockquote>
<p>
2 The header defines all functions, types, and macros the same as C99 7.6.
</p>

<p><ins>
A separate floating point environment shall be maintained for each
thread.  Each function accesses the environment corresponding to its
calling thread.
</ins></p>
</blockquote>





<hr>
<h3><a name="861"></a>861. Incomplete specification of EqualityComparable for std::forward_list</h3>
<p><b>Section:</b> 23.2 [container.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2008-06-24 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#container.requirements">issues</a> in [container.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Table 89, Container requirements, defines <tt>operator==</tt> in terms of the container
member function <tt>size()</tt> and the algorithm <tt>std::equal</tt>:
</p>

<blockquote>
<tt>==</tt> is an equivalence relation. <tt>a.size() == b.size() &amp;&amp;
equal(a.begin(), a.end(), b.begin()</tt>
</blockquote>

<p>
The new container <tt>forward_list</tt> does not provide a <tt>size</tt> member function
by design but does provide <tt>operator==</tt> and <tt>operator!=</tt> without specifying it's semantic.
</p>
<p>
Other parts of the (sequence) container requirements do also depend on
<tt>size()</tt>, e.g. <tt>empty()</tt>
or <tt>clear()</tt>, but this issue explicitly attempts to solve the missing
<tt>EqualityComparable</tt> specification,
because of the special design choices of <tt>forward_list</tt>.
</p>
<p>
I propose to apply one of the following resolutions, which are described as:
</p>

<ol type="A">
<li>
Provide a definition, which is optimal for this special container without
previous size test. This choice prevents two <tt>O(N)</tt> calls of <tt>std::distance()</tt>
with the corresponding container ranges and instead uses a special
<tt>equals</tt> implementation which takes two container ranges instead of 1 1/2.
</li>
<li>
The simple fix where the usual test is adapted such that <tt>size()</tt> is replaced
by <tt>distance</tt> with corresponding performance disadvantages.
</li>
</ol>
<p>
Both proposal choices are discussed, the preferred choice of the author is
to apply (A).
</p>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
<p>
There's an Option C: change the requirements table to use distance().
</p>
<p>
LWG found Option C acceptable.
</p>
<p>
Martin will draft the wording for Option C.
</p>
</blockquote>

<p><i>[
post San Francisco:
]</i></p>


<blockquote>
Martin provided wording for Option C.
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
Other operational semantics (see, for example, Tables 82 and 83) are
written in terms of a container's size() member. Daniel to update
proposed resolution C.
</p>
<p><i>[
Howard: Commented out options A and B.
]</i></p>

</blockquote>

<p><i>[
2009-07-26 Daniel updated proposed resolution C.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Mark NAD Editorial. Addressed by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2986.pdf">N2986</a>.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Reopened.
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2986.pdf">N2986</a>
was rejected in full committee on procedural grounds.
</blockquote>

<p><i>[
2010-01-30 Howard updated Table numbers.
]</i></p>


<p><i>[
2010 Pittsburgh:
]</i></p>


<blockquote>
Moved to Ready for Pittsburgh.
</blockquote>



<p><b>Proposed resolution:</b></p>


<p>
Option (C):
</p>
<blockquote>

<ol>
<li>
<p>
In 23.2.1 [container.requirements.general] change Table 90 -- Container requirements as indicated:
</p>

<ol type="a">
<li>
<p>
Change the text in the Assertion/note column in the row for "<tt>X u</tt>;"
as follows:
</p>

<blockquote>
post: <tt>u.<del>size() == 0</del><ins>empty() == true</ins></tt>
</blockquote>
</li>

<li>
<p>
Change the text in the Assertion/note column in the row for "<tt>X();</tt>"
as follows:
</p>

<blockquote>
<tt>X().<del>size() == 0</del><ins>empty() == true</ins></tt>
</blockquote>
</li>

<li>
<p>
Change the text in the Operational Semantics column in the row for
"<tt>a == b</tt>" as follows:
</p>
<blockquote>
<tt>==</tt> is an equivalence relation.
<tt><del>a.size()</del><ins>distance(a.begin(), a.end())</ins> ==
   <del>b.size()</del><ins>distance(b.begin(), b.end())</ins> &amp;&amp;
equal(a.begin(), a.end(), b.begin())</tt>
</blockquote>
</li>

<li>
<p>
Add text in the Ass./Note/pre-/post-condition column in the row for
"<tt>a == b</tt>" as follows:
</p>
<blockquote><ins>
<i>Requires:</i> <tt>T</tt> is <tt>EqualityComparable</tt>
</ins></blockquote>
</li>

<li>
<p>
Change the text in the Operational Semantics column in the row for
"<tt>a.size()</tt>" as follows:
</p>

<blockquote>
<tt><del>a.end() - a.begin()</del><ins>distance(a.begin(), a.end())</ins></tt>
</blockquote>
</li>

<li>
<p>
Change the text in the Operational Semantics column in the row for
"<tt>a.max_size()</tt>" as follows:
</p>

<blockquote>
<tt><del>size()</del><ins>distance(begin(), end())</ins></tt> of the largest
possible container
</blockquote>
</li>

<li>
<p>
Change the text in the Operational Semantics column in the row for
"<tt>a.empty()</tt>" as follows:
</p>

<blockquote>
<tt><del>a.size() == 0</del><ins>a.begin() == a.end()</ins></tt>
</blockquote>
</li>
</ol>
</li>

<li>
<p>
In 23.2.1 [container.requirements.general] change Table 93 -- Allocator-aware container requirements as indicated:
</p>

<ol type="a">
<li>
<p>
Change the text in the Assertion/note column in the row for "<tt>X() /
X u;</tt>" as follows:
</p>

<blockquote>
<i>Requires:</i> <tt>A</tt> is <tt>DefaultConstructible</tt> post: <tt><del>u.size() ==
0</del><ins>u.empty() == true</ins></tt>, <tt>get_allocator() == A()</tt>
</blockquote>
</li>

<li>
<p>
Change the text in the Assertion/note column in the row for "<tt>X(m) /
X u(m);</tt>" as follows:
</p>

<blockquote>
post: <tt><del>u.size() == 0</del><ins>u.empty() == true</ins>,
get_allocator() == m</tt>
</blockquote>
</li>
</ol>
</li>

<li>
<p>
In 23.2.3 [sequence.reqmts] change Table 94 -- Sequence container requirements as indicated:
</p>

<ol type="a">
<li>
<p>
Change the text in the Assertion/note column in the row for "<tt>X(n,
t) / X a(n, t)</tt>" as follows:
</p>

<blockquote>
post: <tt><del>size()</del><ins>distance(begin(), end())</ins> == n [..]</tt>
</blockquote>
</li>

<li>
<p>
Change the text in the Assertion/note column in the row for "<tt>X(i,
j) / X a(i, j)</tt>" as follows:
</p>

<blockquote>
[..] post: <del><tt>size() ==</tt> distance between <tt>i</tt> and
<tt>j</tt></del><ins><tt>distance(begin(), end()) == distance(i, j)</tt></ins> [..]
</blockquote>
</li>

<li>
<p>
Change the text in the Assertion/note column in the row for
"<tt>a.clear()</tt>" as follows:
</p>
<blockquote>
<tt><ins>a.</ins>erase(<ins>a.</ins>begin(), <ins>a.</ins>end())</tt> post:
<tt><del>size() == 0</del><ins>a.empty() == true</ins></tt>
</blockquote>
</li>
</ol>
</li>

<li>
<p>
In 23.2.4 [associative.reqmts] change Table 96 -- Associative container requirements as indicated:
</p>

<p><i>[
Not every occurrence of <tt>size()</tt> was replaced, because all current
associative containers
have a <tt>size</tt>. The following changes ensure consistency regarding the
semantics of "<tt>erase</tt>"
for all tables and adds some missing objects
]</i></p>


<ol type="a">

<li>
<p>
Change the text in the Complexity column in the row for <tt>X(i,j,c)/X
a(i,j,c);</tt> as follows:
</p>

<blockquote>
<tt>N</tt> log <tt>N</tt> in general (<tt>N</tt> <ins><tt> == distance(i,
j)</tt></ins><del>is the distance from <tt>i</tt> to <tt>j</tt></del>); ...
</blockquote>

</li>

<li>
<p>
Change the text in the Complexity column in the row for
"<tt>a.insert(i, j)</tt>" as follows:
</p>
<blockquote>
<tt>N log(<ins>a.</ins>size() + N)</tt> <del>(<tt>N</tt> is the distance from <tt>i</tt> to
<tt>j</tt>)</del><ins> where <tt>N == distance(i, j)</tt></ins>
</blockquote>
</li>

<li>
<p>
Change the text in the Complexity column in the row for
"<tt>a.erase(k)</tt>" as follows:
</p>
<blockquote>
<tt>log(<ins>a.</ins>size()) + <ins>a.</ins>count(k)</tt>
</blockquote>
</li>

<li>
<p>
Change the text in the Complexity column in the row for
"<tt>a.erase(q1, q2)</tt>" as follows:
</p>

<blockquote>
<tt>log(<ins>a.</ins>size()) + N</tt> where <tt>N</tt> <del>is the distance from <tt>q1</tt>
to <tt>q2</tt></del>
   <ins><tt>== distance(q1, q2)</tt></ins>.
</blockquote>
</li>

<li>
<p>
Change the text in the Assertion/note column in the row for
"<tt>a.clear()</tt>" as follows:
</p>

<blockquote>
<tt><ins>a.</ins>erase(a.begin(),a.end())</tt> post: <tt><del>size() ==
0</del><ins>a.empty() == true</ins></tt>
</blockquote>
</li>

<li>
<p>
Change the text in the Complexity column in the row for "<tt>a.clear()</tt>"
as follows:
</p>

<blockquote>
linear in <tt><ins>a.</ins>size()</tt>
</blockquote>
</li>

<li>
<p>
Change the text in the Complexity column in the row for
"<tt>a.count(k)</tt>" as follows:
</p>

<blockquote>
<tt>log(<ins>a.</ins>size()) + <ins>a.</ins>count(k)</tt>
</blockquote>
</li>
</ol>
</li>

<li>
<p>
In 23.2.5 [unord.req] change Table 98 -- Unordered associative container requirements as indicated:
</p>
<p><i>[
The same rational as for Table 96 applies here
]</i></p>


<ol type="a">
<li>
<p>
Change the text in the Assertion/note column in the row for
"<tt>a.clear()</tt>" as follows:
</p>

<blockquote>
[..] Post: <tt>a.<del>size() == 0</del><ins>empty() == true</ins></tt>
</blockquote>
</li>
</ol>
</li>
</ol>


</blockquote>





<hr>
<h3><a name="865"></a>865. More algorithms that throw away information</h3>
<p><b>Section:</b> 25.3.6 [alg.fill], 25.3.7 [alg.generate] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2008-07-13 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In regard to library defect <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#488">488</a> I found some more algorithms which
unnecessarily throw away information. These are typically algorithms,
which sequentially write into an <tt>OutputIterator</tt>, but do not return the
final value of this output iterator. These cases are:
</p>

<ol>
<li>
<pre>template&lt;class OutputIterator, class Size, class T&gt;
void fill_n(OutputIterator first, Size n, const T&amp; value);</pre></li>

<li>
<pre>template&lt;class OutputIterator, class Size, class Generator&gt;
void generate_n(OutputIterator first, Size n, Generator gen);</pre></li>
</ol>
<p>
In both cases the minimum requirements on the iterator are
<tt>OutputIterator</tt>, which means according to the requirements of
24.2.4 [output.iterators]/2 that only single-pass iterations are guaranteed.
So, if users of <tt>fill_n</tt> and <tt>generate_n</tt> have *only* an <tt>OutputIterator</tt>
available, they have no chance to continue pushing further values
into it, which seems to be a severe limitation to me.
</p>

<p><i>[
Post Summit Daniel "conceptualized" the wording.
]</i></p>


<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Alisdair likes the idea, but has concerns about the specific wording
about the returns clauses.
</p>
<p>
Alan notes this is a feature request.
</p>
<p>
Bill notes we have made similar changes to other algorithms.
</p>
<p>
Move to Open.
</p>
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
We have a consensus for moving forward on this issue, but Daniel needs
to deconceptify it.
</blockquote>

<p><i>[
2009-07-25 Daniel provided non-concepts wording.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Moved to Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>

<ol>
<li>
<p>
Replace the current declaration of <tt>fill_n</tt> in 25 [algorithms]/2, header
<tt>&lt;algorithm&gt;</tt> synopsis and in 25.3.6 [alg.fill] by
</p>

<blockquote><pre>template&lt;class OutputIterator, class Size, class T&gt;
  <del>void</del><ins>OutputIterator</ins> fill_n(OutputIterator first, Size n, const T&amp; value);
</pre></blockquote>

<p>
Just after the effects clause add a new returns clause saying:
</p>

<blockquote>
<ins><i>Returns:</i> For <tt>fill_n</tt> and positive <tt>n</tt>, returns <tt>first + n</tt>. Otherwise
returns <tt>first</tt> for <tt>fill_n</tt>.</ins>
</blockquote>
</li>

<li>
<p>
Replace the current declaration of <tt>generate_n</tt> in 25 [algorithms]/2,
header <tt>&lt;algorithm&gt;</tt> synopsis and in 25.3.7 [alg.generate] by
</p>

<blockquote><pre>template&lt;class OutputIterator, class Size, class Generator&gt;
  <del>void</del><ins>OutputIterator</ins> generate_n(OutputIterator first, Size n, Generator gen);
</pre></blockquote>

<p>
Just after the effects clause add a new returns clause saying:
</p>

<blockquote>
<ins>For <tt>generate_n</tt> and positive <tt>n</tt>, returns <tt>first + n</tt>. Otherwise
returns <tt>first</tt> for <tt>generate_n</tt>.</ins>
</blockquote>
</li>
</ol>







<hr>
<h3><a name="866"></a>866. Qualification of placement new-expressions</h3>
<p><b>Section:</b> 20.9.8 [specialized.algorithms], 20.9.10.2.6 [util.smartptr.shared.create] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Alberto Ganesh Barbati <b>Opened:</b> 2008-07-14 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#specialized.algorithms">issues</a> in [specialized.algorithms].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
LWG issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#402">402</a> replaced "<tt>new</tt>" with "<tt>::new</tt>" in the placement
new-expression in 20.9.5.1 [allocator.members]. I believe the rationale
given in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#402">402</a> applies also to the following other contexts:
</p>
<ul>
<li>
<p>
in 20.9.8 [specialized.algorithms], all four algorithms <tt>unitialized_copy</tt>,
<tt>unitialized_copy_n</tt>, <tt>unitialized_fill</tt> and <tt>unitialized_fill_n</tt> use
the unqualified placement new-expression in some variation of the form:
</p>
<blockquote><pre>new  (static_cast&lt;void*&gt;(&amp;*result)) typename  iterator_traits&lt;ForwardIterator&gt;::value_type(*first);
</pre></blockquote>
</li>
<li>
<p>
in 20.9.10.2.6 [util.smartptr.shared.create] there is a reference to the unqualified placement new-expression:
</p>
<blockquote><pre>new  (pv)  T(std::forward&lt;Args&gt;(args)...),
</pre></blockquote>
</li>
</ul>
<p>
I suggest to add qualification in all those places. As far as I know,
these are all the remaining places in the whole library that explicitly
use a placement new-expression. Should other uses come out, they should
be qualified as well.
</p>
<p>
As an aside, a qualified placement new-expression does not need
additional requirements to be compiled in a constrained context. By
adding qualification, the <tt>HasPlacementNew</tt> concept introduced recently in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2677.pdf">N2677 (Foundational Concepts)</a>
would no longer be needed by library and
should therefore be removed.
</p>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
Detlef: If we move this to Ready, it's likely that we'll forget about
the side comment about the <tt>HasPlacementNew</tt> concept.
</blockquote>

<p><i>[
post San Francisco:
]</i></p>


<blockquote>
Daniel:  <tt>HasPlacementNew</tt> has been removed from
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2774.pdf">N2774 (Foundational Concepts)</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Replace "<tt>new</tt>" with "<tt>::new</tt>" in:
</p>
<ul>
<li>
20.9.8.2 [uninitialized.copy], paragraphs 1 and 3
</li>
<li>
20.9.8.3 [uninitialized.fill]  paragraph 1
</li>
<li>
20.9.8.4 [uninitialized.fill.n] paragraph 1
</li>
<li>
20.9.10.2.6 [util.smartptr.shared.create] once in paragraph 1 and twice in paragraph 2.
</li>
</ul>






<hr>
<h3><a name="868"></a>868. default construction and value-initialization</h3>
<p><b>Section:</b> 23 [containers] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Alberto Ganesh Barbati <b>Opened:</b> 2008-07-22 <b>Last modified:</b> 2010-11-24</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#containers">issues</a> in [containers].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The term "default constructed" is often used in wording that predates
the introduction of the concept of value-initialization. In a few such
places the concept of value-initialization is more correct than the
current wording (for example when the type involved can be a built-in)
so a replacement is in order. Two of such places are already covered by
issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#867">867</a>. This issue deliberately addresses the hopefully
non-controversial changes in the attempt of being approved more quickly.
A few other occurrences (for example in <tt>std::tuple</tt>,
<tt>std::reverse_iterator</tt> and <tt>std::move_iterator</tt>) are left to separate
issues. For <tt>std::reverse_iterator</tt>, see also issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#408">408</a>. This issue is
related with issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#724">724</a>.
</p>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
<p>
The list provided in the proposed resolution is not complete. James
Dennett will review the library and provide a complete list and will
double-check the vocabulary.
</p>
<p>
This issue relates to Issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#886">886</a> tuple construction
</p>
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
The proposed resolution is incomplete.
</p>
<p>
Move to Tentatively NAD Future. Howard will contact Ganesh for wording.
If wording is forthcoming, Howard will move it back to Review.
</p>
</blockquote>

<p><i>[
2009-07-18 Ganesh updated the proposed wording.
]</i></p>


<blockquote>
<p>
Howard:  Moved back to Review.  Note that 20.2.1 [utility.arg.requirements]
refers to a section that is not in the current working paper, but does refer to
a section that we expect to reappear after the de-concepts merge.  This was a
point of confusion we did not recognize when we reviewed this issue in Frankfurt.
</p>
<p>
Howard:  Ganesh also includes a survey of places in the WP surveyed for changes
of this nature and purposefully <em>not</em> treated:
</p>

<blockquote>
<p>
Places where changes are <u>not</u> being
proposed
</p>
<p>
In the following paragraphs, we are not proposing changes because
it's not clear whether we actually prefer value-initialization over
default-initialization (now partially covered by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1012">1012</a>):
</p>
<ul>
    <li><p>20.9.9.2.1 [unique.ptr.single.ctor] para 3 e 7</p></li>
    <li><p>24.5.1.3.1 [reverse.iter.cons] para 1</p></li>
    <li><p>24.5.3.3.1 [move.iter.op.const] para 1</p></li>
</ul>
<p>In the following paragraphs, the expression "default
constructed" need not be changed, because the relevant type does
not depend on a template parameter and has a user-provided
constructor:</p>
<ul>
    <li><p> [func.referenceclosure.invoke] para 12, type:
    reference_closure</p></li>
    <li><p>30.3.1.2 [thread.thread.constr] para 30, type: thread</p></li>
    <li><p>30.3.1.5 [thread.thread.member] para 52, type: thread_id</p></li>
    <li><p>30.3.2 [thread.thread.this], para 1, type: thread_id</p></li>
</ul>
</blockquote>

</blockquote>

<p><i>[
2009-08-18 Daniel adds:
]</i></p>


<blockquote>
<p>
I have no objections against the currently suggested changes, but I
also cross-checked
with the list regarding intentionally excluded changes, and from this
I miss the discussion
of
</p>

<ol>
<li>
<p>
21.4.1 [string.require]/2:
</p>

<blockquote>
"[..] The <tt>Allocator</tt> object used shall be a copy of the <tt>Allocator&gt;</tt>
object passed to the <tt>basic_string</tt> object's
constructor or, if the constructor does not take an <tt>Allocator</tt>
argument, a copy of a default-constructed
<tt>Allocator</tt> object."
</blockquote>
</li>

<li>
<p>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2723.pdf">N2723</a>,
26.5.1.4 [rand.req.eng], Table 109, expression "<tt>T()</tt>":
</p>
<blockquote>
Pre-/post-condition: "Creates an engine with the same initial state as
all other default-constructed engines of type <tt>X</tt>."
</blockquote>

<p>
as well as in 26.5.5 [rand.predef]/1-9 (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2914.pdf">N2914</a>), 26.5.7.1 [rand.util.seedseq]/3, 27.7.1.1.1 [istream.cons]/3, 27.7.2.2 [ostream.cons]/9 (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2914.pdf">N2914</a>), 28.13 [re.grammar]/2, 30.3.1.4 [thread.thread.assign]/1 (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2914.pdf">N2914</a>),
</p>
<p><i>[
Candidates for the "the expression "default constructed" need not be
changed" list
]</i></p>


<p>
I'm fine, if these would be added to the intentionally exclusion list,
but mentioning them makes it
easier for other potential reviewers to decide on the relevance or
not-relevance of them for this issue.
</p>
</li>

<li>
<p>
I suggest to remove the reference of  [func.referenceclosure.invoke]
in the "it's not clear" list, because
this component does no longer exist.
</p>
</li>

<li>
<p>
I also suggest to add a short comment that all paragraphs in the
resolution whether they refer to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2723.pdf">N2723</a> or to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2914.pdf">N2914</a> numbering, because e.g. "Change 23.3.2.1 [deque.cons] para 5" is an <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2723.pdf">N2723</a> coordinate, while "Change 23.3.2.2 [deque.capacity] para 1" is an <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2914.pdf">N2914</a> coordinate. Even better would be to use one default document
for the numbering (probably <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2914.pdf">N2914</a>) and mention special cases (e.g. "Change 20.2.1 [utility.arg.requirements] para 2" as referring to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2723.pdf">N2723</a> numbering).
</p>
</li>
</ol>

</blockquote>

<p><i>[
2009-08-18 Alisdair adds:
]</i></p>


<blockquote>
<p>
I strongly believe the term "default constructed" should not appear in
the library clauses unless we very clearly define a meaning for it, and
I am not sure what that would be.
</p>

<p>
In those cases where we do not want to replace "default constructed"
with "vale initialized" we should be using "default initialized".  If we
have a term that could mean either, we reduce portability of programs.
</p>

<p>
I have not done an exhaustive review to clarify if that is a vendor
freedom we have reason to support (e.g. value-init in debug,
default-init in release) so I may yet be convinced that LWG has reason
to define this new term of art, but generally C++ initialization is
confusing enough without supporting further ill-defined terms.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Move to Ready.
</blockquote>

<p><i>[
2010 Pittsburgh:
]</i></p>


<blockquote>
Moved to review in order to enable conflict resolution with <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#704">704</a>.
</blockquote>

<p><i>[
2010-03-26 Daniel harmonized the wording with the upcoming FCD.
]</i></p>



<p><i>[
2010 Rapperswil:
]</i></p>


<blockquote>
Move to Ready.
</blockquote>

<p><i>[
Adopted at 2010-11 Batavia
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
Change 20.2.1 [utility.arg.requirements] para 2:
</p>

<blockquote>
2 In general, a default constructor is
not required. Certain container class member function signatures
specify <del>the default constructor</del><ins>T()</ins>
as a default argument. T() shall be a well-defined expression (8.5)
if one of those signatures is called using the default argument
(8.3.6).
</blockquote>

<p>
Change 23.3.2.1 [deque.cons] para 3:
</p>

<blockquote>
3 <i>Effects:</i> Constructs a deque with n
<del>default constructed</del><ins>value-initialized</ins>
elements. 
</blockquote>

<p>
Change 23.3.2.2 [deque.capacity] para 1:
</p>

<blockquote>
1 <i>Effects:</i> If sz &lt; size(), equivalent
to erase(begin() + sz, end());. If size() &lt; sz, appends sz -
size() <del>default
constructed</del><ins>value-initialized</ins>
elements to the sequence.
</blockquote>

<p>
Change 23.3.3.1 [forwardlist.cons] para 3:
</p>

<blockquote>
3 <i>Effects:</i> Constructs a forward_list object with n <del>default
constructed</del><ins>value-initialized</ins>
elements.
</blockquote>

<p>
Change 23.3.3.4 [forwardlist.modifiers] para 22:
</p>

<blockquote>
22 <i>Effects:</i> [...] For the first signature
the inserted elements are <del>default
constructed</del><ins>value-initialized</ins>,
and for the second signature they are copies of c.
</blockquote>

<p>
Change 23.3.4.1 [list.cons] para 3:
</p>

<blockquote>
3 <i>Effects:</i> Constructs a list with n <del>default
constructed</del><ins>value-initialized</ins>
elements. 
</blockquote>

<p>
Change 23.3.4.2 [list.capacity] para 1:
</p>

<blockquote>
1 <i>Effects:</i> If sz &lt; size(), equivalent
to list&lt;T&gt;::iterator it = begin(); advance(it, sz); erase(it,
end());. If size() &lt; sz, appends sz - size() <del>default
constructed</del><ins>value-initialized</ins>
elements to the sequence.
</blockquote>

<p>
Change 23.4.1.1 [vector.cons] para 3:
</p>

<blockquote>
3 <i>Effects:</i> Constructs a vector with n
<del>default constructed</del><ins>value-initialized</ins>
elements. 
</blockquote>

<p>
Change 23.4.1.2 [vector.capacity] para 9:
</p>

<blockquote>
9 <i>Effects:</i> If sz &lt; size(), equivalent
to erase(begin() + sz, end());. If size() &lt; sz, appends sz -
size() <del>default
constructed</del><ins>value-initialized</ins>
elements to the sequence.
</blockquote>






<hr>
<h3><a name="869"></a>869. Bucket (local) iterators and iterating past end</h3>
<p><b>Section:</b> 23.2.5 [unord.req] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Sohail Somani <b>Opened:</b> 2008-07-22 <b>Last modified:</b> 2010-10-29</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#unord.req">active issues</a> in [unord.req].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#unord.req">issues</a> in [unord.req].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Is there any language in the current draft specifying the behaviour of the following snippet?
</p>

<blockquote><pre>unordered_set&lt;int&gt; s;
unordered_set&lt;int&gt;::local_iterator it = s.end(0);

// Iterate past end - the unspecified part
it++;
</pre></blockquote>

<p>
I don't think there is anything about <tt>s.end(n)</tt> being considered an
iterator for the past-the-end value though (I think) it should be.
</p>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
We believe that this is not a substantive change, but the proposed
change to the wording is clearer than what we have now.
</blockquote>

<p><i>[
Post Summit:
]</i></p>


<blockquote>
Recommend Tentatively Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change Table 97 "Unordered associative container requirements" in 23.2.5 [unord.req]:
</p>

<blockquote>
<table border="1">
<caption>Table 97: Unordered associative container requirements</caption>
<tbody><tr>
<th>expression</th><th>return type</th><th>assertion/note pre/post-condition</th><th>complexity</th>
</tr>
<tr>
<td><tt>b.begin(n)</tt></td>
<td><tt>local_iterator</tt><br><tt>const_local_iterator</tt> for const <tt>b</tt>.</td>
<td>Pre: n shall be in the range [0,b.bucket_count()). <del>Note: [b.begin(n), b.end(n)) is a
valid range containing all of the elements in the n<sup>th</sup> bucket.</del>
<ins><tt>b.begin(n)</tt> returns an iterator referring to the first element in the bucket.
If the bucket is empty, then <tt>b.begin(n) == b.end(n)</tt>.</ins></td>
<td>Constant</td>
</tr>
<tr>
<td><tt>b.end(n)</tt></td>
<td><tt>local_iterator</tt><br><tt>const_local_iterator</tt> for const <tt>b</tt>.</td>
<td>Pre: n shall be in the range <tt>[0, b.bucket_count())</tt>.
<ins><tt>b.end(n)</tt> returns an iterator which is the past-the-end value for the bucket.</ins></td>
<td>Constant</td>
</tr>
</tbody></table>
</blockquote>






<hr>
<h3><a name="870"></a>870. Do unordered containers not support function pointers for predicate/hasher?</h3>
<p><b>Section:</b> 23.2.5 [unord.req] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2008-08-17 <b>Last modified:</b> 2010-10-29</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#unord.req">active issues</a> in [unord.req].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#unord.req">issues</a> in [unord.req].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Good ol' associative containers allow both function pointers and
function objects as feasible
comparators, as described in 23.2.4 [associative.reqmts]/2:
</p>

<blockquote>
Each associative container is parameterized on <tt>Key</tt> and an ordering
relation <tt>Compare</tt> that
induces a strict weak ordering (25.3) on elements of Key. [..]. The
object of type <tt>Compare</tt> is
called the comparison object of a container. This comparison object
may be a pointer to
function or an object of a type with an appropriate function call operator.[..]
</blockquote>

<p>
The corresponding wording for unordered containers is not so clear,
but I read it to disallow
function pointers for the hasher and I miss a clear statement for the
equality predicate, see
23.2.5 [unord.req]/3+4+5:
</p>

<blockquote>
<p>
Each unordered associative container is parameterized by <tt>Key</tt>, by a
function object <tt>Hash</tt> that
acts as a hash function for values of type <tt>Key</tt>, and by a binary
predicate <tt>Pred</tt> that induces an
equivalence relation on values of type <tt>Key</tt>.[..]
</p>
<p>
A hash function is a function object that takes a single argument of
type <tt>Key</tt> and returns a
value of type <tt>std::size_t</tt>.
</p>
<p>
Two values <tt>k1</tt> and <tt>k2</tt> of type <tt>Key</tt> are considered equal if the
container's equality function object
returns <tt>true</tt> when passed those values.[..]
</p>
</blockquote>

<p>
and table 97 says in the column "assertion...post-condition" for the
expression X::hasher:
</p>

<blockquote>
<tt>Hash</tt> shall be a unary function object type such that the expression
<tt>hf(k)</tt> has type <tt>std::size_t</tt>.
</blockquote>

<p>
Note that 20.8 [function.objects]/1 defines as "Function objects are
objects with an <tt>operator()</tt> defined.[..]"
</p>
<p>
Does this restriction exist by design or is it an oversight? If an
oversight, I suggest that to apply
the following
</p>

<p><i>[
2009-07-28 Reopened by Alisdair.  No longer solved by concepts.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Ask Daniel to provide proposed wording that: makes it explicit that
function pointers are function objects at the beginning of 20.8 [function.objects]; fixes the "requirements" for typedefs in
20.8.4 [refwrap] to instead state that the function objects
defined in that clause have these typedefs, but not that these typedefs
are requirements on function objects; remove the wording that explicitly
calls out that associative container comparators may be function
pointers.
</blockquote>

<p><i>[
2009-12-19 Daniel updates wording and rationale.
]</i></p>


<p><i>[
2010-02-11 Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>




<p><b>Rationale:</b></p>

<p>
The below provided wording also affects some part of the library which is
involved with <em>callable types</em> (20.8.1 [func.def]/3). Reason for
this is that <em>callable objects</em> do have a lot in common with <em>function
objects</em>. A simple formula seems to be:
</p>

<blockquote>
callable objects = function objects + pointers to member
</blockquote>

<p>
The latter group is excluded from function objects because of the
expression-based usage of <em>function objects</em> in the algorithm clause,
which is incompatible with the notation to dereference pointers to member
without a concept map available in the language.
</p>

<p>
This analysis showed some currently existing normative definition differences
between the above subset of callable objects and function objects which seem to
be unintended: Backed by the Santa Cruz outcome function objects should include
both function pointers and "object[s] with an operator() defined". This clearly
excludes class types with a conversion function to a function pointer or all
similar conversion function situations described in 13.3 [over.match]/2
b. 2. In contrast to this, the wording for callable types seems to be less
constrained (20.8.1 [func.def]/3):
</p>

<blockquote>
A callable type is a [..] class type whose objects can appear immediately to the
left of a function call operator.
</blockquote>

<p>
The rationale given in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1673.html#fn2">N1673</a>
and a recent private communication with Peter Dimov revealed that the intention
of this wording was to cover the above mentioned class types with conversion
functions as well. To me the current wording of callable types can be read
either way and I suggest to make the intention more explicit by replacing
</p>

<blockquote>
[..] class type whose objects can appear immediately to the left of a function
call operator
</blockquote>

by

<blockquote>
[..] class type whose objects can appear as the leftmost subexpression of a
function call expression 5.2.2 [expr.call].
</blockquote>

<p>
and to use the same definition for the class type part of <em>function
objects</em>, because there is no reason to exclude class types with a
conversion function to e.g. pointer to function from being used in algorithms.
</p>

<p>
Now this last term "function objects" itself brings us to a third unsatisfactory
state: The term is used both for objects (e.g. "Function objects are
objects[..]" in 20.8 [function.objects]/1) and for types (e.g. "Each
unordered associative container is parameterized [..] by a function object Hash
that acts as a hash function [..]" in 23.2.5 [unord.req]/3). This
impreciseness should be fixed and I suggest to introduce the term <em>function
object type</em> as the counter part to <em>callable type</em>. This word seems
to be a quite natural choice, because the library already uses it here and there
(e.g. "Hash shall be a unary function object type such that the expression
<tt>hf(k)</tt> has type <tt>std::size_t</tt>." in Table 98, "<tt>X::hasher</tt>"
or "Requires: <tt>T</tt> shall be a function object type [..]" in 20.8.14.2.5 [func.wrap.func.targ]/3).
</p>

<p>
Finally I would like to add that part of the issue 870 discussion related to the
requirements for typedefs in 20.8.4 [refwrap] during the Santa Cruz
meeting is now handled by the new issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1290">1290</a>.
</p>

<p>
Obsolete rationale:
</p>

<blockquote>
<p><i>[
San Francisco:
]</i></p>


<blockquote>
This is fixed by
<a href="" ref="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2776.pdf">N2776</a>.
</blockquote>

</blockquote>



<p><b>Proposed resolution:</b></p>

<ol>

<li>
<p>
Change 20.8 [function.objects]/1 as indicated:
</p>

<blockquote>
<p>
1 <del>Function objects are objects with an <tt>operator()</tt>
defined.</del> <ins>An object type (3.9 [basic.types]) that can be the
type of the <em>postfix-expression</em> in a function call (5.2.2 [expr.call], 13.3.1.1 [over.match.call]) is called a <em>function
object type</em><sup>*</sup>. A <em>function object</em> is an object of a
<em>function object type</em>.</ins> In the places where one would expect to
pass a pointer to a function to an algorithmic template (Clause 25 [algorithms]), the interface is specified to accept <del>an object with
an <tt>operator()</tt> defined</del><ins>a function object</ins>. This not only
makes algorithmic templates work with pointers to functions, but also enables
them to work with arbitrary function objects.
</p>
<blockquote><ins>
* Such a type is either a function pointer or a class type which often has a
member <tt>operator()</tt>, but in some cases it can omit that member and
provide a conversion to a pointer to function.
</ins></blockquote>
</blockquote>
</li>

<li>
<p>
Change 20.8.1 [func.def]/3 as indicated: <i>[The intent is to make the
commonality of callable types and function object
types more explicit and to get rid of wording redundancies]</i>
</p>

<blockquote>
3 A <i>callable type</i> is <del>a pointer to function,</del> a pointer to
member <del>function, a pointer to member data,</del> or a <del>class type whose
objects can appear immediately to the left of a function call operator</del>
<ins><em>function object type</em> (20.8 [function.objects])</ins>.
</blockquote>
</li>

<li>
<p>
Change 20.8.10 [bind]/1 as indicated:
</p>

<blockquote>
1 The function template <tt>bind</tt> returns an object that binds a
<del>function</del> <ins>callable</ins> object passed as an argument to
additional arguments.
</blockquote>
</li>

<li>
<p>
Change 20.8.10.1 [func.bind]/1 as indicated:
</p>

<blockquote>
1 This subclause describes a uniform mechanism for binding arguments of
<del>function</del> <ins>callable</ins> objects.
</blockquote>
</li>

<li>
<p>
Change 20.8.14 [func.wrap]/1 as indicated:
</p>

<blockquote>
1 This subclause describes a polymorphic wrapper class that encapsulates
arbitrary <del>function</del> <ins>callable</ins> objects.
</blockquote>
</li>

<li>
<p>
Change 20.8.14.2 [func.wrap.func]/2 as indicated <i>[The reason for this
change is that 20.8.14.2 [func.wrap.func]/1 clearly says that all callable
types may be wrapped by <tt>std::function</tt> and current implementations
indeed do provide support for pointer to members as well. One further suggested
improvement is to set the below definition of Callable in italics]</i>:
</p>

<blockquote>
2 A <del>function</del><ins>callable</ins> object <tt>f</tt> of type <tt>F</tt>
is <del>Callable</del> <ins><em>Callable</em></ins> for argument types
<del><tt>T1, T2, ..., TN</tt> in</del> <tt>ArgTypes</tt> and <del>a</del> return
type <tt>R</tt><del>,</del> if<del>, given lvalues <tt>t1, t2, ..., tN</tt> of
types <tt>T1, T2, ..., TN</tt>, respectively,</del> <ins>the expression</ins>
<tt><i>INVOKE</i>(f, <ins>declval&lt;ArgTypes&gt;()..., R</ins><del>t1, t2, ...,
tN</del>)</tt><ins>, considered as an unevaluated operand (5 [expr]),</ins> is well formed (20.7.2)<del> and, if <tt>R</tt> is not
<tt>void</tt>, convertible to <tt>R</tt></del>.
</blockquote>
</li>



<li>
<p>
Change 20.8.14.2.1 [func.wrap.func.con]/7 as indicated:
</p>

<blockquote><pre>function(const function&amp; f);
template &lt;class A&gt; function(allocator_arg_t, const A&amp; a, const function&amp; f);
</pre>
<blockquote>
<p>...</p>
<p>
7 <i>Throws:</i> shall not throw exceptions if <tt>f</tt>'s target is a function
pointer or a <del>function</del> <ins>callable</ins> object passed via
<tt>reference_wrapper</tt>. Otherwise, may throw <tt>bad_alloc</tt> or any
exception thrown by the copy constructor of the stored <del>function</del>
<ins>callable</ins> object. [<i>Note:</i> Implementations are encouraged to
avoid the use of dynamically allocated memory for small <del>function</del>
<ins>callable</ins> objects, e.g., where <tt>f</tt>'s target is an object
holding only a pointer or reference to an object and a member function pointer.
 <i>end note</i>]
</p>
</blockquote>
</blockquote>
</li>

<li>
<p>
Change 20.8.14.2.1 [func.wrap.func.con]/11 as indicated:
</p>

<blockquote><pre>template&lt;class F&gt; function(F f);
template &lt;class F, class A&gt; function(allocator_arg_t, const A&amp; a, F f);
</pre>
<blockquote>
<p>...</p>
<p>
11 [..] [<i>Note:</i> implementations are encouraged to avoid the use of dynamically
allocated memory for small <del>function</del> <ins>callable</ins> objects, for
example, where <tt>f</tt>'s target is an object holding only a pointer or
reference to an object and a member function pointer.  <i>end note</i>]
</p>
</blockquote>
</blockquote>
</li>

<li>
<p>
Change 20.8.14.2.4 [func.wrap.func.inv]/3 as indicated:
</p>

<blockquote><pre>R operator()(ArgTypes... args) const
</pre>
<blockquote>
<p>...</p>
<p>
3 <i>Throws:</i> <tt>bad_function_call</tt> if <tt>!*this</tt>; otherwise, any
exception thrown by the wrapped <del>function</del> <ins>callable</ins> object.
</p>
</blockquote>
</blockquote>
</li>

<li>
<p>
Change 20.8.14.2.5 [func.wrap.func.targ]/3 as indicated:
</p>

<blockquote><pre>template&lt;typename T&gt;       T* target();
template&lt;typename T&gt; const T* target() const;
</pre>
<blockquote>
<p>...</p>
<p>
3 <i>Requires:</i> <tt>T</tt> shall be a <del>function object</del> type that is
Callable (20.8.14.2 [func.wrap.func]) for parameter types <tt>ArgTypes</tt>
and return type <tt>R</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li>
<p>
Change 23.2.4 [associative.reqmts]/2 as indicated: <i>[The suggested
removal seems harmless, because 25.4 [alg.sorting]1 already clarifies
that <tt>Compare</tt> is a function object type. Nevertheless it is recommended,
because the explicit naming of "pointer to function" is misleading]</i>
</p>

<blockquote>
2 Each associative container is parameterized on <tt>Key</tt> and an ordering
relation <tt>Compare</tt> that induces a strict weak ordering (25.4 [alg.sorting]) on elements of <tt>Key</tt>. In addition, <tt>map</tt>
and <tt>multimap</tt> associate an arbitrary type <tt>T</tt> with the
<tt>Key</tt>. The object of type <tt>Compare</tt> is called the comparison
object of a container. <del>This comparison object may be a pointer to function
or an object of a type with an appropriate function call operator.</del>
</blockquote>
</li>

<li>
<p>
Change 23.2.5 [unord.req]/3 as indicated:
</p>

<blockquote>
3 Each unordered associative container is parameterized by <tt>Key</tt>, by a
function object <ins>type</ins> <tt>Hash</tt> that acts as a hash function for
values of type <tt>Key</tt>, and by a binary predicate <tt>Pred</tt> that
induces an equivalence relation on values of type Key. [..]
</blockquote>
</li>

<li>
<p>
Change 25.1 [algorithms.general]/7 as indicated: <i>[The intent is to
bring this part in sync with 20.8 [function.objects]]</i>
</p>

<blockquote>
7 The <tt>Predicate</tt> parameter is used whenever an algorithm expects a
function object <ins>(20.8 [function.objects])</ins> that when applied
to the result of dereferencing the corresponding iterator returns a value
testable as <tt>true</tt>. In other words, if an algorithm takes <tt>Predicate
pred</tt> as its argument and <tt>first</tt> as its iterator argument, it should
work correctly in the construct <tt>if (pred(*first)){...}</tt>. The function
object <tt>pred</tt> shall not apply any nonconstant function through the
dereferenced iterator. <del>This function object may be a pointer to function,
or an object of a type with an appropriate function call operator.</del>
</blockquote>
</li>

<li>
<p>
Change 20.9.9.2 [unique.ptr.single]/1 as indicated:
</p>

<blockquote>
1 The default type for the template parameter <tt>D</tt> is
<tt>default_delete</tt>. A client-supplied template argument <tt>D</tt> shall be
a function <del>pointer or functor</del> <ins>object type</ins> for which, given
a value <tt>d</tt> of type <tt>D</tt> and a pointer <tt>ptr</tt> of type
<tt>T*</tt>, the expression <tt>d(ptr)</tt> is valid and has the effect of
deallocating the pointer as appropriate for that deleter. <tt>D</tt> may also be
an lvalue-reference to a deleter.
</blockquote>
</li>

</ol>








<hr>
<h3><a name="871"></a>871. Iota's requirements on T are too strong</h3>
<p><b>Section:</b> 26.7.5 [numeric.iota] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2008-08-20 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
According to the recent WP
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2691.pdf">N2691</a>,
26.7.5 [numeric.iota]/1, the requires clause
of <tt>std::iota</tt> says:
</p>

<blockquote>
<tt>T</tt> shall meet the requirements of <tt>CopyConstructible</tt> and <tt>Assignable</tt> types, and
shall be convertible to <tt>ForwardIterator</tt>'s value type.[..]
</blockquote>

<p>
Neither <tt>CopyConstructible</tt> nor <tt>Assignable</tt> is needed, instead <tt>MoveConstructible</tt>
seems to be the correct choice. I guess the current wording resulted as an
artifact from comparing it with similar numerical algorithms like <tt>accumulate</tt>.
</p>

<p>
Note: If this function will be conceptualized, the here proposed
<tt>MoveConstructible</tt>
requirement can be removed, because this is an implied requirement of
function arguments, see
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2710.pdf">N2710</a>/[temp.req.impl]/3, last bullet.
</p>

<p><i>[
post San Francisco:
]</i></p>


<blockquote>
Issue pulled by author prior to review.
</blockquote>

<p><i>[
2009-07-30 Daniel reopened:
]</i></p>


<blockquote>
with the absence of concepts, this issue (closed) is valid again and I
suggest to reopen it.
I also revised by proposed resolution based on N2723 wording:
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Change 'convertible' to 'assignable', Move To Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change the first sentence of 26.7.5 [numeric.iota]/1:
</p>

<blockquote>
<i>Requires:</i> <tt>T</tt> shall <del>meet the requirements of <tt>CopyConstructible</tt> and
<tt>Assignable</tt> types, and shall</del> be
assignable to <tt>ForwardIterator</tt>'s value type. [..]
</blockquote>








<hr>
<h3><a name="872"></a>872. <tt>move_iterator::operator[]</tt> has wrong return type</h3>
<p><b>Section:</b> 24.5.3.3.12 [move.iter.op.index] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Doug Gregor <b>Opened:</b> 2008-08-21 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>move_iterator</tt>'s <tt>operator[]</tt> is declared as:
</p>

<blockquote><pre>reference operator[](difference_type n) const;
</pre></blockquote>

<p>
This has the same problem that <tt>reverse_iterator</tt>'s <tt>operator[]</tt> used to
have: if the underlying iterator's <tt>operator[]</tt> returns a proxy, the
implicit conversion to <tt>value_type&amp;&amp;</tt> could end up referencing a temporary
that has already been destroyed. This is essentially the same issue that
we dealt with for <tt>reverse_iterator</tt> in DR <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#386">386</a>.
</p>

<p><i>[
2009-07-28 Reopened by Alisdair.  No longer solved by concepts.
]</i></p>


<p><i>[
2009-08-15 Howard adds:
]</i></p>


<blockquote>
I recommend closing this as  a duplicate of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1051">1051</a> which addresses
this issue for both <tt>move_iterator</tt> and <tt>reverse_iterator</tt>.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Move to Ready. Note that if <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1051">1051</a> is reopened, it may yield a
better resolution, but <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1051">1051</a> is currently marked NAD.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
In 24.5.3.1 [move.iterator] and 24.5.3.3.12 [move.iter.op.index], change the declaration of
<tt>move_iterator</tt>'s <tt>operator[]</tt> to:
</p>

<blockquote><pre><del>reference</del> <ins><i>unspecified</i></ins> operator[](difference_type n) const;
</pre></blockquote>



<p><b>Rationale:</b></p>
<p><i>[
San Francisco:
]</i></p>


<blockquote>
NAD Editorial, see
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2777.pdf">N2777</a>.
</blockquote>




<hr>
<h3><a name="876"></a>876. <tt>basic_string</tt> access operations should give stronger guarantees</h3>
<p><b>Section:</b> 21.4 [basic.string] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2008-08-22 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#basic.string">issues</a> in [basic.string].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
During the Sophia Antipolis meeting it was decided to split-off some
parts of the
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2647.html">n2647</a>
("Concurrency modifications for <tt>basic_string</tt>")
proposal into a separate issue, because these weren't actually
concurrency-related. The here proposed changes refer to the recent
update document
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2668.htm">n2668</a>
and attempt to take advantage of the
stricter structural requirements.
</p>
<p>
Indeed there exists some leeway for more guarantees that would be
very useful for programmers, especially if interaction with transactionary
or exception-unaware C API code is important. This would also allow
compilers to take advantage of more performance optimizations, because
more functions can have throw() specifications. This proposal uses the
form of "Throws: Nothing" clauses to reach the same effect, because
there already exists a different issue in progress to clean-up the current
existing "schizophrenia" of the standard in this regard.
</p>
<p>
Due to earlier support for copy-on-write, we find the following
unnecessary limitations for C++0x:
</p>

<ol>
<li>
Missing no-throw guarantees: <tt>data()</tt> and <tt>c_str()</tt> simply return
a pointer to their guts, which is a non-failure operation. This should
be spelled out. It is also noteworthy to mention that the same
guarantees should also be given by the size query functions,
because the combination of pointer to content and the length is
typically needed during interaction with low-level API.
</li>
<li>
Missing complexity guarantees: <tt>data()</tt> and <tt>c_str()</tt> simply return
a pointer to their guts, which is guaranteed O(1). This should be
spelled out.
</li>
<li>
Missing reading access to the terminating character: Only the
const overload of <tt>operator[]</tt> allows reading access to the terminator
char. For more intuitive usage of strings, reading access to this
position should be extended to the non-const case. In contrast
to C++03 this reading access should now be homogeneously
an lvalue access.
</li>
</ol>

<p>
The proposed resolution is split into a main part (A) and a
secondary part (B) (earlier called "Adjunct Adjunct Proposal").
(B) extends (A) by also making access to index position
size() of the at() overloads a no-throw operation. This was
separated, because this part is theoretically observable in
specifically designed test programs.
</p>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
<p>
We oppose part 1 of the issue but hope to address <tt>size()</tt> in
issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#877">877</a>.
</p>
<p>
We do not support part B. 4 of the issue because of the breaking API change.
</p>
<p>
We support part A. 2 of the issue.
</p>
<p>
On support part A. 3 of the issue:
</p>
<blockquote>
Pete's broader comment: now that we know that basic_string will be a
block of contiguous memory, we should just rewrite its specification
with that in mind. The expression of the specification will be simpler
and probably more correct as a result.
</blockquote>
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
Move proposed resolution A to Ready.
</p>
<p><i>[
Howard: Commented out part B.
]</i></p>

</blockquote>



<p><b>Proposed resolution:</b></p>
<ol type="A">
<li>
<ol>
<li>
<p>In 21.4.4 [string.capacity], just after p. 1 add a new paragraph:
</p>
<blockquote>
<i>Throws:</i> Nothing.
</blockquote>

</li>
<li>
<p>
In 21.4.5 [string.access] <em>replace</em> p. 1 by the following <em>4</em> paragraghs:
</p>

<blockquote>
<p>
<i>Requires:</i> <tt>pos &#8804; size()</tt>.
</p>
<p>
<i>Returns:</i> If <tt>pos &lt; size()</tt>, returns <tt>*(begin() + pos)</tt>. Otherwise, returns
a reference to a <tt>charT()</tt> that shall not be modified.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
<p>
<i>Complexity:</i> Constant time.
</p>
</blockquote>

</li>
<li>
<p>
In 21.4.7.1 [string.accessors] replace the now <em>common</em> returns
clause of <tt>c_str()</tt> and <tt>data()</tt> by the following <em>three</em> paragraphs:
</p>
<blockquote>
<p>
<i>Returns:</i> A pointer <tt>p</tt> such that <tt>p+i == &amp;operator[](i)</tt> for each <tt>i</tt>
in <tt>[0, size()]</tt>.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
<p>
<i>Complexity:</i> Constant time.
</p>
</blockquote>
</li>
</ol>
</li>

</ol>






<hr>
<h3><a name="878"></a>878. <tt>forward_list</tt> preconditions</h3>
<p><b>Section:</b> 23.3.3 [forwardlist] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2008-08-23 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#forwardlist">issues</a> in [forwardlist].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
       <p>

<tt>forward_list</tt> member functions that take
a <tt>forward_list::iterator</tt> (denoted <tt>position</tt> in the
function signatures) argument have the following precondition:

       </p>
       <blockquote>

<i>Requires:</i> <tt>position</tt> is dereferenceable or equal
to <tt>before_begin()</tt>.

       </blockquote>
       <p>

I believe what's actually intended is this:

       </p>
       <blockquote>

<i>Requires:</i> <tt>position</tt> is in the range
[<tt>before_begin()</tt>, <tt>end()</tt>).

       </blockquote>
       <p>

That is, when it's dereferenceable, <tt>position</tt> must point
into <tt>*this</tt>, not just any <tt>forward_list</tt> object.

       </p>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
Robert suggested alternate proposed wording which had large support.
</blockquote>

<p><i>[
Post Summit:
]</i></p>


<blockquote>
<p>
Walter: "position is before_begin() or a dereferenceable": add "is" after the "or"
</p>
<p>
With that minor update, Recommend Tentatively Ready.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
       <p>

Change the <i>Requires</i> clauses
 [forwardlist] , p21, p24, p26, p29, and,
23.3.3.5 [forwardlist.ops], p39, p43, p47
as follows:

       </p>
       <blockquote>

<i>Requires:</i> <tt>position</tt> is <ins><tt>before_begin()</tt> or is a</ins>
dereferenceable
<ins>iterator in the range <tt>[begin(), end())</tt></ins>
<del>or equal to <tt>before_begin()</tt></del>. ...

       </blockquote>
   



<hr>
<h3><a name="881"></a>881. shared_ptr conversion issue</h3>
<p><b>Section:</b> 20.9.10.2.1 [util.smartptr.shared.const] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Peter Dimov <b>Opened:</b> 2008-08-30 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#util.smartptr.shared.const">issues</a> in [util.smartptr.shared.const].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
We've changed <tt>shared_ptr&lt;Y&gt;</tt> to not convert to <tt>shared_ptr&lt;T&gt;</tt> when <tt>Y*</tt>
doesn't convert to <tt>T*</tt> by resolving issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#687">687</a>. This only fixed the
converting copy constructor though.
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2351.htm">N2351</a>
later added move support, and
the converting move constructor is not constrained.
</p>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
We might be able to move this to NAD, Editorial once shared_ptr is
conceptualized, but we want to revisit this issue to make sure.
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
Moved to Ready.
</p>
<p>
This issue now represents the favored format for specifying constrained templates.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
We need to change the Requires clause of the move constructor:
</p>

<blockquote><pre>shared_ptr(shared_ptr&amp;&amp; r); 
template&lt;class Y&gt; shared_ptr(shared_ptr&lt;Y&gt;&amp;&amp; r); 
</pre>
<blockquote>
<i><del>Requires</del> <ins>Remarks</ins>:</i> <del>For the second constructor <tt>Y*</tt> shall be
convertible to <tt>T*</tt>.</del>
<ins>
The second constructor shall not participate in overload resolution
unless <tt>Y*</tt> is convertible to <tt>T*</tt>.
</ins>
</blockquote>
</blockquote>

<p>
in order to actually make the example in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#687">687</a> compile
(it now resolves to the move constructor).
</p>






<hr>
<h3><a name="882"></a>882. <tt>duration</tt> non-member arithmetic requirements</h3>
<p><b>Section:</b> 20.11.3.5 [time.duration.nonmember] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2008-09-08 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#time.duration.nonmember">issues</a> in [time.duration.nonmember].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2661.htm">N2661</a>
specified the following requirements for the non-member <tt>duration</tt>
arithmetic:
</p>

<blockquote>

<pre>template &lt;class Rep1, class Period, class Rep2&gt;
  duration&lt;typename common_type&lt;Rep1, Rep2&gt;::type, Period&gt;
  operator*(const duration&lt;Rep1, Period&gt;&amp; d, const Rep2&amp; s);
</pre>
<blockquote>
<i>Requires:</i> Let <tt>CR</tt> represent the <tt>common_type</tt> of <tt>Rep1</tt> and
<tt>Rep2</tt>.  Both <tt>Rep1</tt> and <tt>Rep2</tt> shall be implicitly convertible
to CR, diagnostic required.
</blockquote>

<pre>template &lt;class Rep1, class Period, class Rep2&gt;
  duration&lt;typename common_type&lt;Rep1, Rep2&gt;::type, Period&gt;
  operator*(const Rep1&amp; s, const duration&lt;Rep2, Period&gt;&amp; d);
</pre>

<blockquote>
<i>Requires:</i> Let <tt>CR</tt> represent the <tt>common_type</tt> of
<tt>Rep1</tt> and <tt>Rep2</tt>. Both <tt>Rep1</tt> and <tt>Rep2</tt>
shall be implicitly convertible to <tt>CR</tt>, diagnostic required.
</blockquote>

<pre>template &lt;class Rep1, class Period, class Rep2&gt;
  duration&lt;typename common_type&lt;Rep1, Rep2&gt;::type, Period&gt;
  operator/(const duration&lt;Rep1, Period&gt;&amp; d, const Rep2&amp; s);
</pre>

<blockquote>
<i>Requires:</i> Let <tt>CR</tt> represent the <tt>common_type</tt> of
<tt>Rep1</tt> and <tt>Rep2</tt>. Both <tt>Rep1</tt> and <tt>Rep2</tt> shall be
implicitly convertible to <tt>CR</tt>, and <tt>Rep2</tt> shall not be an
instantiation of <tt>duration</tt>, diagnostic required.
</blockquote>

</blockquote>

<p>
During transcription into the working paper, the requirements clauses on these
three functions was changed to:
</p>

<blockquote>
<i>Requires:</i> <tt>CR(Rep1, Rep2)</tt> shall exist. Diagnostic required.
</blockquote>

<p>
This is a non editorial change with respect to
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2661.htm">N2661</a>
as user written representations which are used in <tt>duration</tt> need not be
implicitly convertible to or from arithmetic types in order to interoperate with
<tt>duration</tt>s based on arithmetic types.  An explicit conversion will do
fine for most expressions as long as there exists a <tt>common_type</tt> specialization
relating the user written representation and the arithmetic type.  For example:
</p>

<blockquote><pre>class saturate
{
public:
  explicit saturate(long long i);
  ...
};

namespace std {

template &lt;&gt;
struct common_type&lt;saturate, long long&gt;
{
    typedef saturate type;
};

template &lt;&gt;
struct common_type&lt;long long, saturate&gt;
{
    typedef saturate type;
};

}  // std

millisecond ms(3);  // integral-based duration
duration&lt;saturate, milli&gt; my_ms = ms;  // ok, even with explicit conversions
my_ms = my_ms + ms;                    // ok, even with explicit conversions
</pre></blockquote>

<p>
However, when dealing with multiplication of a duration and its representation,
implicit convertibility is required between the rhs and the lhs's representation
for the member <tt>*=</tt> operator:
</p>

<blockquote><pre>template &lt;class Rep, class Period = ratio&lt;1&gt;&gt; 
class duration { 
public: 
   ...
   duration&amp; operator*=(const rep&amp; rhs);
   ...
};
...
ms *= 2;               // ok, 2 is implicitly convertible to long long
my_ms *= saturate(2);  // ok, rhs is lhs's representation
my_ms *= 2;            // error, 2 is not implicitly convertible to saturate
</pre></blockquote>

<p>
The last line does not (and should not) compile.  And we want non-member multiplication
to have the same behavior as member arithmetic:
</p>

<blockquote><pre>my_ms = my_ms * saturate(2);  // ok, rhs is lhs's representation
my_ms = my_ms * 2;            // <em>should be</em> error, 2 is not implicitly convertible to saturate
</pre></blockquote>

<p>
The requirements clauses of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2661.htm">N2661</a>
make the last line an error as expected.  However the latest working draft at
this time
(<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2723.pdf">N2723</a>)
allows the last line to compile.
</p>

<p>
All that being said, there does appear to be an error in these requirements clauses
as specified by 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2661.htm">N2661</a>.
</p>

<blockquote>
<i>Requires:</i> ... <em>Both</em> <tt>Rep1</tt> and <tt>Rep2</tt> shall be implicitly convertible
to CR, diagnostic required.
</blockquote>

<p>
It is not necessary for both <tt>Rep</tt>s to be <i>implicitly</i> convertible to
the <tt>CR</tt>.  It is only necessary for the rhs <tt>Rep</tt> to be implicitly
convertible to the <tt>CR</tt>.  The <tt>Rep</tt> within the <tt>duration</tt>
should be allowed to only be explicitly convertible to the <tt>CR</tt>.  The
explicit-conversion-requirement is covered under 20.11.3.7 [time.duration.cast].
</p>



<p><b>Proposed resolution:</b></p>
<p>
Change the requirements clauses under 20.11.3.5 [time.duration.nonmember]:
</p>

<blockquote>

<pre>template &lt;class Rep1, class Period, class Rep2&gt;
  duration&lt;typename common_type&lt;Rep1, Rep2&gt;::type, Period&gt;
  operator*(const duration&lt;Rep1, Period&gt;&amp; d, const Rep2&amp; s);
</pre>

<blockquote>
<i>Requires:</i> <del><tt>CR(Rep1, Rep2)</tt> shall exist.</del>
<ins><tt>Rep2</tt> shall be implicitly convertible to <tt>CR(Rep1, Rep2)</tt>.</ins>
Diagnostic required.
</blockquote>

<pre>template &lt;class Rep1, class Period, class Rep2&gt;
  duration&lt;typename common_type&lt;Rep1, Rep2&gt;::type, Period&gt;
  operator*(const Rep1&amp; s, const duration&lt;Rep2, Period&gt;&amp; d);
</pre>

<blockquote>
<i>Require<ins>s</ins><del>d behavior</del>:</i> <del><tt>CR(Rep1, Rep2)</tt> shall exist.</del>
<ins><tt>Rep1</tt> shall be implicitly convertible to <tt>CR(Rep1, Rep2)</tt>.</ins>
Diagnostic required.
</blockquote>

<pre>template &lt;class Rep1, class Period, class Rep2&gt;
  duration&lt;typename common_type&lt;Rep1, Rep2&gt;::type, Period&gt;
  operator/(const duration&lt;Rep1, Period&gt;&amp; d, const Rep2&amp; s);
</pre>

<blockquote>
<i>Requires:</i> <del><tt>CR(Rep1, Rep2)</tt> shall exist</del>
<ins><tt>Rep2</tt> shall be implicitly convertible to <tt>CR(Rep1, Rep2)</tt></ins>
and <tt>Rep2</tt> shall not
be an instantiation of <tt>duration</tt>. Diagnostic required.
</blockquote>

</blockquote>





<hr>
<h3><a name="883"></a>883. swap circular definition</h3>
<p><b>Section:</b> 23 [containers] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2008-09-10 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#containers">issues</a> in [containers].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Note in particular that Table 90 "Container Requirements" gives
semantics of <tt>a.swap(b)</tt> as <tt>swap(a,b)</tt>, yet for all
containers we define <tt>swap(a,b)</tt> to call <tt>a.swap(b)</tt> - a
circular definition.
</p>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
Robert to propose a resolution along the lines of "Postcondition: "a =
b, b = a" This will be a little tricky for the hash containers, since
they don't have <tt>operator==</tt>.
</blockquote>

<p><i>[
Post Summit Anthony Williams provided proposed wording.
]</i></p>


<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
Moved to Ready with minor edits (which have been made).
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
In table 80 in section 23.2.1 [container.requirements.general],
replace the postcondition of <tt>a.swap(b)</tt> with the following:
</p>

<blockquote>
<table border="1">
<caption>Table 80 -- Container requirements</caption>
<tbody><tr>
<th>Expression</th>
<th>Return type</th>
<th>Operational semantics</th>
<th>Assertion/note pre-/post-conidtion</th>
<th>Complexity</th>
</tr>
<tr>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
<tr>
<td><tt>a.swap(b);</tt></td>
<td><tt>void</tt></td>
<td>&nbsp;</td>
<td><del><tt>swap(a,b)</tt></del>
<ins>Exchange the contents of <tt>a</tt> and <tt>b</tt>.</ins></td>
<td>(Note A)</td>
</tr>
</tbody></table>
</blockquote>

<p>
Remove the reference to swap from the paragraph following the table.
</p>

<blockquote>
Notes: the algorithms <del><tt>swap()</tt>, </del><tt>equal()</tt> and
<tt>lexicographical_compare()</tt> are defined in Clause 25. ...
</blockquote>





<hr>
<h3><a name="884"></a>884. shared_ptr swap</h3>
<p><b>Section:</b> 20.9.10.2.4 [util.smartptr.shared.mod] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2008-09-15 <b>Last modified:</b> 2010-11-20</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<blockquote><pre>#include &lt;memory&gt;
#include &lt;cassert&gt;

struct A { };
struct B : A { };

int main()
{
    std::shared_ptr&lt;A&gt; pa(new A);
    std::shared_ptr&lt;B&gt; pb(new B);
    std::swap&lt;A&gt;(pa, pb);  // N.B. no argument deduction
    assert( pa.get() == pb.get() );
    return 0;
}
</pre></blockquote>

<p>
Is this behaviour correct (I believe it is) and if so, is it
unavoidable, or not worth worrying about?
</p>

<p>
This calls the lvalue/rvalue swap overload for <tt>shared_ptr</tt>:
</p>

<blockquote><pre>template&lt;class T&gt; void swap( shared_ptr&lt;T&gt; &amp; a, shared_ptr&lt;T&gt; &amp;&amp; b );
</pre></blockquote>

<p>
silently converting the second argument from <tt>shared_ptr&lt;B&gt;</tt> to
<tt>shared_ptr&lt;A&gt;</tt> and binding the rvalue ref to the produced temporary.
</p>

<p>
This is not, in my opinion, a <tt>shared_ptr</tt> problem; it is a general issue
with the rvalue swap overloads. Do we want to prevent this code from
compiling? If so, how?
</p>

<p>
Perhaps we should limit rvalue args to swap to those types that would
benefit from the "swap trick".  Or, since we now have <tt>shrink_to_fit()</tt>, just
eliminate the rvalue swap overloads altogether.  The original motivation
was:
</p>

<blockquote><pre>vector&lt;A&gt; v = ...;
...
swap(v, vector&lt;A&gt;(v));
</pre></blockquote>

<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1690.html#Improved%20swap%20Interface">N1690</a>.

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution.
Move to <del>NAD Editorial</del><ins>Resolved</ins>.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Recommend <del>NAD Editorial</del><ins>Resolved</ins>, fixed by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2844.html">N2844</a>.
</p>





<hr>
<h3><a name="885"></a>885. pair assignment</h3>
<p><b>Section:</b> 20.3.5 [pairs] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2008-09-15 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#pairs">issues</a> in [pairs].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<blockquote><pre>20.2.3 pairs
Missing assignemnt operator:
template&lt;class U , class V&gt;
  requires CopyAssignable&lt;T1, U&gt; &amp;&amp; CopyAssignable&lt;T2, V&gt;
    pair&amp; operator=(pair&lt;U , V&gt; const &amp; p );
</pre></blockquote>

<p>
Well, that's interesting. This assignment operator isn't in the
current working paper, either. Perhaps we deemed it acceptable to
build a temporary of type <tt>pair</tt> from <tt>pair&lt;U, V&gt;</tt>, then move-assign
from that temporary?
</p>
<p>
It sounds more like an issue waiting to be opened, unless you want to plug
it now.  As written we risk moving from lvalues.
</p>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
<p>
Would be NAD if better ctors fixed it.
</p>
<p>
Related to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#811">811</a>.
</p>
</blockquote>

<p><i>[
post San Francisco:
]</i></p>


<blockquote>
Possibly NAD Editorial, solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2770.pdf">N2770</a>.
</blockquote>

<p><i>[
2009-05-25 Alisdair adds:
]</i></p>


<blockquote>
Issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#885">885</a> was something I reported while reviewing the library concepts
documents ahead of San Francisco.  The missing operator was added as part of
the paper adopted at that meeting
(<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2770.pdf">N2770</a>)
and I can confirm this operator is
present in the current working paper.  I recommend NAD.
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
We agree with the intent, but we need to wait for the dust to settle on concepts.
</blockquote>

<p><i>[
2010-03-11 Stefanus provided wording.
]</i></p>


<p><i>[
2010 Pittsburgh:  Moved to Ready for Pittsburgh.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
Add the following declaration 20.3.5.2 [pairs.pair], before the
declaration of <tt>pair&amp; operator=(pair&amp;&amp; p);</tt>:
</p>
 
<blockquote><pre>template&lt;class U, class V&gt; pair&amp; operator=(const pair&lt;U, V&gt;&amp; p);
</pre></blockquote>

<p>
Add the following description to 20.3.5.2 [pairs.pair] after paragraph 11 (before
the description of <tt>pair&amp; operator=(pair&amp;&amp; p);)</tt>:
</p>
 
<blockquote><pre>template&lt;class U, class V&gt; pair&amp; operator=(const pair&lt;U, V&gt;&amp; p);
</pre>
<blockquote>
<p>
<i>Requires:</i> <tt>T1</tt> shall satisfy the requirements of
<tt>CopyAssignable</tt> from <tt>U</tt>. <tt>T2</tt> shall
satisfy the requirements of <tt>CopyAssignable</tt> from <tt>V</tt>.
</p>
<p>
<i>Effects:</i> Assigns <tt>p.first</tt> to <tt>first</tt> and 
<tt>p.second</tt> to <tt>second</tt>.
</p>
<p>
<i>Returns:</i> <tt>*this</tt>.
</p>
</blockquote>
</blockquote>






<hr>
<h3><a name="886"></a>886. tuple construction</h3>
<p><b>Section:</b> 20.4.2.1 [tuple.cnstr] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2008-09-15 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#tuple.cnstr">issues</a> in [tuple.cnstr].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
20.4.2.1 [tuple.cnstr]:
</p>
<blockquote>
<i>Effects:</i> Default initializes each element.
</blockquote>

<p>
Could be clarified to state each "non-trivial" element.  Otherwise
we have a conflict with Core deinfition of default initialization -
trivial types do not get initialized (rather than initialization
having no effect)
</p>

<p>
I'm going to punt on this one, because it's not an issue that's
related to concepts. I suggest bringing it to Howard's attention on
the reflector.
</p>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
<p>
Text in draft doesn't mean anything, changing to "non-trivial" makes it
meaningful.
</p>
<p>
We prefer "value initializes". Present implementations use
value-initialization. Users who don't want value initialization have
alternatives.
</p>
<p>
Request resolution text from Alisdair.
</p>

<p>
This issue relates to Issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#868">868</a> default construction and value-initialization.
</p>
</blockquote>

<p><i>[
2009-05-04 Alisdair provided wording and adds:
]</i></p>


<blockquote>
<p>
Note: This <em>IS</em> a change of semantic from TR1, although one the room agreed
with during the discussion.  To preserve TR1 semantics, this would have been
worded:
</p>
<blockquote><pre>requires DefaultConstructible&lt;Types&gt;... tuple();
</pre>
<blockquote>
-2-   <i>Effects:</i> Default-initializes each non-trivial element.
</blockquote>
</blockquote>


</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
Move to Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change p2 in Construction 20.4.2.1 [tuple.cnstr]:
</p>

<blockquote><pre>requires DefaultConstructible&lt;Types&gt;... tuple();
</pre>
<blockquote>
<p>
-2- <i>Effects:</i> <del>Default</del> <ins>Value-</ins>initializes each element.
</p>
</blockquote>
</blockquote>






<hr>
<h3><a name="888"></a>888. this_thread::yield too strong</h3>
<p><b>Section:</b> 30.3.2 [thread.thread.this] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Lawrence Crowl <b>Opened:</b> 2008-09-15 <b>Last modified:</b> 2010-10-29</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#thread.thread.this">active issues</a> in [thread.thread.this].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.thread.this">issues</a> in [thread.thread.this].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I never thought I'd say this, but <tt>this_thread::yield</tt> seems to be too
strong in specification.  The issue is that some systems distinguish
between yielding to another thread in the same process and yielding
to another process.  Given that the C++ standard only talks about
a single program, one can infer that the specification allows yielding
only to another thread within the same program.  Posix has no
facility for that behavior.  Can you please file an issue to weaken
the wording.  Perhaps "Offers the operating system the opportunity
to reschedule."
</p>

<p><i>[
Post Summit:
]</i></p>


<blockquote>
Recommend move to Tentatively Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 30.3.2 [thread.thread.this]/3:
</p>

<blockquote>
<pre>void this_thread::yield();
</pre>
<blockquote>
<i>Effects:</i> Offers the <del>operating system</del> <ins>implementation</ins>
the opportunity to <ins>re</ins>schedule.
<del>another thread.</del>
</blockquote>
</blockquote>





<hr>
<h3><a name="890"></a>890. Improving <tt>&lt;system_error&gt;</tt> initialization</h3>
<p><b>Section:</b> 19.5.1 [syserr.errcat] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Beman Dawes <b>Opened:</b> 2008-09-14 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <tt>static const error_category</tt> objects <tt>generic_category</tt> and
<tt>system_category</tt> in header <tt>&lt;system_error&gt;</tt> are currently declared:
</p>

<blockquote><pre>const error_category&amp; get_generic_category();
const error_category&amp; get_system_category();

static const error_category&amp; generic_category = get_generic_category();
static const error_category&amp; system_category = get_system_category();
</pre></blockquote>

<p>
This formulation has several problems:
</p>

<ul>
<li>
Implementation details are exposed, since initialization is specified in
the interface. This over-constrains implementations without offsetting
user benefits. The form of initialization specified may be less than
maximally efficient on some platforms.
</li>
<li>
Use of the objects is more expensive in terms of number of machine level
instructions. See <i>Implementation experience</i> below.
</li>
<li>
Depending on the compiler, some cost may be incurred by each translation unit
that includes the header, even if the objects are not used. This is a
common scenario in user code, since the header is included by other
standard library headers. It should be mentioned that at least one
compilers is able to optimize this cost away, however.
</li>
</ul>

<p>
IO streams uses a somewhat different formulation for iostream_category, but 
still suffer much the same problems.
</p>

<p>
The original plan was to eliminate these problems by applying the C++0x
<tt>constexpr</tt> feature. See LWG issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#832">832</a>. However, that approach turned out
to be unimplementable, since it would require a <tt>constexpr</tt> object of a
class with virtual functions, and that is not allowed by the core
language.
</p>

<p>
The proposed resolution was developed as an alternative. It mitigates the above 
problems by removing initialization from the visible interface, allowing 
implementations flexibility.
</p>

<p>
<b>Implementation experience:</b>
</p>

<p>
Prototype implementations of the current WP interface and proposed
resolution interface were tested with recent Codegear, GCC, Intel, and Microsoft 
compilers on Windows. The code generated by the Microsoft compiler was studied 
at length; the WP and proposal versions generated very similar code. For both versions 
the compiler did make use of static
initialization; apparently the compiler applied an implicit <tt>constexpr</tt>
where useful, even in cases where <tt>constexpr</tt> would not be permitted by
the language!
</p>

<p>
<b>Acknowledgements:</b>
</p>

<p>
Martin Sebor, Chris Kohlhoff, and John Lakos provided useful ideas and comments on initialization issues.
</p>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
<p>
Martin: prefers not to create more file-scope static objects, and would
like to see <tt>get_*</tt> functions instead.
</p>
</blockquote>


<p><i>[Pre-Summit:]</i></p>

<blockquote>


<p>
Beman: The proposed resolution has been reworked to remove the file-scope 
static objects, per Martin's suggestions. The <tt>get_</tt> prefix has been 
eliminated from the function names as no longer necessary and to conform with 
standard library naming practice.
</p>

</blockquote>

<p><i>[
Post Summit:
]</i></p>


<blockquote>
Agreement that this is wise and essential, text provided works and has
been implemented. Seems to be widespread consensus. Move to Tentative Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>

<p>Change 17.6.4.14 [value.error.codes] Value of error codes as indicated:</p>
<blockquote>
 <p>Certain functions in the C++ standard library report errors via a 
 <tt>std::error_code</tt> (19.4.2.2) object. That object's <tt>category()</tt> member shall 
 return <del>a reference to</del> <code>std::system_category</code><tt><ins><code>()</code></ins></tt> for errors originating from the 
 operating system, or a reference to an implementation-defined error_category 
 object for errors originating elsewhere. The implementation shall define the 
 possible values of value() for each of these error categories. [<i>Example:</i> For 
 operating systems that are based on POSIX, implementations are encouraged to 
 define the <code>std::system_category</code><tt><ins><code>()</code></ins></tt> values as identical to the POSIX <tt>errno</tt> values, 
 with additional values as defined by the operating system's documentation. 
 Implementations for operating systems that are not based on POSIX are 
 encouraged to define values identical to the operating system's values. For 
 errors that do not originate from the operating system, the implementation may 
 provide enums for the associated values --<i>end example</i>]</p>
</blockquote>

<p>
Change 19.5.1.1 [syserr.errcat.overview] Class <tt>error_category</tt> overview
<tt>error_category</tt> synopsis as indicated:
</p>

<blockquote>
<pre>const error_category&amp; <del>get_</del>generic_category();
const error_category&amp; <del>get_</del>system_category();

<del>static storage-class-specifier const error_category&amp; generic_category = get_generic_category();
static storage-class-specifier const error_category&amp; system_category = get_system_category();</del>
</pre>
</blockquote>

<p>
Change 19.5.1.5 [syserr.errcat.objects] Error category objects as indicated:
</p>

<blockquote>
<pre>const error_category&amp; <del>get_</del>generic_category();
</pre>

<blockquote>

<p>
<i>Returns:</i> A reference to an object of a type derived from class <tt>error_category</tt>.
</p>

<p>
<i>Remarks:</i> The object's <tt>default_error_condition</tt> and <tt>equivalent</tt> virtual
functions shall behave as specified for the class <tt>error_category</tt>. The
object's <tt>name</tt> virtual function shall return a pointer to the string
<tt>"GENERIC"</tt>.
</p>
</blockquote>

<pre>const error_category&amp; <del>get_</del>system_category();
</pre>

<blockquote>
<p>
<i>Returns:</i> A reference to an object of a type derived from class <tt>error_category</tt>.
</p>

<p>
<i>Remarks:</i> The object's <tt>equivalent</tt> virtual functions shall behave as
specified for class <tt>error_category</tt>. The object's <tt>name</tt> virtual function
shall return a pointer to the string <tt>"system"</tt>. The object's
<tt>default_error_condition</tt> virtual function shall behave as follows:
</p>
<blockquote>
If the argument <tt>ev</tt> corresponds to a POSIX <tt>errno</tt> value <tt>posv</tt>, the function
shall return <tt>error_condition(posv, generic_category<ins>()</ins>)</tt>. Otherwise, the
function shall return <tt>error_condition(ev, system_category<ins>()</ins>)</tt>. What
constitutes correspondence for any given operating system is
unspecified. [<i>Note:</i> The number of potential system error codes is large
and unbounded, and some may not correspond to any POSIX <tt>errno</tt> value.
Thus implementations are given latitude in determining correspondence.
<i>-- end note</i>]
</blockquote>
</blockquote>

</blockquote>

<p>Change 19.5.2.2 [syserr.errcode.constructors] Class error_code constructors 
as indicated:</p>
<blockquote>
 <pre>error_code();</pre>
 <blockquote>
 <p><i>Effects:</i> Constructs an object of type error_code.</p>
 <p><i>Postconditions:</i> <code>val_ == 0 </code>and <code>cat_ == &amp;system_category</code><tt><ins>()</ins></tt>.</p>
 </blockquote>
</blockquote>
<p>Change 19.5.2.3 [syserr.errcode.modifiers] Class error_code modifiers as 
indicated:</p>
<blockquote>
 <pre>void clear();</pre>
 <blockquote>
 <p>Postconditions: <code>value() == 0</code> and <code>category() == 
 system_category</code><tt><ins>()</ins></tt>.</p>
 </blockquote>
</blockquote>
<p>Change 19.5.2.5 [syserr.errcode.nonmembers] Class error_code non-member 
functions as indicated:</p>
<blockquote>
 <pre>error_code make_error_code(errc e);</pre>
 <blockquote>
 <p><i>Returns:</i> <code>error_code(static_cast&lt;int&gt;(e), generic_category</code><tt><ins>()</ins></tt><code>)</code>.</p>
 </blockquote>
</blockquote>
<p>Change 19.5.3.2 [syserr.errcondition.constructors] Class error_condition 
constructors as indicated:</p>
<blockquote>
 <pre>error_condition();</pre>
 <blockquote>
 <p><i>Effects:</i> Constructs an object of type <code>error_condition</code>.</p>
 <p><i>Postconditions:</i> <code>val_ == 0</code> and <code>cat_ == &amp;generic_category</code><tt><ins>()</ins></tt>.</p>
 </blockquote>
</blockquote>
<p>Change 19.5.3.3 [syserr.errcondition.modifiers] Class error_condition 
modifiers as indicated:</p>
<blockquote>
 <pre>void clear();</pre>
 <blockquote>
 <p><i>Postconditions:</i> <code>value() == 0</code> and <code>category() == 
 generic_category</code><tt><ins>()</ins></tt>.</p>
 </blockquote>
</blockquote>
<p>Change 19.5.3.5 [syserr.errcondition.nonmembers] Class error_condition 
non-member functions as indicated:</p>
<blockquote>
 <pre>error_condition make_error_condition(errc e);</pre>
 <blockquote>
 <p><i>Returns:</i> <tt>error_condition(static_cast&lt;int&gt;(e), generic_category<ins>()</ins>)</tt>.</p>
 </blockquote>
</blockquote>
 <p>Change 27.5 [iostreams.base] Iostreams base classes, Header &lt;ios&gt; 
 synopsis as indicated:</p>
<blockquote>
 <pre>concept_map ErrorCodeEnum&lt;io_errc&gt; { };
error_code make_error_code(io_errc e);
error_condition make_error_condition(io_errc e);
<del>storage-class-specifier</del> const error_category&amp; iostream_category<ins>()</ins>;</pre>
</blockquote>
<p>Change 27.5.2.1.1 [ios::failure] Class ios_base::failure, paragraph 2 as 
indicated:</p>
<blockquote>
<p>When throwing ios_base::failure exceptions, implementations should provide 
values of ec that identify the specific reason for the failure. [ Note: Errors 
arising from the operating system would typically be reported as <tt>
system_category</tt><tt><ins>()</ins></tt> errors with an error value of the 
error number reported by the operating system. Errors arising from within the 
stream library would typically be reported as <tt>error_code(io_errc::stream, 
iostream_category<ins>()</ins>)</tt>. --end note ]</p>
</blockquote>
<p>Change 27.5.5.5 [error.reporting] Error reporting as indicated:</p>
<blockquote>
 <pre>error_code make_error_code(io_errc e);</pre>
 <blockquote>
 <p><i>Returns:</i> <code>error_code(static_cast&lt;int&gt;(e), iostream_category</code><ins>()</ins><code>)</code>.</p>
 </blockquote>
 <pre>error_condition make_error_condition(io_errc e);</pre>
 <blockquote>
 <p><i>Returns:</i> <code>error_condition(static_cast&lt;int&gt;(e), 
 iostream_category</code><ins>()</ins><code>)</code>.</p>
 </blockquote>
 <pre><del>storage-class-specifier</del> const error_category&amp; iostream_category<ins>()</ins>;</pre>
 <blockquote>
 <del><p>The implementation shall initialize iostream_category. Its storage-class-specifier 
 may be static or extern. It is unspecified whether initialization is static 
 or dynamic (3.6.2). If initialization is dynamic, it shall occur before 
 completion of the dynamic initialization of the first translation unit 
 dynamically initialized that includes header &lt;system_error&gt;.</p></del>
<p>
<ins><i>Returns:</i> A reference to an object of a type derived from class <tt>error_category</tt>.</ins>
</p>
<p><i>Remarks:</i> The object's default_error_condition and equivalent virtual functions shall 
behave as specified for the class error_category. The object's name virtual 
function shall return a pointer to the string "iostream".</p>
 </blockquote>
</blockquote>







<hr>
<h3><a name="891"></a>891. std::thread, std::call_once issue</h3>
<p><b>Section:</b> 30.3.1.2 [thread.thread.constr], 30.4.4.2 [thread.once.callonce] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Peter Dimov <b>Opened:</b> 2008-09-15 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.thread.constr">issues</a> in [thread.thread.constr].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I notice that the vararg overloads of <tt>std::thread</tt> and <tt>std::call_once</tt>
(N2723 30.3.1.2 [thread.thread.constr] and 30.4.4.2 [thread.once.callonce]) are no longer specified in terms of
<tt>std::bind</tt>; instead, some of the <tt>std::bind</tt> wording has been inlined into
the specification.
</p>
<p>
There are two problems with this.
</p>
<p>
First, the specification (and implementation) in terms of <tt>std::bind</tt> allows, for example:
</p>

<blockquote><pre>std::thread th( f, 1, std::bind( g ) );
</pre></blockquote>

<p>
which executes <tt>f( 1, g() )</tt> in a thread. This can be useful. The
"inlined" formulation changes it to execute <tt>f( 1, bind(g) )</tt> in a thread.
</p>
<p>
Second, assuming that we don't want the above, the specification has copied the wording
</p>

<blockquote>
<tt>INVOKE(func, w1, w2, ..., wN)</tt> (20.6.2) shall be a valid
expression for some values <tt>w1, w2, ..., wN</tt>
</blockquote>

<p>
but this is not needed since we know that our argument list is args; it should simply be
</p>

<blockquote>
<tt>INVOKE(func, args...)</tt> (20.6.2) shall be a valid expression
</blockquote>

<p><i>[
Summit:
]</i></p>


<blockquote>
Move to open.
</blockquote>

<p><i>[
Post Summit Anthony provided proposed wording.
]</i></p>


<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
Leave Open. Await decision for thread variadic constructor.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
See proposed wording for <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#929">929</a> for this, for the formulation
on how to solve this.  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#929">929</a> modifies the thread constructor to
have "pass by value" behavior with pass by reference efficiency through the use
of the <tt>decay</tt> trait.  This same formula would be useful for <tt>call_once</tt>.
</blockquote>

<p><i>[
2010-02-11 Anthony updates wording.
]</i></p>


<p><i>[
2010-02-12 Moved to Tentatively Ready after 5 postive votes on c++std-lib.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
Modify 30.4.4.2 [thread.once.callonce] p1-p2 with the following:
</p>

<blockquote>
<pre>template&lt;class Callable, class ...Args&gt;
  void call_once(once_flag&amp; flag, Callable<ins>&amp;&amp;</ins> func, Args&amp;&amp;... args);</pre>
<blockquote>

<p><ins>
Given a function as follows:
</ins></p>

<blockquote><pre><ins>
template&lt;typename T&gt; typename decay&lt;T&gt;::type decay_copy(T&amp;&amp; v)
   { return std::forward&lt;T&gt;(v); }
</ins></pre></blockquote>

<p>
1 <i>Requires:</i> <del>The template parameters</del> <tt>Callable</tt> and each
<tt>Ti</tt> in <tt>Args</tt> shall <del>be <tt>CopyConstructible</tt> if an
lvalue and otherwise</del> <ins>satisfy the</ins>
<tt>MoveConstructible</tt> <ins>requirements</ins>.
<tt><i>INVOKE</i>(<ins>decay_copy(std::forward&lt;Callable&gt;(</ins>func<ins>)</ins>,
<del>w1, w2, ..., wN</del>
<ins>decay_copy(std::forward&lt;Args&gt;(args))...</ins>)</tt> (20.8.2 [func.require]) shall be a valid expression<del> for some values <tt>w1,
w2, ..., wN</tt>, where <tt>N == sizeof...(Args)</tt></del>.
</p>

<p>
2 <i>Effects:</i> Calls to <tt>call_once</tt> on the same <tt>once_flag</tt>
object are serialized. If there has been a prior effective call to
<tt>call_once</tt> on the same <tt>once_flag</tt> object, the call to
<tt>call_once</tt> returns without invoking <tt>func</tt>. If there has been no
prior effective call to <tt>call_once</tt> on the same <tt>once_flag</tt>
object, <del>the argument <tt>func</tt> (or a copy thereof) is called as if by
invoking <tt>func(args)</tt></del>
<ins><tt><i>INVOKE</i>(decay_copy(std::forward&lt;Callable&gt;(func)),
decay_copy(std::forward&lt;Args&gt;(args))...)</tt> is executed</ins>. The call
to <tt>call_once</tt> is effective if and only if <del><tt>func(args)</tt></del>
<ins><tt><i>INVOKE</i>(decay_copy(std::forward&lt;Callable&gt;(func)),
decay_copy(std::forward&lt;Args&gt;(args))...)</tt></ins> returns without
throwing an exception. If an exception is thrown it is propagated to the caller.
</p>

</blockquote>

</blockquote>







<hr>
<h3><a name="893"></a>893. std::mutex issue</h3>
<p><b>Section:</b> 30.4.1.2.1 [thread.mutex.class] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Peter Dimov <b>Opened:</b> 2008-09-15 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.mutex.class">issues</a> in [thread.mutex.class].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#905">905</a></p>
<p><b>Discussion:</b></p>
<p>
30.4.1.2.1 [thread.mutex.class]/27 (in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2723.pdf">N2723</a>)
says that the behavior is undefined if:
</p>
<ul>
<li>a thread that owns a <tt>mutex</tt> object calls <tt>lock()</tt> or
<tt>try_lock()</tt> on that object</li>
</ul>
<p>
I don't believe that this is right. Calling <tt>lock()</tt> or <tt>try_lock()</tt> on a
locked <tt>mutex</tt> is well defined in the general case. <tt>try_lock()</tt> is required
to fail and return <tt>false</tt>. <tt>lock()</tt> is required to either throw an
exception (and is allowed to do so if it detects deadlock) or to block
until the <tt>mutex</tt> is free. These general requirements apply regardless of
the current owner of the <tt>mutex</tt>; they should apply even if it's owned by
the current thread.
</p>
<p>
Making double <tt>lock()</tt> undefined behavior probably can be justified (even
though I'd still disagree with the justification), but <tt>try_lock()</tt> on a
locked <tt>mutex</tt> must fail.
</p>

<p><i>[
Summit:
]</i></p>

<blockquote>
<p>
Move to open. Proposed resolution:
</p>
<ul>
<li>
In 30.4.1 [thread.mutex.requirements] paragraph 12, change the error
condition for <tt>resource_deadlock_would_occur</tt> to: "if the implementation
detects that a deadlock would occur"
</li>
<li>
Strike 30.4.1.2.1 [thread.mutex.class] paragraph 3 bullet 2 "a thread that owns a mutex object
calls <tt>lock()</tt> or <tt>try_lock()</tt> on that object, or"
</li>
</ul>
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
Move to Review. Alisdair to provide note.
</blockquote>

<p><i>[
2009-07-31 Alisdair provided note.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Moved to Ready.
</blockquote>

<p><i>[
2009-11-18 Peter Opens:
]</i></p>


<blockquote>
<p>
I don't believe that the proposed note:
</p>

<blockquote>
[<i>Note:</i> a program may deadlock if the thread that owns a <tt>mutex</tt>
object calls <tt>lock()</tt> or <tt>try_lock()</tt> on that object. If the program can
detect the deadlock, a <tt>resource_deadlock_would_occur</tt> error condition may
be observed.  <i>end note</i>]
</blockquote>

<p>
is entirely correct. "or <tt>try_lock()</tt>" should be removed, because
<tt>try_lock</tt> is non-blocking and doesn't deadlock; it just returns
<tt>false</tt> when it fails to lock the mutex.
</p>

<p><i>[
Howard: I've set to Open and updated the wording per Peter's suggestion.
]</i></p>


</blockquote>

<p><i>[
2009-11-18 Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
In 30.4.1 [thread.mutex.requirements] paragraph 12 change:
</p>

<blockquote>
<ul>
<li>...</li>
<li>
<tt>resource_deadlock_would_occur</tt> -- if the <del>current thread already owns the mutex and is able 
to detect it</del> <ins>implementation detects that a deadlock would occur</ins>.
</li>
<li>...</li>
</ul>
</blockquote>

<p>
Strike 30.4.1.2.1 [thread.mutex.class] paragraph 3 bullet 2:
</p>
<blockquote>
<p>
-3- The behavior of a program is undefined if:
</p>
<ul>
<li>...</li>
<li>
<del>a thread that owns a <tt>mutex</tt> object calls <tt>lock()</tt> or <tt>try_lock()</tt> on that object, or</del>
</li>
<li>...</li>
</ul>
</blockquote>

<p>
Add the following note after p3 30.4.1.2.1 [thread.mutex.class]
</p>

<blockquote>
[<i>Note:</i> a program may deadlock if the thread that owns a <tt>mutex</tt>
object calls <tt>lock()</tt> on that object. If the implementation can detect the
deadlock, a <tt>resource_deadlock_would_occur</tt> error condition may be
observed.  <i>end note</i>]
</blockquote>






<hr>
<h3><a name="894"></a>894. longjmp and destructors</h3>
<p><b>Section:</b> 18.10 [support.runtime] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Lawrence Crowl, Alisdair Meredith <b>Opened:</b> 2008-09-17 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#support.runtime">issues</a> in [support.runtime].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The interaction between <tt>longjmp</tt> and exceptions seems unnecessarily
restrictive and not in keeping with existing practice.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Edit paragraph 4 of 18.10 [support.runtime] as follows:
</p>

<blockquote>
The function signature <tt>longjmp(jmp_buf jbuf, int val)</tt> has more
restricted behavior in this International Standard. A
<tt>setjmp/longjmp</tt> call pair has undefined behavior if replacing the
<tt>setjmp</tt> and <tt>longjmp</tt> by <tt>catch</tt> and
<tt>throw</tt> would <del>destroy</del>
<ins>invoke any non-trivial destructors for</ins>
any automatic objects.
</blockquote>





<hr>
<h3><a name="896"></a>896. Library thread safety issue</h3>
<p><b>Section:</b> 20.9.10.2 [util.smartptr.shared] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Hans Boehm <b>Opened:</b> 2008-09-16 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#util.smartptr.shared">issues</a> in [util.smartptr.shared].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It is unclear whether <tt>shared_ptr</tt> is thread-safe in the sense that
multiple threads may simultaneously copy a <tt>shared_ptr</tt>.  However this
is a critical piece of information for the client, and it has significant
impact on usability for many applications.  (Detlef Vollman thinks it
is currently clear that it is not thread-safe.  Hans Boehm thinks
it currently requires thread safety, since the <tt>use_count</tt> is not an
explicit field, and constructors and assignment take a const reference
to an existing <tt>shared_ptr</tt>.)
</p>

<p>
Pro thread-safety:
</p>
<p>
Many multi-threaded usages are impossible.  A thread-safe version can
be used to destroy an object when the last thread drops it, something
that is often required, and for which we have no other easy mechanism.
</p>
<p>
Against thread-safety:
</p>
<p>
The thread-safe version is well-known to be far more expensive, even
if used by a single thread.  Many applications, including all single-threaded
ones, do not care.
</p>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
<p>
Beman: this is a complicated issue, and would like to move this to Open
and await comment from Peter Dimov; we need very careful and complete
rationale for any decision we make; let's go slow
</p>
<p>
Detlef: I think that <tt>shared_ptr</tt> should not be thread-safe.
</p>
<p>
Hans: When you create a thread with a lambda, it in some cases makes it
very difficult for the lambda to reference anything in the heap. It's
currently ambiguous as to whether you can use a <tt>shared_ptr</tt> to get at an
object.
</p>
<p>
Leave in Open. Detlef will submit an alternative proposed resolution
that makes <tt>shared_ptr</tt> explicitly unsafe.
</p>
<p>
A third option is to support both threadsafe and non-safe share_ptrs,
and to let the programmer decide which behavior they want.
</p>

<p>
Beman:  Peter, do you support the PR?
</p>

<p>
Peter:
</p>
<blockquote>
<p>
Yes, I support the proposed resolution, and I certainly oppose any
attempts to <tt>make shared_ptr</tt> thread-unsafe.
</p>
<p>
I'd mildly prefer if
</p>
<blockquote>
[<i>Note:</i> This is true in spite of that fact that such functions often
modify <tt>use_count()</tt> <i>--end note</i>]
</blockquote>
<p>
is changed to
</p>
<blockquote>
[<i>Note:</i> This is true in spite of that fact that such functions often
cause a change in <tt>use_count()</tt> <i>--end note</i>]
</blockquote>
<p>
(or something along these lines) to emphasise that <tt>use_count()</tt> is not,
conceptually, a variable, but a return value.
</p>
</blockquote>

</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
Vote: Do we want one thread-safe shared pointer or two? If two, one
would allow concurrent construction and destruction of shared pointers,
and one would not be thread-safe. If one, then it would be thread-safe.
</p>
<p>
No concensus on that vote.
</p>
<p>
Hans to improve wording in consultation with Pete. Leave Open.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Move to Ready. Ask Editor to clear up wording a little when integrating to
make it clear that the portion after the first comma only applies for
the presence of data races.
</blockquote>

<p><i>[
2009-10-24 Hans adds:
]</i></p>


<blockquote>
<p>
I think we need to pull 896 back from ready, unfortunately.  My wording
doesn't say the right thing.
</p>

<p>
I suspect we really want to say something along the lines of:
</p>

<blockquote>
For purposes of determining the presence of a data race, member
functions access and modify only the <tt>shared_ptr</tt> and
<tt>weak_ptr</tt> objects themselves and not objects they refer to.
Changes in <tt>use_count()</tt> do not reflect modifications that can
introduce data races.
</blockquote>

<p>
But I think this needs further discussion by experts to make sure this
is right.
</p>

<p>
Detlef and I agree continue to disagree on the resolution, but I think
we agree that it would be good to try to expedite this so that it can be
in CD2, since it's likely to generate NB comments no matter what we do.
And lack of clarity of intent is probably the worst option.  I think it
would be good to look at this between meetings.
</p>
</blockquote>

<p><i>[
2010-01-20 Howard:
]</i></p>


<blockquote>
<p>
I've moved Hans' suggested wording above into the proposed resolution section
and preserved the previous wording here:
</p>

<blockquote>
<p>
Make it explicitly thread-safe, in this weak sense, as I believe was intended:
</p>
<p>
Insert in 20.9.10.2 [util.smartptr.shared], before p5:
</p>
<blockquote>
<p>
For purposes of determining the presence of a data race,
member functions do not modify <tt>const shared_ptr</tt> and
const <tt>weak_ptr</tt> arguments, nor any objects they
refer to.  [<i>Note:</i> This is true in spite of that fact that such functions often
cause a change in <tt>use_count()</tt> <i>--end note</i>]
</p>
</blockquote>
<p>
On looking at the text, I'm not sure we need a similar disclaimer
anywhere else, since nothing else has the problem with the modified
<tt>use_count()</tt>.  I think Howard arrived at a similar conclusion.
</p>
</blockquote>
</blockquote>

<p><i>[
2010 Pittsburgh:  Moved to Ready for Pittsburgh
]</i></p>




<p><b>Proposed resolution:</b></p>

<p>
Insert a new paragraph at the end of 20.9.10.2 [util.smartptr.shared]:
</p>

<blockquote>
For purposes of determining the presence of a data race, member functions access
and modify only the <tt>shared_ptr</tt> and <tt>weak_ptr</tt> objects themselves
and not objects they refer to. Changes in <tt>use_count()</tt> do not reflect
modifications that can introduce data races.
</blockquote>





<hr>
<h3><a name="898"></a>898. Small contradiction in n2723 to forward to committee</h3>
<p><b>Section:</b> 23.3.3.5 [forwardlist.ops] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Arch Robison <b>Opened:</b> 2008-09-08 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#forwardlist.ops">issues</a> in [forwardlist.ops].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I ran across a small contradiction in working draft n2723. 
</p>
<blockquote>
<p>
23.3.3 [forwardlist]p2: A <tt>forward_list</tt> satisfies all of the
requirements of a container (table 90), except that the <tt>size()</tt> member
function is not provided.
</p>
<p>
23.3.3.5 [forwardlist.ops]p57: <i>Complexity:</i> At most <tt>size() + x.size() - 1</tt>
comparisons.
</p>
</blockquote>
<p>
Presumably 23.3.3.5 [forwardlist.ops]p57 needs to be rephrased to not use
<tt>size()</tt>, or note that it is used there only for sake of notational convenience. 
</p>

<p><i>[
2009-03-29 Beman provided proposed wording.
]</i></p>


<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We agree with the proposed resolution.
</p>
<p>
Move to Tentatively Ready.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p><i>Change 23.3.3.5 [forwardlist.ops],
forward_list operations, paragraph 19, merge complexity as indicated:
</i></p>
<blockquote><i>Complexity:</i> At most <tt><del>size() + x.size()</del>
<ins>distance(begin(), end()) + distance(x.begin(), x.end())</ins> - 1</tt>
comparisons.
</blockquote>





<hr>
<h3><a name="899"></a>899. Adjusting <tt>shared_ptr</tt> for <tt>nullptr_t</tt></h3>
<p><b>Section:</b> 20.9.10.2.2 [util.smartptr.shared.dest] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Peter Dimov <b>Opened:</b> 2008-09-18 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#util.smartptr.shared.dest">issues</a> in [util.smartptr.shared.dest].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
James Dennett, message c++std-lib-22442:
</p>
<blockquote>
The wording below addresses one case of this, but opening an
issue to address the need to sanity check uses of the term "pointer"
in 20.9.10.2 [util.smartptr.shared] would be a good thing.
</blockquote>
<p>
There's one more reference, in <tt>~shared_ptr;</tt> we can apply your suggested change to it, too. That is:
</p>
<p>
Change 20.9.10.2.2 [util.smartptr.shared.dest]/1 second bullet from:
</p>
<blockquote>
Otherwise, if *this owns a pointer p and a deleter d, d(p) is called.
</blockquote>
<p>
to:
</p>
<blockquote>
Otherwise, if *this owns an object p and a deleter d, d(p) is called.
</blockquote>

<p><i>[
Post Summit:
]</i></p>


<blockquote>
Recommend Review.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Peter Dimov notes the analogous change has already been made
to "the new nullptr_t taking constructors
in 20.9.10.2.1 [util.smartptr.shared.const] p9-13."
</p>
<p>
We agree with the proposed resolution.
Move to Tentatively Ready.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 20.9.10.2.2 [util.smartptr.shared.dest]/1 second bullet:
</p>
<blockquote>
<ul>
<li>...</li>
<li>
Otherwise, if <tt>*this</tt> <i>owns</i> <del>a pointer</del>
<ins>an object</ins> <tt>p</tt> and a
deleter <tt>d</tt>, <tt>d(p)</tt> is called.
</li>
</ul>
</blockquote>





<hr>
<h3><a name="900"></a>900. stream move-assignment</h3>
<p><b>Section:</b> 27.9.1.8 [ifstream.assign] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Niels Dekker <b>Opened:</b> 2008-09-20 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It
appears that we have an issue similar to issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#675">675</a> regarding the move-assignment of
stream types. For example, when assigning to an <tt>std::ifstream</tt>,
<tt>ifstream1</tt>, it seems preferable to close the file originally held by
<tt>ifstream1</tt>:
</p>

<blockquote><pre>ifstream1 = std::move(ifstream2); 
</pre></blockquote>

<p>
The current Draft
(<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2723.pdf">N2723</a>)
specifies that the move-assignment of
stream types like <tt>ifstream</tt> has the same effect as a swap:
</p>

<blockquote>
<p>
Assign and swap 27.9.1.8 [ifstream.assign]
</p>
<pre>basic_ifstream&amp; operator=(basic_ifstream&amp;&amp; rhs); 
</pre>
<blockquote>
<i>Effects:</i> <tt>swap(rhs)</tt>.
</blockquote>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Howard agrees with the analysis and the direction proposed.
</p>
<p>
Move to Open pending specific wording to be supplied by Howard.
</p>
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
Howard is going to write wording.
</blockquote>

<p><i>[
2009-07-26 Howard provided wording.
]</i></p>


<p><i>[
2009-09-13 Niels adds:
]</i></p>


<blockquote>
Note: The proposed change of 27.9.1.3 [filebuf.assign]/1 depends on the
resolution of LWG <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1204">1204</a>, which allows implementations to assume that
<tt>*this</tt> and <tt>rhs</tt> refer to different objects.
</blockquote>

<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote>
Leave as Open.  Too closely related to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#911">911</a> to move on at this time.
</blockquote>

<p><i>[
2010 Pittsburgh:
]</i></p>


<blockquote>
Moved to Ready for Pittsburgh.
</blockquote>



<p><b>Proposed resolution:</b></p>

<p>
Change 27.8.1.2 [stringbuf.assign]/1:
</p>

<blockquote><pre>basic_stringbuf&amp; operator=(basic_stringbuf&amp;&amp; rhs);
</pre>
<blockquote>
-1- <i>Effects:</i> <del><tt>swap(rhs)</tt>.</del>
<ins>After the move assignment <tt>*this</tt> reflects the same observable
state it would have if it had been move constructed from <tt>rhs</tt>
(27.8.1.1 [stringbuf.cons]).
</ins>
</blockquote>
</blockquote>

<p>
Change 27.8.2.2 [istringstream.assign]/1:
</p>

<blockquote><pre>basic_istringstream&amp; operator=(basic_istringstream&amp;&amp; rhs);
</pre>
<blockquote>
-1- <i>Effects:</i> <del><tt>swap(rhs)</tt>.</del>
<ins>Move assigns the base and members of <tt>*this</tt> with the respective
base and members of <tt>rhs</tt>.
</ins>
</blockquote>
</blockquote>

<p>
Change 27.8.3.2 [ostringstream.assign]/1:
</p>

<blockquote><pre>basic_ostringstream&amp; operator=(basic_ostringstream&amp;&amp; rhs);
</pre>
<blockquote>
-1- <i>Effects:</i> <del><tt>swap(rhs)</tt>.</del>
<ins>Move assigns the base and members of <tt>*this</tt> with the respective
base and members of <tt>rhs</tt>.
</ins>
</blockquote>
</blockquote>

<p>
Change 27.8.5.1 [stringstream.assign]/1:
</p>

<blockquote><pre>basic_stringstream&amp; operator=(basic_stringstream&amp;&amp; rhs);
</pre>
<blockquote>
-1- <i>Effects:</i> <del><tt>swap(rhs)</tt>.</del>
<ins>Move assigns the base and members of <tt>*this</tt> with the respective
base and members of <tt>rhs</tt>.
</ins>
</blockquote>
</blockquote>

<p>
Change 27.9.1.3 [filebuf.assign]/1:
</p>

<blockquote><pre>basic_filebuf&amp; operator=(basic_filebuf&amp;&amp; rhs);
</pre>
<blockquote>
-1- <i>Effects:</i> <del><tt>swap(rhs)</tt>.</del>
<ins>Begins by calling <tt>this-&gt;close()</tt>.
After the move assignment <tt>*this</tt> reflects the same observable
state it would have if it had been move constructed from <tt>rhs</tt>
(27.9.1.2 [filebuf.cons]).
</ins>
</blockquote>
</blockquote>

<p>
Change 27.9.1.8 [ifstream.assign]/1:
</p>

<blockquote><pre>basic_ifstream&amp; operator=(basic_ifstream&amp;&amp; rhs);
</pre>
<blockquote>
-1- <i>Effects:</i> <del><tt>swap(rhs)</tt>.</del>
<ins>Move assigns the base and members of <tt>*this</tt> with the respective
base and members of <tt>rhs</tt>.</ins>
</blockquote>
</blockquote>

<p>
Change 27.9.1.12 [ofstream.assign]/1:
</p>

<blockquote><pre>basic_ofstream&amp; operator=(basic_ofstream&amp;&amp; rhs);
</pre>
<blockquote>
-1- <i>Effects:</i> <del><tt>swap(rhs)</tt>.</del>
<ins>Move assigns the base and members of <tt>*this</tt> with the respective
base and members of <tt>rhs</tt>.</ins>
</blockquote>
</blockquote>

<p>
Change 27.9.1.16 [fstream.assign]/1:
</p>

<blockquote><pre>basic_fstream&amp; operator=(basic_fstream&amp;&amp; rhs);
</pre>
<blockquote>
-1- <i>Effects:</i> <del><tt>swap(rhs)</tt>.</del>
<ins>Move assigns the base and members of <tt>*this</tt> with the respective
base and members of <tt>rhs</tt>.</ins>
</blockquote>
</blockquote>






<hr>
<h3><a name="904"></a>904. result_of argument types</h3>
<p><b>Section:</b> X [func.ret] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2008-09-10 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#func.ret">issues</a> in [func.ret].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The WP and TR1 have the same text regarding the argument types of a
<tt>result_of</tt> expression:
</p>
<blockquote>
The values <tt>ti</tt> are lvalues when the corresponding type <tt>Ti</tt> is a
reference type, and rvalues otherwise.
</blockquote>
<p>
I read this to mean that this compiles:
</p>
<blockquote><pre>typedef int (*func)(int&amp;);
result_of&lt;func(int&amp;&amp;)&gt;::type i = 0;
</pre></blockquote>
<p>
even though this doesn't:
</p>
<blockquote><pre>int f(int&amp;);
f( std::move(0) );
</pre></blockquote>
<p>
Should the text be updated to say "when <tt>Ti</tt> is an lvalue-reference
type" or am I missing something?
</p>
<p>
I later came up with this self-contained example which won't compile,
but I think it should:
</p>
<blockquote><pre>struct X {
  void operator()(int&amp;);
  int operator()(int&amp;&amp;);
} x;

std::result_of&lt; X(int&amp;&amp;) &gt;::type i = x(std::move(0));
</pre></blockquote>

<p><i>[
Post Summit:
]</i></p>


<blockquote>
Recommend Tentatively Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change X [func.ret], p1:
</p>

<blockquote>
... The values <tt>ti</tt> are lvalues 
when the corresponding type <tt>Ti</tt> is a<ins>n</ins> <ins>lvalue-</ins>reference type,
and rvalues otherwise. 
</blockquote>





<hr>
<h3><a name="907"></a>907. Bitset's immutable element retrieval is inconsistently defined</h3>
<p><b>Section:</b> 20.5.2 [bitset.members] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2008-09-26 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#bitset.members">issues</a> in [bitset.members].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The current standard 14882::2003(E) as well as the current draft
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2723.pdf">N2723</a>
have in common a contradiction of the operational semantics
of member function test 20.5.2 [bitset.members]/56-58 and the immutable
member <tt>operator[]</tt> overload 20.5.2 [bitset.members]/64-66 (all references
are defined in terms of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2723.pdf">N2723</a>):
</p>

<ol>
<li><pre>bool test(size_t pos) const;
</pre>
<blockquote>
<p>
<i>Requires:</i> <tt>pos</tt> is valid
</p>
<p>
<i>Throws:</i> <tt>out_of_range</tt> if <tt>pos</tt> does not correspond
to a valid bit position.
</p>
<p>
<i>Returns:</i> <tt>true</tt> if the bit at position <tt>pos</tt> in <tt>*this</tt>
has the value one.
</p>
</blockquote>
</li>
<li><pre>constexpr bool operator[](size_t pos) const;
</pre>
<blockquote>
<p>
<i>Requires:</i> <tt>pos</tt> shall be valid.
</p>
<p>
<i>Throws:</i> nothing.
</p>
<p>
<i>Returns:</i> <tt>test(pos)</tt>.
</p>
</blockquote>
</li>
</ol>

<p>
Three interpretations:
</p>

<ol type="A">
<li>
The <tt>operator[]</tt> overload is indeed allowed to throw an exception
(via <tt>test()</tt>, if <tt>pos</tt> corresponds to an invalid bit position) which does
not leave the call frame. In this case this function cannot be a
<tt>constexpr</tt> function, because <tt>test()</tt> is not, due to
5.19 [expr.const]/2, last bullet.
</li>
<li>
The intend was not to throw an exception in <tt>test</tt> in case of an
invalid bit position. There is only little evidence for this interpretation.
</li>
<li>
The intend was that <tt>operator[]</tt> should not throw any exception,
but that <tt>test</tt> has the contract to do so, if the provided bit position
is invalid.
</li>
</ol>

<p>
The problem became worse, because issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#720">720</a>
recently voted into WP argued that member <tt>test</tt> logically must be
a <tt>constexpr</tt> function, because it was used to define the semantics
of another <tt>constexpr</tt> function (the <tt>operator[]</tt> overload).
</p>

<p>
Three alternatives are proposed, corresponding to the three bullets
(A), (B), and (C), the author suggests to follow proposal (C).
</p>

<b>
Proposed alternatives:
</b>

<ol type="A">
<li>
<p>
Remove the <tt>constexpr</tt> specifier in front of <tt>operator[]</tt> overload and
undo that of member <tt>test</tt> (assuming <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#720">720</a> is accepted) in both the
class declaration 20.5 [template.bitset]/1 and in the member description
before 20.5.2 [bitset.members]/56 and before /64 to read:
</p>
<blockquote><pre><del>constexpr</del> bool test(size_t pos) const;
..
<del>constexpr</del> bool operator[](size_t pos) const;
</pre></blockquote>

<p>
Change the throws clause of p. 65 to read:
</p>

<blockquote>
<i>Throws:</i> <del>nothing</del>
<ins><tt>out_of_range</tt> if <tt>pos</tt> does not correspond to a valid bit
position</ins>.
</blockquote>
</li>
<li>
<p>
Replace the throws clause p. 57 to read:
</p>

<blockquote>
<i>Throws:</i> <del><tt>out_of_range</tt> if <tt>pos</tt> does not correspond to a valid bit
position</del> <ins>nothing</ins>.
</blockquote>
</li>
<li>
<p>
Undo the addition of the <tt>constexpr</tt> specifier to the <tt>test</tt> member
function in both class declaration 20.5 [template.bitset]/1 and in the
member description before 20.5.2 [bitset.members]/56, assuming that <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#720">720</a>
was applied.
</p>

<blockquote><pre><del>constexpr</del> bool test(size_t pos) const;
</pre></blockquote>

<p>
Change the returns clause p. 66 to read:
</p>

<blockquote>
<i>Returns:</i> <del><tt>test(pos)</tt></del> <ins><tt>true</tt> if the bit at position <tt>pos</tt> in <tt>*this</tt>
has the value one, otherwise <tt>false</tt></ins>.
</blockquote>
</li>
</ol>

<p><i>[
Post Summit:
]</i></p>


<blockquote>
<p>
Lawrence: proposed resolutions A, B, C are mutually exclusive.
</p>
<p>
Recommend Review with option C.
</p>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution.
Move to Tentatively Ready.
</blockquote>


<p><b>Proposed resolution:</b></p>

<ol type="A" ,="" start="3">
<li>
<p>
Undo the addition of the <tt>constexpr</tt> specifier to the <tt>test</tt> member
function in both class declaration 20.5 [template.bitset]/1 and in the
member description before 20.5.2 [bitset.members]/56, assuming that <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#720">720</a>
was applied.
</p>

<blockquote><pre><del>constexpr</del> bool test(size_t pos) const;
</pre></blockquote>

<p>
Change the returns clause p. 66 to read:
</p>

<blockquote>
<i>Returns:</i> <del><tt>test(pos)</tt></del> <ins><tt>true</tt> if the bit at position <tt>pos</tt> in <tt>*this</tt>
has the value one, otherwise <tt>false</tt></ins>.
</blockquote>
</li>
</ol>






<hr>
<h3><a name="909"></a>909. <tt>regex_token_iterator</tt> should use <tt>initializer_list</tt></h3>
<p><b>Section:</b> 28.12.2 [re.tokiter] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2008-09-26 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#re.tokiter">issues</a> in [re.tokiter].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 319</b></p>
<p>
Construction of a <tt>regex_token_iterator</tt> (28.12.2 [re.tokiter]/6+) usually
requires the provision of a sequence of integer values, which
can currently be done via a <tt>std::vector&lt;int&gt;</tt> or
a C array of <tt>int</tt>. Since the introduction of <tt>initializer_list</tt> in the
standard it seems much more reasonable to provide a
corresponding constructor that accepts an <tt>initializer_list&lt;int&gt;</tt>
instead. This could be done as a pure addition or one could
even consider replacement. The author suggests the
replacement strategy (A), but provides an alternative additive
proposal (B) as a fall-back, because of the handiness of this
range type:
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We strongly recommend alternative B of the proposed resolution
in order that existing code not be broken.
With that understanding, move to Tentatively Ready.
</blockquote>

<p><b>Original proposed wording:</b></p>

<ol type="A">
<li><br>
<ol>
<li>
<p>
In 28.12.2 [re.tokiter]/6 and the list 28.12.2.1 [re.tokiter.cnstr]/10-11 change the
constructor declaration:
</p>

<blockquote><pre><del>template &lt;std::size_t N&gt;</del>
regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b,
                     const regex_type&amp; re,
                     <del>const int (&amp;submatches)[N]</del> <ins>initializer_list&lt;int&gt; submatches</ins>,
                     regex_constants::match_flag_type m =
                       regex_constants::match_default);
</pre></blockquote>
</li>

<li>
<p>
In 28.12.2.1 [re.tokiter.cnstr]/12 change the last sentence
</p>

<blockquote>
The third constructor initializes the member <tt>subs</tt> to hold
a copy of the sequence of integer values pointed to by the
iterator range <tt>[<del>&amp;</del>submatches<ins>.begin()</ins>,
<del>&amp;</del>submatches<ins>.end()</ins> <del>+ N</del>)</tt>.
</blockquote>
</li>
</ol>
</li>

<li><br>
<ol>
<li>
<p>
In 28.12.2 [re.tokiter]/6 and the list 28.12.2.1 [re.tokiter.cnstr]/10-11 <em>insert</em> the
following constructor declaration between the already existing ones
accepting a <tt>std::vector</tt> and a C array of <tt>int</tt>, resp.:
</p>

<blockquote><pre>regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b,
                     const regex_type&amp; re,
                     initializer_list&lt;int&gt; submatches,
                     regex_constants::match_flag_type m =
                       regex_constants::match_default);
</pre></blockquote>
</li>
<li>
<p>
In 28.12.2.1 [re.tokiter.cnstr]/12 change the last sentence
</p>

<blockquote>
The third <ins>and fourth</ins> constructor initialize<del>s</del> the member <tt>subs</tt>
to hold a copy of the sequence of integer values pointed to
by the iterator range <tt>[&amp;submatches,&amp;submatches + N)</tt>
<ins>and <tt>[submatches.begin(),submatches.end())</tt>, respectively</ins>.
</blockquote>
</li>
</ol>
</li>

</ol>



<p><b>Proposed resolution:</b></p>

<ol type="A" start="2">

<li><br>
<ol>
<li>
<p>
In 28.12.2 [re.tokiter]/6 and the list 28.12.2.1 [re.tokiter.cnstr]/10-11 <em>insert</em> the
following constructor declaration between the already existing ones
accepting a <tt>std::vector</tt> and a C array of <tt>int</tt>, resp.:
</p>

<blockquote><pre>regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b,
                     const regex_type&amp; re,
                     initializer_list&lt;int&gt; submatches,
                     regex_constants::match_flag_type m =
                       regex_constants::match_default);
</pre></blockquote>
</li>
<li>
<p>
In 28.12.2.1 [re.tokiter.cnstr]/12 change the last sentence
</p>

<blockquote>
The third <ins>and fourth</ins> constructor initialize<del>s</del> the member <tt>subs</tt>
to hold a copy of the sequence of integer values pointed to
by the iterator range <tt>[&amp;submatches,&amp;submatches + N)</tt>
<ins>and <tt>[submatches.begin(),submatches.end())</tt>, respectively</ins>.
</blockquote>
</li>
</ol>
</li>

</ol>






<hr>
<h3><a name="911"></a>911. I/O streams and <tt>move/swap</tt> semantic</h3>
<p><b>Section:</b> 27.7.1 [input.streams], 27.7.2 [output.streams] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Alberto Ganesh Barbati <b>Opened:</b> 2008-09-29 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Class template <tt>basic_istream</tt>, <tt>basic_ostream</tt> and <tt>basic_iostream</tt>
implements public move constructors, move assignment operators and <tt>swap</tt>
method and free functions. This might induce both the user and the
compiler to think that those types are <tt>MoveConstructible</tt>, <tt>MoveAssignable</tt>
and <tt>Swappable</tt>. However, those class templates fail to fulfill the user
expectations. For example:
</p>

<blockquote><pre>std::ostream os(std::ofstream("file.txt"));
assert(os.rdbuf() == 0); // buffer object is not moved to os, file.txt has been closed

std::vector&lt;std::ostream&gt; v;
v.push_back(std::ofstream("file.txt"));
v.reserve(100); // causes reallocation
assert(v[0].rdbuf() == 0); // file.txt has been closed!

std::ostream&amp;&amp; os1 = std::ofstream("file1.txt");
os1 = std::ofstream("file2.txt");
os1 &lt;&lt; "hello, world"; // still writes to file1.txt, not to file2.txt!

std::ostream&amp;&amp; os1 = std::ofstream("file1.txt");
std::ostream&amp;&amp; os2 = std::ofstream("file2.txt");
std::swap(os1, os2);
os1 &lt;&lt; "hello, world"; // writes to file1.txt, not to file2.txt!
</pre></blockquote>

<p>
This is because the move constructor, the move assignment operator and
<tt>swap</tt> are all implemented through calls to <tt>std::basic_ios</tt> member
functions <tt>move()</tt> and <tt>swap()</tt> that do not move nor swap the controlled
stream buffers. That can't happen because the stream buffers may have
different types.
</p>

<p>
Notice that for <tt>basic_streambuf</tt>, the member function <tt>swap()</tt> is
protected. I believe that is correct and all of <tt>basic_istream</tt>,
<tt>basic_ostream</tt>, <tt>basic_iostream</tt> should do the same as the move ctor, move
assignment operator and swap member function are needed by the derived
<tt>fstream</tt>s and <tt>stringstream</tt>s template. The free swap functions for
<tt>basic_(i|o|io)stream</tt> templates should be removed for the same reason.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We note that the rvalue swap functions have already been removed.
</p>
<p>
Bill is unsure about making the affected functions protected;
he believes they may need to be public.
</p>
<p>
We are also unsure about removing the lvalue swap functions as proposed.
</p>
<p>
Move to Open.
</p>
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
<p>
It's not clear that the use case is compelling.
</p>
<p>
Howard: This needs to be implemented and tested.
</p>
</blockquote>

<p><i>[
2009-07-26 Howard adds:
]</i></p>


<blockquote>
<p>
I started out thinking I would recommend NAD for this one.  I've turned around
to agree with the proposed resolution (which I've updated to the current draft).
I did not fully understand Ganesh's rationale, and attempt to describe my
improved understanding below.
</p>

<p>
The move constructor, move assignment operator, and swap function are different
for <tt>basic_istream</tt>, <tt>basic_ostream</tt> and <tt>basic_iostream</tt>
than other classes.  A timely conversation with Daniel reminded me of this long
forgotten fact.  These members are sufficiently different that they would be
extremely confusing to use in general, but they are very much needed for derived
clients.
</p>

<ul>
<li>
The move constructor moves everything but the <tt>rdbuf</tt> pointer.
</li>
<li>
The move assignment operator moves everything but the <tt>rdbuf</tt> pointer.
</li>
<li>
The swap function swaps everything but the <tt>rdbuf</tt> pointer.
</li>
</ul>

<p>
The reason for this behavior is that for the std-derived classes (stringstreams,
filestreams), the <tt>rdbuf</tt> pointer points back into the class itself
(self referencing).  It can't be swapped or moved.  But this fact isn't born out
at the <tt>stream</tt> level.  Rather it is born out at the <tt>fstream</tt>/<tt>sstream</tt>
level.  And the lower levels just need to deal with that fact by not messing around
with the <tt>rdbuf</tt> pointer which is stored down at the lower levels.
</p>

<p>
In a nutshell, it is very confusing for all of those who are not so intimately
related with streams that they've implemented them.  And it is even fairly
confusing for some of those who have (including myself).  I do not think it is
safe to swap or move <tt>istreams</tt> or <tt>ostreams</tt> because this will
(by necessary design) separate stream state from streambuffer state.  Derived
classes (such as <tt>fstream</tt> and <tt>stringstream</tt> must be used to
keep the stream state and stream buffer consistently packaged as one unit during
a move or swap.
</p>

<p>
I've implemented this proposal and am living with it day to day.
</p>

</blockquote>

<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote>
Leave Open.  Pablo expected to propose alternative wording which would rename
move construction, move assignment and swap, and may or may not make them
protected.  This will impact issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#900">900</a>.
</blockquote>

<p><i>[
2010 Pittsburgh:
]</i></p>


<blockquote>
Moved to Ready for Pittsburgh.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
27.7.1.1 [istream]: make the following member functions protected:
</p>

<blockquote><pre>basic_istream(basic_istream&amp;&amp;  rhs);
basic_istream&amp;  operator=(basic_istream&amp;&amp;  rhs);
void  swap(basic_istream&amp;  rhs);
</pre></blockquote>

<p>
Ditto: remove the swap free function signature
</p>

<blockquote><pre><del>// swap: 
template &lt;class charT, class traits&gt; 
  void swap(basic_istream&lt;charT, traits&gt;&amp; x, basic_istream&lt;charT, traits&gt;&amp; y);</del>
</pre></blockquote>

<p>
27.7.1.1.2 [istream.assign]: remove paragraph 4
</p>

<blockquote><pre><del>template &lt;class charT, class traits&gt; 
  void swap(basic_istream&lt;charT, traits&gt;&amp; x, basic_istream&lt;charT, traits&gt;&amp; y);</del>
</pre>
<blockquote>
<del><i>Effects:</i> <tt>x.swap(y)</tt>.</del>
</blockquote>
</blockquote>

<p>
27.7.1.5 [iostreamclass]: make the following member function protected:
</p>

<blockquote><pre>basic_iostream(basic_iostream&amp;&amp;  rhs);
basic_iostream&amp;  operator=(basic_iostream&amp;&amp;  rhs);
void  swap(basic_iostream&amp;  rhs);
</pre></blockquote>

<p>
Ditto: remove the swap free function signature
</p>

<blockquote><pre><del>template &lt;class charT, class traits&gt; 
  void swap(basic_iostream&lt;charT, traits&gt;&amp; x, basic_iostream&lt;charT, traits&gt;&amp; y);</del>
</pre></blockquote>

<p>
27.7.1.5.3 [iostream.assign]: remove paragraph 3
</p>

<blockquote><pre><del>template &lt;class charT, class traits&gt; 
  void swap(basic_iostream&lt;charT, traits&gt;&amp; x, basic_iostream&lt;charT, traits&gt;&amp; y);</del>
</pre>
<blockquote>
<del><i>Effects:</i> <tt>x.swap(y)</tt>.</del>
</blockquote>
</blockquote>

<p>
27.7.2.1 [ostream]: make the following member function protected:
</p>

<blockquote><pre>basic_ostream(basic_ostream&amp;&amp;  rhs);
basic_ostream&amp;  operator=(basic_ostream&amp;&amp;  rhs);
void  swap(basic_ostream&amp;  rhs);
</pre></blockquote>

<p>
Ditto: remove the swap free function signature
</p>

<blockquote><pre><del>// swap: 
template &lt;class charT, class traits&gt; 
  void swap(basic_ostream&lt;charT, traits&gt;&amp; x, basic_ostream&lt;charT, traits&gt;&amp; y);</del>
</pre></blockquote>

<p>
27.7.2.3 [ostream.assign]: remove paragraph 4 
</p>

<blockquote><pre><del>template &lt;class charT, class traits&gt; 
  void swap(basic_ostream&lt;charT, traits&gt;&amp; x, basic_ostream&lt;charT, traits&gt;&amp; y);</del>
</pre>
<blockquote>
<del><i>Effects:</i> <tt>x.swap(y)</tt>.</del>
</blockquote>
</blockquote>






<hr>
<h3><a name="920"></a>920. Ref-qualification support in the library</h3>
<p><b>Section:</b> 20.8.13 [func.memfn] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Bronek Kozicki <b>Opened:</b> 2008-10-06 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#func.memfn">issues</a> in [func.memfn].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1230">1230</a></p>
<p><b>Discussion:</b></p>
<p>
Daniel Krgler wrote:
</p>

<blockquote>
<p>
Shouldn't above list be completed for &amp;- and &amp;&amp;-qualified
member functions This would cause to add:
</p>
<blockquote><pre>template&lt;Returnable R, class T, CopyConstructible... Args&gt;
unspecified mem_fn(R (T::* pm)(Args...) &amp;);
template&lt;Returnable R, class T, CopyConstructible... Args&gt;
unspecified mem_fn(R (T::* pm)(Args...) const &amp;);
template&lt;Returnable R, class T, CopyConstructible... Args&gt;
unspecified mem_fn(R (T::* pm)(Args...) volatile &amp;);
template&lt;Returnable R, class T, CopyConstructible... Args&gt;
unspecified mem_fn(R (T::* pm)(Args...) const volatile &amp;);
template&lt;Returnable R, class T, CopyConstructible... Args&gt;
unspecified mem_fn(R (T::* pm)(Args...) &amp;&amp;);
template&lt;Returnable R, class T, CopyConstructible... Args&gt;
unspecified mem_fn(R (T::* pm)(Args...) const &amp;&amp;);
template&lt;Returnable R, class T, CopyConstructible... Args&gt;
unspecified mem_fn(R (T::* pm)(Args...) volatile &amp;&amp;);
template&lt;Returnable R, class T, CopyConstructible... Args&gt;
unspecified mem_fn(R (T::* pm)(Args...) const volatile &amp;&amp;);
</pre></blockquote>

</blockquote>

<p>
yes, absolutely. Thanks for spotting this. Without this change <tt>mem_fn</tt>
cannot be initialized from pointer to ref-qualified member function. I
believe semantics of such function pointer is well defined.
</p>

<p><i>[
Post Summit Daniel provided wording.
]</i></p>


<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We need to think about whether we really want to go down the proposed path
of combinatorial explosion.
Perhaps a Note would suffice.
</p>
<p>
We would really like to have an implementation before proceeding.
</p>
<p>
Move to Open, and recommend this be deferred until after the next
Committee Draft has been issued.
</p>
</blockquote>

<p><i>[
2009-10-10 Daniel updated wording to post-concepts.
]</i></p>


<blockquote>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1230">1230</a> has a similar proposed resolution
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Move to Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>
Change 20.8 [function.objects]/2, header
<tt>&lt;functional&gt;</tt> synopsis as follows:
</p>

<blockquote><pre>// 20.7.14, member function adaptors:
template&lt;class R, class T&gt; <i>unspecified</i> mem_fn(R T::*);

<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::*)(Args...));</ins>
<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::*)(Args...) const);</ins>
<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::*)(Args...) volatile);</ins>
<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::*)(Args...) const volatile);</ins>

<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::*)(Args...) &amp;);</ins>
<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::*)(Args...) const &amp;);</ins>
<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::*)(Args...) volatile &amp;);</ins>
<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::*)(Args...) const volatile &amp;);</ins>

<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::*)(Args...) &amp;&amp;);</ins>
<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::*)(Args...) const &amp;&amp;);</ins>
<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::*)(Args...) volatile &amp;&amp;);</ins>
<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::*)(Args...) const volatile &amp;&amp;);</ins>
</pre></blockquote>
</li>

<li>
<p>
Change the prototype list of 20.8.13 [func.memfn] as follows [NB: The
following text, most notably p.2 and p.3 which
discuss influence of the cv-qualification on the definition of the
base class's first template parameter remains
unchanged. ]:
</p>

<blockquote><pre>template&lt;class R, class T&gt; <i>unspecified</i> mem_fn(R T::* pm);

<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::* pm)(Args...));</ins>
<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::* pm)(Args...) const);</ins>
<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::* pm)(Args...) volatile);</ins>
<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::* pm)(Args...) const volatile);</ins>

<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::* pm)(Args...) &amp;);</ins>
<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::* pm)(Args...) const &amp;);</ins>
<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::* pm)(Args...) volatile &amp;);</ins>
<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::* pm)(Args...) const volatile &amp;);</ins>

<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::* pm)(Args...) &amp;&amp;);</ins>
<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::* pm)(Args...) const &amp;&amp;);</ins>
<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::* pm)(Args...) volatile &amp;&amp;);</ins>
<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::* pm)(Args...) const volatile &amp;&amp;);</ins>
</pre></blockquote>
</li>

<li>
<p>
Remove 20.8.13 [func.memfn]/5:
</p>

<blockquote>
<del><i>Remarks:</i> Implementations may implement <tt>mem_fn</tt> as a set of
overloaded function templates.</del>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="921"></a>921. Rational Arithmetic should use template aliases</h3>
<p><b>Section:</b> 20.6.1 [ratio.ratio] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Pablo Halpern <b>Opened:</b> 2008-10-07 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#ratio.ratio">issues</a> in [ratio.ratio].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The compile-time functions that operate on <tt>ratio&lt;N,D&gt;</tt> require the
cumbersome and error-prone "evaluation" of a <tt>type</tt> member using a
meta-programming style that predates the invention of template aliases.
Thus, multiplying three ratios <tt>a</tt>, <tt>b</tt>, and <tt>c</tt> requires the expression:
</p>

<blockquote><pre>ratio_multiply&lt;a, ratio_multiply&lt;b, c&gt;::type&gt;::type
</pre></blockquote>

<p>
The simpler expression:
</p>

<blockquote><pre>ratio_multiply&lt;a, ratio_multiply&lt;b, c&gt;&gt;
</pre></blockquote>

<p>
Could be used by if template aliases were employed in the definitions.
</p>

<p><i>[
Post Summit:
]</i></p>


<blockquote>
<p>
Jens: not a complete proposed resolution: "would need to make similar change"
</p>
<p>
Consensus: We agree with the direction of the issue.
</p>
<p>
Recommend Open.
</p>
</blockquote>

<p><i>[
2009-05-11 Daniel adds:
]</i></p>


<blockquote>
<p>
Personally I'm <em>not</em> in favor for the addition of:
</p>
<blockquote><pre>typedef ratio type;
</pre></blockquote>
<p>
For a reader of the
standard it's usage or purpose is unclear. I haven't seen similar examples
of attempts to satisfy non-feature complete compilers.
</p>
</blockquote>

<p><i>[
2009-05-11 Pablo adds:
]</i></p>


<blockquote>
<p>
The addition of type to the <tt>ratio</tt> template allows the previous style
(i.e., in the prototype implementations) to remain valid and permits the
use of transitional library implementations for C++03 compilers.  I do
not feel strongly about its inclusion, however, and leave it up to the
reviewers to decide.
</p>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Bill asks for additional discussion in the issue
that spells out more details of the implementation.
Howard points us to issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#948">948</a>
which has at least most of the requested details.
Tom is strongly in favor of overflow-checking at compile time.
Pete points out that there is no change of functionality implied.
We agree with the proposed resolution,
but recommend moving the issue to Review
to allow time to improve the discussion if needed.
</blockquote>

<p><i>[
2009-07-21 Alisdair adds:
]</i></p>


<blockquote>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1121">1121</a> for a potentially incompatible proposal.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Move to Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>

 
 <ol start="0">
<li>
<p>
In 20.6 [ratio]/3 change as indicated:
</p>

<blockquote><pre>// ratio arithmetic
template &lt;class R1, class R2&gt; <del>struct</del><ins>using</ins> ratio_add<ins> = <em>see below</em></ins>;
template &lt;class R1, class R2&gt; <del>struct</del><ins>using</ins> ratio_subtract<ins> = <em>see below</em></ins>;
template &lt;class R1, class R2&gt; <del>struct</del><ins>using</ins> ratio_multiply<ins> = <em>see below</em></ins>;
template &lt;class R1, class R2&gt; <del>struct</del><ins>using</ins> ratio_divide<ins> = <em>see below</em></ins>;
</pre></blockquote>
</li>
<li>
<p>
In 20.6.1 [ratio.ratio], change as indicated:
</p>
<blockquote><pre>namespace std {
  template &lt;intmax_t N, intmax_t D = 1&gt;
  class ratio {
  public:
    <ins>typedef ratio type;</ins>
    static const intmax_t num;
    static const intmax_t den;
  };
}
</pre></blockquote>
</li>
<li>
<p>
In 20.6.2 [ratio.arithmetic] change as indicated:
</p>

<blockquote><pre>template &lt;class R1, class R2&gt; <del>struct</del><ins>using</ins> ratio_add<ins> = <em>see below</em></ins><del>{
  typedef <em>see below</em> type;
}</del>;
</pre>

<blockquote>
<p>
1 The <del>nested typedef</del> type <tt><ins>ratio_add&lt;R1, R2&gt;</ins></tt>
shall be a synonym for <tt>ratio&lt;T1, T2&gt;</tt>
where <tt>T1</tt> has the value <tt>R1::num * R2::den + R2::num * R1::den</tt> and <tt>T2</tt>
has the value <tt>R1::den * R2::den</tt>.
</p>
</blockquote>
</blockquote>
<blockquote><pre>template &lt;class R1, class R2&gt; <del>struct</del><ins>using</ins> ratio_subtract<ins> = <em>see below</em></ins><del>{
  typedef <em>see below</em> type;
}</del>;
</pre>
<blockquote>
<p>
2 The <del>nested typedef</del> type <tt><ins>ratio_subtract&lt;R1, R2&gt;</ins></tt>
shall be a synonym for <tt>ratio&lt;T1, T2&gt;</tt>
where <tt>T1</tt> has the value <tt>R1::num * R2::den - R2::num * R1::den</tt> and <tt>T2</tt>
has the value <tt>R1::den * R2::den</tt>.
</p>
</blockquote>
</blockquote>
<blockquote><pre>template &lt;class R1, class R2&gt; <del>struct</del><ins>using</ins> ratio_multiply<ins> = <em>see below</em></ins><del>{
  typedef <em>see below</em> type;
}</del>;
</pre>
<blockquote>
<p>
3 The <del>nested typedef</del> type <tt><ins>ratio_multiply&lt;R1, R2&gt;</ins></tt>
shall be a synonym for <tt>ratio&lt;T1, T2&gt;</tt>
where <tt>T1</tt> has the value <tt>R1::num * R2::num</tt> and <tt>T2</tt> has the value <tt>R1::den * R2::den</tt>.
</p>
</blockquote>
</blockquote>
<blockquote><pre>template &lt;class R1, class R2&gt; <del>struct</del><ins>using</ins> ratio_divide<ins> = <em>see below</em></ins><del>{
  typedef <em>see below</em> type;
}</del>;
</pre>
<blockquote>
<p>
4 The <del>nested typedef</del> type <tt><ins>ratio_divide&lt;R1, R2&gt;</ins></tt>
shall be a synonym for <tt>ratio&lt;T1, T2&gt;</tt>
where <tt>T1</tt> has the value <tt>R1::num * R2::den</tt> and <tt>T2</tt> has the value <tt>R1::den * R2::num</tt>.
</p>
</blockquote>
</blockquote>
</li>
<li>
<p>
In 20.11.3.1 [time.duration.cons]/4 change as indicated:
</p>
<blockquote>
<p>
<i>Requires:</i> <tt>treat_as_floating_point&lt;rep&gt;::value</tt> shall be true or
<tt>ratio_divide&lt;Period2, period&gt;::<del>type::</del>den</tt> shall be 1.[..]
</p>
</blockquote>
</li>
<li>
<p>
In 20.11.3.7 [time.duration.cast]/2 change as indicated:
</p>
<blockquote>
<p>
<i>Returns:</i> Let CF be <tt>ratio_divide&lt;Period, typename
ToDuration::period&gt;<del>::type</del></tt>, and [..]
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="922"></a>922. [func.bind.place] Number of placeholders</h3>
<p><b>Section:</b> B [implimits] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Sohail Somani <b>Opened:</b> 2008-10-11 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses DE 24</b></p>

<p>
With respect to the section 20.8.10.1.3 [func.bind.place]:
</p>
<p>
TR1 dropped some suggested implementation quantities for the number of
placeholders. The purpose of this defect is to put these back for C++0x.
</p>

<p><i>[
Post Summit:
]</i></p>


<blockquote>
<p>
see DE 24
</p>
<p>
Recommend applying the proposed resolution from DE 24, with that
Tentatively Ready.
</p>
</blockquote>

<b>Original proposed resolution:</b>

<p>
Add 20.8.10.1.3 [func.bind.place]/2:
</p>

<blockquote>
While the exact number of placeholders (<tt>_M</tt>) is implementation defined,
this number shall be at least 10.
</blockquote>



<p><b>Proposed resolution:</b></p>

<p>
Add to B [implimits]:
</p>

<ul>
<li>
Number of placeholders (20.8.10.1.3 [func.bind.place]) [10].
</li>
</ul>






<hr>
<h3><a name="925"></a>925. <tt>shared_ptr</tt>'s explicit conversion from <tt>unique_ptr</tt></h3>
<p><b>Section:</b> 20.9.10.2.1 [util.smartptr.shared.const] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Rodolfo Lima <b>Opened:</b> 2008-10-12 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#util.smartptr.shared.const">issues</a> in [util.smartptr.shared.const].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The current working draft
(<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2798.pdf">N2798</a>),
section 20.9.10.2.1 [util.smartptr.shared.const] declares
<tt>shared_ptr</tt>'s constructor that takes a rvalue reference to <tt>unique_ptr</tt> and
<tt>auto_ptr</tt> as being explicit, affecting several valid smart pointer use
cases that would take advantage of this conversion being implicit, for
example:
</p>

<blockquote><pre>class A;
std::unique_ptr&lt;A&gt; create();
void process(std::shared_ptr&lt;A&gt; obj);

int main()
{
   process(create());                  // use case #1
   std::unique_ptr&lt;A&gt; uobj = create();
   process(std::move(uobj));           // use case #2
   return 0;
}
</pre></blockquote>

<p>
If <tt>unique_ptr</tt> to <tt>shared_ptr</tt> conversions are explicit, the above lines
should be written:
</p>

<blockquote><pre>process(std::shared_ptr&lt;A&gt;(create()));        // use case #1
process(std::shared_ptr&lt;A&gt;(std::move(uobj))); // use case #2
</pre></blockquote>

<p>
The extra cast required doesn't seems to give any benefits to the user,
nor protects him of any unintended conversions, this being the raison
d'etre of explicit constructors.
</p>

<p>
It seems that this constructor was made explicit to mimic the conversion
from <tt>auto_ptr</tt> in pre-rvalue reference days, which accepts both lvalue and
rvalue references. Although this decision was valid back then, C++0x
allows the user to express in a clear and non verbose manner when he wants
move semantics to be employed, be it implicitly (use case 1) or explicitly
(use case 2).
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Howard and Alisdair like the motivating use cases
and the proposed resolution.
</p>
<p>
Move to Tentatively Ready.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
In both 20.9.10.2 [util.smartptr.shared] paragraph 1 and 
20.9.10.2.1 [util.smartptr.shared.const] change:
</p>

<blockquote><pre>template &lt;class Y&gt; <del>explicit</del> shared_ptr(auto_ptr&lt;Y&gt; &amp;&amp;r);
template &lt;class Y, class D&gt; <del>explicit</del> shared_ptr(unique_ptr&lt;Y, D&gt; &amp;&amp;r);
</pre></blockquote>






<hr>
<h3><a name="929"></a>929. Thread constructor</h3>
<p><b>Section:</b> 30.3.1.2 [thread.thread.constr] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Anthony Williams <b>Opened:</b> 2008-10-23 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.thread.constr">issues</a> in [thread.thread.constr].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 323</b></p>

<p>
The <tt>thread</tt> constructor for starting a new thread with a function and
arguments is overly constrained by the signature requiring rvalue
references for <tt>func</tt> and <tt>args</tt> and the <tt>CopyConstructible</tt> requirements
for the elements of <tt>args</tt>. The use of an rvalue reference for the
function restricts the potential use of a plain function name, since
the type of the bound parameter will be deduced to be a function
reference and decay to pointer-to-function will not happen. This
therefore complicates the implementation in order to handle a simple
case. Furthermore, the use of rvalue references for args prevents the
array to pointer decay. Since arrays are not <tt>CopyConstructible</tt> or even
<tt>MoveConstructible</tt>, this essentially prevents the passing of arrays as
parameters. In particular it prevents the passing of string literals.
Consequently a simple case such as
</p>

<blockquote><pre>void f(const char*);
std::thread t(f,"hello");
</pre></blockquote>

<p>
is ill-formed since the type of the string literal is <tt>const char[6]</tt>.
</p>

<p>
By changing the signature to take all parameters by value we can
eliminate the <tt>CopyConstructible</tt> requirement and permit the use of
arrays, as the parameter passing semantics will cause the necessary
array-to-pointer decay. They will also cause the function name to
decay to a pointer to function and allow the implementation to handle
functions and function objects identically.
</p>

<p>
The new signature of the <tt>thread</tt> constructor for a function and
arguments is thus:
</p>

<blockquote><pre>template&lt;typename F,typename... Args&gt;
thread(F,Args... args);
</pre></blockquote>

<p>
Since the parameter pack <tt>Args</tt> can be empty, the single-parameter
constructor that takes just a function by value is now redundant.
</p>

<p><i>[
Howard adds:
]</i></p>


<blockquote>
<p>
I agree with everything Anthony says in this issue.  However I believe we
can optimize in such a way as to get the pass-by-value behavior with the
pass-by-rvalue-ref performance.  The performance difference is that the latter
removes a <tt>move</tt> when passing in an lvalue.
</p>

<p>
This circumstance is very analogous to <tt>make_pair</tt> (20.3.5 [pairs])
where we started with passing by const reference, changed to pass by value to
get pointer decay, and then changed to pass by rvalue reference, but modified with
<tt>decay&lt;T&gt;</tt> to retain the pass-by-value behavior.  If we were to
apply the same solution here it would look like:
</p>

<blockquote><pre><del>template &lt;class F&gt; explicit thread(F f);</del>
template &lt;class F, class ...Args&gt; thread(F&amp;&amp; f, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-4- <i>Requires:</i> <tt>F</tt> and each <tt>Ti</tt> in <tt>Args</tt> shall be <del><tt>CopyConstructible</tt>
if an lvalue and otherwise</del> <tt>MoveConstructible</tt>.
<tt><i>INVOKE</i>(f, w1, w2, ..., wN)</tt> (20.8.2 [func.require]) shall be a valid expression for
some values <tt>w1, w2, ... , wN,</tt> where <tt>N == sizeof...(Args)</tt>.
</p>
<p>
-5- <i>Effects:</i> Constructs an object of type <tt>thread</tt>
<del>and executes <tt><i>INVOKE</i>(f, t1, t2, ..., tN)</tt> in a new
thread of execution, where <tt>t1, t2, ..., tN</tt> are the values in <tt>args...</tt></del>.
<ins>Constructs
the following objects in memory which is accessible to a new thread of execution
as if:</ins>
</p>
<blockquote><pre><ins>typename decay&lt;F&gt;::type g(std::forward&lt;F&gt;(f));</ins>
<ins>tuple&lt;typename decay&lt;Args&gt;::type...&gt; w(std::forward&lt;Args&gt;(args)...);</ins>
</pre></blockquote>
<p>
<ins>The new thread of
execution executes <tt><i>INVOKE</i>(g, wi...)</tt> where the <tt>wi...</tt> refers
to the elements stored in the <tt>tuple w</tt>.</ins>
Any return value from <tt>g</tt> is ignored.
<del>If <tt>f</tt> terminates with an uncaught exception, <tt>std::terminate()</tt> shall be called.</del>
<ins>If the evaluation of <tt><i>INVOKE</i>(g,  wi...)</tt> terminates
with an uncaught exception, <tt>std::terminate()</tt> shall be called [<i>Note:</i>
<tt>std::terminate()</tt> could be called before entering <tt>g</tt>. -- <i>end note</i>]. Any
exception thrown before the evaluation of <tt><i>INVOKE</i></tt> has started shall be
catchable in the calling thread.</ins>
</p>
</blockquote>
</blockquote>

<p>
Text referring to when <tt>terminate()</tt> is called was contributed by Ganesh.
</p>

</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution,
but would like the final sentence to be reworded
since "catchable" is not a term of art (and is used nowhere else).
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
<p>
This is linked to
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2901.pdf">N2901</a>.
</p>
<p>
Howard to open a separate issue to remove (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1176">1176</a>).
</p>
<p>
In Frankfurt there is no consensus for removing the variadic constructor.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
We want to move forward with this issue.  If we later take it out via <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1176">1176</a>
then that's ok too.  Needs small group to improve wording.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
<p>
Stefanus provided revised wording.  Moved to Review  Here is the original wording:
</p>
<blockquote>
<p>
Modify the class definition of <tt>std::thread</tt> in 30.3.1 [thread.thread.class] to remove the
following signature:
</p>

<blockquote><pre><del>template&lt;class F&gt; explicit thread(F f);</del>
template&lt;class F, class ... Args&gt; <ins>explicit</ins> thread(F&amp;&amp; f, Args&amp;&amp; ... args);
</pre></blockquote>

<p>
Modify 30.3.1.2 [thread.thread.constr] to replace the constructors prior to paragraph 4 with
the single constructor as above. Replace paragraph 4 - 6 with the
following:
</p>

<blockquote>
<p>
-4- <i>Requires:</i> <tt>F</tt> and each <tt>Ti</tt> in <tt>Args</tt> shall be <del><tt>CopyConstructible</tt>
if an lvalue and otherwise</del> <tt>MoveConstructible</tt>.
<tt><i>INVOKE</i>(f, w1, w2, ..., wN)</tt> (20.8.2 [func.require]) shall be a valid expression for
some values <tt>w1, w2, ... , wN,</tt> where <tt>N == sizeof...(Args)</tt>.
</p>
<p>
-5- <i>Effects:</i> Constructs an object of type <tt>thread</tt>
<del>and executes <tt><i>INVOKE</i>(f, t1, t2, ..., tN)</tt> in a new
thread of execution, where <tt>t1, t2, ..., tN</tt> are the values in <tt>args...</tt></del>.
<ins>Constructs
the following objects:</ins>
</p>
<blockquote><pre><ins>typename decay&lt;F&gt;::type g(std::forward&lt;F&gt;(f));</ins>
<ins>tuple&lt;typename decay&lt;Args&gt;::type...&gt; w(std::forward&lt;Args&gt;(args)...);</ins>
</pre></blockquote>
<p>
<ins>and executes <tt><i>INVOKE</i>(g, wi...)</tt> in a new thread of execution.
These objects shall be destroyed when the new thread of execution completes.</ins>
Any return value from <tt>g</tt> is ignored.
<del>If <tt>f</tt> terminates with an uncaught exception, <tt>std::terminate()</tt> shall be called.</del>
<ins>If the evaluation of <tt><i>INVOKE</i>(g,  wi...)</tt> terminates
with an uncaught exception, <tt>std::terminate()</tt> shall be called [<i>Note:</i>
<tt>std::terminate()</tt> could be called before entering <tt>g</tt>. -- <i>end note</i>]. Any
exception thrown before the evaluation of <tt><i>INVOKE</i></tt> has started shall be
catchable in the calling thread.</ins>
</p>
<p>
-6- <i>Synchronization:</i> The invocation of the constructor <i>happens before</i> the
invocation of <del><tt>f</tt></del> <ins><tt>g</tt></ins>.
</p>
</blockquote>

</blockquote>
</blockquote>

<p><i>[
2010-01-19 Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
Modify the class definition of <tt>std::thread</tt> in 30.3.1 [thread.thread.class] to remove the
following signature:
</p>

<blockquote><pre><del>template&lt;class F&gt; explicit thread(F f);</del>
template&lt;class F, class ... Args&gt; <ins>explicit</ins> thread(F&amp;&amp; f, Args&amp;&amp; ... args);
</pre></blockquote>

<p>
Modify 30.3.1.2 [thread.thread.constr] to replace the constructors prior to paragraph 4 with
the single constructor as above. Replace paragraph 4 - 6 with the
following:
</p>

<blockquote>
<p>
<ins>Given a function as follows:</ins>
</p>

<blockquote><pre><ins>
template&lt;typename T&gt; typename decay&lt;T&gt;::type decay_copy(T&amp;&amp; v)
    { return std::forward&lt;T&gt;(v); }
</ins></pre></blockquote>

<p>
-4- <i>Requires:</i> <tt>F</tt> and each <tt>Ti</tt> in <tt>Args</tt> shall
<del>be <tt>CopyConstructible</tt> if an lvalue and otherwise</del> <ins>satisfy
the</ins> <tt>MoveConstructible</tt> <ins>requirements</ins>.
<del><tt><i>INVOKE</i>(f, w1, w2, ..., wN)</tt> (20.8.2 [func.require])
shall be a valid expression for some values <tt>w1, w2, ... , wN,</tt> where
<tt>N == sizeof...(Args)</tt>.</del>
<ins><tt><i>INVOKE</i>(decay_copy(std::forward&lt;F&gt;(f)), decay_copy(std::forward&lt;Args&gt;(args))...)</tt> (20.8.2 [func.require]) shall be a valid expression.</ins>
</p>

<p>
-5- <i>Effects:</i> Constructs an object of type <tt>thread</tt> <del>and executes
<tt>INVOKE(f, t1, t2, ..., tN)</tt> in a new thread of execution, where
<tt>t1, t2, ..., tN</tt> are the values in <tt>args...</tt>. 
Any return
value from <tt>f</tt> is ignored. If <tt>f</tt> terminates with an
uncaught exception, <tt>std::terminate()</tt> shall be called.</del>
<ins>The new thread of execution executes <tt>INVOKE(decay_copy(std::forward&lt;F&gt;(f)),
decay_copy(std::forward&lt;Args&gt;(args))...)</tt> with the calls to <tt>decay_copy()</tt> being evaluated in
the constructing thread. Any return value from this invocation is
ignored. [<i>Note:</i> this implies any exceptions not thrown from the
invocation of the copy of <tt>f</tt> will be thrown in the constructing thread,
not the new thread.  <i>end note</i>].
If the invocation of <tt><i>INVOKE</i>(decay_copy(std::forward&lt;F&gt;(f)),
decay_copy(std::forward&lt;Args&gt;(args))...)</tt> terminates with an uncaught
exception, <tt>std::terminate</tt> shall be called.
</ins></p>

<p>
-6- <i>Synchronization:</i> The invocation of the constructor <i>happens before</i> the
invocation of <ins>the copy of</ins> <tt>f</tt>.
</p>
</blockquote>






<hr>
<h3><a name="931"></a>931. type trait <tt>extent&lt;T, I&gt;</tt></h3>
<p><b>Section:</b> 20.7.4.3 [meta.unary.prop] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Yechezkel Mett <b>Opened:</b> 2008-11-04 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#meta.unary.prop">issues</a> in [meta.unary.prop].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The draft (N2798) says in 20.7.4.3 [meta.unary.prop] Table 44: 
</p>
<blockquote>
<table border="1">
<caption>Table 44 -- Type property queries</caption>
<tbody><tr><th>Template</th><th>Value</th></tr>
<tr>
<td>
<tt>template &lt;class T, unsigned I = 0&gt; struct extent;</tt>
</td>
<td>
If <tt>T</tt> is not an array type (8.3.4), or if it has rank less than
<tt>I</tt>, or if <tt>I</tt> is 0
and <tt>T</tt> has type "array of unknown bound of <tt>U</tt>", then 0; otherwise, the
size of the <tt>I</tt>'th dimension of <tt>T</tt>
</td>
</tr>
</tbody></table>
</blockquote>

<p>
Firstly it isn't clear from the wording if <tt>I</tt> is 0-based or 1-based 
("the <tt>I</tt>'th dimension" sort of implies 1-based). From the following 
example it is clear that the intent is 0-based, in which case it 
should say "or if it has rank less than or equal to <tt>I</tt>".
</p>
<p>
Sanity check:
</p>
<p>
The example says <tt>assert((extent&lt;int[2], 1&gt;::value) == 0);</tt>
</p>
<p>
Here the rank is 1 and <tt>I</tt> is 1, but the desired result is 0.
</p>

<p><i>[
Post Summit:
]</i></p>


<blockquote>
<p>
Do not use "size" or "value", use "bound". Also, move the
cross-reference to 8.3.4 to just after "bound".
</p>
<p>
Recommend Tentatively Ready.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
In Table 44 of 20.7.4.3 [meta.unary.prop], third row, column "Value",
change the cell content:
</p>

<blockquote>
<table border="1">
<caption>Table 44 -- Type property queries</caption>
<tbody><tr><th>Template</th><th>Value</th></tr>
<tr>
<td>
<tt>template &lt;class T, unsigned I = 0&gt; struct extent;</tt>
</td>
<td>
If <tt>T</tt> is not an array type <del>(8.3.4)</del>, or if it has rank less than
<ins> or equal to</ins> <tt>I</tt>, or if <tt>I</tt> is 0
and <tt>T</tt> has type "array of unknown bound of <tt>U</tt>", then 0; otherwise, the
<del>size</del> <ins>bound (8.3.4)</ins> of the <tt>I</tt>'th dimension of <tt>T</tt><ins>,
where indexing of <tt>I</tt> is zero-based.</ins>
</td>
</tr>
</tbody></table>
</blockquote>

<p><i>[
Wording supplied by Daniel.
]</i></p>







<hr>
<h3><a name="932"></a>932. <tt>unique_ptr(pointer p)</tt> for pointer deleter types</h3>
<p><b>Section:</b> 20.9.9.2.1 [unique.ptr.single.ctor] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2008-11-26 <b>Last modified:</b> 2010-11-19</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#unique.ptr.single.ctor">issues</a> in [unique.ptr.single.ctor].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses US 79</b></p>

<p>
20.9.9.2.1 [unique.ptr.single.ctor]/5 no longer requires for <tt>D</tt>
not to be a pointer type.  I believe this restriction was accidently removed
when we relaxed the completeness reuqirements on <tt>T</tt>. The restriction
needs to be put back in.  Otherwise we have a run time failure that could
have been caught at compile time:
</p>

<blockquote><pre>{
unique_ptr&lt;int, void(*)(void*)&gt; p1(malloc(sizeof(int)));  <font color="#C80000">// should not compile</font>
}  <font color="#C80000">// p1.~unique_ptr() dereferences a null function pointer</font>
unique_ptr&lt;int, void(*)(void*)&gt; p2(malloc(sizeof(int)), free);  <font color="#C80000">// ok</font>
</pre></blockquote>

<p><i>[
Post Summit:
]</i></p>


<blockquote>
Recommend Tentatively Ready.
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
Moved from Tentatively Ready to Open only because the wording needs to be
improved for enable_if type constraining, possibly following Robert's
formula.
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
<p>
We need to consider whether some requirements in the Requires paragraphs
of [unique.ptr] should instead be Remarks.
</p>
<p>
Leave Open. Howard to provide wording, and possibly demonstrate how this
can be implemented using enable_if.
</p>
</blockquote>

<p><i>[
2009-07-27 Howard adds:
]</i></p>


<blockquote>
<p>
The two constructors to which this issue applies are not easily constrained
with <tt>enable_if</tt> as they are not templated:
</p>

<blockquote><pre>unique_ptr();
explicit unique_ptr(pointer p);
</pre></blockquote>

<p>
To "SFINAE" these constructors away would take heroic effort such as specializing
the entire <tt>unique_ptr</tt> class template on pointer deleter types.  There
is insufficient motivation for such heroics.  Here is the expected and
reasonable implementation for these constructors:
</p>

<blockquote><pre>unique_ptr()
    : ptr_(pointer())
    {
        static_assert(!is_pointer&lt;deleter_type&gt;::value,
            "unique_ptr constructed with null function pointer deleter");
    }
explicit unique_ptr(pointer p)
    : ptr_(p)
    {
        static_assert(!is_pointer&lt;deleter_type&gt;::value,
            "unique_ptr constructed with null function pointer deleter");
    }
</pre></blockquote>

<p>
I.e. just use <tt>static_assert</tt> to verify that the constructor is not
instantiated with a function pointer for a deleter.  The compiler will automatically
take care of issuing a diagnostic if the deleter is a reference type (uninitialized
reference error).
</p>

<p>
In keeping with our discussions in Frankfurt, I'm moving this requirement on
the implementation from the Requires paragraph to a Remarks paragraph.
</p>

</blockquote>

<p><i>[
2009-08-17 Daniel adds:
]</i></p>


<blockquote>
<p>
It is insufficient to require a diagnostic. This doesn't imply an
ill-formed program
as of 1.3.6 [defns.diagnostic] (a typical alternative would be a compiler
warning), but
exactly that seems to be the intend. I suggest to use the following
remark instead:
</p>

<blockquote>
<i>Remarks:</i> The program shall be ill-formed if this constructor is
instantiated when <tt>D</tt> is a pointer type or reference type.
</blockquote>

<p>
Via the general standard rules of 1.4 [intro.compliance] the "diagnostic
required" is implied.
</p>

</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Moved to Ready.
</blockquote>

<p><i>[
2010-03-14 Howard adds:
]</i></p>


<blockquote>
We moved
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3073.html">N3073</a>
to the formal motions page in Pittsburgh which should obsolete this issue.  I've
moved this issue to NAD Editorial, solved by N3073.
</blockquote>



<p><b>Rationale:</b></p>
<p>
Solved by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3073.html">N3073</a>.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change the description of the default constructor in 20.9.9.2.1 [unique.ptr.single.ctor]:
</p>

<blockquote><pre>unique_ptr();
</pre>
<blockquote>
<p>
-1- <i>Requires:</i> <tt>D</tt> shall be default constructible, and that construction
shall not throw an exception. <del><tt>D</tt> shall 
not be a reference type or pointer type (diagnostic required).</del>
</p>
<p>...</p>
<p><ins>
<i>Remarks:</i> The program shall be ill-formed if this constructor is
instantiated when <tt>D</tt> is a pointer type or reference type.

</ins></p>
</blockquote>
</blockquote>

<p>
Add  after 20.9.9.2.1 [unique.ptr.single.ctor]/8:
</p>

<blockquote><pre>unique_ptr(pointer p);
</pre>
<blockquote>
<p>...</p>
<p><ins>
<i>Remarks:</i> The program shall be ill-formed if this constructor is
instantiated when <tt>D</tt> is a pointer type or reference type.

</ins></p>
</blockquote>
</blockquote>





<hr>
<h3><a name="934"></a>934. <tt>duration</tt> is missing <tt>operator%</tt></h3>
<p><b>Section:</b> 20.11.3 [time.duration] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Terry Golubiewski <b>Opened:</b> 2008-11-30 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#time.duration">issues</a> in [time.duration].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses US 81</b></p>

<p>
<tt>duration</tt> is missing <tt>operator%</tt>.  This operator is convenient
for computing where in a time frame a given <tt>duration</tt> lies.  A
motivating example is converting a <tt>duration</tt> into a "broken-down"
time duration such as hours::minutes::seconds:
</p>

<blockquote><pre>class ClockTime
{
    typedef std::chrono::hours hours;
    typedef std::chrono::minutes minutes;
    typedef std::chrono::seconds seconds;
public:
    hours hours_;
    minutes minutes_;
    seconds seconds_;

    template &lt;class Rep, class Period&gt;
      explicit ClockTime(const std::chrono::duration&lt;Rep, Period&gt;&amp; d)
        : hours_  (std::chrono::duration_cast&lt;hours&gt;  (d)),
          minutes_(std::chrono::duration_cast&lt;minutes&gt;(d % hours(1))),
          seconds_(std::chrono::duration_cast&lt;seconds&gt;(d % minutes(1)))
          {}
};
</pre></blockquote>

<p><i>[
Summit:
]</i></p>


<blockquote>
Agree except that there is a typo in the proposed resolution. The member
operators should be operator%=.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution.
Move to Tentatively Ready.
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
Moved from Tentatively Ready to Open only because the wording needs to be
improved for enable_if type constraining, possibly following Robert's
formula.
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
<p>
Howard to open a separate issue (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1177">1177</a>) to handle the removal of member
functions from overload sets, provide wording, and possibly demonstrate
how this can be implemented using enable_if (see <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#947">947</a>).
</p>
<p>
Move to Ready.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add to the synopsis in 20.11 [time]:
</p>

<blockquote><pre>template &lt;class Rep1, class Period, class Rep2&gt;
  duration&lt;typename common_type&lt;Rep1, Rep2&gt;::type, Period&gt;
  operator%(const duration&lt;Rep1, Period&gt;&amp; d, const Rep2&amp; s);
template &lt;class Rep1, class Period1, class Rep2, class Period2&gt;
  typename common_type&lt;duration&lt;Rep1, Period1&gt;, duration&lt;Rep2, Period2&gt;&gt;::type
  operator%(const duration&lt;Rep1, Period1&gt;&amp; lhs, const duration&lt;Rep2, Period2&gt;&amp; rhs);
</pre></blockquote>

<p>
Add to the synopsis of <tt>duration</tt> in 20.11.3 [time.duration]:
</p>

<blockquote><pre>template &lt;class Rep, class Period = ratio&lt;1&gt;&gt;
class duration {
public:
  ...
  <ins>duration&amp; operator%=(const rep&amp; rhs);</ins>
  <ins>duration&amp; operator%=(const duration&amp; d);</ins>
  ...
};
</pre></blockquote>

<p>
Add to 20.11.3.3 [time.duration.arithmetic]:
</p>

<blockquote>
<pre>duration&amp; operator%=(const rep&amp; rhs);
</pre>
<blockquote>
<p>
<i>Effects:</i> <tt>rep_ %= rhs</tt>.
</p>
<p>
<i>Returns:</i> <tt>*this</tt>.
</p>
</blockquote>

<pre>duration&amp; operator%=(const duration&amp; d);
</pre>
<blockquote>
<p>
<i>Effects:</i> <tt>rep_ %= d.count()</tt>.
</p>
<p>
<i>Returns:</i> <tt>*this</tt>.
</p>
</blockquote>
</blockquote>

<p>
Add to 20.11.3.5 [time.duration.nonmember]:
</p>

<blockquote>

<pre>template &lt;class Rep1, class Period, class Rep2&gt;
  duration&lt;typename common_type&lt;Rep1, Rep2&gt;::type, Period&gt;
  operator%(const duration&lt;Rep1, Period&gt;&amp; d, const Rep2&amp; s);
</pre>
<blockquote>
<p>
<i>Requires:</i> <tt>Rep2</tt> shall be implicitly convertible to <tt>CR(Rep1, Rep2)</tt> and
<tt>Rep2</tt> shall not be an instantiation of <tt>duration</tt>. Diagnostic required.
</p>
<p>
<i>Returns:</i> <tt>duration&lt;CR, Period&gt;(d) %= s</tt>.
</p>
</blockquote>

<pre>template &lt;class Rep1, class Period1, class Rep2, class Period2&gt;
  typename common_type&lt;duration&lt;Rep1, Period1&gt;, duration&lt;Rep2, Period2&gt;&gt;::type
  operator%(const duration&lt;Rep1, Period1&gt;&amp; lhs, const duration&lt;Rep2, Period2&gt;&amp; rhs);
</pre>
<blockquote>
<p>
<i>Returns:</i> <tt>common_type&lt;duration&lt;Rep1, Period1&gt;, duration&lt;Rep2, Period2&gt;&gt;::type(lhs) %= rhs</tt>.
</p>
</blockquote>

</blockquote>






<hr>
<h3><a name="938"></a>938. <tt>default_delete&lt;T[]&gt;::operator()</tt> should only accept <tt>T*</tt></h3>
<p><b>Section:</b> 20.9.9.1.3 [unique.ptr.dltr.dflt1] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2008-12-07 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Consider:
</p>

<blockquote><pre>derived* p = new derived[3];
std::default_delete&lt;base[]&gt; d;
d(p);  <font color="#C80000">// should fail</font>
</pre></blockquote>

<p>
Currently the marked line is a run time failure.  We can make it a compile
time failure by "poisoning" <tt>op(U*)</tt>.
</p>

<p><i>[
Post Summit:
]</i></p>


<blockquote>
Recommend Review.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution.
Move to Tentatively Ready.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Add to 20.9.9.1.3 [unique.ptr.dltr.dflt1]:
</p>

<blockquote><pre>namespace std {
  template &lt;class T&gt; struct default_delete&lt;T[]&gt; {
    void operator()(T*) const;
  <ins>template &lt;class U&gt; void operator()(U*) const = delete;</ins>
};
}
</pre></blockquote>





<hr>
<h3><a name="939"></a>939. Problem with <tt>std::identity</tt> and reference-to-temporaries</h3>
<p><b>Section:</b> 20.3.3 [forward] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2008-12-11 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#forward">issues</a> in [forward].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>std::identity</tt> takes an argument of type <tt>T const &amp;</tt>
and returns a result of <tt>T const &amp;</tt>.
</p>
<p>
Unfortunately, this signature will accept a value of type other than <tt>T</tt> that
is convertible-to-<tt>T</tt>, and then return a reference to the dead temporary.  The
constraint in the concepts version simply protects against returning
reference-to-<tt>void</tt>.
</p>
<p>
Solutions:
</p>
<blockquote>
<p>
i/  Return-by-value, potentially slicing bases and rejecting non-copyable
types
</p>
<p>
ii/ Provide an additional overload:
</p>
<blockquote><pre>template&lt; typename T &gt;
template operator( U &amp; ) = delete;
</pre></blockquote>
<p>
This seems closer on intent, but moves beyond the original motivation for
the operator, which is compatibility with existing (non-standard)
implementations.
</p>
<p>
iii/ Remove the <tt>operator()</tt> overload.  This restores the original definition
of the <tt>identity</tt>, although now effectively a type_trait rather than part of
the perfect forwarding protocol.
</p>
<p>
iv/ Remove <tt>std::identity</tt> completely; its original reason to exist is
replaced with the <tt>IdentityOf</tt> concept.
</p>
</blockquote>
<p>
My own preference is somewhere between (ii) and (iii) - although I stumbled
over the issue with a specific application hoping for resolution (i)!
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We dislike options i and iii, and option ii seems like overkill.
If we remove it (option iv), implementers can still provide it under a
different name.
</p>
<p>
Move to Open pending wording (from Alisdair) for option iv.
</p>
</blockquote>

<p><i>[
2009-05-23 Alisdair provided wording for option iv.
]</i></p>


<p><i>[
2009-07-20 Alisdair adds:
]</i></p>


<blockquote>
<p>
I'm not sure why this issue was not discussed at Frankfurt (or I missed
the discussion) but the rationale is now fundamentally flawed.  With the
removal of concepts, <tt>std::identity</tt> again becomes an important library
type so we cannot simply remove it.
</p>
<p>
At that point, we need to pick one of the other suggested resolutions,
but have no guidance at the moment.
</p>
</blockquote>

<p><i>[
2009-07-20 Howard adds:
]</i></p>


<blockquote>
<p>
I believe the rationale for not addressing this issue in Frankfurt was that it did
not address a national body comment.
</p>
<p>
I also believe that removal of <tt>identity</tt> is still a practical option as
my latest reformulation of <tt>forward</tt>, which is due to comments suggested
at Summit, no longer uses <tt>identity</tt>. :-)
</p>

<blockquote><pre>template &lt;class T, class U,
    class = typename enable_if
            &lt;
                !is_lvalue_reference&lt;T&gt;::value || 
                 is_lvalue_reference&lt;T&gt;::value &amp;&amp;
                 is_lvalue_reference&lt;U&gt;::value
            &gt;::type,
    class = typename enable_if
            &lt;
                is_same&lt;typename remove_all&lt;T&gt;::type,
                        typename remove_all&lt;U&gt;::type&gt;::value
            &gt;::type&gt;
inline
T&amp;&amp;
forward(U&amp;&amp; t)
{
    return static_cast&lt;T&amp;&amp;&gt;(t);

}
</pre>

<p><i>[
The above code assumes acceptance of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1120">1120</a> for the definition of
<tt>remove_all</tt>.  This is just to make the syntax a little more palatable.
Without this trait the above is still very implementable.
]</i></p>


</blockquote>

<p>
Paper with rationale is on the way ... <i>really</i>, I promise this time! ;-)
</p>
</blockquote>

<p><i>[
2009-07-30 Daniel adds:  See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#823">823</a> for an alternative resolution.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Move to Ready. Howard will update proposed wording to reflect current draft.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Strike from 20.3 [utility]:
</p>

<blockquote><pre><del>template &lt;class T&gt; struct identity;</del>
</pre></blockquote>

<p>
Remove from 20.3.3 [forward]:
</p>

<blockquote>
<pre><del>template &lt;class T&gt; struct identity {
  typedef T type;

  const T&amp; operator()(const T&amp; x) const;
};</del>

<del>const T&amp; operator()(const T&amp; x) const;</del>
</pre>
<blockquote>
<del>-2-  <i>Returns:</i> <tt>x</tt></del>
</blockquote>
</blockquote>






<hr>
<h3><a name="943"></a>943. <tt>ssize_t</tt> undefined</h3>
<p><b>Section:</b> 29.5.2 [atomics.types.address] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Holger Grund <b>Opened:</b> 2008-12-19 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#atomics.types.address">issues</a> in [atomics.types.address].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There is a row in "Table 122 - Atomics for standard typedef types"
in 29.5.1 [atomics.types.integral] with <tt>atomic_ssize_t</tt>
and <tt>ssize_t</tt>. Unless, I'm missing something <tt>ssize_t</tt>
is not defined by the standard.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Move to review. Proposed resolution: Remove the typedef. Note: ssize_t
is a POSIX type.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution.
Move to Tentatively Ready.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Remove the row containing <tt>ssize_t</tt> from Table 119
"Atomics for standard typedef types" in 29.5.2 [atomics.types.address].
</p>





<hr>
<h3><a name="947"></a>947. duration arithmetic: contradictory requirements</h3>
<p><b>Section:</b> 20.11.3.5 [time.duration.nonmember] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2008-12-20 <b>Last modified:</b> 2010-11-20</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#time.duration.nonmember">issues</a> in [time.duration.nonmember].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 20.11.3.5 [time.duration.nonmember], paragraph 8 says that calling
<tt>dur / rep</tt>
when <tt>rep</tt> is an instantiation of <tt>duration</tt> requires a diagnostic.
That's followed by an <tt>operator/</tt> that takes two durations.
So <tt>dur1 / dur2</tt> is legal under the second version,
but requires a diagnostic under the first.
</p>

<p><i>[
Howard adds:
]</i></p>


<blockquote>
Please see the thread starting with c++std-lib-22980 for more information.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Move to Open, pending proposed wording (and preferably an implementation).
</blockquote>

<p><i>[
2009-07-27 Howard adds:
]</i></p>


<blockquote>
<p>
I've addressed this issue under the proposed wording for <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1177">1177</a> which
cleans up several places under 20.11.3 [time.duration] which used the
phrase "diagnostic required".
</p>
<p>
For clarity's sake, here is an example implementation of the constrained <tt>operator/</tt>:
</p>

<blockquote><pre>template &lt;class _Duration, class _Rep, bool = __is_duration&lt;_Rep&gt;::value&gt;
struct __duration_divide_result
{
};

template &lt;class _Duration, class _Rep2,
    bool = is_convertible&lt;_Rep2,
                          typename common_type&lt;typename _Duration::rep, _Rep2&gt;::type&gt;::value&gt;
struct __duration_divide_imp
{
};

template &lt;class _Rep1, class _Period, class _Rep2&gt;
struct __duration_divide_imp&lt;duration&lt;_Rep1, _Period&gt;, _Rep2, true&gt;
{
    typedef duration&lt;typename common_type&lt;_Rep1, _Rep2&gt;::type, _Period&gt; type;
};

template &lt;class _Rep1, class _Period, class _Rep2&gt;
struct __duration_divide_result&lt;duration&lt;_Rep1, _Period&gt;, _Rep2, false&gt;
    : __duration_divide_imp&lt;duration&lt;_Rep1, _Period&gt;, _Rep2&gt;
{
};

template &lt;class _Rep1, class _Period, class _Rep2&gt;
inline
typename __duration_divide_result&lt;duration&lt;_Rep1, _Period&gt;, _Rep2&gt;::type
operator/(const duration&lt;_Rep1, _Period&gt;&amp; __d, const _Rep2&amp; __s)
{
    typedef typename common_type&lt;_Rep1, _Rep2&gt;::type _Cr;
    duration&lt;_Cr, _Period&gt; __r = __d;
    __r /= static_cast&lt;_Cr&gt;(__s);
    return __r;
}
</pre></blockquote>

<p>
<tt>__duration_divide_result</tt> is basically a custom-built <tt>enable_if</tt>
that will contain <tt>type</tt> only if <tt>Rep2</tt> is not a <tt>duration</tt>
and if <tt>Rep2</tt> is implicitly convertible to
<tt>common_type&lt;typename Duration::rep, Rep2&gt;::type</tt>. <tt>__is_duration</tt>
is simply a private trait that answers <tt>false</tt>, but is specialized for
<tt>duration</tt> to answer <tt>true</tt>.
</p>

<p>
The constrained <tt>operator%</tt> works identically.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Mark <del>NAD Editorial</del><ins>Resolved</ins>, fixed by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1177">1177</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="948"></a>948. <tt>ratio</tt> arithmetic tweak</h3>
<p><b>Section:</b> 20.6.2 [ratio.arithmetic] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2008-12-26 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#ratio.arithmetic">issues</a> in [ratio.arithmetic].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2800.pdf">N2800</a>,
20.6.2 [ratio.arithmetic] lacks a paragraph from the proposal
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2661.htm">N2661</a>:
</p>

<blockquote>
<p><b>ratio arithmetic [ratio.arithmetic]</b></p>

<p>
... If the implementation is unable to form the indicated <tt>ratio</tt> due to
overflow, a diagnostic shall be issued.
</p>
</blockquote>

<p>
The lack of a diagnostic on compile-time overflow is a significant lack of
functionality.  This paragraph could be put back into the WP simply editorially.
However in forming this issue I realized that we can do better than that.  This
paragraph should also allow alternative formulations which go to extra lengths
to avoid overflow when possible.  I.e. we should not mandate overflow when the
implementation can avoid it.
</p>

<p>
For example:
</p>

<blockquote>
<pre>template &lt;class R1, class R2&gt; struct ratio_multiply {
  typedef <i>see below</i>} type; 
</pre>

<blockquote>
The nested typedef type shall be a synonym for <tt>ratio&lt;T1, T2&gt;</tt> where
<tt>T1</tt> has the value <tt>R1::num * R2::num</tt> and <tt>T2</tt> has the
value <tt>R1::den * R2::den</tt>.
</blockquote>

</blockquote>

<p>
Consider the case where <tt>intmax_t</tt> is a 64 bit 2's complement signed integer,
and we have:
</p>

<blockquote><pre>typedef std::ratio&lt;0x7FFFFFFFFFFFFFFF, 0x7FFFFFFFFFFFFFF0&gt; R1;
typedef std::ratio&lt;8, 7&gt; R2;
typedef std::ratio_multiply&lt;R1, R2&gt;::type RT;
</pre></blockquote>

<p>
According to the present formulation the implementaiton will multiply
<tt>0x7FFFFFFFFFFFFFFF * 8</tt> which will result in an overflow and subsequently
require a diagnostic.
</p>

<p>
However if the implementation is first allowed to divde <tt>0x7FFFFFFFFFFFFFFF</tt>
by <tt>7</tt> obtaining <tt>0x1249249249249249 / 1</tt> and divide
<tt>8</tt> by <tt>0x7FFFFFFFFFFFFFF0</tt> obtaining <tt>1 / 0x0FFFFFFFFFFFFFFE</tt>,
then the exact result can then be computed without overflow:
</p>

<blockquote><pre>[0x7FFFFFFFFFFFFFFF/0x7FFFFFFFFFFFFFF0] * [8/7] = [0x1249249249249249/0x0FFFFFFFFFFFFFFE]
</pre></blockquote>

<p>
Example implmentation which accomplishes this:
</p>

<blockquote><pre>template &lt;class R1, class R2&gt;
struct ratio_multiply
{
private:
    typedef ratio&lt;R1::num, R2::den&gt; _R3;
    typedef ratio&lt;R2::num, R1::den&gt; _R4;
public:
    typedef ratio&lt;__ll_mul&lt;_R3::num, _R4::num&gt;::value,
                  __ll_mul&lt;_R3::den, _R4::den&gt;::value&gt; type;
};
</pre></blockquote>

<p><i>[
Post Summit:
]</i></p>


<blockquote>
Recommend Tentatively Ready.
</blockquote>




<p><b>Proposed resolution:</b></p>
<p>
Add a paragraph prior to p1 in 20.6.2 [ratio.arithmetic]:
</p>

<blockquote>
Implementations may use other algorithms to compute the indicated ratios to avoid overflow. 
If overflow occurs, a diagnostic shall be issued.
</blockquote>





<hr>
<h3><a name="949"></a>949. <tt>owner_less</tt></h3>
<p><b>Section:</b> 20.9.10.3.7 [util.smartptr.ownerless] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Thomas Plum <b>Opened:</b> 2008-12-30 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
20.9.10.3.7 [util.smartptr.ownerless] (class template <tt>owner_less</tt>) says that 
<tt>operator()(x,y)</tt> shall return <tt>x.before(y)</tt>.
</p>
<p>
However, <tt>shared_ptr</tt> and <tt>weak_ptr</tt> have an <tt>owner_before()</tt> but not a
<tt>before()</tt>, and there's no base class to provide a missing <tt>before()</tt>.
</p>
<p>
Being that the class is named  <tt>owner_less</tt> , I'm guessing that
"<tt>before()</tt>" should be "<tt>owner_before()</tt>", right?
</p>

<p><i>[
Herve adds:
]</i></p>


<blockquote>
Agreed with the typo, it should be "shall return <tt>x.owner_before(y)</tt>".
</blockquote>

<p><i>[
Post Summit:
]</i></p>


<blockquote>
Recommend Tentatively Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 20.9.10.3.7 [util.smartptr.ownerless] p2:
</p>

<blockquote>
-2- <tt>operator()(x,y)</tt> shall return
<tt>x.<ins>owner_</ins>before(y)</tt>. [<i>Note:</i> ...
</blockquote>





<hr>
<h3><a name="950"></a>950. unique_ptr converting ctor shouldn't accept array form</h3>
<p><b>Section:</b> 20.9.9.2.1 [unique.ptr.single.ctor] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-01-07 <b>Last modified:</b> 2010-11-19</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#unique.ptr.single.ctor">issues</a> in [unique.ptr.single.ctor].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>unique_ptr</tt>'s of array type should not convert to
<tt>unique_ptr</tt>'s which do not have an array type.
</p>

<blockquote><pre>struct Deleter
{
   void operator()(void*) {}
};

int main()
{
   unique_ptr&lt;int[], Deleter&gt; s;
   unique_ptr&lt;int, Deleter&gt; s2(std::move(s));  <font color="#C80000">// should not compile</font>
}
</pre></blockquote>

<p><i>[
Post Summit:
]</i></p>


<blockquote>
<p>
Walter: Does the "diagnostic required" apply to both arms of the "and"?
</p>
<p>
Tom Plum: suggest to break into several sentences
</p>
<p>
Walter: suggest "comma" before the "and" in both places
</p>
<p>
Recommend Review.
</p>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
The post-Summit comments have been applied to the proposed resolution.
We now agree with the proposed resolution.
Move to Tentatively Ready.
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
Moved from Tentatively Ready to Open only because the wording needs to be
improved for enable_if type constraining, possibly following Robert's
formula.
</blockquote>

<p><i>[
2009-08-01 Howard updates wording and sets to Review.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Move to Ready.
</blockquote>

<p><i>[
2010-02-27 Pete Opens:
]</i></p>


<blockquote>
<p>
The proposed replacement text doesn't make sense.
</p>

<blockquote>
If <tt>D</tt> is a reference type, then <tt>E</tt> shall be the same type as
<tt>D</tt>, else this constructor shall not participate in overload resolution.
</blockquote>

<p>
This imposes two requirements. 1. If <tt>D</tt> is a reference type, <tt>E</tt>
has to be <tt>D</tt>. 2. If <tt>D</tt> is not a reference type, the constructor
shall not participate in overload resolution. If the latter apples, the language
in the preceding paragraph that this constructor shall not throw an exception if
<tt>D</tt> is not a reference type is superfluous. I suspect that's not the
intention, but I can't parse this text any other way.
</p>

<blockquote>
<tt>U</tt> shall not be an array type, else this constructor shall not
participate in overload resolution.
</blockquote>

<p>
I don't know what this means.
</p>
</blockquote>

<p><i>[
2010-02-27 Peter adds:
]</i></p>


<blockquote>
<p>
I think that the intent is (proposed text):
</p>

<blockquote>
<p>
<i>Remarks:</i> this constructor shall only participate in overload resolution
if:
</p>

<ul>
<li>
<tt>unique_ptr&lt;U, E&gt;::pointer</tt> is implicitly convertible to
<tt>pointer</tt>,
</li>

<li>
<tt>U</tt> is not an array type, and
</li>

<li>
if <tt>D</tt> is a reference type, <tt>E</tt> is the same type as <tt>D</tt>.
</li>
</ul>

</blockquote>

</blockquote>

<p><i>[
2010-02-28 Howard adds:
]</i></p>


<blockquote>
<p>
I like Peter's proposal.  Here is a tweak of it made after looking at my
implementation.  I believe this fixes a further defect not addressed by the
current proposed wording:
</p>

<blockquote>
<p>
<i>Remarks:</i> this constructor shall only participate in overload resolution
if:
</p>

<ul>
<li>
<tt>unique_ptr&lt;U, E&gt;::pointer</tt> is implicitly convertible to
<tt>pointer</tt>, and
</li>

<li>
<tt>U</tt> is not an array type, and
</li>

<li>
if <tt>D</tt> is a reference type, <tt>E</tt> is the same type as <tt>D</tt>,
else <tt>E</tt> shall be implicitly convertible to <tt>D</tt>.
</li>
</ul>

</blockquote>

</blockquote>

<p><i>[
2010 Pittsburgh:  Moved to NAD Editorial.  Rationale added below.
]</i></p>




<p><b>Rationale:</b></p>
<p>
Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3073.html">N3073</a>.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change 20.9.9.2.1 [unique.ptr.single.ctor]:
</p>

<blockquote>
<pre>template &lt;class U, class E&gt; unique_ptr(unique_ptr&lt;U, E&gt;&amp;&amp; u);
</pre>
<blockquote>
<p>
-20- <i>Requires:</i> If <tt>D</tt> is not a reference type,
construction of the deleter <tt>D</tt> from an rvalue of type <tt>E</tt>
shall be well formed and shall not throw an exception. <del>If <tt>D</tt> is
a reference type, then <tt>E</tt> shall be the same type as <tt>D</tt>
(diagnostic required). <tt>unique_ptr&lt;U, E&gt;::pointer</tt> shall be
implicitly convertible to <tt>pointer</tt>. [<i>Note:</i> These requirements
imply that <tt>T</tt> and <tt>U</tt> are complete types.  <i>end note</i>]</del>
</p>

<p><ins>
<i>Remarks:</i> If <tt>D</tt> is
a reference type, then <tt>E</tt> shall be the same type as <tt>D</tt>, else this
constructor shall not participate in overload resolution. <tt>unique_ptr&lt;U, E&gt;::pointer</tt> shall be
implicitly convertible to <tt>pointer</tt>, else this
constructor shall not participate in overload resolution. <tt>U</tt> shall not be
an array type, else this
constructor shall not participate in overload resolution. [<i>Note:</i> These requirements
imply that <tt>T</tt> and <tt>U</tt> are complete types.  <i>end note</i>]
</ins></p>

</blockquote>
</blockquote>

<p>
Change 20.9.9.2.3 [unique.ptr.single.asgn]:
</p>

<blockquote>
<pre>template &lt;class U, class E&gt; unique_ptr&amp; operator=(unique_ptr&lt;U, E&gt;&amp;&amp; u);
</pre>
<blockquote>
<p>
-6- <i>Requires:</i> Assignment of the deleter <tt>D</tt> from an rvalue
<tt>D</tt> shall not throw an exception. <del><tt>unique_ptr&lt;U,
E&gt;::pointer</tt> shall be implicitly convertible to <tt>pointer</tt>.
[<i>Note:</i> These requirements imply that <tt>T</tt> and <tt>U</tt>
are complete types.  <i>end note</i>]</del>
</p>

<p><ins>
<i>Remarks:</i> <tt>unique_ptr&lt;U,
E&gt;::pointer</tt> shall be implicitly convertible to <tt>pointer</tt>, else this
operator shall not participate in overload resolution.
<tt>U</tt> shall not be an array type, else this
operator shall not participate in overload resolution.
[<i>Note:</i> These requirements imply that <tt>T</tt> and <tt>U</tt>
are complete types.  <i>end note</i>]
</ins></p>

</blockquote>
</blockquote>






<hr>
<h3><a name="951"></a>951. Various threading bugs #1</h3>
<p><b>Section:</b> 20.11.2.1 [time.traits.is_fp] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2009-01-07 <b>Last modified:</b> 2010-11-24</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Related to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#953">953</a>.
</p>

<p>
20.11.2.1 [time.traits.is_fp] says that the type <tt>Rep</tt> "is
assumed to be ... a class emulating an integral type." What are the
requirements for such a type?
</p>
<p><i>[
2009-05-10 Howard adds:
]</i></p>


<blockquote>
<tt>IntegralLike</tt>.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
As with issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#953">953</a>,
we recommend this issue be addressed in the context of providing concepts for the entire <tt>thread</tt> header.
</p>
<p>
We look forward to proposed wording.
</p>
<p>
Move to Open.
</p>
</blockquote>

<p><i>[
2009-08-01 Howard adds:
]</i></p>


<blockquote>
<p>
I have surveyed all clauses of 20.11.2.2 [time.traits.duration_values],
20.11.2.3 [time.traits.specializations] and 20.11.3 [time.duration].
I can not find any clause which involves the use of a <tt>duration::rep</tt> type
where the requirements on the <tt>rep</tt> type are not clearly spelled out.
These requirements were carefully crafted to allow any arithmetic type, or
any user-defined type emulating an arithmetic type.
</p>

<p>
Indeed, <tt>treat_as_floating_point</tt>
becomes completely superfluous if <tt>duration::rep</tt> can never be a class type.
</p>

<p>
There will be some <tt>Rep</tt> types which will not meet the requirements of
<em>every</em> <tt>duration</tt> operation.  This is no different than the fact
that <tt>vector&lt;T&gt;</tt> can easily be used for types <tt>T</tt> which are
not <tt>DefaultConstructible</tt>, even though some members of <tt>vector&lt;T&gt;</tt>
require <tt>T</tt> to be <tt>DefaultConstructible</tt>.  This is why the requirements
on <tt>Rep</tt> are specified for each operation individually.
</p>

<p>
In 20.11.2.1 [time.traits.is_fp] p1:
</p>

<blockquote><pre>template &lt;class Rep&gt; struct treat_as_floating_point 
  : is_floating_point&lt;Rep&gt; { };
</pre>

<blockquote>
The <tt>duration</tt> template uses the <tt>treat_as_floating_point</tt> trait to help
determine if a <tt>duration</tt> object can be converted to another <tt>duration</tt>
with a different tick period. If <tt>treat_as_floating_point&lt;Rep&gt;::value</tt> is
<tt>true</tt>, then <tt>Rep</tt> is a floating-point type and implicit conversions are
allowed among <tt>duration</tt>s. Otherwise, the implicit convertibility depends
on the tick periods of the <tt>duration</tt>s. If <tt>Rep</tt> is <u>a class type which
emulates a floating-point type</u>, the author of <tt>Rep</tt> can specialize
<tt>treat_as_floating_point</tt> so that <tt>duration</tt> will treat this <tt>Rep</tt> as if it
were a floating-point type. Otherwise <tt>Rep</tt> is assumed to be an integral
type or <u>a class emulating an integral type</u>.
</blockquote>
</blockquote>

<p>
The phrases "a class type which emulates a floating-point type" and
"a class emulating an integral type" are clarifying phrases which refer to
the summation of all the requirements on the <tt>Rep</tt> type specified in
detail elsewhere (and <em>should not</em> be repeated here).
</p>

<p>
This specification has been implemented, now multiple times, and the experience
has been favorable.  The current specification clearly specifies the requirements
at each point of use (though I'd be happy to fix any place I may have missed,
but none has been pointed out).
</p>

<p>
I am amenable to improved wording of this paragraph (and any others), but do not have any
suggestions for improved wording at this time.  I am <em>strongly</em> opposed to
changes which would significantly alter the semantics of the
specification under 20.11 [time] without firmly grounded and
documented rationale, example implementation, testing, and user
experience which relates a positive experience.
</p>

<p>
I recommend NAD unless someone wants to produce some clarifying wording.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Stefanus to provide wording to turn this into a note.
</blockquote>

<p><i>[
2010-02-11 Stefanus provided wording.
]</i></p>



<p><i>[
2010 Rapperswil:
]</i></p>


<blockquote>
Move to Ready.
</blockquote>

<p><i>[
Adopted at 2010-11 Batavia
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
Change 20.11.2.1 [time.traits.is_fp]/1:
</p>

<blockquote>
1 The <tt>duration</tt> template uses the <tt>treat_as_floating_point</tt> trait
to help determine if a <tt>duration</tt> object can be converted to another
<tt>duration</tt> with a different tick period. If
<tt>treat_as_floating_point&lt;Rep&gt;::value</tt> is <tt>true</tt>, then
<del><tt>Rep</tt> is a floating-point type and</del> implicit conversions are allowed among
<tt>duration</tt>s. Otherwise, the implicit convertibility depends on the tick
periods of the <tt>duration</tt>s. <del>If <tt>Rep</tt> is a class type which
emulates a floating-point type, the author of <tt>Rep</tt> can specialize
<tt>treat_as_floating_point</tt> so that duration will treat this <tt>Rep</tt>
as if it were a floating-point type. Otherwise <tt>Rep</tt> is assumed to be an
integral type or a class emulating an integral type.</del>
<ins>[<i>Note:</i> The intention of this trait is to indicate whether a given
class behaves like a floating point type, and thus allows division of one value
by another with acceptable loss of precision. If
<tt>treat_as_floating_point&lt;Rep&gt;::value</tt> is <tt>false</tt>,
<tt>Rep</tt> will be treated as if it behaved like an integral type for the
purpose of these conversions.  <i>end note</i>]</ins>
</blockquote>






<hr>
<h3><a name="953"></a>953. Various threading bugs #3</h3>
<p><b>Section:</b> 20.11.1 [time.clock.req] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2009-01-07 <b>Last modified:</b> 2010-11-20</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#time.clock.req">issues</a> in [time.clock.req].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Related to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#951">951</a>.
</p>

<p>
20.11.1 [time.clock.req] says that a clock's <tt>rep</tt> member is "an
arithmetic type or a class emulating an arithmetic type." What are the
requirements for such a type?
</p>

<p><i>[
2009-05-10 Howard adds:
]</i></p>


<blockquote>
This wording was aimed directly at the <tt>ArithmeticLike</tt> concept.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We recommend this issue be addressed in the context of providing concepts
for the entire <tt>thread</tt> header.
</p>
<p>
May resolve for now by specifying arithmetic types,
and in future change to <tt>ArithmeticLike</tt>.
However, Alisdair believes this is not feasible.
</p>
<p>
Bill disagrees.
</p>
<p>
We look forward to proposed wording.  Move to Open.
</p>
</blockquote>

<p><i>[
2009-08-01 Howard adds:
]</i></p>


<blockquote>
See commented dated 2009-08-01 in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#951">951</a>.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Stefanus to provide wording to turn this into a note.
</blockquote>

<p><i>[
2010-02-11 Stephanus provided wording for <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#951">951</a> which addresses
this issue as well.
]</i></p>



<p><i>[
2010 Rapperswil:
]</i></p>


<blockquote>
Move to <del>NAD Editorial</del><ins>Resolved</ins>, resolved by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#951">951</a>.
</blockquote>




<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="954"></a>954. Various threading bugs #4</h3>
<p><b>Section:</b> 20.11.1 [time.clock.req] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2009-01-07 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#time.clock.req">issues</a> in [time.clock.req].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Table 55 -- Clock Requirements (in 20.11.1 [time.clock.req])
</p>

<ol type="a">
<li>
the requirements for <tt>C1::time_point</tt> require <tt>C1</tt> and <tt>C2</tt>
to "refer to the same epoch", but "epoch" is not defined.
</li>
<li>
"Different clocks may share a <tt>time_point</tt> definition if it is
valid to compare their <tt>time_point</tt>s by comparing their
respective <tt>duration</tt>s." What does "valid" mean here? And, since
<tt>C1::rep</tt> is "**THE** representation type of the native
<tt>duration</tt> and <tt>time_point</tt>" (emphasis added), there
doesn't seem to be much room for some other representation.
</li>
<li>
<tt>C1::is_monotonic</tt> has type "<tt>const bool</tt>". The
"<tt>const</tt>" should be removed.
</li>
<li>
<tt>C1::period</tt> has type <tt>ratio</tt>. <tt>ratio</tt> isn't a type, 
it's a template. What is the required type?
</li>
</ol>

<p><i>[
2009-05-10 Howard adds:
]</i></p>


<ol type="a">
<li>
<p>
"epoch" is purposefully not defined beyond the common English
<a href="http://www.dictionary.net/epoch">definition</a>.  The C standard
also chose not to define epoch, though POSIX did.  I believe it is a strength
of the C standard that epoch is not defined.  When it is known that two <tt>time_point</tt>s
refer to the same epoch, then a definition of the epoch is not needed to compare
the two <tt>time_point</tt>s, or subtract them.
</p>
<p>
A <tt>time_point</tt> and a <tt>Clock</tt> implicitly refer to an (unspecified) epoch.
The <tt>time_point</tt> represents an offset (<tt>duration</tt>) from an epoch.
</p>
</li>
<li>
<p>
The sentence:
</p>
<blockquote>
Different clocks 
may share a <tt>time_point</tt>
definition if it is valid to 
compare their <tt>time_point</tt>s by 
comparing their respective 
<tt>duration</tt>s.
</blockquote>

<p>
is redundant and could be removed.  I believe the sentence which follows the above:
</p>

<blockquote>
<tt>C1</tt> and <tt>C2</tt> shall refer to the same epoch.
</blockquote>

<p>
is sufficient.  If two clocks share the same epoch, then by definition, comparing
their <tt>time_point</tt>s is valid.
</p>
</li>
<li>
<tt>is_monotonic</tt> is meant to never change (be <tt>const</tt>).  It is also
desired that this value be usable in compile-time computation and branching.
</li>
<li>
<p>
This should probably instead be worded:
</p>
<blockquote>
An instantiation of <tt>ratio</tt>.
</blockquote>
</li>
</ol>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Re (a): It is not clear to us whether "epoch" is a term of art.
</p>
<p>
Re (b), (c), and (d):  We agree with Howard's comments,
and would consider adding to (c) a <tt>static constexpr</tt> requirement.
</p>
<p>
Move to Open pending proposed wording.
</p>
</blockquote>

<p><i>[
2009-05-25 Daniel adds:
]</i></p>


<blockquote>
In regards to (d) I suggest to say "a specialization of ratio" instead of
"An instantiation of ratio". This seems to be the better matching standard
core language term for this kind of entity.
</blockquote>

<p><i>[
2009-05-25 Ganesh adds:
]</i></p>


<blockquote>
<p>
Regarding (a), I found this paper on the ISO website using the term "epoch" consistently with the current wording:
</p>

<p>
<a href="http://standards.iso.org/ittf/PubliclyAvailableStandards/C030811e_FILES/MAIN_C030811e/text/ISOIEC_18026E_TEMPORAL_CS.HTM">http://standards.iso.org/ittf/PubliclyAvailableStandards/C030811e_FILES/MAIN_C030811e/text/ISOIEC_18026E_TEMPORAL_CS.HTM</a>
</p>
<p>
which is part of ISO/IEC 18026 "Information technology -- Spatial Reference Model (SRM)".
</p>
</blockquote>

<p><i>[
2009-08-01 Howard: Moved to Reivew as the wording requested in Batavia has been provided.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Move to Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>
<ol type="a">
<li>
<p>
Change 20.11.1 [time.clock.req] p1:
</p>
<blockquote>
-1- A clock is a bundle consisting of a native <tt>duration</tt>, a native <tt>time_point</tt>, and a function <tt>now()</tt> to get the 
current <tt>time_point</tt>.  <ins>The origin of the clock's <tt>time_point</tt> is referred to as the clock's <i>epoch</i> as defined in 
section 6.3 of ISO/IEC 18026.</ins>
A clock shall meet the requirements in Table 45.
</blockquote>
</li>
<li>
<p>
Remove the sentence from the <tt>time_point</tt> row of the table "Clock Requirements":
</p>
<table border="1">
<caption>Clock requirements</caption>
<tbody><tr>
<td>
<tt>C1::time_point</tt>
</td>
<td>
<tt>chrono::time_point&lt;C1&gt;</tt> or <tt>chrono::time_point&lt;C2, C1::duration&gt;</tt>
</td>
<td>
The native <tt>time_point</tt> type of the clock.
<del>Different clocks may share a <tt>time_point</tt> definition if it is valid to compare their <tt>time_point</tt>s by comparing their respective <tt>duration</tt>s.</del>
<tt>C1</tt> and <tt>C2</tt> shall refer to the same epoch.
</td>
</tr>
</tbody></table>
</li>
</ol>
<ol type="a" start="4">
<li>
<p>
Change the row starting with <tt>C1::period</tt> of the table "Clock Requirements":
</p>
<table border="1">
<caption>Clock requirements</caption>
<tbody><tr>
<td>
<tt>C1::period</tt>
</td>
<td>
<ins>a specialization of</ins> <tt>ratio</tt>
</td>
<td>
The tick period of the clock in seconds.
</td>
</tr>
</tbody></table>

</li>
</ol>





<hr>
<h3><a name="956"></a>956. Various threading bugs #6</h3>
<p><b>Section:</b> 20.11.1 [time.clock.req] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2009-01-07 <b>Last modified:</b> 2010-11-24</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#time.clock.req">issues</a> in [time.clock.req].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
20.11.1 [time.clock.req] uses the word "native" in several places,
but doesn't define it. What is a "native <tt>duration</tt>"?
</p>

<p><i>[
2009-05-10 Howard adds:
]</i></p>


<blockquote>
The standard uses "native" in several places without defining it (e.g.
2.14.3 [lex.ccon]).  It is meant to mean "that which is defined
by the facility", or something along those lines.  In this case it refers
to the nested <tt>time_point</tt> and <tt>duration</tt> types of the clock.
Better wording is welcome.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Move to Open pending proposed wording from Pete.
</blockquote>

<p><i>[
2009-10-23 Pete provides wording:
]</i></p>


<p><i>[
2009-11-18 Daniel adds:
]</i></p>


<blockquote>
<p>
I see that 30.4.1.3 [thread.timedmutex.requirements]/3 says:
</p>

<blockquote>
<i>Precondition:</i> If the tick <tt>period</tt> of <tt>rel_time</tt> is not
exactly convertible to the native tick <tt>period</tt>, the <tt>duration</tt>
shall be rounded up to the nearest native tick <tt>period</tt>.
</blockquote>

<p>
I would prefer to see that adapted as well. Following the same style as
the proposed resolution I come up with
</p>

<blockquote>
<i>Precondition:</i> If the tick <tt>period</tt> of <tt>rel_time</tt> is not
exactly convertible to the <del>native</del> tick <tt>period</tt> <ins>of the
execution environment</ins>, the <tt>duration</tt> shall be rounded up to the
nearest <del>native</del> tick <tt>period</tt> <ins>of the execution
environment</ins>.
</blockquote>

</blockquote>

<p><i>[
2010-03-28 Daniel synced wording with N3092
]</i></p>


<p><i>[
Post-Rapperswil, Howard provides wording:
]</i></p>


<blockquote>
Moved to Tentatively Ready with revised wording from Howard Hinnant after 5 positive votes on c++std-lib.
</blockquote>

<p><i>[
Adopted at 2010-11 Batavia
]</i></p>




<p><b>Proposed resolution:</b></p>

<p>
Change 20.11.1 [time.clock.req]:
</p>

<blockquote>
<p>
1 A clock is a bundle consisting of a <del>native</del> <tt>duration</tt>, a
<del>native</del> <tt>time_point</tt>, and a function <tt>now()</tt> to get the
current <tt>time_point</tt>. The origin of the clock's <tt>time_point</tt> is
referred to as the clock's <i>epoch</i>. A clock shall meet the requirements in
Table 56.
</p>

<p>
2 ...
</p>

<table border="1">
<caption>Table 56  Clock requirements</caption>
<tbody><tr><th>Expression</th> <th>Return type</th> <th>Operational semantics</th></tr>

<tr>
<td><tt>C1::rep</tt></td>
<td>An arithmetic type or a class emulating an arithmetic type</td>
<td>The representation type of <del>the native</del>
<tt><ins>C1::</ins>duration</tt><ins>.</ins> <del>and
<tt>time_point</tt>.</del></td>
</tr>

<tr>
<td><tt>C1::period</tt></td>
<td align="center">...</td>
<td align="center">...</td>
</tr>

<tr>
<td><tt>C1::duration</tt></td>
<td><tt>chrono::duration&lt;C1::rep, C1::period&gt;</tt></td>
<td>The <del>native</del> <tt>duration</tt> type of the clock.</td>
</tr>

<tr>
<td><tt>C1::time_point</tt></td>
<td><tt>chrono::time_point&lt;C1&gt;</tt> or <tt>chrono::time_point&lt;C2,
C1::duration&gt;</tt></td>
<td>The <del>native</del> <tt>time_point</tt> type of the clock. <tt>C1</tt> and
<tt>C2</tt> shall refer to the same epoch.</td>
</tr>

<tr>
<td colspan="3" align="center">...</td>
</tr>

</tbody></table>
</blockquote>






<hr>
<h3><a name="957"></a>957. Various threading bugs #7</h3>
<p><b>Section:</b> 20.11.5.1 [time.clock.system] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2009-01-07 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#time.clock.system">issues</a> in [time.clock.system].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
20.11.5.1 [time.clock.system]: <tt>to_time_t</tt> is overspecified. It
requires truncation, but should allow rounding. For example, suppose a
system has a clock that gives times in milliseconds, but <tt>time()</tt> rounds
those times to the nearest second. Then <tt>system_clock</tt> can't use any
resolution finer than one second, because if it did, truncating times
between half a second and a full second would produce the wrong <tt>time_t</tt>
value.
</p>

<p><i>[
Post Summit Anthony Williams provided proposed wording.
]</i></p>


<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Move to Review pending input from Howard. and other stakeholders.
</blockquote>

<p><i>[
2009-05-23 Howard adds:
]</i></p>


<blockquote>
I am in favor of the wording provided by Anthony.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Move to Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
In 20.11.5.1 [time.clock.system] replace paragraphs 3 and 4 with:
</p>

<blockquote>
<pre>time_t to_time_t(const time_point&amp; t);
</pre>
<blockquote>
-3- <i>Returns:</i> A <tt>time_t</tt> object that represents the same
point in time as <tt>t</tt> when both values are <del>truncated</del>
<ins>restricted</ins> to the coarser of the precisions of
<tt>time_t</tt> and <tt>time_point</tt>. <ins> It is implementation
defined whether values are rounded or truncated to the required
precision.</ins>
</blockquote>

<pre>time_point from_time_t(time_t t);
</pre>
<blockquote>
-4- <i>Returns:</i> A <tt>time_point</tt> object that represents the
same point in time as <tt>t</tt> when both values are <del>truncated</del>
<ins>restricted</ins> to the
coarser of the precisions of <tt>time_t</tt> and <tt>time_point</tt>.
<ins>It is implementation defined whether values are
rounded or truncated to the required precision.</ins>
</blockquote>
</blockquote>





<hr>
<h3><a name="960"></a>960. Various threading bugs #10</h3>
<p><b>Section:</b> 30.4.1 [thread.mutex.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2009-01-07 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.mutex.requirements">issues</a> in [thread.mutex.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
30.4.1 [thread.mutex.requirements]: paragraph 4 is entitled
"Error conditions", but according to 17.5.1.4 [structure.specifications], "Error
conditions:" specifies "the error conditions for error codes reported by
the function." It's not clear what this should mean when there is no
function in sight.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Move to open.
</blockquote>

<p><i>[
Beman provided proposed wording.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Move to Ready. Fix the proposed wording with "functions of type Mutex"
-&gt; "functions of Mutex type"
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 30.4.1 [thread.mutex.requirements] Mutex requirements,
paragraph 4 as indicated:
</p>

<blockquote>
<p>
-4- <del><i>Error conditions:</i></del>
<ins>The error conditions for error codes, if any, reported by member
functions of Mutex type shall be:</ins>
</p>
<ul>
<li>
<tt>not_enough_memory</tt> -- if there is not enough memory to construct
the mutex object.
</li>
<li>
<tt>resource_unavailable_try_again</tt> -- if any native handle type
manipulated is not available.
</li>
<li>
<tt>operation_not_permitted</tt> -- if the thread does not have the
necessary permission to change the state of the mutex object.
</li>
<li>
<tt>device_or_resource_busy</tt> -- if any native handle type
manipulated is already locked.
</li>
<li>
<tt>invalid_argument</tt> -- if any native handle type manipulated as
part of mutex construction is incorrect.
</li>
</ul>
</blockquote>





<hr>
<h3><a name="962"></a>962. Various threading bugs #12</h3>
<p><b>Section:</b> 30.4.2.2.2 [thread.lock.unique.locking] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2009-01-07 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.lock.unique.locking">issues</a> in [thread.lock.unique.locking].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
30.4.2.2.2 [thread.lock.unique.locking]:  <tt>unique_lock::lock</tt> is
required to throw an object of type <tt>std::system_error</tt> "when the
postcondition cannot be achieved." The postcondition is <tt>owns == true</tt>,
and this is trivial to achieve. Presumably, the requirement is intended
to mean something more than that.
</p>

<p><i>[
Summit:
]</i></p>

<blockquote>
Move to open.
</blockquote>

<p><i>[
Beman has volunteered to provide proposed wording.
]</i></p>


<p><i>[
2009-07-21 Beman added wording to address 30.2.2 [thread.req.exception]
in response to the Frankfurt notes in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#859">859</a>.
]</i></p>


<p><i>[
2009-09-25 Beman: minor update to wording.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Move to Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>

<p><i>Change Exceptions 30.2.2 [thread.req.exception] as indicated:</i></p>
<blockquote>
<p>Some functions described in this Clause are specified to throw exceptions of 
type <code>system_error</code> (19.5.5). Such exceptions shall be thrown if <ins>
any of the <i>Error conditions</i> are detected or</ins> a call to an operating 
system or other underlying API results in an error that prevents the library 
function from <del>satisfying its postconditions or from returning a meaningful 
value</del> <ins>meeting its specifications</ins>. <ins>Failure to
allocate storage shall be reported as described in
17.6.4.12 [res.on.exception.handling].</ins></p>
</blockquote>

<p><i>Change thread assignment 30.3.1.5 [thread.thread.member], join(), 
paragraph 8 as indicated:</i></p>
<blockquote>
<p><i>Throws:</i> <code>std::system_error</code> when <del>the postconditions cannot be achieved</del> <ins>an exception is required (30.2.2 [thread.req.exception])</ins>.</p>

</blockquote>

<p><i>Change thread assignment 30.3.1.5 [thread.thread.member], detach(), paragraph 
13 as indicated:</i></p>
<blockquote>

<p><i>Throws:</i> <code>std::system_error</code> when <del>the effects or 
postconditions cannot be achieved</del> <ins>an exception is required (30.2.2 [thread.req.exception])</ins>.</p>

</blockquote>

<p><i>Change Mutex requirements 30.4.1 [thread.mutex.requirements], paragraph 
11, as indicated:</i></p>
<blockquote>

<p><i>Throws:</i> <code>std::system_error</code> when <del>the effects or 
postcondition cannot be achieved</del> <ins>an exception is required (30.2.2 [thread.req.exception])</ins>.</p>
</blockquote>
<p><i>Change unique_lock locking 30.4.2.2.2 [thread.lock.unique.locking], 
paragraph 3, as indicated:</i></p>
<blockquote>

<p><i>Throws:</i> <code>std::system_error</code> when <del>the  postcondition cannot be achieved</del> <ins>an exception is required (30.2.2 [thread.req.exception])</ins>.</p>
</blockquote>
<p><i>Change unique_lock locking 30.4.2.2.2 [thread.lock.unique.locking], 
paragraph 8, as indicated:</i></p>
<blockquote>

<p><i>Throws:</i> <code>std::system_error</code> when <del>the  postcondition cannot be achieved</del> <ins>an exception is required (30.2.2 [thread.req.exception])</ins>.</p>
</blockquote>
<p><i>Change unique_lock locking 30.4.2.2.2 [thread.lock.unique.locking], 
paragraph 13, as indicated:</i></p>
<blockquote>

<p><i>Throws:</i> <code>std::system_error</code> when <del>the  postcondition cannot be achieved</del> <ins>an exception is required (30.2.2 [thread.req.exception])</ins>.</p>
</blockquote>
<p><i>Change unique_lock locking 30.4.2.2.2 [thread.lock.unique.locking], 
paragraph 18, as indicated:</i></p>
<blockquote>

<p><i>Throws:</i> <code>std::system_error</code> when <del>the  postcondition cannot be achieved</del> <ins>an exception is required (30.2.2 [thread.req.exception])</ins>.</p>
</blockquote>
<p><i>Change unique_lock locking 30.4.2.2.2 [thread.lock.unique.locking], 
paragraph 22, as indicated:</i></p>
<blockquote>

<p><i>Throws:</i> <code>std::system_error</code> when <del>the  postcondition cannot be achieved</del> <ins>an exception is required (30.2.2 [thread.req.exception])</ins>.</p>
</blockquote>
<p><i>Change Function call_once 30.4.4.2 [thread.once.callonce], paragraph 4, as 
indicated</i></p>
<blockquote>
  <p><i>Throws:</i> <code>std::system_error</code> when <del>the effects cannot be achieved</del> <ins>an exception is required (30.2.2 [thread.req.exception])</ins>, 
  or any exception thrown by <code>func</code>.</p>
</blockquote>
<p><i>Change Class condition_variable 30.5.1 [thread.condition.condvar], 
paragraph 12, as indicated:</i></p>
<blockquote>

<p><i>Throws:</i> <code>std::system_error</code> when <del>the effects or 
postcondition cannot be achieved</del> <ins>an exception is required (30.2.2 [thread.req.exception])</ins>.</p>
</blockquote>
<p><i>Change Class condition_variable 30.5.1 [thread.condition.condvar], 
paragraph 19, as indicated:</i></p>
<blockquote>

<p><i>Throws:</i> <code>std::system_error</code> when <del>the effects or 
postcondition cannot be achieved</del> <ins>an exception is required (30.2.2 [thread.req.exception])</ins>.</p>
</blockquote>
<p><i>Change Class condition_variable_any 30.5.2 [thread.condition.condvarany], 
paragraph 10, as indicated:</i></p>
<blockquote>

<p><i>Throws:</i> <code>std::system_error</code> when <del>the effects or 
postcondition cannot be achieved</del> <ins>an exception is required (30.2.2 [thread.req.exception])</ins>.</p>
</blockquote>
<p><i>Change Class condition_variable_any 30.5.2 [thread.condition.condvarany], 
paragraph 16, as indicated:</i></p>
<blockquote>

<p><i>Throws:</i> <code>std::system_error</code> when <del>the returned value, effects, or 
postcondition cannot be achieved</del> <ins>an exception is required (30.2.2 [thread.req.exception])</ins>.</p>
</blockquote>

<p><i>Assuming issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#859">859</a>, Monotonic Clock is Conditionally Supported?, has been 
applied to the working paper, change Change 30.5.1 [thread.condition.condvar] as 
indicated:</i></p>
<blockquote>
<pre>template &lt;class Rep, class Period&gt; 
bool wait_for(unique_lock&lt;mutex&gt;&amp; lock, 
              const chrono::duration&lt;Rep, Period&gt;&amp; rel_time);</pre>
<pre>...</pre>

<p><i>Throws:</i> <code>std::system_error</code> when <del>the effects or 
postcondition cannot be achieved</del> <ins>an exception is required ([thread.req.exception])</ins>.</p>
</blockquote>

<p><i>Assuming issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#859">859</a>, Monotonic Clock is Conditionally Supported?, has been 
applied to the working paper, change Change 30.5.1 [thread.condition.condvar] as 
indicated:</i></p>
<blockquote>
<pre>template &lt;class Rep, class Period, class Predicate&gt; 
  bool wait_for(unique_lock&lt;mutex&gt;&amp; lock, 
                const chrono::duration&lt;Rep, Period&gt;&amp; rel_time, 
                Predicate pred);</pre>
  <pre>...</pre>

<p><i>Throws:</i> <code>std::system_error</code> when <del>the effects or 
postcondition cannot be achieved</del> <ins>an exception is required (30.2.2 [thread.req.exception])</ins>.</p>
</blockquote>

<p><i>Assuming issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#859">859</a>, Monotonic Clock is Conditionally Supported?, has been 
applied to the working paper, change 30.5.2 [thread.condition.condvarany] as 
indicated:</i></p>
<blockquote>
<pre>template &lt;class Lock, class Rep, class Period&gt; 
  bool wait_for(Lock&amp; lock, const chrono::duration&lt;Rep, Period&gt;&amp; rel_time);</pre>
  <pre>...</pre>

<p><i>Throws:</i> <code>std::system_error</code> when <del>the returned value, effects or 
postcondition cannot be achieved</del> <ins>an exception is required (30.2.2 [thread.req.exception])</ins>.</p>
</blockquote>

<p><i>Assuming issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#859">859</a>, Monotonic Clock is Conditionally Supported?, has been 
applied to the working paper, change 30.5.2 [thread.condition.condvarany] as 
indicated:</i></p>
<blockquote>
<pre>template &lt;class Lock, class Rep, class Period, class Predicate&gt; 
  bool wait_for(Lock&amp; lock, const chrono::duration&lt;Rep, Period&gt;&amp; rel_time, Predicate pred);</pre>
  <pre>...</pre>

<p><i>Throws:</i> <code>std::system_error</code> when <del>the returned value, effects or 
postcondition cannot be achieved</del> <ins>an exception is required (30.2.2 [thread.req.exception])</ins>.</p>
</blockquote>






<hr>
<h3><a name="963"></a>963. Various threading bugs #13</h3>
<p><b>Section:</b> 30.3.1.5 [thread.thread.member] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2009-01-07 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.thread.member">issues</a> in [thread.thread.member].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
30.3.1.5 [thread.thread.member]:  <tt>thread::detach</tt> is required to
throw an exception if the thread is "not a detachable thread".
"Detachable" is never defined.
</p>

<p><i>[
Howard adds:
]</i></p>


<blockquote>
Due to a mistake on my part, 3 proposed resolutions appeared at approximately
the same time.  They are all three noted below in the discussion.
</blockquote>

<p><i>[
Summit, proposed resolution:
]</i></p>


<blockquote>
<p>
In 30.3.1.5 [thread.thread.member] change:
</p>

<blockquote><pre>void detach();
</pre>
<blockquote>
<p>...</p>
<p>-14- <i>Error conditions:</i></p>
<ul>
<li><tt>no_such_process</tt> --  <ins>if the thread is</ins> not <del>a</del> valid<del> thread</del>.</li>
<li><tt>invalid_argument</tt> -- <ins>if the thread is</ins> not <del>a detachable</del> <ins>joinable</ins><del> thread</del>.</li>
</ul>
</blockquote>

</blockquote>

</blockquote>

<p><i>[
Post Summit, Jonathan Wakely adds:
]</i></p>


<blockquote>
<p>
A <tt>thread</tt> is detachable if it is joinable. As we've defined joinable,
we can just use that.
</p>
<p>
This corresponds to the pthreads specification, where pthread_detach
fails if the thread is not joinable:
</p>
<blockquote>
EINVAL: The  implementation  has  detected  that  the value specified by
thread does not refer to a joinable thread.
</blockquote>
<p>
Jonathan recommends this proposed wording:
</p>
<blockquote>
<p>
In 30.3.1.5 [thread.thread.member] change:
</p>

<blockquote><pre>void detach();
</pre>
<blockquote>
<p>...</p>
<p>-14- <i>Error conditions:</i></p>
<ul>
<li>...</li>
<li><tt>invalid_argument</tt> -- not a <del>detachable</del> <ins>joinable</ins> thread.</li>
</ul>
</blockquote>

</blockquote>
</blockquote>
</blockquote>

<p><i>[
Post Summit, Anthony Williams adds:
]</i></p>


<blockquote>
<p>
This is covered by the precondition that <tt>joinable()</tt> be <tt>true</tt>.
</p>
<p>
Anthony recommends this proposed wording:
</p>

<blockquote>
<p>
In 30.3.1.5 [thread.thread.member] change:
</p>

<blockquote><pre>void detach();
</pre>
<blockquote>
<p>...</p>
<p>-14- <i>Error conditions:</i></p>
<ul>
<li>...</li>
<li><del><tt>invalid_argument</tt> -- not a detachable thread.</del></li>
</ul>
</blockquote>

</blockquote>

</blockquote>

</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Mark as Ready with proposed resolution from Summit.
</blockquote>



<p><b>Proposed resolution:</b></p>

<p>
In 30.3.1.5 [thread.thread.member] change:
</p>

<blockquote><pre>void detach();
</pre>
<blockquote>
<p>...</p>
<p>-14- <i>Error conditions:</i></p>
<ul>
<li><tt>no_such_process</tt> --  <ins>if the thread is</ins> not <del>a</del> valid<del> thread</del>.</li>
<li><tt>invalid_argument</tt> -- <ins>if the thread is</ins> not <del>a detachable</del> <ins>joinable</ins><del> thread</del>.</li>
</ul>
</blockquote>

</blockquote>






<hr>
<h3><a name="965"></a>965. Various threading bugs #15</h3>
<p><b>Section:</b> 30.5.1 [thread.condition.condvar] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2009-01-07 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.condition.condvar">issues</a> in [thread.condition.condvar].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
30.5.1 [thread.condition.condvar]: the constructor for
<tt>condition_variable</tt> throws an exception with error code
<tt>device_or_resource_busy</tt> "if attempting to initialize a
previously-initialized but as of yet undestroyed <tt>condition_variable</tt>."
How can this occur?
</p>

<p><i>[
Summit:
]</i></p>

<blockquote>
<p>
Move to review. Proposed resolution: strike the <tt>device_or_resource_busy</tt>
error condition from the constructor of <tt>condition_variable</tt>.
</p>
<ul>
<li>
This is a POSIX error that cannot occur in this interface because the
C++ interface does not separate declaration from initialization.
</li>
</ul>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution.
Move to Tentatively Ready.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 30.5.1 [thread.condition.condvar] p3:
</p>

<blockquote>
<ul>
<li>...</li>
<li>
<del><tt>device_or_resource_busy</tt> -- if attempting to initialize a
previously-initialized but as of yet undestroyed
<tt>condition_variable</tt>.</del>
</li>
</ul>
</blockquote>





<hr>
<h3><a name="967"></a>967. Various threading bugs #17</h3>
<p><b>Section:</b> 30.3.1.2 [thread.thread.constr] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2009-01-07 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.thread.constr">issues</a> in [thread.thread.constr].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
the error handling for the constructor for <tt>condition_variable</tt>
distinguishes lack of memory from lack of other resources, but the error
handling for the thread constructor does not. Is this difference
intentional?
</p>

<p><i>[
Beman has volunteered to provide proposed wording.
]</i></p>


<p><i>[
2009-09-25 Beman provided proposed wording.
]</i></p>


<blockquote>
The proposed resolution assumes <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#962">962</a> has been accepted and
its proposed resolution applied to the working paper.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Move to Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>


<p><span style="font-style: italic">Change Mutex requirements 30.4.1 [thread.mutex.requirements], 
paragraph 4, as indicated:</span></p>
<blockquote>

<p><i>Error conditions:</i></p>
  <blockquote>

<ul>
<li><del> <code>not_enough_memory</code>  if there is not enough memory to construct 
the mutex object.</del></li>

<li><code>resource_unavailable_try_again</code>  if any native handle type 
manipulated is not available.</li>

<li><code>operation_not_permitted</code>  if the thread does not have the 
necessary permission to change the state of the mutex object.</li>

<li><code>device_or_resource_busy</code>  if any native handle type 
manipulated is already locked.</li>

<li><code>invalid_argument</code>  if any native handle type manipulated as 
part of mutex construction is incorrect.</li>
</ul>
  </blockquote>
</blockquote>

<p><span style="font-style: italic">Change Class condition_variable 30.5.1 [thread.condition.condvar], 
default constructor, as indicated:</span></p>
<blockquote>
  <p><code>condition_variable();</code></p>
  <blockquote>
    <p><i>Effects:</i> Constructs an object of type <code>condition_variable</code>.</p>
    <p><ins><i>Throws:</i> <code>std::system_error</code> when an exception is required (30.2.2 [thread.req.exception])</ins>.</p>
    <p><i>Error conditions:</i></p>
    <blockquote>
    <ul>
      <li><del><code>not_enough_memory</code>  if a memory limitation prevents 
      initialization.</del></li>
      <li> <code>resource_unavailable_try_again</code>  if some non-memory 
      resource limitation prevents initialization.</li>
      <li> <code>device_or_resource_busy</code>  if attempting to initialize a 
      previously-initialized but as of yet undestroyed <code>condition_variable</code>.</li>
    </ul>
    </blockquote>
  </blockquote>
</blockquote>





<hr>
<h3><a name="968"></a>968. Various threading bugs #18</h3>
<p><b>Section:</b> 30.4.1 [thread.mutex.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2009-01-07 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.mutex.requirements">issues</a> in [thread.mutex.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
30.4.1 [thread.mutex.requirements]: several functions are
required to throw exceptions "if the thread does not have the necessary
permission ...". "The necessary permission" is not defined.
</p>

<p><i>[
Summit:
]</i></p>

<blockquote>
Move to open.
</blockquote>


<p><i>[
Beman has volunteered to provide proposed wording.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Moved to Ready with minor word-smithing in the example.
</blockquote>



<p><b>Proposed resolution:</b></p>


<p><i>Change Exceptions 30.2.2 [thread.req.exception] as indicated:</i></p>
<blockquote>
<p>Some functions described in this Clause are 
specified to throw exceptions of type <code>system_error</code> (19.5.5). Such exceptions 
shall be thrown if any of the <i>Error conditions</i> are detected or a call to an operating system or other underlying API 
results in an error that prevents the library function from meeting its specifications.
<i>[Note:</i> See 17.6.4.12 [res.on.exception.handling] for exceptions thrown to report 
storage allocation failures. <i>end 
note]</i></p>

<p><ins><i>[Example:</i></ins></p>

<blockquote>

<p><ins>Consider a function in this clause that is specified to throw exceptions of type <code>
system_error</code> and specifies <i>Error conditions</i> that include <code>
operation_not_permitted</code> for a thread that does not have the privilege to 
perform the operation. Assume that, during the execution of this function, an <code>errno</code> 
of <code>EPERM</code> is reported by a POSIX API call used by the 
implementation. Since POSIX specifies an <code>errno</code> of <code>EPERM</code> 
when "the caller does not have the privilege to perform the operation", 
the implementation maps <code>EPERM</code>&nbsp; to an <code>error_condition</code> 
of <code>operation_not_permitted</code> (19.5 [syserr]) and an exception of type <code>
system_error</code> is thrown. </ins></p>

</blockquote>

<p><ins><i>end example]</i></ins></p>

<p><span style="font-style: italic">Editorial note: For the sake of exposition, 
the existing text above is shown with the changes proposed in issues 962 and 967. The 
proposed additional example is independent of whether or not the 962 and 967 
proposed resolutions are accepted.</span></p>

</blockquote>

<p><span style="font-style: italic">Change Mutex requirements 30.4.1 [thread.mutex.requirements], 
paragraph 4, as indicated:</span></p>

<blockquote>

<p> <code>operation_not_permitted</code>  if the thread does not have the 
<del>necessary permission to change the state of the mutex object</del> <ins>privilege to perform the operation</ins>.</p>

</blockquote>

<p><span style="font-style: italic">Change Mutex requirements 30.4.1 [thread.mutex.requirements], 
paragraph 12, as indicated:</span></p>

<blockquote>

<p> <code>operation_not_permitted</code>  if the thread does not have the 
<del>necessary permission to change the state of the mutex</del> <ins>privilege to perform the operation</ins>.</p>

</blockquote>






<hr>
<h3><a name="970"></a>970. addressof overload unneeded</h3>
<p><b>Section:</b> 20.9.8.1 [specialized.addressof] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-01-16 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
20.9.8.1 [specialized.addressof] specifies:
</p>

<blockquote><pre>template &lt;ObjectType T&gt; T* addressof(T&amp; r);
template &lt;ObjectType T&gt; T* addressof(T&amp;&amp; r);
</pre></blockquote>

<p>
The two signatures are ambiguous when the argument is an lvalue.  The
second signature seems not useful:  what does it mean to take the
address of an rvalue?
</p>

<p><i>[
Post Summit:
]</i></p>


<blockquote>
Recommend Review.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution.
Move to Tentatively Ready.
</blockquote>

<p><i>[
2009-11-18 Moved from Pending WP to WP.  Confirmed in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n3000.pdf">N3000</a>.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
Change 20.9.8.1 [specialized.addressof]:
</p>

<blockquote><pre>template &lt;ObjectType T&gt; T* addressof(T&amp; r);
<del>template &lt;ObjectType T&gt; T* addressof(T&amp;&amp; r);</del>
</pre></blockquote>






<hr>
<h3><a name="974"></a>974. <tt>duration&lt;double&gt;</tt> should not implicitly convert to <tt>duration&lt;int&gt;</tt></h3>
<p><b>Section:</b> 20.11.3.1 [time.duration.cons] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-01-21 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The following code should not compile because it involves implicit truncation
errors (against the design philosophy of the <tt>duration</tt> library).
</p>

<blockquote><pre>duration&lt;double&gt; d(3.5);
duration&lt;int&gt; i = d;  <font color="#C80000">// implicit truncation, should not compile</font>
</pre></blockquote>

<p>
This intent was codified in the example implementation which drove this proposal
but I failed to accurately translate the code into the specification in this
regard.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We agree with the proposed resolution.
</p>
<p>
Move to Tentatively Ready.
</p>
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
Moved from Tentatively Ready to Open only because the wording needs to be
improved for enable_if type constraining, possibly following Robert's
formula.
</blockquote>

<p><i>[
2009-08-01 Howard adds:
]</i></p>


<blockquote>
Addressed by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1177">1177</a>.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Not completely addressed by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1177">1177</a>.  Move to Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 20.11.3.1 [time.duration.cons], p4:
</p>

<blockquote>
<pre>template &lt;class Rep2, class Period2&gt; 
  duration(const duration&lt;Rep2, Period2&gt;&amp; d);
</pre>
<blockquote>
-4- <i>Requires:</i> <tt>treat_as_floating_point&lt;rep&gt;::value</tt>
shall be <tt>true</tt> or <ins>both</ins> <tt>ratio_divide&lt;Period2,
period&gt;::type::den</tt> shall be 1
<ins>and <tt>treat_as_floating_point&lt;Rep2&gt;::value</tt>
shall be <tt>false</tt></ins>.
Diagnostic required.
[<i>Note:</i> This requirement prevents implicit truncation error when
converting between integral-based <tt>duration</tt> types. Such a
construction could easily lead to confusion about the value of the
<tt>duration</tt>. -- <i>end note</i>]
</blockquote>
</blockquote>





<hr>
<h3><a name="975"></a>975. <tt>is_convertible</tt> cannot be instantiated for  non-convertible types</h3>
<p><b>Section:</b> 20.7.6 [meta.rel] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2009-01-25 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#meta.rel">issues</a> in [meta.rel].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>

<b>Addresses UK 206</b>

<p>
Related to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1114">1114</a>.
</p>

<p>
The current specification of <tt>std::is_convertible</tt> (reference is draft
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2798.pdf">N2798</a>)
is basically defined by 20.7.6 [meta.rel]/4:
</p>

<blockquote>
<p>
In order to instantiate the template <tt>is_convertible&lt;From,
To&gt;</tt>, the following code shall be well formed:
</p>

<blockquote><pre>template &lt;class T&gt;
  typename add_rvalue_reference&lt;T&gt;::type create();

To test() {
  return create&lt;From&gt;();
}
</pre></blockquote>

<p>
[<i>Note:</i> This requirement gives well defined results for reference
types, void types, array types, and function types. --<i>end note</i>]
</p>
</blockquote>

<p>
The first sentence can be interpreted, that e.g. the expression
</p>

<blockquote><pre>std::is_convertible&lt;double, int*&gt;::value
</pre></blockquote>

<p>
is ill-formed because <tt>std::is_convertible&lt;double, int*&gt;</tt> could not be
instantiated, or in more general terms: The wording requires that
<tt>std::is_convertible&lt;X, Y&gt;</tt> cannot be instantiated for otherwise valid
argument types <tt>X</tt> and <tt>Y</tt> if <tt>X</tt> is not convertible to <tt>Y</tt>.
</p>

<p>
This semantic is both unpractical and in contradiction to what the last type
traits paper
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2255.html">N2255</a>
proposed:
</p>

<blockquote>
<p>
If the following <tt>test</tt> function is well formed code <tt>b</tt>
is <tt>true</tt>, else it is <tt>false</tt>.
</p>

<blockquote><pre>template &lt;class T&gt;
  typename add_rvalue_reference&lt;T&gt;::type create();

To test() {
  return create&lt;From&gt;();
}
</pre></blockquote>

<p>
[<i>Note:</i> This definition gives well defined results for <tt>reference</tt>
types, <tt>void</tt> types, array types, and function types. --<i>end note</i>]
</p>
</blockquote>

<p><i>[
Post Summit:
]</i></p>


<blockquote>
<p>
Jens: Checking that code is well-formed and then returning true/false
sounds like speculative compilation. John Spicer would really dislike
this. Please find another wording suggesting speculative compilation.
</p>
<p>
Recommend Open.
</p>
</blockquote>

<p><i>[
Post Summit, Howard adds:
]</i></p>


<blockquote>
<p>
John finds the following wording clearer:
</p>
<blockquote>

<table border="1">
<tbody><tr>
<th>Template</th><th>Condition</th><th>Comments</th>
</tr>
<tr>
<td><tt>template &lt;class From, class To&gt;<br>struct is_convertible;</tt></td>
<td><i>see below</i></td>
<td><tt>From</tt> and <tt>To</tt> shall be complete types, arrays of unknown bound,
or (possibly cv-qualified) <tt>void</tt> types.</td>
</tr>
</tbody></table>

<p>
Given the following function prototype:
</p>

<blockquote><pre>template &lt;class T&gt;
  typename add_rvalue_reference&lt;T&gt;::type create();
</pre></blockquote>

<p>
<tt>is_convertible&lt;From, To&gt;::value</tt> shall be <tt>true</tt> if the
return expression in the following code would be well-formed, including
any implicit conversions to the return type of the function, else
<tt>is_convertible&lt;From, To&gt;::value</tt> shall be <tt>false</tt>.
</p>

<blockquote><pre>To test() {
  return create&lt;From&gt;();
}
</pre></blockquote>

</blockquote>

</blockquote>

<b>Original proposed wording:</b>

<p>
In 20.7.6 [meta.rel]/4 change:
</p>

<blockquote>
<del>In order to instantiate the template <tt>is_convertible&lt;From, To&gt;</tt>, the
following code shall be well formed</del> <ins>If the following code
is well formed <tt>is_convertible&lt;From, To&gt;::value</tt> is <tt>true</tt>, otherwise
<tt>false</tt></ins>:[..]
</blockquote>

<p><b>Revision 2</b></p>

<blockquote>

<p>
In 20.7.6 [meta.rel] change:
</p>

<blockquote>

<table border="1">
<tbody><tr>
<th>Template</th><th>Condition</th><th>Comments</th>
</tr>
<tr>
</tr><tr><td>...</td><td>...</td><td>...</td></tr>
<tr><td><tt>template &lt;class From, class To&gt;<br>struct is_convertible;</tt></td>
<td>
<del>The code set out below shall be well formed.</del>
<ins><i>see below</i></ins></td>
<td><tt>From</tt> and <tt>To</tt> shall be complete types, arrays of unknown bound,
or (possibly cv-qualified) <tt>void</tt> types.</td>
</tr>
</tbody></table>

<p>
-4- <del>In order to instantiate the template <tt>is_convertible&lt;From, To&gt;</tt>, the
following code shall be well formed:</del>
<ins>Given the following function prototype:</ins>
</p>

<blockquote><pre>template &lt;class T&gt; 
  typename add_rvalue_reference&lt;T&gt;::type create();
</pre></blockquote>

<p>
<ins><tt>is_convertible&lt;From, To&gt;::value</tt> inherits either directly or
indirectly from <tt>true_type</tt> if the
return expression in the following code would be well-formed, including
any implicit conversions to the return type of the function, else
<tt>is_convertible&lt;From, To&gt;::value</tt> inherits either directly or
indirectly from <tt>false_type</tt>.</ins>
</p>

<blockquote><pre>To test() { 
  return create&lt;From&gt;(); 
}
</pre></blockquote>

<p>
[<i>Note:</i> This requirement gives well defined results for reference types,
void types, array types, and function types. <i>-- end note</i>]
</p>

</blockquote>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution.
Move to Tentatively Ready.
</blockquote>


<p><b>Proposed resolution:</b></p>

<p>
In 20.7.6 [meta.rel] change:
</p>

<blockquote>

<table border="1">
<tbody><tr>
<th>Template</th><th>Condition</th><th>Comments</th>
</tr>
<tr>
</tr><tr><td>...</td><td>...</td><td>...</td></tr>
<tr><td><tt>template &lt;class From, class To&gt;<br>struct is_convertible;</tt></td>
<td>
<del>The code set out below shall be well formed.</del>
<ins><i>see below</i></ins></td>
<td><tt>From</tt> and <tt>To</tt> shall be complete types, arrays of unknown bound,
or (possibly cv-qualified) <tt>void</tt> types.</td>
</tr>
</tbody></table>

<p>
-4- <del>In order to instantiate the template <tt>is_convertible&lt;From, To&gt;</tt>, the
following code shall be well formed:</del>
<ins>Given the following function prototype:</ins>
</p>

<blockquote><pre>template &lt;class T&gt; 
  typename add_rvalue_reference&lt;T&gt;::type create();
</pre></blockquote>

<p>
<ins>the predicate condition for a template specialization
<tt>is_convertible&lt;From, To&gt;</tt> shall be satisfied, if and only
if the return expression in the following code would be well-formed,
including any implicit conversions to the return type of the
function.</ins>
</p>

<blockquote><pre>To test() { 
  return create&lt;From&gt;(); 
}
</pre></blockquote>

<p>
[<i>Note:</i> This requirement gives well defined results for reference types,
void types, array types, and function types. <i> end note</i>]
</p>

</blockquote>





<hr>
<h3><a name="978"></a>978. Hashing smart pointers</h3>
<p><b>Section:</b> 20.8.15 [unord.hash] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-02-02 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#unord.hash">issues</a> in [unord.hash].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses UK 208</b></p>
<p>
I don't see an open issue on supporting <tt>std::hash</tt> for smart pointers
(<tt>unique_ptr</tt> and <tt>shared_ptr</tt> at least).
</p>
<p>
It seems reasonable to at least expect support for the smart
pointers, especially as they support comparison for use in ordered
associative containers.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Howard points out that the client can always supply a custom hash function.
</p>
<p>
Alisdair replies that the smart pointer classes are highly likely
to be frequently used as hash keys.
</p>
<p>
Bill would prefer to be conservative.
</p>
<p>
Alisdair mentions that this issue may also be viewed as a subissue or
duplicate of issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1025">1025</a>.
</p>
<p>
Move to Open, and recommend the issue be deferred until after the next
Committee Draft is issued.
</p>
</blockquote>

<p><i>[
2009-05-31 Peter adds:
]</i></p>


<blockquote>
<blockquote>
Howard points out that the client can always supply a custom hash function.
</blockquote>
<p>
Not entirely true. The client cannot supply the function that hashes the
address of the control block (the equivalent of the old <tt>operator&lt;</tt>, now
proudly carrying the awkward name of '<tt>owner_before</tt>'). Only the
implementation can do that, not necessarily via specializing <tt>hash&lt;&gt;</tt>, of
course.
</p>
<p>
This hash function makes sense in certain situations for <tt>shared_ptr</tt>
(when one needs to switch from <tt>set/map</tt> using ownership ordering to
<tt>unordered_set/map</tt>) and is the only hash function that makes sense for
<tt>weak_ptr</tt>.
</p>
</blockquote>

<p><i>[
2009-07-28 Alisdair provides wording.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Move to Ready.
</blockquote>

<p><i>[
2009-11-16 Moved from Ready to Open:
]</i></p>


<blockquote>
<p>
Pete writes:
</p>
<blockquote>
<p>
As far as I can see, "...suitable for using this type as key in unordered
associative containers..." doesn't define any semantics. It's advice to the
reader, and if it's present at all it should be in a note. But we have far too
much of this sort of editorial commentary as it is.
</p>
<p>
And in the resolution of 978 it's clearly wrong: it says that if there is no
hash specialization available for <tt>D::pointer</tt>, the implementation may provide
<tt>hash&lt;unique_ptr&lt;T,D&gt;&gt;</tt> if the result is not suitable for use in unordered
containers.
</p>
</blockquote>

<p>
Howard writes:
</p>

<blockquote>
Is this a request to pull 978 from Ready?
</blockquote>

<p>
Barry writes:
</p>
<blockquote>
<p>
I read this as more than a request. The PE says it's wrong, so it can't be
Ready.
</p>
</blockquote>

</blockquote>

<p><i>[
2010-01-31 Alisdair: related to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1245">1245</a> and <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1182">1182</a>.
]</i></p>


<p><i>[
2010-02-08 Beman updates wording.
]</i></p>


<p><i>[
2010-02-09 Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>




<p><b>Proposed resolution:</b></p>

<p><i>Add the following declarations to the synopsis of <tt>&lt;memory&gt;</tt> in 
20.9 [memory] </i></p>

<blockquote>
<pre><ins>// [util.smartptr.hash] hash support
template &lt;class T&gt; struct hash;
template &lt;class T, class D&gt; struct hash&lt;unique_ptr&lt;T,D&gt;&gt;;
template &lt;class T&gt; struct hash&lt;shared_ptr&lt;T&gt;&gt;;</ins></pre>
</blockquote>

<p><i>Add a new subclause under 20.9.10 [util.smartptr] called hash support </i></p>

<blockquote>
<h3><ins>hash support [util.smartptr.hash]</ins></h3>

<pre><ins>template &lt;class T, class D&gt; struct hash&lt;unique_ptr&lt;T,D&gt;&gt;;</ins></pre>

<blockquote>
<p><ins>
Specialization meeting the requirements of class template <tt>hash</tt> (20.8.15 [unord.hash]). For an object <tt>p</tt> of type <tt>UP</tt>, where
<tt>UP</tt> is a type <tt>unique_ptr&lt;T,D&gt;</tt>,
<tt>hash&lt;UP&gt;()(p)</tt> shall evaluate to the same value as
<tt>hash&lt;typename UP::pointer&gt;()(p.get())</tt>. The specialization
<tt>hash&lt;typename UP::pointer&gt;</tt> is required to be well-formed.
</ins></p>
</blockquote>

<pre><ins>template &lt;class T&gt; struct hash&lt;shared_ptr&lt;T&gt;&gt;;</ins></pre>

<blockquote>
<p><ins>
Specialization meeting the requirements of class template <tt>hash</tt> (20.8.15 [unord.hash]). For an object <tt>p</tt> of type
<tt>shared_ptr&lt;T&gt;</tt>, <tt>hash&lt;shared_ptr&lt;T&gt;&gt;()(p)</tt>
shall evaluate to the same value as <tt> hash&lt;T*&gt;()(p.get())</tt>.
</ins></p>
</blockquote>
</blockquote>






<hr>
<h3><a name="981"></a>981. Unordered container requirements should add  <tt>initializer_list</tt> support</h3>
<p><b>Section:</b> 23.2.5 [unord.req] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2009-02-08 <b>Last modified:</b> 2010-10-29</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#unord.req">active issues</a> in [unord.req].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#unord.req">issues</a> in [unord.req].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Refering to
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2800.pdf">N2800</a>
all container requirements tables (including those for
associative containers) provide useful member function overloads
accepting <tt>std::initializer_list</tt> as argument, the only exception is
Table 87. There seems to be no reason for not providing them, because 23.7 [unord]
is already <tt>initializer_list</tt>-aware. For the sake of 
library interface consistency and user-expectations corresponding 
overloads should be added to the table requirements of unordered 
containers as well.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We agree with the proposed resolution.
</p>
<p>
Move to Tentatively Ready.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>

<p>
In 23.2.5 [unord.req]/9 insert:
</p>

<blockquote>
... <tt>[q1, q2)</tt> is a valid range in <tt>a</tt>, <ins><tt>il</tt>
designates an object of type <tt>initializer_list&lt;value_type&gt;</tt>, </ins><tt>t</tt> is a value of type
<tt>X::value_type</tt>, ...
</blockquote>

<p>
In 23.2.5 [unord.req], Table 87 insert:
</p>

<blockquote>
<table border="1">
<caption>Table 87 - Unordered associative container requirements (in addition to container)</caption>
<tbody><tr>
<th>Expression</th> <th>Return type</th> <th>Assertion/note<br>pre-/post-condition</th> <th>Complexity</th>
</tr>
<tr>
<td><tt>X(i, j)<br>X a(i, j)</tt></td> <td><tt>X</tt></td> <td>...</td> <td>...</td>
</tr>
<tr>
<td><ins><tt>X(il)</tt></ins></td> <td><ins><tt>X</tt></ins></td> 
<td><ins>Same as <tt>X(il.begin(), il.end())</tt>.</ins></td> 
<td><ins>Same as <tt>X(il.begin(), il.end())</tt>.</ins></td>
</tr>
<tr>
<td>...</td> <td>...</td> <td>...</td> <td>...</td>
</tr>
<tr>
<td><tt>a = b</tt></td> <td><tt>X</tt></td> <td>...</td> <td>...</td>
</tr>
<tr>
<td><ins><tt>a = il</tt></ins></td> <td><ins><tt>X&amp;</tt></ins></td> 
<td><ins><tt>a = X(il); return *this;</tt></ins></td> 
<td><ins>Same as <tt>a = X(il)</tt>.</ins></td>
</tr>
<tr>
<td>...</td> <td>...</td> <td>...</td> <td>...</td>
</tr>
<tr>
<td><tt>a.insert(i, j)</tt></td> <td><tt>void</tt></td> <td>...</td> <td>...</td>
</tr>
<tr>
<td><ins><tt>a.insert(il)</tt></ins></td> <td><ins><tt>void</tt></ins></td> 
<td><ins>Same as <tt>a.insert(il.begin(), il.end())</tt>.</ins></td> 
<td><ins>Same as <tt>a.insert(il.begin(), il.end())</tt>.</ins></td>
</tr>
</tbody></table>
</blockquote>






<hr>
<h3><a name="982"></a>982. Wrong complexity for initializer_list assignment in  Table 85</h3>
<p><b>Section:</b> 23.2.4 [associative.reqmts] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2009-02-08 <b>Last modified:</b> 2010-10-29</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#associative.reqmts">active issues</a> in [associative.reqmts].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#associative.reqmts">issues</a> in [associative.reqmts].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
According to
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2800.pdf">N2800</a>,
the associative container requirements table 85 says
    that assigning an <tt>initializer_list</tt> to such a container is of
    constant complexity, which is obviously wrong.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We agree with the proposed resolution.
</p>
<p>
Move to Tentatively Ready.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>

<p>
In 23.2.4 [associative.reqmts], Table 85 change:
</p>

<blockquote>
<table border="1">
<caption>Table 85 - Associative container requirements (in addition to container)</caption>
<tbody><tr>
<th>Expression</th> <th>Return type</th> <th>Assertion/note<br>pre-/post-condition</th> <th>Complexity</th>
</tr>
<tr>
<td><tt>a = il</tt></td> <td><tt>X&amp;</tt></td> <td><tt>a = X(il);<br>return *this;</tt></td> 
<td><del>constant</del><ins>Same as <tt>a = X(il)</tt>.</ins></td>
</tr>
</tbody></table>
</blockquote>






<hr>
<h3><a name="983"></a>983. <tt>unique_ptr</tt> reference deleters should not be moved from</h3>
<p><b>Section:</b> 20.9.9.2 [unique.ptr.single] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-02-10 <b>Last modified:</b> 2010-11-19</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#unique.ptr.single">issues</a> in [unique.ptr.single].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Dave brought to my attention that when a <tt>unique_ptr</tt> has a non-const reference
type deleter, move constructing from it, even when the <tt>unique_ptr</tt> containing
the reference is an rvalue, could have surprising results:
</p>

<blockquote><pre>D d(some-state);
unique_ptr&lt;A, D&amp;&gt; p(new A, d);
unique_ptr&lt;A, D&gt; p2 = std::move(p);
<font color="#C80000">// has d's state changed here?</font>
</pre></blockquote>

<p>
I agree with him.  It is the <tt>unique_ptr</tt> that is the rvalue, not the
deleter.  When the deleter is a reference type, the <tt>unique_ptr</tt> should
respect the "lvalueness" of the deleter.
</p>

<p>
Thanks Dave.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Seems correct, but complicated enough that we recommend moving to Review.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Move to Ready.
</blockquote>

<p><i>[
2010-03-14 Howard adds:
]</i></p>


<blockquote>
We moved
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3073.html">N3073</a>
to the formal motions page in Pittsburgh which should obsolete this issue.  I've
moved this issue to NAD Editorial, solved by N3073.
</blockquote>



<p><b>Rationale:</b></p>
<p>
Solved by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3073.html">N3073</a>.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change 20.9.9.2.1 [unique.ptr.single.ctor], p20-21
</p>

<blockquote>
<pre>template &lt;class U, class E&gt; unique_ptr(unique_ptr&lt;U, E&gt;&amp;&amp; u);
</pre>

<blockquote>

<p>
-20- <i>Requires:</i> If <tt><del>D</del> <ins>E</ins></tt> is not a reference type,
construction of the deleter <tt>D</tt> from an rvalue of type <tt>E</tt>
shall be well formed and shall not throw an exception.
<ins>
Otherwise <tt>E</tt> is a reference type and construction of the deleter
<tt>D</tt> from an lvalue of type <tt>E</tt> shall be well formed and
shall not throw an exception.
</ins>
If <tt>D</tt> is
a reference type, then <tt>E</tt> shall be the same type as <tt>D</tt>
(diagnostic required). <tt>unique_ptr&lt;U, E&gt;::pointer</tt> shall be
implicitly convertible to <tt>pointer</tt>. [<tt>Note:</tt> These
requirements imply that <tt>T</tt> and <tt>U</tt> are complete types.
<i>-- end note</i>]
</p>

<p>
-21- <i>Effects:</i> Constructs a <tt>unique_ptr</tt> which owns the
pointer which <tt>u</tt> owns (if any). If the deleter
<ins><tt>E</tt></ins> is not a reference type, <del>it</del> <ins>this
deleter</ins> is move constructed from <tt>u</tt>'s deleter, otherwise
<del>the reference</del> <ins>this deleter</ins> is copy constructed
from <tt>u</tt>.'s deleter. After the construction, <tt>u</tt> no longer
owns a pointer. [<i>Note:</i> The deleter constructor can be implemented
with <tt>std::forward&lt;<del>D</del><ins>E</ins>&gt;</tt>. <i>-- end
note</i>]
</p>

</blockquote>
</blockquote>

<p>
Change 20.9.9.2.3 [unique.ptr.single.asgn], p1-3
</p>

<blockquote>
<pre>unique_ptr&amp; operator=(unique_ptr&amp;&amp; u);
</pre>
<blockquote>

<p>
-1- <i>Requires:</i> <ins>If the deleter <tt>D</tt> is not a reference type,</ins>
<del>A</del><ins>a</ins>ssignment of the deleter <tt>D</tt> from an rvalue <tt>D</tt> shall not throw an exception.
<ins>
Otherwise the deleter <tt>D</tt> is a reference type,
and assignment of the deleter <tt>D</tt> from an lvalue <tt>D</tt> shall not throw an exception.</ins>
</p>

<p>
-2- <i>Effects:</i> reset(u.release()) followed by
a<ins>n</ins> <del>move</del> assignment from <del><tt>u</tt>'s deleter to this deleter</del>
<ins><tt>std::forward&lt;D&gt;(u.get_deleter())</tt></ins>.
</p>

<p>
-3- <i>Postconditions:</i> This <tt>unique_ptr</tt> now owns the pointer
which <tt>u</tt> owned, and <tt>u</tt> no longer owns it. <del>[<i>Note:</i> If
<tt>D</tt> is a reference type, then the referenced lvalue deleters are
move assigned. <i>-- end note</i>]</del>
</p>
</blockquote>
</blockquote>

<p>
Change 20.9.9.2.3 [unique.ptr.single.asgn], p6-7
</p>

<blockquote>
<pre>template &lt;class U, class E&gt; unique_ptr&amp; operator=(unique_ptr&lt;U, E&gt;&amp;&amp; u);
</pre>
<blockquote>

<p>
<i>Requires:</i> <ins>If the deleter <tt>E</tt> is not a reference type,</ins>
<del>A</del><ins>a</ins>ssignment of the deleter <tt>D</tt> from an rvalue
<tt><del>D</del><ins>E</ins></tt> shall not throw an exception.
<ins>
Otherwise the deleter <tt>E</tt> is a reference type,
and assignment of the deleter <tt>D</tt> from an lvalue <tt>E</tt> shall not throw an exception.</ins>
<tt>unique_ptr&lt;U, E&gt;::pointer</tt> shall be implicitly convertible to <tt>pointer</tt>.
[<i>Note:</i> These requirements imply that <tt>T</tt> and <tt>U&gt;</tt>
are complete types. <i>-- end note</i>]
</p>

<p>
<i>Effects:</i> <tt>reset(u.release())</tt> followed by
a<ins>n</ins> <del>move</del> assignment from <del><tt>u</tt>'s deleter to this deleter</del>
<ins><tt>std::forward&lt;E&gt;(u.get_deleter())</tt></ins>.
<del>If either
<tt>D</tt> or <tt>E</tt> is a reference type, then the referenced lvalue
deleter participates in the move assignment.</del>
</p>

</blockquote>
</blockquote>






<hr>
<h3><a name="984"></a>984. Does <tt>&lt;cinttypes&gt;</tt> have macro guards?</h3>
<p><b>Section:</b> 27.9.2 [c.files] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-02-12 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The C standard says about <tt>&lt;inttypes.h&gt;</tt>:
</p>

<blockquote>
C++ implementations should define these macros only when <tt>__STDC_FORMAT_MACROS</tt>is defined 
before <tt>&lt;inttypes.h&gt;</tt> is included.
</blockquote>

<p>
The C standard has a similar note about <tt>&lt;stdint.h&gt;</tt>.  For <tt>&lt;cstdint&gt;</tt>
we adopted a "thanks but no thanks" policy and documented that fact in
18.4.1 [cstdint.syn]:
</p>

<blockquote>
... [<i>Note:</i> The macros defined by <tt>&lt;stdint&gt;</tt> are
provided unconditionally. In particular, the symbols
<tt>__STDC_LIMIT_MACROS</tt> and <tt>__STDC_CONSTANT_MACROS</tt>
(mentioned in C99 footnotes 219, 220, and 222) play no role in C++.
<i>-- end note</i>]
</blockquote>

<p>
I recommend we put a similar note in 27.9.2 [c.files] regarding <tt>&lt;cinttypes&gt;</tt>.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution.
Move to Tentatively Ready.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Add to 27.9.2 [c.files]:
</p>

<blockquote>
Table 112 describes header <tt>&lt;cinttypes&gt;</tt>.
<ins>
[<i>Note:</i> The macros defined by <tt>&lt;cintypes&gt;</tt> are
provided unconditionally. In particular, the symbol
<tt>__STDC_FORMAT_MACROS</tt>
(mentioned in C99 footnote 182) plays no role in C++.
<i>-- end note</i>]
</ins>
</blockquote>





<hr>
<h3><a name="986"></a>986. Generic <tt>try_lock</tt> contradiction</h3>
<p><b>Section:</b> 30.4.3 [thread.lock.algorithm] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Chris Fairles <b>Opened:</b> 2009-02-14 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 30.4.3 [thread.lock.algorithm], the generic <tt>try_lock</tt> effects (p2) say that a failed
<tt>try_lock</tt> is when it either returns <tt>false</tt> or throws an exception. In
the event a call to <tt>try_lock</tt> does fail, by either returning <tt>false</tt> or
throwing an exception, it states that <tt>unlock</tt> shall be called for all
prior arguments. Then the returns clause (p3) goes on to state
in a note that after returning, either all locks are locked or none
will be. So what happens if multiple locks fail on <tt>try_lock</tt>?
</p>

<p>
Example:
</p>

<blockquote><pre>#include &lt;mutex&gt;

int main() {
 std::mutex m0, m1, m2;
 std::unique_lock&lt;std::mutex&gt; l0(m0, std::defer_lock);
 std::unique_lock&lt;std::mutex&gt; l1(m1); //throws on try_lock
 std::unique_lock&lt;std::mutex&gt; l2(m2); //throws on try_lock

 int result = std::try_lock(l0, l1, l2);

 assert( !l0.owns_lock() );
 assert( l1.owns_lock() ); //??
 assert( l2.owns_lock() ); //??
}
</pre></blockquote>

<p>
The first lock's <tt>try_lock</tt> succeeded but, being a prior argument to a
lock whose <tt>try_lock</tt> failed, it gets unlocked as per the effects clause
of 30.4.3 [thread.lock.algorithm]. However, 2 locks remain locked in this case but the return
clause states that either all arguments shall be locked or none will
be. This seems to be a contradiction unless the intent is for
implementations to make an effort to unlock not only prior arguments,
but the one that failed and those that come after as well. Shouldn't
the note only apply to the arguments that were successfully locked?
</p>

<p>
Further discussion and possible resolutions in c++std-lib-23049.
</p>

<p><i>[
Summit:
]</i></p>

<blockquote>
Move to review. Agree with proposed resolution.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution.
Move to Tentatively Ready.
</blockquote>


<p><b>Proposed resolution:</b></p>

<p>
Change 30.4.3 [thread.lock.algorithm], p2:
</p>

<blockquote>
-2- <i>Effects:</i> Calls <tt>try_lock()</tt> for each argument in order
beginning with the first until all arguments have been processed or a
call to <tt>try_lock()</tt> fails, either by returning <tt>false</tt> or by throwing an
exception. If a call to <tt>try_lock()</tt> fails, <tt>unlock()</tt> shall be called for
all prior arguments<ins> and there shall be no further calls to <tt>try_lock()</tt></ins>.
</blockquote>

<p>
Delete the note from 30.4.3 [thread.lock.algorithm], p3
</p>

<blockquote>
-3- <i>Returns:</i> -1 if all calls to <tt>try_lock()</tt> returned <tt>true</tt>,
otherwise a 0-based index value that indicates 
the argument for which <tt>try_lock()</tt> returned <tt>false</tt>. <del>[<i>Note:</i>
On return, either all arguments will be 
locked or none will be locked. -- <i>end note</i>]</del>
</blockquote>





<hr>
<h3><a name="987"></a>987. <tt>reference_wrapper</tt> and function types</h3>
<p><b>Section:</b> 20.8.4 [refwrap] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-02-18 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#refwrap">issues</a> in [refwrap].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The synopsis in 20.8.4 [refwrap] says:
</p>

<blockquote><pre>template &lt;<b>ObjectType</b> T&gt; class reference_wrapper
...
</pre></blockquote>

<p>
And then paragraph 3 says:
</p>

<blockquote>
<p>
The template instantiation <tt>reference_wrapper&lt;T&gt;</tt> shall be
derived from <tt>std::unary_function&lt;T1, R&gt;</tt> only if the type
<tt>T</tt> is any of the following:
</p>

<ul>
<li>
a <b>function type</b> or a pointer to function type taking one argument of
type <tt>T1</tt> and returning <tt>R</tt>
</li>
</ul>
</blockquote>

<p>
But function types are not <tt>ObjectType</tt>s.
</p>

<p>
Paragraph 4 contains the same contradiction.
</p>

<p><i>[
Post Summit:
]</i></p>


<blockquote>
<p>
Jens: restricted reference to ObjectType
</p>
<p>
Recommend Review.
</p>
</blockquote>

<p><i>[
Post Summit, Peter adds:
]</i></p>


<blockquote>
<p>
In <a href="https://svn.boost.org/trac/boost/ticket/1846">https://svn.boost.org/trac/boost/ticket/1846</a>
however Eric Niebler makes the very reasonable point that <tt>reference_wrapper&lt;F&gt;</tt>,
where <tt>F</tt> is a function type, represents a reference to a function,
a legitimate entity. So <tt>boost::ref</tt> was changed to allow it.
</p>
<p>
<a href="https://svn.boost.org/trac/boost/browser/trunk/libs/bind/test/ref_fn_test.cpp">https://svn.boost.org/trac/boost/browser/trunk/libs/bind/test/ref_fn_test.cpp</a>
</p>
<p>
Therefore, I believe an alternative proposed resolution for issue 987 could simply
allow <tt>reference_wrapper</tt> to be used with function types.
</p>
</blockquote>

<p><i>[
Post Summit, Howard adds:
]</i></p>


<blockquote>
<p>
I agree with Peter (and Eric).  I got this one wrong on my first try.  Here
is code that demonstrates how easy (and useful) it is to instantiate
<tt>reference_wrapper</tt> with a function type:
</p>

<blockquote><pre>#include &lt;functional&gt;

template &lt;class F&gt;
void test(F f);

void f() {}

int main()
{
    test(std::ref(f));
}
</pre></blockquote>

<p>
Output (link time error shows type of <tt>reference_wrapper</tt> instantiated
with function type):
</p>

<blockquote><pre>Undefined symbols:
  "void test&lt;std::reference_wrapper&lt;void ()()&gt; &gt;(std::reference_wrapper&lt;void ()()&gt;)",...
</pre></blockquote>

<p>
I've taken the liberty of changing the proposed wording to allow function types
and set to Open.  I'll also freely admit that I'm not positive <tt>ReferentType</tt>
is the correct concept.
</p>

</blockquote>



<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Howard observed that <tt>FunctionType</tt>,
a concept not (yet?) in the Working Paper,
is likely the correct constraint to be applied.
However, the proposed resolution provides an adequate approximation.
</p>
<p>
Move to Review.
</p>
</blockquote>

<p><i>[
2009-05-23 Alisdair adds:
]</i></p>


<blockquote>
<p>
By constraining to <tt>PointeeType</tt> we rule out the ability for <tt>T</tt> to be a
reference, and call in reference-collapsing.  I'm not sure if this is
correct and intended, but would like to be sure the case was considered.
</p>
<p>
Is dis-allowing reference types and the
implied reference collapsing the intended result?
</p>
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
Moved from Review to Open only because the wording needs to be
tweaked for concepts removal.
</blockquote>

<p><i>[
2009-10-14 Daniel provided de-conceptified wording.
]</i></p>


<p><i>[
2009-10 post-Santa Cruz:
]</i></p>


<blockquote>
Move to Tentatively Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 20.8.4 [refwrap]/1 as indicated:
</p>

<blockquote>
<tt>reference_wrapper&lt;T&gt;</tt> is a <tt>CopyConstructible</tt> and
<tt><ins>Copy</ins>Assignable</tt> wrapper around a
reference to an object <ins>or function</ins> of type <tt>T</tt>.
</blockquote>








<hr>
<h3><a name="990"></a>990. <tt>monotonic_clock::is_monotonic</tt> must be <tt>true</tt></h3>
<p><b>Section:</b> X [time.clock.monotonic] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-03-09 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#time.clock.monotonic">issues</a> in [time.clock.monotonic].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There is some confusion over what the value of <tt>monotonic_clock::is_monotonic</tt>
when <tt>monotonic_clock</tt> is a  synonym for <tt>system_clock</tt>.  The
intent is that if <tt>monotonic_clock</tt> exists, then <tt>monotonic_clock::is_monotonic</tt>
is <tt>true</tt>.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We agree with the proposed resolution.
</p>
<p>
Move to Tentatively Ready.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change X [time.clock.monotonic], p1:
</p>

<blockquote>
-1- Objects of class <tt>monotonic_clock</tt> represent clocks for which
values of <tt>time_point</tt> never decrease as physical time advances.
<tt>monotonic_clock</tt> may be a synonym for <tt>system_clock</tt>
<ins>if and only if <tt>system_clock::is_monotonic</tt> is
<tt>true</tt></ins>.
</blockquote>





<hr>
<h3><a name="991"></a>991. Response to JP 50</h3>
<p><b>Section:</b> 22.3.3.2.2 [conversions.string] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> P.J. Plauger <b>Opened:</b> 2009-03-03 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#conversions.string">issues</a> in [conversions.string].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Add custom allocator parameter to <tt>wstring_convert</tt>, since we cannot
allocate memory for strings from a custom allocator.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution.
Move to Tentatively Ready.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 22.3.3.2.2 [conversions.string]:
</p>

<blockquote><pre>template&lt;class Codecvt, class Elem = wchar_t<ins>,
         class Wide_alloc = std::allocator&lt;Elem&gt;,
         class Byte_alloc = std::allocator&lt;char&gt; </ins>&gt; class wstring_convert {
  public:
    typedef std::basic_string&lt;char<ins>, char_traits&lt;char&gt;, Byte_alloc</ins>&gt; byte_string;
    typedef std::basic_string&lt;Elem<ins>, char_traits&lt;Elem&gt;, Wide_alloc</ins>&gt; wide_string;
     ...
</pre></blockquote>

<p>
Change 22.3.3.2.2 [conversions.string], p3:
</p>

<blockquote>
-3- The class template describes an ob ject that controls conversions
between wide string ob jects of class
<tt>std::basic_string&lt;Elem<ins>, char_traits&lt;Elem&gt;, Wide_alloc</ins>&gt;</tt>
and byte string objects of class
<tt>std::basic_string&lt;char<ins>, char_traits&lt;char&gt;, Byte_alloc</ins>&gt;</tt>
<del>(also known as <tt>std::string</tt>)</del>.
</blockquote>






<hr>
<h3><a name="993"></a>993. Response to UK 188</h3>
<p><b>Section:</b> 18.5 [support.start.term] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> P.J. Plauger <b>Opened:</b> 2009-03-03 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#support.start.term">issues</a> in [support.start.term].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The function <tt>_Exit</tt> does not appear to be defined in this standard.
Should it be added to the table of functions included-by-reference to
the C standard?
</p>

<p><i>[
2009-05-09 Alisdair fixed some minor issues in the wording.
]</i></p>


<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution.
Move to Tentatively Ready.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Add to 18.5 [support.start.term] Table 20 (Header
<tt>&lt;cstdlib&gt;</tt> synopsis) Functions:
</p>

<blockquote><pre>_Exit
</pre></blockquote>

<p>
Add before the description of <tt>abort(void)</tt>:
</p>

<blockquote><pre>void _Exit [[noreturn]] (int status)
</pre>

<blockquote>
<p>
The function <tt>_Exit(int status)</tt> has additional behavior in this
International Standard:
</p>
<ul>
<li>
The program is terminated without executing destructors for objects of
automatic, thread, or static storage duration and without calling the
functions passed to <tt>atexit()</tt> (3.6.3 [basic.start.term]).
</li>
</ul>
</blockquote>
</blockquote>






<hr>
<h3><a name="994"></a>994. Response to UK 193</h3>
<p><b>Section:</b> 18.6.2.3 [new.handler] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> P.J. Plauger <b>Opened:</b> 2009-03-03 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>quick_exit</tt> has been added as a new valid way to terminate a program in a
well defined way
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution.
Move to Tentatively Ready.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 18.6.2.3 [new.handler], p2:
</p>

<blockquote>
<p>
-2- <i>Required behavior:</i> ...
</p>
<ul>
<li>...</li>
<li>
<del>call either <tt>abort()</tt> or <tt>exit();</tt></del>
<ins>terminate execution of the program without returning to the caller</ins>
</li>
</ul>
</blockquote>







<hr>
<h3><a name="997"></a>997. Response to UK 163</h3>
<p><b>Section:</b> 17.5.1.4 [structure.specifications] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Thomas Plum <b>Opened:</b> 2009-03-03 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#structure.specifications">issues</a> in [structure.specifications].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Many functions are defined as "Effects: Equivalent to a...", which seems
to also define the preconditions, effects, etc. But this is not made
clear.
</p>

<p>
After studying the occurrences of "Effects: Equivalent to", I agree with
the diagnosis but disagree with the solution.  In 21.4.2 [string.cons]
we find
</p>

<blockquote>
<p>
14 <i>Effects:</i> If <tt>InputIterator</tt> is an integral type, equivalent to
<tt>basic_string(static_cast&lt;size_type&gt;(begin), static_cast&lt;value_type&gt;(end), a)</tt>
</p>
<p>
15 Otherwise constructs a string from the values in the range <tt>[begin,
end)</tt>, as indicated in the Sequence Requirements table (see 23.1.3).
</p>
</blockquote>

<p>
This would be devishly difficult to re-write with an explicit
"Equivalent to:" clause.  Instead, I propose the following, which will
result in much less editorial re-work.
</p>

<p><i>[
2009-05-09 Alisdair adds:
]</i></p>


<blockquote>
This issue is related to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#492">492</a>.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution.
Move to Tentatively Ready.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Add a new paragraph after 17.5.1.4 [structure.specifications], p3:
</p>

<blockquote>
<p>
-3- Descriptions of function semantics contain the following elements (as appropriate):<sup>154</sup>
</p>

<ul>
<li>
<i>Requires:</i> the preconditions for calling the function
</li>
<li>
<i>Effects:</i> the actions performed by the function
</li>
<li>
<i>Postconditions:</i> the observable results established by the function
</li>
<li>
<i>Returns:</i> a description of the value(s) returned by the function
</li>
<li>
<i>Throws:</i> any exceptions thrown by the function, and the conditions that would cause the exception
</li>
<li>
<i>Complexity:</i> the time and/or space complexity of the function
</li>
<li>
<i>Remarks:</i> additional semantic constraints on the function
</li>
<li>
<i>Error conditions:</i> the error conditions for error codes reported by the function.
</li>
<li>
<i>Notes:</i> non-normative comments about the function
</li>
</ul>

<p><ins>
Whenever the <i>Effects</i> element specifies that the semantics of some
function <tt>F</tt> are <i>Equivalent to</i> some <i>code-sequence</i>, then
the various elements are interpreted as follows.  If <tt>F</tt>'s
semantics specifies a <i>Requires</i> element, then that requirement is
logically imposed prior to the <i>equivalent-to</i> semantics.  Then,
the semantics of the <i>code-sequence</i> are determined by the
<i>Requires</i>, <i>Effects</i>, <i>Postconditions</i>, <i>Returns</i>,
<i>Throws</i>, <i>Complexity</i>, <i>Remarks</i>, <i>Error
Conditions</i> and <i>Notes</i> specified for the (one or more) function
invocations contained in the <i>code-sequence</i>. The value returned from
<tt>F</tt> is specified by <tt>F</tt>'s <i>Returns</i> element, or
if <tt>F</tt> has no <i>Returns</i> element, a non-<tt>void</tt> return from <tt>F</tt> is specified 
by the <i>Returns</i> elements in <i>code-sequence</i>.  If
<tt>F</tt>'s semantics contains a <i>Throws</i> (or
<i>Postconditions</i>, or <i>Complexity</i>) element, then that
supersedes any occurrences of that element in the <i>code-sequence</i>.
</ins></p>
</blockquote>






<hr>
<h3><a name="998"></a>998. Smart pointer referencing its owner</h3>
<p><b>Section:</b> 20.9.9.2.5 [unique.ptr.single.modifiers] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Pavel Minaev <b>Opened:</b> 2009-02-26 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#unique.ptr.single.modifiers">issues</a> in [unique.ptr.single.modifiers].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Consider the following (simplified) implementation of 
<tt>std::auto_ptr&lt;T&gt;::reset()</tt>: 
</p>

<blockquote><pre>void reset(T* newptr = 0) { 
   if (this-&gt;ptr &amp;&amp; this-&gt;ptr != newptr) { 
     delete this-&gt;ptr; 
   } 
   this-&gt;ptr = newptr; 
} 
</pre></blockquote>

<p>
Now consider the following code which uses the above implementation: 
</p>

<blockquote><pre>struct foo { 
   std::auto_ptr&lt;foo&gt; ap; 
   foo() : ap(this) {} 
   void reset() { ap.reset(); } 
}; 
int main() { 
   (new foo)-&gt;reset(); 
} 
</pre></blockquote>

<p>
With the above implementation of auto_ptr, this results in U.B. at the 
point of auto_ptr::reset(). If this isn't obvious yet, let me explain 
how this goes step by step: 
</p>

<ol>
<li>
<tt>foo::reset()</tt> entered 
</li>
<li>
<tt>auto_ptr::reset()</tt> entered 
</li>
<li>
<tt>auto_ptr::reset()</tt> tries to delete <tt>foo</tt>
</li>
<li>
<tt>foo::~foo()</tt> entered, tries to destruct its members 
</li>
<li>
<tt>auto_ptr::~auto_ptr()</tt> executed - <tt>auto_ptr</tt> is no longer a valid object! 
</li>
<li>
<tt>foo::~foo()</tt> left 
</li>
<li>
<tt>auto_ptr::reset()</tt> sets its "ptr" field to 0 &lt;- U.B.! <tt>auto_ptr</tt>
is not a valid object here already! 
</li>
</ol>

<p><i>[
Thanks to Peter Dimov who recognized the connection to <tt>unique_ptr</tt> and
brought this to the attention of the LWG, and helped with the solution.
]</i></p>


<p><i>[
Howard adds:
]</i></p>


<blockquote>
To fix this behavior <tt>reset</tt> must be specified such that deleting the
pointer is the last action to be taken within <tt>reset</tt>.
</blockquote>

<p><i>[
Alisdair adds:
]</i></p>


<blockquote>
<p>
The example providing the rationale for LWG <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#998">998</a> is poor, as it relies on
broken semantics of having two object believing they are unique owners of a
single resource.  It should not be surprising that UB results from such
code, and I feel no need to go out of our way to support such behaviour.
</p>
<p>
If an example is presented that does not imply multiple ownership of a
unique resource, I would be much more ready to accept the proposed
resolution.
</p>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Howard summarizes:
</p>
<blockquote>
This issue has to do with circular ownership,
and affects <tt>auto_ptr</tt>, too (but we don't really care about that).
It is intended to spell out the order in which operations must be performed
so as to avoid the possibility
of undefined behavior in the self-referential case.
</blockquote>
<p>
Howard points to message c++std-lib-23175 for another example,
requested by Alisdair.
</p>
<p>
We agree with the issue and with the proposed resolution.
Move to Tentatively Ready.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 20.9.9.2.5 [unique.ptr.single.modifiers], p5 (<i>Effects</i> clause for <tt>reset</tt>), and p6:
</p>

<blockquote>
<p>
-5- <i>Effects:</i> <del>If <tt>get() == nullptr</tt> there are no effects. Otherwise <tt>get_deleter()(get())</tt>.</del>
<ins>Assigns <tt>p</tt> to the stored <tt>pointer</tt>, and then if the old value of the <tt>pointer</tt> is not
equal to <tt>nullptr</tt>, calls <tt>get_deleter()(</tt>the old value of the <tt>pointer)</tt>.
[<i>Note:</i> The order of these operations is significant because the call to <tt>get_deleter()</tt>
may destroy <tt>*this</tt>. <i>-- end note</i>]</ins>
</p>

<p>
-6- Postconditions: <tt>get() == p</tt>.
<ins>[<i>Note:</i> The postcondition does not hold if the call to
<tt>get_deleter()</tt> destroys <tt>*this</tt> since <tt>this-&gt;get()</tt> is no longer a valid
expression. <i>-- end note</i>]</ins>
</p>
</blockquote>





<hr>
<h3><a name="999"></a>999. Taking the address of a function</h3>
<p><b>Section:</b> 20.9.8 [specialized.algorithms] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Peter Dimov <b>Opened:</b> 2009-03-09 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#specialized.algorithms">issues</a> in [specialized.algorithms].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The same fix (reference <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#987">987</a>) may be applied to <tt>addressof</tt>, which is also constrained to
<tt>ObjectType</tt>. (That was why <tt>boost::ref</tt> didn't work with functions - it
tried to apply <tt>boost::addressof</tt> and the <tt>reinterpret_cast&lt;char&amp;&gt;</tt>
implementation of <tt>addressof</tt> failed.)
</p>



<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We agree.
</p>
<p>
Move to Tentatively Ready.
</p>
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
Moved from Tentatively Ready to Open only because the wording needs to be
tweaked for concepts removal.
</blockquote>

<p><i>[
2009-10-10 Daniel updates wording to concept-free.
]</i></p>


<p><i>[
2009-10 post-Santa Cruz:
]</i></p>


<blockquote>
Move to Tentatively Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p><i>[
The resolution assumes that <tt>addressof</tt> is reintroduced as described in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2946.pdf">n2946</a>
]</i></p>


<p>
In 20.9.8 [specialized.algorithms] change as described:
</p>

<blockquote><pre>template &lt;class T&gt; T* addressof(T&amp; r);
</pre>
<blockquote>
<i>Returns:</i> The actual address of the object <ins>or function</ins>
referenced by <tt>r</tt>, even in the
presence of an overloaded <tt>operator&amp;</tt>.
</blockquote>
</blockquote>







<hr>
<h3><a name="1004"></a>1004. Response to UK 179</h3>
<p><b>Section:</b> 17.6.3.8 [res.on.functions] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#res.on.functions">issues</a> in [res.on.functions].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 179</b></p>

<p>
According to the 4th bullet there is a problem if "if any replacement
function or handler function or destructor operation throws an
exception". There should be no problem throwing exceptions so long as
they are caught within the function.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
The phrasing "throws an exception" is commonly used elsewhere
to mean "throws or propagates an exception."
Move to Open pending a possible more general resolution.
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
Replace "propagates" in the proposed resolution with the phrase "exits
via" and move to Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change the 4th bullet of 17.6.3.8 [res.on.functions], p2:
</p>

<blockquote>
<ul>
<li>
if any replacement function or handler function or destructor operation
<del>throws</del> <ins>exits via</ins> an exception, unless specifically
allowed in the applicable <i>Required behavior:</i> paragraph.
</li>
</ul>
</blockquote>






<hr>
<h3><a name="1006"></a>1006. <tt>operator delete</tt> in garbage collected implementation</h3>
<p><b>Section:</b> 18.6.1 [new.delete] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#new.delete">issues</a> in [new.delete].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 190</b></p>

<p>
It is not entirely clear how the current specification acts in the
presence of a garbage collected implementation.
</p>

<p><i>[
Summit:
]</i></p>

 
<blockquote>
Agreed.
</blockquote>

<p><i>[
2009-05-09 Alisdair adds:
]</i></p>


<blockquote>
Proposed wording is too strict for implementations that do not support
garbage collection.  Updated wording supplied.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We recommend advancing this to Tentatively Ready
with the understanding that it will not be moved for adoption
unless and until the proposed resolution to Core issue #853 is adopted.
</blockquote>


<p><b>Proposed resolution:</b></p>

<p>
(Editorial note: This wording ties into the proposed
resolution for Core #853)
</p>

<p>
Add paragraphs to 18.6.1.1 [new.delete.single]:
</p>

<blockquote><pre>void operator delete(void* ptr) throw();
<del>void operator delete(void* ptr, const std::nothrow_t&amp;) throw();</del>
</pre>

<p><i>[
The second signature deletion above is editorial.
]</i></p>


<blockquote>
<p><ins>
<i>Requires:</i> If an implementation has strict pointer safety
(3.7.4.3 [basic.stc.dynamic.safety]) then <tt>ptr</tt> shall
be a safely-derived pointer.
</ins></p>

<p>-10- ...</p>
</blockquote>

<pre>void operator delete(void* ptr, const std::nothrow_t&amp;) throw();
</pre>

<blockquote>
<p><ins>
<i>Requires:</i> If an implementation has strict pointer safety
(3.7.4.3 [basic.stc.dynamic.safety]) then <tt>ptr</tt> shall
be a safely-derived pointer.
</ins></p>

<p>-15- ...</p>
</blockquote>

</blockquote>

<p>
Add paragraphs to 18.6.1.2 [new.delete.array]:
</p>

<blockquote><pre>void operator delete[](void* ptr) throw();
<del>void operator delete[](void* ptr, const std::nothrow_t&amp;) throw();</del>
</pre>

<p><i>[
The second signature deletion above is editorial.
]</i></p>


<blockquote>
<p><ins>
<i>Requires:</i> If an implementation has strict pointer safety
(3.7.4.3 [basic.stc.dynamic.safety]) then <tt>ptr</tt> shall
be a safely-derived pointer.
</ins></p>

<p>-9- ...</p>
</blockquote>

<pre>void operator delete[](void* ptr, const std::nothrow_t&amp;) throw();
</pre>

<blockquote>
<p><ins>
<i>Requires:</i> If an implementation has strict pointer safety
(3.7.4.3 [basic.stc.dynamic.safety]) then <tt>ptr</tt> shall
be a safely-derived pointer.
</ins></p>

<p>-13- ...</p>
</blockquote>

</blockquote>


<p>
Add paragraphs to 18.6.1.3 [new.delete.placement]:
</p>

<blockquote><pre>void operator delete(void* ptr, void*) throw();
</pre>

<blockquote>
<p><ins>
<i>Requires:</i> If an implementation has strict pointer safety
(3.7.4.3 [basic.stc.dynamic.safety]) then <tt>ptr</tt> shall
be a safely-derived pointer.
</ins></p>

<p>-7- ...</p>
</blockquote>

<pre>void operator delete[](void* ptr, void*) throw();
</pre>

<blockquote>
<p><ins>
<i>Requires:</i> If an implementation has strict pointer safety
(3.7.4.3 [basic.stc.dynamic.safety]) then <tt>ptr</tt> shall
be a safely-derived pointer.
</ins></p>

<p>-9- ...</p>
</blockquote>

</blockquote>






<hr>
<h3><a name="1011"></a>1011. <tt>next/prev</tt> wrong iterator type</h3>
<p><b>Section:</b> 24.4.4 [iterator.operations] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#iterator.operations">issues</a> in [iterator.operations].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 271</b></p>

<p>
<tt>next/prev</tt> return an incremented iterator without changing the value of
the original iterator. However, even this may invalidate an
<tt>InputIterator</tt>. A <tt>ForwardIterator</tt> is required to guarantee the
'multipass' property.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution.
Move to Tentatively Ready.
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
Moved from Tentatively Ready to Open only because the wording needs to be
tweaked for concepts removal.
</blockquote>

<p><i>[
2009-10-14 Daniel provided de-conceptified wording.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Moved to Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>


<ol>
<li>
<p>
Change header <tt>&lt;iterator&gt;</tt> synopsis 24.3 [iterator.synopsis] as indicated:
</p>

<blockquote><pre>// 24.4.4, iterator operations:
...
template &lt;class <del>Input</del><ins>Forward</ins>Iterator&gt;
  <del>Input</del><ins>Forward</ins>Iterator
  next(<del>Input</del><ins>Forward</ins>Iterator x, typename std::iterator_traits&lt;<del>Input</del><ins>Forward</ins>Iterator&gt;::difference_type n = 1);
</pre></blockquote>
</li>

<li>
<p>
Change 24.4.4 [iterator.operations] before p.6 as indicated:
</p>

<blockquote><pre>template &lt;class <del>Input</del><ins>Forward</ins>Iterator&gt;
  <del>Input</del><ins>Forward</ins>Iterator
  next(<del>Input</del><ins>Forward</ins>Iterator x, typename std::iterator_traits&lt;<del>Input</del><ins>Forward</ins>Iterator&gt;::difference_type n = 1);
</pre></blockquote>
</li>
</ol>






<hr>
<h3><a name="1012"></a>1012. <tt>reverse_iterator</tt> default ctor should value initialize</h3>
<p><b>Section:</b> 24.5.1.3.1 [reverse.iter.cons] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 277</b></p>

<p>
The default constructor default-initializes current, rather than
value-initializes. This means that when Iterator corresponds to a
trivial type, the current member is left un-initialized, even when the
user explictly requests value intialization! At this point, it is not
safe to perform any operations on the reverse_iterator other than assign
it a new value or destroy it. Note that this does correspond to the
basic definition of a singular iterator.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Agree with option i.
</blockquote>

<p>
Related issue: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#408">408</a>
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We believe this should be revisited
in conjunction with issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#408">408</a>,
which nearly duplicates this issue.
Move to Open.
</blockquote>

<p><i>[
2009-07 post-Frankfurt:
]</i></p>


<blockquote>
<p>
Change "constructed" to "initialized" in two places in the proposed resolution.
</p>
<p>
Move to Tentatively Ready.
</p>
</blockquote>

<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote>
Moved to Ready for this meeting.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change  [reverse.iter.con]:
</p>

<blockquote><pre>reverse_iterator();
</pre>
<blockquote>
-1- <i>Effects:</i> <del>Default</del> <ins>Value</ins> initializes <tt>current</tt>. Iterator
operations applied to the resulting iterator have defined behavior if and
only if the corresponding operations are defined on a <del>default constructed</del>
<ins>value initialized</ins>
iterator of type <tt>Iterator</tt>.
</blockquote>
</blockquote>

<p>
Change 24.5.3.3.1 [move.iter.op.const]:
</p>

<blockquote><pre>move_iterator();
</pre>
<blockquote>
-1- <i>Effects:</i> Constructs a <tt>move_iterator</tt>, <del>default</del> <ins>value</ins>
initializing <tt>current</tt>.
<ins>Iterator
operations applied to the resulting iterator have defined behavior if and
only if the corresponding operations are defined on a
value initialized
iterator of type <tt>Iterator</tt>.</ins>
</blockquote>
</blockquote>






<hr>
<h3><a name="1014"></a>1014. Response to UK 317 and JP 74</h3>
<p><b>Section:</b> 28.8.2 [re.regex.construct] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#re.regex.construct">issues</a> in [re.regex.construct].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 317 and JP 74</b></p>

<p>
UK 317:
</p>

<blockquote>
<tt>basic_string</tt> has both a constructor and an assignment operator that
accepts an initializer list, <tt>basic_regex</tt> should have the same.
</blockquote>

<p>
JP 74:
</p>

<blockquote>
<tt>basic_regx &amp; operator= (initializer_list&lt;T&gt;);</tt> is not defined.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
UK 317 asks for both assignment and constructor,
but the requested constructor is already present in the current Working Paper.
We agree with the proposed resolution.
Move to Tentatively Ready.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 28.8 [re.regex]:
</p>

<blockquote><pre>template &lt;class charT,
          class traits = regex_traits&lt;charT&gt; &gt;
class basic_regex {
  ...
  basic_regex&amp; operator=(const charT* ptr);
  <ins>basic_regex&amp; operator=(initializer_list&lt;charT&gt; il);</ins>
  template &lt;class ST, class SA&gt;
    basic_regex&amp; operator=(const basic_string&lt;charT, ST, SA&gt;&amp; p);
  ...
};
</pre></blockquote>

<p>
Add in  28.8.2 [re.regex.construct]:
</p>

<blockquote>
<blockquote>
-20- ...
</blockquote>
<pre>basic_regex&amp; operator=(initializer_list&lt;charT&gt; il);
</pre>
<blockquote>
-21- <i>Effects:</i> returns <tt>assign(il.begin(), il.end());</tt>
</blockquote>
</blockquote>






<hr>
<h3><a name="1019"></a>1019. Response to UK 205</h3>
<p><b>Section:</b> 20.7.3 [meta.help] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#meta.help">issues</a> in [meta.help].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 205</b></p>

<p>
<tt>integral_constant</tt> objects should be usable in integral-constant-expressions.
The addition to the language of literal types and the enhanced rules for
constant expressions make this possible.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree that the <tt>static</tt> data member
ought be declared <tt>constexpr</tt>,
but do not see a need for the proposed <tt>operator value_type()</tt>.
(A use case would be helpful.)
Move to Open.
</blockquote>

<p><i>[
2009-05-23 Alisdair adds:
]</i></p>


<blockquote>
<p>
The motivating case in my mind is that we can then use
<tt>true_type</tt> and <tt>false_type</tt> as integral Boolean expressions, for example inside
a <tt>static_assert</tt> declaration.  In that sense it is purely a matter of style.
</p>
<p>
Note that Boost has applied the non-explicit conversion operator for many
years as it has valuable properties for extension into other metaprogramming
libraries, such as MPL.  If additional rationale is desired I will poll the
Boost lists for why this extension was originally applied.  I would argue
that explicit conversion is more appropriate for 0x though.
</p>
</blockquote>

<p><i>[
2009-07-04 Howard adds:
]</i></p>


<blockquote>
<p>
Here's a use case which demonstrates the syntactic niceness which Alisdair describes:
</p>

<blockquote><pre>#define requires(...) class = typename std::enable_if&lt;(__VA_ARGS__)&gt;::type

template &lt;class T, class U,
    requires(!is_lvalue_reference&lt;T&gt;() ||
              is_lvalue_reference&lt;T&gt;() &amp;&amp; is_lvalue_reference&lt;U&gt;()),
    requires(is_same&lt;typename base_type&lt;T&gt;::type,
                     typename base_type&lt;U&gt;::type&gt;)&gt;
inline
T&amp;&amp;
forward(U&amp;&amp; t)
{
    return static_cast&lt;T&amp;&amp;&gt;(t);
}
</pre></blockquote>
</blockquote>

<p><i>[
2009-07 post-Frankfurt:
]</i></p>


<blockquote>
Move to Tentatively Ready.
</blockquote>

<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote>
Moved to Ready for this meeting.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add to the <tt>integral_constant</tt> struct definition in 20.7.3 [meta.help]:
</p>

<blockquote><pre>template &lt;class T, T v&gt;
struct integral_constant {
  static const<ins>expr</ins> T value = v;
  typedef T value_type;
  typedef integral_constant&lt;T,v&gt; type;
  <ins>constexpr operator value_type() { return value; }</ins>
};
</pre></blockquote>





<hr>
<h3><a name="1021"></a>1021. Response to UK 211</h3>
<p><b>Section:</b> 20.9.9.2.3 [unique.ptr.single.asgn] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 211</b></p>

<p>
The <tt>nullptr_t</tt> type was introduced to resolve the null pointer literal
problem. It should be used for the assignemnt operator, as with the
constructor and elsewhere through the library.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution.
Move to Tentatively Ready.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change the synopsis in 20.9.9.2 [unique.ptr.single]:
</p>

<blockquote><pre>unique_ptr&amp; operator=(<del><i>unspecified-pointer-type</i></del> <ins>nullptr_t</ins>);
</pre></blockquote>

<p>
Change 20.9.9.2.3 [unique.ptr.single.asgn]:
</p>

<blockquote><pre>unique_ptr&amp; operator=(<del><i>unspecified-pointer-type</i></del> <ins>nullptr_t</ins>);
</pre>
<blockquote>
<del>Assigns from the literal 0 or <tt>NULL</tt>. [<i>Note:</i> The
<i>unspecified-pointer-type</i> is often implemented as a pointer to a
private data member, avoiding many of the implicit conversion pitfalls.
<i>-- end note</i>]</del>
</blockquote>
</blockquote>





<hr>
<h3><a name="1030"></a>1030. Response to JP 44</h3>
<p><b>Section:</b> 20.9.10.5 [util.smartptr.shared.atomic] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses JP 44</b></p>

<p>
The 1st parameter <tt>p</tt> and 2nd parameter <tt>v</tt> is now
<tt>shared_ptr&lt;T&gt;*</tt>.
</p>
<p>
It should be <tt>shared_ptr&lt;T&gt;&amp;</tt>, or if these are
<tt>shared_ptr&lt;T&gt;*</tt> then add the "<tt>p</tt> shall not be a
null pointer" at the requires.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Agree. All of the functions need a requirement that <tt>p</tt> (or
<tt>v</tt>) is a pointer to a valid object.
</blockquote>

<p><i>[
2009-07 post-Frankfurt:
]</i></p>


<blockquote>
<p>
Lawrence explained that these signatures match the regular atomics. The
regular atomics must not use references because these signatures are
shared with C. The decision to pass shared_ptrs by pointer rather than
by reference was deliberate and was motivated by the principle of least
surprise.
</p>
<p>
Lawrence to write wording that requires that the pointers not be null.
</p>
</blockquote>

<p><i>[
2009-09-20 Lawrence provided wording:
]</i></p>


<blockquote>
<p>
The parameter types for atomic shared pointer access
were deliberately chosen to be pointers
to match the corresponding parameters of the atomics chapter.
Those in turn were deliberately chosen
to match C functions,
which do not have reference parameters.
</p>
<p>
We adopt the second suggestion,
to require that such pointers not be null.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Moved to Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
In section "<code>shared_ptr</code> atomic access"
20.9.10.5 [util.smartptr.shared.atomic], add to each function the
following clause.
</p>
<blockquote><p>
<i>Requires:</i> <code>p</code> shall not be null.
</p></blockquote>





<hr>
<h3><a name="1033"></a>1033. <tt>thread::join()</tt> effects?</h3>
<p><b>Section:</b> 30.3.1.5 [thread.thread.member] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Alberto Ganesh Barbati <b>Opened:</b> 2009-03-12 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.thread.member">issues</a> in [thread.thread.member].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>

<p>
While looking at <tt>thread::join()</tt> I think I spotted a couple of
possible defects in the specifications. I could not find a previous
issue or NB comment about that, but I might have missed it.
</p>

<p>
The postconditions clause for <tt>thread::join()</tt> is:
</p>

<blockquote>
<i>Postconditions:</i> If <tt>join()</tt> throws an exception, the value
returned by <tt>get_id()</tt> is unchanged. Otherwise, <tt>get_id() == id()</tt>.
</blockquote>

<p>
and the throws clause is:
</p>

<blockquote>
<i>Throws:</i> <tt>std::system_error</tt> when the postconditions cannot be achieved.
</blockquote>

<p>
Now... how could the postconditions <em>not</em> be achieved?
It's just a matter of resetting the value of <tt>get_id()</tt> or leave it
unchanged! I bet we can always do that. Moreover, it's a chicken-and-egg
problem: in order to decide whether to throw or not I depend on the
postconditions, but the postconditions are different in the two cases.
</p>

<p>
I believe the throws clause should be:
</p>

<blockquote>
<i>Throws:</i> <tt>std::system_error</tt> when the effects or postconditions
cannot be achieved.
</blockquote>

<p>
as it is in <tt>detach()</tt>, or, even better, as the postcondition is
trivially satisfiable and to remove the circular dependency:
</p>


<blockquote>
<i>Throws:</i> <tt>std::system_error</tt> if the effects cannot be achieved.
</blockquote>

<p>
Problem is that... ehm... <tt>join()</tt> has no "Effects" clause. Is that intentional?
</p>

<p><i>[
See the thread starting at c++std-lib-23204 for more discussion.
]</i></p>


<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Pete believes there may be some more general language (in frontmatter)
that can address this and related issues such as <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#962">962</a>.
</p>
<p>
Move to Open.
</p>
</blockquote>

<p><i>[
2009-11-18 Anthony provides wording.
]</i></p>



<p><i>[
2010-02-12 Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>


<p><b>Proposed resolution:</b></p>
<p>
Edit 30.3.1.5 [thread.thread.member] as indicated:
</p>

<blockquote><pre>void join();
</pre>
<blockquote>
<p>
5 <i>Precondition:</i> <tt>joinable()</tt> is <tt>true</tt>.
</p>
<p><ins>
<i>Effects:</i> Blocks until the thread represented by <tt>*this</tt> has completed.
</ins></p>

<p>
6 <i>Synchronization:</i> The completion of the thread represented by
<tt>*this</tt> happens before (1.10 [intro.multithread])
<tt>join()</tt> returns. [<i>Note:</i> Operations on <tt>*this</tt> are not
synchronized.  <i>end note</i>]
</p>

<p>
7 <i>Postconditions:</i> <del>If <tt>join()</tt> throws an exception, the value
returned by <tt>get_id()</tt> is unchanged. Otherwise,</del> <ins>The thread
represented by <tt>*this</tt> has completed.</ins> <tt>get_id() == id()</tt>.
</p>

<p>
8 ...
</p>


</blockquote>
</blockquote>






<hr>
<h3><a name="1034"></a>1034. Response to UK 222</h3>
<p><b>Section:</b> 23.2.1 [container.requirements.general] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-12 <b>Last modified:</b> 2010-10-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#container.requirements.general">active issues</a> in [container.requirements.general].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#container.requirements.general">issues</a> in [container.requirements.general].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 222</b></p>

<p>
It is not clear what purpose the Requirement tables serve in the
Containers clause. Are they the definition of a library Container? Or
simply a conventient shorthand to factor common semantics into a single
place, simplifying the description of each subsequent container? This
becomes an issue for 'containers' like <tt>array</tt>, which does not meet the
default-construct-to-empty requirement, or <tt>forward_list</tt> which does not
support the size operation. Are these components no longer containers?
Does that mean the remaining requirements don't apply? Or are these
contradictions that need fixing, despite being a clear design decision?
</p>

<p>
Recommend:
</p>

<p>
Clarify all the tables in 23.2 [container.requirements] are
there as a convenience for documentation, rather than a strict set of
requirements. Containers should be allowed to relax specific
requirements if they call attention to them in their documentation. The
introductory text for <tt>array</tt> should be expanded to mention a
default constructed <tt>array</tt> is not empty, and
<tt>forward_list</tt> introduction should mention it does not provide
the required <tt>size</tt> operation as it cannot be implemented
efficiently.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Agree in principle.
</blockquote>

<p><i>[
2009-07 post-Frankfurt:
]</i></p>


<blockquote>
We agree in principle, but we have a timetable. This group feels that
the issue should be closed as NAD unless a proposed resolution is
submitted prior to the March 2010 meeting.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Looked at this and still intend to close as NAD in March
2010 unless there is proposed wording that we like.
</blockquote>

<p><i>[
2010-02-02 Nicolai M. Josuttis updates proposed wording and adds:
]</i></p>


<blockquote>
<p>
I just came across issue #1034 (response to UK 222),
which covers the role of container requirements.
The reason I found this issue was that I am wondering why
<tt>array&lt;&gt;</tt> is specified to be a sequence container.
For me, currently, this follows from
Sequence containers 23.2.3 [sequence.reqmts]
saying:
</p>
<blockquote>
The library provides five basic kinds of sequence containers: <tt>array</tt>,
<tt>vector</tt>, <tt>forward_list</tt>, <tt>list</tt>, and <tt>deque</tt>. while
later on in Table 94 "Sequence container requirements" are defined.
</blockquote>

<p>
IMO, you can hardly argue that this is NAD.
We MUST say somewhere that either array is not a sequence container
or does not provide all operations of a sequence container
(even not all requirements of a container in general).
</p>
<p>
Here is the number of requirements <tt>array&lt;&gt;</tt> does not meet
(AFAIK):
</p>
<p>
general container requirements:
</p>
<ul>
<li>
a default constructed <tt>array</tt> is not empty
</li>
<li>
<tt>swap</tt> has no constant complexity
</li>
</ul>

<p>
 Note also that <tt>swap</tt> not only has linear complexity
 it also invalidates iterators (or to be more precise,
 assigns other values to the elements), which
 is different from the effect swap has for other containers.
 For this reason, I must say that i tend to propose to
 remove <tt>swap()</tt> for <tt>arrays</tt>.
 </p>

<p>
sequence container requirements:
</p>

<ul>
<li>
There is no constructor and assignment for a range
</li>
<li>
There is no constructor and assignment for <tt>n</tt> copies of <tt>t</tt>
</li>
<li>
 There are no <tt>emplace</tt>, <tt>insert</tt>, <tt>erase</tt>, <tt>clear</tt>,
 <tt>assign</tt> operations
</li>
</ul>

<p>
In fact, out of all sequence container requirements <tt>array&lt;&gt;</tt> only
provides the following operations:
from sequence requirements (Table 94):
</p>
<blockquote><pre>X(il);
a = il;
</pre></blockquote>
<p>
and from optional requirements (Table 95):
</p>
<blockquote><pre>[], at(), front(), back()
</pre></blockquote>
<p>
This is almost nothing!
</p>

<p>
Note in addition, that due to the fact that
<tt>array</tt> is an aggregate and not a container with
<tt>initializer_lists</tt>
a construction or assignment with an initializer list is valid
for all sequence containers but not valid for array:
</p>

<blockquote><pre>vector&lt;int&gt;  v({1,2,3});   // OK
v = {4,5,6};               // OK

array&lt;int,3&gt; a({1,2,3});   // Error
array&lt;int,3&gt; a = {1,2,3};  // OK
a = {4,5,6};               // Error
</pre></blockquote>

<p>
BTW, for this reason, I am wondering, why <tt>&lt;array&gt;</tt> includes
<tt>&lt;initializer_list&gt;</tt>.
</p>

<p>
IMO, we can't really say that <tt>array</tt> is a sequence container.
<tt>array</tt> is special.
As the solution to this issue seemed to miss some proposed wording
where all could live with, let me try to suggest some.
</p>

</blockquote>

<p><i>[
2010-02-12 Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>


<p><i>[
2010 Pittsburgh:  Ok with move to Ready except for "OPEN:" part.
]</i></p>




<p><b>Proposed resolution:</b></p>

<p><i>In Sequence containers 23.2.3 [sequence.reqmts] modify paragraph 1 as 
indicated: </i> </p>
<blockquote>
  <p>1 A sequence container organizes a finite set of objects, all of the same 
  type, into a strictly linear arrangement. The library provides <del>five</del>
  <ins>four</ins> basic kinds of sequence containers: <del><tt>array</tt>,</del>
  <tt>vector</tt>, <tt>forward_list</tt>, <tt>list</tt>, and <tt>deque</tt>.
  <ins>In addition, <tt>array</tt> is provided as a sequence container that 
  only provides limited sequence operations because it has a fixed number of 
  elements.</ins> <del>It</del> <ins>The library</ins> also provides container adaptors that make it easy to 
  construct abstract data types, such as <tt>stack</tt>s or <tt>queue</tt>s, out 
  of the basic sequence container kinds (or out of other kinds of sequence 
  containers that the user might define). </p>
</blockquote>
<p><i>Modify paragraph 2 as follows (just editorial): </i> </p>
<blockquote>
  <p>2 The <del>five basic</del> sequence 
  containers offer the programmer different complexity trade-offs and should be 
  used accordingly. <tt>vector</tt> or <tt>array</tt> is the type of sequence 
  container that should be used by default. <tt>list</tt> or <tt>forward_list</tt> 
  should be used when there are frequent insertions and deletions from the 
  middle of the sequence. <tt>deque</tt> is the data structure of choice when 
  most insertions and deletions take place at the beginning or at the end of the 
  sequence. </p>
</blockquote>
<p><i>In Class template array 23.3.1 [array] modify paragraph 3 as indicated:
</i> </p>
<blockquote>
  <p>3 <del>Unless otherwise specified, all <tt>array</tt> operations are as 
  described in 23.2.</del> <ins>An array satisfies all of the requirements of a 
  container and of a reversible container (given in two tables in 23.2 [container.requirements]) 
  except that a default constructed <tt>array</tt> is not empty, <tt>swap</tt> 
  does not have constant complexity, and <tt>swap</tt> may throw exceptions. An <tt>array</tt> satisfies some of the requirements of a 
  sequence container (given in 23.2.3 [sequence.reqmts]).</ins> Descriptions are 
  provided here only for operations on <tt>array</tt> that are not described
  <del>in that Clause</del> <ins>in one of these tables</ins> or for operations 
  where there is additional semantic information. </p>
</blockquote>
<p><i>In array specialized algorithms 23.3.1.2 [array.special] add to the 
specification of <tt>swap()</tt>: </i> </p>
<blockquote>
  <pre>template &lt;class T, size_t N&gt; void swap(array&lt;T,N&gt;&amp; x, array&lt;T,N&gt;&amp; y);
</pre>
  <blockquote>
    <p>1 <i>Effects:</i> ... </p>
    <p><ins><i>Complexity:</i> Linear in <tt>N</tt>. </ins></p>
  </blockquote>
</blockquote>









<hr>
<h3><a name="1037"></a>1037. Response to UK 232</h3>
<p><b>Section:</b> 23.2.3 [sequence.reqmts] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-12 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#sequence.reqmts">issues</a> in [sequence.reqmts].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 232</b></p>

<p>
<tt>match_results</tt> may follow the requirements but is not listed a general
purpose library container.
</p>

<p>
Remove reference to <tt>match_results</tt> against <tt>a[n]</tt> operation.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Agree. <tt>operator[]</tt> is defined elsewhere.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution.
Move to Tentatively Ready.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
In 23.2.3 [sequence.reqmts] Table 84, remove reference to
<tt>match_results</tt> in the row describing the <tt>a[n]</tt> operation.
</p>





<hr>
<h3><a name="1038"></a>1038. Response to UK 233</h3>
<p><b>Section:</b> 23.2.3 [sequence.reqmts] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-12 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#sequence.reqmts">issues</a> in [sequence.reqmts].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 233</b></p>

<p>
Table 84 is missing references to several new container types.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Agree.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution.
Move to Tentatively Ready.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
In 23.2.3 [sequence.reqmts] Table 84, Add reference to listed
containers to the following rows:
</p>

<blockquote>
<table border="1">
<caption>Table 84 -- Optional sequence container operations</caption>
<tbody><tr>
<th>Expression</th>
<th>Return type</th>
<th>Operational semantics</th>
<th>Container</th>
</tr>
<tr>
<td><tt>a.front()</tt></td>
<td>...</td>
<td>...</td>
<td><tt>vector, list, deque, basic_string<ins>, array, forward_list</ins></tt></td>
</tr>
<tr>
<td><tt>a.back()</tt></td>
<td>...</td>
<td>...</td>
<td><tt>vector, list, deque, basic_string<ins>, array</ins></tt></td>
</tr>
<tr>
<td><tt>a.emplace_front(args)</tt></td>
<td>...</td>
<td>...</td>
<td><tt>list, deque<ins>, forward_list</ins></tt></td>
</tr>
<tr>
<td><tt>a.push_front(t)</tt></td>
<td>...</td>
<td>...</td>
<td><tt>list, deque<ins>, forward_list</ins></tt></td>
</tr>
<tr>
<td><tt>a.push_front(rv)</tt></td>
<td>...</td>
<td>...</td>
<td><tt>list, deque<ins>, forward_list</ins></tt></td>
</tr>
<tr>
<td><tt>a.pop_front()</tt></td>
<td>...</td>
<td>...</td>
<td><tt>list, deque<ins>, forward_list</ins></tt></td>
</tr>
<tr>
<td><tt>a[n]</tt></td>
<td>...</td>
<td>...</td>
<td><tt>vector, deque, basic_string<ins>, array</ins></tt></td>
</tr>
<tr>
<td><tt>a.at(n)</tt></td>
<td>...</td>
<td>...</td>
<td><tt>vector, deque<ins>, basic_string, array</ins></tt></td>
</tr>
</tbody></table>
</blockquote>





<hr>
<h3><a name="1039"></a>1039. Response to UK 234</h3>
<p><b>Section:</b> 23.2.3 [sequence.reqmts] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-12 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#sequence.reqmts">issues</a> in [sequence.reqmts].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 234</b></p>

<p>
The reference to <tt>iterator</tt> in semantics for <tt>back</tt> should
also allow for <tt>const_iterator</tt> when called on a const-qualified
container. This would be ugly to specify in the 03 standard, but is
quite easy with the addition of <tt>auto</tt> in this new standard.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Agree.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution.
Move to Tentatively Ready.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
In 23.2.3 [sequence.reqmts] Table 84, replace iterator with auto in semantics for back:
</p>

<blockquote>
<table border="1">
<caption>Table 84 -- Optional sequence container operations</caption>
<tbody><tr>
<th>Expression</th>
<th>Return type</th>
<th>Operational semantics</th>
<th>Container</th>
</tr>
<tr>
<td><tt>a.back()</tt></td>
<td><tt>reference; const_reference</tt> for constant <tt>a</tt></td>
<td><tt>{ <del>iterator</del> <ins>auto</ins> tmp = a.end();<br>--tmp;<br>return *tmp; }</tt></td>
<td><tt>vector, list, deque, basic_string</tt></td>
</tr>
</tbody></table>
</blockquote>





<hr>
<h3><a name="1040"></a>1040. Response to UK 238</h3>
<p><b>Section:</b> 23.2.4 [associative.reqmts] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-12 <b>Last modified:</b> 2010-10-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#associative.reqmts">active issues</a> in [associative.reqmts].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#associative.reqmts">issues</a> in [associative.reqmts].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 238</b></p>

<p>
Leaving it unspecified whether or not <tt>iterator</tt> and <tt>const_iterator</tt> are the
same type is dangerous, as user code may or may not violate the One
Definition Rule by providing overloads for 
both types. It is probably too late to specify a single behaviour, but
implementors should document what to expect. Observing that problems can be
avoided by users restricting themselves to using <tt>const_iterator</tt>, add a note to that effect. 
</p>
<p>
Suggest Change 'unspecified' to 'implementation defined'.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Agree with issue. Agree with adding the note but not with changing the
normative text. We believe the note provides sufficient guidance.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution.
Move to Tentatively Ready.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
In 23.2.4 [associative.reqmts] p6, add:
</p>

<blockquote>
-6- <tt>iterator</tt> of an associative container meets the requirements
of the <tt>BidirectionalIterator</tt> concept. For associative
containers where the value type is the same as the key type, both
<tt>iterator</tt> and <tt>const_iterator</tt> are constant iterators. It
is unspecified whether or not <tt>iterator</tt> and
<tt>const_iterator</tt> are the same type.
<ins>[<i>Note:</i> <tt>iterator</tt> and <tt>const_iterator</tt> have identical semantics in
this case, and <tt>iterator</tt> is convertible to <tt>const_iterator</tt>. Users can avoid
violating the One Definition Rule by always using <tt>const_iterator</tt>
in their function parameter lists <i>-- end note</i>]</ins>
</blockquote>





<hr>
<h3><a name="1044"></a>1044. Response to UK 325</h3>
<p><b>Section:</b> 30.4 [thread.mutex] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-12 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.mutex">issues</a> in [thread.mutex].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 325</b></p>

<p>
We believe constexpr literal values should be a more natural expression
of empty tag types than extern objects as it should improve the
compiler's ability to optimize the empty object away completely.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Move to review. The current specification is a "hack", and the proposed
specification is a better "hack".
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution.
Move to Tentatively Ready.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change the synopsis in 30.4 [thread.mutex]:
</p>

<blockquote><pre>struct defer_lock_t <ins>{}</ins>;
struct try_to_lock_t <ins>{}</ins>;
struct adopt_lock_t <ins>{}</ins>;

<del>extern</del> const<ins>expr</ins> defer_lock_t defer_lock <ins>{}</ins>;
<del>extern</del> const<ins>expr</ins> try_to_lock_t try_to_lock <ins>{}</ins>;
<del>extern</del> const<ins>expr</ins> adopt_lock_t adopt_lock <ins>{}</ins>;
</pre></blockquote>






<hr>
<h3><a name="1045"></a>1045. Response to UK 326</h3>
<p><b>Section:</b> 30.4.2.2.1 [thread.lock.unique.cons] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-12 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 326</b></p>

<p>
The precondition that the mutex is not owned by this thread offers
introduces the risk of un-necessary undefined behaviour into the
program. The only time it matters whether the current thread owns the
mutex is in the lock operation, and that will happen subsequent to
construction in this case. The lock operation has the identical
pre-condition, so there is nothing gained by asserting that precondition
earlier and denying the program the right to get into a valid state
before calling lock.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Agree, move to review.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution.
Move to Tentatively Ready.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Strike 30.4.2.2.1 [thread.lock.unique.cons] p7:
</p>

<blockquote><pre>unique_lock(mutex_type&amp; m, defer_lock_t);
</pre>
<blockquote>
<del>-7- <i>Precondition:</i> If <tt>mutex_type</tt> is not a recursive mutex
the calling thread does not own the mutex.</del>
</blockquote>
</blockquote>






<hr>
<h3><a name="1054"></a>1054. <tt>forward</tt> broken</h3>
<p><b>Section:</b> 20.3.3 [forward] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-03-13 <b>Last modified:</b> 2010-11-20</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#forward">issues</a> in [forward].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>

<p>
This is a placeholder issue to track the fact that we (well I) put the standard
into an inconsistent state by requesting that we accept
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2844.html">N2844</a>
except for the proposed changes to [forward].
</p>

<p>
There will exist in the post meeting mailing
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2835.html">N2835</a>
which in its current state reflects the state of affairs prior to the Summit
meeting.  I hope to update it in time for the post Summit mailing, but as I write
this issue I have not done so yet.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Move to Open, awaiting the promised paper.
</blockquote>

<p><i>[
2009-08-02 Howard adds:
]</i></p>


<blockquote>
<p>
My current preferred solution is:
</p>

<blockquote><pre>template &lt;class T&gt;
struct __base_type
{
   typedef typename remove_cv&lt;typename remove_reference&lt;T&gt;::type&gt;::type type;
};

template &lt;class T, class U,
   class = typename enable_if&lt;
       !is_lvalue_reference&lt;T&gt;::value ||
        is_lvalue_reference&lt;T&gt;::value &amp;&amp;
        is_lvalue_reference&lt;U&gt;::value&gt;::type,
   class = typename enable_if&lt;
        is_same&lt;typename __base_type&lt;T&gt;::type,
                typename __base_type&lt;U&gt;::type&gt;::value&gt;::type&gt;
inline
T&amp;&amp;
forward(U&amp;&amp; t)
{
   return static_cast&lt;T&amp;&amp;&gt;(t);
}
</pre></blockquote>

<p>
This has been tested by Bill, Jason and myself.
</p>

<p>
It allows the following lvalue/rvalue casts:
</p>

<ol>
<li>
Cast an lvalue <tt>t</tt> to an lvalue <tt>T</tt> (identity).
</li>
<li>
Cast an lvalue <tt>t</tt> to an rvalue <tt>T</tt>.
</li>
<li>
Cast an rvalue <tt>t</tt> to an rvalue <tt>T</tt> (identity).
</li>
</ol>

<p>
It disallows:
</p>

<ol type="a">
<li>
Cast an rvalue <tt>t</tt> to an lvalue <tt>T</tt>.
</li>
<li>
Cast one type <tt>t</tt> to another type <tt>T</tt> (such as <tt>int</tt> to <tt>double</tt>).
</li>
</ol>

<p>
"a." is disallowed as it can easily lead to dangling references.
"b." is disallowed as this function is meant to only change the lvalue/rvalue
characteristic of an expression.
</p>

<p>
Jason has expressed concern that "b." is not dangerous and is useful in contexts
where you want to "forward" a derived type as a base type.  I find this use case
neither dangerous, nor compelling.  I.e. I could live with or without the "b."
constraint.  Without it, forward would look like:
</p>

<blockquote><pre>template &lt;class T, class U,
   class = typename enable_if&lt;
       !is_lvalue_reference&lt;T&gt;::value ||
        is_lvalue_reference&lt;T&gt;::value &amp;&amp;
        is_lvalue_reference&lt;U&gt;::value&gt;::type&gt;
inline
T&amp;&amp;
forward(U&amp;&amp; t)
{
   return static_cast&lt;T&amp;&amp;&gt;(t);
}
</pre></blockquote>

<p>
Or possibly:
</p>

<blockquote><pre>template &lt;class T, class U,
   class = typename enable_if&lt;
       !is_lvalue_reference&lt;T&gt;::value ||
        is_lvalue_reference&lt;T&gt;::value &amp;&amp;
        is_lvalue_reference&lt;U&gt;::value&gt;::type,
   class = typename enable_if&lt;
        is_base_of&lt;typename __base_type&lt;U&gt;::type,
                   typename __base_type&lt;T&gt;::type&gt;::value&gt;::type&gt;
inline
T&amp;&amp;
forward(U&amp;&amp; t)
{
   return static_cast&lt;T&amp;&amp;&gt;(t);
}
</pre></blockquote>


<p>
The "promised paper" is not in the post-Frankfurt mailing only because I'm waiting
for the non-concepts draft.  But I'm hoping that by adding this information here
I can keep people up to date.
</p>
</blockquote>

<p><i>[
2009-08-02 David adds:
]</i></p>


<blockquote>
<p>
<tt>forward</tt> was originally designed to do one thing: perfect forwarding.
That is, inside a function template whose actual argument can be a const
or non-const lvalue or rvalue, restore the original "rvalue-ness" of the
actual argument:
</p>

<blockquote><pre>template &lt;class T&gt;
void f(T&amp;&amp; x)
{
    // x is an lvalue here.  If the actual argument to f was an
    // rvalue, pass static_cast&lt;T&amp;&amp;&gt;(x) to g; otherwise, pass x.
    g( forward&lt;T&gt;(x) );
}
</pre></blockquote>

<p>
Attempting to engineer <tt>forward</tt> to accomodate uses other than perfect
forwarding dilutes its idiomatic meaning.  The solution proposed here
declares that <tt>forward&lt;T&gt;(x)</tt> means nothing more than <tt>static_cast&lt;T&amp;&amp;&gt;(x)</tt>,
with a patchwork of restrictions on what <tt>T</tt> and <tt>x</tt> can be that can't be
expressed in simple English.
</p>

<p>
I would be happy with either of two approaches, whose code I hope (but
can't guarantee) I got right.
</p>

<ol>
<li>
<p>
Use a simple definition of <tt>forward</tt> that accomplishes its original
purpose without complications to accomodate other uses:
</p>

<blockquote><pre>template &lt;class T, class U&gt;
T&amp;&amp; forward(U&amp; x)
{
    return static_cast&lt;T&amp;&amp;&gt;(x);
}
</pre></blockquote>
</li>

<li>
<p>
Use a definition of <tt>forward</tt> that protects the user from as many
potential mistakes as possible, by actively preventing <em>all</em> other
uses:
</p>

<blockquote><pre>template &lt;class T, class U&gt;
boost::enable_if_c&lt;
    // in forward&lt;T&gt;(x), x is a parameter of the caller, thus an lvalue
    is_lvalue_reference&lt;U&gt;::value
    // in caller's deduced T&amp;&amp; argument, T can only be non-ref or lvalue ref
    &amp;&amp; !is_rvalue_reference&lt;T&gt;::value
    // Must not cast cv-qualifications or do any type conversions
    &amp;&amp; is_same&lt;T&amp;,U&amp;&gt;::value
    , T&amp;&amp;&gt;::type forward(U&amp;&amp; a)
{
    return static_cast&lt;T&amp;&amp;&gt;(a);
}
</pre></blockquote>
</li>
</ol>

</blockquote>

<p><i>[
2009-09-27 Howard adds:
]</i></p>


<blockquote>
A paper,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2951.html">N2951</a>,
is available which compares several implementations (including David's) with respect to several
use cases (including Jason's) and provides wording for one implementation.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
<del>NAD Editorial</del><ins>Resolved</ins>.  Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2951.html">N2951</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1055"></a>1055. Response to UK 98</h3>
<p><b>Section:</b> 20.7.7.6 [meta.trans.other] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-12 <b>Last modified:</b> 2010-11-20</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#meta.trans.other">issues</a> in [meta.trans.other].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 98</b></p>

<p>
It would be useful to be able to determine the underlying
type of an arbitrary enumeration type. This would allow
safe casting to an integral type (especially needed for
scoped enums, which do not promote), and would allow
use of <tt>numeric_limits</tt>. In general it makes generic
programming with enumerations easier.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Pete observes (and Tom concurs)
that the proposed resolution seems to require compiler support
for its implementation,
as it seems necessary to look at the range of values
of the enumerated type.
To a first approximation,
a library solution could give an answer based on the size of the type.
If the user has specialized <tt>numeric_limits</tt> for the enumerated type,
then the library might be able to do better,
but there is no such requirement.
Keep status as Open
and solicit input from CWG.
</blockquote>

<p><i>[
2009-05-23 Alisdair adds:
]</i></p>


<blockquote>
Just to confirm that the BSI originator of this comment assumed it did
indeed imply a compiler intrinsic.  Rather than request a Core extension, it
seemed in keeping with that the type traits interface provides a library API
to unspecified compiler features - where we require several other traits
(e.g. <tt>has_trivial_*</tt>) to get the 'right' answer now, unlike in TR1.
</blockquote>

<p><i>[
Addressed in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2947.html">N2947</a>.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
<del>NAD Editorial</del><ins>Resolved</ins>.  Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2984.html">N2984</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add a new row to the table in 20.7.7.6 [meta.trans.other]:
</p>

<blockquote>
<table border="1">
<caption>Table 41 -- Other transformations</caption>
<tbody><tr>
<th>Template</th>
<th>Condition</th>
<th>Comments</th>
</tr>
<tr>
<td>
<tt>template&lt;&nbsp;class&nbsp;T&nbsp;&gt; struct enum_base;</tt>
</td>
<td>
<tt>T</tt> shall be an enumeration type (7.2 [dcl.enum])
</td>
<td>
The member typedef <tt>type</tt> shall name the underlying type
of the enum <tt>T</tt>.
</td>
</tr>
</tbody></table>
</blockquote>





<hr>
<h3><a name="1065"></a>1065. Response to UK 168</h3>
<p><b>Section:</b> 17.6.1.1 [contents] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-03-15 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#contents">issues</a> in [contents].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses UK 168</b></p>
<p>
We should make it clear (either by note or normatively) that namespace
<tt>std</tt> may contain inline namespaces, and that entities specified to be
defined in std may in fact be defined in one of these inline namespaces.
(If we're going to use them for versioning, eg when TR2 comes along,
we're going to need that.)
</p>

<p>
Replace "namespace std or namespaces nested within namespace std" with
"namespace std or namespaces nested within namespace std or inline
namespaces nested directly or indirectly within namespace std"
</p>

<p><i>[
Summit:
]</i></p>

<blockquote>
adopt UK words (some have reservations whether it is correct)
</blockquote>

<p><i>[
2009-05-09 Alisdair improves the wording.
]</i></p>


<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Bill believes there is strictly speaking no need to say that
because no portable test can detect the difference.
However he agrees that it doesn't hurt to say this.
</p>
<p>
Move to Tentatively Ready.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 17.6.1.1 [contents] p2:
</p>

<blockquote>
All library entities except macros, <tt>operator new</tt> and
<tt>operator delete</tt> are defined within the namespace <tt>std</tt> or
namespaces nested within namespace <tt>std</tt>.
<ins>It is unspecified whether names declared in a specific namespace
are declared directly in that namespace, or in an inline namespace inside
that namespace. [<i>Footnote:</i> This gives implementers freedom to support
multiple configurations of the library.]</ins>
</blockquote>





<hr>
<h3><a name="1066"></a>1066. Response to UK 189 and JP 27</h3>
<p><b>Section:</b> 18 [language.support] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-03-15 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses UK 189 and JP 27</b></p>
<p>
The addition of the <tt>[[noreturn]]</tt> attribute to the language will be an
important aid for static analysis tools.
</p>

<p>
The following functions should be declared in C++ with the
<tt>[[noreturn]]</tt> attribute: <tt>abort</tt> <tt>exit</tt>
<tt>quick_exit</tt> <tt>terminate</tt> <tt>unexpected</tt>
<tt>rethrow_exception</tt> <tt>throw_with_nested</tt>.
</p>

<p><i>[
Summit:
]</i></p>

<blockquote>
Agreed.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution.
Move to Tentatively Ready.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 18.5 [support.start.term] p3:
</p>

<blockquote>
<p>-2- ...</p>
<pre><ins>void</ins> abort <ins>[[noreturn]]</ins> (void)
</pre>
<p>-3- ...</p>
<p>-6- ...</p>
<pre><ins>void</ins> exit<ins> [[noreturn]] </ins>(int status)
</pre>
<p>-7- ...</p>
<p>-11- ...</p>
<pre>void quick_exit<ins> [[noreturn]] </ins>(int status)
</pre>
<p>-12- ...</p>
</blockquote>

<p>
Change the <tt>&lt;exception&gt;</tt> synopsis in 18.8 [support.exception]:
</p>

<blockquote><pre>void unexpected<ins> [[noreturn]] </ins>();
...
void terminate<ins> [[noreturn]] </ins>();
...
void rethrow_exception<ins> [[noreturn]] </ins>(exception_ptr p);
...
template &lt;class T&gt; void throw_with_nested<ins> [[noreturn]] </ins>(T&amp;&amp; t); <del>// [[noreturn]]</del>
</pre></blockquote>

<p>
Change D.13.3 [unexpected]:
</p>

<blockquote><pre>void unexpected<ins> [[noreturn]] </ins>();
</pre></blockquote>

<p>
Change 18.8.3.3 [terminate]:
</p>

<blockquote><pre>void terminate<ins> [[noreturn]] </ins>();
</pre></blockquote>

<p>
Change 18.8.5 [propagation]:
</p>

<blockquote><pre>void rethrow_exception<ins> [[noreturn]] </ins>(exception_ptr p);
</pre></blockquote>

<p>
In the synopsis of 18.8.6 [except.nested] and the definition area change:
</p>

<blockquote><pre>template &lt;class T&gt; void throw_with_nested<ins> [[noreturn]] </ins>(T&amp;&amp; t); <del>// [[noreturn]]</del>
</pre></blockquote>





<hr>
<h3><a name="1070"></a>1070. Ambiguous move overloads in function</h3>
<p><b>Section:</b> 20.8.14.2 [func.wrap.func] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-03-19 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#func.wrap.func">issues</a> in [func.wrap.func].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The synopsis in 20.8.14.2 [func.wrap.func] says:
</p>

<blockquote><pre>template&lt;Returnable R, CopyConstructible... ArgTypes&gt; 
class function&lt;R(ArgTypes...)&gt;
{
    ...
    template&lt;class F&gt; 
      requires CopyConstructible&lt;F&gt; &amp;&amp; Callable&lt;F, ArgTypes...&gt; 
            &amp;&amp; Convertible&lt;Callable&lt;F, ArgTypes...&gt;::result_type, R&gt; 
      function(F); 
    template&lt;class F&gt; 
      requires CopyConstructible&lt;F&gt; &amp;&amp; Callable&lt;F, ArgTypes...&gt; 
            &amp;&amp; Convertible&lt;Callable&lt;F, ArgTypes...&gt;::result_type, R&gt; 
      function(F&amp;&amp;);
    ...
    template&lt;class F, Allocator Alloc&gt; function(allocator_arg_t, const Alloc&amp;, F); 
    template&lt;class F, Allocator Alloc&gt; function(allocator_arg_t, const Alloc&amp;, F&amp;&amp;);
    ...
    template&lt;class F&gt; 
      requires CopyConstructible&lt;F&gt; &amp;&amp; Callable&lt;F, ArgTypes..&gt; 
            &amp;&amp; Convertible&lt;Callable&lt;F, ArgTypes...&gt;::result_type 
      function&amp; operator=(F); 
    template&lt;class F&gt; 
      requires CopyConstructible&lt;F&gt; &amp;&amp; Callable&lt;F, ArgTypes...&gt; 
            &amp;&amp; Convertible&lt;Callable&lt;F, ArgTypes...&gt;::result_type, R&gt; 
      function&amp; operator=(F&amp;&amp;);
    ...
};
</pre></blockquote>

<p>
Each of the 3 pairs above are ambiguous.  We need only one of each pair, and we
could do it with either one.  If we choose the <tt>F&amp;&amp;</tt> version we
need to bring <tt>decay</tt> into the definition to get the pass-by-value behavior.
In the proposed wording I've gotten lazy and just used the pass-by-value signature.
</p>

<p><i>[
2009-05-01 Daniel adds:
]</i></p>


<blockquote>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1024">1024</a> modifies the second removed constructor.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We briefly discussed whether we ought support moveable function objects,
but decided that should be a separate issue if someone cares to propose it.
</p>
<p>
Move to Tentatively Ready.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change the synopsis of 20.8.14.2 [func.wrap.func], and remove the associated definitions in
20.8.14.2.1 [func.wrap.func.con]:
</p>

<blockquote><pre>template&lt;Returnable R, CopyConstructible... ArgTypes&gt; 
class function&lt;R(ArgTypes...)&gt;
{
    ...
    template&lt;class F&gt; 
      requires CopyConstructible&lt;F&gt; &amp;&amp; Callable&lt;F, ArgTypes...&gt; 
            &amp;&amp; Convertible&lt;Callable&lt;F, ArgTypes...&gt;::result_type, R&gt; 
      function(F); 
    <del>template&lt;class F&gt; 
      requires CopyConstructible&lt;F&gt; &amp;&amp; Callable&lt;F, ArgTypes...&gt; 
            &amp;&amp; Convertible&lt;Callable&lt;F, ArgTypes...&gt;::result_type, R&gt; 
      function(F&amp;&amp;);</del>
    ...
    template&lt;class F, Allocator Alloc&gt; function(allocator_arg_t, const Alloc&amp;, F); 
    <del>template&lt;class F, Allocator Alloc&gt; function(allocator_arg_t, const Alloc&amp;, F&amp;&amp;);</del>
    ...
    template&lt;class F&gt; 
      requires CopyConstructible&lt;F&gt; &amp;&amp; Callable&lt;F, ArgTypes..&gt; 
            &amp;&amp; Convertible&lt;Callable&lt;F, ArgTypes...&gt;::result_type 
      function&amp; operator=(F); 
    <del>template&lt;class F&gt; 
      requires CopyConstructible&lt;F&gt; &amp;&amp; Callable&lt;F, ArgTypes...&gt; 
            &amp;&amp; Convertible&lt;Callable&lt;F, ArgTypes...&gt;::result_type, R&gt; 
      function&amp; operator=(F&amp;&amp;);</del>
    ...
};
</pre></blockquote>






<hr>
<h3><a name="1071"></a>1071. is_bind_expression should derive from integral_constant&lt;bool&gt;</h3>
<p><b>Section:</b> 20.8.10.1.1 [func.bind.isbind] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-19 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#func.bind.isbind">issues</a> in [func.bind.isbind].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Class template is_bind_expression 20.8.10.1.1 [func.bind.isbind]:
</p>

<blockquote><pre>namespace std {
  template&lt;class T&gt; struct is_bind_expression {
    static const bool value = see below;
  };
}
</pre></blockquote>
<p>
<tt>is_bind_expression</tt> should derive from <tt>std::integral_constant&lt;bool&gt;</tt> like
other similar trait types.
</p>

<p><i>[
Daniel adds:
]</i></p>

<blockquote>
We need the same thing for the trait <tt>is_placeholder</tt> as well.
</blockquote>
<p><i>[
2009-03-22 Daniel provided wording.
]</i></p>


<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We recommend this be deferred until after the next Committee Draft is issued.
</p>
<p>
Move to Open.
</p>
</blockquote>

<p><i>[
2009-05-31 Peter adds:
]</i></p>


<blockquote>
<p>
I am opposed to the proposed resolution and to the premise of the issue
in general. The traits's default definitions should NOT derive from
<tt>integral_constant</tt>, because this is harmful, as it misleads people into
thinking that <tt>is_bind_expression&lt;E&gt;</tt> always derives from
<tt>integral_constant</tt>, whereas it may not.
</p>
<p>
<tt>is_bind_expression</tt> and <tt>is_placeholder</tt> allow user
specializations, and in fact, this is their primary purpose. Such user
specializations may not derive from <tt>integral_constant</tt>, and the
places where <tt>is_bind_expression</tt> and <tt>is_placeholder</tt> are
used intentionally do not require such derivation.
</p>
<p>
The long-term approach here is to switch to
<tt>BindExpression&lt;E&gt;</tt> and <tt>Placeholder&lt;P&gt;</tt>
explicit concepts, of course, but until that happens, I say leave them
alone.
</p>
</blockquote>

<p><i>[
2009-10 post-Santa Cruz:
]</i></p>


<blockquote>
Move to Tentatively Ready.  We are comfortable with requiring user specializations
to derive from <tt>integral_constant</tt>.
</blockquote>



<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>
In 20.8.10.1.1 [func.bind.isbind] change as indicated:
</p>
<blockquote><pre>namespace std {
 template&lt;class T&gt; struct is_bind_expression <ins>: integral_constant&lt;bool, <i>see below</i>&gt; { };</ins><del>{
   static const bool value = <i>see below</i>;
 };</del>
}
</pre></blockquote>
</li>
<li>
<p>
In 20.8.10.1.1 [func.bind.isbind]/2 change as indicated:
</p>
<blockquote><pre><del>static const bool value;</del>
</pre>
<blockquote>
-2- <del><tt>true</tt> if <tt>T</tt> is a type returned from <tt>bind</tt>, <tt>false</tt> otherwise.</del>
  <ins>If <tt>T</tt> is a type returned from <tt>bind</tt>, <tt>is_bind_expression&lt;T&gt;</tt> shall
be publicly derived from
        <tt>integral_constant&lt;bool, true&gt;</tt>, otherwise it shall be
publicly derived from
          <tt>integral_constant&lt;bool, false&gt;</tt>.</ins>
</blockquote>
</blockquote>
</li>
<li>
<p>
In  [func.bind.isplace] change as indicated:
</p>
<blockquote><pre>namespace std {
 template&lt;class T&gt; struct is_placeholder <ins>: integral_constant&lt;int, <i>see below</i>&gt; { };</ins><del>{
   static const int value = <i>see below</i>;
 };</del>
}
</pre></blockquote>
</li>
<li>
<p>
In  [func.bind.isplace]/2 change as indicated:
</p>
<blockquote><pre><del>static const int value;</del>
</pre>
<blockquote>
-2- <del>value is <tt>J</tt> if <tt>T</tt> is the type of <tt>std::placeholders::_J</tt>, 0 otherwise.</del>
  <ins>If <tt>T</tt> is the type of <tt>std::placeholders::_J</tt>, <tt>is_placeholder&lt;T&gt;</tt>
shall be publicly
          derived from <tt>integral_constant&lt;int, J&gt;</tt> otherwise it shall
be publicly derived
          from <tt>integral_constant&lt;int, 0&gt;</tt>.</ins>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="1073"></a>1073. Declaration of <tt>allocator_arg</tt> should be <tt>constexpr</tt></h3>
<p><b>Section:</b> 20.9 [memory] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-19 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#memory">issues</a> in [memory].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Declaration of <tt>allocator_arg</tt> should be <tt>constexpr</tt> to ensure constant
initialization.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution.  Move to Tentatively Ready.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 20.9 [memory] p2:
</p>

<blockquote><pre>// 20.8.1, allocator argument tag
struct allocator_arg_t { };
const<ins>expr</ins> allocator_arg_t allocator_arg = allocator_arg_t();
</pre></blockquote>






<hr>
<h3><a name="1075"></a>1075. Response to US 65, US 74.1</h3>
<p><b>Section:</b> 20 [utilities], 23 [containers] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> Alan Talbot <b>Opened:</b> 2009-03-20 <b>Last modified:</b> 2010-11-20</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#utilities">issues</a> in [utilities].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US 65 and US 74.1</b></p>

<p>US 65:</p>

<blockquote>
Scoped allocators and allocator propagation traits add a small amount of
utility at the cost of a great deal of machinery. The machinery is user
visible, and it extends to library components that don't have any
obvious connection to allocators, including basic concepts and simple
components like <tt>pair</tt> and <tt>tuple</tt>.

<p>Suggested resolution:</p>

<p>
Sketch of proposed resolution: Eliminate scoped allocators, replace
allocator propagation traits with a simple uniform rule (e.g. always
propagate on copy and move), remove all mention of allocators from
components that don't explicitly allocate memory (e.g. pair), and adjust
container interfaces to reflect this simplification.
</p>
<p>
Components that I propose eliminating include HasAllocatorType,
is_scoped_allocator, allocator_propagation_map, scoped_allocator_adaptor,
and ConstructibleAsElement.
</p>
</blockquote>

<p>US 74.1:</p>

<blockquote>
<p>
Scoped allocators represent a poor trade-off for standardization, since
(1) scoped-allocator--aware containers can be implemented outside the
C++ standard library but used with its algorithms, (2) scoped
allocators only benefit a tiny proportion of the C++ community
(since few C++ programmers even use today's allocators), and (3) all C++
users, especially the vast majority of the C++ community that won't ever
use scoped allocators are forced to cope with the interface complexity
introduced by scoped allocators.
</p>
<p>
In essence, the larger community will suffer to support a very small
subset of the community who can already implement their own
data structures outside of the standard library. Therefore, scoped
allocators should be removed from the working paper.
</p>
<p>
Some evidence of the complexity introduced by scoped allocators:
</p>
<blockquote>
<p>
20.3.5 [pairs], 20.4 [tuple]: Large increase in the
number of pair and tuple constructors.
</p>
<p>
23 [containers]: Confusing "AllocatableElement" requirements throughout.
</p>
</blockquote>
<p>Suggested resolution:</p>

<p>
Remove support for scoped allocators from the working paper. This
includes at least the following changes:
</p>

<blockquote>
<p>
Remove X [allocator.element.concepts]
</p>
<p>
Remove 20.10 [allocator.adaptor]
</p>
<p>
Remove  [construct.element]
</p>
<p>
In Clause 23 [containers]: replace requirements naming the
<tt>AllocatableElement</tt> concept with requirements naming <tt>CopyConstructible</tt>,
<tt>MoveConstructible</tt>, <tt>DefaultConstructible</tt>, or <tt>Constructible</tt>, as
appropriate.
</p>
</blockquote>

</blockquote>

<p><i>[
Post Summit Alan moved from NAD to Open.
]</i></p>


<p><i>[
2009-05-15 Ganesh adds:
]</i></p>


<blockquote>
<p>
The requirement <tt>AllocatableElement</tt> should not be replaced with
<tt>Constructible</tt> on the <tt>emplace_xxx()</tt> functions as suggested. In the
one-parameter case the <tt>Constructible</tt> requirement is not satisfied when
the constructor is explicit (as per  [concept.map.fct], twelfth
bullet) but we do want to allow explicit constructors in emplace, as the
following example shows:
</p>

<blockquote><pre>vector&lt;shared_ptr&lt;int&gt;&gt; v;
v.emplace_back(new int); <font color="#C80000">// should be allowed</font>
</pre></blockquote>

<p>
If the issue is accepted and scoped allocators are removed, I suggest to
add a new pair of concepts to  [concept.construct], namely:
</p>

<blockquote><pre>auto concept HasExplicitConstructor&lt;typename T, typename... Args&gt; {
 explicit T::T(Args...);
}

auto concept ExplicitConstructible&lt;typename T, typename... Args&gt;
 : HasExplicitConstructor&lt;T, Args...&gt;, NothrowDestructible&lt;T&gt;
{ }
</pre></blockquote>

<p>
We should then use <tt>ExplicitConstructible</tt> as the requirement for all
<tt>emplace_xxx()</tt> member functions.
</p>
<p>
For coherence and consistency with the similar concepts
<tt>Convertible/ExplicitlyConvertible</tt>, we might also consider changing
<tt>Constructible</tt> to:
</p>

<blockquote><pre>auto concept Constructible&lt;typename T, typename... Args&gt;
 : HasConstructor&lt;T, Args...&gt;, ExplicitConstructible&lt;T, Args...&gt;
{ }
</pre></blockquote>

<p>
Moreover, all emplace-related concepts in  [container.concepts]
should also use <tt>ExplicitConstructible</tt> instead of <tt>Constructible</tt> in the
definitions of their axioms. In fact the concepts in  [container.concepts] should be
corrected even if the issue is not accepted.
</p>
<p>
On the other hand, if the issue is not accepted, the scoped allocator
adaptors should be fixed because the following code:
</p>

<blockquote><pre>template &lt;typename T&gt; using scoped_allocator = scoped_allocator_adaptor&lt;allocator&lt;T&gt;&gt;;

vector&lt;shared_ptr&lt;int&gt;, scoped_allocator&lt;shared_ptr&lt;int&gt;&gt;&gt; v;
v.emplace_back(new int); <font color="#C80000">// ops! doesn't compile</font>
</pre></blockquote>

<p>
doesn't compile, as the member function <tt>construct()</tt> of the scoped
allocator requires non-explicit constructors through concept
<tt>ConstructibleWithAllocator</tt>. Fixing that is not difficult but probably
more work than it's worth and is therefore, IMHO, one more reason in
support of the complete removal of scoped allocators.
</p>
</blockquote>

<p><i>[
2009-06-09 Alan adds:
]</i></p>


<blockquote>
<p>
I reopened this issue because I did not think that these National Body
comments were adequately addressed by marking them NAD. My understanding
is that something can be marked NAD if it is clearly a misunderstanding
or trivial, but a substantive issue that has any technical merit
requires a disposition that addresses the concerns.
</p>
<p>
The notes in the NB comment list (US 65 &amp; US 74.1) say that:
</p>
<ol type="a">
<li>
this issue has not introduced any new arguments not previously discussed,
</li>
<li>
the vote (4-9-3) was not a consensus for removing scoped allocators,
</li>
<li>
the issue is resolved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2840.pdf">N2840</a>.
</li>
</ol>
<p>
My opinion is:
</p>
<ol type="a">
<li>
there are new arguments in both comments regarding concepts (which were
not present in the library when the scoped allocator proposal was voted
in),
</li>
<li>
the vote was clearly not a consensus for removal, but just saying there
was a vote does not provide a rationale,
</li>
<li>
I do not believe that N2840 addresses these comments (although it does
many other things and was voted in with strong approval).
</li>
</ol>

<p>
My motivation to open the issue was to ensure that the NB comments were
adequately addressed in a way that would not risk a "no" vote on our
FCD. If there are responses to the technical concerns raised, then
perhaps they should be recorded. If the members of the NB who authored
the comments are satisfied with N2840 and the other disposition remarks
in the comment list, then I am sure they will say so. In either case,
this issue can be closed very quickly in Frankfurt, and hopefully will
have helped make us more confident of approval with little effort. If in
fact there is controversy, my thought is that it is better to know now
rather than later so there is more time to deal with it.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
<del>NAD Editorial</del><ins>Resolved</ins>.  Addressed by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2982.pdf">N2982</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
Scoped allocators have been revised significantly.





<hr>
<h3><a name="1079"></a>1079. UK-265: <code>RandomAccessIterator</code>'s <code>operator-</code> has nonsensical effects clause</h3>
<p><b>Section:</b> 24.2.7 [random.access.iterators] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Doug Gregor <b>Opened:</b> 2009-03-20 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#random.access.iterators">issues</a> in [random.access.iterators].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses UK 265</b></p>

<p>UK-265:</p>
<p>
This effects clause is nonesense. It looks more like an axiom stating
equivalence, and certainly an effects clause cannot change the state of
two arguments passed by const reference
</p>

<p><i>[
2009-09-18 Alisdair adds:
]</i></p>


<blockquote>
<p>
For random access iterators, the definitions of <tt>(b-a)</tt> and
<tt>(a&lt;b)</tt> are circular:
</p>

<p>
From table Table 104 -- Random access iterator requirements:
</p>

<blockquote><pre>b - a :==&gt;  (a &lt; b) ? distance(a,b) : -distance(b,a)

a &lt; b :==&gt;  b - a &gt; 0
</pre></blockquote>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Moved to Ready.
</blockquote>

<p><i>[
2010-02-13 Alisdair opens.
]</i></p>


<blockquote>
<p>
Looking again at LWG #1079, the wording in the issue no longer exists, and
appears to be entirely an artefact of the concepts wording.
</p>

<p>
This issue is currently on our Ready list (not even Tentative!) but I think it
has to be pulled as there is no way to apply the resolution.
</p>

<p>
Looking at the current paper, I think this issue is now "NAD, solved by the
removal of concepts".  Unfortunately it is too late to poll again, so we will
have to perform that review in Pittsburgh.
</p>
</blockquote>

<p><i>[
2010-02-13 Daniel updates the wording to address the circularity problem.
]</i></p>


<blockquote>
<p><i>[
The previous wording is preserved here:
]</i></p>

<blockquote>

<p>Modify 24.2.7 [random.access.iterators]p7-9 as follows:</p>

<blockquote><pre>difference_type operator-(const X&amp; a, const X&amp; b);
</pre>
<ol start="7">
  <li><i>Precondition</i>: there exists a value <code>n</code> of
  <code>difference_type</code> such that <code>a == b + n</code>.</li>
  <li><del><i>Effects</i>: <code>b == a + (b - a)</code></del></li>
  <li><i>Returns</i>: <del><code>(a &lt; b) ? distance(a,b) :
  -distance(b,a)</code></del><ins><code>n</code></ins></li>
</ol>
</blockquote>

</blockquote>
</blockquote>

<p><i>[
2010 Pittsburgh:
]</i></p>


<blockquote>
Moved to Ready for Pittsburgh.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Modify Table 105 in 24.2.7 [random.access.iterators]:
</p>

<blockquote>
<table border="1">
<caption>Table 105  Random access iterator requirements (in addition to
bidirectional iterator)</caption>

<tbody><tr>
<th>Expression</th>
<th>Return type</th>
<th>Operational semantics</th>
<th>Assertion/note<br>pre-/post-condition</th>
</tr>

<tr>
<td><tt>b - a</tt></td>
<td><tt>Distance</tt></td>
<td><tt><del>distance(a,b)</del></tt>
<ins>return <tt>n</tt></ins></td>
<td>pre: there exists a value <tt>n</tt> of <tt>Distance</tt> such that <tt>a +
n == b</tt>. <tt>b == a + (b - a)</tt>.</td>
</tr>

</tbody></table>
</blockquote>





<hr>
<h3><a name="1089"></a>1089. Response to JP 76</h3>
<p><b>Section:</b> 30 [thread] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-03-22 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread">issues</a> in [thread].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses JP 76</b></p>

<p>
A description for "Throws: Nothing." are not unified.
</p>

<p>
At the part without throw, "Throws: Nothing." should be described.
</p>

<p>
Add "Throws: Nothing." to the following.
</p>

<ul>
<li>
30.3.1.6 [thread.thread.static] p1
</li>
<li>
30.4.2.1 [thread.lock.guard] p4
</li>
<li>
30.4.2.2.1 [thread.lock.unique.cons] p6
</li>
<li>
30.5.1 [thread.condition.condvar] p7 and p8
</li>
<li>
30.5.2 [thread.condition.condvarany] p6, p7, p19, p21 and p25
</li>
</ul>

<p><i>[
Summit:
]</i></p>

<blockquote>
Pass on to editor.
</blockquote>

<p><i>[
Post Summit:  Editor declares this non-editorial.
]</i></p>


<p><i>[
2009-08-01 Howard provided wording:
]</i></p>


<blockquote>

<p>
The definition of "<i>Throws:</i> Nothing." that I added is probably going to
be controversial, but I beg you to consider it seriously.
</p>

<blockquote>
<p>
In C++ there are three "flow control" options for a function:
</p>

<ol>
<li>
It can return, either with a value, or with <tt>void</tt>.
</li>
<li>
It can call a function which never returns, such as <tt>std::exit</tt> or
<tt>std::terminate</tt>.
</li>
<li>
It can throw an exception.
</li>
</ol>

The above list can be abbreviated with:

<ol>
<li><b>R</b>eturns.</li>
<li><b>E</b>nds program.</li>
<li><b>T</b>hrows exception.</li>
</ol>

<p>
In general a function can have the behavior of any of these 3, or any combination
of any of these three, depending upon run time data.
</p>

<ol>
<li><b>R</b></li>
<li><b>E</b></li>
<li><b>T</b></li>
<li><b>RE</b></li>
<li><b>RT</b></li>
<li><b>ET</b></li>
<li><b>RET</b></li>
</ol>

<p>
A function with no throw spec, and no documentation, is in general a <b>RET</b>
function.  It may return, it may end the program, or it may throw.  When we
specify a function with an empty throw spec:
</p>

<blockquote><pre>void f() throw();
</pre></blockquote>

<p>
We are saying that <tt>f()</tt> is an <b>RE</b> function:  It may return or end
the program, but it will not throw.
</p>

<p>
I posit that there are very few places in the library half of the standard
where we intend for functions to be able to end the program (call <tt>terminate</tt>).
And none of those places where we do say <tt>terminate</tt> could be called,
do we currently say "<i>Throws:</i> Nothing.".
</p>

<p>
I believe that if we define "<i>Throws:</i> Nothing." to mean <b>R</b>,
we will both clarify many, many places in the standard, <em>and</em> give us a
good rationale for choosing between "<i>Throws:</i> Nothing." (<b>R</b>)
and <tt>throw()</tt> (<b>RE</b>) in the future.  Indeed, this may give us motivation
to change several <tt>throw()</tt>s to "<i>Throws:</i> Nothing.".
</p>
</blockquote>

<p>
I did not add the following changes as JP 76 requested as I believe we want to
allow these functions to throw:
</p>

<blockquote>
<p>
Add a paragraph under 30.4.2.1 [thread.lock.guard] p4:
</p>

<blockquote><pre>explicit lock_guard(mutex_type&amp; m);
</pre>

<p><ins>
<i>Throws:</i> Nothing.
</ins></p>
</blockquote>

<p>
Add a paragraph under 30.4.2.2.1 [thread.lock.unique.cons] p6:
</p>

<blockquote><pre>explicit unique_lock(mutex_type&amp; m);
</pre>

<p><ins>
<i>Throws:</i> Nothing.
</ins></p>
</blockquote>

<p>
Add a paragraph under 30.5.2 [thread.condition.condvarany] p19, p21 and p25:
</p>

<blockquote><pre>template &lt;class Lock, class Rep, class Period&gt; 
  bool wait_for(Lock&amp; lock, const chrono::duration&lt;Rep, Period&gt;&amp; rel_time);
</pre>

<p><ins>
<i>Throws:</i> Nothing.
</ins></p>
</blockquote>

<blockquote><pre>template &lt;class Lock, class Duration, class Predicate&gt; 
  bool wait_until(Lock&amp; lock, const chrono::time_point&lt;Clock, Duration&gt;&amp; rel_time, Predicate pred);
</pre>

<p><ins>
<i>Throws:</i> Nothing.
</ins></p>
</blockquote>

<blockquote><pre>template &lt;class Lock, class Rep, class Period, class Predicate&gt; 
  bool wait_for(Lock&amp; lock, const chrono::duration&lt;Rep, Period&gt;&amp; rel_time, Predicate pred);
</pre>

<p><ins>
<i>Throws:</i> Nothing.
</ins></p>
</blockquote>

</blockquote>

</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Defer pending further developments with exception restriction annotations.
</blockquote>

<p><i>[
2010-02-11 Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>


<p><i>[
2010-02-24 Pete moved to Open:
]</i></p>


<blockquote>
A "<i>Throws:</i> Nothing" specification is not the place to say that a function
is not allowed to call <tt>exit()</tt>. While I agree with the thrust of the
proposed resolution, "doesn't throw exceptions" is a subset of "always returns
normally". If it's important to say that most library functions don't call
<tt>exit()</tt>, say so.
</blockquote>

<p><i>[
2010 Pittsburgh:
]</i></p>


<blockquote>
Move to Ready except for the added paragraph to 17.5.1.4 [structure.specifications].
</blockquote>



<p><b>Proposed resolution:</b></p>


<p>
Add a paragraph under 30.3.1.6 [thread.thread.static] p1:
</p>

<blockquote><pre>unsigned hardware_concurrency();
</pre>

<p>
-1- <i>Returns:</i> ...
</p>

<p><ins>
<i>Throws:</i> Nothing.
</ins></p>
</blockquote>

<p>
Add a paragraph under 30.5.1 [thread.condition.condvar] p7 and p8:
</p>

<blockquote>
<p>
<i>[Informational, not to be incluced in the WP: The POSIX spec allows only:</i>
</p>
<dl>
<dt><i>[EINVAL]</i></dt>
<dd><i>The value <tt>cond</tt> does not refer to an initialized condition variable.  end informational]</i></dd>
</dl>

<pre>void notify_one();
</pre>

<p>
-7- <i>Effects:</i> ...
</p>

<p><ins>
<i>Throws:</i> Nothing.
</ins></p>
</blockquote>

<blockquote><pre>void notify_all();
</pre>

<p>
-8- <i>Effects:</i> ...
</p>

<p><ins>
<i>Throws:</i> Nothing.
</ins></p>
</blockquote>


<p>
Add a paragraph under 30.5.2 [thread.condition.condvarany] p6 and p7:
</p>

<blockquote>
<pre>void notify_one();
</pre>

<p>
-6- <i>Effects:</i> ...
</p>

<p><ins>
<i>Throws:</i> Nothing.
</ins></p>
</blockquote>

<blockquote><pre>void notify_all();
</pre>

<p>
-7- <i>Effects:</i> ...
</p>

<p><ins>
<i>Throws:</i> Nothing.
</ins></p>
</blockquote>







<hr>
<h3><a name="1094"></a>1094. Response to JP 65 and JP 66</h3>
<p><b>Section:</b> 27.5.4.3 [iostate.flags] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> P.J. Plauger <b>Opened:</b> 2009-03-24 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#iostate.flags">issues</a> in [iostate.flags].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses JP 65 and JP 66</b></p>

<p>
Switch from "unspecified-bool-type" to "explicit operator bool() const". 
</p>

<p>
Replace <tt>operator unspecified-bool-type() const;</tt>" with <tt>explicit operator bool() const;</tt>
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution.
Move to Review.
</blockquote>

<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote>
Moved to Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change the synopis in 27.5.4 [ios]:
</p>

<blockquote><pre><ins>explicit</ins> operator <del><i>unspecified-bool-type</i></del> <ins>bool</ins>() const;
</pre></blockquote>

<p>
Change 27.5.4.3 [iostate.flags]:
</p>

<blockquote><pre><ins>explicit</ins> operator <del><i>unspecified-bool-type</i></del> <ins>bool</ins>() const;
</pre>

<blockquote>
<p>
-1- <i>Returns:</i> <ins><tt>!fail()</tt></ins> <del>If <tt>fail()</tt> then a value that will evaluate
false in a boolean context; otherwise a value that will evaluate true in
a boolean context. The value type returned shall not be convertible to
int.</del>
</p>
<p>
<del>[<i>Note:</i> This conversion can be used in contexts where a bool is expected
(e.g., an <tt>if</tt> condition); however, implicit conversions (e.g.,
to <tt>int</tt>) that can occur with <tt>bool</tt> are not allowed,
eliminating some sources of user error. One possible implementation
choice for this type is pointer-to-member. <i>-- end note</i>]</del>
</p>
</blockquote>
</blockquote>







<hr>
<h3><a name="1095"></a>1095. <i>Shared objects and the library</i> wording unclear</h3>
<p><b>Section:</b> 17.6.3.10 [res.on.objects] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Beman Dawes <b>Opened:</b> 2009-03-27 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2775.htm">N2775</a>,
<i>Small library thread-safety revisions</i>, among other changes, removed a note from
17.6.3.10 [res.on.objects] that read:
</p>

<blockquote>
[<i>Note:</i> This prohibition against concurrent non-const access means that
modifying an object of a standard library type shared between threads
without using a locking mechanism may result in a data race. <i>--end note</i>.]
</blockquote>

<p>
That resulted in wording which is technically correct but can only be
understood by reading the lengthy and complex 17.6.4.9 [res.on.data.races]
Data race avoidance. This has the effect of making
17.6.3.10 [res.on.objects] unclear, and has already resulted in a query
to the LWG reflector. See c++std-lib-23194.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
The proposed wording seems to need a bit of tweaking
("really bad idea" isn't quite up to standardese).
We would like feedback
as to whether the original Note's removal was intentional.
</p>
<p>
Change the phrase "is a really bad idea"
to "risks undefined behavior" and
move to Review status.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Note: Change to read: "Modifying...", Delete 'thus', move to Ready
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 17.6.3.10 [res.on.objects] as indicated:
</p>

<blockquote>
<p>
The behavior of a program is undefined if calls to standard library
functions from different threads may introduce a data race. The
conditions under which this may occur are specified in 17.6.4.7.
</p>
<p><ins>
[<i>Note:</i> Modifying an object of a standard library type shared between
threads risks undefined behavior unless objects of the type are explicitly
specified as being sharable without data races or the user supplies a
locking mechanism. <i>--end note</i>]
</ins></p>
</blockquote>





<hr>
<h3><a name="1097"></a>1097. #define __STDCPP_THREADS</h3>
<p><b>Section:</b> 18.2 [support.types] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Jens Maurer <b>Opened:</b> 2009-04-03 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#support.types">issues</a> in [support.types].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses DE 18</b></p>

<p>
Freestanding implementations do not (necessarily) have
  support for multiple threads (see 1.10 [intro.multithread]).
  Applications and libraries may want to optimize for the
  absence of threads.  I therefore propose a preprocessor
  macro to indicate whether multiple threads can occur.
</p>

<p>
There is ample prior implementation experience for this
  feature with various spellings of the macro name.  For
  example, gcc implicitly defines <tt>_REENTRANT</tt>
  if multi-threading support is selected on the compiler
  command-line.
</p>

<p>
While this is submitted as a library issue, it may be more
  appropriate to add the macro in 16.8 cpp.predefined in the
  core language.
</p>

<p>
See also
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2693.html">N2693</a>.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We agree with the issue, and believe it is properly a library issue.
</p>
<p>
We prefer that the macro be conditionally defined
as part of the <tt>&lt;thread&gt;</tt> header.
</p>
<p>
Move to Review.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Move to Ready.
</blockquote>

<p><i>[
2010-02-25 Pete moved to Open:
]</i></p>


<blockquote>
<p>
The proposed resolution adds a feature-test macro named
<tt>__STDCPP_THREADS</tt>, described after the following new text:
</p>

<blockquote>
The standard library defines the following macros; no explicit prior inclusion
of any header file is necessary.
</blockquote>

<p>
The correct term here is "header", not "header file". But that's minor. The real
problem is that library entities are always defined in headers. If
<tt>__STDCPP_THREADS</tt> is defined without including any header it's part of
the language and belongs with the other predefined macros in the Preprocessor
clause.
</p>

<p>
Oddly enough, the comments from Batavia say "We prefer that the macro be
conditionally defined as part of the <tt>&lt;thread&gt;</tt> header." There's no
mention of a decision to change this.
</p>
</blockquote>

<p><i>[
2010-02-26 Ganesh updates wording.
]</i></p>


<p><i>[
2010 Pittsburgh:  Adopt Ganesh's wording and move to Review.
]</i></p>


<p><i>[
2010-03-08 Pete adds:
]</i></p>


<blockquote>
Most macros we have begin and end with with double underbars, this one
only begins with double underbars.
</blockquote>

<p><i>[
2010 Pittsburgh:  Ganesh's wording adopted and moved to Ready for Pittsburgh.
]</i></p>




<p><b>Proposed resolution:</b></p>

<p>
Change 17.6.1.3 [compliance]/3:
</p>

<blockquote>
3 The supplied version of the header <tt>&lt;cstdlib&gt;</tt> shall
declare at least the functions <tt>abort()</tt>, <tt>atexit()</tt>, and
<tt>exit()</tt> (18.5). <ins>The supplied version of the header
<tt>&lt;thread&gt;</tt> either shall meet the same requirements as for a
hosted implementation or including it shall have no effect.</ins> The
other headers listed in this table shall meet the same requirements as
for a hosted implementation.
</blockquote>

<p>
Add the following line to table 15:
</p>

<blockquote>
<table border="1">
<caption>Table 15  C++ headers for freestanding implementations</caption>

<tbody><tr>
<th>Subclause</th>
<th>Header(s)</th>
</tr>

<tr>
<td colspan="2">...</td>
</tr>

<tr>
<td><ins>30.3 [thread.threads] Threads</ins></td>
<td><ins><tt>&lt;thread&gt;</tt></ins></td>
</tr>

</tbody></table>

</blockquote>

<p>
Add to the <tt>&lt;thread&gt;</tt> synopsis in 30.3 [thread.threads]/1 the line:
</p>

<blockquote><pre>namespace std {

<ins>#define __STDCPP_THREADS __cplusplus</ins>

  class thread;
  ...
</pre></blockquote>









<hr>
<h3><a name="1098"></a>1098. definition of get_pointer_safety()</h3>
<p><b>Section:</b> 20.9.11 [util.dynamic.safety] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Jens Maurer <b>Opened:</b> 2009-04-03 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#util.dynamic.safety">issues</a> in [util.dynamic.safety].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses DE 18</b></p>

<p>
 In 20.9.11 [util.dynamic.safety], <tt>get_pointer_safety()</tt> purports
to define behavior for
 non-safely derived pointers (3.7.4.3 [basic.stc.dynamic.safety]).  However,
 the cited core-language section in paragraph 4 specifies undefined behavior
 for the use of such pointer values.  This seems an unfortunate near-contradiction.
 I suggest to specify the term <i>relaxed pointer safety</i> in
 the core language section and refer to it from the library description.
 This issue deals with the library part, the corresponding core issue (c++std-core-13940)
 deals with the core modifications.
</p>

<p>
See also
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2693.html">N2693</a>.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We recommend if this issue is to be moved,
the issue be moved concurrently with the cited Core issue.
</p>
<p>
We agree with the intent of the proposed resolution.
We would like input from garbage collection specialists.
</p>
<p>
Move to Open.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
The core issue is 853 and is in Ready status.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
In 20.9.11 [util.dynamic.safety] p16, replace the description of
<tt>get_pointer_safety()</tt> with:
</p>

<blockquote>
<p>
<tt>pointer_safety get_pointer_safety();</tt>
</p>
<blockquote>
<p>
<del><i>Returns:</i> an enumeration value indicating the implementation's treatment
of pointers that are not safely derived (3.7.4.3). Returns
<tt>pointer_safety::relaxed</tt> if pointers that are not safely derived will be
treated the same as pointers that are safely derived for the duration of
the program. Returns <tt>pointer_safety::preferred</tt> if pointers that are not
safely derived will be treated the same as pointers that are safely
derived for the duration of the program but allows the implementation to
hint that it could be desirable to avoid dereferencing pointers that are
not safely derived as described. [<i>Example:</i> <tt>pointer_safety::preferred</tt>
might be returned to detect if a leak detector is running to avoid
spurious leak reports. -- <i>end note</i>] Returns <tt>pointer_safety::strict</tt> if
pointers that are not safely derived might be treated differently than
pointers that are safely derived.</del>
</p>
<p><ins>
<i>Returns:</i> Returns <tt>pointer_safety::strict</tt> if the implementation has
   strict pointer safety (3.7.4.3 [basic.stc.dynamic.safety]). It is
   implementation-defined whether <tt>get_pointer_safety</tt> returns
   <tt>pointer_safety::relaxed</tt> or <tt>pointer_safety::preferred</tt> if the
   implementation has relaxed pointer safety
   (3.7.4.3 [basic.stc.dynamic.safety]).<sup>Footnote</sup>
</ins></p>

<p><ins>
<i>Throws:</i> nothing
</ins></p>

<p><ins>
Footnote) <tt>pointer_safety::preferred</tt> might be returned to indicate to the
   program that a leak detector is running so that the program can avoid
   spurious leak reports.
</ins>
</p>

</blockquote>
</blockquote>





<hr>
<h3><a name="1100"></a>1100. <tt>auto_ptr</tt> to <tt>unique_ptr</tt> conversion</h3>
<p><b>Section:</b> 20.9.9.2.1 [unique.ptr.single.ctor] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-04-25 <b>Last modified:</b> 2010-11-19</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#unique.ptr.single.ctor">issues</a> in [unique.ptr.single.ctor].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Message c++std-lib-23182 led to a discussion in which several people
expressed interest in being able to convert an <tt>auto_ptr</tt> to a
<tt>unique_ptr</tt> without the need to call <tt>release</tt>.  Below is
wording to accomplish this.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Pete believes it not a good idea to separate parts of a class's definition.
Therefore, if we do this,
it should be part of <tt>unique-ptr</tt>'s specification.
</p>
<p>
Alisdair believes the lvalue overload may be not necessary.
</p>
<p>
Marc believes it is more than just sugar,
as it does ease the transition to <tt>unique-ptr</tt>.
</p>
<p>
We agree with the resolution as presented.
Move to Tentatively Ready.
</p>
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
Moved from Tentatively Ready to Open only because the wording needs to be
tweaked for concepts removal.
</blockquote>

<p><i>[
2009-08-01 Howard deconceptifies wording:
]</i></p>


<blockquote>
I also moved the change from D.12 [depr.auto.ptr]
to 20.9.9.2 [unique.ptr.single] per the Editor's request
in Batavia (as long as I was making changes anyway).  Set back
to Review.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Move to Ready.
</blockquote>

<p><i>[
2010-03-14 Howard adds:
]</i></p>


<blockquote>
We moved
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3073.html">N3073</a>
to the formal motions page in Pittsburgh which should obsolete this issue.  I've
moved this issue to NAD Editorial, solved by N3073.
</blockquote>



<p><b>Rationale:</b></p>
<p>
Solved by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3073.html">N3073</a>.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add to 20.9.9.2 [unique.ptr.single]:
</p>

<blockquote><pre>template &lt;class T, class D&gt;
class unique_ptr
{
public:
<ins>    template &lt;class U&gt;
      unique_ptr(auto_ptr&lt;U&gt;&amp; u);
    template &lt;class U&gt;
      unique_ptr(auto_ptr&lt;U&gt;&amp;&amp; u);</ins>
};
</pre></blockquote>

<p>
Add to 20.9.9.2.1 [unique.ptr.single.ctor]:
</p>

<blockquote><pre>template &lt;class U&gt;
  unique_ptr(auto_ptr&lt;U&gt;&amp; u);
template &lt;class U&gt;
  unique_ptr(auto_ptr&lt;U&gt;&amp;&amp; u);
</pre>
<blockquote>
<p>
<i>Effects:</i> Constructs a <tt>unique_ptr</tt> with <tt>u.release()</tt>.
</p>

<p>
<i>Postconditions:</i> <tt>get() == </tt> the value <tt>u.get()</tt> had before
the construciton, modulo any required offset adjustments resulting from the cast from
<tt>U*</tt> to <tt>T*</tt>.  <tt>u.get() == nullptr</tt>.
</p>

<p>
<i>Throws:</i> nothing.
</p>

<p>
<i>Remarks:</i> <tt>U*</tt> shall be implicitly convertible to <tt>T*</tt> and
<tt>D</tt> shall be the same type as <tt>default_delete&lt;T&gt;</tt>, else these
constructors shall not participate in overload resolution.
</p>
</blockquote>
</blockquote>






<hr>
<h3><a name="1103"></a>1103. <tt>system_error</tt> constructor postcondition overly strict</h3>
<p><b>Section:</b> 19.5.6.2 [syserr.syserr.members] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-04-25 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
19.5.6.2 [syserr.syserr.members] says:
</p>

<blockquote><pre>system_error(error_code ec, const string&amp; what_arg);
</pre>
<blockquote>
<p>
<i>Effects:</i> Constructs an object of class <tt>system_error</tt>.
</p>
<p>
<i>Postconditions:</i> <tt>code() == ec</tt> and <tt>strcmp(runtime_error::what(), what_arg.c_str()) == 0</tt>.
</p>
</blockquote>
</blockquote>

<p>
However the intent is for:
</p>

<blockquote><pre>std::system_error se(std::errc::not_a_directory, "In FooBar");
...
se.what();  <font color="#C80000">// returns something along the lines of:</font>
            <font color="#C80000">//   "In FooBar: Not a directory"</font>
</pre></blockquote>

<p>
The way the constructor postconditions are set up now, to achieve both
conformance, and the desired intent in the <tt>what()</tt> string, the
<tt>system_error</tt> constructor must store "In FooBar" in the base class,
and then form the desired output each time <tt>what()</tt> is called.  Or
alternatively, store "In FooBar" in the base class, and store the desired
<tt>what()</tt> string in the derived <tt>system_error</tt>, and override
<tt>what()</tt> to return the string in the derived part.
</p>

<p>
Both of the above implementations seem suboptimal to me.  In one I'm computing
a new string every time <tt>what()</tt> is called.  And since <tt>what()</tt>
can't propagate exceptions, the client may get a different string on different
calls.
</p>

<p>
The second solution requires storing two strings instead of one.
</p>

<p>
What I would like to be able to do is form the desired <tt>what()</tt> string
once in the <tt>system_error</tt> constructor, and store <em>that</em> in the
base class.  Now I'm:
</p>

<ol>
<li>Computing the desired <tt>what()</tt> only once.</li>
<li>The base class <tt>what()</tt> definition is sufficient and nothrow.</li>
<li>I'm not storing multiple strings.</li>
</ol>

<p>
This is smaller code, smaller data, and faster.
</p>

<p>
<tt>ios_base::failure</tt> has the same issue.
</p>

<p><i>[
Comments about this change received favorable comments from the <tt>system_error</tt>
designers.
]</i></p>


<p><i>[
Batavia (2009-05):
]</i></p>


<blockquote>
<p>
We agree with the proposed resolution.
</p>
<p>
Move to Tentatively Ready.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
In 19.5.6.2 [syserr.syserr.members], change the following constructor postconditions:
</p>

<blockquote>
<pre>system_error(error_code ec, const string&amp; what_arg);
</pre>
<blockquote>
-2- <i>Postconditions:</i> <tt>code() == ec</tt>
and <tt><del>strcmp(runtime_error::what(), what_arg.c_str()) == 0</del>
<ins>string(what()).find(what_arg) != string::npos</ins></tt>.
</blockquote>

<pre>system_error(error_code ec, const char* what_arg);
</pre>
<blockquote>
-4- <i>Postconditions:</i> <tt>code() == ec</tt>
and <tt><del>strcmp(runtime_error::what(), what_arg) == 0</del>
<ins>string(what()).find(what_arg) != string::npos</ins></tt>.
</blockquote>

<pre>system_error(error_code ec);
</pre>
<blockquote>
-6- <i>Postconditions:</i> <tt>code() == ec</tt>
<del>and <tt>strcmp(runtime_error::what(), ""</tt></del>.
</blockquote>

<pre>system_error(int ev, const error_category&amp; ecat, const string&amp; what_arg);
</pre>
<blockquote>
-8- <i>Postconditions:</i> <tt>code() == error_code(ev, ecat)</tt>
and <tt><del>strcmp(runtime_error::what(), what_arg.c_str()) == 0</del>
<ins>string(what()).find(what_arg) != string::npos</ins></tt>.
</blockquote>

<pre>system_error(int ev, const error_category&amp; ecat, const char* what_arg);
</pre>
<blockquote>
-10- <i>Postconditions:</i> <tt>code() == error_code(ev, ecat)</tt>
and <tt><del>strcmp(runtime_error::what(), what_arg) == 0</del>
<ins>string(what()).find(what_arg) != string::npos</ins></tt>.
</blockquote>

<pre>system_error(int ev, const error_category&amp; ecat);
</pre>
<blockquote>
-12- <i>Postconditions:</i> <tt>code() == error_code(ev, ecat)</tt>
<del>and <tt>strcmp(runtime_error::what(), "") == 0</tt></del>.
</blockquote>

</blockquote>

<p>
In 19.5.6.2 [syserr.syserr.members], change the description of <tt>what()</tt>:
</p>

<blockquote>
<pre>const char *what() const throw();
</pre>
<blockquote>
<p>
-14- <i>Returns:</i> An NTBS incorporating <del><tt>runtime_error::what()</tt> and
<tt>code().message()</tt></del> <ins>the arguments supplied in the constructor</ins>.
</p>
<p>
[<i>Note:</i> <del>One possible implementation would be:</del>
<ins>The return NTBS might take the form: <tt>what_arg + ": " + code().message()</tt></ins>
</p>
<blockquote><pre><del>
if (msg.empty()) { 
  try { 
    string tmp = runtime_error::what(); 
    if (code()) { 
      if (!tmp.empty()) 
        tmp += ": "; 
      tmp += code().message(); 
    } 
    swap(msg, tmp); 
  } catch(...) { 
    return runtime_error::what(); 
  } 
return msg.c_str();
</del></pre></blockquote>
<p>
 <i>end note</i>]
</p>
</blockquote>
</blockquote>

<p>
In 27.5.2.1.1 [ios::failure], change the synopsis:
</p>

<blockquote><pre>namespace std { 
  class ios_base::failure : public system_error { 
  public: 
    explicit failure(const string&amp; msg, const error_code&amp; ec = io_errc::stream); 
    explicit failure(const char* msg, const error_code&amp; ec = io_errc::stream); 
    <del>virtual const char* what() const throw();</del>
  }; 
}
</pre></blockquote>

<p>
In 27.5.2.1.1 [ios::failure], change the description of the constructors:
</p>

<blockquote>

<pre>explicit failure(const string&amp; msg, , const error_code&amp; ec = io_errc::stream);
</pre>
<blockquote>
<p>
-3- <i>Effects:</i> Constructs an object of class <tt>failure</tt>
<ins>by constructing the base class with <tt>msg</tt> and <tt>ec</tt></ins>.
</p>
<p>
<del>-4- <i>Postcondition:</i> <tt>code() == ec</tt> and <tt>strcmp(what(), msg.c_str()) == 0</tt></del>
</p>
</blockquote>

<pre>explicit failure(const char* msg, const error_code&amp; ec = io_errc::stream);
</pre>
<blockquote>
<p>
-5- <i>Effects:</i> Constructs an object of class <tt>failure</tt>
<ins>by constructing the base class with <tt>msg</tt> and <tt>ec</tt></ins>.
</p>
<p>
<del>-6- <i>Postcondition:</i> <tt>code() == ec and strcmp(what(), msg) == 0</tt></del>
</p>
</blockquote>

</blockquote>

<p>
In 27.5.2.1.1 [ios::failure], remove <tt>what</tt> (the base class definition
need not be repeated here).
</p>

<blockquote>
<pre><del>const char* what() const;</del>
</pre>
<blockquote>
<del>-7- <i>Returns:</i> The message <tt>msg</tt> with which the exception was created.</del>
</blockquote>

</blockquote>






<hr>
<h3><a name="1104"></a>1104. <tt>basic_ios::move</tt> should accept lvalues</h3>
<p><b>Section:</b> 27.5.4.2 [basic.ios.members] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-04-25 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#basic.ios.members">issues</a> in [basic.ios.members].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
With the rvalue reference changes in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2844.html">N2844</a>
<tt>basic_ios::move</tt> no longer has the most convenient signature:
</p>

<blockquote><pre>void move(basic_ios&amp;&amp; rhs);
</pre></blockquote>

<p>
This signature should be changed to accept lvalues.  It does not need to be
overloaded to accept rvalues.  This is a special case that only derived clients
will see.  The generic <tt>move</tt> still needs to accept rvalues.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Tom prefers, on general principles, to provide both overloads.
Alisdair agrees.
</p>
<p>
Howard points out that there is no backward compatibility issue
as this is new to C++0X.
</p>
<p>
We agree that both overloads should be provided,
and Howard will provide the additional wording.
Move to Open.
</p>
</blockquote>

<p><i>[
2009-05-23 Howard adds:
]</i></p>


<blockquote>
Added overload, moved to Review.
</blockquote>

<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote>
Move to Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add a signature to the existing prototype in the synopsis of 27.5.4 [ios]
and in 27.5.4.2 [basic.ios.members]:
</p>

<blockquote><pre><ins>void move(basic_ios&amp; rhs);</ins>
void move(basic_ios&amp;&amp; rhs);
</pre></blockquote>





<hr>
<h3><a name="1108"></a>1108. thread.req.exception overly constrains implementations</h3>
<p><b>Section:</b> 30.2.2 [thread.req.exception] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Christopher Kohlhoff <b>Opened:</b> 2009-04-25 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The current formulation of 30.2.2 [thread.req.exception]/2 reads:
</p>
<blockquote>
The error_category of the <tt>error_code</tt> reported by such an
exception's <tt>code()</tt> member function is as specified in the error
condition Clause.
</blockquote>
<p>
This constraint on the code's associated <tt>error_categor</tt> means an
implementation must perform a mapping from the system-generated
error to a <tt>generic_category()</tt> error code. The problems with this
include:
</p>

<ul>
<li>
The mapping is always performed, even if the resultant value is
 never used.
</li>
<li>
<p>
The original error produced by the operating system is lost.
</p>
</li>
</ul>
<p>
The latter was one of Peter Dimov's main objections (in a private
email discussion) to the original <tt>error_code</tt>-only design, and led to
the creation of <tt>error_condition</tt> in the first place. Specifically,
<tt>error_code</tt> and <tt>error_condition</tt> are intended to perform the following
roles:
</p>
<ul>
<li>
<tt>error_code</tt> holds the original error produced by the operating
 system.
</li>
<li>
<tt>error_condition</tt> and the generic category provide a set of well
 known error constants that error codes may be tested against.
</li>
</ul>
<p>
Any mapping determining correspondence of the returned error code to
the conditions listed in the error condition clause falls under the
"latitude" granted to implementors in 19.5.1.5 [syserr.errcat.objects].
(Although obviously their latitude is restricted a little by the
need to match the right error condition when returning an error code
from a library function.)
</p>
<p>
It is important that this <tt>error_code/error_condition</tt> usage is done
correctly for the thread library since it is likely to set the
pattern for future TR libraries that interact with the operating
system.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Move to Open, and recommend the issue be deferred until after the next
Committee Draft is issued.
</blockquote>

<p><i>[
2009-10 post-Santa Cruz:
]</i></p>


<blockquote>
Move to Tentatively Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 30.2.2 [thread.req.exception]/2:
</p>

<blockquote>
<p>
-2- <del>The <tt>error_category</tt> (19.5.1.1) of the <tt>error_code</tt> reported by
such an exception's <tt>code()</tt> member function 
is as specified in the error condition Clause.</del>
<ins>
The <tt>error_code</tt> reported by such an exception's <tt>code()</tt> member
function shall compare equal to one of the conditions specified in
the function's error condition Clause. [<i>Example:</i> When the thread
constructor fails:
</ins>
</p>
<blockquote><pre><ins>
ec.category() == implementation-defined // probably system_category
ec == errc::resource_unavailable_try_again // holds true
</ins></pre></blockquote>

<p><ins>
 <i>end example</i>]
</ins></p>

</blockquote>






<hr>
<h3><a name="1110"></a>1110. Is <tt>for_each</tt> overconstrained?</h3>
<p><b>Section:</b> 25.2.4 [alg.foreach] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-04-29 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.foreach">issues</a> in [alg.foreach].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Quoting working paper for reference (25.2.4 [alg.foreach]):
</p>

<blockquote>
<pre>template&lt;InputIterator Iter, Callable&lt;auto, Iter::reference&gt; Function&gt;
  requires CopyConstructible&lt;Function&gt;
  Function for_each(Iter first, Iter last, Function f);
</pre>
<blockquote>
<p>
1 Effects: Applies f to the result of dereferencing every iterator in the
 range [first,last), starting from first and proceeding to last - 1.
</p>
<p>
2 Returns: f.
</p>
<p>
3 Complexity: Applies f exactly last - first times.
</p>
</blockquote>
</blockquote>

<p>
P2 implies the passed object <tt>f</tt> should be invoked at each stage, rather than
some copy of <tt>f</tt>.  This is important if the return value is to usefully
accumulate changes.  So the requirements are an object of type <tt>Function</tt> can
be passed-by-value, invoked multiple times, and then return by value.  In
this case, <tt>MoveConstructible</tt> is sufficient. This would open support for
move-only functors, which might become important in concurrent code as you
can assume there are no other references (copies) of a move-only type and so
freely use them concurrently without additional locks.
</p>

<p><i>[
See further discussion starting with c++std-lib-23686.
]</i></p>


<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Pete suggests we may want to look at this in a broader context
involving other algorithms.
We should also consider the implications of parallelism.
</p>
<p>
Move to Open, and recommend the issue be deferred until after the next
Committee Draft is issued.
</p>
</blockquote>

<p><i>[
2009-10-14 Daniel de-conceptified the proposed resolution.
]</i></p>


<blockquote>
<p>
The note in 25.1 [algorithms.general]/9 already says the right thing:
</p>
<blockquote>
Unless otherwise specified, algorithms that take function objects
as arguments are permitted to copy those function objects freely.
</blockquote>
<p>
So we only need to ensure that the wording for <tt>for_each</tt> is sufficiently
clear, which is the intend of the following rewording.
</p>
</blockquote>

<p><i>[
2009-10-15 Daniel proposes:
]</i></p>


<blockquote>
<ul>
<li>
<p>
Add a new Requires clause just after the prototype declaration (25.2.4 [alg.foreach]):
</p>
<blockquote>
<p>
<ins><i>Requires:</i> <tt>Function</tt> shall be <tt>MoveConstructible</tt>
( [moveconstructible]), <tt>CopyConstructible</tt> is not required.</ins>
</p>
</blockquote>
</li>
<li>
<p>
Change 25.2.4 [alg.foreach]/2 as indicated:
</p>

<blockquote>
<i>Returns:</i> <ins>std::move(</ins>f<ins>)</ins>.
</blockquote>
</li>
</ul>
</blockquote>

<p><i>[
2009-10 post-Santa Cruz:
]</i></p>


<blockquote>
Move to Tentatively Ready, using Daniel's wording without the portion
saying "CopyConstructible is not required".
</blockquote>

<p><i>[
2009-10-27 Daniel adds:
]</i></p>


<blockquote>
<p>
I see that during the Santa Cruz meeting the originally proposed addition
</p>

<blockquote>
, <tt>CopyConstructible</tt> is not required.
</blockquote>

<p>
was removed. I don't think that this removal was a good idea. The combination
of 25.1 [algorithms.general]/9
</p>

<blockquote>
[<i>Note:</i> Unless otherwise specified, algorithms that take function objects
as arguments are permitted to copy those function objects freely.[..]
</blockquote>

<p>
with the fact that <tt>CopyConstructible</tt> is a refinement <tt>MoveConstructible</tt>
makes it necessary that such an explicit statement is given. Even the
existence of the usage of <tt>std::move</tt> in the <i>Returns</i> clause doesn't
help much, because this would still be well-formed for a <tt>CopyConstructible</tt>
without move constructor. Let me add that the originally proposed
addition reflects current practice in the standard, e.g. 25.3.9 [alg.unique]/5
usages a similar terminology.
</p>

<p>
For similar wording need in case for auto_ptr see <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#973">973</a>.
</p>

<p><i>[
Howard: Moved from Tentatively Ready to Open.
]</i></p>

</blockquote>

<p><i>[
2009-11-20 Howard restores "not <tt>CopyConstructible</tt>" to the spec.
]</i></p>


<p><i>[
2009-11-22 Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>



<p><b>Proposed resolution:</b></p>
<ul>
<li>
<p>
Add a new Requires clause just after the prototype declaration (25.2.4 [alg.foreach]):
</p>
<blockquote>
<p>
<ins><i>Requires:</i> <tt>Function</tt> shall meet the requirements of
<tt>MoveConstructible</tt> ( [moveconstructible]). 
<tt>Function</tt> need not meet the requirements of
<tt>CopyConstructible</tt> ( [copyconstructible]).</ins>
</p>
</blockquote>
</li>
<li>
<p>
Change 25.2.4 [alg.foreach]/2 as indicated:
</p>

<blockquote>
<i>Returns:</i> <ins>std::move(</ins>f<ins>)</ins>.
</blockquote>
</li>
</ul>








<hr>
<h3><a name="1113"></a>1113. <tt>bitset::to_string</tt> could be simplified</h3>
<p><b>Section:</b> 20.5 [template.bitset] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-05-09 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#template.bitset">issues</a> in [template.bitset].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#853">853</a> our resolution is changing the signature by adding two
defaulting arguments to 3 calls.  In principle, this means that ABI breakage
is not an issue, while API is preserved.
</p>
<p>
With that observation, it would be very nice to use the new ability to
supply default template parameters to function templates to collapse all 3
signatures into 1.  In that spirit, this issue offers an alternative resolution
than that of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#853">853</a>.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Move to Open,
and look at the issue again after <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#853">853</a> has been accepted.
We further recommend this be deferred until after the next Committee Draft.
</blockquote>

<p><i>[
2009-10 post-Santa Cruz:
]</i></p>


<blockquote>
Move to Tentatively Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>

<ol type="A">
<li>
<p>
In 20.5 [template.bitset]/1 (class bitset) ammend:
</p>
<blockquote><pre>template &lt;class charT <ins>= char</ins>,
            class traits <ins>= char_traits&lt;charT&gt;</ins>,
            class Allocator <ins>= allocator&lt;charT&gt;</ins>&gt; 
  basic_string&lt;charT, traits, Allocator&gt;
  to_string(charT zero = charT('0'), charT one = charT('1')) const;
<del>template &lt;class charT, class traits&gt; 
  basic_string&lt;charT, traits, allocator&lt;charT&gt; &gt; to_string() const; 
template &lt;class charT&gt; 
  basic_string&lt;charT, char_traits&lt;charT&gt;, allocator&lt;charT&gt; &gt; to_string() const; 
basic_string&lt;char, char_traits&lt;char&gt;, allocator&lt;char&gt; &gt; to_string() const;</del>
</pre></blockquote>
</li>
<li>
<p>
In 20.5.2 [bitset.members] prior to p35 ammend:
</p>
<blockquote><pre>template &lt;class charT <ins>= char</ins>,
            class traits <ins>= char_traits&lt;charT&gt;</ins>,
            class Allocator <ins>= allocator&lt;charT&gt;</ins>&gt; 
  basic_string&lt;charT, traits, Allocator&gt;
  to_string(charT zero = charT('0'), charT one = charT('1')) const;
</pre></blockquote>
</li>
<li>
Strike 20.5.2 [bitset.members] paragraphs 37 -&gt; 39 (including signature
above 37)
</li>
</ol>






<hr>
<h3><a name="1114"></a>1114. Type traits underspecified</h3>
<p><b>Section:</b> 20.7 [meta] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2009-05-12 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#meta">issues</a> in [meta].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Related to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#975">975</a> and <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1023">1023</a>.
</p>

<p>
The current wording in 20.7.1 [meta.rqmts] is still unclear concerning
it's requirements on the type traits classes regarding ambiguities.
Specifically it's unclear
</p>

<ul>
<li>
if a predicate trait (20.7.4 [meta.unary], 20.7.6 [meta.rel]) could derive from both
<tt>true_type</tt>/<tt>false_type</tt>.
</li>
<li>
if any of the type traits (20.7.1 [meta.rqmts], 20.7.4 [meta.unary], 20.7.6 [meta.rel]) could ambiguously derive
from the same specified result type.
</li>
<li>
if any of the type traits (20.7.1 [meta.rqmts], 20.7.4 [meta.unary], 20.7.6 [meta.rel]) could derive from other
<tt>integral_constant</tt> types making the contained names ambiguous
</li>
<li>
if any of the type traits (20.7.1 [meta.rqmts], 20.7.4 [meta.unary], 20.7.6 [meta.rel]) could have other base
classes that contain members hiding the name of the result type members
or make the contained member names ambiguous.
</li>
</ul>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Alisdair would prefer to factor some of the repeated text,
but modulo a corner case or two,
he believes the proposed wording is otherwise substantially correct.
</p>
<p>
Move to Open.
</p>
</blockquote>

<p><i>[
2009-10 post-Santa Cruz:
]</i></p>


<blockquote>
Move to Tentatively Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p><i>[
The usage of the notion of a <i>BaseCharacteristic</i> below might be
useful in other places - e.g. to define the base class relation in 20.8.4 [refwrap], 20.8.13 [func.memfn], or 20.8.14.2 [func.wrap.func]. In this case it's definition should probably
be moved to Clause 17
]</i></p>


<ol>
<li>
<p>
Change 20.7.1 [meta.rqmts]/1 as indicated:
</p>
<blockquote>
[..] It shall be <tt>DefaultConstructible</tt>, <tt>CopyConstructible</tt>, and publicly
<ins>and unambiguously</ins> derived, directly or indirectly, from
<ins>its <i>BaseCharacteristic</i>, which is</ins> a specialization of the
template <tt>integral_constant</tt> (20.6.3), with the arguments to the template
<tt>integral_constant</tt> determined by the requirements for the particular
property being described. <ins>The member names of the
<i>BaseCharacteristic</i> shall be unhidden and unambiguously
available in the <i>UnaryTypeTrait</i>.</ins>
</blockquote>
</li>
<li>
<p>
Change 20.7.1 [meta.rqmts]/2 as indicated:
</p>
<blockquote>
[..] It shall be <tt>DefaultConstructible</tt>, <tt>CopyConstructible</tt>, and publicly
<ins>and unambiguously</ins> derived, directly or indirectly, from
<del>an instance</del> <ins>its <i>BaseCharacteristic</i>, which is a
specialization</ins> of the template <tt>integral_constant</tt> (20.6.3), with
the arguments to the template <tt>integral_constant</tt> determined by the
requirements for the particular relationship being described. <ins>The
member names of the <i>BaseCharacteristic</i> shall be unhidden
and unambiguously available in the <i>BinaryTypeTrait</i>.</ins>
</blockquote>
</li>
<li>
<p>
Change 20.7.4 [meta.unary]/2 as indicated:
</p>
<blockquote>
Each of these templates shall be a <i>UnaryTypeTrait</i> (20.6.1),
<del>publicly derived directly or indirectly from <tt>true_type</tt> if the
corresponding condition is true, otherwise from <tt>false_type</tt></del>
<ins>where its <i>BaseCharacteristic</i> shall be <tt>true_type</tt> if the
corresponding condition is true, otherwise <tt>false_type</tt></ins>.
</blockquote>
</li>
<li>
<p>
Change 20.7.6 [meta.rel]/2 as indicated:
</p>

<blockquote>
Each of these templates shall be a <i>BinaryTypeTrait</i> (20.6.1),
<del>publicly derived directly or indirectly from <tt>true_type</tt> if the
corresponding condition is true, otherwise from <tt>false_type</tt></del>
<ins>where its <i>BaseCharacteristic</i> shall be <tt>true_type</tt> if the
corresponding condition is true, otherwise <tt>false_type</tt></ins>.
</blockquote>
</li>
</ol>






<hr>
<h3><a name="1116"></a>1116. Literal constructors for tuple</h3>
<p><b>Section:</b> 20.4.2 [tuple.tuple] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-05-23 <b>Last modified:</b> 2010-11-20</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#tuple.tuple">issues</a> in [tuple.tuple].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It is not currently possible to construct <tt>tuple</tt> literal values,
even if the elements are all literal types.  This is because parameters
are passed to constructor by reference.
</p>
<p>
An alternative would be to pass all constructor arguments by value, where it
is known that *all* elements are literal types.  This can be determined with
concepts, although note that the negative constraint really requires
factoring out a separate concept, as there is no way to provide an 'any of
these fails' constraint inline.
</p>
<p>
Note that we will have similar issues with <tt>pair</tt> (and
<tt>tuple</tt> constructors from <tt>pair</tt>) although I am steering
clear of that class while other constructor-related issues settle.
</p>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
<del>NAD Editorial</del><ins>Resolved</ins>.  Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2994.html">N2994</a>.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Ammend the tuple class template declaration in 20.4.2 [tuple.tuple] as
follows
</p>

<blockquote>
<p>
Add the following concept:
</p>

<blockquote><pre>auto concept AllLiteral&lt; typename ... Types &gt; {
  requires LiteralType&lt;Types&gt;...;
}
</pre></blockquote>

<p>
ammend the constructor 
</p>

<blockquote><pre><ins>template &lt;class... UTypes&gt;
  requires AllLiteral&lt;Types...&gt;
        &amp;&amp; Constructible&lt;Types, UTypes&gt;...
  explicit tuple(UTypes...);</ins>

template &lt;class... UTypes&gt;
  requires <ins>!AllLiteral&lt;Types...&gt;</ins>
        <ins>&amp;&amp;</ins> Constructible&lt;Types, UTypes&amp;&amp;&gt;...
  explicit tuple(UTypes&amp;&amp;...);
</pre></blockquote>

<p>
ammend the constructor
</p>

<blockquote><pre><ins>template &lt;class... UTypes&gt;
  requires AllLiteral&lt;Types...&gt;
        &amp;&amp; Constructible&lt;Types, UTypes&gt;...
  tuple(tuple&lt;UTypes...&gt;);</ins>

template &lt;class... UTypes&gt;
  requires <ins>!AllLiteral&lt;Types...&gt;</ins>
        <ins>&amp;&amp;</ins> Constructible&lt;Types, const UTypes&amp;&gt;...
  tuple(const tuple&lt;UTypes...&gt;&amp;);
</pre></blockquote>

</blockquote>

<p>
Update the same signatures in 20.4.2.1 [tuple.cnstr], paras 3 and 5.
</p>





<hr>
<h3><a name="1117"></a>1117. tuple copy constructor</h3>
<p><b>Section:</b> 20.4.2.1 [tuple.cnstr] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-05-23 <b>Last modified:</b> 2010-11-20</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#tuple.cnstr">issues</a> in [tuple.cnstr].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The copy constructor for the <tt>tuple</tt> template is constrained.  This seems an
unusual strategy, as the copy constructor will be implicitly deleted if the
constraints are not met.  This is exactly the same effect as requesting an
<tt>=default;</tt> constructor.  The advantage of the latter is that it retains
triviality, and provides support for <tt>tuple</tt>s as literal types if issue
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1116">1116</a> is also accepted.
</p>
<p>
Actually, it might be worth checking with core if a constrained copy
constructor is treated as a constructor template, and as such does not
suppress the implicit generation of the copy constructor which would hide
the template in this case.
</p>

<p><i>[
2009-05-27 Daniel adds:
]</i></p>


<blockquote>
This would solve one half of the suggested changes in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#801">801</a>.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
<del>NAD Editorial</del><ins>Resolved</ins>.  Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2994.htm">N2994</a>.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 20.4.2 [tuple.tuple] and 20.4.2.1 [tuple.cnstr] p4:
</p>

<blockquote><pre><del>requires CopyConstructible&lt;Types&gt;...</del> tuple(const tuple&amp;)<ins> = default</ins>;
</pre></blockquote>





<hr>
<h3><a name="1118"></a>1118. tuple query APIs do not support cv-qualification</h3>
<p><b>Section:</b> 20.4.2.5 [tuple.helper] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-05-23 <b>Last modified:</b> 2010-11-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#tuple.helper">issues</a> in [tuple.helper].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The APIs <tt>tuple_size</tt> and <tt>tuple_element</tt> do not support
cv-qualified <tt>tuple</tt>s, <tt>pair</tt>s or <tt>array</tt>s.
</p>
<p>
The most generic solution would be to supply partial specializations once
for each cv-type in the <tt>tuple</tt> header.  However, requiring this header for
cv-qualified <tt>pair</tt>s/<tt>array</tt>s seems unhelpful.  The BSI editorial
suggestion (UK-198/US-69,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2533.html">N2533</a>)
to merge <tt>tuple</tt> into <tt>&lt;utility&gt;</tt> would help with <tt>pair</tt>,
but not <tt>array</tt>.  That might be resolved by making a dependency between the
<tt>&lt;array&gt;</tt> header and <tt>&lt;utility&gt;</tt>, or simply recognising
the dependency be fulfilled in a Remark.
</p>

<p><i>[
2009-05-24 Daniel adds:
]</i></p>


<blockquote>
<p>
All <tt>tuple_size</tt> templates with a base class need to derive publicly, e.g.
</p>

<blockquote><pre>template &lt;IdentityOf T&gt; class tuple_size&lt; const T &gt; :
   <ins>public</ins> tuple_size&lt;T&gt; {};
</pre></blockquote>

<p>
The same applies to the tuple_element class hierarchies.
</p>
<p>
What is actually meant with the comment
</p>
<blockquote>
this solution relies on 'metafunction forwarding' to inherit the
nested typename type
</blockquote>
<p>
?
</p>
<p>
I ask, because all base classes are currently unconstrained and their
instantiation is invalid in the constrained context of the <tt>tuple_element</tt> partial
template specializations.
</p>
</blockquote>

<p><i>[
2009-05-24 Alisdair adds:
]</i></p>


<blockquote>
<p>
I think a better solution might be to ask Pete editorially to change all
declarations of tupling APIs to use the struct specifier instead of class.
</p>
<p>
"metafunction forwarding" refers to the MPL metafunction protocol, where a
metafunction result is declared as a nested typedef with the name "type",
allowing metafunctions to be chained by means of inheritance.  It is a
neater syntax than repeatedly declaring a typedef, and inheritance syntax is
slightly nicer when it comes to additional typename keywords.
</p>
<p>
The constrained template with an unconstrained base is a good observation
though.
</p>
</blockquote>

<p><i>[
2009-10 post-Santa Cruz:
]</i></p>


<blockquote>
Move to Open, Alisdair to provide wording. Once wording is
provided, Howard will move to Review.
</blockquote>

<p><i>[
2010-03-28 Daniel deconceptified wording.
]</i></p>


<p><i>[
Post-Rapperswil - Daniel provides wording:
]</i></p>


<p>
The below given P/R reflects the discussion from the Rapperswil meeting that the wording should not constrain 
implementation freedom to realize the actual issue target. Thus the original code form was replaced by
normative words.
</p>
<p>
While preparing this wording it turned out that several <tt>tuple_size</tt> specializations as 
that of <tt>pair</tt> and <tt>array</tt> are underspecified, because the underlying type of the member 
value is not specified except that it is an integral type. For the specializations we could introduce a 
canonical one - like <tt>size_t</tt> - or we could use the same type as the specialization of the 
unqualified type uses. The following wording follows the second approach.
</p>
<p>
The wording refers to N3126.
</p>

<blockquote>
Moved to Tentatively Ready after 6 positive votes on c++std-lib.
</blockquote>

<p><i>[
Adopted at 2010-11 Batavia
]</i></p>




<p><b>Proposed resolution:</b></p>

<ol>
<li>Change 20.4.1 [tuple.general]/2, header <tt>&lt;tuple&gt;</tt> synopsis, as indicated:
<blockquote><pre>// 20.4.2.5, tuple helper classes:
template &lt;class T&gt; class tuple_size; // undefined
<ins>template &lt;class T&gt; class tuple_size&lt;const T&gt;;</ins>
<ins>template &lt;class T&gt; class tuple_size&lt;volatile T&gt;;</ins>
<ins>template &lt;class T&gt; class tuple_size&lt;const volatile T&gt;;</ins>
<ins></ins>
template &lt;class... Types&gt; class tuple_size&lt;tuple&lt;Types...&gt; &gt;;
	
template &lt;size_t I, class T&gt; class tuple_element; // undefined
<ins>template &lt;size_t I, class T&gt; class tuple_element&lt;I, const T&gt;;</ins>
<ins>template &lt;size_t I, class T&gt; class tuple_element&lt;I, volatile T&gt;;</ins>
<ins>template &lt;size_t I, class T&gt; class tuple_element&lt;I, const volatile T&gt;;</ins>
<ins></ins>
template &lt;size_t I, class... Types&gt; class tuple_element&lt;I, tuple&lt;Types...&gt; &gt;;
</pre></blockquote>
</li>
<li>Add the end of subclause 20.4.2.5 [tuple.helper] insert the following two paragraphs:
<blockquote><pre><ins>template &lt;class T&gt; class tuple_size&lt;const T&gt;;</ins>
<ins>template &lt;class T&gt; class tuple_size&lt;volatile T&gt;;</ins>
<ins>template &lt;class T&gt; class tuple_size&lt;const volatile T&gt;;</ins>
</pre><blockquote>
<ins>Let <em>TS</em> denote <tt>tuple_size&lt;T&gt;</tt> of the <em>cv</em>-unqualified type <tt>T</tt>. 
Then each of the three templates shall meet the UnaryTypeTrait requirements (20.7.1) with a BaseCharacteristic of 
<tt>integral_constant&lt;remove_cv&lt;decltype(<em>TS</em>::value)&gt;::type, <em>TS</em>::value&gt;</tt>.</ins>
</blockquote></blockquote>

<blockquote><pre><ins>template &lt;size_t I, class T&gt; class tuple_element&lt;I, const T&gt;;</ins>
<ins>template &lt;size_t I, class T&gt; class tuple_element&lt;I, volatile T&gt;;</ins>
<ins>template &lt;size_t I, class T&gt; class tuple_element&lt;I, const volatile T&gt;;</ins>
</pre><blockquote>
<ins>Let <em>TE</em> denote <tt>tuple_element&lt;I, T&gt;</tt> of the <em>cv</em>-unqualified type <tt>T</tt>. Then each of the 
three templates shall meet the TransformationTrait requirements (20.7.1) with a member typedef <tt>type</tt> that shall name the 
same type as the following type:</ins>
<ul>
<li><ins>for the first specialization, the type <tt>add_const&lt;<em>TE</em>::type&gt;::type</tt>,</ins></li>
<li><ins>for the second specialization, the type <tt>add_volatile&lt;<em>TE</em>::type&gt;::type</tt>, and</ins></li>
<li><ins>for the third specialization, the type <tt>add_cv&lt;<em>TE</em>::type&gt;::type</tt></ins></li>
</ul>
</blockquote></blockquote>
</li>
</ol>






<hr>
<h3><a name="1122"></a>1122. Ratio values should be constexpr</h3>
<p><b>Section:</b> 20.6.1 [ratio.ratio] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-05-25 <b>Last modified:</b> 2010-11-20</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#ratio.ratio">issues</a> in [ratio.ratio].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The values <tt>num</tt> and <tt>den</tt> in the <tt>ratio</tt> template
should be declared <tt>constexpr</tt>.
</p>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
<del>NAD Editorial</del><ins>Resolved</ins>.  Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2994.htm">N2994</a>.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
20.6.1 [ratio.ratio]
</p>

<blockquote><pre>namespace std {
  template &lt;intmax_t N, intmax_t D = 1&gt;
  class ratio {
  public:
    static const<ins>expr</ins> intmax_t num;
    static const<ins>expr</ins> intmax_t den;
  };
}
</pre></blockquote>






<hr>
<h3><a name="1123"></a>1123. no requirement that standard streams be flushed</h3>
<p><b>Section:</b> 27.5.2.1.6 [ios::Init] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> James Kanze <b>Opened:</b> 2009-05-14 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#ios::Init">issues</a> in [ios::Init].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
As currently formulated, the standard doesn't require that there 
is ever a flush of <tt>cout</tt>, etc.  (This implies, for example, that 
the classical hello, world program may have no output.)  In the 
current draft
(<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2798.pdf">N2798</a>),
there is a requirement that the objects 
be constructed before <tt>main</tt>, and before the dynamic 
initialization of any non-local objects defined after the 
inclusion of <tt>&lt;iostream&gt;</tt> in the same translation unit.  The only 
requirement that I can find concerning flushing, however, is in 
27.5.2.1.6 [ios::Init], where the destructor of the last 
<tt>std::ios_base::Init</tt> object flushes.  But there is, as far as I 
can see, no guarantee that such an object ever exists. 
</p>
<p>
Also, the wording in  [iostreams.objects] says that:
</p>
<blockquote>
The objects 
are constructed and the associations are established at some 
time prior to or during the first time an object of class 
<tt>ios_base::Init</tt> is constructed, and in any case before the body 
of main begins execution.
</blockquote>
<p>
In 27.5.2.1.6 [ios::Init], however, as an 
effect of the constructor, it says that
</p>
<blockquote>
If <tt>init_cnt</tt> is zero, 
the function stores the value one in <tt>init_cnt</tt>, then constructs 
and initializes the objects <tt>cin</tt>, <tt>cout</tt>, <tt>cerr</tt>, <tt>clog</tt> 
<tt>wcin</tt>, <tt>wcout</tt>, <tt>wcerr</tt>, and <tt>wclog</tt>"
</blockquote>

<p>
which seems to forbid earlier 
construction. 
</p>

<p>
(Note that with these changes, the exposition only "<tt>static 
int init_cnt</tt>" in <tt>ios_base::Init</tt> can be dropped.) 
</p>
<p>
Of course, a determined programmer can still inhibit the 
flush with things like: 
</p>
<blockquote><pre>new std::ios_base::Init ;       //  never deleted 
</pre></blockquote>
<p>
or (in a function): 
</p>
<blockquote><pre>std::ios_base::Init ensureConstruction ; 
//  ... 
exit( EXIT_SUCCESS ) ; 
</pre></blockquote>
<p>
Perhaps some words somewhere to the effect that all 
<tt>std::ios_base::Init</tt> objects should have static lifetime 
would be in order. 
</p>

<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote>
Moved to Ready.  Some editorial changes are expected (in addition to the
proposed wording) to remove <tt>init_cnt</tt> from <tt>Init</tt>.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 27.4 [iostream.objects]/2:
</p>

<blockquote>
-2- The objects are constructed and the associations are established at
some time prior to or during the first time an object of class
<tt>ios_base::Init</tt> is constructed, and in any case before the body
of main begins execution.<sup>292</sup> The objects are not destroyed
during program execution.<sup>293</sup>
<del>If a translation unit includes
<tt>&lt;iostream&gt;</tt> or explicitly constructs an
<tt>ios_base::Init</tt> object, these stream objects shall be
constructed before dynamic initialization of non-local objects defined
later in that translation unit.</del>
<ins>The results of including <tt>&lt;iostream&gt;</tt> in a translation
unit shall be as if <tt>&lt;iostream&gt;</tt> defined an instance of
<tt>ios_base::Init</tt> with static lifetime. Similarly, the entire
program shall behave as if there were at least one instance of
<tt>ios_base::Init</tt> with static lifetime.</ins>
</blockquote>

<p>
Change 27.5.2.1.6 [ios::Init]/3:
</p>

<blockquote>
<pre>Init();
</pre>
<blockquote>
-3- <i>Effects:</i> Constructs an object of class <tt>Init</tt>. 
<del>If <tt>init_cnt</tt> is zero, the function stores the value one in
<tt>init_cnt</tt>, then constructs and initializes the objects
<tt>cin</tt>, <tt>cout</tt>, <tt>cerr</tt>, <tt>clog</tt> (27.4.1),
<tt>wcin</tt>, <tt>wcout</tt>, <tt>wcerr</tt>, and <tt>wclog</tt>
(27.4.2). In any case, the function then adds one to the value stored in
<tt>init_cnt</tt>.</del>
<ins>Constructs and initializes the objects <tt>cin</tt>, <tt>cout</tt>,
<tt>cerr</tt>, <tt>clog</tt>, <tt>wcin</tt>, <tt>wcout</tt>,
<tt>wcerr</tt> and <tt>wclog</tt> if they have not already been
constructed and initialized.</ins>
</blockquote>
</blockquote>

<p>
Change 27.5.2.1.6 [ios::Init]/4:
</p>

<blockquote>
<pre>~Init();
</pre>
<blockquote>
-4- <i>Effects:</i> Destroys an object of class <tt>Init</tt>.
<del>The function subtracts one from the value stored in <tt>init_cnt</tt> and,
if the resulting stored value is one,</del>
<ins>If there are no other instances of the class still in
existance,</ins>
calls <tt>cout.flush()</tt>,
<tt>cerr.flush()</tt>, <tt>clog.flush()</tt>, <tt>wcout.flush()</tt>,
<tt>wcerr.flush()</tt>, <tt>wclog.flush()</tt>.
</blockquote>
</blockquote>






<hr>
<h3><a name="1126"></a>1126. <tt>istreambuff_iterator::equal</tt> needs a const &amp; parameter</h3>
<p><b>Section:</b> 24.6.3.5 [istreambuf.iterator::equal] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-05-28 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#istreambuf.iterator::equal">issues</a> in [istreambuf.iterator::equal].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <tt>equal</tt> member function of <tt>istreambuf_iterator</tt> is
declared <tt>const</tt>, but takes its argument by non-const reference.
</p>
<p>
This is not compatible with the <tt>operator==</tt> free function overload, which is
defined in terms of calling <tt>equal</tt> yet takes both arguments by reference to
const.
</p>

<p><i>[
The proposed wording is consistent with <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#110">110</a> with status TC1.
]</i></p>


<p><i>[
2009-11-02 Howard adds:
]</i></p>


<blockquote>
Set to Tentatively Ready after 5 positive votes on c++std-lib.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Ammend in both:<br>
24.6.3 [istreambuf.iterator]<br>
24.6.3.5 [istreambuf.iterator::equal]<br>
</p>

<blockquote><pre>bool equal(<ins>const </ins>istreambuf_iterator&amp; b) const;
</pre></blockquote>






<hr>
<h3><a name="1130"></a>1130. <tt>copy_exception</tt> name misleading</h3>
<p><b>Section:</b> 18.8.5 [propagation] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Peter Dimov <b>Opened:</b> 2009-05-13 <b>Last modified:</b> 2010-10-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#propagation">active issues</a> in [propagation].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#propagation">issues</a> in [propagation].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The naming of <tt>std::copy_exception</tt> misleads almost everyone
(experts included!) to think that it is the function that copies an
<tt>exception_ptr</tt>:
</p>

<blockquote><pre>exception_ptr p1 = current_exception();
exception_ptr p2 = copy_exception( p1 );
</pre></blockquote>

<p>
But this is not at all what it does. The above actually creates an
<tt>exception_ptr p2</tt> that contains a copy of <tt>p1</tt>, not of
the exception to which <tt>p1</tt> refers!
</p>
<p>
This is, of course, all my fault; in my defence, I used <tt>copy_exception</tt>
because I was unable to think of a better name.
</p>
<p>
But I believe that, based on what we've seen so far, <em>any</em> other name would be better.
</p>
<p>
Therefore, I propose <tt>copy_exception</tt> to be renamed to
<tt>create_exception</tt>:
</p>

<blockquote><pre>template&lt;class E&gt; exception_ptr create_exception(E e);
</pre></blockquote>

<p>
with the following explanatory paragraph after it:
</p>

<blockquote>
Creates an <tt>exception_ptr</tt> that refers to a copy of <tt>e</tt>.
</blockquote>

<p><i>[
2009-05-13 Daniel adds:
]</i></p>


<blockquote>
<p>
What about
</p>
<blockquote><pre>make_exception_ptr
</pre></blockquote>
<p>
in similarity to <tt>make_pair</tt> and <tt>make_tuple</tt>, <tt>make_error_code</tt> and
<tt>make_error_condition</tt>, or <tt>make_shared</tt>? Or, if a stronger symmetry to
<tt>current_exception</tt> is preferred:
</p>

<blockquote><pre>make_exception
</pre></blockquote>
<p>
We have not a single <tt>create_*</tt> function in the library, it was always
<tt>make_*</tt> used.
</p>
</blockquote>

<p><i>[
2009-05-13 Peter adds:
]</i></p>


<blockquote>
<tt>make_exception_ptr</tt> works for me.
</blockquote>

<p><i>[
2009-06-02 Thomas J. Gritzan adds:
]</i></p>


<blockquote>
<p>
To avoid surprises and unwanted recursion, how about making a call to
<tt>std::make_exception_ptr</tt> with an <tt>exception_ptr</tt> illegal?
</p>
<p>
It might work like this:
</p>
<blockquote><pre>template&lt;class E&gt;
exception_ptr make_exception_ptr(E e);
template&lt;&gt;
exception_ptr make_exception_ptr&lt;exception_ptr&gt;(exception_ptr e) = delete;
</pre></blockquote>
</blockquote>

<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote>
Move to Review for the time being. The subgroup thinks this is a good
idea, but doesn't want to break compatibility unnecessarily if someone
is already shipping this. Let's talk to Benjamin and PJP tomorrow to
make sure neither objects.
</blockquote>

<p><i>[
2009-11-16 Jonathan Wakely adds:
]</i></p>


<blockquote>
GCC 4.4 shipped with <tt>copy_exception</tt> but we could certainly keep that
symbol in the library (but not the headers) so it can still be found
by any apps foolishly relying on the experimental C++0x mode being ABI
stable.
</blockquote>

<p><i>[
2009-11-16 Peter adopts wording supplied by Daniel.
]</i></p>


<p><i>[
2009-11-16 Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>



<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>
Change 18.8 [support.exception]/1, header <tt>&lt;exception&gt;</tt>
synopsis as indicated:
</p>

<blockquote><pre>exception_ptr current_exception();
void rethrow_exception [[noreturn]] (exception_ptr p);
template&lt;class E&gt; exception_ptr <del>copy_exception</del><ins>make_exception_ptr</ins>(E e);
</pre></blockquote>
</li>

<li>
<p>
Change 18.8.5 [propagation]:
</p>

<blockquote>
<pre>template&lt;class E&gt; exception_ptr <del>copy_exception</del><ins>make_exception_ptr</ins>(E e);
</pre>

<blockquote>
<p>
-11- <i>Effects:</i> <ins>Creates an <tt>exception_ptr</tt> that refers
to a copy of <tt>e</tt>,</ins> as if
</p>

<blockquote><pre>try {
  throw e;
} catch(...) {
  return current_exception();
}
</pre></blockquote>

<p>...</p>
</blockquote>

</blockquote>
</li>

<li>
<p>
Change 30.6.5 [futures.promise]/7 as indicated:
</p>

<blockquote>
<i>Effects:</i> if the associated state of <tt>*this</tt> is not ready, stores an exception
object of type <tt>future_error</tt> with an error code of <tt>broken_promise</tt> as if by
<tt>this-&gt;set_exception(<del>copy_exception</del><ins>make_exception_ptr</ins>(
future_error(future_errc::broken_promise))</tt>.  Destroys ...
</blockquote>
</li>
</ol>






<hr>
<h3><a name="1131"></a>1131. C++0x does not need <tt>alignment_of</tt></h3>
<p><b>Section:</b> 20.7.4.3 [meta.unary.prop] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Niels Dekker <b>Opened:</b> 2009-06-01 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#meta.unary.prop">issues</a> in [meta.unary.prop].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <tt>alignment_of</tt> template is no longer necessary, now that the
core language will provide <tt>alignof</tt>. Scott Meyers raised this
issue at comp.std.c++,
<a href="http://groups.google.com/group/comp.std.c++/browse_thread/thread/9b020306e803f08a">C++0x: alignof vs. alignment_of</a>,
May 21, 2009.  In a reply, Daniel Krgler pointed out that
<tt>alignof</tt> was added to the working paper <i>after</i>
<tt>alignment_of</tt>. So it appears that <tt>alignment_of</tt> is only
part of the current Working Draft 
(<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2857.pdf">N2857</a>)
because it is in TR1.
</p>
<p>
Having both <tt>alignof</tt> and <tt>alignment_of</tt> would cause
unwanted confusion. In general, I think TR1 functionality should not be
brought into C++0x if it is entirely redundant with other C++0x language
or library features.
</p>

<p><i>[
2009-11-16 Chris adds:
]</i></p>


<blockquote>
<p>
I would like to suggest the following new wording for this issue, based on
recent discussions. Basically this doesn't delete <tt>alignment_of</tt>, it just
makes it clear that it is just a wrapper for <tt>alignof</tt>. This deletes the
first part of the proposed resolution, changes the second part by leaving in
<tt>alignof(T)</tt> but changing the precondition and leaves the 3rd part
unchanged.
</p>

<p>
Suggested Resolution:
</p>

<blockquote>
<p>
Change the first row of Table 44 ("Type property queries"), from Type properties
20.7.4.3 [meta.unary.prop]:
</p>

<blockquote>
<table border="1">
<caption>Table 44  Type property queries</caption>
<tbody><tr>
<td>
<tt>template &lt;class T&gt; struct alignment_of;</tt>
</td>
<td>
<tt>alignof(T)</tt>.<br>
<i>Precondition:</i> <del><tt>T</tt> shall be a complete type, a reference type,
or an array of unknown bound, but shall not be a function type or (possibly
cv-qualified) <tt>void</tt>.</del> <ins><tt>alignof(T)</tt> shall be defined</ins>
</td>
</tr>

</tbody></table>
</blockquote>

<p>
Change text in Table 51 ("Other transformations"), from Other transformations
20.7.7.6 [meta.trans.other], as follows:
</p>

<blockquote>
<table border="1">
<caption>Table 51  Other transformations</caption>
<tbody><tr><td>...<tt>aligned_storage;</tt></td>
<td>
<tt>Len</tt> shall not be zero. <tt>Align</tt> shall be equal to
<tt><del>alignment_of&lt;T&gt;::value</del> <ins>alignof(T)</ins></tt> for some
type <tt>T</tt> or to <i>default-alignment</i>.
</td>
<td>...</td>
</tr></tbody></table>
</blockquote>
</blockquote>
</blockquote>

<p><i>[
2010-01-30 Alisdair proposes that Chris' wording be moved into the proposed wording
section and tweaks it on the way.
]</i></p>


<blockquote>
<p>
Original proposed wording saved here:
</p>
<blockquote>
<p>
Remove from Header &lt;type_traits&gt; synopsis 20.7.2 [meta.type.synop]:
</p>
<blockquote><pre><del>template &lt;class T&gt; struct alignment_of;</del>
</pre></blockquote>

<p>
Remove the first row of Table 44 ("Type property queries"), from
Type properties 20.7.4.3 [meta.unary.prop]:
</p>
<blockquote>
<table border="1">
<caption>Table 44  Type property queries</caption>
<tbody><tr>
<td><del><tt>template &lt;class T&gt; struct alignment_of;</tt></del></td>
<td><del><tt>alignof(T)</tt>.</del><br>
<del><i>Precondition:</i> <tt>T</tt> shall be a complete type, a reference
type, or an array of unknown bound, but shall not be a function type or
(possibly cv-qualified) <tt>void</tt>.</del>
</td>
</tr>
</tbody></table>
</blockquote>

<p>
Change text in Table 51 ("Other transformations"), from Other
transformations 20.7.7.6 [meta.trans.other], as follows:
</p>
<blockquote>
<table border="1">
<caption>Table 51  Other transformations</caption>
<tbody><tr><td>...<tt>aligned_storage;</tt></td>
<td>
<tt>Len</tt> shall not be zero.  Align shall be equal to
<tt><del>alignment_of&lt;T&gt;::value</del> <ins>alignof(T)</ins></tt> for some
type <tt>T</tt> or to <i>default-alignment</i>.
</td>
<td>...</td>
</tr></tbody></table>
</blockquote>
</blockquote>
</blockquote>

<p><i>[
2010-01-30 Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>




<p><b>Proposed resolution:</b></p>

<p>
Change the first row of Table 43 ("Type property queries"), from Type properties
20.7.4.3 [meta.unary.prop]:
</p>

<blockquote>
<table border="1">
<caption>Table 43  Type property queries</caption>
<tbody><tr>
<td>
<tt>template &lt;class T&gt; struct alignment_of;</tt>
</td>
<td>
<tt>alignof(T)</tt>.<br>
<i>Precondition:</i> <del><tt>T</tt> shall be a complete type, a reference type,
or an array of unknown bound, but shall not be a function type or (possibly
cv-qualified) <tt>void</tt>.</del> <ins><tt>alignof(T)</tt> is a valid
expression (5.3.6 [expr.alignof])</ins>
</td>
</tr>

</tbody></table>
</blockquote>

<p>
Change text in Table 51 ("Other transformations"), from Other transformations
20.7.7.6 [meta.trans.other], as follows:
</p>

<blockquote>
<table border="1">
<caption>Table 51  Other transformations</caption>
<tbody><tr><td>...<tt>aligned_storage;</tt></td>
<td>
<tt>Len</tt> shall not be zero. <tt>Align</tt> shall be equal to
<tt><del>alignment_of&lt;T&gt;::value</del> <ins>alignof(T)</ins></tt> for some
type <tt>T</tt> or to <i>default-alignment</i>.
</td>
<td>...</td>
</tr></tbody></table>
</blockquote>






<hr>
<h3><a name="1133"></a>1133. Does N2844 break current specification of list::splice?</h3>
<p><b>Section:</b> 23.3.3.5 [forwardlist.ops], 23.3.4.4 [list.ops] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-05-09 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#forwardlist.ops">issues</a> in [forwardlist.ops].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
IIUC,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2844.html">N2844</a>
means that lvalues will no longer bind to rvalue references.
Therefore, the current specification of <tt>list::splice</tt> (list
operations 23.3.4.4 [list.ops]) will be a breaking change of behaviour for existing
programs.  That is because we changed the signature to swallow via an rvalue
reference rather than the lvalue reference used in 03.
</p>
<p>
Retaining this form would be safer, requiring an explicit move when splicing
from lvalues.  However, this will break existing programs.
We have the same problem with <tt>forward_list</tt>, although without the risk of
breaking programs so here it might be viewed as a positive feature.
</p>
<p>
The problem signatures:
</p>
<blockquote><pre>void splice_after(const_iterator position, forward_list&lt;T,Alloc&gt;&amp;&amp; x);
void splice_after(const_iterator position, forward_list&lt;T,Alloc&gt;&amp;&amp; x,
                  const_iterator i);
void splice_after(const_iterator position, forward_list&lt;T,Alloc&gt;&amp;&amp; x,
                  const_iterator first, const_iterator last);

void splice(const_iterator position, list&lt;T,Alloc&gt;&amp;&amp; x);
void splice(const_iterator position, list&lt;T,Alloc&gt;&amp;&amp; x,
            const_iterator i);
void splice(const_iterator position, list&lt;T,Alloc&gt;&amp;&amp; x,
            const_iterator first, const_iterator last);
</pre></blockquote>

<b>Possible resolutions:</b>

<p>
Option A.   Add an additional (non-const) lvalue-reference
overload in each case
</p>
<p>
Option B.   Change rvalue reference back to (non-const)
lvalue-reference overload in each case
</p>
<p>
Option C.   Add an additional (non-const) lvalue-reference
overload in just the <tt>std::list</tt> cases
</p>
<p>
I think (B) would be very unfortunate, I really like the <tt>forward_list</tt>
behaviour in (C) but feel (A) is needed for consistency.
</p>
<p>
My actual preference would be NAD, ship with this as a breaking change as it
is a more explicit interface.  I don't think that will fly though!
</p>

<p>
See the thread starting with c++std-lib-23725 for more discussion.
</p>

<p><i>[
2009-10-27 Christopher Jefferson provides proposed wording for Option C.
]</i></p>


<p><i>[
2009-12-08 Jonathan Wakely adds:
]</i></p>


<blockquote>
<p>
As Bill Plauger pointed out, <tt>list::merge</tt> needs similar treatment.
</p>
<p><i>[
Wording updated.
]</i></p>

</blockquote>

<p><i>[
2009-12-13 Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
In 23.3.4 [list]
</p>

<p>
Add lvalue overloads before rvalue ones:
</p>

<blockquote><pre><ins>void splice(const_iterator position, list&lt;T,Allocator&gt;&amp; x);</ins>
void splice(const_iterator position, list&lt;T,Allocator&gt;&amp;&amp; x);
<ins>void splice(const_iterator position, list&lt;T,Allocator&gt;&amp; x, const_iterator i);</ins>
void splice(const_iterator position, list&lt;T,Allocator&gt;&amp;&amp; x, const_iterator i);
<ins>void splice(const_iterator position, list&lt;T,Allocator&gt;&amp; x,
            const_iterator first, const_iterator last);</ins>
void splice(const_iterator position, list&lt;T,Allocator&gt;&amp;&amp; x,
            const_iterator first, const_iterator last);
<ins>void merge(list&lt;T,Allocator&gt;&amp; x);
template &lt;class Compare&gt; void merge(list&lt;T,Allocator&gt;&amp; x, Compare comp);</ins>
void merge(list&lt;T,Allocator&gt;&amp;&amp; x);
template &lt;class Compare&gt; void merge(list&lt;T,Allocator&gt;&amp;&amp; x, Compare comp);

</pre></blockquote>

<p>
In 23.3.4.4 [list.ops], similarly add lvalue overload before each rvalue one:
</p>
<p>
(After paragraph 2)
</p>

<blockquote><pre><ins>void splice(const_iterator position, list&lt;T,Allocator&gt;&amp; x);</ins>
void splice(const_iterator position, list&lt;T,Allocator&gt;&amp;&amp; x);
</pre></blockquote>

<p>
(After paragraph 6)
</p>

<blockquote><pre><ins>void splice(const_iterator position, list&lt;T,Allocator&gt;&amp; x, const_iterator i);</ins>
void splice(const_iterator position, list&lt;T,Allocator&gt;&amp;&amp; x, <ins>const_</ins>iterator i);
</pre></blockquote>

<p>
(After paragraph 10)
</p>

<blockquote><pre><ins>void splice(const_iterator position, list&lt;T,Allocator&gt;&amp; x,
            const_iterator first, const_iterator last);</ins>
void splice(const_iterator position, list&lt;T,Allocator&gt;&amp;&amp; x,
            <ins>const_</ins>iterator first, <ins>const_</ins>iterator last);
</pre></blockquote>

<p>
In 23.3.4.4 [list.ops], after paragraph 21
</p>

<blockquote><pre><ins>void merge(list&lt;T,Allocator&gt;&amp; x);
template &lt;class Compare&gt; void merge(list&lt;T,Allocator&gt;&amp; x, Compare comp);</ins>
void merge(list&lt;T,Allocator&gt;&amp;&amp; x);
template &lt;class Compare&gt; void merge(list&lt;T,Allocator&gt;&amp;&amp; x, Compare comp);
</pre></blockquote>






<hr>
<h3><a name="1134"></a>1134. Redundant specification of stdint.h, fenv.h, tgmath.h, and maybe complex.h</h3>
<p><b>Section:</b> X [stdinth], X [fenv], 26.8 [c.math], X [cmplxh] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Robert Klarer <b>Opened:</b> 2009-05-26 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
This is probably editorial.
</p>
<p>
The following items should be removed from the draft, because they're
redundant with Annex D, and they arguably make some *.h headers
non-deprecated:
</p>
<p>
X [stdinth] (regarding <tt>&lt;stdint.h&gt;</tt>) 
</p>
<p>
X [fenv] (regarding <tt>&lt;fenv.h&gt;</tt>
</p>
<p>
Line 3 of 26.8 [c.math] (regarding <tt>&lt;tgmath.h&gt;</tt>) 
</p>
<p>
X [cmplxh] (regarding <tt>&lt;complex.h&gt;</tt>, though the note in this subclause is not redundant) 
</p>

<p><i>[
2009-06-10 Ganesh adds:
]</i></p>


<blockquote>
While searching for <tt>stdint</tt> in the CD, I found that <tt>&lt;stdint.h&gt;</tt> is also
mentioned in 3.9.1 [basic.fundamental] /5. It guess it should refer to
<tt>&lt;cstdint&gt;</tt> instead.
</blockquote>

<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote>
Real issue. Maybe just editorial, maybe not. Move to Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Remove the section X [stdinth].
</p>
<p>
Remove the section X [fenv].
</p>
<p>
Remove 26.8 [c.math], p3:
</p>

<blockquote>
<del>-3- The header <tt>&lt;tgmath.h&gt;</tt> effectively includes the headers <tt>&lt;complex.h&gt;</tt>
and <tt>&lt;math.h&gt;</tt>.</del>
</blockquote>
<p>
Remove the section X [cmplxh].
</p>





<hr>
<h3><a name="1135"></a>1135. <tt>exception_ptr</tt> should support contextual conversion to <tt>bool</tt></h3>
<p><b>Section:</b> 18.8.5 [propagation] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2007-06-06 <b>Last modified:</b> 2010-11-19</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#propagation">active issues</a> in [propagation].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#propagation">issues</a> in [propagation].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p>
As of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2857.pdf">N2857</a>
18.8.5 [propagation]/5, the implementation-defined type
<tt>exception_ptr</tt> does provide the following ways to check whether
it is a null value:
</p>
<blockquote><pre>void f(std::exception_ptr p) {
  p == nullptr;
  p == 0;
  p == exception_ptr();
}
</pre></blockquote>
<p>
This is rather cumbersome way of checking for the null value
and I suggest to require support for evaluation in a boolean
context like so:
</p>

<blockquote><pre>void g(std::exception_ptr p) {
  if (p) {}
  !p;
}
</pre></blockquote>

<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote>
Move to Ready. Note to editor: considering putting in a cross-reference
to 4 [conv], paragraph 3, which defines the phrase
"contextually converted to <tt>bool</tt>".
</blockquote>

<p><i>[
2010-03-14 Howard adds:
]</i></p>


<blockquote>
We moved
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3073.html">N3073</a>
to the formal motions page in Pittsburgh which should obsolete this issue.  I've
moved this issue to NAD Editorial, solved by N3073.
</blockquote>



<p><b>Rationale:</b></p>
<p>
Solved by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3073.html">N3073</a>.
</p>


<p><b>Proposed resolution:</b></p>
<p>
In section 18.8.5 [propagation] insert a new paragraph between p.5 and p.6:
</p>

<blockquote>
<ins>
An object <tt>e</tt> of type <tt>exception_ptr</tt> can be contextually converted to <tt>bool</tt>.
The effect shall be as if <tt>e != exception_ptr()</tt> had been evaluated in place
of <tt>e</tt>. There shall be no implicit conversion to arithmetic type, to
enumeration type or to pointer type.
</ins>
</blockquote>





<hr>
<h3><a name="1136"></a>1136. Incomplete specification of <tt>nested_exception::rethrow_nested()</tt></h3>
<p><b>Section:</b> 18.8.6 [except.nested] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2007-06-06 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#except.nested">issues</a> in [except.nested].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It was recently mentioned in a newsgroup article
<a href="http://groups.google.de/group/comp.std.c++/msg/f82022aff68edf3d">http://groups.google.de/group/comp.std.c++/msg/f82022aff68edf3d</a>
that the specification of the member function <tt>rethrow_nested()</tt> of the
class <tt>nested_exception</tt> is incomplete, specifically it remains unclear
what happens, if member <tt>nested_ptr()</tt> returns a null value. In
18.8.6 [except.nested] we find only the following paragraph related to that:
</p>
<blockquote><pre>void rethrow_nested() const; // [[noreturn]]
</pre>
<blockquote>
-4- <i>Throws:</i> the stored exception captured by this <tt>nested_exception</tt> object.
</blockquote>
</blockquote>
<p>
This is a problem, because it is possible to create an object of
<tt>nested_exception</tt> with exactly such a state, e.g.
</p>
<blockquote><pre>#include &lt;exception&gt;
#include &lt;iostream&gt;

int main() try {
  std::nested_exception e; // OK, calls current_exception() and stores it's null value
  e.rethrow_nested(); // ?
  std::cout &lt;&lt; "A" &lt;&lt; std::endl;
}
catch(...) {
  std::cout &lt;&lt; "B" &lt;&lt; std::endl;
}
</pre></blockquote>
<p>
I suggest to follow the proposal of the reporter, namely to invoke
<tt>terminate()</tt> if <tt>nested_ptr()</tt> return a null value of <tt>exception_ptr</tt> instead
of relying on the fallback position of undefined behavior. This would
be consistent to the behavior of a <tt>throw;</tt> statement when no
exception is being handled.
</p>

<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote>
Move to Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change around 18.8.6 [except.nested]/4 as indicated:
</p>
<blockquote>
<p>
-4- <i>Throws:</i> the stored exception captured by this <tt>nested_exception</tt>
object<ins>, if <tt>nested_ptr() != nullptr</tt></ins>
</p>
<p>
<ins>- <i>Remarks:</i> If <tt>nested_ptr() == nullptr</tt>, <tt>terminate()</tt>
shall be called.</ins>
</p>
</blockquote>





<hr>
<h3><a name="1137"></a>1137. Return type of <tt>conj</tt> and <tt>proj</tt></h3>
<p><b>Section:</b> 26.4.9 [cmplx.over] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Marc Steinbach <b>Opened:</b> 2009-06-11 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#cmplx.over">issues</a> in [cmplx.over].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In clause 1, the Working Draft 
(<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2857.pdf">N2857</a>)
specifies overloads of the
functions
</p>
<blockquote><pre>arg, conj, imag, norm, proj, real
</pre></blockquote>
<p>
for non-complex arithmetic types (<tt>float</tt>, <tt>double</tt>,
<tt>long double</tt>, and integers).
The only requirement (clause 2) specifies effective type promotion of arguments.
</p>
<p>
I strongly suggest to add the following requirement on the return types:
</p>
<blockquote>
All the specified overloads must return real (i.e., non-complex) values,
specifically, the nested <tt>value_type</tt> of effectively promoted arguments.
</blockquote>

<p>
(This has no effect on <tt>arg</tt>, <tt>imag</tt>, <tt>norm</tt>, <tt>real</tt>:
they are real-valued anyway.)
</p>
<p><b>Rationale:</b></p>
<p>
Mathematically, <tt>conj()</tt> and <tt>proj()</tt>, like the transcendental functions, are
complex-valued in general but map the (extended) real line to itself.
In fact, both functions act as identity on the reals.
A typical user will expect <tt>conj()</tt> and <tt>proj()</tt> to preserve this essential
mathematical property in the same way as <tt>exp()</tt>, <tt>sin()</tt>, etc.
A typical use of <tt>conj()</tt>, e.g., is the generic scalar product of n-vectors:
</p>

<blockquote><pre>template&lt;typename T&gt;
inline T
scalar_product(size_t n, T const* x, T const* y) {
  T result = 0;
  for (size_t i = 0; i &lt; n; ++i)
    result += x[i] * std::conj(y[i]);
  return result;
}
</pre></blockquote>
<p>
This will work equally well for real and complex floating-point types <tt>T</tt> if
<tt>conj()</tt> returns <tt>T</tt>. It will not work with real types if <tt>conj()</tt>
returns complex values.
</p>
<p>
Instead, the implementation of <tt>scalar_product</tt> becomes either less efficient
and less useful (if a complex result is always returned), or unnecessarily
complicated (if overloaded versions with proper return types are defined).
In the second case, the real-argument overload of <tt>conj()</tt> cannot be used.
In fact, it must be avoided.
</p>
<p>
Overloaded <tt>conj()</tt> and <tt>proj()</tt> are principally needed in generic programming.
All such use cases will benefit from the proposed return type requirement,
in a similar way as the <tt>scalar_product</tt> example.
The requirement will not harm use cases where a complex return value
is expected, because of implicit conversion to complex.
Without the proposed return type guarantee, I find overloaded versions
of <tt>conj()</tt> and <tt>proj()</tt> not only useless but actually troublesome.
</p>


<p><i>[
2009-11-11 Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
Insert a new paragraph after 26.4.9 [cmplx.over]/2:
</p>

<blockquote>
<ins>
All of the specified overloads shall have a return type which is the nested <tt>value_type</tt> of
the effectively cast arguments.
</ins>
</blockquote>





<hr>
<h3><a name="1138"></a>1138. unusual return value for operator+</h3>
<p><b>Section:</b> 21.4.8.1 [string::op+] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-06-12 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Many of the <tt>basic_string operator+</tt> overloads return an rvalue-reference.  Is
that really intended?
</p>
<p>
I'm considering it might be a mild performance tweak to avoid making
un-necessary copies of a cheaply movable type, but it opens risk to dangling
references in code like:
</p>

<blockquote><pre>auto &amp;&amp; s = string{"x"} + string{y};
</pre></blockquote>

<p>
and I'm not sure about:
</p>

<blockquote><pre>auto s = string{"x"} + string{y};
</pre></blockquote>

<p><i>[
2009-10-11 Howard updated <i>Returns:</i> clause for each of these.
]</i></p>


<p><i>[
2009-11-05 Howard adds:
]</i></p>


<blockquote>
Moved to Tentatively Ready after 5 positive votes on c++std-lib.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Strike the <tt>&amp;&amp;</tt> from the return type in the following function
signatures:
</p>

<blockquote>
<p>
21.3 [string.classes] p2 Header Synopsis
</p>

<blockquote><pre>template&lt;class charT, class traits, class Allocator&gt;
  basic_string&lt;charT,traits,Allocator&gt;<del>&amp;&amp;</del>
    operator+(basic_string&lt;charT,traits,Allocator&gt;&amp;&amp; lhs,
              const basic_string&lt;charT,traits,Allocator&gt;&amp; rhs);

template&lt;class charT, class traits, class Allocator&gt;
  basic_string&lt;charT,traits,Allocator&gt;<del>&amp;&amp;</del>
    operator+(const basic_string&lt;charT,traits,Allocator&gt;&amp; lhs,
              basic_string&lt;charT,traits,Allocator&gt;&amp;&amp; rhs);

template&lt;class charT, class traits, class Allocator&gt;
  basic_string&lt;charT,traits,Allocator&gt;<del>&amp;&amp;</del>
    operator+(basic_string&lt;charT,traits,Allocator&gt;&amp;&amp; lhs,
              basic_string&lt;charT,traits,Allocator&gt;&amp;&amp; rhs);


template&lt;class charT, class traits, class Allocator&gt;
  basic_string&lt;charT,traits,Allocator&gt;<del>&amp;&amp;</del>
    operator+(const charT* lhs,
              basic_string&lt;charT,traits,Allocator&gt;&amp;&amp; rhs);

template&lt;class charT, class traits, class Allocator&gt;
  basic_string&lt;charT,traits,Allocator&gt;<del>&amp;&amp;</del>
    operator+(charT lhs, basic_string&lt;charT,traits,Allocator&gt;&amp;&amp; rhs);

template&lt;class charT, class traits, class Allocator&gt;
  basic_string&lt;charT,traits,Allocator&gt;<del>&amp;&amp;</del>
    operator+(basic_string&lt;charT,traits,Allocator&gt;&amp;&amp; lhs,
              const charT* rhs);

template&lt;class charT, class traits, class Allocator&gt;
  basic_string&lt;charT,traits,Allocator&gt;<del>&amp;&amp;</del>
    operator+(basic_string&lt;charT,traits,Allocator&gt;&amp;&amp; lhs, charT rhs);
</pre></blockquote>

<p>
21.4.8.1 [string::op+]
</p>

<blockquote><pre>template&lt;class charT, class traits, class Allocator&gt;
  basic_string&lt;charT,traits,Allocator&gt;<del>&amp;&amp;</del>
    operator+(basic_string&lt;charT,traits,Allocator&gt;&amp;&amp; lhs,
              const basic_string&lt;charT,traits,Allocator&gt;&amp; rhs);
</pre>
<blockquote>
<i>Returns:</i> <tt><ins>std::move(</ins>lhs.append(rhs)<ins>)</ins></tt>
</blockquote>
<pre>template&lt;class charT, class traits, class Allocator&gt;
  basic_string&lt;charT,traits,Allocator&gt;<del>&amp;&amp;</del>
    operator+(const basic_string&lt;charT,traits,Allocator&gt;&amp; lhs,
              basic_string&lt;charT,traits,Allocator&gt;&amp;&amp; rhs);
</pre>
<blockquote>
<i>Returns:</i> <tt><ins>std::move(</ins>rhs.insert(0, lhs)<ins>)</ins></tt>
</blockquote>
<pre>template&lt;class charT, class traits, class Allocator&gt;
  basic_string&lt;charT,traits,Allocator&gt;<del>&amp;&amp;</del>
    operator+(basic_string&lt;charT,traits,Allocator&gt;&amp;&amp; lhs,
              basic_string&lt;charT,traits,Allocator&gt;&amp;&amp; rhs);
</pre>
<blockquote>
<i>Returns:</i> <tt><ins>std::move(</ins>lhs.append(rhs)<ins>)</ins></tt> [<i>Note:</i> Or equivalently
<tt><ins>std::move(</ins>rhs.insert(0, lhs)<ins>)</ins></tt>  <i>end note</i>]
</blockquote>
<pre>template&lt;class charT, class traits, class Allocator&gt;
  basic_string&lt;charT,traits,Allocator&gt;<del>&amp;&amp;</del>
    operator+(const charT* lhs,
              basic_string&lt;charT,traits,Allocator&gt;&amp;&amp; rhs);
</pre>
<blockquote>
<i>Returns:</i> <tt><ins>std::move(</ins>rhs.insert(0, lhs)<ins>)</ins></tt>.
</blockquote>
<pre>template&lt;class charT, class traits, class Allocator&gt;
  basic_string&lt;charT,traits,Allocator&gt;<del>&amp;&amp;</del>
    operator+(charT lhs, basic_string&lt;charT,traits,Allocator&gt;&amp;&amp; rhs);
</pre>
<blockquote>
<i>Returns:</i> <tt><ins>std::move(</ins>rhs.insert(0, 1, lhs)<ins>)</ins></tt>.
</blockquote>
<pre>template&lt;class charT, class traits, class Allocator&gt;
  basic_string&lt;charT,traits,Allocator&gt;<del>&amp;&amp;</del>
    operator+(basic_string&lt;charT,traits,Allocator&gt;&amp;&amp; lhs,
              const charT* rhs);
</pre>
<blockquote>
<i>Returns:</i> <tt><ins>std::move(</ins>lhs.append(rhs)<ins>)</ins></tt>.
</blockquote>
<pre>template&lt;class charT, class traits, class Allocator&gt;
  basic_string&lt;charT,traits,Allocator&gt;<del>&amp;&amp;</del>
    operator+(basic_string&lt;charT,traits,Allocator&gt;&amp;&amp; lhs, charT rhs);
</pre>
<blockquote>
<i>Returns:</i> <tt><ins>std::move(</ins>lhs.append(1, rhs)<ins>)</ins></tt>.
</blockquote>
</blockquote>

</blockquote>






<hr>
<h3><a name="1144"></a>1144. "thread safe" is undefined</h3>
<p><b>Section:</b> 18.5 [support.start.term] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> LWG <b>Opened:</b> 2009-06-16 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#support.start.term">issues</a> in [support.start.term].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 187</b></p>

<p>
The term "thread safe" is not defined nor used in this context
anywhere else in the standard.
</p>

<p><b>Suggested action:</b></p>
<p>
Clarify the meaning of "thread safe".
</p>

<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote>
<p>
The "thread safe" language has already been change in the WP. It was
changed to "happen before", but the current WP text is still a little
incomplete: "happen before" is binary, but the current WP text only
mentions one thing.
</p>
<p>
Move to Ready.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
For the following functions in 18.5 [support.start.term].
</p>
<blockquote><pre><code>
extern "C" int at_quick_exit(void (*f)(void));
extern "C++" int at_quick_exit(void (*f)(void));
</code></pre></blockquote>

<p>
Edit paragraph 10 as follows.
The intent is
to provide the other half of the happens before relation;
to note indeterminate ordering;
and to clean up some formatting.
</p>
<blockquote><p>
<i>Effects:</i>
The <code>at_quick_exit()</code> functions
register the function pointed to by <code>f</code>
to be called without arguments when <code>quick_exit</code> is called.
It is unspecified whether a call to <code>at_quick_exit()</code>
that does not <del>happen-before</del> <ins>happen before</ins> (1.10)
<ins>all calls to <code>quick_exit</code></ins>
will succeed.
[<i>Note:</i>
the <code>at_quick_exit()</code> functions
shall not introduce a data race (17.6.4.7).
<del>exitnote</del>
<ins><i>end note</i>]</ins>
<ins>
[<i>Note:</i>
The order of registration may be indeterminate
if <code>at_quick_exit</code> was called from more than one thread.
<i>end note</i>]
</ins>
[<i>Note:</i> The <code>at_quick_exit</code> registrations
are distinct from the <code>atexit</code> registrations,
and applications may need to call both registration functions
with the same argument.
<i>end note</i>]
</p></blockquote>

<p>
For the following function.
</p>
<blockquote><pre><code>
void quick_exit [[noreturn]] (int status)
</code></pre></blockquote>

<p>
Edit paragraph 13 as follows.
The intent is to note that thread-local variables may be different.
</p>
<blockquote><p>
<i>Effects:</i>
Functions registered by calls to <code>at_quick_exit</code>
are called in the reverse order of their registration,
except that a function shall be called
after any previously registered functions
that had already been called at the time it was registered.
Objects shall not be destroyed as a result of calling <code>quick_exit</code>.
If control leaves a registered function called by <code>quick_exit</code>
because the function does not provide a handler for a thrown exception,
<code>terminate()</code> shall be called.
<ins>
[<i>Note:</i>
Functions registered by one thread may be called by any thread,
and hence should not rely on the identity of thread-storage-duration objects.
<i>end note</i>]
</ins>
After calling registered functions,
<code>quick_exit</code> shall call <code>_Exit(status)</code>.
[<i>Note:</i>
The standard file buffers are not flushed.
See: ISO C 7.20.4.4.
<i>end note</i>]
</p></blockquote>





<hr>
<h3><a name="1151"></a>1151. Behavior of the library in the presence of threads is incompletely specified</h3>
<p><b>Section:</b> 17 [library] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> LWG <b>Opened:</b> 2009-06-28 <b>Last modified:</b> 2010-11-19</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US 63</b></p>

   <p><b>Description</b></p>
        <p>The behavior of the library in the presence of threads
        is incompletely specified.</p>
        <p>For example, if thread 1 assigns to <tt>X</tt>, then writes data
        to file <tt>f</tt>, which is read by thread 2, and then accesses
        variable <tt>X</tt>, is thread 2 guaranteed to be able to see the
        value assigned to <tt>X</tt> by thread 1? In other words, does the
        write of the data "happen before" the read?</p>
        <p>Another example: does simultaneous access using <tt>operator
        at()</tt> to different characters in the same non-const string
        really introduce a data race?</p>
<p><b>Suggestion</b></p>
<p><b>Notes</b></p><p>17 SG: should go to threads group; misclassified in document
</p>

    <p>Concurrency SG: Create an issue. Hans will look into it.</p>

<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote>
Move to "Open". Hans and the rest of the concurrency working group will
study this. We can't make progress without a thorough review and a
paper.
</blockquote>

<p><i>[
2010 Pittsburgh:  Moved to NAD Editorial.  Rationale added below.
]</i></p>




<p><b>Rationale:</b></p>
<p>
Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3069.html">N3069</a>.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1152"></a>1152. expressions parsed differently than intended</h3>
<p><b>Section:</b> 22.4.2.2.2 [facet.num.put.virtuals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Seungbeom Kim <b>Opened:</b> 2009-06-27 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#facet.num.put.virtuals">issues</a> in [facet.num.put.virtuals].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In Table 73 -- Floating-point conversions, 22.4.2.2.2 [facet.num.put.virtuals], 
in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2914.pdf">N2914</a>,
we have the following entries: 
</p>
<table border="1">
<caption>Table 73  Floating-point conversions</caption>
<tbody><tr>
<th>State</th> <th><tt>stdio</tt> equivalent</th>
</tr>
<tr>
<td><tt>floatfield == ios_base::fixed | ios_base::scientific &amp;&amp; !uppercase</tt></td>
<td align="center"><tt>%a</tt></td>
</tr>

<tr>
<td><tt>floatfield == ios_base::fixed | ios_base::scientific</tt></td>
<td align="center"><tt>%A</tt></td>
</tr>
</tbody></table>

<p>
These expressions are supposed to mean: 
</p>

<blockquote><pre>floatfield == (ios_base::fixed | ios_base::scientific) &amp;&amp; !uppercase 
floatfield == (ios_base::fixed | ios_base::scientific) 
</pre></blockquote>
<p>
but technically parsed as: 
</p>
<blockquote><pre>((floatfield == ios_base::fixed) | ios_base::scientific) &amp;&amp; (!uppercase) 
((floatfield == ios_base::fixed) | ios_base::scientific) 
</pre></blockquote>
<p>
and should be corrected with additional parentheses, as shown above. 
</p>

<p><i>[
2009-10-28 Howard:
]</i></p>


<blockquote>
Moved to Tentatively Ready after 5 positive votes on c++std-lib.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change Table 83  Floating-point conversions in  22.4.2.2.2 [facet.num.put.virtuals]:
</p>

<table border="1">
<caption>Table 83  Floating-point conversions</caption>
<tbody><tr>
<th>State</th> <th><tt>stdio</tt> equivalent</th>
</tr>
<tr>
<td><tt>floatfield == <ins>(</ins>ios_base::fixed | ios_base::scientific<ins>)</ins> &amp;&amp; !uppercase</tt></td>
<td align="center"><tt>%a</tt></td>
</tr>

<tr>
<td><tt>floatfield == <ins>(</ins>ios_base::fixed | ios_base::scientific<ins>)</ins></tt></td>
<td align="center"><tt>%A</tt></td>
</tr>
</tbody></table>





<hr>
<h3><a name="1157"></a>1157. Local types can now instantiate templates</h3>
<p><b>Section:</b> 17.6.3.2.1 [namespace.std] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> LWG <b>Opened:</b> 2009-06-28 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 175</b></p>

<p><b>Description</b></p>
        <p>Local types can
        now be used to instantiate templates, but don't have
        external linkage.</p>
<p><b>Suggestion</b></p>
        <p>Remove the reference to external linkage.</p>

<p><b>Notes</b></p>
<p>We accept the proposed solution. Martin will draft an issue.</p>

<p><i>[
2009-07-28 Alisdair provided wording.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Moved to Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
17.6.3.2.1 [namespace.std]
</p>
<p>
Strike "of external linkage" in p1 and p2:
</p>

<blockquote>
<p>
-1- The behavior of a C++ program is undefined if it adds declarations or
definitions to namespace <tt>std</tt> or to a namespace within namespace <tt>std</tt>
unless otherwise specified. A program may add a concept map for any
standard library concept or a template specialization for any standard
library template to namespace <tt>std</tt> only if the declaration depends on a
user-defined type <del>of external linkage</del> and the specialization meets the
standard library requirements for the original template and is not
explicitly prohibited.<sup>179</sup>
</p>

<p>
-2- The behavior of a C++ program is undefined if it declares
</p>
<ul>
<li>
an explicit specialization of any member function of a standard library
class template, or
</li>
<li>
an explicit specialization of any member function template of a standard
library class or class template, or
</li>
<li>
an explicit or partial specialization of any member class template of a
standard library class or class template.
</li>
</ul>
<p>
A program may explicitly instantiate a template defined in the standard
library only if the declaration depends on the name of a user-defined
type <del>of external linkage</del> and the instantiation meets the standard
library requirements for the original template.
</p>
</blockquote>






<hr>
<h3><a name="1158"></a>1158. Encouragement to use monotonic clock</h3>
<p><b>Section:</b> 30.2.4 [thread.req.timing] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> LWG <b>Opened:</b> 2009-06-28 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.req.timing">issues</a> in [thread.req.timing].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 322, US 96</b></p>

<p><b>Description</b></p>
        <p>Not all systems
        can provide a monotonic clock. How are they expected to
        treat a _for function?</p>
<p><b>Suggestion</b></p>
        <p>Add at least a note explaining the intent
        for systems that do not support a monotonic clock.</p>

<p><b>Notes</b></p>
<p>Create an issue, together with UK 96. Note that the specification as is 
    already allows a non-monotonic clock due to the word should rather than 
    shall. If this wording is kept, a footnote should be added to make the 
    meaning clear.</p>

<p><i>[ 2009-06-29 Beman provided a proposed resolution. ] </i></p>

<p><i>[
2009-10-31 Howard adds:
]</i></p>


<blockquote>
Set to Tentatively Ready after 5 positive votes on c++std-lib.
</blockquote>

<p><i>[
2010-02-24 Pete moved to Open:
]</i></p>


<blockquote>
LWG 1158's proposed resolution replaces the ISO-specified normative term
"should" with "are encouraged but not required to", which presumably means the
same thing, but has no ISO normative status. The WD used the latter formulation
in quite a few non-normative places, but only three normative ones. I've changed
all the normative uses to "should".
</blockquote>

<p><i>[
2010-03-06 Beman updates wording.
]</i></p>


<p><i>[
2010 Pittsburgh:  Moved to Ready.
]</i></p>




<p><b>Proposed resolution:</b></p>

<p><i>Change Timing specifications 30.2.4 [thread.req.timing] as indicated:</i></p>

<p>
The member functions whose names end in <tt>_for</tt> take an argument that
specifies a relative time. Implementations should use a monotonic clock to
measure time for these functions.  <ins>[<i>Note:</i> Implementations are not
required to use a monotonic clock because such a clock may be unavailable.
 <i>end note</i>]</ins>
</p>






<hr>
<h3><a name="1159"></a>1159. Unclear spec for <tt>resource_deadlock_would_occur</tt></h3>
<p><b>Section:</b> 30.4.2.2.2 [thread.lock.unique.locking] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> LWG <b>Opened:</b> 2009-06-28 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.lock.unique.locking">issues</a> in [thread.lock.unique.locking].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1219">1219</a></p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 327, UK 328</b></p>

<p><b>UK 327 Description</b></p>
        <p>Not clear what
        the specification for error condition
        <tt>resource_deadlock_would_occur</tt> means. It is perfectly
        possible for this thread to own the mutex without setting
        owns to true on this specific lock object. It is also
        possible for lock operations to succeed even if the thread
        does own the mutex, if the mutex is recursive. Likewise, if
        the mutex is not recursive and the mutex has been locked
        externally, it is not always possible to know that this
        error condition should be raised, depending on the host
        operating system facilities. It is possible that 'i.e.' was
        supposed to be 'e.g.' and that suggests that recursive
        locks are not allowed. That makes sense, as the
        exposition-only member owns is boolean and not a integer to
        count recursive locks.</p>
        
<p><b>UK 327 Suggestion</b></p>
        <p>Add a precondition <tt>!owns</tt>. Change the 'i.e.'
        in the error condition to be 'e.g.' to allow for this
        condition to propogate deadlock detection by the host OS.</p>
<p><b>UK 327 Notes</b></p>
<p>Create an issue. Assigned to Lawrence Crowl. Note: not sure what try_lock 
    means for recursive locks when you are the owner. POSIX has language on 
    this, which should ideally be followed. Proposed fix is not quite right, for 
    example, try_lock should have different wording from lock.</p>

<p><b>UK 328 Description</b></p>

        <p>There is a missing precondition that <tt>owns</tt>
        is true, or an <tt>if(owns)</tt> test is missing from the effect
        clause</p>
<p><b>UK 328 Suggestion</b></p>
        <p>Add a
        precondition that <tt>owns == true</tt>. Add an error condition to
        detect a violation, rather than yield undefined behaviour.</p>
<p><b>UK 328 Notes</b></p>
<p>Handle in same issue as UK 327. Also uncertain that the proposed resolution 
    is the correct one.</p>

<p><i>[
2009-11-11 Alisdair notes that this issue is very closely related to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1219">1219</a>,
if not a dup.
]</i></p>


<p><i>[
2010-02-12 Anthony provided wording.
]</i></p>


<p><i>[
2010 Pittsburgh:
]</i></p>


<blockquote>
Wording updated and moved to Ready for Pittsburgh.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Modify 30.4.2.2.2 [thread.lock.unique.locking] p3 to say:
</p>

<blockquote>
<pre>void lock();</pre>
<blockquote>
<p>...</p>
<p>
3 <i>Throws:</i> <ins>Any exception thrown by <tt>pm-&gt;lock()</tt>.
<tt>std::system_error</tt> if an exception is required (30.2.2 [thread.req.exception]).
<tt>std::system_error</tt> with an error condition of
<tt>operation_not_permitted</tt> if <tt>pm</tt> is <tt>0</tt>.
<tt>std::system_error</tt> with an error condition of
<tt>resource_deadlock_would_occur</tt> if on entry <tt>owns</tt> is <tt>true</tt>.</ins>
<del><tt>std::system_error</tt> when the
postcondition cannot be achieved.</del>
</p>
</blockquote>
</blockquote>

<p>
Remove 30.4.2.2.2 [thread.lock.unique.locking] p4 (Error condition clause).
</p>

<p>
Modify 30.4.2.2.2 [thread.lock.unique.locking] p8 to say:
</p>

<blockquote>
<pre>bool try_lock();</pre>
<blockquote>
<p>...</p>
<p>
8 <i>Throws:</i> <ins>Any exception thrown by <tt>pm-&gt;try_lock()</tt>.
<tt>std::system_error</tt> if an exception is required (30.2.2 [thread.req.exception]).
<tt>std::system_error</tt> with an error condition of
<tt>operation_not_permitted</tt> if <tt>pm</tt> is <tt>0</tt>.
<tt>std::system_error</tt> with an error condition of
<tt>resource_deadlock_would_occur</tt> if on entry <tt>owns</tt> is <tt>true</tt>.</ins>
<del><tt>std::system_error</tt> when the
postcondition cannot be achieved.</del>
</p>
</blockquote>
</blockquote>

<p>
Remove 30.4.2.2.2 [thread.lock.unique.locking] p9 (Error condition clause).
</p>

<p>
Modify 30.4.2.2.2 [thread.lock.unique.locking] p13 to say:
</p>

<blockquote>
<pre>template &lt;class Clock, class Duration&gt;
  bool try_lock_until(const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time);</pre>
<blockquote>
<p>...</p>
<p>
13 <i>Throws:</i> <ins>Any exception thrown by <tt>pm-&gt;try_lock_until()</tt>.
<tt>std::system_error</tt> if an exception is required (30.2.2 [thread.req.exception]).
<tt>std::system_error</tt> with an error condition of
<tt>operation_not_permitted</tt> if <tt>pm</tt> is <tt>0</tt>.
<tt>std::system_error</tt> with an error condition of
<tt>resource_deadlock_would_occur</tt> if on entry <tt>owns</tt> is <tt>true</tt>.</ins>
<del><tt>std::system_error</tt> when the
postcondition cannot be achieved.</del>
</p>
</blockquote>
</blockquote>

<p>
Remove 30.4.2.2.2 [thread.lock.unique.locking] p14 (Error condition clause).
</p>

<p>
Modify 30.4.2.2.2 [thread.lock.unique.locking] p18 to say:
</p>

<blockquote>
<pre>template &lt;class Rep, class Period&gt;
  bool try_lock_for(const chrono::duration&lt;Rep, Period&gt;&amp; rel_time);</pre>
<blockquote>
<p>...</p>
<p>
18 <i>Throws:</i> <ins>Any exception thrown by <tt>pm-&gt;try_lock_for()</tt>.
<tt>std::system_error</tt> if an exception is required (30.2.2 [thread.req.exception]).
<tt>std::system_error</tt> with an error condition of
<tt>operation_not_permitted</tt> if <tt>pm</tt> is <tt>0</tt>.
<tt>std::system_error</tt> with an error condition of
<tt>resource_deadlock_would_occur</tt> if on entry <tt>owns</tt> is <tt>true</tt>.</ins>
<del><tt>std::system_error</tt> when the
postcondition cannot be achieved.</del>
</p>
</blockquote>
</blockquote>

<p>
Remove 30.4.2.2.2 [thread.lock.unique.locking] p19 (Error condition clause).
</p>






<hr>
<h3><a name="1170"></a>1170. String <i>char-like types</i> no longer PODs</h3>
<p><b>Section:</b> 21.1 [strings.general] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Beman Dawes <b>Opened:</b> 2009-06-22 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 218</b></p>

<p>Prior to the introduction of constant expressions into the library, 
<tt>basic_string</tt> elements had to be POD types, and thus had to be both trivially 
copyable and standard-layout. This ensured that they could be memcpy'ed and 
would be compatible with other libraries and languages, particularly the C 
language and its library.</p>
<p>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2349.pdf">N2349</a>,
Constant Expressions in the Standard Library Revision 2, changed the 
requirement in 21/1 from "POD type" to "literal type". That change had the 
effect of removing the trivially copyable and standard-layout requirements from 
<tt>basic_string</tt> elements.</p>
<p>This means that <tt>basic_string</tt> elements no longer are guaranteed to be 
memcpy'able, and are no longer guaranteed to be standard-layout types:</p>
<blockquote>
  <p>3.9/p2 and 3.9/p3 both make it clear that a "trivially copyable type" is 
  required for memcpy to be guaranteed to work.</p>
  <p>Literal types (3.9p12) may have a non-trivial copy assignment operator, and 
  that violates the trivially copyable requirements given in 9/p 6, bullet item 
  2. </p>
  <p>Literal types (3.9p12) have no standard-layout requirement, either.</p>
</blockquote>
<p>This situation probably arose because the wording for "Constant Expressions 
in the Standard Library" was in process at the same time the C++ POD 
deconstruction wording was in process. </p>
<p>Since trivially copyable types meet the C++0x requirements for literal types, 
and thus work with constant expressions, it seems an easy fix to revert the 
<tt>basic_string</tt> element wording to its original state.</p>

 <p><i>[
 2009-07-28 Alisdair adds:
 ]</i></p>

 
<blockquote>
When looking for any resolution for this issue, consider the definition of
"character container type" in 17.3.5 [defns.character.container].  This
does require the character type to be a POD, and this term is used in a
number of places through clause 21 and 28. This suggests the PODness
constraint remains, but is much more subtle than before.  Meanwhile, I
suspect the change from POD type to literal type was intentional with
the assumption that trivially copyable types with
non-trivial-but-constexpr constructors should serve as well.  I don't
believe the current wording offers the right guarantees for either of
the above designs.
</blockquote>

<p><i>[
2009-11-04 Howard modifies proposed wording to disallow array types as
char-like types.
]</i></p>


<p><i>[
2010-01-23 Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>




<p><b>Proposed resolution:</b></p>

<p><i>Change General 21.1 [strings.general] as indicated:</i></p>
<blockquote>
<p>This Clause describes components for manipulating sequences of any
<del>literal</del> <ins>non-array POD</ins> (3.9) type. In this Clause
such types are called <i>char-like types</i>, and objects of char-like
types are called <i>char-like objects</i> or simply
<i>characters</i>.</p>
</blockquote>






<hr>
<h3><a name="1171"></a>1171. duration types should be literal</h3>
<p><b>Section:</b> 20.11.3 [time.duration] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-07-06 <b>Last modified:</b> 2010-11-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#time.duration">issues</a> in [time.duration].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <tt>duration</tt> types in 20.11.3 [time.duration] are exactly the sort of type
that should be "literal types" in the new standard.  Likewise,
arithmetic operations on <tt>duration</tt>s should be declared <tt>constexpr</tt>.
</p>

<p><i>[
2009-09-21 Daniel adds:
]</i></p>


<blockquote>
An alternative (and possibly preferable solution for potentially
heap-allocating big_int representation types) would be to ask the core
language to allow references to <tt>const</tt> literal types as feasible
arguments for <tt>constexpr</tt> functions.
</blockquote>

<p><i>[
2009-10-30 Alisdair adds:
]</i></p>


<blockquote>
<p>
I suggest this issue moves from New to Open.
</p>

<p>
Half of this issue was dealt with in paper
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2994.html">n2994</a>
on constexpr constructors.
</p>

<p>
The other half (duration arithmetic) is on hold pending Core support for
<tt>const &amp;</tt> in <tt>constexpr</tt> functions.
</p>

</blockquote>

<p><i>[
2010-03-15 Alisdair updated wording to be consistent with
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3078.html">N3078</a>.
]</i></p>



<p><i>[
2010 Rapperswil:
]</i></p>


<blockquote>
This issue was the motivation for Core adding the facility for <tt>constexpr</tt> functions to take parameters by <tt>const &amp;</tt>.

Move to Tentatively Ready.
</blockquote>

<p><i>[
Adopted at 2010-11 Batavia.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
Add <tt>constexpr</tt> to declaration of following functions and constructors:
</p>
<p>
Modify p1 20.11 [time], and the prototype definitions in 20.11.3.5 [time.duration.nonmember], 20.11.3.6 [time.duration.comparisons],
and 20.11.3.7 [time.duration.cast]:
</p>

<blockquote>
<p>
<b>Header <tt>&lt;chrono&gt;</tt> synopsis</b>
</p>

<pre><i>// duration arithmetic</i>
template &lt;class Rep1, class Period1, class Rep2, class Period2&gt;
   typename common_type&lt;duration&lt;Rep1, Period1&gt;, duration&lt;Rep2, Period2&gt;&gt;::type
   <ins>constexpr</ins> operator+(const duration&lt;Rep1, Period1&gt;&amp; lhs, const duration&lt;Rep2, Period2&gt;&amp; rhs);
template &lt;class Rep1, class Period1, class Rep2, class Period2&gt;
   typename common_type&lt;duration&lt;Rep1, Period1&gt;, duration&lt;Rep2, Period2&gt;&gt;::type
   <ins>constexpr</ins> operator-(const duration&lt;Rep1, Period1&gt;&amp; lhs, const duration&lt;Rep2, Period2&gt;&amp; rhs);
template &lt;class Rep1, class Period, class Rep2&gt;
   duration&lt;typename common_type&lt;Rep1, Rep2&gt;::type, Period&gt;
   <ins>constexpr</ins> operator*(const duration&lt;Rep1, Period&gt;&amp; d, const Rep2&amp; s);
template &lt;class Rep1, class Period, class Rep2&gt;
   duration&lt;typename common_type&lt;Rep1, Rep2&gt;::type, Period&gt;
   <ins>constexpr</ins> operator*(const Rep1&amp; s, const duration&lt;Rep2, Period&gt;&amp; d);
template &lt;class Rep1, class Period, class Rep2&gt;
   duration&lt;typename common_type&lt;Rep1, Rep2&gt;::type, Period&gt;
   <ins>constexpr</ins> operator/(const duration&lt;Rep1, Period&gt;&amp; d, const Rep2&amp; s);
template &lt;class Rep1, class Period1, class Rep2, class Period2&gt;
   typename common_type&lt;Rep1, Rep2&gt;::type
   <ins>constexpr</ins> operator/(const duration&lt;Rep1, Period1&gt;&amp; lhs, const duration&lt;Rep2, Period2&gt;&amp; rhs);

<i>// duration comparisons</i>
template &lt;class Rep1, class Period1, class Rep2, class Period2&gt;
   <ins>constexpr</ins> bool operator==(const duration&lt;Rep1, Period1&gt;&amp; lhs, const duration&lt;Rep2, Period2&gt;&amp; rhs);
template &lt;class Rep1, class Period1, class Rep2, class Period2&gt;
   <ins>constexpr</ins> bool operator!=(const duration&lt;Rep1, Period1&gt;&amp; lhs, const duration&lt;Rep2, Period2&gt;&amp; rhs);
template &lt;class Rep1, class Period1, class Rep2, class Period2&gt;
   <ins>constexpr</ins> bool operator&lt; (const duration&lt;Rep1, Period1&gt;&amp; lhs, const duration&lt;Rep2, Period2&gt;&amp; rhs);
template &lt;class Rep1, class Period1, class Rep2, class Period2&gt;
   <ins>constexpr</ins> bool operator&lt;=(const duration&lt;Rep1, Period1&gt;&amp; lhs, const duration&lt;Rep2, Period2&gt;&amp; rhs);
template &lt;class Rep1, class Period1, class Rep2, class Period2&gt;
   <ins>constexpr</ins> bool operator&gt; (const duration&lt;Rep1, Period1&gt;&amp; lhs, const duration&lt;Rep2, Period2&gt;&amp; rhs);
template &lt;class Rep1, class Period1, class Rep2, class Period2&gt;
   <ins>constexpr</ins> bool operator&gt;=(const  duration&lt;Rep1, Period1&gt;&amp; lhs, const duration&lt;Rep2, Period2&gt;&amp; rhs);

<i>// duration_cast</i>
template &lt;class ToDuration, class Rep, class Period&gt;
   <ins>constexpr</ins> ToDuration duration_cast(const duration&lt;Rep, Period&gt;&amp; d);
</pre>

</blockquote>

<p>
Change 20.11.3 [time.duration]:
</p>

<blockquote>

<pre>template &lt;class Rep, class Period = ratio&lt;1&gt;&gt;
class duration {
  ...
public:
  ...
  <ins>constexpr</ins> duration(const duration&amp;) = default;
  ...

};
</pre>
</blockquote>
<p><i>[
Note - this edit already seems assumed by definition of the duration static members <tt>zero/min/max</tt>.
They cannot meaningfully be <tt>constexpr</tt> without this change.
]</i></p>






<hr>
<h3><a name="1174"></a>1174. type property predicates</h3>
<p><b>Section:</b> 20.7.4.3 [meta.unary.prop] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> Jason Merrill <b>Opened:</b> 2009-07-16 <b>Last modified:</b> 2010-11-20</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#meta.unary.prop">issues</a> in [meta.unary.prop].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I've been implementing compiler support for <tt>is_standard_layout</tt>, and
noticed a few nits about 20.7.4.3 [meta.unary.prop]:
</p>

<ol>
<li>
There's no trait for "trivially copyable type", which is now the
property that lets you do bitwise copying of a type, and therefore seems
useful to be able to query.  <tt>has_trivial_assign</tt> &amp;&amp;
<tt>has_trivial_copy_constructor</tt> &amp;&amp; <tt>has_trivial_destructor</tt>
is similar, but
not identical, specifically with respect to const types.
</li>
<li>
<tt>has_trivial_copy_constructor</tt> and <tt>has_trivial_assign</tt> lack the "or an
array of such a class type" language that most other traits in that
section, including <tt>has_nothrow_copy_constructor</tt> and <tt>has_nothrow_assign</tt>,
have; this seems like an oversight.
</li>
</ol>

<p><i>[
See the thread starting with c++std-lib-24420 for further discussion.
]</i></p>


<p><i>[
Addressed in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2947.html">N2947</a>.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
<del>NAD Editorial</del><ins>Resolved</ins>.  Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2984.html">N2984</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="1177"></a>1177. Improve "diagnostic required" wording</h3>
<p><b>Section:</b> 20.11.3 [time.duration] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-07-18 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#time.duration">issues</a> in [time.duration].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
"diagnostic required" has been used (by me) for code words meaning "use
<tt>enable_if</tt> to constrain templated functions.  This needs to be
improved by referring to the function signature as not participating in
the overload set, and moving this wording to a <i>Remarks</i> paragraph.
</p>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Moved to Ready.
</blockquote>

<p><i>[
2009-11-19 Pete opens:
]</i></p>


<blockquote>
<p>
Oh, and speaking of 1177, most of the changes result in rather convoluted prose.
Instead of saying
</p>

<blockquote>
A shall be B, else C
</blockquote>

<p>
it should be
</p>

<blockquote>
C if A is not B
</blockquote>

<p>
That is:
</p>

<blockquote>
<tt>Rep2</tt> shall be implicitly convertible to <tt>CR(Rep1, Rep2)</tt>, else
this signature shall not participate in overload resolution.
</blockquote>

<p>
should be
</p>

<blockquote>
This signature shall not participate in overload resolution if <tt>Rep2</tt> is
not implicitly convertible to <tt>CR(Rep1, Rep2)</tt>.
</blockquote>

<p>
That is clearer, and eliminates the false requirement that <tt>Rep2</tt> "shall
be" convertible.
</p>

</blockquote>

<p><i>[
2009-11-19 Howard adds:
]</i></p>


<blockquote>
I've updated the wording to match Pete's suggestion and included bullet 16
from <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1195">1195</a>.
</blockquote>

<p><i>[
2009-11-19 Jens adds:
]</i></p>


<blockquote>
<p>
Further wording suggestion using "unless":
</p>

<blockquote>
This signature shall not participate in overload resolution unless <tt>Rep2</tt>
is implicitly convertible to <tt>CR(Rep1, Rep2)</tt>.
</blockquote>
</blockquote>

<p><i>[
2009-11-20 Howard adds:
]</i></p>


<blockquote>
I've updated the wording to match Jens' suggestion.
</blockquote>

<p><i>[
2009-11-22 Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p><i>[
This proposed resolution addresses <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#947">947</a> and <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#974">974</a>. 
]</i></p>


<ol>
<li>
<p>
Change 20.11.3.1 [time.duration.cons] (and reorder the <i>Remarks</i>
paragraphs per 17.5.1.4 [structure.specifications]):
</p>

<blockquote>
<pre>template &lt;class Rep2&gt; 
  explicit duration(const Rep2&amp; r);
</pre>
<blockquote>
<p>
<i><del>Requires:</del> <ins>Remarks:</ins></i> <ins>This constructor shall not
participate in overload resolution unless</ins> <tt>Rep2</tt> <del>shall be</del>
<ins>is</ins> implicitly convertible to <tt>rep</tt> and
</p>
<ul>
<li>
<tt>treat_as_floating_point&lt;rep&gt;::value</tt> <del>shall be</del>
<ins>is</ins> <tt>true</tt><ins>,</ins> or
</li>
<li>
<tt>treat_as_floating_point&lt;Rep2&gt;::value</tt> <del>shall be</del>
<ins>is</ins> <tt>false</tt>.
</li>
</ul>
<p>
<del>Diagnostic required</del> [<i>Example:</i>
</p>
<blockquote><pre>duration&lt;int, milli&gt; d(3); // OK 
duration&lt;int, milli&gt; d(3.5); // error 
</pre></blockquote>

<p>
 <i>end example</i>]
</p>

<p>
<i>Effects:</i> Constructs an object of type <tt>duration</tt>.
</p>

<p>
<i>Postcondition:</i> <tt>count() == static_cast&lt;rep&gt;(r)</tt>.
</p>

</blockquote>

<pre>template &lt;class Rep2, class Period2&gt;
  duration(const duration&lt;Rep2, Period2&gt;&amp; d);
</pre>
<blockquote>
<p>
<i><del>Requires:</del> <ins>Remarks:</ins></i> <ins>This constructor shall not
participate in overload resolution unless</ins>
<tt>treat_as_floating_point&lt;rep&gt;::value</tt> <del>shall be</del>
<ins>is</ins> <tt>true</tt> or <tt>ratio_divide&lt;Period2,
period&gt;::type::den</tt> <del>shall be</del> <ins>is</ins> 1. <del>Diagnostic
required.</del> [<i>Note:</i> This requirement prevents implicit truncation
error when converting between integral-based duration types. Such a construction
could easily lead to confusion about the value of the duration.  <i>end
note</i>] [<i>Example:</i>
</p>

<blockquote><pre>duration&lt;int, milli&gt; ms(3); 
duration&lt;int, micro&gt; us = ms; // OK 
duration&lt;int, milli&gt; ms2 = us; // error 
</pre></blockquote>

<p>
 <i>end example</i>]
</p>

<p>
<i>Effects:</i> Constructs an object of type <tt>duration</tt>, constructing
<tt>rep_</tt> from
<tt>duration_cast&lt;duration&gt;(d).count()</tt>.
</p>

</blockquote>


</blockquote>
</li>

<li>
<p>
Change the following paragraphs in 20.11.3.5 [time.duration.nonmember]:
</p>

<blockquote>
<pre>template &lt;class Rep1, class Period, class Rep2&gt; 
  duration&lt;typename common_type&lt;Rep1, Rep2&gt;::type, Period&gt; 
  operator*(const duration&lt;Rep1, Period&gt;&amp; d, const Rep2&amp; s);
</pre>
<blockquote>
<i><del>Requires</del> <ins>Remarks</ins>:</i> <ins>This operator shall not
participate in overload resolution unless</ins> <tt>Rep2</tt> <del>shall
be</del> <ins>is</ins> implicitly convertible to <tt>CR(Rep1, Rep2)</tt>.
<del>Diagnostic required.</del>
</blockquote>

<pre>template &lt;class Rep1, class Period, class Rep2&gt; 
  duration&lt;typename common_type&lt;Rep1, Rep2&gt;::type, Period&gt; 
  operator*(const Rep1&amp; s, const duration&lt;Rep2, Period&gt;&amp; d);
</pre>
<blockquote>
<i><del>Requires</del> <ins>Remarks</ins>:</i> <ins>This operator shall not
participate in overload resolution unless</ins> <tt>Rep1</tt> <del>shall
be</del> <ins>is</ins> implicitly convertible to <tt>CR(Rep1, Rep2)</tt>.
<del>Diagnostic required.</del>
</blockquote>

<pre>template &lt;class Rep1, class Period, class Rep2&gt; 
  duration&lt;typename common_type&lt;Rep1, Rep2&gt;::type, Period&gt; 
  operator/(const duration&lt;Rep1, Period&gt;&amp; d, const Rep2&amp; s);
</pre>
<blockquote>
<i><del>Requires</del> <ins>Remarks</ins>:</i> <ins>This operator shall not
participate in overload resolution unless</ins> <tt>Rep2</tt> <del>shall
be</del> <ins>is</ins> implicitly convertible to <tt>CR(Rep1, Rep2)</tt> and
<tt>Rep2</tt> <del>shall not be</del> <ins>is not</ins> an instantiation of
<tt>duration</tt>. <del>Diagnostic required.</del>
</blockquote>

<pre>template &lt;class Rep1, class Period, class Rep2&gt; 
  duration&lt;typename common_type&lt;Rep1, Rep2&gt;::type, Period&gt; 
  operator%(const duration&lt;Rep1, Period&gt;&amp; d, const Rep2&amp; s);
</pre>
<blockquote>
<i><del>Requires</del> <ins>Remarks</ins>:</i> <ins>This operator shall not
participate in overload resolution unless</ins> <tt>Rep2</tt> <del>shall
be</del> <ins>is</ins> implicitly convertible to <tt>CR(Rep1, Rep2)</tt> and
<tt>Rep2</tt> <del>shall not be</del> <ins>is not</ins> an instantiation of
<tt>duration</tt>. <del>Diagnostic required.</del>
</blockquote>

</blockquote>
</li>

<li>
<p>
Change the following paragraphs in 20.11.3.7 [time.duration.cast]:
</p>

<blockquote><pre>template &lt;class ToDuration, class Rep, class Period&gt; 
  ToDuration duration_cast(const duration&lt;Rep, Period&gt;&amp; d);
</pre>

<blockquote>
<i><del>Requires</del> <ins>Remarks</ins>:</i> <ins>This function shall not
participate in overload resolution unless</ins> <tt>ToDuration</tt> <del>shall
be</del> <ins>is</ins> an instantiation of <tt>duration</tt>. <del>Diagnostic
required.</del>
</blockquote>
</blockquote>
</li>

<li>
<p>
Change 20.11.4.1 [time.point.cons]/3 as indicated:
</p>

<blockquote>
<p>
<del><i>Requires:</i> <tt>Duration2</tt> shall be implicitly convertible to <tt>duration</tt>.
Diagnostic required.</del>
</p>

<p>
<ins><i>Remarks:</i> This constructor shall not participate in overload
resolution unless <tt>Duration2</tt> is implicitly convertible to
<tt>duration</tt>.</ins>
</p>
</blockquote>

</li>

<li>
<p>
Change the following paragraphs in 20.11.4.7 [time.point.cast]:
</p>

<blockquote><pre>template &lt;class ToDuration, class Clock, class Duration&gt; 
  time_point&lt;Clock, ToDuration&gt; time_point_cast(const time_point&lt;Clock, Duration&gt;&amp; t);
</pre>

<blockquote>
<i><del>Requires</del> <ins>Remarks</ins>:</i> <ins>This function shall not
participate in overload resolution unless</ins> <tt>ToDuration</tt> <del>shall
be</del> <ins>is</ins> an instantiation of <tt>duration</tt>. <del>Diagnostic
required.</del>
</blockquote>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="1178"></a>1178. Header dependencies</h3>
<p><b>Section:</b> 17.6.4.2 [res.on.headers] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Beman Dawes <b>Opened:</b> 2009-07-18 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
See Frankfurt notes of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1001">1001</a>.
</p>


<p><b>Proposed resolution:</b></p>
<p><i>Change 17.6.4.2 [res.on.headers], Headers, paragraph 1, as indicated:</i></p>

<blockquote>

<p>
A C++ header may include other C++
headers.<del><sup>[footnote]</sup></del> <ins>A C++ header shall provide
the declarations and definitions that appear in its synopsis
(3.2 [basic.def.odr]). A C++ header shown in its synopsis as including 
other C++ headers shall provide the declarations and definitions that appear in
the synopses of those other headers.</ins>
</p>

  <p><del><sup>[footnote]</sup> C++ headers must include a C++ header that contains 
  any needed definition (3.2).</del></p>
</blockquote>






<hr>
<h3><a name="1180"></a>1180. Missing string_type member typedef in class <tt>sub_match</tt></h3>
<p><b>Section:</b> 28.9.1 [re.submatch.members] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2009-07-25 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The definition of class template <tt>sub_match</tt> is strongly dependent
on the type <tt>basic_string&lt;value_type&gt;</tt>, both in interface and effects,
but does not provide a corresponding typedef <tt>string_type</tt>, as e.g.
class <tt>match_results</tt> does, which looks like an oversight to me that
should be fixed.
</p>

<p><i>[
2009-11-15 Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>



<p><b>Proposed resolution:</b></p>

<ol>
<li>
<p>
In the class template <tt>sub_match</tt> synopsis 28.9 [re.submatch]/1
change as indicated:
</p>

<blockquote><pre>template &lt;class BidirectionalIterator&gt;
class sub_match : public std::pair&lt;BidirectionalIterator, BidirectionalIterator&gt; {
public:
  typedef typename iterator_traits&lt;BidirectionalIterator&gt;::value_type value_type;
  typedef typename iterator_traits&lt;BidirectionalIterator&gt;::difference_type difference_type;
  typedef BidirectionalIterator iterator;
  <ins>typedef basic_string&lt;value_type&gt; string_type;</ins>

  bool matched;

  difference_type length() const;
  operator <del>basic_string&lt;value_type&gt;</del><ins>string_type</ins>() const;
  <del>basic_string&lt;value_type&gt;</del><ins>string_type</ins> str() const;
  int compare(const sub_match&amp; s) const;
  int compare(const <del>basic_string&lt;value_type&gt;</del><ins>string_type</ins>&amp; s) const;
  int compare(const value_type* s) const;
};
</pre></blockquote>
</li>

<li>
<p>
In 28.9.1 [re.submatch.members]/2 change as indicated:
</p>

<blockquote><pre>operator <del>basic_string&lt;value_type&gt;</del><ins>string_type</ins>() const;
</pre>

<blockquote>
<i>Returns:</i> <tt>matched ? <del>basic_string&lt;value_type&gt;</del>
<ins>string_type</ins>(first, second) : <del>basic_string&lt;value_type&gt;</del>
<ins>string_type</ins>()</tt>.
</blockquote>
</blockquote>
</li>

<li>
<p>
In 28.9.1 [re.submatch.members]/3 change as indicated:
</p>

<blockquote><pre><del>basic_string&lt;value_type&gt;</del><ins>string_type</ins> str() const;
</pre>

<blockquote>
<i>Returns:</i> <tt>matched ? <del>basic_string&lt;value_type&gt;</del>
<ins>string_type</ins>(first, second) : <del>basic_string&lt;value_type&gt;</del>
<ins>string_type</ins>()</tt>.
</blockquote>
</blockquote>
</li>

<li>
<p>
In 28.9.1 [re.submatch.members]/5 change as indicated:
</p>

<blockquote><pre>int compare(const <del>basic_string&lt;value_type&gt;</del><ins>string_type</ins>&amp; s) const;
</pre></blockquote>
</li>
</ol>






<hr>
<h3><a name="1181"></a>1181. Invalid <tt>sub_match</tt> comparison operators</h3>
<p><b>Section:</b> 28.9.2 [re.submatch.op] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2009-07-25 <b>Last modified:</b> 2010-11-24</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#re.submatch.op">issues</a> in [re.submatch.op].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Several heterogeneous comparison operators of class template
<tt>sub_match</tt> are specified by return clauses that are not valid
in general. E.g. 28.9.2 [re.submatch.op]/7:
</p>

<blockquote><pre>template &lt;class BiIter, class ST, class SA&gt;
bool operator==(
  const basic_string&lt;
    typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; lhs,
  const sub_match&lt;BiIter&gt;&amp; rhs);
</pre>
<blockquote>
<i>Returns:</i> <tt>lhs == rhs.str()</tt>.
</blockquote>
</blockquote>

<p>
The returns clause would be ill-formed for all cases where
<tt>ST != std::char_traits&lt;iterator_traits&lt;BiIter&gt;::value_type&gt;</tt>
or <tt>SA != std::allocator&lt;iterator_traits&lt;BiIter&gt;::value_type&gt;</tt>.
</p>
<p>
The generic character of the comparison was intended, so
there are basically two approaches to fix the problem: The
first one would define the semantics of the comparison
using the traits class <tt>ST</tt> (The semantic of <tt>basic_string::compare</tt>
is defined in terms of the compare function of the corresponding
traits class), the second one would define the semantics of the
comparison using the traits class
</p>

<blockquote><pre>std::char_traits&lt;iterator_traits&lt;BiIter&gt;::value_type&gt;
</pre></blockquote>

<p>
which is essentially identical to
</p>

<blockquote><pre>std::char_traits&lt;sub_match&lt;BiIter&gt;::value_type&gt;
</pre></blockquote>

<p>
I suggest to follow the second approach, because
this emphasizes the central role of the <tt>sub_match</tt>
object as part of the comparison and would also
make sure that a <tt>sub_match</tt> comparison using some
<tt>basic_string&lt;char_t, ..&gt;</tt> always is equivalent to
a corresponding comparison with a string literal
because of the existence of further overloads (beginning
from 28.9.2 [re.submatch.op]/19). If users really want to
take advantage of their own <tt>traits::compare</tt>, they can
simply write a corresponding compare function that
does so.
</p>

<p><i>[
Post-Rapperswil
]</i></p>


<p>
The following update is a result of the discussion during the Rapperswil meeting, the P/R expresses all comparisons by 
delegating to sub_match's compare functions. The processing is rather mechanical: Only <tt>==</tt> and <tt>&lt;</tt>
where defined by referring to <tt>sub_match</tt>'s compare function, all remaining ones where replaced by the canonical
definitions in terms of these two.
</p>

<blockquote>
Moved to Tentatively Ready after 5 positive votes on c++std-lib.
</blockquote>

<p><i>[
Adopted at 2010-11 Batavia
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
<i>The wording refers to N3126.</i>
</p>

<ol>
<li>Change 28.9.2 [re.submatch.op]/7 as indicated:
<blockquote><pre>template &lt;class BiIter, class ST, class SA&gt;
 bool operator==(
   const basic_string&lt;
     typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; lhs,
   const sub_match&lt;BiIter&gt;&amp; rhs);
</pre>
7 <em>Returns</em>: <tt><del>lhs == rhs.str()</del><ins>rhs.compare(lhs.c_str()) == 0</ins></tt>.
</blockquote>
</li>
<li>Change 28.9.2 [re.submatch.op]/8 as indicated:
<blockquote><pre>template &lt;class BiIter, class ST, class SA&gt;
 bool operator!=(
   const basic_string&lt;
     typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; lhs,
   const sub_match&lt;BiIter&gt;&amp; rhs);
</pre>
8 <em>Returns</em>: <tt><del>lhs != rhs.str()</del><ins>!(lhs == rhs)</ins></tt>.
</blockquote>
</li>
<li>Change 28.9.2 [re.submatch.op]/9 as indicated:
<blockquote><pre>template &lt;class BiIter, class ST, class SA&gt;
 bool operator&lt;(
   const basic_string&lt;
     typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; lhs,
   const sub_match&lt;BiIter&gt;&amp; rhs);
</pre>
9 <em>Returns</em>: <tt><del>lhs &lt; rhs.str()</del><ins>rhs.compare(lhs.c_str()) &gt; 0</ins></tt>.
</blockquote>
</li>
<li>Change 28.9.2 [re.submatch.op]/10 as indicated:
<blockquote><pre>template &lt;class BiIter, class ST, class SA&gt;
 bool operator&gt;(
   const basic_string&lt;
     typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; lhs,
   const sub_match&lt;BiIter&gt;&amp; rhs);
</pre>
10 <em>Returns</em>: <tt><del>lhs &gt; rhs.str()</del><ins>rhs &lt; lhs</ins></tt>.
</blockquote>
</li>
<li>Change 28.9.2 [re.submatch.op]/11 as indicated:
<blockquote><pre>template &lt;class BiIter, class ST, class SA&gt;
 bool operator&gt;=(
   const basic_string&lt;
   typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; lhs,
 const sub_match&lt;BiIter&gt;&amp; rhs);
</pre>
11 <em>Returns</em>: <tt><del>lhs &gt;= rhs.str()</del><ins>!(lhs &lt; rhs)</ins></tt>.
</blockquote>
</li>
<li>Change 28.9.2 [re.submatch.op]/12 as indicated:
<blockquote><pre>template &lt;class BiIter, class ST, class SA&gt;
 bool operator&lt;=(
   const basic_string&lt;
     typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; lhs,
   const sub_match&lt;BiIter&gt;&amp; rhs);
</pre>
12 <em>Returns</em>: <tt><del>lhs &lt;= rhs.str()</del><ins>!(rhs &lt; lhs)</ins></tt>.
</blockquote>
</li>
<li>Change 28.9.2 [re.submatch.op]/13 as indicated:
<blockquote><pre>template &lt;class BiIter, class ST, class SA&gt;
 bool operator==(const sub_match&lt;BiIter&gt;&amp; lhs,
   const basic_string&lt;
     typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; rhs);
</pre>
13 <em>Returns</em>: <tt><del>lhs.str() == rhs</del><ins>lhs.compare(rhs.c_str()) == 0</ins></tt>.
</blockquote>
</li>
<li>Change 28.9.2 [re.submatch.op]/14 as indicated:
<blockquote><pre>template &lt;class BiIter, class ST, class SA&gt;
 bool operator!=(const sub_match&lt;BiIter&gt;&amp; lhs,
   const basic_string&lt;
     typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; rhs);
</pre>
14 <em>Returns</em>: <tt><del>lhs.str() != rhs</del><ins>!(lhs == rhs)</ins></tt>.
</blockquote>
</li>
<li>Change 28.9.2 [re.submatch.op]/15 as indicated:
<blockquote><pre>template &lt;class BiIter, class ST, class SA&gt;
 bool operator&lt;(const sub_match&lt;BiIter&gt;&amp; lhs,
   const basic_string&lt;
     typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; rhs);
</pre>
15 <em>Returns</em>: <tt><del>lhs.str() &lt; rhs</del><ins>lhs.compare(rhs.c_str()) &lt; 0</ins></tt>.
</blockquote>
</li>
<li>Change 28.9.2 [re.submatch.op]/16 as indicated:
<blockquote><pre>template &lt;class BiIter, class ST, class SA&gt;
 bool operator&gt;(const sub_match&lt;BiIter&gt;&amp; lhs,
   const basic_string&lt;
     typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; rhs);
</pre>
16 <em>Returns</em>: <tt><del>lhs.str() &gt; rhs</del><ins>rhs &lt; lhs</ins></tt>.
</blockquote>
</li>
<li>Change 28.9.2 [re.submatch.op]/17 as indicated:
<blockquote><pre>template &lt;class BiIter, class ST, class SA&gt;
 bool operator&gt;=(const sub_match&lt;BiIter&gt;&amp; lhs,
   const basic_string&lt;
     typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; rhs);
</pre>
17 <em>Returns</em>: <tt><del>lhs.str() &gt;= rhs</del><ins>!(lhs &lt; rhs)</ins></tt>.
</blockquote>
</li>
<li>Change 28.9.2 [re.submatch.op]/18 as indicated:
<blockquote><pre>template &lt;class BiIter, class ST, class SA&gt;
 bool operator&lt;=(const sub_match&lt;BiIter&gt;&amp; lhs,
   const basic_string&lt;
     typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; rhs);
</pre>
18 <em>Returns</em>: <tt><del>lhs.str() &lt;= rhs</del><ins>!(rhs &lt; lhs)</ins></tt>.
</blockquote>
</li>
<li>Change 28.9.2 [re.submatch.op]/19 as indicated:
<blockquote><pre>template &lt;class BiIter&gt;
 bool operator==(typename iterator_traits&lt;BiIter&gt;::value_type const* lhs,
   const sub_match&lt;BiIter&gt;&amp; rhs);
</pre>
19 <em>Returns</em>: <tt><del>lhs == rhs.str()</del><ins>rhs.compare(lhs) == 0</ins></tt>.
</blockquote>
</li>
<li>Change 28.9.2 [re.submatch.op]/20 as indicated:
<blockquote><pre>template &lt;class BiIter&gt;
 bool operator!=(typename iterator_traits&lt;BiIter&gt;::value_type const* lhs,
   const sub_match&lt;BiIter&gt;&amp; rhs);
</pre>
20 <em>Returns</em>: <tt><del>lhs != rhs.str()</del><ins>!(lhs == rhs)</ins></tt>.
</blockquote>
</li>
<li>Change 28.9.2 [re.submatch.op]/21 as indicated:
<blockquote><pre>template &lt;class BiIter&gt;
 bool operator&lt;(typename iterator_traits&lt;BiIter&gt;::value_type const* lhs,
   const sub_match&lt;BiIter&gt;&amp; rhs);
</pre>
21 <em>Returns</em>: <tt><del>lhs &lt; rhs.str()</del><ins>rhs.compare(lhs) &gt; 0</ins></tt>.
</blockquote>
</li>
<li>Change 28.9.2 [re.submatch.op]/22 as indicated:
<blockquote><pre>template &lt;class BiIter&gt;
 bool operator&gt;(typename iterator_traits&lt;BiIter&gt;::value_type const* lhs,
   const sub_match&lt;BiIter&gt;&amp; rhs);
</pre>
22 <em>Returns</em>: <tt><del>lhs &gt; rhs.str()</del><ins>rhs &lt; lhs</ins></tt>.
</blockquote>
</li>
<li>Change 28.9.2 [re.submatch.op]/23 as indicated:
<blockquote><pre>template &lt;class BiIter&gt;
 bool operator&gt;=(typename iterator_traits&lt;BiIter&gt;::value_type const* lhs,
   const sub_match&lt;BiIter&gt;&amp; rhs);
</pre>
23 <em>Returns</em>: <tt><del>lhs &gt;= rhs.str()</del><ins>!(lhs &lt; rhs)</ins></tt>.
</blockquote>
</li>
<li>Change 28.9.2 [re.submatch.op]/24 as indicated:
<blockquote><pre>template &lt;class BiIter&gt;
 bool operator&lt;=(typename iterator_traits&lt;BiIter&gt;::value_type const* lhs,
   const sub_match&lt;BiIter&gt;&amp; rhs);
</pre>
24 <em>Returns</em>: <tt><del>lhs &lt;= rhs.str()</del><ins>!(rhs &lt; lhs)</ins></tt>.
</blockquote>
</li>
<li>Change 28.9.2 [re.submatch.op]/25 as indicated:
<blockquote><pre>template &lt;class BiIter&gt;
 bool operator==(const sub_match&lt;BiIter&gt;&amp; lhs,
   typename iterator_traits&lt;BiIter&gt;::value_type const* rhs);
</pre>
25 <em>Returns</em>: <tt><del>lhs.str() == rhs</del><ins>lhs.compare(rhs) == 0</ins></tt>.
</blockquote>
</li>
<li>Change 28.9.2 [re.submatch.op]/26 as indicated:
<blockquote><pre>template &lt;class BiIter&gt;
 bool operator!=(const sub_match&lt;BiIter&gt;&amp; lhs,
   typename iterator_traits&lt;BiIter&gt;::value_type const* rhs);
</pre>
26 <em>Returns</em>: <tt><del>lhs.str() != rhs</del><ins>!(lhs == rhs)</ins></tt>.
</blockquote>
</li>
<li>Change 28.9.2 [re.submatch.op]/27 as indicated:
<blockquote><pre>template &lt;class BiIter&gt;
 bool operator&lt;(const sub_match&lt;BiIter&gt;&amp; lhs,
   typename iterator_traits&lt;BiIter&gt;::value_type const* rhs);
</pre>
27 <em>Returns</em>: <tt><del>lhs.str() &lt; rhs</del><ins>lhs.compare(rhs) &lt; 0</ins></tt>.
</blockquote>
</li>
<li>Change 28.9.2 [re.submatch.op]/28 as indicated:
<blockquote><pre>template &lt;class BiIter&gt;
 bool operator&gt;(const sub_match&lt;BiIter&gt;&amp; lhs,
   typename iterator_traits&lt;BiIter&gt;::value_type const* rhs);
</pre>
28 <em>Returns</em>: <tt><del>lhs.str() &gt; rhs</del><ins>rhs &lt; lhs</ins></tt>.
</blockquote>
</li>
<li>Change 28.9.2 [re.submatch.op]/29 as indicated:
<blockquote><pre>template &lt;class BiIter&gt;
 bool operator&gt;=(const sub_match&lt;BiIter&gt;&amp; lhs,
   typename iterator_traits&lt;BiIter&gt;::value_type const* rhs);
</pre>
29 <em>Returns</em>: <tt><del>lhs.str() &gt;= rhs</del><ins>!(lhs &lt; rhs)</ins></tt>.
</blockquote>
</li>
<li>Change 28.9.2 [re.submatch.op]/30 as indicated:
<blockquote><pre>template &lt;class BiIter&gt;
 bool operator&lt;=(const sub_match&lt;BiIter&gt;&amp; lhs,
   typename iterator_traits&lt;BiIter&gt;::value_type const* rhs);
</pre>
30 <em>Returns</em>: <tt><del>lhs.str() &lt;= rhs</del><ins>!(rhs &lt; lhs)</ins></tt>.
</blockquote>
</li>
<li>Change 28.9.2 [re.submatch.op]/31 as indicated:
<blockquote><pre>template &lt;class BiIter&gt;
 bool operator==(typename iterator_traits&lt;BiIter&gt;::value_type const&amp; lhs,
   const sub_match&lt;BiIter&gt;&amp; rhs);
</pre>
<del>31 <em>Returns</em>: <tt>basic_string&lt;typename iterator_traits&lt;BiIter&gt;::value_type&gt;(1,	lhs) == rhs.str()</tt>.</del><br>
<ins>31 <em>Returns</em>: <tt>rhs.compare(typename sub_match&lt;BiIter&gt;::string_type(1, lhs)) == 0</tt>.</ins>
</blockquote>
</li>
<li>Change 28.9.2 [re.submatch.op]/32 as indicated:
<blockquote><pre>template &lt;class BiIter&gt;
 bool operator!=(typename iterator_traits&lt;BiIter&gt;::value_type const&amp; lhs,
   const sub_match&lt;BiIter&gt;&amp; rhs);
</pre>
32 <em>Returns</em>: <tt><del>basic_string&lt;typename iterator_traits&lt;BiIter&gt;::value_type&gt;(1, lhs) !=
rhs.str()</del><ins>!(lhs == rhs)</ins></tt>.
</blockquote>
</li>
<li>Change 28.9.2 [re.submatch.op]/33 as indicated:
<blockquote><pre>template &lt;class BiIter&gt;
 bool operator&lt;(typename iterator_traits&lt;BiIter&gt;::value_type const&amp; lhs,
   const sub_match&lt;BiIter&gt;&amp; rhs);
</pre>
<del>33 <em>Returns</em>: <tt>basic_string&lt;typename iterator_traits&lt;BiIter&gt;::value_type&gt;(1, lhs) &lt; rhs.str()</tt>.</del><br>
<ins>33 <em>Returns</em>: <tt>rhs.compare(typename sub_match&lt;BiIter&gt;::string_type(1, lhs)) &gt; 0</tt>.</ins>
</blockquote>
</li>
<li>Change 28.9.2 [re.submatch.op]/34 as indicated:
<blockquote><pre>template &lt;class BiIter&gt;
 bool operator&gt;(typename iterator_traits&lt;BiIter&gt;::value_type const&amp; lhs,
   const sub_match&lt;BiIter&gt;&amp; rhs);
</pre>
34 <em>Returns</em>: <tt><del>basic_string&lt;typename iterator_traits&lt;BiIter&gt;::value_type&gt;(1, lhs) &gt; rhs.str()</del><ins>rhs &lt; lhs</ins></tt>.
</blockquote>
</li>
<li>Change 28.9.2 [re.submatch.op]/35 as indicated:
<blockquote><pre>template &lt;class BiIter&gt;
 bool operator&gt;=(typename iterator_traits&lt;BiIter&gt;::value_type const&amp; lhs,
   const sub_match&lt;BiIter&gt;&amp; rhs);
</pre>
35 <em>Returns</em>: <tt><del>basic_string&lt;typename iterator_traits&lt;BiIter&gt;::value_type&gt;(1, lhs) &gt;= rhs.str()</del><ins>!(lhs &lt; rhs)</ins></tt>.
</blockquote>
</li>
<li>Change 28.9.2 [re.submatch.op]/36 as indicated:
<blockquote><pre>template &lt;class BiIter&gt;
 bool operator&lt;=(typename iterator_traits&lt;BiIter&gt;::value_type const&amp; lhs,
   const sub_match&lt;BiIter&gt;&amp; rhs);
</pre>
36 <em>Returns</em>: <tt><del>basic_string&lt;typename iterator_traits&lt;BiIter&gt;::value_type&gt;(1, lhs) &lt;= rhs.str()</del><ins>!(rhs &lt; lhs)</ins></tt>.
</blockquote>
</li>
<li>Change 28.9.2 [re.submatch.op]/37 as indicated:
<blockquote><pre>template &lt;class BiIter&gt;
 bool operator==(const sub_match&lt;BiIter&gt;&amp; lhs,
   typename iterator_traits&lt;BiIter&gt;::value_type const&amp; rhs);
</pre>
<del>37 <em>Returns</em>: <tt>lhs.str() == basic_string&lt;typename iterator_traits&lt;BiIter&gt;::value_type&gt;(1, rhs)</tt>.</del><br>
<ins>37 <em>Returns</em>: <tt>lhs.compare(typename sub_match&lt;BiIter&gt;::string_type(1, rhs)) == 0</tt>.</ins>
</blockquote>
</li>
<li>Change 28.9.2 [re.submatch.op]/38 as indicated:
<blockquote><pre>template &lt;class BiIter&gt;
 bool operator!=(const sub_match&lt;BiIter&gt;&amp; lhs,
   typename iterator_traits&lt;BiIter&gt;::value_type const&amp; rhs);
</pre>
38 <em>Returns</em>: <tt><del>lhs.str() != basic_string&lt;typename iterator_traits&lt;BiIter&gt;::value_type&gt;(1, rhs)</del><ins>!(lhs == rhs)</ins></tt>.
</blockquote>
</li>
<li>Change 28.9.2 [re.submatch.op]/39 as indicated:
<blockquote><pre>template &lt;class BiIter&gt;
 bool operator&lt;(const sub_match&lt;BiIter&gt;&amp; lhs,
   typename iterator_traits&lt;BiIter&gt;::value_type const&amp; rhs);
</pre>
<del>39 <em>Returns</em>: <tt>lhs.str() &lt; basic_string&lt;typename iterator_traits&lt;BiIter&gt;::value_type&gt;(1, rhs)</tt>.</del><br>
<ins>39 <em>Returns</em>: <tt>lhs.compare(typename sub_match&lt;BiIter&gt;::string_type(1, rhs)) &lt; 0</tt>.</ins>
</blockquote>
</li>
<li>Change 28.9.2 [re.submatch.op]/40 as indicated:
<blockquote><pre>template &lt;class BiIter&gt;
 bool operator&gt;(const sub_match&lt;BiIter&gt;&amp; lhs,
   typename iterator_traits&lt;BiIter&gt;::value_type const&amp; rhs);
</pre>
40 <em>Returns</em>: <tt><del>lhs.str() &gt; basic_string&lt;typename iterator_traits&lt;BiIter&gt;::value_type&gt;(1, rhs)</del><ins>rhs &lt; lhs</ins></tt>.
</blockquote>
</li>
<li>Change 28.9.2 [re.submatch.op]/41 as indicated:
<blockquote><pre>template &lt;class BiIter&gt;
 bool operator&gt;=(const sub_match&lt;BiIter&gt;&amp; lhs,
   typename iterator_traits&lt;BiIter&gt;::value_type const&amp; rhs);
</pre>
41 <em>Returns</em>: <tt><del>lhs.str() &gt;= basic_string&lt;typename iterator_traits&lt;BiIter&gt;::value_type&gt;(1, rhs)</del><ins>!(lhs &lt; rhs)</ins></tt>.
</blockquote>
</li>
<li>Change 28.9.2 [re.submatch.op]/42 as indicated:
<blockquote><pre>template &lt;class BiIter&gt;
 bool operator&lt;=(const sub_match&lt;BiIter&gt;&amp; lhs,
   typename iterator_traits&lt;BiIter&gt;::value_type const&amp; rhs);
</pre>
42 <em>Returns</em>: <tt><del>lhs.str() &lt;= basic_string&lt;typename iterator_traits&lt;BiIter&gt;::value_type&gt;(1, rhs)</del><ins>!(rhs &lt; lhs)</ins></tt>.
</blockquote>
</li>
</ol>






<hr>
<h3><a name="1182"></a>1182. Unfortunate hash dependencies</h3>
<p><b>Section:</b> 20.8.15 [unord.hash] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-07-28 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#unord.hash">issues</a> in [unord.hash].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses UK 324</b></p>

<p>
The implied library dependencies created by spelling out all the <tt>hash</tt>
template specializations in the <tt>&lt;functional&gt;</tt> synopsis are unfortunate. 
The potential coupling is greatly reduced if the <tt>hash</tt> specialization is
declared in the appropriate header for each library type, as it is much
simpler to forward declare the primary template and provide a single
specialization than it is to implement a <tt>hash</tt> function for a <tt>string</tt> or
<tt>vector</tt> without providing a definition for the whole <tt>string/vector</tt>
template in order to access the necessary bits.
</p>

<p>
Note that the proposed resolution purely involves moving the
declarations of a few specializations, it specifically does not make any
changes to 20.8.15 [unord.hash].
</p>

<p><i>[
2009-09-15 Daniel adds:
]</i></p>


<blockquote>
</blockquote>
<p>
I suggest to add to the current existing
proposed resolution the following items.
</p>

<ul>
<li>
<p>
Add to the very first strike-list of the currently suggested resolution
the following lines:
</p>

<blockquote><pre><del>template &lt;&gt; struct hash&lt;std::error_code&gt;;</del>
<del>template &lt;&gt; struct hash&lt;std::thread::id&gt;;</del>
</pre></blockquote>
</li>

<li>
<p>
Add the following declarations to 19.5 [syserr], header
<tt>&lt;system_error&gt;</tt> synopsis after // 19.5.4:
</p>

<blockquote><pre><ins>
// 19.5.x hash support
template &lt;class T&gt; struct hash;
template &lt;&gt; struct hash&lt;error_code&gt;;
</ins>
</pre></blockquote>
</li>

<li>
<p>
Add a new clause 19.5.X (probably after 19.5.4):
</p>

<blockquote>
<p><ins>
19.5.X Hash support [syserr.hash]
</ins></p>

<pre><ins>
template &lt;&gt; struct hash&lt;error_code&gt;;
</ins></pre>

<blockquote><ins>
An explicit specialization of the class template hash (20.8.15 [unord.hash])
shall be provided
for the type <tt>error_code</tt> suitable for using this type as key in
unordered associative
containers (23.7 [unord]).
</ins></blockquote>
</blockquote>
</li>

<li>
<p>
Add the following declarations to 30.3.1.1 [thread.thread.id] just after the
declaration of
the comparison operators:
</p>

<blockquote><pre><ins>
template &lt;class T&gt; struct hash;
template &lt;&gt; struct hash&lt;thread::id&gt;;
</ins></pre></blockquote>
</li>

<li>
<p>
Add a new paragraph at the end of 30.3.1.1 [thread.thread.id]:
</p>

<blockquote>
<pre><ins>
template &lt;&gt; struct hash&lt;thread::id&gt;;
</ins></pre>

<blockquote><ins>
An explicit specialization of the class template hash (20.8.15 [unord.hash])
shall be provided
for the type <tt>thread::id</tt> suitable for using this type as key in
unordered associative
containers (23.7 [unord]).
</ins></blockquote>
</blockquote>
</li>

<li>
Issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#889">889</a> independently suggests moving the specialization
<tt>std::hash&lt;std::thread::id&gt;</tt> to header <tt>&lt;thread&gt;</tt>.
</li>
</ul>

<p><i>[
2009-11-13 Alisdair adopts Daniel's suggestion and the extended note from
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#889">889</a>.
]</i></p>


<p><i>[
2010-01-31 Alisdair: related to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1245">1245</a> and <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#978">978</a>.
]</i></p>


<p><i>[
2010-02-07 Proposed wording updated by Beman, Daniel, Alisdair and Ganesh.
]</i></p>


<p><i>[
2010-02-09 Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p><i>Strike the following specializations declared in the <tt>&lt;functional&gt;</tt> 
synopsis p2 20.8 [function.objects] </i> </p>
<blockquote>
  <pre><del>template &lt;&gt; struct hash&lt;std::string&gt;;</del>
<del>template &lt;&gt; struct hash&lt;std::u16string&gt;;</del>
<del>template &lt;&gt; struct hash&lt;std::u32string&gt;;</del>
<del>template &lt;&gt; struct hash&lt;std::wstring&gt;;</del>

<del>template &lt;&gt; struct hash&lt;std::error_code&gt;;</del>
<del>template &lt;&gt; struct hash&lt;std::thread::id&gt;;</del>
<del>template &lt;class Allocator&gt; struct hash&lt;std::vector&lt;bool, Allocator&gt; &gt;;</del>
<del>template &lt;std::size_t N&gt; struct hash&lt;std::bitset&lt;N&gt; &gt;;</del></pre>
</blockquote>
<p><i>Add the following at the end of 20.8.15 [unord.hash]:</i></p>
<blockquote>
  <pre><ins>template &lt;&gt; struct hash&lt;bool&gt;;
template &lt;&gt; struct hash&lt;char&gt;;
template &lt;&gt; struct hash&lt;signed char&gt;;
template &lt;&gt; struct hash&lt;unsigned char&gt;;
template &lt;&gt; struct hash&lt;char16_t&gt;;
template &lt;&gt; struct hash&lt;char32_t&gt;;
template &lt;&gt; struct hash&lt;wchar_t&gt;;
template &lt;&gt; struct hash&lt;short&gt;;
template &lt;&gt; struct hash&lt;unsigned short&gt;;
template &lt;&gt; struct hash&lt;int&gt;;
template &lt;&gt; struct hash&lt;unsigned int&gt;;
template &lt;&gt; struct hash&lt;long&gt;;
template &lt;&gt; struct hash&lt;long long&gt;;
template &lt;&gt; struct hash&lt;unsigned long&gt;;
template &lt;&gt; struct hash&lt;unsigned long long&gt;;
template &lt;&gt; struct hash&lt;float&gt;;
template &lt;&gt; struct hash&lt;double&gt;;
template &lt;&gt; struct hash&lt;long double&gt;;
template&lt;class T&gt; struct hash&lt;T*&gt;;</ins></pre>
  <p><ins>
  Specializations meeting the requirements of class template <tt>hash</tt> 20.8.15 [unord.hash].</ins></p>
</blockquote>
<p><i>Add the following declarations to 19.5 [syserr], header <tt>&lt;system_error&gt;</tt> 
synopsis after // 19.5.4: </i> </p>
<blockquote>
  <pre><ins>// [syserr.hash] hash support
template &lt;class T&gt; struct hash;
template &lt;&gt; struct hash&lt;error_code&gt;;</ins></pre>
</blockquote>
<p><i>Add a new clause 19.5.X (probably after 19.5.4): </i> </p>
<blockquote>
  <p><ins>19.5.X Hash support [syserr.hash] </ins></p>
  <pre><ins>template &lt;&gt; struct hash&lt;error_code&gt;;</ins></pre>
    <p><ins>Specialization meeting the requirements of class template <tt>hash</tt> 20.8.15 [unord.hash].</ins></p>
</blockquote>
<p><i>Add the following declarations to the synopsis of <tt>&lt;string&gt;</tt> in 21.3 [string.classes]
</i>
</p>
<blockquote>
  <pre><ins>// [basic.string.hash] hash support
template &lt;class T&gt; struct hash;
template &lt;&gt; struct hash&lt;string&gt;;
template &lt;&gt; struct hash&lt;u16string&gt;;
template &lt;&gt; struct hash&lt;u32string&gt;;
template &lt;&gt; struct hash&lt;wstring&gt;;</ins></pre>
</blockquote>
<p><i>Add a new clause 21.4.X </i> </p>
<blockquote>
  <p><ins>21.4.X Hash support [basic.string.hash]&gt;</ins></p>
  <pre><ins>template &lt;&gt; struct hash&lt;string&gt;;
template &lt;&gt; struct hash&lt;u16string&gt;;
template &lt;&gt; struct hash&lt;u32string&gt;;
template &lt;&gt; struct hash&lt;wstring&gt;;</ins></pre>
    <p><ins>Specializations meeting the requirements of class template <tt>hash</tt> 20.8.15 [unord.hash].</ins></p>
</blockquote>
<p><i>Add the following declarations to the synopsis of <tt>&lt;vector&gt;</tt> in
23.3 [sequences]</i> </p>
<blockquote>
  <pre><ins>// 21.4.x hash support
template &lt;class T&gt; struct hash;
template &lt;class Allocator&gt; struct hash&lt;vector&lt;bool, Allocator&gt;&gt;;</ins></pre>
</blockquote>
<p><i>Add a new paragraph to the end of 23.4.2 [vector.bool] </i> </p>
<blockquote>
  <pre><ins>template &lt;class Allocator&gt; struct hash&lt;vector&lt;bool, Allocator&gt;&gt;;</ins></pre>
    <p><ins>Specialization meeting the requirements of class template <tt>hash</tt> 20.8.15 [unord.hash].</ins></p>
</blockquote>
<p><i>Add the following declarations to the synopsis of <tt>&lt;bitset&gt;</tt> in 20.5 [template.bitset] </i> </p>
<blockquote>
  <pre><ins>// [bitset.hash] hash support
template &lt;class T&gt; struct hash;
template &lt;size_t N&gt; struct hash&lt;bitset&lt;N&gt; &gt;;</ins></pre>
</blockquote>
<p><i>Add a new subclause 20.3.7.X [bitset.hash] </i> </p>
<blockquote>
  <p><ins>20.3.7.X bitset hash support [bitset.hash]</ins></p>
  <pre><ins>template &lt;size_t N&gt; struct hash&lt;bitset&lt;N&gt; &gt;;</ins></pre>
    <p><ins>Specialization meeting the requirements of class template <tt>hash</tt> 20.8.15 [unord.hash].</ins></p>
</blockquote>
<p><i>Add the following declarations to 30.3.1.1 [thread.thread.id] synopsis just after the 
declaration of the comparison operators: </i> </p>
<blockquote>
  <pre><ins>template &lt;class T&gt; struct hash;
template &lt;&gt; struct hash&lt;thread::id&gt;;</ins></pre>
</blockquote>
<p><i>Add a new paragraph at the end of 30.3.1.1 [thread.thread.id]: </i> </p>
<blockquote>
  <pre><ins>template &lt;&gt; struct hash&lt;thread::id&gt;;</ins></pre>
  <p><ins>Specialization meeting the requirements of class template <tt>hash</tt> 20.8.15 [unord.hash].</ins></p>
</blockquote>

<p><i>Change Header &lt;typeindex&gt; synopsis 20.13.1 [type.index.synopsis] as 
indicated:</i></p>
<blockquote>
<pre>namespace std {
class type_index;
  <ins>// [type.index.hash] hash support</ins>
  template &lt;class T&gt; struct hash;
  template&lt;&gt; struct hash&lt;type_index&gt;<ins>;</ins> <del> : public unary_function&lt;type_index, size_t&gt; {
    size_t operator()(type_index index) const;
  }</del>
}</pre>
</blockquote>

<p><i>Change Template specialization hash&lt;type_index&gt;  [type.index.templ]
  as indicated:</i></p>

<blockquote>

  <p>20.11.4 <del>Template specialization hash&lt;type_index&gt; [type.index.templ]</del>
  <ins>Hash support [type.index.hash]</ins></p>

  <pre><del>size_t operator()(type_index index) const;</del></pre>
  <blockquote>
    <p><del><i>Returns:</i> <tt>index.hash_code()</tt></del></p>
  </blockquote>
  
  <pre><ins>template&lt;&gt; struct hash&lt;type_index&gt;;</ins></pre>
  <p><ins>Specialization meeting the requirements of class template <tt>hash</tt> [unord.hash]. 
  For an object <tt>index</tt> of type <tt>type_index</tt>, <tt>hash&lt;type_index&gt;()(index)</tt> 
  shall evaluate to the same value as <tt>index.hash_code()</tt>.</ins></p>
  
</blockquote>






<hr>
<h3><a name="1183"></a>1183. <tt>basic_ios::set_rdbuf</tt> may break class invariants</h3>
<p><b>Section:</b> 27.5.4.2 [basic.ios.members] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2009-07-28 <b>Last modified:</b> 2010-11-24</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#basic.ios.members">issues</a> in [basic.ios.members].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The protected member function <tt>set_rdbuf</tt> had been added during the
process of adding move and swap semantics to IO classes. A relevant
property of this function is described by it's effects in
27.5.4.2 [basic.ios.members]/19:
</p>

<blockquote>
<i>Effects:</i> Associates the <tt>basic_streambuf</tt> object pointed to by sb with
this stream without calling <tt>clear()</tt>.
</blockquote>

<p>
This means that implementors of or those who derive from existing IO classes
could cause an internal state where the stream buffer could be 0, but the
IO class has the state <tt>good()</tt>. This would break several currently existing
implementations which rely on the fact that setting a stream buffer via the
currently only ways, i.e. either by calling
</p>

<blockquote><pre>void init(basic_streambuf&lt;charT,traits&gt;* sb);
</pre></blockquote>

<p>
or by calling
</p>

<blockquote><pre>basic_streambuf&lt;charT,traits&gt;* rdbuf(basic_streambuf&lt;charT,traits&gt;* sb);
</pre></blockquote>

<p>
to set <tt>rdstate()</tt> to <tt>badbit</tt>, if the buffer is 0. This has the effect that many
internal functions can simply check <tt>rdstate()</tt> instead of <tt>rdbuf()</tt> for being 0.
</p>

<p>
I therefore suggest that a requirement is added for callers of <tt>set_rdbuf</tt> to
set a non-0 value.
</p>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Moved to Open.  Martin volunteers to provide new wording, where
<tt>set_rdbuf()</tt> sets the <tt>badbit</tt> but does not cause an
exception to be thrown like a call to <tt>clear()</tt> would.
</blockquote>

<p><i>[
2009-10-20 Martin provides wording:
]</i></p>


<p>
Change 27.5.4.2 [basic.ios.members] around p. 19 as indicated:
</p>

<blockquote><pre>void set_rdbuf(basic_streambuf&lt;charT, traits&gt;* sb);
</pre>

<blockquote>
<p><del>
<i>Effects:</i> Associates the <tt>basic_streambuf</tt> object pointed
to by <tt>sb</tt> with this stream without calling <tt>clear()</tt>.
<i>Postconditions:</i> <tt>rdbuf() == sb</tt>.
</del></p>

<p><ins>
<i>Effects:</i> As if:
</ins></p>

<blockquote><pre><ins>
iostate state = rdstate();
try { rdbuf(sb); }
catch(ios_base::failure) {
   if (0 == (state &amp; ios_base::badbit))
       unsetf(badbit);
}
</ins></pre></blockquote>

<p>
<i>Throws:</i> Nothing.
</p>

</blockquote>
</blockquote>

<p><b>Rationale:</b></p>
We need to be able to call <tt>set_rdbuf()</tt> on stream objects
for which (<tt>rdbuf() == 0</tt>) holds without causing <tt>ios_base::failure</tt> to
be thrown. We also don't want <tt>badbit</tt> to be set as a result of
setting <tt>rdbuf()</tt> to 0 if it wasn't set before the call. This changed
Effects clause maintains the current behavior (as of N2914) without
requiring that <tt>sb</tt> be non-null.


<p><i>[
Post-Rapperswil
]</i></p>


<p>
Several reviewers and the submitter believe that the best solution would be to add a pre-condition that the 
buffer shall not be a null pointer value.
</p>

<blockquote>
Moved to Tentatively Ready with revised wording provided by Daniel after 5 positive votes on c++std-lib.
</blockquote>

<p><i>[
Adopted at 2010-11 Batavia
]</i></p>




<p><b>Proposed resolution:</b></p>
<ol>
<li>Add a new pre-condition just before 27.5.4.2 [basic.ios.members]/23 as indicated:
<blockquote><pre>void set_rdbuf(basic_streambuf&lt;charT, traits&gt;* sb);
</pre>
<blockquote>
<ins>?? <em>Requires</em>: <tt>sb != nullptr</tt>.</ins>
<p>
23 <em>Effects</em>: Associates the <tt>basic_streambuf</tt> object pointed to by <tt>sb</tt> with this stream without calling <tt>clear()</tt>.
</p>
<p>
24 <em>Postconditions</em>: <tt>rdbuf() == sb</tt>.
</p>
<p>
25 <em>Throws</em>: Nothing.
</p>
</blockquote></blockquote>
</li>
</ol>


<p><b>Rationale:</b></p>
We believe that setting a <tt>nullptr</tt> stream buffer can be prevented.





<hr>
<h3><a name="1187"></a>1187. std::decay</h3>
<p><b>Section:</b> 20.7.7.6 [meta.trans.other] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Jason Merrill <b>Opened:</b> 2009-08-07 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#meta.trans.other">issues</a> in [meta.trans.other].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I notice that <tt>std::decay</tt> is specified to strip the cv-quals from
anything but an array or pointer.  This seems incorrect for values of
class type, since class rvalues can have cv-qualified type (3.10 [basic.lval]/9).
</p>

<p><i>[
2009-08-09 Howard adds:
]</i></p>


<blockquote>
See the thread starting with c++std-lib-24568 for further discussion.  And
here is a convenience link to the
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2069.html">original proposal</a>.
Also see the closely related issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#705">705</a>.
</blockquote>

<p><i>[
2010 Pittsburgh:  Moved to Ready.
]</i></p>




<p><b>Proposed resolution:</b></p>

<p>
Add a note to <tt>decay</tt> in 20.7.7.6 [meta.trans.other]:
</p>

<blockquote>
[<i>Note:</i> This behavior is similar to the lvalue-to-rvalue (4.1),
array-to-pointer (4.2), and function-to-pointer (4.3) conversions
applied when an lvalue expression is used as an rvalue, but also strips
cv-qualifiers from class types in order to more closely model by-value
argument passing.  <i>end note</i>]
</blockquote>








<hr>
<h3><a name="1189"></a>1189. Awkward interface for changing the number of buckets in an unordered associative container</h3>
<p><b>Section:</b> 23.2.5 [unord.req], 23.7 [unord] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2009-08-10 <b>Last modified:</b> 2010-10-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#unord.req">active issues</a> in [unord.req].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#unord.req">issues</a> in [unord.req].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Consider a typical use case: I create an <tt>unordered_map</tt> and then start
adding elements to it one at a time. I know that it will eventually need
to store a few million elements, so, for performance reasons, I would
like to reserve enough capacity that none of the calls to <tt>insert</tt> will
trigger a rehash.
</p>

<p>
Unfortunately, the existing interface makes this awkward. The user
naturally sees the problem in terms of the number of elements, but the
interface presents it as buckets. If <tt>m</tt> is the map and <tt>n</tt> is the expected
number of elements, this operation is written <tt>m.rehash(n /
m.max_load_factor())</tt>  not very novice friendly.
</p>

<p><i>[
2009-09-30 Daniel adds:
]</i></p>


<blockquote>
I recommend to replace "<tt>resize</tt>" by a different name like
"<tt>reserve</tt>", because that would better match the intended
use-case. Rational: Any existing resize function has the on-success
post-condition that the provided size is equal to <tt>size()</tt>, which
is not satisfied for the proposal. Reserve seems to fit the purpose of
the actual renaming suggestion.
</blockquote>

<p><i>[
2009-10-28 Ganesh summarizes alternative resolutions and expresses a
strong preference for the second (and opposition to the first):
]</i></p>


<blockquote>
<ol>
<li>
<p>
In the unordered associative container requirements (23.2.5 [unord.req]),
remove the row for
rehash and replace it with:
</p>

<blockquote>
<table border="1">
<caption>Table 87  Unordered associative container requirements
(in addition to container)</caption>

<tbody><tr>
<th>Expression</th><th>Return type</th><th>Assertion/note pre-/post-condition</th>
<th>Complexity</th>
</tr>
<tr>
<td><tt>a.<del>rehash</del><ins>reserve</ins>(n)</tt></td>
<td><tt>void</tt></td>
<td>
Post: <tt>a.bucket_count &gt; <ins>max(</ins>a.size()<ins>, n)</ins>
/ a.max_load_factor()</tt><del> and <tt>a.bucket_count()
&gt;= n</tt></del>.
</td>
<td>
Average case linear in <tt>a.size()</tt>, worst case quadratic.
</td>
</tr>
</tbody></table>
</blockquote>

<p>
Make the corresponding change in the class synopses in 23.7.1 [unord.map], 23.7.2 [unord.multimap],  23.7.3 [unord.set], and 23.7.4 [unord.multiset].
</p>
</li>
<li>

<p>
In 23.2.5 [unord.req]/9, table 98, append a new row after the last one:
</p>

<blockquote>
<table border="1">
<caption>Table 87  Unordered associative container requirements
(in addition to container)</caption>

<tbody><tr>
<th>Expression</th><th>Return type</th><th>Assertion/note pre-/post-condition</th>
<th>Complexity</th>
</tr>
<tr>
<td><tt>a.rehash(n)</tt></td>
<td><tt>void</tt></td>
<td>
Post: <tt>a.bucket_count &gt; a.size()
/ a.max_load_factor()</tt> and <tt>a.bucket_count()
&gt;= n</tt>.
</td>
<td>
Average case linear in <tt>a.size()</tt>, worst case quadratic.
</td>
</tr>
<tr>
<td><ins>
<tt>a.reserve(n)</tt>
</ins></td>
<td><ins>
<tt>void</tt>
</ins></td>
<td><ins>
Same as <tt>a.rehash(ceil(n / a.max_load_factor()))</tt>
</ins></td>
<td><ins>
Average case linear in <tt>a.size()</tt>, worst case quadratic.
</ins></td>
</tr>
</tbody></table>
</blockquote>

<p>
In 23.7.1 [unord.map]/3 in the definition of class template <tt>unordered_map</tt>, in
23.7.2 [unord.multimap]/3 in the definition of class template <tt>unordered_multimap</tt>, in
23.7.3 [unord.set]/3 in the definition of class template <tt>unordered_set</tt> and in
23.7.4 [unord.multiset]/3 in the definition of class template <tt>unordered_multiset</tt>, add the
following line after member function <tt>rehash()</tt>:
</p>

<blockquote><pre>void reserve(size_type n);
</pre></blockquote>

</li>
</ol>
</blockquote>

<p><i>[
2009-10-28 Howard:
]</i></p>


<blockquote>
<p>
Moved to Tentatively Ready after 5 votes in favor of Ganesh's option 2 above.
The original proposed wording now appears here:
</p>

<blockquote>
<p>
Informally: instead of providing <tt>rehash(n)</tt> provide <tt>resize(n)</tt>, with the
semantics "make the container a good size for <tt>n</tt> elements".
</p>

<p>
In the unordered associative container requirements (23.2.5 [unord.req]),
remove the row for
rehash and replace it with:
</p>

<blockquote>
<table border="1">
<caption>Table 87  Unordered associative container requirements
(in addition to container)</caption>

<tbody><tr>
<th>Expression</th><th>Return type</th><th>Assertion/note pre-/post-condition</th>
<th>Complexity</th>
</tr>
<tr>
<td><tt>a.<del>rehash</del><ins>resize</ins>(n)</tt></td>
<td><tt>void</tt></td>
<td>
Post: <tt>a.bucket_count &gt; <ins>max(</ins>a.size()<ins>, n)</ins>
/ a.max_load_factor()</tt><del> and <tt>a.bucket_count()
&gt;= n</tt></del>.
</td>
<td>
Average case linear in <tt>a.size()</tt>, worst case quadratic.
</td>
</tr>
</tbody></table>
</blockquote>

<p>
Make the corresponding change in the class synopses in 23.7.1 [unord.map], 23.7.2 [unord.multimap],  23.7.3 [unord.set], and 23.7.4 [unord.multiset].
</p>

</blockquote>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
In 23.2.5 [unord.req]/9, table 98, append a new row after the last one:
</p>

<blockquote>
<table border="1">
<caption>Table 87  Unordered associative container requirements
(in addition to container)</caption>

<tbody><tr>
<th>Expression</th><th>Return type</th><th>Assertion/note pre-/post-condition</th>
<th>Complexity</th>
</tr>
<tr>
<td><tt>a.rehash(n)</tt></td>
<td><tt>void</tt></td>
<td>
Post: <tt>a.bucket_count &gt; a.size()
/ a.max_load_factor()</tt> and <tt>a.bucket_count()
&gt;= n</tt>.
</td>
<td>
Average case linear in <tt>a.size()</tt>, worst case quadratic.
</td>
</tr>
<tr>
<td><ins>
<tt>a.reserve(n)</tt>
</ins></td>
<td><ins>
<tt>void</tt>
</ins></td>
<td><ins>
Same as <tt>a.rehash(ceil(n / a.max_load_factor()))</tt>
</ins></td>
<td><ins>
Average case linear in <tt>a.size()</tt>, worst case quadratic.
</ins></td>
</tr>
</tbody></table>
</blockquote>

<p>
In 23.7.1 [unord.map]/3 in the definition of class template <tt>unordered_map</tt>, in
23.7.2 [unord.multimap]/3 in the definition of class template <tt>unordered_multimap</tt>, in
23.7.3 [unord.set]/3 in the definition of class template <tt>unordered_set</tt> and in
23.7.4 [unord.multiset]/3 in the definition of class template <tt>unordered_multiset</tt>, add the
following line after member function <tt>rehash()</tt>:
</p>

<blockquote><pre>void reserve(size_type n);
</pre></blockquote>





<hr>
<h3><a name="1191"></a>1191. <tt>tuple get</tt> API should respect rvalues</h3>
<p><b>Section:</b> 20.4.2.6 [tuple.elem] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-08-18 <b>Last modified:</b> 2010-11-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <tt>tuple get</tt> API should respect rvalues.  This would allow for moving a
single element out of a <tt>tuple</tt>-like type.
</p>

<p><i>[
2009-10-30 Alisdair adds:
]</i></p>


<blockquote>
<p>
The issue of rvalue overloads of get for tuple-like types was briefly
discussed in Santa Cruz.
</p>

<p>
The feedback was this would be welcome, but we need full wording for the
other types (<tt>pair</tt> and <tt>array</tt>) before advancing.
</p>

<p>
I suggest the issue moves to Open from New as it has been considered,
feedback given, and it has not (yet) been rejected as NAD.
</p>
</blockquote>


<p><i>[
2010 Rapperswil:
]</i></p>


<blockquote>
Note that wording has been provided, and this issue becomes more important now that we have added a function to support forwarding argument lists as <tt>tuple</tt>s.

Move to Tentatively Ready.
</blockquote>

<p><i>[
Adopted at 2010-11 Batavia
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
Add the following signature to p2 20.4.1 [tuple.general]
</p>

<blockquote><pre><ins>
template &lt;size_t I, class ... Types&gt;
typename tuple_element&lt;I, tuple&lt;Types...&gt; &gt;::type&amp;&amp; get(tuple&lt;Types...&gt; &amp;&amp;);
</ins></pre></blockquote>

<p>
And again to 20.4.2.6 [tuple.elem].
</p>

<blockquote><pre><ins>
template &lt;size_t I, class ... Types&gt;
typename tuple_element&lt;I, tuple&lt;Types...&gt; &gt;::type&amp;&amp; get(tuple&lt;Types...&gt;&amp;&amp; t);
</ins></pre>

<blockquote>
<p><ins>
<i>Effects:</i> Equivalent to <tt>return std::forward&lt;typename tuple_element&lt;I, tuple&lt;Types...&gt; &gt;::type&amp;&amp;&gt;(get&lt;I&gt;(t));</tt>
</ins></p>


<p><ins>
[<i>Note:</i> If a <tt>T</tt> in <tt>Types</tt> is some reference type <tt>X&amp;</tt>,
the return type is <tt>X&amp;</tt>, not <tt>X&amp;&amp;</tt>.
However, if the element type is non-reference type <tt>T</tt>,
the return type is <tt>T&amp;&amp;</tt>.  <i>end note</i>]
</ins></p>

</blockquote>
</blockquote>

<p>
Add the following signature to p1 20.3 [utility]
</p>

<blockquote><pre><ins>
template &lt;size_t I, class T1, class T2&gt;
typename tuple_element&lt;I, pair&lt;T1,T2&gt; &gt;::type&amp;&amp; get(pair&lt;T1, T2&gt;&amp;&amp;);
</ins></pre></blockquote>

<p>
And to p5 20.3.5.4 [pair.astuple]
</p>

<blockquote><pre><ins>
template &lt;size_t I, class T1, class T2&gt;
typename tuple_element&lt;I, pair&lt;T1,T2&gt; &gt;::type&amp;&amp; get(pair&lt;T1, T2&gt;&amp;&amp; p);
</ins></pre>

<blockquote>
<p><ins>
<i>Returns:</i> If <tt>I == 0</tt> returns <tt>std::forward&lt;T1&amp;&amp;&gt;(p.first)</tt>;
if <tt>I == 1</tt>
returns <tt>std::forward&lt;T2&amp;&amp;&gt;(p.second)</tt>; otherwise the program is ill-formed.
</ins></p>

<p><ins>
<i>Throws:</i> Nothing.
</ins></p>

</blockquote>

</blockquote>

<p>
Add the following signature to 23.3 [sequences] <tt>&lt;array&gt;</tt> synopsis
</p>

<blockquote><pre><ins>template &lt;size_t I, class T, size_t N&gt;
T&amp;&amp; get(array&lt;T,N&gt; &amp;&amp;);
</ins></pre></blockquote>

<p>
And after p8 23.3.1.8 [array.tuple]
</p>

<blockquote><pre><ins>template &lt;size_t I, class T, size_t N&gt;
T&amp;&amp; get(array&lt;T,N&gt; &amp;&amp; a);
</ins></pre>

<blockquote><ins>
<i>Effects:</i> Equivalent to <tt>return std::move(get&lt;I&gt;(a));</tt>
</ins></blockquote>
</blockquote>






<hr>
<h3><a name="1192"></a>1192. <tt>basic_string</tt> missing definitions for <tt>cbegin</tt> / <tt>cend</tt> / <tt>crbegin</tt> / <tt>crend</tt></h3>
<p><b>Section:</b> 21.4.3 [string.iterators] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2009-08-14 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Unlike the containers in clause 23, <tt>basic_string</tt> has definitions for
<tt>begin()</tt> and <tt>end()</tt>, but these have not been updated to include <tt>cbegin</tt>,
<tt>cend</tt>, <tt>crbegin</tt> and <tt>crend</tt>.
</p>

<p><i>[
2009-10-28 Howard:
]</i></p>


<blockquote>
Moved to Tentatively NAD after 5 positive votes on c++std-lib.  Added
rationale.
</blockquote>

<p><i>[
2009-10-28 Alisdair disagrees:
]</i></p>


<blockquote>
<p>
I'm going to have to speak up as the dissenting voice.
</p>

<p>
I agree the issue could be handled editorially, and that would be my
preference if Pete feels this is appropriate. Failing that, I really
think this issue should be accepted and moved to ready.  The other
begin/end functions all have a semantic definition for this template,
and it is confusing if a small few are missing.
</p>

<p>
I agree that an alternative would be to strike <em>all</em> the definitions for
<tt>begin/end/rbegin/rend</tt> and defer completely to the requirements tables in
clause 23.  I think that might be confusing without a forward reference
though, as those tables are defined in a *later* clause than the
basic_string template itself.  If someone wants to pursue this I would
support it, but recommend it as a separate issue.
</p>

<p>
So my preference is strongly to move Ready over NAD, and a stronger
preference for NAD Editorial if Pete is happy to make these changes.
</p>

</blockquote>

<p><i>[
2009-10-29 Howard:
]</i></p>


<blockquote>
Moved to Tentatively Ready after 5 positive votes on c++std-lib.  Removed
rationale to mark it NAD.  :-)
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add to 21.4.3 [string.iterators]
</p>

<blockquote><pre>iterator       begin();
const_iterator begin() const;
<ins>const_iterator cbegin() const;</ins>
</pre>

<p>...</p>

<pre>iterator       end();
const_iterator end() const;
<ins>const_iterator cend() const;</ins>
</pre>

<p>...</p>

<pre>reverse_iterator       rbegin();
const_reverse_iterator rbegin() const;
<ins>const_reverse_iterator crbegin() const;</ins>
</pre>

<p>...</p>

<pre>reverse_iterator       rend();
const_reverse_iterator rend() const;
<ins>const_reverse_iterator crend() const;</ins>
</pre>

</blockquote>





<hr>
<h3><a name="1193"></a>1193. <tt>default_delete</tt> cannot be instantiated with  incomplete types</h3>
<p><b>Section:</b> 20.9.9.1 [unique.ptr.dltr] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2009-08-18 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
According to the general rules of 17.6.3.8 [res.on.functions]/2 b 5 the effects
are undefined, if an incomplete type is used to instantiate a library template. But neither in
20.9.9.1 [unique.ptr.dltr] nor
in any other place of the standard such explicit allowance is given.
Since this template is intended to be instantiated with incomplete
types, this must
be fixed.
</p>

<p><i>[
2009-11-15 Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>


<p><i>[
2009-11-17 Alisdair Opens:
]</i></p>


<blockquote>
<p>
LWG 1193 tries to support unique_ptr for incomplete types.  I believe the
proposed wording goes too far:
</p>

<blockquote>
The template parameter <tt>T</tt> of <tt>default_delete</tt> may be an
incomplete type.
</blockquote>

<p>
Do we really want to support <tt>cv-void</tt>?  Suggested ammendment:
</p>

<blockquote>
The template parameter <tt>T</tt> of <tt>default_delete</tt> may be an
incomplete type <ins>other than <tt>cv-void</tt></ins>.
</blockquote>

<p>
We might also consider saying something about arrays of incomplete types.
</p>

<p>
Did we lose support for <tt>unique_ptr&lt;function-type&gt;</tt> when the
concept-enabled work was shelved?  If so, we might want a
<tt>default_delete</tt> partial specialization for function types that does
nothing.  Alternatively, function types should <em>not</em> be supported by
default, but there is no reason a user cannot support them via their own
deletion policy.
</p>

<p>
Function-type support might also lead to conditionally supporting a
function-call operator in the general case, and that seems way too inventive at
this stage to me, even if we could largely steal wording directly from
<tt>reference_wrapper</tt>.  <tt>shared_ptr</tt> would have similar problems
too.
</p>

</blockquote>

<p><i>[
2010-01-24 Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
Add two new paragraphs directly to 20.9.9.1 [unique.ptr.dltr] (before
20.9.9.1.2 [unique.ptr.dltr.dflt]) with the following
content:
</p>

<blockquote>
<p><ins>
The class template <tt>default_delete</tt> serves as the default deleter (destruction policy) for
the class template <tt>unique_ptr</tt>.
</ins></p>

<p><ins>
The template parameter <tt>T</tt> of <tt>default_delete</tt> may be an incomplete type.
</ins></p>
</blockquote>





<hr>
<h3><a name="1194"></a>1194. Unintended <tt>queue</tt> constructor</h3>
<p><b>Section:</b> 23.5 [container.adaptors] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-08-20 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#container.adaptors">issues</a> in [container.adaptors].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
23.5.1.1 [queue.defn] has the following <tt>queue</tt> constructor:
</p>

<blockquote><pre>template &lt;class Alloc&gt; explicit queue(const Alloc&amp;);
</pre></blockquote>

<p>
This will be implemented like so:
</p>

<blockquote><pre>template &lt;class Alloc&gt; explicit queue(const Alloc&amp; a) : c(a) {}
</pre></blockquote>

<p>
The issue is that <tt>Alloc</tt> can be anything that a container will construct
from, for example an <tt>int</tt>.  Is this intended to compile?
</p>

<blockquote><pre>queue&lt;int&gt; q(5);
</pre></blockquote>

<p>
Before the addition of this constructor, <tt>queue&lt;int&gt;(5)</tt> would not compile.
I ask, not because this crashes, but because it is new and appears to be
unintended.  We do not want to be in a position of accidently introducing this
"feature" in C++0X and later attempting to remove it.
</p>

<p>
I've picked on <tt>queue</tt>.  <tt>priority_queue</tt> and <tt>stack</tt> have
the same issue.  Is it useful to create a <tt>priority_queue</tt> of 5
identical elements?
</p>

<p><i>[
Daniel, Howard and Pablo collaborated on the proposed wording.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Move to Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>

<p><i>[
This resolution includes a semi-editorial clean up, giving definitions to members
which in some cases weren't defined since C++98.
This resolution also offers editorially different wording for <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#976">976</a>,
and it also provides wording for <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1196">1196</a>.
]</i></p>


<p>
Change  container.adaptors, p1:
</p>

<blockquote>
The container adaptors each take a <tt>Container</tt> template parameter, and
each constructor takes a <tt>Container</tt> reference argument. This container is
copied into the <tt>Container</tt> member of each adaptor. If the container takes
an allocator, then a compatible allocator may be passed in to the
adaptor's constructor. Otherwise, normal copy or move construction is
used for the container argument. <del>[<i>Note:</i> it is not necessary for an
implementation to distinguish between the one-argument constructor that
takes a <tt>Container</tt> and the one- argument constructor that takes an
allocator_type. Both forms use their argument to construct an instance
of the container.  <i>end note</i>]</del>
</blockquote>

<p>
Change  queue.defn, p1:
</p>

<blockquote><pre>template &lt;class T, class Container = deque&lt;T&gt; &gt;
class queue {
public:
  typedef typename Container::value_type      value_type;
  typedef typename Container::reference       reference;
  typedef typename Container::const_reference const_reference;
  typedef typename Container::size_type       size_type;
  typedef Container                           container_type;
protected:
  Container c;

public:
  explicit queue(const Container&amp;);
  explicit queue(Container&amp;&amp; = Container());
  queue(queue&amp;&amp; q)<ins>;</ins><del> : c(std::move(q.c)) {}</del>
  template &lt;class Alloc&gt; explicit queue(const Alloc&amp;);
  template &lt;class Alloc&gt; queue(const Container&amp;, const Alloc&amp;);
  template &lt;class Alloc&gt; queue(Container&amp;&amp;, const Alloc&amp;);
  template &lt;class Alloc&gt; queue(queue&amp;&amp;, const Alloc&amp;);
  queue&amp; operator=(queue&amp;&amp; q)<ins>;</ins><del> { c = std::move(q.c); return *this; }</del>

  bool empty() const          { return c.empty(); }
  ...
};
</pre></blockquote>

<p>
Add a new section after 23.5.1.1 [queue.defn], [queue.cons]:
</p>

<blockquote>
<p><b><tt>queue</tt> constructors [queue.cons]</b></p>

<pre>explicit queue(const Container&amp; cont);
</pre>

<blockquote>

<p>
<i>Effects:</i> Initializes <tt>c</tt> with <tt>cont</tt>.
</p>

</blockquote>

<pre>explicit queue(Container&amp;&amp; cont = Container());
</pre>

<blockquote>

<p>
<i>Effects:</i> Initializes <tt>c</tt> with <tt>std::move(cont)</tt>.
</p>

</blockquote>

<pre>queue(queue&amp;&amp; q)
</pre>

<blockquote>

<p>
<i>Effects:</i> Initializes <tt>c</tt> with <tt>std::move(q.c)</tt>.
</p>

</blockquote>

<p>
For each of the following constructors,
if <tt>uses_allocator&lt;container_type, Alloc&gt;::value</tt> is <tt>false</tt>,
then the constructor shall not participate in overload resolution.
</p>

<pre>template &lt;class Alloc&gt; 
  explicit queue(const Alloc&amp; a);
</pre>

<blockquote>

<p>
<i>Effects:</i> Initializes <tt>c</tt> with <tt>a</tt>.
</p>

</blockquote>

<pre>template &lt;class Alloc&gt; 
  queue(const container_type&amp; cont, const Alloc&amp; a);
</pre>

<blockquote>

<p>
<i>Effects:</i> Initializes <tt>c</tt> with <tt>cont</tt> as the first
argument and <tt>a</tt> as the second argument.
</p>

</blockquote>

<pre>template &lt;class Alloc&gt; 
  queue(container_type&amp;&amp; cont, const Alloc&amp; a);
</pre>

<blockquote>

<p>
<i>Effects:</i> Initializes <tt>c</tt> with <tt>std::move(cont)</tt> as the
first argument and <tt>a</tt> as the second argument.
</p>

</blockquote>

<pre>template &lt;class Alloc&gt; 
  queue(queue&amp;&amp; q, const Alloc&amp; a);
</pre>

<blockquote>

<p>
<i>Effects:</i> Initializes <tt>c</tt> with <tt>std::move(q.c)</tt> as the
first argument and <tt>a</tt> as the second argument.
</p>

</blockquote>

<pre>queue&amp; operator=(queue&amp;&amp; q);
</pre>

<blockquote>

<p>
<i>Effects:</i> Assigns <tt>c</tt> with <tt>std::move(q.c)</tt>.
</p>

<p>
<i>Returns:</i> <tt>*this</tt>.
</p>

</blockquote>



</blockquote>

<p>
Add to 23.5.2.1 [priqueue.cons]:
</p>

<blockquote>

<pre>priority_queue(priority_queue&amp;&amp; q);
</pre>

<blockquote>

<p>
<i>Effects:</i> Initializes <tt>c</tt> with <tt>std::move(q.c)</tt> and
initializes <tt>comp</tt> with <tt>std::move(q.comp)</tt>.
</p>

</blockquote>

<p>
For each of the following constructors,
if <tt>uses_allocator&lt;container_type, Alloc&gt;::value</tt> is <tt>false</tt>,
then the constructor shall not participate in overload resolution.
</p>

<pre>template &lt;class Alloc&gt;
  explicit priority_queue(const Alloc&amp; a);
</pre>

<blockquote>

<p>
<i>Effects:</i> Initializes <tt>c</tt> with <tt>a</tt> and value-initializes <tt>comp</tt>.
</p>

</blockquote>

<pre>template &lt;class Alloc&gt;
  priority_queue(const Compare&amp; compare, const Alloc&amp; a);
</pre>

<blockquote>

<p>
<i>Effects:</i> Initializes <tt>c</tt> with <tt>a</tt> and initializes <tt>comp</tt>
with <tt>compare</tt>.
</p>

</blockquote>

<pre>template &lt;class Alloc&gt;
  priority_queue(const Compare&amp; compare, const Container&amp; cont, const Alloc&amp; a);
</pre>

<blockquote>

<p>
<i>Effects:</i> Initializes <tt>c</tt> with <tt>cont</tt> as the first argument
and <tt>a</tt> as the second argument,
and initializes <tt>comp</tt> with <tt>compare</tt>.
</p>

</blockquote>

<pre>template &lt;class Alloc&gt;
  priority_queue(const Compare&amp; compare, Container&amp;&amp; cont, const Alloc&amp; a);
</pre>

<blockquote>

<p>
<i>Effects:</i> Initializes <tt>c</tt> with <tt>std::move(cont)</tt> as 
the first argument and <tt>a</tt> as the second argument,
and initializes <tt>comp</tt> with <tt>compare</tt>.
</p>

</blockquote>

<pre>template &lt;class Alloc&gt;
  priority_queue(priority_queue&amp;&amp; q, const Alloc&amp; a);
</pre>

<blockquote>

<p>
<i>Effects:</i> Initializes <tt>c</tt> with <tt>std::move(q.c)</tt> as the
first argument and <tt>a</tt> as the second argument, 
and initializes <tt>comp</tt> with <tt>std::move(q.comp)</tt>.
</p>

</blockquote>

<pre>priority_queue&amp; operator=(priority_queue&amp;&amp; q);
</pre>

<blockquote>

<p>
<i>Effects:</i> Assigns <tt>c</tt> with <tt>std::move(q.c)</tt> and
assigns <tt>comp</tt> with <tt>std::move(q.comp)</tt>.
</p>

<p>
<i>Returns:</i> <tt>*this</tt>.
</p>

</blockquote>

</blockquote>




<p>
Change 23.5.3.1 [stack.defn]:
</p>

<blockquote><pre>template &lt;class T, class Container = deque&lt;T&gt; &gt;
class stack {
public:
  typedef typename Container::value_type      value_type;
  typedef typename Container::reference       reference;
  typedef typename Container::const_reference const_reference;
  typedef typename Container::size_type       size_type;
  typedef Container                           container_type;
protected:
  Container c;

public:
  explicit stack(const Container&amp;);
  explicit stack(Container&amp;&amp; = Container());
  <ins>stack(stack&amp;&amp; s);</ins>
  template &lt;class Alloc&gt; explicit stack(const Alloc&amp;);
  template &lt;class Alloc&gt; stack(const Container&amp;, const Alloc&amp;);
  template &lt;class Alloc&gt; stack(Container&amp;&amp;, const Alloc&amp;);
  template &lt;class Alloc&gt; stack(stack&amp;&amp;, const Alloc&amp;);
  <ins>stack&amp; operator=(stack&amp;&amp; s);</ins>

  bool empty() const          { return c.empty(); }
  ...
};
</pre></blockquote>

<p>
Add a new section after 23.5.3.1 [stack.defn], [stack.cons]:
</p>

<blockquote>
<p><b><tt>stack</tt> constructors [stack.cons]</b></p>

<pre>stack(stack&amp;&amp; s);
</pre>

<blockquote>

<p>
<i>Effects:</i> Initializes <tt>c</tt> with <tt>std::move(s.c)</tt>.
</p>

</blockquote>

<p>
For each of the following constructors,
if <tt>uses_allocator&lt;container_type, Alloc&gt;::value</tt> is <tt>false</tt>,
then the constructor shall not participate in overload resolution.
</p>

<pre>template &lt;class Alloc&gt; 
  explicit stack(const Alloc&amp; a);
</pre>

<blockquote>

<p>
<i>Effects:</i> Initializes <tt>c</tt> with <tt>a</tt>.
</p>

</blockquote>

<pre>template &lt;class Alloc&gt; 
  stack(const container_type&amp; cont, const Alloc&amp; a);
</pre>

<blockquote>

<p>
<i>Effects:</i> Initializes <tt>c</tt> with <tt>cont</tt> as the
first argument and <tt>a</tt> as the second argument.
</p>

</blockquote>

<pre>template &lt;class Alloc&gt; 
  stack(container_type&amp;&amp; cont, const Alloc&amp; a);
</pre>

<blockquote>

<p>
<i>Effects:</i> Initializes <tt>c</tt> with <tt>std::move(cont)</tt> as the
first argument and <tt>a</tt> as the second argument.
</p>

</blockquote>

<pre>template &lt;class Alloc&gt; 
  stack(stack&amp;&amp; s, const Alloc&amp; a);
</pre>

<blockquote>

<p>
<i>Effects:</i> Initializes <tt>c</tt> with <tt>std::move(s.c)</tt> as the
first argument and <tt>a</tt> as the second argument.
</p>

</blockquote>

<pre>stack&amp; operator=(stack&amp;&amp; s);
</pre>

<blockquote>

<p>
<i>Effects:</i> Assigns <tt>c</tt> with <tt>std::move(s.c)</tt>.
</p>

<p>
<i>Returns:</i> <tt>*this</tt>.
</p>

</blockquote>

</blockquote>






<hr>
<h3><a name="1195"></a>1195. "Diagnostic required" wording is insufficient to  prevent UB</h3>
<p><b>Section:</b> 17 [library] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2009-08-18 <b>Last modified:</b> 2010-10-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Several parts of the library use the notion of "Diagnostic required"
to indicate that
in the corresponding situation an error diagnostic should occur, e.g.
20.9.9.1.2 [unique.ptr.dltr.dflt]/2
</p>
<blockquote><pre>void operator()(T *ptr) const;
</pre>

<blockquote>
<i>Effects:</i> calls <tt>delete</tt> on <tt>ptr</tt>. A diagnostic is required if <tt>T</tt> is an
incomplete type.
</blockquote>
</blockquote>

<p>
The problem with this approach is that such a requirement is
insufficient to prevent
undefined behavior, if this situation occurs. According to 1.3.6 [defns.diagnostic]
a <i>diagnostic message</i> is defined as
</p>

<blockquote>
a message belonging to an implementation-defined subset of the
implementation's output messages.
</blockquote>

<p>
which doesn't indicate any relation to an ill-formed program. In fact,
"compiler warnings"
are a typical expression of such diagnostics. This means that above
wording can be interpreted
by compiler writers that they satisfy the requirements of the standard
if they just produce
such a "warning", if the compiler happens to compile code like this:
</p>

<blockquote><pre>#include &lt;memory&gt;

struct Ukn; // defined somewhere else
Ukn* create_ukn(); // defined somewhere else

int main() {
 std::default_delete&lt;Ukn&gt;()(create_ukn());
}
</pre></blockquote>

<p>
In this and other examples discussed here it was the authors intent to
guarantee that the
program is ill-formed with a required diagnostic, therefore such
wording should be used instead.
According to the general rules outlined in 1.4 [intro.compliance] it
should be sufficient
to require that these situations produce an ill-formed program and the
"diagnostic
required" part should be implied. The proposed resolution also
suggests to remove
several <i>redundant</i> wording of "Diagnostics required" to ensure that
the absence of
such saying does not cause a misleading interpretation.
</p>

<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote>
<p>
Move to NAD.
</p>
<p>
It's not clear that there's any important difference between
"ill-formed" and "diagnostic required". From 1.4 [intro.compliance], 1.3.9 [defns.ill.formed], and 1.3.26 [defns.well.formed] it appears that an ill-formed program is one
that is not correctly constructed according to the syntax rules and
diagnosable semantic rules, which means that... "a conforming
implementation shall issue at least one diagnostic message." The
author's intent seems to be that we should be requiring a fatal error
instead of a mere warning, but the standard just doesn't have language
to express that distinction. The strongest thing we can ever require is
a "diagnostic".
</p>
<p>
The proposed rewording may be a clearer way of expressing the same thing
that the WP already says, but such a rewording is editorial.
</p>
</blockquote>

<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote>
Considered again.  Group disagrees that the change is technical, but likes
it editorially.  Moved to NAD Editorial.
</blockquote>

<p><i>[
2009-11-19: Moved from NAD Editorial to Open.  Please see the thread starting
with Message c++std-lib-25916.
]</i></p>


<p><i>[
2009-11-20 Daniel updated wording.
]</i></p>


<blockquote>
<p>
The following resolution differs from the previous one by avoiding the unusual
and misleading term "shall be ill-formed", which does also not follow the core
language style. This resolution has the advantage of a minimum impact on the
current wording, but I would like to mention that a more intrusive solution
might be preferrable - at least as a long-term solution: Jens Maurer suggested
the following approach to get rid of the usage of the term "ill-formed" from the
library by introducing a new category to existing elements to the list of 17.5.1.4 [structure.specifications]/3, e.g. "type requirements" or "static
constraints" that define conditions that can be checked during compile-time and
any violation would make the program ill-formed. As an example, the currently
existing phrase 20.4.2.5 [tuple.helper]/1
</p>

<blockquote>
<i>Requires:</i> <tt>I &lt; sizeof...(Types)</tt>. The program is ill-formed if
<tt>I</tt> is out of bounds.
</blockquote>

<p>
could then be written as
</p>

<blockquote>
<i>Static constraints:</i> <tt>I &lt; sizeof...(Types)</tt>.
</blockquote>

</blockquote>

<p><i>[
2009-11-21 Daniel updated wording.
]</i></p>


<p><i>[
2009-11-22 Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>




<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>
Change 20.6 [ratio]/2 as indicated:
</p>

<blockquote>
Throughout this subclause, <ins>if</ins> the template argument types <tt>R1</tt>
and <tt>R2</tt> <del>shall be</del> <ins>are not</ins> specializations of the
<tt>ratio</tt> template<ins>, the program is ill-formed</ins>. <del>Diagnostic
required.</del>
</blockquote>
</li>

<li>
<p>
Change 20.6.1 [ratio.ratio]/1 as indicated:
</p>

<p>
<ins>If t</ins><del>T</del>he template argument <tt>D</tt> <del>shall not
be</del> <ins>is</ins> zero<del>, and</del> <ins>or</ins> the absolute values of
the template arguments <tt>N</tt> and <tt>D</tt> <del>shall be</del> <ins>are
not</ins> representable by type <tt>intmax_t</tt><ins>, the program is
ill-formed</ins>. <del>Diagnostic required.</del> [..]
</p>

</li>

<li>
<p>
Change 20.6.2 [ratio.arithmetic]/1 as indicated:
</p>

<blockquote>
Implementations may use other algorithms to compute these values. If overflow
occurs, <ins>the program is ill-formed</ins> <del>a diagnostic shall be
issued</del>.
</blockquote>

</li>

<li>
<p>
Change 20.6.3 [ratio.comparison]/2 as indicated:
</p>

<blockquote>
[...] Implementations may use other algorithms to compute this relationship to
avoid overflow. If overflow occurs, <ins>the program is ill-formed</ins> <del>a
diagnostic is required</del>.
</blockquote>

</li>

<li>
<p>
Change 20.9.9.1.2 [unique.ptr.dltr.dflt]/2 as indicated:
</p>

<blockquote>
<p>
<i>Effects:</i> calls <tt>delete</tt> on <tt>ptr</tt>. <del>A diagnostic is
required if <tt>T</tt> is an incomplete type.</del>
</p>

<p>
<ins><i>Remarks:</i> If <tt>T</tt> is an incomplete type, the program is
ill-formed.</ins>
</p>
</blockquote>

</li>

<li>
<p>
Change 20.9.9.1.3 [unique.ptr.dltr.dflt1]/1 as indicated:
</p>

<blockquote><pre>void operator()(T* ptr) const;
</pre>
<blockquote>
<p>
<ins><i>Effects:</i></ins> <del><tt>operator()</tt></del> calls
<tt>delete[]</tt> on <tt>ptr</tt>. <del>A diagnostic is required if <tt>T</tt>
is an incomplete type.</del>
</p>
<p>
<ins><i>Remarks:</i> If <tt>T</tt> is an incomplete type, the program is
ill-formed.</ins>
</p>
</blockquote>
</blockquote>

</li>

<li>
<p>
Change 20.9.9.2.1 [unique.ptr.single.ctor] as indicated: <i>[Note: This
editorially improves the currently suggested wording of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#932">932</a> by
replacing</i>
</p>
<blockquote>
<i>"shall be ill-formed" by "is ill-formed"]</i>
</blockquote>

<p>
<i>[If
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n3025.html">N3025</a>
is accepted this bullet is applied identically in that paper as well.]</i>
</p>

<blockquote>
<p>
-1- <i>Requires:</i> <tt>D</tt> shall be default constructible, and that
construction shall not throw an exception. <del><tt>D</tt> shall not be a
reference type or pointer type (diagnostic required).</del>
</p>

<p>...</p>

<p><ins>
<i>Remarks:</i> If this constructor is instantiated with a pointer type
or reference type for the template argument <tt>D</tt>, the program is
ill-formed.
</ins></p>
</blockquote>

</li>

<li>
<p>
Change 20.9.9.2.1 [unique.ptr.single.ctor]/8 as indicated: <i>[Note: This
editorially improves the currently suggested wording of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#932">932</a> by
replacing</i>
</p>
<blockquote>
<i>"shall be ill-formed" by "is ill-formed"]</i>
</blockquote>

<p>
<i>[If
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n3025.html">N3025</a>
is accepted this bullet is applied identically in that paper as well.]</i>
</p>

<blockquote><pre>unique_ptr(pointer p);
</pre>
<blockquote>
<p>...</p>
<p><ins>
<i>Remarks:</i> If this constructor is instantiated with a pointer type
or reference type for the template argument <tt>D</tt>, the program is
ill-formed.
</ins></p>
</blockquote>
</blockquote>

</li>

<li>
<p>
Change 20.9.9.2.1 [unique.ptr.single.ctor]/13 as indicated:
</p>

<blockquote>
[..] If <tt>d</tt> is an rvalue, it will bind to the second constructor of this
pair <ins>and the program is ill-formed</ins>. <del>That constructor shall emit
a diagnostic.</del> [<i>Note:</i> The diagnostic could be implemented using a
<tt>static_assert</tt> which assures that <tt>D</tt> is not a reference type.
 <i>end note</i>] Else <tt>d</tt> is an lvalue and will bind to the first
constructor of this pair. [..]
</blockquote>

</li>

<li>
20.9.9.2.1 [unique.ptr.single.ctor]/20: Solved by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#950">950</a>.
</li>

<li>
<p>
Change 20.9.9.3 [unique.ptr.runtime]/1 as indicated:
</p>

<blockquote>
<p>
A specialization for array types is provided with a slightly altered interface.
</p>
<ul>
<li>
Conversions among different types of <tt>unique_ptr&lt;T[], D&gt;</tt> or to or
from the non-array forms of <tt>unique_ptr</tt> <del>are disallowed (diagnostic
required)</del> <ins>produce an ill-formed program</ins>.
</li>
<li>...</li>
</ul>
</blockquote>

</li>

<li>
<p>
Change 20.11.3 [time.duration]/2-4 as indicated:
</p>

<blockquote>
<p>
2 <i>Requires:</i> <tt>Rep</tt> shall be an arithmetic type or a class emulating
an arithmetic type. <del>If a program instantiates <tt>duration</tt> with a
<tt>duration</tt> type for the template argument <tt>Rep</tt> a diagnostic is
required.</del>
</p>
<p>
<ins>3 <i>Remarks:</i> If <tt>duration</tt> is instantiated with a
<tt>duration</tt> type for the template argument <tt>Rep</tt>, the program is
ill-formed.</ins>
</p>

<p>
<del>3</del> <ins>4</ins> <i><del>Requires</del> <ins>Remarks</ins>:</i>
<ins>If</ins> <tt>Period</tt> <del>shall be</del> <ins>is not</ins> a
specialization of <tt>ratio</tt>, <del>diagnostic required</del> <ins>the
program is ill-formed</ins>.
</p>

<p>
<del>4</del> <ins>5</ins> <i><del>Requires</del> <ins>Remarks</ins>:</i>
<ins>If</ins> <tt>Period::num</tt> <del>shall be</del> <ins>is not</ins>
positive, <del>diagnostic required</del> <ins>the program is ill-formed</ins>.
</p>
</blockquote>

</li>

<li>
20.11.3.1 [time.duration.cons]/1+4: Apply <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1177">1177</a>
</li>

<li>
20.11.3.5 [time.duration.nonmember]/4+6+8+11: Apply <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1177">1177</a>
</li>

<li>
20.11.3.7 [time.duration.cast]/1: Apply <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1177">1177</a>
</li>

<li>
<p>
Change 20.11.4 [time.point]/2 as indicated:
</p>
<blockquote>
<ins>If</ins> <tt>Duration</tt> <del>shall be</del> <ins>is not</ins> an
instance of <tt>duration</tt><ins>, the program is ill-formed</ins>.
<del>Diagnostic required.</del>
</blockquote>
</li>

<li>
20.11.4.1 [time.point.cons]/3: Apply <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1177">1177</a>
</li>

<li>
20.11.4.7 [time.point.cast]/1: Apply <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1177">1177</a>
</li>

</ol>






<hr>
<h3><a name="1197"></a>1197. Can unordered containers have <tt>bucket_count() == 0</tt>?</h3>
<p><b>Section:</b> 23.2.5 [unord.req] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-08-24 <b>Last modified:</b> 2010-10-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#unord.req">active issues</a> in [unord.req].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#unord.req">issues</a> in [unord.req].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Table 97 "Unordered associative container requirements" in
23.2.5 [unord.req] says:
</p>

<blockquote>
<table border="1">
<caption>Table 97  Unordered associative container requirements
(in addition to container)</caption>

<tbody><tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion/note pre-/post-condition</th>
<th>Complexity</th>
</tr>

<tr>
<td><tt>b.bucket(k)</tt></td>
<td><tt>size_type</tt></td>
<td>Returns the index of the bucket in which elements with keys 
equivalent to <tt>k</tt> would be found, 
if any such element existed. 
Post: the return value shall be 
in the range <tt>[0, 
b.bucket_count())</tt>.</td>
<td>Constant</td>
</tr>

</tbody></table>
</blockquote>

<p>
What should <tt>b.bucket(k)</tt> return if <tt>b.bucket_count() == 0</tt>?
</p>

<p>
I believe allowing <tt>b.bucket_count() == 0</tt> is important.  It is a
very reasonable post-condition of the default constructor, or of a moved-from
container.
</p>

<p>
I can think of several reasonable results from <tt>b.bucket(k)</tt> when
<tt>b.bucket_count() == 0</tt>:
</p>

<ol>
<li>
Return 0.
</li>
<li>
Return <tt>numeric_limits&lt;size_type&gt;::max()</tt>.
</li>
<li>
Throw a <tt>domain_error</tt>.
</li>
<li>
Requires: <tt>b.bucket_count() != 0</tt>.
</li>
</ol>

<p><i>[
2009-08-26 Daniel adds:
]</i></p>


<blockquote>
<p>
A forth choice would be to add the pre-condition "<tt>b.bucket_count() != 0</tt>"
and thus imply undefined behavior if this is violated.
</p>

<p><i>[
Howard:  I like this option too, added to the list.
]</i></p>


<p>
Further on here my own favorite solution (rationale see below):
</p>

<p><b>Suggested resolution:</b></p>

<p>
[Rationale: I suggest to follow choice (1). The main reason is
that all associative container functions which take a key argument,
are basically free of pre-conditions and non-disrupting, therefore
excluding choices (3) and (4). Option (2) seems a bit unexpected
to me. It would be more natural, if several similar functions
would exist which would also justify the existence of a symbolic
constant like npos for this situation. The value 0 is both simple
and consistent, it has exactly the same role as a past-the-end
iterator value. A typical use-case is:
</p>

<blockquote><pre>size_type pos = m.bucket(key);
if (pos != m.bucket_count()) {
 ...
} else {
 ...
}
</pre></blockquote>

<p> end Rationale]</p>

<p>
- Change Table 97 in 23.2.5 [unord.req] as follows (Row b.bucket(k), Column "Assertion/..."):
</p>

<blockquote>
<table border="1">
<caption>Table 97  Unordered associative container requirements
(in addition to container)</caption>

<tbody><tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion/note pre-/post-condition</th>
<th>Complexity</th>
</tr>

<tr>
<td><tt>b.bucket(k)</tt></td>
<td><tt>size_type</tt></td>
<td>Returns the index of the bucket in which elements with keys 
equivalent to <tt>k</tt> would be found, 
if any such element existed. 
Post: <ins>if b.bucket_count() != 0, </ins>the return value shall be 
in the range <tt>[0, 
b.bucket_count())</tt><ins>, otherwise 0</ins>.</td>
<td>Constant</td>
</tr>

</tbody></table>
</blockquote>

</blockquote>

<p><i>[
2010-01-25 Choice 4 put into proposed resolution section.
]</i></p>


<p><i>[
2010-01-31 Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
Change Table 97 in 23.2.5 [unord.req] as follows (Row b.bucket(k), Column
"Assertion/..."):
</p>

<blockquote>
<table border="1">
<caption>Table 97  Unordered associative container requirements
(in addition to container)</caption>

<tbody><tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion/note pre-/post-condition</th>
<th>Complexity</th>
</tr>

<tr>
<td><tt>b.bucket(k)</tt></td>
<td><tt>size_type</tt></td>
<td><ins>Pre:  <tt>b.bucket_count() &gt; 0</tt></ins> Returns the index of the
bucket in which elements with keys equivalent to <tt>k</tt> would be found, if
any such element existed. Post: the return value shall be in the range <tt>[0,
b.bucket_count())</tt>.</td>
<td>Constant</td>
</tr>

</tbody></table>
</blockquote>






<hr>
<h3><a name="1198"></a>1198. Container adaptor swap: member or non-member?</h3>
<p><b>Section:</b> 23.5 [container.adaptors] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Pablo Halpern <b>Opened:</b> 2009-08-26 <b>Last modified:</b> 2010-11-24</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#container.adaptors">issues</a> in [container.adaptors].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Under 23.5 [container.adaptors] of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2914.pdf">N2914</a>
the member function of <tt>swap</tt> of <tt>queue</tt> and <tt>stack</tt> call:
</p>

<blockquote><pre>swap(c, q.c);
</pre></blockquote>

<p>
But under 23.5 [container.adaptors] of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2723.pdf">N2723</a>
these members are specified to call:
</p>

<blockquote><pre>c.swap(q.c);
</pre></blockquote>

<p>
Neither draft specifies the semantics of member <tt>swap</tt> for
<tt>priority_queue</tt> though it is declared.
</p>

<p>
Although the distinction between member <tt>swap</tt> and non-member
<tt>swap</tt> is not important when these adaptors are adapting standard
containers, it may be important for user-defined containers.
</p>
<p>
We (Pablo and Howard) feel that
it is more likely for a user-defined container to support a namespace scope
<tt>swap</tt> than a member <tt>swap</tt>, and therefore these adaptors
should use the container's namespace scope <tt>swap</tt>.
</p>

<p><i>[
2009-09-30 Daniel adds:
]</i></p>


<blockquote>
The outcome of this issue should be considered with the outcome of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#774">774</a> both in style and in content (e.g. <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#774">774</a> bullet 9
suggests to define the semantic of <tt>void
priority_queue::swap(priority_queue&amp;)</tt> in terms of the member
<tt>swap</tt> of the container).
</blockquote>

<p><i>[
2010-03-28 Daniel update to diff against N3092.
]</i></p>



<p><i>[
2010 Rapperswil:
]</i></p>


<blockquote>
Preference to move the wording into normative text, rather than inline function definitions in the class synopsis.

Move to Tenatively Ready.
</blockquote>

<p><i>[
Adopted at 2010-11 Batavia
]</i></p>




<p><b>Proposed resolution:</b></p>

<p>
Change 23.5.1.1 [queue.defn]:
</p>

<blockquote><pre>template &lt;class T, class Container = deque&lt;T&gt; &gt; 
class queue {
   ...
   void swap(queue&amp; q) { <ins>using std::swap;</ins>
                          <del>c.</del>swap(<ins>c, </ins>q.c); }
   ...
};
</pre></blockquote>

<p>
Change 23.5.2 [priority.queue]:
</p>

<blockquote><pre>template &lt;class T, class Container = vector&lt;T&gt;, 
          class Compare = less&lt;typename Container::value_type&gt; &gt; 
class priority_queue { 
    ...
    void swap(priority_queue&amp; <ins>q</ins>)<del>;</del> <ins>{ using std::swap;</ins>
                                     <ins>swap(c, q.c);</ins>
                                     <ins>swap(comp, q.comp); }</ins>
    ...
};
</pre></blockquote>

<p>
Change 23.5.3.1 [stack.defn]:
</p>

<blockquote><pre>template &lt;class T, class Container = deque&lt;T&gt; &gt; 
class stack {
   ...
   void swap(stack&amp; s) { <ins>using std::swap;</ins>
                          <del>c.</del>swap(<ins>c, </ins>s.c); }
   ...
};
</pre></blockquote>






<hr>
<h3><a name="1199"></a>1199. Missing extended copy constructor in container adaptors</h3>
<p><b>Section:</b> 23.5 [container.adaptors] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Pablo Halpern <b>Opened:</b> 2009-08-26 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#container.adaptors">issues</a> in [container.adaptors].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>queue</tt> has a constructor:
</p>

<blockquote><pre>template &lt;class Alloc&gt;
  queue(queue&amp;&amp;, const Alloc&amp;);
</pre></blockquote>

<p>
but it is missing a corresponding constructor:
</p>

<blockquote><pre>template &lt;class Alloc&gt;
  queue(const queue&amp;, const Alloc&amp;);
</pre></blockquote>

<p>
The same is true of <tt>priority_queue</tt>, and <tt>stack</tt>.  This
"extended copy constructor" is needed for consistency and to ensure that the
user of a container adaptor can always specify the allocator for his adaptor.
</p>

<p><i>[
2010-02-01 Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p><i>[
This resolution has been harmonized with the proposed resolution to issue
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1194">1194</a>
]</i></p>


<p>Change 23.5.1.1 [queue.defn], p1:</p>

<blockquote><pre>template &lt;class T, class Container = deque&lt;T&gt; &gt;
class queue {
public:
  typedef typename Container::value_type      value_type;
  typedef typename Container::reference       reference;
  typedef typename Container::const_reference const_reference;
  typedef typename Container::size_type       size_type;
  typedef Container                           container_type;
protected:
  Container c;

public:
  explicit queue(const Container&amp;);
  explicit queue(Container&amp;&amp; = Container());
  queue(queue&amp;&amp; q);

  template &lt;class Alloc&gt; explicit queue(const Alloc&amp;);
  template &lt;class Alloc&gt; queue(const Container&amp;, const Alloc&amp;);
  template &lt;class Alloc&gt; queue(Container&amp;&amp;, const Alloc&amp;);
  <ins>template &lt;class Alloc&gt; queue(const queue&amp;, const Alloc&amp;);</ins>
  template &lt;class Alloc&gt; queue(queue&amp;&amp;, const Alloc&amp;);
  queue&amp; operator=(queue&amp;&amp; q);

  bool empty() const          { return c.empty(); }
  ...
};
</pre></blockquote>

<p>
To the new section 23.5.1.2 [queue.cons], introduced
in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1194">1194</a>, add:
</p>

<blockquote>

<pre>template &lt;class Alloc&gt; 
  queue(const queue&amp; q, const Alloc&amp; a);
</pre>

<blockquote><p>
<i>Effects:</i> Initializes <tt>c</tt> with <tt>q.c</tt> as the
first argument and <tt>a</tt> as the second argument.
</p></blockquote>

</blockquote>

<p>Change 23.5.2 [priority.queue] as follows (I've an included an editorial change to
  move the poorly-placed move-assignment operator):</p>

<blockquote><pre>template &lt;class T, class Container = vector&lt;T&gt;,
          class Compare = less&lt;typename Container::value_type&gt; &gt;
class priority_queue {
public:
  typedef typename Container::value_type      value_type;
  typedef typename Container::reference       reference;
  typedef typename Container::const_reference const_reference;
  typedef typename Container::size_type       size_type;
  typedef          Container                  container_type;
protected:
  Container c;
  Compare comp;

public:
  priority_queue(const Compare&amp; x, const Container&amp;);
  explicit priority_queue(const Compare&amp; x = Compare(), Container&amp;&amp; = Container());
  template &lt;class InputIterator&gt;
    priority_queue(InputIterator first, InputIterator last,
                   const Compare&amp; x, const Container&amp;);
  template &lt;class InputIterator&gt;
    priority_queue(InputIterator first, InputIterator last,
                   const Compare&amp; x = Compare(), Container&amp;&amp; = Container());
  priority_queue(priority_queue&amp;&amp;);
  <del>priority_queue&amp; operator=(priority_queue&amp;&amp;);</del>
  template &lt;class Alloc&gt; explicit priority_queue(const Alloc&amp;);
  template &lt;class Alloc&gt; priority_queue(const Compare&amp;, const Alloc&amp;);
  template &lt;class Alloc&gt; priority_queue(const Compare&amp;,
                                        const Container&amp;, const Alloc&amp;);
  template &lt;class Alloc&gt; priority_queue(const Compare&amp;,
                                        Container&amp;&amp;, const Alloc&amp;);
  <ins>template &lt;class Alloc&gt; priority_queue(const priority_queue&amp;, const Alloc&amp;);</ins>
  template &lt;class Alloc&gt; priority_queue(priority_queue&amp;&amp;, const Alloc&amp;);

  <ins>priority_queue&amp; operator=(priority_queue&amp;&amp;);</ins>
  ...
};
</pre></blockquote>

<p>
Add to 23.5.2.1 [priqueue.cons]:
</p>

<blockquote>

<pre>template &lt;class Alloc&gt;
  priority_queue(const priority_queue&amp; q, const Alloc&amp; a);
</pre>

<blockquote><p>
<i>Effects:</i> Initializes <tt>c</tt> with <tt>q.c</tt> as the
first argument and <tt>a</tt> as the second argument, 
and initializes <tt>comp</tt> with <tt>q.comp</tt>.
</p></blockquote>

</blockquote>

<p>
Change 23.5.3.1 [stack.defn]:
</p>

<blockquote><pre>template &lt;class T, class Container = deque&lt;T&gt; &gt;
class stack {
public:
  typedef typename Container::value_type      value_type;
  typedef typename Container::reference       reference;
  typedef typename Container::const_reference const_reference;
  typedef typename Container::size_type       size_type;
  typedef Container                           container_type;
protected:
  Container c;

public:
  explicit stack(const Container&amp;);
  explicit stack(Container&amp;&amp; = Container());
  stack(stack&amp;&amp; s);

  template &lt;class Alloc&gt; explicit stack(const Alloc&amp;);
  template &lt;class Alloc&gt; stack(const Container&amp;, const Alloc&amp;);
  template &lt;class Alloc&gt; stack(Container&amp;&amp;, const Alloc&amp;);
  <ins>template &lt;class Alloc&gt; stack(const stack&amp;, const Alloc&amp;);</ins>
  template &lt;class Alloc&gt; stack(stack&amp;&amp;, const Alloc&amp;);
  stack&amp; operator=(stack&amp;&amp; s);

  bool empty() const          { return c.empty(); }
  ...
};
</pre></blockquote>

<p>
To the new section 23.5.3.2 [stack.cons], introduced
in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1194">1194</a>, add:
</p>

<blockquote>

<pre>template &lt;class Alloc&gt; 
  stack(const stack&amp; s, const Alloc&amp; a);
</pre>

<blockquote><p>
<i>Effects:</i> Initializes <tt>c</tt> with <tt>s.c</tt> as the
first argument and <tt>a</tt> as the second argument.
</p></blockquote>
</blockquote>






<hr>
<h3><a name="1204"></a>1204. Global permission to move</h3>
<p><b>Section:</b> 17.6.3.9 [res.on.arguments] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-09-12 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#res.on.arguments">issues</a> in [res.on.arguments].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
When a library function binds an rvalue reference parameter to an argument, the
library must be able to assume that the bound argument is a temporary, and not
a moved-from lvalue.  The reason for this is that the library function must be
able to modify that argument without concern that such modifications will corrupt
the logic of the calling code.  For example:
</p>

<blockquote><pre>template &lt;class T, class A&gt;
void
vector&lt;T, A&gt;::push_back(value_type&amp;&amp; v)
{
    <font color="#C80000">// This function should move from v, potentially modifying</font>
    <font color="#C80000">//   the object v is bound to.</font>
}
</pre></blockquote>

<p>
If <tt>v</tt> is truly bound to a temporary, then <tt>push_back</tt> has the
<em>only</em> reference to this temporary in the entire program.  Thus any
modifications will be invisible to the rest of the program.
</p>

<p>
If the client supplies <tt>std::move(x)</tt> to <tt>push_back</tt>, the onus is
on the client to ensure that the value of <tt>x</tt> is no longer important to
the logic of his program after this statement.  I.e. the client is making a statement
that <tt>push_back</tt> may treat <tt>x</tt> as a temporary.
</p>

<blockquote><em>
The above statement is the very foundation upon which move semantics is based.
</em></blockquote>

<p>
The standard is currently lacking a global statement to this effect.  I propose
the following addition to 17.6.3.9 [res.on.arguments]:
</p>

<blockquote>
<p>
Each of the following statements applies to all arguments to functions
defined in the C++ standard library, unless explicitly stated otherwise.
</p>
<ul>
<li>
If an argument to a function has an invalid value (such as a value
outside the domain of the function, or a pointer invalid for its
intended use), the behavior is undefined.
</li>
<li>
If a function argument is described as being an array, the pointer
actually passed to the function shall have a value such that all address
computations and accesses to objects (that would be valid if the pointer
did point to the first element of such an array) are in fact valid.
</li>
<li><ins>
If a function argument binds to an rvalue reference parameter, the C++
standard library may assume that this parameter is a unique reference
to this argument.  If the parameter is a generic parameter of the
form <tt>T&amp;&amp;</tt>, and an lvalue of type <tt>A</tt> is bound,
then the binding is considered to be to an lvalue reference
(14.8.2.1 [temp.deduct.call]) and thus not covered by this clause.
[<i>Note:</i>
If a program casts an lvalue to an rvalue while passing that lvalue to
a library function (e.g. <tt>move(x)</tt>), then the program is effectively
asking the library to treat that lvalue as a temporary.  The library is at
liberty to optimize away aliasing checks which might be needed if the argument
were an lvalue.
 <i>end note</i>]
</ins></li>
</ul>

</blockquote>

<p>
Such a global statement will eliminate the need for piecemeal statements such as
23.2.1 [container.requirements.general]/13:
</p>

<blockquote>
An object bound to an rvalue reference parameter of a member function of
a container shall not be an element of that container; no diagnostic
required.
</blockquote>

<p>
Additionally this clarifies that move assignment operators need not perform the
traditional <tt>if (this != &amp;rhs)</tt> test commonly found (and needed) in
copy assignment operators.
</p>

<p><i>[
2009-09-13 Niels adds:
]</i></p>


<blockquote>
Note: This resolution supports the change of 27.9.1.3 [filebuf.assign]/1,
proposed by LWG <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#900">900</a>.
</blockquote>

<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote>
Move to Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add a bullet to 17.6.3.9 [res.on.arguments]:
</p>

<blockquote>
<p>
Each of the following statements applies to all arguments to functions
defined in the C++ standard library, unless explicitly stated otherwise.
</p>
<ul>
<li>
If an argument to a function has an invalid value (such as a value
outside the domain of the function, or a pointer invalid for its
intended use), the behavior is undefined.
</li>
<li>
If a function argument is described as being an array, the pointer
actually passed to the function shall have a value such that all address
computations and accesses to objects (that would be valid if the pointer
did point to the first element of such an array) are in fact valid.
</li>
<li><ins>
If a function argument binds to an rvalue reference parameter, the C++
standard library may assume that this parameter is a unique reference
to this argument.  If the parameter is a generic parameter of the
form <tt>T&amp;&amp;</tt>, and an lvalue of type <tt>A</tt> is bound,
then the binding is considered to be to an lvalue reference
(14.8.2.1 [temp.deduct.call]) and thus not covered by this clause.
[<i>Note:</i>
If a program casts an lvalue to an rvalue while passing that lvalue to
a library function (e.g. <tt>move(x)</tt>), then the program is effectively
asking the library to treat that lvalue as a temporary.  The library is at
liberty to optimize away aliasing checks which might be needed if the argument
were an lvalue.
 <i>end note</i>]
</ins></li>
</ul>
</blockquote>

<p>
Delete 23.2.1 [container.requirements.general]/13:
</p>

<blockquote><del>
An object bound to an rvalue reference parameter of a member function of
a container shall not be an element of that container; no diagnostic
required.
</del></blockquote>






<hr>
<h3><a name="1205"></a>1205. Some algorithms could more clearly document their handling of empty ranges</h3>
<p><b>Section:</b> 25 [algorithms] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-09-13 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#algorithms">issues</a> in [algorithms].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There are a number of algorithms whose result might depend on the
handling of an empty range.  In some cases the result is not clear,
while in others it would help readers to clearly mention the result
rather than require some subtle intuition of the supplied wording.
</p>

<p>
25.2.1 [alg.all_of]
</p>

<blockquote>
<i>Returns:</i> <tt>true</tt> if <tt>pred(*i)</tt> is <tt>true</tt> for every
iterator <tt>i</tt> in the range <tt>[first,last)</tt>, ...
</blockquote>

<p>
What does this mean if the range is empty?
</p>

<p>
I believe that we intend this to be <tt>true</tt> and suggest a
non-normative note to clarify:
</p>

<p>
Add to p1 25.2.1 [alg.all_of]:
</p>

<blockquote>
[<i>Note:</i> Returns <tt>true</tt> if <tt>[first,last)</tt> is empty. 
 <i>end note</i>]
</blockquote>

<p>
25.2.3 [alg.none_of]
</p>

<blockquote>
<i>Returns:</i> <tt>true</tt> if <tt>pred(*i)</tt> is <tt>false</tt> for every
iterator <tt>i</tt> in the range <tt>[first,last)</tt>, ...
</blockquote>

<p>
What does this mean if the range empty?
</p>

<p>
I believe that we intend this to be <tt>true</tt> and suggest a
non-normative note to clarify:
</p>

<p>
Add to p1 25.2.3 [alg.none_of]:
</p>

<blockquote>
[<i>Note:</i> Returns <tt>true</tt> if <tt>[first,last)</tt> is empty. 
 <i>end note</i>]
</blockquote>

<p>
25.2.2 [alg.any_of]
</p>

<p>
The specification for an empty range is actually fairly clear in this
case, but a note wouldn't hurt and would be consistent with proposals
for <tt>all_of</tt>/<tt>none_of</tt> algorithms.
</p>

<p>
Add to p1 25.2.2 [alg.any_of]:
</p>

<blockquote>
[<i>Note:</i> Returns <tt>false</tt> if <tt>[first,last)</tt> is empty. 
 <i>end note</i>]
</blockquote>

<p>
25.2.6 [alg.find.end]
</p>

<p>
what does this mean if <tt>[first2,last2)</tt> is empty?
</p>

<p>
I believe the wording suggests the algorithm should return
<tt>last1</tt> in this case, but am not 100% sure. Is this in fact the
correct result anyway? Surely an empty range should always match and the
naive expected result would be <tt>first1</tt>?
</p>

<p>
My proposed wording is a note to clarify the current semantic:
</p>

<p>
Add to p2 25.2.6 [alg.find.end]:
</p>

<blockquote>
[<i>Note:</i> Returns <tt>last1</tt> if <tt>[first2,last2)</tt> is
empty.  <i>end note</i>]
</blockquote>

<p>
I would prefer a normative wording treating empty ranges specially, but
do not believe we can change semantics at this point in the process,
unless existing implementations actually yield this result:
</p>

<p>
Alternative wording: (NOT a note)
</p>
<p>
Add to p2 25.2.6 [alg.find.end]:
</p>
<blockquote>
Returns <tt>first1</tt> if <tt>[first2,last2)</tt> is empty.
</blockquote>

<p>
25.2.7 [alg.find.first.of]
</p>

<p>
The phrasing seems precise when <tt>[first2, last2)</tt> is empty, but a small
note to confirm the reader's understanding might still help.
</p>

<p>
Add to p2 25.2.7 [alg.find.first.of]
</p>
<blockquote>
[<i>Note:</i> Returns <tt>last1</tt> if <tt>[first2,last2)</tt> is
empty.  <i>end note</i>]
</blockquote>

<p>
25.2.13 [alg.search]
</p>

<p>
What is the expected result if <tt>[first2, last2)</tt> is empty?
</p>

<p>
I believe the wording suggests the algorithm should return <tt>last1</tt> in this
case, but am not 100% sure. Is this in fact the correct result anyway? 
Surely an empty range should always match and the naive expected result
would be <tt>first1</tt>?
</p>

<p>
My proposed wording is a note to clarify the current semantic:
</p>

<p>
Add to p2 25.2.13 [alg.search]:
</p>

<blockquote>
[<i>Note:</i> Returns <tt>last1</tt> if <tt>[first2,last2)</tt> is
empty.  <i>end note</i>]
</blockquote>

<p>
Again, I would prefer a normative wording treating empty ranges
specially, but do not believe we can change semantics at this point in
the process, unless existing implementations actually yield this result:
</p>

<p>
Alternative wording: (NOT a note)
</p>
<p>
Add to p2 25.2.13 [alg.search]:
</p>

<blockquote>
Returns <tt>first1</tt> if <tt>[first2,last2)</tt> is empty.
</blockquote>

<p>
25.3.13 [alg.partitions]
</p>

<p>
Is an empty range partitioned or not?
</p>

<p>
Proposed wording:
</p>

<p>
Add to p1 25.3.13 [alg.partitions]:
</p>

<blockquote>
[<i>Note:</i> Returns <tt>true</tt> if <tt>[first,last)</tt> is empty. 
 <i>end note</i>]
</blockquote>

<p>
25.4.5.1 [includes]
</p>

<blockquote>
<i>Returns:</i> <tt>true</tt> if every element in the range
<tt>[first2,last2)</tt> is contained in the range
<tt>[first1,last1)</tt>. ...
</blockquote>

<p>
I really don't know what this means if <tt>[first2,last2)</tt> is empty.
I could loosely guess that this implies empty ranges always match, and
my proposed wording is to clarify exactly that:
</p>

<p>
Add to p1 25.4.5.1 [includes]:
</p>

<blockquote>
[<i>Note:</i> Returns <tt>true</tt> if <tt>[first2,last2)</tt> is empty.
 <i>end note</i>]
</blockquote>

<p>
25.4.6.2 [pop.heap]
</p>

<p>
The effects clause is invalid if the range <tt>[first,last)</tt> is empty, unlike
all the other heap alogorithms.  The should be called out in the
requirements.
</p>

<p>
Proposed wording:
</p>
<p>
Revise p2 25.4.6.2 [pop.heap]
</p>

<blockquote>
<i>Requires:</i> The range <tt>[first,last)</tt> shall be a valid
<ins>non-empty</ins> heap.
</blockquote>

<p>
[Editorial] Reverse order of 25.4.6.2 [pop.heap] p1 and p2.
</p>

<p>
25.4.7 [alg.min.max]
</p>

<p>
<tt>minmax_element</tt> does not clearly specify behaviour for an empty
range in the same way that <tt>min_element</tt> and <tt>max_element</tt> do.
</p>

<p>
Add to p31 25.4.7 [alg.min.max]:
</p>

<blockquote>
Returns <tt>make_pair(first, first)</tt> if <tt>first == last</tt>.
</blockquote>

<p>
25.4.8 [alg.lex.comparison]
</p>

<p>
The wording here seems quite clear, especially with the sample algorithm
implementation.  A note is recommended purely for consistency with the
rest of these issue resolutions:
</p>

<p>
Add to p1 25.4.8 [alg.lex.comparison]:
</p>

<blockquote>
[<i>Note:</i> An empty sequence is lexicographically less than any other
non-empty sequence, but not to another empty sequence.  <i>end note</i>]
</blockquote>

<p><i>[
2009-11-11 Howard changes Notes to Remarks and changed <tt>search</tt> to
return <tt>first1</tt> instead of <tt>last1</tt>.
]</i></p>


<p><i>[
2009-11-11 Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
Add to 25.2.1 [alg.all_of]:
</p>
<blockquote><ins>
<i>Remarks:</i> Returns <tt>true</tt> if <tt>[first,last)</tt> is empty. 
</ins></blockquote>

<p>
Add to 25.2.2 [alg.any_of]:
</p>

<blockquote><ins>
<i>Remarks:</i> Returns <tt>false</tt> if <tt>[first,last)</tt> is empty. 
</ins></blockquote>

<p>
Add to 25.2.3 [alg.none_of]:
</p>
<blockquote><ins>
<i>Remarks:</i> Returns <tt>true</tt> if <tt>[first,last)</tt> is empty. 
</ins></blockquote>

<p>
Add to 25.2.6 [alg.find.end]:
</p>
<blockquote><ins>
<i>Remarks:</i> Returns <tt>last1</tt> if <tt>[first2,last2)</tt> is
empty.
</ins></blockquote>

<p>
Add to 25.2.7 [alg.find.first.of]
</p>
<blockquote><ins>
<i>Remarks:</i> Returns <tt>last1</tt> if <tt>[first2,last2)</tt> is
empty.
</ins></blockquote>

<p>
Add to 25.2.13 [alg.search]:
</p>
<blockquote><ins>
<i>Remarks:</i> Returns <tt>first1</tt> if <tt>[first2,last2)</tt> is
empty.
</ins></blockquote>

<p>
Add to 25.3.13 [alg.partitions]:
</p>
<blockquote><ins>
<i>Remarks:</i> Returns <tt>true</tt> if <tt>[first,last)</tt> is empty. 
</ins></blockquote>

<p>
Add to 25.4.5.1 [includes]:
</p>
<blockquote><ins>
<i>Remarks:</i> Returns <tt>true</tt> if <tt>[first2,last2)</tt> is empty. 
</ins></blockquote>

<p>
Revise p2 25.4.6.2 [pop.heap]
</p>
<blockquote>
<i>Requires:</i> The range <tt>[first,last)</tt> shall be a valid
<ins>non-empty</ins> heap.
</blockquote>

<p>
[Editorial] 
</p>
<blockquote>
Reverse order of 25.4.6.2 [pop.heap] p1 and p2.
</blockquote>

<p>
Add to p35 25.4.7 [alg.min.max]:
</p>
<blockquote><pre>template&lt;class ForwardIterator, class Compare&gt;
  pair&lt;ForwardIterator, ForwardIterator&gt;
    minmax_element(ForwardIterator first, ForwardIterator last, Compare comp);
</pre>
<blockquote>
<i>Returns:</i> <tt>make_pair(m, M)</tt>, where <tt>m</tt> is the first iterator in
<tt>[first,last)</tt> such that no iterator in the range refers to a smaller
element, and where <tt>M</tt> is the last iterator in <tt>[first,last)</tt> such that no
iterator in the range refers to a larger element. 
<ins>Returns <tt>make_pair(first, first)</tt> if <tt>first == last</tt>.</ins>
</blockquote>
</blockquote>

<p>
Add to 25.4.8 [alg.lex.comparison]:
</p>
<blockquote><ins>
<i>Remarks:</i> An empty sequence is lexicographically less than any other
non-empty sequence, but not less than another empty sequence.
</ins></blockquote>






<hr>
<h3><a name="1206"></a>1206. Incorrect requires for <tt>move_backward</tt> and <tt>copy_backward</tt></h3>
<p><b>Section:</b> 25.3.2 [alg.move] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-09-13 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
25.3.2 [alg.move], p6 says:
</p>

<blockquote>
<pre>template&lt;class BidirectionalIterator1, class BidirectionalIterator2&gt;
  BidirectionalIterator2
    move_backward(BidirectionalIterator1 first,
                  BidirectionalIterator1 last,
                  BidirectionalIterator2 result);
</pre>
<blockquote>
<p>...</p>
<p>
<i>Requires:</i> <tt>result</tt> shall not be in the range
<tt>[first,last)</tt>.
</p>
</blockquote>
</blockquote>

<p>
This is essentially an "off-by-one" error.
</p>

<p>
When <tt>result == last</tt>, which
<em>is</em> allowed by this specification, then the range <tt>[first, last)</tt>
is being move assigned into the range <tt>[first, last)</tt>.  The <tt>move</tt>
(forward) algorithm doesn't allow self move assignment, and neither should
<tt>move_backward</tt>.  So <tt>last</tt> should be included in the range which
<tt>result</tt> can not be in.
</p>

<p>
Conversely, when <tt>result == first</tt>, which <em>is not</em> allowed by this
specification, then the range <tt>[first, last)</tt>
is being move assigned into the range <tt>[first - (last-first), first)</tt>.
I.e. into a <em>non-overlapping</em> range.  Therefore <tt>first</tt> should
not be included in the range which <tt>result</tt> can not be in.
</p>

<p>
The same argument applies to <tt>copy_backward</tt> though copy assigning elements
to themselves (<tt>result == last</tt>) should be harmless (though is disallowed
by <tt>copy</tt>).
</p>

<p><i>[
2010 Pittsburgh:  Moved to Ready.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
Change 25.3.2 [alg.move], p6:
</p>

<blockquote>
<pre>template&lt;class BidirectionalIterator1, class BidirectionalIterator2&gt;
  BidirectionalIterator2
    move_backward(BidirectionalIterator1 first,
                  BidirectionalIterator1 last,
                  BidirectionalIterator2 result);
</pre>
<blockquote>
<p>...</p>
<p>
<i>Requires:</i> <tt>result</tt> shall not be in the range
<tt><del>[</del><ins>(</ins>first,last<ins>]</ins><del>)</del></tt>.
</p>
</blockquote>
</blockquote>

<p>
Change 25.3.1 [alg.copy], p13:
</p>

<blockquote>
<pre>template&lt;class BidirectionalIterator1, class BidirectionalIterator2&gt;
  BidirectionalIterator2
    copy_backward(BidirectionalIterator1 first,
                  BidirectionalIterator1 last,
                  BidirectionalIterator2 result);
</pre>
<blockquote>
<p>...</p>
<p>
<i>Requires:</i> <tt>result</tt> shall not be in the range
<tt><del>[</del><ins>(</ins>first,last<ins>]</ins><del>)</del></tt>.
</p>
</blockquote>
</blockquote>





<hr>
<h3><a name="1207"></a>1207. Underspecified std::list operations?</h3>
<p><b>Section:</b> 23.3.4.4 [list.ops] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Loc Joly <b>Opened:</b> 2009-09-13 <b>Last modified:</b> 2010-11-24</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#list.ops">issues</a> in [list.ops].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It looks to me like some operations of <tt>std::list</tt>
(<tt>sort</tt>, <tt>reverse</tt>, <tt>remove</tt>, <tt>unique</tt> &amp;
<tt>merge</tt>) do not specify the validity of iterators, pointers &amp;
references to elements of the list after those operations. Is it implied
by some other text in the standard?
</p>

<p>
I believe <tt>sort</tt> &amp; <tt>reverse</tt> do not invalidating
anything, <tt>remove</tt> &amp; <tt>unique</tt> only invalidates what
refers to erased elements, <tt>merge</tt> does not invalidate anything
(with the same precision as <tt>splice</tt> for elements who changed of
container). Are those assumptions correct ?
</p>

<p><i>[
2009-12-08 Jonathan Wakely adds:
]</i></p>


<blockquote>
<p>
23.2.1 [container.requirements.general] paragraph 11 says iterators
aren't invalidated unless specified, so I don't think it needs to be repeated on
every function that doesn't invalidate iterators. <tt>list::unique</tt> says it
"eliminates" elements, that should probably be "erases" because IMHO that term
is used elsewhere and so makes it clearer that iterators to the erased elements
are invalidated.
</p>

<p>
<tt>list::merge</tt> coud use the same wording as <tt>list::splice</tt> w.r.t
iterators and references to moved elements.
</p>

<p>
Suggested resolution:
</p>

<p>
In 23.3.4.4 [list.ops] change paragraph 19
</p>

<blockquote><pre>                                 void unique();
template &lt;class BinaryPredicate&gt; void unique(BinaryPredicate binary_pred);
</pre>
<blockquote>
<i>Effects:</i> <del>Eliminates</del> <ins>Erases</ins> all but the first
element from every consecutive group ...
</blockquote>
</blockquote>

<p>
Add to the end of paragraph 23
</p>

<blockquote><pre>void                          merge(list&lt;T,Allocator&gt;&amp;&amp; x);
template &lt;class Compare&gt; void merge(list&lt;T,Allocator&gt;&amp;&amp; x, Compare comp);
</pre>
<blockquote>
<p>...</p>
<p>
<i>Effects:</i> ... that is, for every iterator <tt>i</tt>, in the range other
than the first, the condition <tt>comp(*i, *(i - 1)</tt> will be false.
<ins>Pointers and references to the moved elements of <tt>x</tt> now refer to
those same elements but as members of <tt>*this</tt>. Iterators referring to the
moved elements will continue to refer to their elements, but they now behave as
iterators into <tt>*this</tt>, not into <tt>x</tt>.</ins>
</p>
</blockquote>
</blockquote>
</blockquote>

<p><i>[
2009-12-12 Loc adds wording.
]</i></p>


<p><i>[
2010-02-10 Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>


<p><i>[
2010-02-10 Alisdair opens:
]</i></p>


<blockquote>
<p>
I object to the current resolution of #1207.  I believe it is overly strict with
regard to <tt>list</tt> end iterators, being the only mutating operations to
require such stability.
</p>

<p>
More importantly, the same edits need to be applied to <tt>forward_list</tt>,
which uses slightly different words to describe some of these operations so may
require subtly different edits (not checked.)
</p>

<p>
I am prepared to pick up the <tt>end()</tt> iterator as a separate (new) issue,
as part of the FCD ballot review (BSI might tell me 'no' first ;~) but I do want
to see <tt>forward_list</tt> adjusted at the same time.
</p>
</blockquote>

<p><i>[
2010-03-28 Daniel adds the first 5 bullets in an attempt to address Alisdair's
concerns.
]</i></p>



<p><i>[
2010 Rapperswil:
]</i></p>


<blockquote>
The wording looks good.

Move to Tentatively Ready.
</blockquote>

<p><i>[
Adopted at 2010-11 Batavia
]</i></p>




<p><b>Proposed resolution:</b></p>

<ol>

<li>
<p>
Change 23.3.3.5 [forwardlist.ops]/12 as indicated:
</p>

<blockquote><pre>void remove(const T&amp; value);
template &lt;class Predicate&gt; void remove_if(Predicate pred);
</pre>

<blockquote>
12 <i>Effects:</i> Erases all the elements in the list referred by a list
iterator <tt>i</tt> for which the following conditions hold: <tt>*i == value
(for remove()), pred(*i)</tt> is true (<tt>for remove_if()</tt>). This operation
shall be stable: the relative order of the elements that are not removed is the
same as their relative order in the original list. <ins>Invalidates only the
iterators and references to the erased elements.</ins>
</blockquote>
</blockquote>
</li>

<li>
<p>
Change 23.3.3.5 [forwardlist.ops]/15 as indicated:
</p>

<blockquote><pre>template &lt;class BinaryPredicate&gt; void unique(BinaryPredicate pred);
</pre>

<blockquote>
15 <i>Effects:</i>: <del>Eliminates</del><ins>Erases</ins> all but the first
element from every consecutive group of equal elements referred to by the
iterator <tt>i</tt> in the range <tt>[first + 1,last)</tt> for which <tt>*i ==
*(i-1)</tt> (for the version with no arguments) or <tt>pred(*i, *(i - 1))</tt>
(for the version with a predicate argument) holds. <ins>Invalidates only the
iterators and references to the erased elements.</ins>
</blockquote>
</blockquote>
</li>

<li>
<p>
Change 23.3.3.5 [forwardlist.ops]/19 as indicated:
</p>

<blockquote><pre>void merge(forward_list&lt;T,Allocator&gt;&amp;&amp; x);
template &lt;class Compare&gt; void merge(forward_list&lt;T,Allocator&gt;&amp;&amp; x, Compare comp)
</pre>

<blockquote>
<p>
[..]
</p>

<p>
19 <i>Effects:</i>: Merges <tt>x</tt> into <tt>*this</tt>. This operation shall
be stable: for equivalent elements in the two lists, the elements from
<tt>*this</tt> shall always precede the elements from <tt>x</tt>. <tt>x</tt> is
empty after the merge. If an exception is thrown other than by a comparison
there are no effects. <ins>Pointers and references to the moved elements of
<tt>x</tt> now refer to those same elements but as members of <tt>*this</tt>.
Iterators referring to the moved elements will continue to refer to their
elements, but they now behave as iterators into <tt>*this</tt>, not into
<tt>x</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>

<li>
<p>
Change 23.3.3.5 [forwardlist.ops]/22 as indicated:
</p>

<blockquote><pre>void sort();
template &lt;class Compare&gt; void sort(Compare comp);
</pre>

<blockquote>
<p>
[..]
</p>

<p>
22 <i>Effects:</i>: Sorts the list according to the <tt>operator&lt;</tt> or the
<tt>comp</tt> function object. This operation shall be stable: the relative
order of the equivalent elements is preserved. If an exception is thrown the
order of the elements in <tt>*this</tt> is unspecified. <ins>Does not affect the
validity of iterators and references.</ins>
</p>
</blockquote>
</blockquote>
</li>

<li>
<p>
Change 23.3.3.5 [forwardlist.ops]/24 as indicated:
</p>

<blockquote><pre>void reverse();
</pre>

<blockquote>
24 <i>Effects:</i>: Reverses the order of the elements in the list. <ins>Does
not affect the validity of iterators and references.</ins>
</blockquote>
</blockquote>
</li>

<li>
<p>
Change 23.3.4.4 [list.ops], p15:
</p>

<blockquote><pre>                           void remove(const T&amp; value);
template &lt;class Predicate&gt; void remove_if(Predicate pred);
</pre>
<blockquote>
<i>Effects:</i> Erases all the elements in the list referred by a list iterator
<tt>i</tt> for which the following conditions hold: <tt>*i == value, pred(*i) !=
false</tt>.  <ins>Invalidates only the iterators and references to the erased
elements.</ins>
</blockquote>
</blockquote>
</li>

<li>
<p>
Change 23.3.4.4 [list.ops], p19:
</p>

<blockquote><pre>                                 void unique();
template &lt;class BinaryPredicate&gt; void unique(BinaryPredicate binary_pred);
</pre>
<blockquote>
<i>Effects:</i> <del>Eliminates</del> <ins>Erases</ins> all but the first
element from every consecutive group of equal elements referred to by the
iterator <tt>i</tt> in the range <tt>[first + 1,last)</tt> for which <tt>*i ==
*(i-1)</tt> (for the version of <tt>unique</tt> with no arguments) or
<tt>pred(*i, *(i - 1))</tt> (for the version of <tt>unique</tt> with a predicate
argument) holds. <ins>Invalidates only the iterators and references to the
erased elements.</ins>
</blockquote>
</blockquote>
</li>

<li>
<p>
Change 23.3.4.4 [list.ops], p23:
</p>

<blockquote><pre>void                          merge(list&lt;T,Allocator&gt;&amp;&amp; x);
template &lt;class Compare&gt; void merge(list&lt;T,Allocator&gt;&amp;&amp; x, Compare comp);
</pre>
<blockquote>
<i>Effects:</i> If <tt>(&amp;x == this)</tt> does nothing; otherwise, merges the
two sorted ranges <tt>[begin(), end())</tt> and <tt>[x.begin(), x.end())</tt>.
The result is a range in which the elements will be sorted in non-decreasing
order according to the ordering defined by <tt>comp</tt>; that is, for every
iterator <tt>i</tt>, in the range other than the first, the condition
<tt>comp(*i, *(i - 1)</tt> will be false.
<ins>Pointers and references to the moved elements of <tt>x</tt> now refer to
those same elements but as members of <tt>*this</tt>. Iterators referring to the
moved elements will continue to refer to their elements, but they now behave as
iterators into <tt>*this</tt>, not into <tt>x</tt>.</ins>
</blockquote>
</blockquote>
</li>

<li>
<p>
Change 23.3.4.4 [list.ops], p26:
</p>

<blockquote><pre>void reverse();
</pre>
<blockquote>
<i>Effects:</i> Reverses the order of the elements in the list.
<ins>Does not affect the validity of iterators and references.</ins>
</blockquote>
</blockquote>
</li>

<li>
<p>
Change 23.3.4.4 [list.ops], p30:
</p>

<blockquote><pre>                         void sort();
template &lt;class Compare&gt; void sort(Compare comp);
</pre>
<blockquote>
<i>Effects:</i> Sorts the list according to the <tt>operator&lt;</tt> or a
<tt>Compare</tt> function object.
<ins>Does not affect the validity of iterators and references.</ins>
</blockquote>
</blockquote>
</li>

</ol>






<hr>
<h3><a name="1208"></a>1208. valarray initializer_list constructor has incorrect effects</h3>
<p><b>Section:</b> 26.6.2.1 [valarray.cons] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-09-23 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#valarray.cons">issues</a> in [valarray.cons].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
26.6.2.1 [valarray.cons] says:
</p>

<blockquote>
<pre>valarray(initializer_list&lt;T&gt; il);
</pre>
<blockquote>
<i>Effects:</i> Same as <tt>valarray(il.begin(), il.end())</tt>.
</blockquote>
</blockquote>

<p>
But there is no <tt>valarray</tt> constructor taking two <tt>const T*</tt>.
</p>

<p><i>[
2009-10-29 Howard:
]</i></p>


<blockquote>
Moved to Tentatively Ready after 6 positive votes on c++std-lib.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 26.6.2.1 [valarray.cons]:
</p>

<blockquote>
<pre>valarray(initializer_list&lt;T&gt; il);
</pre>
<blockquote>
<i>Effects:</i> Same as <tt>valarray(il.begin(), il.<del>end</del><ins>size</ins>())</tt>.
</blockquote>
</blockquote>





<hr>
<h3><a name="1209"></a>1209. match_results should be moveable</h3>
<p><b>Section:</b> 28.10.1 [re.results.const] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2009-09-15 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In Working Draft
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2914.pdf">N2914</a>,
<tt>match_results</tt> lacks a move constructor and move
assignment operator. Because it owns dynamically allocated memory, it
should be moveable.
</p>

<p>
As far as I can tell, this isn't tracked by an active issue yet; Library
Issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#723">723</a> doesn't talk about <tt>match_results</tt>.
</p>

<p><i>[
2009-09-21 Daniel provided wording.
]</i></p>


<p><i>[
2009-11-18: Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>



<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>
Add the following member declarations to 28.10 [re.results]/3:
</p>

<blockquote><pre>// 28.10.1, construct/copy/destroy:
explicit match_results(const Allocator&amp; a = Allocator());
match_results(const match_results&amp; m);
<ins>match_results(match_results&amp;&amp; m);</ins>
match_results&amp; operator=(const match_results&amp; m);
<ins>match_results&amp; operator=(match_results&amp;&amp; m);</ins>
~match_results();
</pre></blockquote>
</li>

<li>
<p>
Add the following new prototype descriptions to 28.10.1 [re.results.const]
using the table numbering of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n3000.pdf">N3000</a>
(referring to the table titled "<tt>match_results</tt> assignment operator effects"):
</p>

<blockquote>
<pre>match_results(const match_results&amp; m);
</pre>

<blockquote>
4 <i>Effects:</i> Constructs an object of class <tt>match_results</tt>, as a
copy of <tt>m</tt>.
</blockquote>

<pre><ins>match_results(match_results&amp;&amp; m);</ins>
</pre>

<blockquote>
<p>
<ins>5 <i>Effects:</i> Move-constructs an object of class <tt>match_results</tt>
from <tt>m</tt> satisfying the same postconditions as Table 131. Additionally
the stored <tt>Allocator</tt> value is move constructed from <tt>m.get_allocator()</tt>.
After the initialization of <tt>*this</tt> sets <tt>m</tt> to an unspecified but valid
state.</ins>
</p>

<p>
<ins>6 <i>Throws:</i> Nothing if the allocator's move constructor throws nothing.</ins>
</p>
</blockquote>

<pre>match_results&amp; operator=(const match_results&amp; m);
</pre>

<blockquote>
7 <i>Effects:</i> Assigns <tt>m</tt> to <tt>*this</tt>. The postconditions of this function are
indicated in Table 131.
</blockquote>

<pre><ins>match_results&amp; operator=(match_results&amp;&amp; m);</ins>
</pre>

<blockquote>
<p>
<ins>8 <i>Effects:</i> Move-assigns <tt>m</tt> to <tt>*this</tt>. The postconditions of this
function are indicated in Table 131. After the assignment, <tt>m</tt> is in
a valid but unspecified state.</ins>
</p>

<p>
<ins>9 <i>Throws:</i> Nothing.</ins>
</p>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="1216"></a>1216. LWG 1066 Incomplete?</h3>
<p><b>Section:</b> 18.8.6 [except.nested] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2009-09-25 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#except.nested">issues</a> in [except.nested].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
LWG <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1066">1066</a> adds <tt>[[noreturn]]</tt> to a bunch of things.
It doesn't add it to <tt>rethrow_nested()</tt>, which seems like an obvious
candidate. I've made the changes indicated in the issue, and haven't
changed <tt>rethrow_nested()</tt>.
</p>

<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote>
Move to Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add <tt>[[noreturn]]</tt> to <tt>rethrow_nested()</tt> in 18.8.6 [except.nested].
</p>





<hr>
<h3><a name="1218"></a>1218. mutex destructor synchronization</h3>
<p><b>Section:</b> 30.4.1 [thread.mutex.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Jeffrey Yasskin <b>Opened:</b> 2009-09-30 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.mutex.requirements">issues</a> in [thread.mutex.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
If an object <tt>*o</tt> contains a mutex <tt>mu</tt> and a
correctly-maintained reference count <tt>c</tt>, is the following code
safe?
</p>

<blockquote><pre>o-&gt;mu.lock();
bool del = (--(o-&gt;c) == 0);
o-&gt;mu.unlock();
if (del) { delete o; }
</pre></blockquote>

<p>
If the implementation of <tt>mutex::unlock()</tt> can touch the mutex's
memory after the moment it becomes free, this wouldn't be safe, and
"Construction and destruction of an object of a Mutex type need not be
thread-safe" 30.4.1 [thread.mutex.requirements] may imply that
it's not safe. Still, it's useful to allow mutexes to guard reference
counts, and if it's not allowed, users are likely to write bugs.
</p>

<p><i>[
2009-11-18: Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>



<p><b>Proposed resolution:</b></p>
<ul>
<li>
<p>
Add a new paragraph after 30.4.1.2.1 [thread.mutex.class] p1:
</p>
<blockquote>
<p>
1 The class <tt>mutex</tt> provides a non-recursive mutex ...
</p>
<p><ins>
[<i>Note:</i> After a thread <tt>A</tt> has called <tt>unlock()</tt>, releasing
the mutex, it is possible for another thread <tt>B</tt> to lock the same mutex,
observe that it is no longer in use, unlock and destroy it, before thread
<tt>A</tt> appears to have returned from its unlock call. Implementations are
required to handle such scenarios correctly, as long as thread <tt>A</tt>
doesn't access the mutex after the unlock call returns. These cases typically
occur when a reference-counted object contains a mutex that is used to protect
the reference count.  <i>end note</i>]
</ins></p>
</blockquote>
</li>

</ul>





<hr>
<h3><a name="1220"></a>1220. What does condition_variable wait on?</h3>
<p><b>Section:</b> 30.5 [thread.condition] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Jeffrey Yasskin <b>Opened:</b> 2009-09-30 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.condition">issues</a> in [thread.condition].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
"Class <tt>condition_variable</tt> provides a condition variable that can only
wait on an object of type <tt>unique_lock</tt>" should say "...object of type
<tt>unique_lock&lt;mutex&gt;</tt>"
</p>

<p><i>[
2009-11-06 Howard adds:
]</i></p>


<blockquote>
Moved to Tentatively Ready after 5 positive votes on c++std-lib.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 30.5 [thread.condition], p1:
</p>

<blockquote>
Condition variables provide synchronization primitives used to block a
thread until notified by some other thread that some condition is met or
until a system time is reached. Class <tt>condition_variable</tt>
provides a condition variable that can only wait on an object of type
<tt>unique_lock<ins>&lt;mutex&gt;</ins></tt>, allowing maximum
efficiency on some platforms. Class <tt>condition_variable_any</tt>
provides a general condition variable that can wait on objects of
user-supplied lock types.
</blockquote>





<hr>
<h3><a name="1221"></a>1221. condition_variable wording</h3>
<p><b>Section:</b> 30.5.1 [thread.condition.condvar] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Jeffrey Yasskin <b>Opened:</b> 2009-09-30 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.condition.condvar">issues</a> in [thread.condition.condvar].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
30.5.1 [thread.condition.condvar] says:
</p>

<blockquote>
<pre>~condition_variable();
</pre>
<blockquote>
<i>Precondition:</i> There shall be no thread blocked on <tt>*this</tt>.
[<i>Note:</i> That is, all threads shall have been notified; they may
subsequently block on the lock specified in the wait. Beware that
destroying a <tt>condition_variable</tt> object while the corresponding
predicate is <tt>false</tt> is likely to lead to undefined behavior.
 <i>end note</i>]
</blockquote>
</blockquote>

<p>
The text hasn't introduced the notion of a "corresponding predicate"
yet.
</p>

<p><i>[
2010-02-11 Anthony provided wording.
]</i></p>


<p><i>[
2010-02-12 Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
Modify 30.5.1 [thread.condition.condvar]p4 as follows:
</p>

<blockquote>
<pre>~condition_variable();</pre>
<blockquote>
4 <i>Precondition:</i> There shall be no thread blocked on <tt>*this</tt>.
[<i>Note:</i> That is, all threads shall have been notified; they may
subsequently block on the lock specified in the wait. <del>Beware that
destroying a <tt>condition_variable</tt> object while the corresponding
predicate is false is likely to lead to undefined behavior.</del> <ins>The user
must take care to ensure that no threads wait on <tt>*this</tt> once the
destructor has been started, especially when the waiting threads are calling the
wait functions in a loop or using the overloads of <tt>wait</tt>,
<tt>wait_for</tt> or <tt>wait_until</tt> that take a predicate.</ins> 
<i>end note</i>]
</blockquote>
</blockquote>





<hr>
<h3><a name="1222"></a>1222. condition_variable incorrect effects for exception safety</h3>
<p><b>Section:</b> 30.5 [thread.condition] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Jeffrey Yasskin <b>Opened:</b> 2009-09-30 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.condition">issues</a> in [thread.condition].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
30.5.1 [thread.condition.condvar] says:
</p>

<blockquote>
<pre>void wait(unique_lock&lt;mutex&gt;&amp; lock);
</pre>
<blockquote>
<p>...</p>
<p>
<i>Effects:</i>
</p>
<ul>
<li>...</li>
<li>
If the function exits via an exception, <tt>lock.unlock()</tt> shall be
called prior to exiting the function scope.
</li>
</ul>
</blockquote>
</blockquote>

<p>
Should that be <tt>lock.lock()</tt>?
</p>

<p><i>[
2009-11-17 Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>



<p><b>Proposed resolution:</b></p>

<p>
Change 30.5.1 [thread.condition.condvar] p10:
</p>

<blockquote>
<pre>void wait(unique_lock&lt;mutex&gt;&amp; lock);
</pre>
<blockquote>
<p>...</p>
<p>
<i>Effects:</i>
</p>
<ul>
<li>...</li>
<li>
If the function exits via an exception, <tt>lock.<del>un</del>lock()</tt> shall be
called prior to exiting the function scope.
</li>
</ul>
</blockquote>
</blockquote>

<p>
And make a similar change in p16, and in 30.5.2 [thread.condition.condvarany],
p8 and p13.
</p>






<hr>
<h3><a name="1227"></a>1227. <tt>&lt;bitset&gt;</tt> synopsis overspecified</h3>
<p><b>Section:</b> 20.5 [template.bitset] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Bo Persson <b>Opened:</b> 2009-10-05 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#template.bitset">issues</a> in [template.bitset].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The resolutions to some library defect reports, like <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1178">1178</a>
requires that <tt>#includes</tt> in each synopsis should be taken
literally. This means that the <tt>&lt;bitset&gt;</tt> header now
<em>must</em> include <tt>&lt;stdexcept&gt;</tt>, even though none of the
exceptions are mentioned in the <tt>&lt;bitset&gt;</tt> header.
</p>
<p>
Many other classes are required to throw exceptions like
<tt>invalid_argument</tt> and <tt>out_of_range</tt>, without explicitly
including <tt>&lt;stdexcept&gt;</tt> in their synopsis. It is totally
possible for implementations to throw the needed exceptions from utility
functions, whose implementations are not visible in the headers.
</p>
<p>
I propose that <tt>&lt;stdexcept&gt;</tt> is removed from the
<tt>&lt;bitset&gt;</tt> header.
</p>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Moved to Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 20.5 [template.bitset]:
</p>

<blockquote><pre>#include &lt;cstddef&gt;        // for size_t
#include &lt;string&gt;
<del>#include &lt;stdexcept&gt;      // for invalid_argument,</del>
                          <del>// out_of_range, overflow_error</del>
#include &lt;iosfwd&gt;         // for istream, ostream
namespace std {
...
</pre></blockquote>





<hr>
<h3><a name="1231"></a>1231. <tt>weak_ptr</tt> comparisons incompletely resolved</h3>
<p><b>Section:</b> 20.9.10.3.5 [util.smartptr.weak.obs] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2009-10-10 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2637.pdf">n2637</a>
paper suggested several updates of the ordering semantics of
<tt>shared_ptr</tt>
and <tt>weak_ptr</tt>, among those the explicit comparison operators of <tt>weak_ptr</tt> were
removed/deleted, instead a corresponding functor <tt>owner_less</tt> was added.
The problem
is that
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2637.pdf">n2637</a>
did not clearly enough specify, how the previous wording
parts describing
the comparison semantics of <tt>weak_ptr</tt> should be removed.
</p>

<p><i>[
2009-11-06 Howard adds:
]</i></p>


<blockquote>
Moved to Tentatively Ready after 5 positive votes on c++std-lib.
</blockquote>



<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>
Change 20.9.10.3 [util.smartptr.weak]/2 as described, the intention is to fix
the now no longer valid
requirement that <tt>weak_ptr</tt> is <tt>LessComparable</tt> [Note the deleted comma]:
</p>

<blockquote>
Specializations of <tt>weak_ptr</tt> shall be <tt>CopyConstructible</tt><del>,</del>
<ins>and</ins> <tt>CopyAssignable</tt>,
<del>and <tt>LessThanComparable</tt>,</del> allowing their use in standard containers.
</blockquote>
</li>

<li>
<p>
In 20.9.10.3.5 [util.smartptr.weak.obs] remove the paragraphs 9-11 including prototype:
</p>

<blockquote>
<del>template&lt;class T, class U&gt; bool operator&lt;(const weak_ptr&lt;T&gt;&amp; a, const weak_ptr&lt;U&gt;&amp; b);</del>

<p>
<del><i>Returns:</i> an unspecified value such that</del>
</p>
<ul>
<li>
<del><tt>operator&lt;</tt> is a strict weak ordering as described in 25.4;</del>
</li>
<li>
<del>under the equivalence relation defined by <tt>operator&lt;</tt>, <tt>!(a
&lt; b) &amp;&amp; !(b &lt; a)</tt>, two <tt>weak_ptr</tt> instances are
equivalent if and only if they share ownership or are both empty.</del>
</li>
</ul>

<p>
<del><i>Throws:</i> nothing.</del>
</p>

<p>
<del>[<i>Note:</i> Allows <tt>weak_ptr</tt> objects to be used as keys in associative
containers.  <i>end note</i>]</del>
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="1234"></a>1234. "Do the right thing" and NULL</h3>
<p><b>Section:</b> 23.2.3 [sequence.reqmts] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2009-10-09 <b>Last modified:</b> 2010-11-24</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#sequence.reqmts">issues</a> in [sequence.reqmts].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
On g++ 4.2.4 (x86_64-linux-gnu), the following file gives a compile
error:
</p>

<blockquote><pre>#include &lt;vector&gt;
void foo() { std::vector&lt;int*&gt; v(500l, NULL); }
</pre></blockquote>

<p>
Is this supposed to work? 
</p>

<p>
The issue: if <tt>NULL</tt> happens to be defined as <tt>0l</tt>, this is an invocation of
the constructor with two arguments of the same integral type.
23.2.3 [sequence.reqmts]/14
(<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3035.pdf">N3035</a>)
says that this will behave as if the the
overloaded constructor
</p>

<blockquote><pre>X(size_type, const value_type&amp; = value_type(),
  const allocator_type&amp; = allocator_type())
</pre></blockquote>

<p>
were called instead, with the arguments
<tt>static_cast&lt;size_type&gt;(first)</tt>, <tt>last</tt> and
<tt>alloc</tt>, respectively. However, it does not say whether this
actually means invoking that constructor with the exact textual form of
the arguments as supplied by the user, or whether the standard permits
an implementation to invoke that constructor with variables of the same
type and value as what the user passed in. In most cases this is a
distinction without a difference. In this particular case it does make a
difference, since one of those things is a null pointer constant and the
other is not.
</p>

<p>
Note that an implementation based on forwarding functions will use the
latter interpretation.
</p>

<p><i>[
2010 Pittsburgh:  Moved to Open.
]</i></p>


<p><i>[
2010-03-19 Daniel provides wording.
]</i></p>


<blockquote>
<ul>
<li>
Adapts the numbering used in the discussion to the recent working paper
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3035.pdf">N3035</a>.
</li>

<li>
Proposes a resolution that requires implementations to use sfinae-like means to
possibly filter away the too generic template c'tor. In fact this resolution is
equivalent to that used for the <tt>pair-NULL</tt> problem (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#811">811</a>),
the only difference is, that issue 1234 was already a C++03 problem.
</li>
</ul>

<p>
This issue can be considered as a refinement of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#438">438</a>.
</p>

</blockquote>

<p><i>[
Post-Rapperswil
]</i></p>


<p>
Wording was verified to match with the most recent WP. Jonathan Wakely and Alberto Barbati observed that the current 
WP has a defect that should be fixed here as well: The functions signatures <tt>fx1</tt> and <tt>fx3</tt> are 
incorrectly referring to <tt>iterator</tt> instead of <tt>const_iterator</tt>.
</p>

<blockquote>
Moved to Tentatively Ready with revised wording after 7 positive votes on c++std-lib.
</blockquote>

<p><i>[
Adopted at 2010-11 Batavia
]</i></p>




<p><b>Proposed resolution:</b></p>

 
<p>
Change 23.2.3 [sequence.reqmts]/14+15 as indicated:
</p>

<blockquote>
<p>
14 For every sequence container defined in this Clause and in Clause 21:
</p>

<ul>
<li>
<p>
If the constructor
</p>

<blockquote><pre>template &lt;class InputIterator&gt;
X(InputIterator first, InputIterator last,
  const allocator_type&amp; alloc = allocator_type())

</pre></blockquote>

<p>
is called with a type <tt>InputIterator</tt> that does not qualify as an input
iterator, then the constructor <ins>shall not participate in overload
resolution.</ins><del>will
behave as if the overloaded constructor:</del>
</p>

<blockquote><pre><del>
X(size_type, const value_type&amp; = value_type(),
  const allocator_type&amp; = allocator_type())
</del></pre></blockquote>

<p>
<del>were called instead, with the arguments
<tt>static_cast&lt;size_type&gt;(first)</tt>, <tt>last</tt> and <tt>alloc</tt>,
respectively</del>.
</p>
</li>

<li>

<p>
If the member functions of the forms:
</p>

<blockquote><pre>template &lt;class InputIterator&gt; <i>// such as insert()</i>
rt fx1(<ins>const_</ins>iterator p, InputIterator first, InputIterator last);

template &lt;class InputIterator&gt; <i>// such as append(), assign()</i>
rt fx2(InputIterator first, InputIterator last);

template &lt;class InputIterator&gt; <i>// such as replace()</i>
rt fx3(<ins>const_</ins>iterator i1, <ins>const_</ins>iterator i2, InputIterator first, InputIterator last);
</pre></blockquote>

<p>
are called with a type <tt>InputIterator</tt> that does not qualify as an input
iterator, then these functions <ins>shall not participate in overload
resolution.</ins><del>will behave as if the overloaded member functions:</del>
</p>

<blockquote><pre><del>rt fx1(iterator, size_type, const value_type&amp;);</del>

<del>rt fx2(size_type, const value_type&amp;);</del>

<del>rt fx3(iterator, iterator, size_type, const value_type&amp;);</del>
</pre></blockquote>

<p>
<del>were called instead, with the same arguments.</del>
</p>
</li>

</ul>

<p><del>
15 In the previous paragraph the alternative binding will fail if <tt>first</tt>
is not implicitly convertible to <tt>X::size_type</tt> or if <tt>last</tt> is
not implicitly convertible to <tt>X::value_type</tt>.
</del></p>
</blockquote>






<hr>
<h3><a name="1237"></a>1237. Constrained error_code/error_condition members</h3>
<p><b>Section:</b> 19.5 [syserr] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2009-10-14 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#syserr">issues</a> in [syserr].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I'm just reflecting on the now SFINAE-constrained constructors
and assignment operators of <tt>error_code</tt> and <tt>error_condition</tt>:
</p>
<p>
These are the <em>only</em> library components that are pro-actively
announcing that they are using <tt>std::enable_if</tt> as constraining tool,
which has IMO several disadvantages:
</p>

<ol>
<li>
<p>
With the availability of template default arguments and
decltype, using <tt>enable_if</tt> in C++0x standard library, seems
unnecessary restricting implementation freedom. E.g. there
should be not need for a useless specification of a dummy
default function argument, which only confuses the reader.
A more reasonable implementation could e.g. be
</p>

<blockquote><pre>template &lt;class ErrorCodeEnum
 class = typename enable_if&lt;is_error_code_enum&lt;ErrorCodeEnum&gt;::value&gt;::type&gt;
error_code(ErrorCodeEnum e);
</pre></blockquote>

<p>
As currently specified, the function signatures are so unreadable,
that errors quite easily happen, see e.g. <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1229">1229</a>.
</p>
</li>

<li>
<p>
We have a <em>lot</em> of constrained functions in other places, that
now have a standard phrase that is easily understandable:
</p>

<blockquote>
<i>Remarks:</i> This constructor/function shall participate in overload
resolution if and only if X.
</blockquote>

<p>
where X describes the condition. Why should these components deviate?
</p>
</li>

<li>
<p>
If <tt>enable_if</tt> would <em>not</em> be explicitly specified, the standard library
is much better prepared for the future. It would also be possible, that
libraries with partial support for not-yet-standard-concepts could provide
a much better diagnostic as is possible with <tt>enable_if</tt>. This again
would allow for experimental concept implementations in the wild,
which as a result would make concept standardization a much more
natural thing, similar to the way as templates were standardized
in C++.
</p>

<p>
In summary: I consider it as a library defect that <tt>error_code</tt> and
<tt>error_condition</tt> explicitly require a dependency to <tt>enable_if</tt> and
do limit implementation freedom and I volunteer to prepare a
corresponding resolution.
</p>
</li>
</ol>

<p><i>[
2009-10-18 Beman adds:
]</i></p>


<blockquote>
I support this proposed resolution, and thank Daniel for writing it up.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Moved to Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p><i>[
Should this resolution be accepted, I recommend to resolve <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1229">1229</a> as NAD
]</i></p>


<ol>
<li>
<p>
In 19.5.2.1 [syserr.errcode.overview]/1, class <tt>error_code</tt>,
change as indicated:
</p>

<blockquote><pre>// 19.5.2.2 constructors:
error_code();
error_code(int val, const error_category&amp; cat);
template &lt;class ErrorCodeEnum&gt;
  error_code(ErrorCodeEnum e<del>,
    typename enable_if&lt;is_error_code_enum&lt;ErrorCodeEnum&gt;::value&gt;::type * = 0</del>);

// 19.5.2.3 modifiers:
void assign(int val, const error_category&amp; cat);
template &lt;class ErrorCodeEnum&gt;
  <del>typename enable_if&lt;is_error_code_enum&lt;ErrorCodeEnum&gt;::value&gt;::type</del><ins>error_code</ins>&amp;
    operator=(ErrorCodeEnum e);
void clear();
</pre></blockquote>
</li>

<li>
<p>
Change 19.5.2.2 [syserr.errcode.constructors] around the prototype before p. 7:
</p>

<blockquote><pre>template &lt;class ErrorCodeEnum&gt;
error_code(ErrorCodeEnum e<del>,
  typename enable_if&lt;is_error_code_enum&lt;ErrorCodeEnum&gt;::value&gt;::type * = 0</del>);
</pre>
<blockquote>
<p>
<ins><i>Remarks:</i> This constructor shall not participate in overload
resolution, unless
<tt>is_error_code_enum&lt;ErrorCodeEnum&gt;::value == true</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>

<li>
<p>
Change 19.5.2.3 [syserr.errcode.modifiers] around the prototype before p. 3:
</p>

<blockquote><pre>template &lt;class ErrorCodeEnum&gt;
  <del>typename enable_if&lt;is_error_code_enum&lt;ErrorCodeEnum&gt;::value&gt;::type</del><ins>error_code</ins>&amp;
    operator=(ErrorCodeEnum e);
</pre>

<blockquote>
<ins><i>Remarks:</i> This operator shall not participate in overload resolution, unless
<tt>is_error_code_enum&lt;ErrorCodeEnum&gt;::value == true</tt>.</ins>
</blockquote>
</blockquote>
</li>

<li>
<p>
In 19.5.3.1 [syserr.errcondition.overview]/1, class <tt>error_condition</tt>, change
as indicated:
</p>

<blockquote><pre>// 19.5.3.2 constructors:
error_condition();
error_condition(int val, const error_category&amp; cat);
template &lt;class ErrorConditionEnum&gt;
  error_condition(ErrorConditionEnum e<del>,
    typename enable_if&lt;is_error_condition_enum&lt;ErrorConditionEnum&gt;::type* = 0</del>);

// 19.5.3.3 modifiers:
void assign(int val, const error_category&amp; cat);
template&lt;<del>typename</del><ins>class</ins> ErrorConditionEnum&gt;
  <del>typename enable_if&lt;is_error_condition_enum&lt;ErrorConditionEnum&gt;, error_code&gt;::type</del><ins>error_condition</ins> &amp;
    operator=( ErrorConditionEnum e );
void clear();
</pre></blockquote>
</li>

<li>
<p>
Change 19.5.3.2 [syserr.errcondition.constructors] around the
prototype before p. 7:
</p>

<blockquote><pre>template &lt;class ErrorConditionEnum&gt;
  error_condition(ErrorConditionEnum e<del>,
    typename enable_if&lt;is_error_condition_enum&lt;ErrorConditionEnum&gt;::value&gt;::type* = 0</del>);
</pre>
<blockquote>
<ins><i>Remarks:</i> This constructor shall not participate in overload
resolution, unless
<tt>is_error_condition_enum&lt;ErrorConditionEnum&gt;::value == true</tt>.</ins>
</blockquote>
</blockquote>
</li>

<li>
<p>
Change 19.5.3.3 [syserr.errcondition.modifiers] around the
prototype before p. 3:
</p>

<blockquote><pre>template &lt;class ErrorConditionEnum&gt;
  <del>typename enable_if&lt;is_error_condition_enum&lt;ErrorConditionEnum&gt;::value&gt;::type</del><ins>error_condition</ins>&amp;
    operator=(ErrorConditionEnum e);
</pre>

<blockquote>
<p>
<ins><i>Remarks:</i> This operator shall not participate in overload resolution, unless
<tt>is_error_condition_enum&lt;ErrorConditionEnum&gt;::value == true</tt>.</ins>
</p>

<p>
<i>Postcondition:</i> <tt>*this == make_error_condition(e)</tt>.
</p>

<p>
<ins><i>Returns:</i> <tt>*this</tt></ins>
</p>
</blockquote>
</blockquote>

</li>
</ol>






<hr>
<h3><a name="1240"></a>1240. Deleted comparison functions of std::function not  needed</h3>
<p><b>Section:</b> 20.8.14.2 [func.wrap.func] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2009-10-18 <b>Last modified:</b> 2010-11-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#func.wrap.func">issues</a> in [func.wrap.func].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The class template <tt>std::function</tt> contains the following member
declarations:
</p>

<blockquote><pre>// deleted overloads close possible hole in the type system
template&lt;class R2, class... ArgTypes2&gt;
  bool operator==(const function&lt;R2(ArgTypes2...)&gt;&amp;) = delete;
template&lt;class R2, class... ArgTypes2&gt;
  bool operator!=(const function&lt;R2(ArgTypes2...)&gt;&amp;) = delete;
</pre></blockquote>

<p>
The leading comment here is part of the history of <tt>std::function</tt>, which
was introduced with <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1402.html#undefined_operators">N1402</a>.
During that time no explicit conversion functions existed, and the
"safe-bool" idiom (based on pointers-to-member) was a popular
technique. The only disadvantage of this idiom was that given two
objects <tt>f1</tt> and <tt>f2</tt> of type <tt>std::function</tt> the expression
</p>

<blockquote><pre>f1 == f2;
</pre></blockquote>

<p>
was well-formed, just because the built-in <tt>operator==</tt> for pointer to member
was considered after a single user-defined conversion. To fix this, an
overload set of <em>undefined</em> comparison functions was added,
such that overload resolution would prefer those ending up in a linkage error.
The new language facility of deleted functions provided a much better
diagnostic mechanism to fix this issue.
</p>

<p>
The central point of this issue is, that with the replacement of the
safe-bool idiom by explicit conversion to bool the original "hole in the
type system" does no longer exist and therefore the comment is wrong and
the superfluous function definitions should be removed as well. An
explicit conversion function is considered in direct-initialization
situations only, which indirectly contain the so-called "contextual
conversion to bool" (4 [conv]/3). These conversions are not considered for
<tt>==</tt> or <tt>!=</tt> as defined by the core language.
</p>

<p><i>[
Post-Rapperswil
]</i></p>


<blockquote>
Moved to Tentatively Ready after 5 positive votes on c++std-lib.
</blockquote>

<p><i>[
Adopted at 2010-11 Batavia
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
In 20.8.14.2 [func.wrap.func]/1, class function change as indicated:
</p>

<blockquote><pre>// 20.7.15.2.3, function capacity:
explicit operator bool() const;

<del>// deleted overloads close possible hole in the type system</del>
<del>template&lt;class R2, class... ArgTypes2&gt;</del>
  <del>bool operator==(const function&lt;R2(ArgTypes2...)&gt;&amp;) = delete;</del>
<del>template&lt;class R2, class... ArgTypes2&gt;</del>
  <del>bool operator!=(const function&lt;R2(ArgTypes2...)&gt;&amp;) = delete;</del>
</pre></blockquote>





<hr>
<h3><a name="1241"></a>1241. unique_copy needs to require EquivalenceRelation</h3>
<p><b>Section:</b> 25.3.9 [alg.unique] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2009-10-17 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.unique">issues</a> in [alg.unique].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
A lot of fixes were silently applied during concept-time and we should
not lose them again. The Requires clause of 25.3.9 [alg.unique]/5
doesn't mention that <tt>==</tt> and the predicate need to satisfy an
<tt>EquivalenceRelation</tt>, as it is correctly said for
<tt>unique</tt>. This was intentionally fixed during conceptification,
were we had:
</p>

<blockquote><pre>template&lt;InputIterator InIter, class OutIter&gt;
  requires OutputIterator&lt;OutIter, RvalueOf&lt;InIter::value_type&gt;::type&gt;
        &amp;&amp; EqualityComparable&lt;InIter::value_type&gt;
        &amp;&amp; HasAssign&lt;InIter::value_type, InIter::reference&gt;
        &amp;&amp; Constructible&lt;InIter::value_type, InIter::reference&gt;
  OutIter unique_copy(InIter first, InIter last, OutIter result);

template&lt;InputIterator InIter, class OutIter,
         EquivalenceRelation&lt;auto, InIter::value_type&gt; Pred&gt;
  requires OutputIterator&lt;OutIter, RvalueOf&lt;InIter::value_type&gt;::type&gt;
        &amp;&amp; HasAssign&lt;InIter::value_type, InIter::reference&gt;
        &amp;&amp; Constructible&lt;InIter::value_type, InIter::reference&gt;
        &amp;&amp; CopyConstructible&lt;Pred&gt;
  OutIter unique_copy(InIter first, InIter last, OutIter result, Pred pred);
</pre></blockquote>

<p>
Note that EqualityComparable implied an equivalence relation.
</p>

<p><i>[
N.B. <tt>adjacent_find</tt> was also specified to require
<tt>EquivalenceRelation</tt>, but that was considered as a defect in
concepts, see <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1000">1000</a>
]</i></p>


<p><i>[
2009-10-31 Howard adds:
]</i></p>


<blockquote>
Moved to Tentatively Ready after 5 positive votes on c++std-lib.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 25.3.9 [alg.unique]/5 as indicated:
</p>

<blockquote><pre>template&lt;class InputIterator, class OutputIterator&gt;
  OutputIterator
    unique_copy(InputIterator first, InputIterator last, OutputIterator result);

template&lt;class InputIterator, class OutputIterator, class BinaryPredicate&gt;
  OutputIterator
    unique_copy(InputIterator first, InputIterator last,
                OutputIterator result, BinaryPredicate pred);
</pre>
<blockquote>
<i>Requires:</i> <ins>The comparison function shall be an equivalence
relation.</ins> The ranges <tt>[first,last)</tt> and
<tt>[result,result+(last-first))</tt> shall not overlap. The expression
<tt>*result = *first</tt> shall be valid. If neither
<tt>InputIterator</tt> nor <tt>OutputIterator</tt> meets the
requirements of forward iterator then the value type of
<tt>InputIterator</tt> shall be <tt>CopyConstructible</tt> (34) and
<tt>CopyAssignable</tt> (table 36). Otherwise <tt>CopyConstructible</tt>
is not required.
</blockquote>
</blockquote>





<hr>
<h3><a name="1245"></a>1245. <tt>std::hash&lt;string&gt;</tt> &amp; co</h3>
<p><b>Section:</b> 20.8.15 [unord.hash] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Paolo Carlini <b>Opened:</b> 2009-10-22 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#unord.hash">issues</a> in [unord.hash].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 20.8.15 [unord.hash], <tt>operator()</tt> is specified as
taking the argument by value. Moreover, it is said that <tt>operator()</tt> shall
not throw exceptions.
</p>

<p>
However, for the specializations for class types, like <tt>string</tt>, <tt>wstring</tt>,
etc, the former requirement seems suboptimal from the performance point
of view (a specific PR has been filed about this in the GCC Bugzilla)
and, together with the latter requirement, hard if not impossible to
fulfill. It looks like pass by const reference should be allowed in such
cases.
</p>

<p><i>[
2009-11-18: Ganesh updates wording.
]</i></p>


<blockquote>
I've removed the list of types for which <tt>hash</tt> shall be instantiated
because it's already explicit in the synopsis of header
<tt>&lt;functional&gt;</tt> in 20.8 [function.objects]/2.
</blockquote>

<p><i>[
2009-11-18: Original wording here:
]</i></p>


<blockquote class="note">
<p>
Add to 20.8.15 [unord.hash]/2:
</p>

<blockquote>
<pre>namespace std {
  template &lt;class T&gt;
  struct hash : public std::unary_function&lt;T, std::size_t&gt; {
    std::size_t operator()(T val) const;
  };
}
</pre>

<p>
The return value of <tt>operator()</tt> is unspecified, except that
equal arguments shall yield the same result. <tt>operator()</tt> shall
not throw exceptions. <ins>It is also unspecified whether
<tt>operator()</tt> of <tt>std::hash</tt> specializations for class
types takes its argument by value or const reference.</ins>
</p>
</blockquote>
</blockquote>

<p><i>[
2009-11-19 Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>


<p><i>[
2009-11-24 Ville Opens:
]</i></p>


<blockquote>
I have received community requests to ask for this issue to be reopened.
Some users feel that mandating the inheritance is overly constraining.
</blockquote>

<p><i>[
2010-01-31 Alisdair: related to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#978">978</a> and <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1182">1182</a>.
]</i></p>


<p><i>[
2010-02-07 Proposed resolution updated by Beman, Daniel and Ganesh.
]</i></p>


<p><i>[
2010-02-09 Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>




<p><b>Proposed resolution:</b></p>
  <p><i>Insert a new subclause either before or after the current 20.2.5 [allocator.requirements]:</i></p>
<blockquote>

  <h3><tt>Hash</tt> Requirements [hash.requirements]</h3>

  <p align="left">This subclause defines the named requirement <tt>Hash</tt>, 
  used in several clauses of the C++ standard library. A type <tt>H</tt> meets the <tt>Hash</tt> requirement if</p>

  <ul>
    <li>

  <p align="left">it is a function object type (20.8 [function.objects]).</p>

    </li>
    <li>

  <p align="left">it satisfies the requirements of <tt>CopyConstructible</tt>, and 
  <tt>Destructible</tt> (20.2.1 [utility.arg.requirements]),</p>

    </li>
    <li>

  <p align="left">the expressions shown in the following table are valid and have the 
  indicated semantics, and</p>

    </li>
    <li>

  <p align="left">it satisfies all other requirements of this subclause.</p>

    </li>
  </ul>

  <p align="left">Given <tt>Key</tt> is an argument type for function objects of 
  type <tt>H</tt>, in the table below <tt>h</tt> is a value of type (possibly <tt>const</tt>)
  <tt>H</tt>, <tt>u</tt> is an lvalue of type <tt>Key</tt>,&nbsp; and <tt>
  k</tt> 
  is a value of a type convertible to (possibly <tt>const</tt>) <tt>Key</tt>:</p>

  <p align="center">Table ? - <tt>Hash</tt> requirements</p>
<table border="1" cellpadding="5" cellspacing="1" style="border-collapse: collapse" bordercolor="#111111">
  <tbody><tr>
    <td>Expression</td>
    <td>Return type</td>
    <td>Requirement</td>
  </tr>
  <tr>
    <td valign="top"><tt>h(k)</tt></td>
    <td valign="top"><tt>size_t</tt></td>
    <td valign="top">Shall not throw exceptions. The value returned shall depend only on
the argument <tt>k</tt>. [<i>Note:</i> Thus all evaluations of the expression <tt>
    h(k)</tt> with the 
    same value for <tt>k</tt> yield the same result. <i> end note</i>] [<i>Note:
    </i>For <tt>t1</tt> and <tt>t2</tt> of different values, the probability that 
    <tt>h(t1)</tt> 
    and <tt>h(t2)</tt> compare equal should be very small, approaching <tt>(1.0/numeric_limits&lt;size_t&gt;::max())</tt>.
    <i> end note</i>] <i><span style="background-color: #C0C0C0">Comment 
    (not to go in WP): The wording for the second note is based on a similar 
    note in 22.4.4.1.2 [locale.collate.virtuals]/3</span></i></td>
  </tr>
  <tr>
    <td valign="top"><tt>h(u)</tt></td>
    <td valign="top"><tt>size_t</tt></td>
    <td valign="top">Shall not modify <tt>u</tt>.</td>
  </tr>
  </tbody></table>

</blockquote>

<p><i>Change 20.8.15 [unord.hash] as indicated: </i>
</p>
<blockquote>
  <p>1 The unordered associative containers defined in Clause 23.7 [unord] use 
  specializations of <ins>the class template</ins> <tt>hash</tt> as the default 
  hash function. <ins>For all object types <tt>T</tt> for which there exists a 
  specialization <tt>hash&lt;T&gt;</tt>, the instantiation <tt>hash&lt;T&gt;</tt> shall:</ins></p>
  <ul>
    <li> <ins>satisfy the <tt>Hash</tt> requirements([hash.requirements]), with <tt>T</tt> as the 
  function call argument type, the <tt>
  DefaultConstructible</tt> requirements ([defaultconstructible]), the <tt>CopyAssignable</tt> 
  requirements ([copyassignable]), and the <tt>
  Swappable</tt> requirements ([swappable]),</ins>
  </li>
    <li> <ins>provide two nested types <tt>result_type</tt> and <tt>argument_type</tt> which shall 
    be synonyms for <tt>size_t</tt> and <tt>T</tt>, respectively,</ins></li>
    <li> <ins>satisfy the 
  requirement that if <tt>k1 == k2</tt> is <tt>true</tt>, <tt>h(k1) == h(k2)</tt> 
  is <tt>true</tt>, where <tt>h</tt> is an object of type <tt>hash&lt;T&gt;</tt>, and
  <tt>k1</tt>, <tt>k2</tt> are objects of type <tt>T</tt>.</ins></li>
  </ul>
  <p> <del>This class template is only required to be instantiable 
  for integer types (3.9.1 [basic.fundamental]), floating-point types (3.9.1 [basic.fundamental]), 
  pointer types (8.3.1 [dcl.ptr]), and <tt>std::string</tt>, <tt>std::u16string</tt>,
  <tt>std::u32string</tt>, <tt>std::wstring</tt>, <tt>std::error_code</tt>, <tt>
  std::thread::id</tt>, <tt>std::bitset</tt>, and <tt>std::vector&lt;bool&gt;</tt>.</del> </p>
  <blockquote>
    <pre><del>namespace std {
  template &lt;class T&gt;
  struct hash : public std::unary_function&lt;T, std::size_t&gt; {
    std::size_t operator()(T val) const;
  };
}</del></pre>
  </blockquote>
  <p><del>2 The return value of <tt>operator()</tt> is unspecified, except that 
  equal arguments shall yield the same result. <tt>operator()</tt> shall not 
  throw exceptions. </del></p>

</blockquote>

  <p><i>Change Unordered associative containers 23.2.5 [unord.req] as indicated:</i></p>
<blockquote>
  <p>Each unordered associative container is parameterized by <tt>Key</tt>, by a 
  function object <ins>type</ins> <tt>Hash</tt><ins>([hash.requirements])</ins> that acts as a hash 
  function for <ins>argument</ins> values of type <tt>Key</tt>, 
  and by a binary predicate <tt>Pred</tt> that induces an equivalence relation 
  on values of type <tt>Key</tt>. Additionally, <tt>unordered_map</tt> and <tt>
  unordered_multimap</tt> associate an arbitrary mapped type <tt>T</tt> with the
  <tt>Key</tt>.</p>
  <p>A hash function is a function object that takes a single argument of type
  <tt>Key</tt> and returns a value of type <tt>std::size_t</tt>.</p>
<p>Two values <tt>k1</tt> and <tt>k2</tt> of type <tt>Key</tt> are considered 
equal if the container's equality function object returns <tt>true</tt> when passed those 
values. If <tt>k1</tt> and <tt>k2</tt> are equal, the hash function shall return 
the same value for both. <ins>[<i>Note:</i> Thus supplying a non-default <tt>Pred</tt> 
parameter usually implies the need to supply a non-default <tt>Hash</tt> 
parameter. <i> end note</i>]</ins></p>

</blockquote>






<hr>
<h3><a name="1247"></a>1247. <tt>auto_ptr</tt> is overspecified</h3>
<p><b>Section:</b> D.12.1 [auto.ptr] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-10-24 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#auto.ptr">issues</a> in [auto.ptr].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
This issue is extracted as the ongoing point-of-interest from earlier
issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#463">463</a>.
</p>

<p>
<tt>auto_ptr</tt> is overspecified as the <tt>auto_ptr_ref</tt>
implementation detail is formally specified, and the technique is
observable so workarounds for compiler defects can  cause a working
implementation of the primary <tt>auto_ptr</tt> template become
non-conforming.
</p>

<p>
<tt>auto_ptr_ref</tt> is a documentation aid to describe a possible
mechanism to implement the class.  It should be marked exposition only,
as per similar classes, e.g., <tt>istreambuf_iterator::proxy</tt>
</p>

<p><i>[
2009-10-25 Daniel adds:
]</i></p>


<blockquote>
<p>
I wonder, whether the revised wording shouldn't be as straight as
for <tt>istream_buf</tt> by adding one further sentence:
</p>

<blockquote>
An implementation is permitted to provide equivalent functionality without
providing a class with this name.
</blockquote>
</blockquote>

<p><i>[
2009-11-06 Alisdair adds Daniel's suggestion to the proposed wording.
]</i></p>


<p><i>[
2009-11-06 Howard moves issue to Review.
]</i></p>


<p><i>[
2009-11-14 Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
Add the term "exposition only" in the following two places:
</p>

<p>
Ammend D.12.1 [auto.ptr]p2:
</p>

<blockquote>
<p>
<ins>The exposition only class </ins> <del>T</del><ins>t</ins>emplate <tt>auto_ptr_ref</tt>
holds a reference to an <tt>auto_ptr</tt>. It is used by the
<tt>auto_ptr</tt> conversions to allow <tt>auto_ptr</tt> objects to be
passed to and returned from functions.
<ins>An implementation is permitted to provide equivalent functionality
without providing a class with this name.</ins>
</p>

<blockquote><pre>namespace std {
 template &lt;class Y&gt; struct auto_ptr_ref { }; <ins>// exposition only</ins>
</pre></blockquote>
</blockquote>





<hr>
<h3><a name="1249"></a>1249. basic_ios default ctor</h3>
<p><b>Section:</b> 27.5.4.1 [basic.ios.cons] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2009-10-25 <b>Last modified:</b> 2010-11-24</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#basic.ios.cons">issues</a> in [basic.ios.cons].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The basic_ios default ctor is required to leave the objects members
uninitialized (see below). The paragraph says the object must be
initialized by calling basic_ios::init() before it's destroyed by
I can't find a requirement that it be initialized before calling
any of the class other member functions. Am I not looking in the
right place or that an issue?
</p>

<p><i>[
2009-10-25 Daniel adds:
]</i></p>


<blockquote>
<p>
I agree, that your wording makes that clearer, but suggest to write
</p>

<blockquote>
... calling <tt>basic_ios::init<del>()</del></tt> before ...
</blockquote>

<p>
Doing so, I recommend to adapt that of <tt>ios_base();</tt> as well, where
we have:
</p>

<blockquote>
<i>Effects:</i> Each <tt>ios_base</tt> member has an indeterminate value
after construction. These members shall be initialized by calling
<tt>basic_ios::init</tt>. If an <tt>ios_base</tt> object is destroyed
before these initializations have taken place, the behavior is
undefined.
</blockquote>
</blockquote>

<p><i>[
Post-Rapperswil:
]</i></p>


<blockquote>
Moved to Tentatively Ready after 5 positive votes on c++std-lib.
</blockquote>

<p><i>[
Adopted at 2010-11 Batavia
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
Change 27.5.2.7 [ios.base.cons] p1:
</p>

<blockquote><pre>ios_base();
</pre>
<blockquote>
<i>Effects:</i> Each <tt>ios_base</tt> member has an indeterminate value
after construction. <del>These</del> <ins>The object's</ins> members shall be initialized by calling
<tt>basic_ios::init</tt> <ins>before the object's first use or before
 it is destroyed, whichever comes first; otherwise the behavior
 is undefined.</ins>. <del>If an <tt>ios_base</tt> object is destroyed
before these initializations have taken place, the behavior is
undefined.</del>
</blockquote>
</blockquote>

<p>
Change 27.5.4.1 [basic.ios.cons] p2:
</p>

<blockquote><pre>basic_ios();
</pre>
<blockquote>
<i>Effects:</i> Constructs an object of class <tt>basic_ios</tt>
(27.5.2.7) leaving its member objects uninitialized. The object shall be
initialized by calling <del>its</del>
<tt><ins>basic_ios::</ins>init</tt> <ins>before its first
use or before it is destroyed, whichever comes first; otherwise the
behavior is undefined.</ins> <del>member function. If it is destroyed
before it has been initialized the behavior is undefined.</del>
</blockquote>
</blockquote>





<hr>
<h3><a name="1250"></a>1250. <tt>&lt;bitset&gt;</tt> still overspecified</h3>
<p><b>Section:</b> 20.5 [template.bitset] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2009-10-29 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#template.bitset">issues</a> in [template.bitset].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1227">1227</a>  <tt>&lt;bitset&gt;</tt> synopsis overspecified makes the observation
that <tt>std::bitset</tt>, and in fact the whole library, may be implemented
without needing to <tt>#include &lt;stdexcept&gt;</tt> in any library header. The
proposed resolution removes the <tt>#include &lt;stdexcept&gt;</tt> directive from
the header.
</p>

<p>
I'd like to add that the <tt>&lt;bitset&gt;</tt> header (as well as the rest of
the library) has also been implemented without #including the
<tt>&lt;cstddef&gt;</tt> header in any library header. In the case of <tt>std::bitset</tt>,
the template is fully usable (i.e., it may be instantiated and all
its member functions may be used) without ever mentioning <tt>size_t</tt>.
In addition, just like no library header except for <tt>&lt;bitset&gt;</tt>
<tt>#includes &lt;stdexcept&gt;</tt> in its synopsis, no header but <tt>&lt;bitset&gt;</tt>
<tt>#includes &lt;cstddef&gt;</tt> either.
</p>

<p>
Thus I suggest that the <tt>#include &lt;cstddef&gt;</tt> directive be similarly
removed from the synopsis of <tt>&lt;bitset&gt;</tt>.
</p>

<p><i>[
2010-02-08 Moved to Tentatively Ready after 6 positive votes on c++std-lib.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
Change 20.5 [template.bitset]:
</p>

<blockquote><pre><del>#include &lt;cstddef&gt;        // for size_t</del>
#include &lt;string&gt;
#include &lt;iosfwd&gt;         // for istream, ostream
namespace std {
...
</pre></blockquote>





<hr>
<h3><a name="1254"></a>1254. Misleading sentence in <tt>vector&lt;bool&gt;::flip</tt></h3>
<p><b>Section:</b> 23.4.2 [vector.bool] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Christopher Jefferson <b>Opened:</b> 2009-11-01 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#vector.bool">issues</a> in [vector.bool].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The effects of <tt>vector&lt;bool&gt;::flip</tt> has the line:
</p>

<blockquote>
It is unspecified whether the function has any effect on allocated but
unused bits.
</blockquote>

<p>
While this is technically true, it is misleading, as any member function
in any standard container may change unused but allocated memory. Users
can never observe such changes as it would also be undefined behaviour
to read such memory.
</p>

<p><i>[
2009-11-14 Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
Strike second sentence from the definition of <tt>vector&lt;bool&gt;::flip()</tt>,
23.4.2 [vector.bool], paragraph 5.
</p>

<blockquote>
<i>Effects:</i> Replaces each element in the container with its complement.
<del>It is unspecified whether the function has any effect on allocated
but unused bits.</del>
</blockquote>





<hr>
<h3><a name="1255"></a>1255. <tt>declval</tt> should be added to the library</h3>
<p><b>Section:</b> 20.3 [utility] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2009-11-03 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#utility">issues</a> in [utility].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
During the Santa Cruz meeting it was decided to split off the provision
of the library utility <tt>value()</tt> proposed in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2979.html">N2979</a>
from the concrete request of the
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2939.html#uk300">UK 300</a>
comment.
The provision of a new library component that allows the production of
values in unevaluated expressions is considered as important
to realize constrained templates in C++0x where concepts are not
available.
</p>

<p>
The following proposed resolution is an improvement over that suggested in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2958.html">N2958</a>,
because the proposed component can now be defined without loss of
general usefulness and any <i>use</i> by user-code will make the program ill-formed.
A possible prototype implementation that satisfies the core language
requirements
can be written as:
</p>

<blockquote><pre>template&lt;class T&gt;
  struct declval_protector {
    static const bool stop = false;
    static typename std::add_rvalue_reference&lt;T&gt;::type delegate(); <font color="#C80000">// undefined</font>
  };

template&lt;class T&gt;
typename std::add_rvalue_reference&lt;T&gt;::type declval() {
  static_assert(declval_protector&lt;T&gt;::stop, "declval() must not be used!");
  return declval_protector&lt;T&gt;::delegate();
}
</pre></blockquote>

<p>
Further-on the earlier suggested name <tt>value()</tt> has been changed to <tt>declval()</tt>
after discussions with committee members.
</p>

<p>
Finally the suggestion shown below demonstrates that it can simplify
existing standard wording by directly using it in the library
specification, and that it also improves an overlooked corner case for
<tt>common_type</tt> by adding support for <tt>cv void</tt>.
</p>

<p><i>[
2009-11-19 Moved to Tentatively Ready after 6 positive votes on c++std-lib.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p><i>[
The proposed resolution has been updated to
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n3000.pdf">N3000</a>
numbering and wording
]</i></p>


<ol>
<li>
<p>
Change 20.3 [utility], header <tt>&lt;utility&gt;</tt> synopsis
as indicated:
</p>

<blockquote><pre>// 20.3.3, forward/move:
template &lt;class T&gt; struct identity;
template &lt;class T, class U&gt; T&amp;&amp; forward(U&amp;&amp;);
template &lt;class T&gt; typename remove_reference&lt;T&gt;::type&amp;&amp; move(T&amp;&amp;);

<ins>// 20.3.4, declval:</ins>
<ins>template &lt;class T&gt; typename add_rvalue_reference&lt;T&gt;::type declval(); // as unevaluated operand</ins>
</pre></blockquote>
</li>

<li>
<p>
Immediately after the current section 20.3.3 [forward] insert a
new section:
</p>
<p>
<ins>20.3.4 Function template declval [declval]</ins>
</p>
<p>
<ins>The library provides the function template <tt>declval</tt> to simplify
the definition of expressions which occur as
unevaluated operands (5 [expr]). The
template parameter <tt>T</tt> of <tt>declval</tt> may
be an incomplete type.</ins>
</p>

<pre><ins>template &lt;class T&gt; typename add_rvalue_reference&lt;T&gt;::type declval(); // as unevaluated operand</ins>
</pre>

<blockquote>
<p>
<ins><i>Remarks:</i> If this function is used according to 3.2 [basic.def.odr],
the program is ill-formed.</ins>
</p>

<p>
<ins>[<i>Example:</i></ins>
</p>

<blockquote><pre><ins>
template&lt;class To, class From&gt;
decltype(static_cast&lt;To&gt;(declval&lt;From&gt;())) convert(From&amp;&amp;);
</ins></pre></blockquote>

<p>
<ins>
declares a function template <tt>convert</tt>, which only participates in
overloading if the type <tt>From</tt> can be explicitly cast to type <tt>To</tt>.
For another example see class template <tt>common_type</tt>
(20.7.7.6 [meta.trans.other]).
 <i>end example</i>]</ins>
</p>
</blockquote>

</li>

<li>
<p>
This bullet just makes clear that after applying <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2984.html">N2984</a>, the changes in 20.7.4.3 [meta.unary.prop], before
table Type property queries should <em>not</em> use <tt>declval</tt>,
because the well-formedness requirement of the specification of
<tt>is_constructible</tt> would become more complicated, because we
would need to make sure that the expression <i>CE</i> is checked in an
unevaluated context.
</p>
</li>

<li>
<p>
Also 20.7.6 [meta.rel]/4 is not modified similar to the previous bullet,
because with
the stricter requirements of not using <tt>declval()</tt> the well-formedness condition
would be harder to specify. The following changes are only editorial ones (e.g.
the removal of the duplicate declaration of <tt>create()</tt>):
</p>

<blockquote>
<p>
Given the following function prototype:
</p>

<blockquote><pre>template &lt;class T&gt;
  typename add_rvalue_reference&lt;T&gt;::type create();
</pre></blockquote>

<p>
the predicate condition for a template specialization
<tt>is_convertible&lt;From, To&gt;</tt> shall be satisfied if and only
if the return expression in the following code would be well-formed,
including any
implicit conversions to the return type of the function:
</p>

<blockquote><pre><del>template &lt;class T&gt;
typename add_rvalue_reference&lt;T&gt;::type create();</del>
To test() {
  return create&lt;From&gt;();
}
</pre></blockquote>
</blockquote>
</li>

<li>
<p>
Change the entry in column "Comments" for <tt>common_type</tt> in Table 51 
Other transformations (20.7.7.6 [meta.trans.other]):
</p>

<p><i>[
NB: This wording change extends the type domain of <tt>common_type</tt> for <tt>cv
void =&gt; cv void</tt> transformations and thus makes <tt>common_type</tt> usable for
all binary type combinations that are supported by <tt>is_convertible</tt>
]</i></p>


<blockquote>
The member typedef <tt>type</tt> shall be defined as set out below. All
types in the parameter pack <tt>T</tt> shall be complete <ins>or
(possibly cv-qualified) <tt>void</tt></ins>. A program may specialize
this trait if at least one template parameter in the specialization is a
user-defined type. [<i>Note:</i> Such specializations are needed when
only explicit conversions are desired among the template arguments.
 <i>end note</i>]
</blockquote>
</li>

<li>
<p>
Change 20.7.7.6 [meta.trans.other]/3 as indicated:
</p>

<p><i>[
NB: This wording change is more than an editorial simplification of
the definition of <tt>common_type</tt>: It also extends its usefulness for <tt>cv
void</tt> types as outlined above
]</i></p>


<blockquote>
<p>
The nested typedef <tt>common_type::type</tt> shall be defined as follows:
</p>

<blockquote>
<p>
[..]
</p>
<pre>template &lt;class T, class U&gt;
struct common_type&lt;T, U&gt; {
<del>private:
  static T&amp;&amp; __t();
  static U&amp;&amp; __u();
public:</del>
  typedef decltype(true ? <del>__t</del><ins>declval&lt;T&gt;</ins>() : <del>__u</del><ins>declval&lt;U&gt;</ins>()) type;
};
</pre>
</blockquote>
</blockquote>
</li>

<li>
<p>
Change X [func.ret]/1 as indicated
[<i>This part solves some main aspects of issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1225">1225</a></i>]:
</p>

<blockquote><pre>namespace std {
  template &lt;class&gt; class result_of; // undefined

  template &lt;class Fn, class... ArgTypes&gt;
  class result_of&lt;Fn(ArgTypes...)&gt; {
  public :
    <del>// types</del>
    typedef <del>see below</del><ins>decltype(declval&lt;Fn&gt;() ( declval&lt;ArgTypes&gt;()... ))</ins> type;
  };
}
</pre>
<p>
<del>1 Given an rvalue <tt>fn</tt> of type <tt>Fn</tt> and values <tt>t1, t2, ..., tN</tt> of
types <tt>T1, T2, ..., TN</tt> in <tt>ArgTypes</tt>,
respectively, the <tt>type</tt> member is the result type of the expression
<tt>fn(t1, t2, ...,tN)</tt>. The values <tt>ti</tt>
are lvalues when the corresponding type <tt>Ti</tt> is an lvalue-reference
type, and rvalues otherwise.</del>
</p>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="1256"></a>1256. <tt>weak_ptr</tt> comparison functions should be removed</h3>
<p><b>Section:</b> 20.9.10.3 [util.smartptr.weak] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2009-11-04 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Additional to the necessary cleanup of the description of the the
<tt>weak_ptr</tt> component from 20.9.10.3 [util.smartptr.weak]
described in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1231">1231</a> it turns out that the currently deleted
comparison functions of <tt>weak_ptr</tt> are not needed at all: There
is no safe-bool conversion from <tt>weak_ptr</tt>, and it won't silently
chose a conversion to <tt>shared_ptr</tt>.
</p>

<p><i>[
2009-11-14 Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
Change 20.9.10.3 [util.smartptr.weak]/1 as indicated:
</p>

<blockquote><pre>namespace std {
template&lt;class T&gt; class weak_ptr {
public:
...
  <del>// comparisons</del>
  <del>template&lt;class Y&gt; bool operator&lt;(weak_ptr&lt;Y&gt; const&amp;) const = delete;</del>
  <del>template&lt;class Y&gt; bool operator&lt;=(weak_ptr&lt;Y&gt; const&amp;) const = delete;</del>
  <del>template&lt;class Y&gt; bool operator&gt;(weak_ptr&lt;Y&gt; const&amp;) const = delete;</del>
  <del>template&lt;class Y&gt; bool operator&gt;=(weak_ptr&lt;Y&gt; const&amp;) const = delete;</del>
};
...
</pre></blockquote>





<hr>
<h3><a name="1257"></a>1257. Header &lt;ios&gt; still contains a <code>concept_map</code></h3>
<p><b>Section:</b> 27.5 [iostreams.base] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Beman Dawes <b>Opened:</b> 2009-11-04 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#iostreams.base">issues</a> in [iostreams.base].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The current WP still contains a <tt>concept_map</tt>.
</p>

<p><i>[
2009-11-11 Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
Change Iostreams base classes 27.5 [iostreams.base], Header &lt;ios&gt; synopsis, 
as indicated:
</p>

<blockquote><pre><del>concept_map ErrorCodeEnum&lt;io_errc&gt; { };</del>
<ins>template &lt;&gt; struct is_error_code_enum&lt;io_errc&gt; : true_type { }</ins>
error_code make_error_code(io_errc e);
error_condition make_error_condition(io_errc e);
const error_category&amp; iostream_category();
</pre></blockquote>






<hr>
<h3><a name="1258"></a>1258. std::function Effects clause impossible to satisfy</h3>
<p><b>Section:</b> 20.8.14.2.2 [func.wrap.func.mod] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2009-11-05 <b>Last modified:</b> 2010-11-19</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p>
As of 20.8.14.2.2 [func.wrap.func.mod]/2+ we have the following
prototype description:
</p>

<blockquote><pre>template&lt;class F, Allocator Alloc&gt;
  void assign(F, const Alloc&amp;);
</pre>
<blockquote>
<i>Effects:</i> <tt>function(f, a).swap(*this)</tt>
</blockquote>
</blockquote>

<p>
Two things: First the concept debris needs to be removed, second and
much more importantly, the effects clause is now impossible to satisfy,
because there is no constructor that would match the parameter sequence
(<tt>FunctionObject</tt>, <tt>Allocator</tt>) [plus the fact that no
<tt>f</tt> and no <tt>a</tt> is part of the signature]. The most
probable candidate is
</p>

<blockquote><pre>template&lt;class F, class A&gt; function(allocator_arg_t, const A&amp;, F);
</pre></blockquote>

<p>
and the effects clause needs to be adapted to use this signature.
</p>

<p><i>[
2009-11-13 Daniel brought wording up to date.
]</i></p>


<p><i>[
2009-11-15 Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>


<p><i>[
2010-02-11 Moved to Tentatively NAD Editorial after 5 positive votes on
c++std-lib.  It was noted that this issue was in partial conflict with <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1288">1288</a>, and the two issues were merged in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1288">1288</a>.
]</i></p>


<p><b>Rationale:</b></p>
<p>
Addressed by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1288">1288</a>.
</p>




<p><b>Proposed resolution:</b></p>
<p>
Change in 20.8.14.2.2 [func.wrap.func.mod] the complete prototype description as
indicated
</p>
<p><i>[
Question to
the editor: Shouldn't there a paragraph number in front of the Effects clause?
]</i></p>


<blockquote><pre>template&lt;class F, <del>Allocator Alloc</del><ins>class A</ins>&gt;
  void assign(F <ins>f</ins>, const A<del>lloc</del>&amp; <ins>a</ins>);
</pre>
<blockquote>
<ins>3</ins> <i>Effects:</i> <tt>function(<del>f, a</del><ins>allocator_arg, a,
f</ins>).swap(*this)</tt>
</blockquote>
</blockquote>





<hr>
<h3><a name="1260"></a>1260. <tt>is_constructible&lt;int*,void*&gt;</tt> reports true</h3>
<p><b>Section:</b> 20.7.4.3 [meta.unary.prop] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> Peter Dimov <b>Opened:</b> 2009-11-07 <b>Last modified:</b> 2010-11-20</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#meta.unary.prop">issues</a> in [meta.unary.prop].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The specification of <tt>is_constructible&lt;T,Args...&gt;</tt> in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n3000.pdf">N3000</a>
uses
</p>

<blockquote><pre>static_cast&lt;T&gt;(create&lt;Args&gt;()...)
</pre></blockquote>

<p>
for the one-argument case, but <tt>static_cast</tt> also permits
unwanted conversions such as <tt>void*</tt> to <tt>T*</tt> and
<tt>Base*</tt> to <tt>Derived*</tt>.
</p>

<p><i>[
Post-Rapperswil:
]</i></p>


<blockquote>
Moved to <del>NAD Editorial</del><ins>Resolved</ins>, this issue is addressed by paper 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3047.html">n3047</a>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 20.7.4.3 [meta.unary.prop], p6:
</p>

<blockquote>
<p>
the predicate condition for a template specialization
<tt>is_constructible&lt;T, Args&gt;</tt> shall be satisfied, if and only
if the following <del>expression <i>CE</i></del> <ins>variable
definition</ins> would be well-formed:
</p>

<ul>
<li>
<p>
if <tt>sizeof...(Args) == <ins>0</ins> <del>1</del></tt><del>, the expression</del>:
</p>
<blockquote><pre><del>static_cast&lt;T&gt;(create&lt;Args&gt;()...)</del>
<ins>T t;</ins>
</pre></blockquote>
</li>
<li>
<p>
otherwise <del>the expression</del>:
</p>
<blockquote><pre>T<ins> t</ins>(create&lt;Args&gt;()...);
</pre></blockquote>
</li>
</ul>
</blockquote>





<hr>
<h3><a name="1261"></a>1261. Insufficent overloads for <tt>to_string</tt> / <tt>to_wstring</tt></h3>
<p><b>Section:</b> 21.5 [string.conversions] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Christopher Jefferson <b>Opened:</b> 2009-11-10 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#string.conversions">issues</a> in [string.conversions].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Reported on the gcc mailing list.
</p>

<blockquote>
The code "<tt>int i; to_string(i);</tt>" fails to compile, as
'<tt>int</tt>' is ambiguous between '<tt>long long</tt>' and '<tt>long
long unsigned</tt>'. It seems unreasonable to expect users to cast
numbers up to a larger type just to use <tt>to_string</tt>.
</blockquote>

<p><i>[
2009-11-14 Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
21.3 [string.classes], change <tt>to_string</tt> and
<tt>to_wstring</tt> to:
</p>

<blockquote><pre><ins>string to_string(int val);</ins>
<ins>string to_string(unsigned val);</ins>
<ins>string to_string(long val);</ins>
<ins>string to_string(unsigned long val);</ins>
string to_string(long long val); 
string to_string(unsigned long long val); 
<ins>string to_string(float val);</ins>
<ins>string to_string(double val);</ins>
string to_string(long double val);

<ins>wstring to_wstring(int val);</ins>
<ins>wstring to_wstring(unsigned val);</ins>
<ins>wstring to_wstring(long val);</ins>
<ins>wstring to_wstring(unsigned long val);</ins>
wstring to_wstring(long long val); 
wstring to_wstring(unsigned long long val); 
<ins>wstring to_wstring(float val);</ins>
<ins>wstring to_wstring(double val);</ins>
wstring to_wstring(long double val);
</pre></blockquote>

<p>
In 21.5 [string.conversions], paragraph 7, change to:
</p>

<blockquote><pre><ins>string to_string(int val);</ins>
<ins>string to_string(unsigned val);</ins>
<ins>string to_string(long val);</ins>
<ins>string to_string(unsigned long val);</ins>
string to_string(long long val); 
string to_string(unsigned long long val); 
<ins>string to_string(float val);</ins>
<ins>string to_string(double val);</ins>
string to_string(long double val);
</pre>

<blockquote>
7 <i>Returns:</i> each function returns a <tt>string</tt> object holding
the character representation of the value of its argument that would be
generated by calling <tt>sprintf(buf, fmt, val)</tt> with a format
specifier of <ins> <tt>"%d"</tt>, <tt>"%u"</tt>, <tt>"%ld"</tt>,
<tt>"%lu"</tt>, </ins> <tt>"%lld"</tt>, <tt>"%llu"</tt>,
<ins><tt>"%f"</tt>, <tt>"%f"</tt>,</ins> or <tt>"%Lf"</tt>, respectively,
where <tt>buf</tt> designates an internal character buffer of sufficient
size.
</blockquote>
</blockquote>

<p>
In 21.5 [string.conversions], paragraph 14, change to:
</p>

<blockquote><pre><ins>wstring to_wstring(int val);</ins>
<ins>wstring to_wstring(unsigned val);</ins>
<ins>wstring to_wstring(long val);</ins>
<ins>wstring to_wstring(unsigned long val);</ins>
wstring to_wstring(long long val); 
wstring to_wstring(unsigned long long val); 
<ins>wstring to_wstring(float val);</ins>
<ins>wstring to_wstring(double val);</ins>
wstring to_wstring(long double val);
</pre>

<blockquote>
14	<i>Returns:</i> Each function returns a <tt>wstring</tt> object
holding the character representation of the value of its argument that
would be generated by calling <tt>swprintf(buf, buffsz, fmt, val)</tt>
with a format specifier of <ins> <tt>L"%d"</tt>, <tt>L"%u"</tt>,
<tt>L"%ld"</tt>, <tt>L"%lu"</tt>, </ins><tt>L"%lld"</tt>,
<tt>L"%llu"</tt>, <ins><tt>L"%f"</tt>, <tt>L"%f"</tt>,</ins> or
<tt>L"%Lf"</tt>, respectively, where <tt>buf</tt> designates an internal
character buffer of sufficient size <tt>buffsz</tt>.
</blockquote>
</blockquote>





<hr>
<h3><a name="1262"></a>1262. <tt>std::less&lt;std::shared_ptr&lt;T&gt;&gt;</tt> is underspecified</h3>
<p><b>Section:</b> 20.9.10.2.7 [util.smartptr.shared.cmp] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2009-11-10 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
20.9.10.2.7 [util.smartptr.shared.cmp]/5 says:
</p>

<blockquote>
For templates <tt>greater</tt>, <tt>less</tt>, <tt>greater_equal</tt>, and <tt>less_equal</tt>, the
partial specializations for <tt>shared_ptr</tt> shall yield a total order, even if
the built-in operators <tt>&lt;</tt>, <tt>&gt;</tt>,
<tt>&lt;=</tt>, and <tt>&gt;=</tt> do not. Moreover,
<tt>less&lt;shared_ptr&lt;T&gt; &gt;::operator()(a, b)</tt> shall return
<tt>std::less&lt;T*&gt;::operator()(a.get(), b.get())</tt>.
</blockquote>

<p>
This is necessary in order to use <tt>shared_ptr</tt> as the key in associate
containers because
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2637.pdf">n2637</a>
changed <tt>operator&lt;</tt> on <tt>shared_ptr</tt>s to be
defined in terms of <tt>operator&lt;</tt> on the stored pointers (a mistake IMHO
but too late now.)  By 5.9 [expr.rel]/2 the result of comparing builtin
pointers is unspecified except in special cases which generally do not
apply to <tt>shared_ptr</tt>.
</p>

<p>
Earlier versions of the WP
(<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2798.pdf">n2798</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2857.pdf">n2857</a>)
had the following note on
that paragraph:
</p>

<blockquote>
[Editor's
note: It's not clear to me whether the first sentence is a requirement
or a note. The second
sentence seems to be a requirement, but it doesn't really belong here,
under <tt>operator&lt;</tt>.]
</blockquote>

<p>
I agree completely - if partial specializations are needed they should
be properly specified.
</p>

<p>
20.9.10.2.7 [util.smartptr.shared.cmp]/6 has a note saying the comparison operator
allows <tt>shared_ptr</tt> objects to be used as keys in associative
containers, which is misleading because something else like a
<tt>std::less</tt> partial specialization is needed.  If it is not correct that
note should be removed.
</p>

<p>
20.9.10.2.7 [util.smartptr.shared.cmp]/3 refers to '<tt>x</tt>' and
'<tt>y</tt>' but the prototype has parameters '<tt>a</tt>' and
'<tt>b</tt>' - that needs to be fixed even if the rest of the issue is
NAD.
</p>

<p>
I see two ways to fix this, I prefer the first because it removes the
need for any partial specializations and also fixes <tt>operator&gt;</tt> and
other comparisons when defined in terms of <tt>operator&lt;</tt>.
</p>

<ol>
<li>
<p>
Replace 20.9.10.2.7 [util.smartptr.shared.cmp]/3 with the following and
remove p5:
</p>

<blockquote><pre>template&lt;class T, class U&gt; bool operator&lt;(const shared_ptr&lt;T&gt;&amp; a, const shared_ptr&lt;U&gt;&amp; b);
</pre>
<blockquote>
<p>
3  <i>Returns:</i> <del><tt>x.get() &lt; y.get()</tt>.</del>
<ins><tt>std::less&lt;V&gt;()(a.get(), b.get())</tt>, where <tt>V</tt> is the
composite pointer type (5.9 [expr.rel]).</ins>
</p>

<p>
4 <i>Throws:</i> nothing.
</p>

<p><del>
5 For templates <tt>greater</tt>, <tt>less</tt>, <tt>greater_equal</tt>, and <tt>less_equal</tt>, the
partial specializations for <tt>shared_ptr</tt> shall yield a total order, even if
the built-in operators <tt>&lt;</tt>, <tt>&gt;</tt>,
<tt>&lt;=</tt>, and <tt>&gt;=</tt> do not. Moreover,
<tt>less&lt;shared_ptr&lt;T&gt; &gt;::operator()(a, b)</tt> shall return
<tt>std::less&lt;T*&gt;::operator()(a.get(), b.get())</tt>.
</del></p>
<p>
6 [<i>Note:</i> Defining a comparison operator allows
<tt>shared_ptr</tt> objects to be used as keys in associative
containers.  <i>end note</i>]
</p>
</blockquote>
</blockquote>
</li>


<li>
<p>
Add to 20.9.10.2 [util.smartptr.shared]/1 (after the <tt>shared_ptr</tt> comparisons)
</p>

<blockquote><pre>template&lt;class T&gt; struct greater&lt;shared_ptr&lt;T&gt;&gt;;
template&lt;class T&gt; struct less&lt;shared_ptr&lt;T&gt;&gt;;
template&lt;class T&gt; struct greater_equal&lt;shared_ptr&lt;T&gt;&gt;;
template&lt;class T&gt; struct less_equal&lt;shared_ptr&lt;T&gt;&gt;;
</pre></blockquote>

<p>
Remove 20.9.10.2.7 [util.smartptr.shared.cmp]/5 and /6 and replace with:
</p>

<blockquote><pre>template&lt;class T, class U&gt; bool operator&lt;(const shared_ptr&lt;T&gt;&amp; a, const shared_ptr&lt;U&gt;&amp; b);
</pre>
<blockquote>
<p>
3  <i>Returns:</i> <tt><del>x</del><ins>a</ins>.get() &lt; <del>y</del><ins>b</ins>.get()</tt>.
</p>

<p>
4 <i>Throws:</i> nothing.
</p>

<p><del>
5 For templates <tt>greater</tt>, <tt>less</tt>, <tt>greater_equal</tt>, and <tt>less_equal</tt>, the
partial specializations for <tt>shared_ptr</tt> shall yield a total order, even if
the built-in operators <tt>&lt;</tt>, <tt>&gt;</tt>,
<tt>&lt;=</tt>, and <tt>&gt;=</tt> do not. Moreover,
<tt>less&lt;shared_ptr&lt;T&gt; &gt;::operator()(a, b)</tt> shall return
<tt>std::less&lt;T*&gt;::operator()(a.get(), b.get())</tt>.
</del></p>
<p><del>
6 [<i>Note:</i> Defining a comparison operator allows
<tt>shared_ptr</tt> objects to be used as keys in associative
containers.  <i>end note</i>]
</del></p>
</blockquote>

<pre><ins>
template&lt;class T&gt; struct greater&lt;shared_ptr&lt;T&gt;&gt; :
binary_function&lt;shared_ptr&lt;T&gt;, shared_ptr&lt;T&gt;, bool&gt; {
  bool operator()(const shared_ptr&lt;T&gt;&amp; a, const shared_ptr&lt;T&gt;&amp; b) const;
};
</ins></pre>

<blockquote><ins>
<tt>operator()</tt> returns <tt>greater&lt;T*&gt;()(a.get(), b.get())</tt>.
</ins></blockquote>

<pre><ins>
template&lt;class T&gt; struct less&lt;shared_ptr&lt;T&gt;&gt; :
binary_function&lt;shared_ptr&lt;T&gt;, shared_ptr&lt;T&gt;, bool&gt; {
  bool operator()(const shared_ptr&lt;T&gt;&amp; a, const shared_ptr&lt;T&gt;&amp; b) const;
};
</ins></pre>

<blockquote><ins>
<tt>operator()</tt> returns <tt>less&lt;T*&gt;()(a.get(), b.get())</tt>.
</ins></blockquote>

<pre><ins>
template&lt;class T&gt; struct greater_equal&lt;shared_ptr&lt;T&gt;&gt; :
binary_function&lt;shared_ptr&lt;T&gt;, shared_ptr&lt;T&gt;, bool&gt; {
  bool operator()(const shared_ptr&lt;T&gt;&amp; a, const shared_ptr&lt;T&gt;&amp; b) const;
};
</ins></pre>

<blockquote><ins>
<tt>operator()</tt> returns <tt>greater_equal&lt;T*&gt;()(a.get(), b.get())</tt>.
</ins></blockquote>

<pre><ins>
template&lt;class T&gt; struct less_equal&lt;shared_ptr&lt;T&gt;&gt; :
binary_function&lt;shared_ptr&lt;T&gt;, shared_ptr&lt;T&gt;, bool&gt; {
  bool operator()(const shared_ptr&lt;T&gt;&amp; a, const shared_ptr&lt;T&gt;&amp; b) const;
};
</ins></pre>

<blockquote><ins>
<tt>operator()</tt> returns <tt>less_equal&lt;T*&gt;()(a.get(), b.get())</tt>.
</ins></blockquote>

</blockquote>
</li>
</ol>

<p><i>[
2009-11-18: Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
Replace 20.9.10.2.7 [util.smartptr.shared.cmp]/3 with the following and
remove p5:
</p>

<blockquote><pre>template&lt;class T, class U&gt; bool operator&lt;(const shared_ptr&lt;T&gt;&amp; a, const shared_ptr&lt;U&gt;&amp; b);
</pre>
<blockquote>
<p>
3  <i>Returns:</i> <del><tt>x.get() &lt; y.get()</tt>.</del>
<ins><tt>less&lt;V&gt;()(a.get(), b.get())</tt>, where <tt>V</tt> is the
composite pointer type (5.9 [expr.rel]) of <tt>T*</tt> and <tt>U*</tt>.</ins>
</p>

<p>
4 <i>Throws:</i> nothing.
</p>

<p><del>
5 For templates <tt>greater</tt>, <tt>less</tt>, <tt>greater_equal</tt>, and <tt>less_equal</tt>, the
partial specializations for <tt>shared_ptr</tt> shall yield a total order, even if
the built-in operators <tt>&lt;</tt>, <tt>&gt;</tt>,
<tt>&lt;=</tt>, and <tt>&gt;=</tt> do not. Moreover,
<tt>less&lt;shared_ptr&lt;T&gt; &gt;::operator()(a, b)</tt> shall return
<tt>std::less&lt;T*&gt;::operator()(a.get(), b.get())</tt>.
</del></p>
<p>
6 [<i>Note:</i> Defining a comparison operator allows
<tt>shared_ptr</tt> objects to be used as keys in associative
containers.  <i>end note</i>]
</p>
</blockquote>
</blockquote>






<hr>
<h3><a name="1264"></a>1264. <tt>quick_exit</tt> support for freestanding implementations</h3>
<p><b>Section:</b> 17.6.1.3 [compliance] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-11-12 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#compliance">issues</a> in [compliance].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses UK 172</b></p>

<p>
This issue is a response to NB comment UK-172
</p>

<p>
The functions <tt>quick_exit</tt> and <tt>at_quick_exit</tt> should be
added to the required features of <tt>&lt;cstdlib&gt;</tt> in a
freestanding implementation.
</p>

<p>
This comment was rejected in Summit saying neither <tt>at_exit</tt> nor
<tt>at_quick_exit</tt> should be required.  This suggests the comment was
misread, as <tt>atexit</tt> is already required to be supported.  If the LWG
really did wish to not require the registration functions be supported,
then a separate issue should be opened to change the current standard.
</p>

<p>
Given both <tt>exit</tt> and <tt>atexit</tt> are required, the UK panel feels it is
appropriate to require the new <tt>quick_exit</tt> facility is similarly
supported.
</p>

<p><i>[
2009-12-11 Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
Ammend p3 Freestanding implementations 17.6.1.3 [compliance]
</p>

<blockquote>
3 The supplied version of the header <tt>&lt;cstdlib&gt;</tt> shall
declare at least the functions <tt>abort<del>()</del></tt>, <tt>atexit<del>()</del></tt>,
<ins><tt>at_quick_exit</tt>,</ins> <del>and</del> <tt>exit<del>()</del></tt><ins>, and
<tt>quick_exit</tt></ins>(18.5 [support.start.term]). The other
headers listed in this table shall meet the same requirements as for a
hosted implementation.
</blockquote>






<hr>
<h3><a name="1267"></a>1267. Incorrect wording for <tt>condition_variable_any::wait_for</tt></h3>
<p><b>Section:</b> 30.5.2 [thread.condition.condvarany] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Anthony Williams <b>Opened:</b> 2009-11-17 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.condition.condvarany">issues</a> in [thread.condition.condvarany].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
30.5.2 [thread.condition.condvarany]p18 and 30.5.2 [thread.condition.condvarany]p27 specify incorrect preconditions for
<tt>condition_variable_any::wait_for</tt>. The stated preconditions require that
<tt>lock</tt> has a <tt>mutex()</tt> member function, and that this produces the
same result for all concurrent calls to <tt>wait_for()</tt>. This is
inconsistent with <tt>wait()</tt> and <tt>wait_until()</tt> which do not impose
such a requirement.
</p>

<p><i>[
2009-12-24 Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
Remove 30.5.2 [thread.condition.condvarany]p18 and 30.5.2 [thread.condition.condvarany]p27.
</p>
<blockquote>
<pre>template &lt;class Lock, class Rep, class Period&gt;
  cv_status wait_for(Lock&amp; lock, const chrono::duration&lt;Rep, Period&gt;&amp; rel_time);
</pre>
<blockquote>
<p><del>
18 <i>Precondition:</i> lock is locked by the calling thread, and either
</del></p>
<ul>
<li><del>
no other thread is waiting on this <tt>condition_variable</tt> object or
</del></li>
<li><del>
<tt>lock.mutex()</tt> returns the same value for each of the lock arguments
supplied by all concurrently waiting (via <tt>wait</tt>, <tt>wait_for</tt>, or
<tt>wait_until</tt>) threads.
</del></li>
</ul>
</blockquote>

<p>...</p>

<pre>template &lt;class Lock, class Rep, class Period, class Predicate&gt;
  bool wait_for(Lock&amp; lock, const chrono::duration&lt;Rep, Period&gt;&amp; rel_time, Predicate pred);
</pre>

<blockquote>

<p><del>
27 Precondition: lock is locked by the calling thread, and either
</del></p>
<ul>
<li><del>
no other thread is waiting on this <tt>condition_variable</tt> object or
</del></li>
<li><del>
<tt>lock.mutex()</tt> returns the same value for each of the lock arguments
supplied by all concurrently waiting (via <tt>wait</tt>, <tt>wait_for</tt>, or
<tt>wait_until</tt>) threads.
</del></li>
</ul>

</blockquote>

</blockquote>






<hr>
<h3><a name="1268"></a>1268. The Mutex requirements in 30.4.1 and 30.4.2 are wrong</h3>
<p><b>Section:</b> 30.4 [thread.mutex] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> Anthony Williams <b>Opened:</b> 2009-11-17 <b>Last modified:</b> 2010-11-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.mutex">issues</a> in [thread.mutex].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <tt>Mutex</tt> requirements in 30.4.1 [thread.mutex.requirements] and
30.4.1.3 [thread.timedmutex.requirements] confuse the requirements on the
behaviour of <tt>std::mutex</tt> et al with the requirements on
<tt>Lockable</tt> types for use with <tt>std::unique_lock</tt>,
<tt>std::lock_guard</tt> and <tt>std::condition_variable_any</tt>.
</p>

<p><i>[
2010 Pittsburgh:
]</i></p>


<blockquote>
<p>
Concepts of threads chapter and issue presentation are: Lockable &lt; Mutex &lt;
TimedMutex and Lockable &lt; TimedLockable &lt; TimedMutex.
</p>
<p>
Typo in failed deletion of Mutex in 30.4.4 p4 edits.
</p>
<p>
Lockable requirements are too weak for condition_variable_any, but the Mutex
requirements are too strong.
</p>
<p>
Need subset of Lockable requirements for condition_variable_any that does not
include try_lock. E.g. CvLockable &lt; Lockable.
</p>
<p>
Text needs updating to recent draft changes.
</p>
<p>
Needs to specify exception behavior in Lockable.
</p>
<p>
The current standard is fine for what it says, but it places requirements that
are too strong on authors of mutexes and locks.
</p>
<p>
Move to open status. Suggest Anthony look at condition_variable_any
requirements. Suggest Anthony refine requirements/concepts categories.
</p>
<p>
Related to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#964">964</a> and <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#966">966</a>
</p>
</blockquote>

<p><i>[
2010-03-28 Daniel synced with N3092.
]</i></p>


<p><i>[
2010-10-25 Daniel adds:
]</i></p>


<blockquote>
Accepting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3130.html">n3130</a> would solve this issue.
</blockquote>

<p><i>[
2010-11 Batavia:
]</i></p>


<blockquote>
Resolved by adopting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3197.html">n3197</a>.
</blockquote>




<p><b>Proposed resolution:</b></p>
<p>
Add a new section to 30.2 [thread.req] after 30.2.4 [thread.req.timing] as follows:
</p>

<blockquote>
<p>
30.2.5 Requirements for Lockable types
</p>

<p>
The standard library templates <tt>unique_lock</tt> (30.4.2.2 [thread.lock.unique]), <tt>lock_guard</tt> (30.4.2.1 [thread.lock.guard]), <tt>lock</tt>, <tt>try_lock</tt> (30.4.3 [thread.lock.algorithm]) and <tt>condition_variable_any</tt> (30.5.2 [thread.condition.condvarany]) all operate on user-supplied
<tt>Lockable</tt> objects. Such an object must support the member functions
specified for either the <tt>Lockable</tt> Requirements or the
<tt>TimedLockable</tt> requirements as appropriate to acquire or release
ownership of a <tt>lock</tt> by a given <tt>thread</tt>. [<i>Note:</i> the
nature of any lock ownership and any synchronization it may entail are not part
of these requirements.  <i>end note</i>]
</p>

<p>
30.2.5.1  Lockable Requirements
</p>

<p>
In order to qualify as a <tt>Lockable</tt> type, the following expressions must
be supported, with the specified semantics, where <tt>m</tt> denotes a value of
type <tt>L</tt> that supports the <tt>Lockable</tt>:
</p>

<p>
The expression <tt>m.lock()</tt> shall be well-formed and have the following
semantics:
</p>

<dl>
  <dt>Effects:</dt><dd>Block until a lock can be acquired for the current thread.</dd>
  <dt>Return type:</dt><dd><tt>void</tt></dd>
</dl>

<p>
The expression <tt>m.try_lock()</tt> shall be well-formed and have the
following semantics:
</p>

<dl>
  <dt>Effects:</dt><dd>Attempt to acquire a lock for the current thread without blocking.</dd>
  <dt>Return type:</dt><dd><tt>bool</tt></dd>
  <dt>Returns:</dt><dd><tt>true</tt> if the lock was
  acquired, <tt>false</tt> otherwise.</dd>
</dl>

<p>
The expression <tt>m.unlock()</tt> shall be well-formed and have the
following semantics:
</p>

<dl>
  <dt>Effects:</dt><dd>Release a lock on <tt>m</tt> held by the current thread.</dd>
  <dt>Return type:</dt><dd><tt> void</tt></dd>
  <dt>Throws:</dt><dd> Nothing if the current thread holds a lock on <tt>m</tt>.</dd>
</dl>

<p>
30.2.5.2 <tt>TimedLockable</tt> Requirements
</p>

<p>
For a type to qualify as <tt>TimedLockable</tt> it must meet the
<tt>Lockable</tt> requirements, and additionally the following
expressions must be well-formed, with the specified semantics,
where <tt>m</tt> is an instance of a type <tt>TL</tt> that supports
the <tt>TimedLockable</tt> requirements, <tt>rel_time</tt> denotes
instantiation of <tt>duration</tt> (20.11.3 [time.duration]) and <tt>abs_time</tt>
denotes an instantiation of <tt>time_point</tt> (20.11.4 [time.point])

</p>

<p>
The expression <tt>m.try_lock_for(rel_time)</tt> shall be well-formed and have the
following semantics:
</p>

<dl>
  <dt>Effects:</dt><dd>Attempt to acquire a lock for the current
  thread within the specified time period.</dd>
  <dt>Return type:</dt><dd><tt>bool</tt></dd>
  <dt>Returns:</dt><dd><tt>true</tt> if the lock was
  acquired, <tt>false</tt> otherwise.</dd>
</dl>

<p>
The expression <tt>m.try_lock_until(abs_time)</tt> shall be well-formed and have the
following semantics:
</p>

<dl>
  <dt>Effects:</dt><dd>Attempt to acquire a lock for the current
  thread before the specified point in time.</dd>
  <dt>Return type:</dt><dd><tt>bool</tt></dd>
  <dt>Returns:</dt><dd><tt>true</tt> if the lock was
  acquired, <tt>false</tt> otherwise.</dd>
</dl>
</blockquote>

<p>
Replace 30.4.1 [thread.mutex.requirements] paragraph 2 with the
following:
</p>

<blockquote>
2 This section describes requirements on <del>template argument types
used to instantiate templates defined in</del> <ins>the mutex types
supplied by</ins> the C++ standard library. <del>The template
definitions in the C++ standard library refer</del> These types shall
conform to the named <tt>Mutex</tt> requirements whose details are set
out below.  In this description, <tt>m</tt> is an object
of <del>a <tt>Mutex</tt> type</del>
<ins>one of the standard library mutex types <tt>std::mutex</tt>,
<tt>std::recursive_mutex</tt>, <tt>std::timed_mutex</tt> or
<tt>std::recursive_timed_mutex</tt>.</ins>.
</blockquote>

<p>
Add the following paragraph after 30.4.1 [thread.mutex.requirements]
paragraph 2:
</p>

<blockquote><ins>
A <tt>Mutex</tt> type shall conform to the <tt>Lockable</tt>
requirements (30.2.5.1).
</ins></blockquote>

<p>
Replace 30.4.1.3 [thread.timedmutex.requirements] paragraph 1 with the
following:
</p>

<blockquote>
<ins>The C++ standard library <tt>TimedMutex</tt> types <tt>std::timed_mutex</tt>
  and <tt>std::recursive_timed_mutex</tt> </ins>
<del>A <tt>TimedMutex</tt> type</del> shall meet the requirements for
a <tt>Mutex</tt> type. In addition, <del>it</del><ins>they</ins> shall
meet the requirements set out <del>in this Clause 30.4.2</del><ins>below</ins>,
where <tt>rel_time</tt> denotes an instantiation of <tt>duration</tt>
(20.11.3 [time.duration]) and <tt>abs_time</tt> denotes an instantiation
of <tt>time_point</tt> (20.11.4 [time.point]).
</blockquote>

<p>
Add the following paragraph after 30.4.1.3 [thread.timedmutex.requirements] paragraph 1:
</p>

<blockquote><ins>
A <tt>TimedMutex</tt> type shall conform to the <tt>TimedLockable</tt>
requirements (30.2.5.1).
</ins></blockquote>


<p>
Add the following paragraph following 30.4.2.1 [thread.lock.guard]
paragraph 1:
</p>

<blockquote><ins>
The supplied <tt>Mutex</tt> type shall meet the <tt>Lockable</tt> 
requirements
(30.2.5.1).
</ins></blockquote>

<p>
Add the following paragraph following 30.4.2.2 [thread.lock.unique]
paragraph 1:
</p>

<blockquote><ins>
The supplied <tt>Mutex</tt> type shall meet the <tt>Lockable</tt> 
requirements
(30.2.5.1). <tt>unique_lock&lt;Mutex&gt;</tt> meets the <tt>Lockable</tt>
requirements. If <tt>Mutex</tt> meets the <tt>TimedLockable</tt> 
requirements
(30.2.5.2) then <tt>unique_lock&lt;Mutex&gt;</tt> also meets the
<tt>TimedLockable</tt> requirements.
</ins></blockquote>

<p>
Replace the use of "mutex" or "mutex object" with "lockable object"
throughout clause 30.4.2 [thread.lock] paragraph 1:
</p>

<blockquote>
1 A lock is an object that holds a reference to
a <del>mutex</del><ins>lockable object</ins> and may unlock
the <del>mutex</del><ins>lockable object</ins> during the lock's
destruction (such as when leaving block scope). A thread of execution
may use a lock to aid in managing <del>mutex</del> ownership <ins>of a
lockable object</ins> in an exception safe manner. A lock is said to
own a <del>mutex</del><ins>lockable object</ins> if it is currently
managing the ownership of that <del>mutex</del><ins>lockable
object</ins> for a thread of execution. A lock does not manage the
lifetime of the <del>mutex</del><ins>lockable object</ins> it
references.  [ Note: Locks are intended to ease the burden of
unlocking the <del>mutex</del><ins>lockable object</ins> under both
normal and exceptional circumstances.  end note ]
</blockquote>

<p>30.4.2 [thread.lock] paragaph 2:</p>

<blockquote>
2 Some lock constructors take tag types which describe what should be
done with the <del>mutex</del><ins>lockable</ins> object during the
lock's constuction.
</blockquote>

<p>30.4.2.1 [thread.lock.guard] paragaph 1:</p>

<blockquote>
1 An object of type <tt>lock_guard</tt> controls the ownership of a
  <del>mutex</del><ins>lockable</ins> object within a scope. A
<tt>lock_guard</tt> object maintains ownership of
a <del>mutex</del><ins>lockable</ins> object throughout
the <tt>lock_guard</tt> object's lifetime. The behavior of a program
is undefined if the <del>mutex</del><ins>lockable object</ins>
referenced by <tt>pm</tt> does not exist for the entire lifetime (3.8)
of the <tt>lock_guard</tt> object. <ins><tt>Mutex</tt> shall meet
  the <tt>Lockable</tt> requirements (30.2.5.1).</ins>
</blockquote>

<p>30.4.2.2 [thread.lock.unique] paragaph 1:</p>

<blockquote>
1 An object of type <tt>unique_lock</tt> controls the ownership of
a <del>mutex</del><ins>lockable object</ins> within a
scope. <del>Mutex</del> <del>o</del><ins>O</ins>wnership <ins>of the
lockable object</ins> may be acquired at construction or after
construction, and may be transferred, after acquisition, to
another <tt>unique_lock</tt> object. Objects of
type <tt>unique_lock</tt> are not copyable but are movable. The
behavior of a program is undefined if the contained
pointer <tt>pm</tt> is not null and the mutex pointed to
by <tt>pm</tt> does not exist for the entire remaining lifetime (3.8)
of the <tt>unique_lock</tt> object. <ins><tt>Mutex</tt> shall meet
the <tt>Lockable</tt> requirements (30.2.5.1).</ins>
</blockquote>


<p>
Add the following to the precondition of <tt>unique_lock(mutex_type&amp;
 m,
const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time)</tt> in 
30.4.2.2.1 [thread.lock.unique.cons] paragraph 18:
</p>

<blockquote><pre>template &lt;class Clock, class Duration&gt;
  unique_lock(mutex_type&amp; m, const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time);
</pre>

<blockquote>
18 <i>Requires:</i> If <tt>mutex_type</tt> is not a recursive mutex 
the
calling thread does not own the mutex. <ins>The supplied <tt>mutex_type</tt>
type shall meet the <tt>TimedLockable</tt> requirements (30.2.5.2).</ins>
</blockquote>
</blockquote>

<p>
Add the following to the precondition of <tt>unique_lock(mutex_type&amp;
 m,
const chrono::duration&lt;Rep, Period&gt;&amp; rel_time)</tt> in 
30.4.2.2.1 [thread.lock.unique.cons]
paragraph 22
</p>

<blockquote>
22  <i>Requires:</i> If <tt>mutex_type</tt> is not a recursive mutex
 the
calling thread does not own the mutex. <ins>The supplied <tt>mutex_type</tt>
type shall meet the <tt>TimedLockable</tt> requirements (30.2.5.2).</ins>
</blockquote>

<p>
Add the following as a precondition of <tt>bool try_lock_until(const
chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time)</tt> before
30.4.2.2.2 [thread.lock.unique.locking] paragraph 8
</p>

<blockquote><pre>template &lt;class Clock, class Duration&gt;
  bool try_lock_until(const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time);
</pre>
<blockquote><ins>
<i>Requires:</i> The supplied <tt>mutex_type</tt> type shall meet the
<tt>TimedLockable</tt> requirements (30.2.5.2).
</ins></blockquote>
</blockquote>

<p>
Add the following as a precondition of <tt>bool try_lock_for(const
chrono::duration&lt;Rep, Period&gt;&amp; rel_time)</tt> before 
30.4.2.2.2 [thread.lock.unique.locking] paragraph 12
</p>

<blockquote><pre>template &lt;class Rep, class Period&gt;
  bool try_lock_for(const chrono::duration&lt;Rep, Period&gt;&amp; rel_time);
</pre>
<blockquote><ins>
<i>Requires:</i> The supplied <tt>mutex_type</tt> type shall meet the
<tt>TimedLockable</tt> requirements (30.2.5.2).
</ins></blockquote>
</blockquote>

<p>
Replace 30.4.3 [thread.lock.algorithm] p1 with the following:
</p>

<blockquote><pre>template &lt;class L1, class L2, class... L3&gt; int try_lock(L1&amp;, L2&amp;, L3&amp;...);
</pre>
<blockquote>
1 <i>Requires:</i> Each template parameter type shall meet the
<tt><del>Mutex</del> <ins>Lockable</ins></tt> requirements
<ins>(30.2.5.1).</ins><del>, except that a call to <tt>try_lock()</tt> 
may throw
an exception.</del> [<i>Note:</i> The <tt>unique_lock</tt> class 
template meets
these requirements when suitably instantiated.  <i>end note</i>]
</blockquote>
</blockquote>

<p>
Replace 30.4.3 [thread.lock.algorithm] p4 with the following:
</p>

<blockquote><pre>template &lt;class L1, class L2, class... L3&gt; void lock(L1&amp;, L2&amp;, L3&amp;...);
</pre>
<blockquote>
4 <i>Requires:</i> Each template parameter type shall meet the
<tt>Mutex<del>Mutex</del> <ins>Lockable</ins></tt>
requirements <ins>(30.2.5.1).</ins><del>, except that a call to
<tt>try_lock()</tt> may throw an exception.</del> [<i>Note:</i> The
<tt>unique_lock</tt> class template meets these requirements when 
suitably
instantiated.  <i>end note</i>]
</blockquote>
</blockquote>

<p>
Replace 30.5.2 [thread.condition.condvarany] paragraph 1 with:
</p>

<blockquote>
1 A <tt>Lock</tt> type shall meet the <del>requirements for a <tt>Mutex</tt>
type</del> <ins><tt>Lockable</tt> requirements (30.2.5.1)</ins>, except 
that
<tt>try_lock</tt> is not required. [<i>Note:</i> All of the standard 
mutex types
meet this requirement.  <i>end note</i>]
</blockquote>






<hr>
<h3><a name="1270"></a>1270. <tt>result_of</tt> should be moved to <tt>&lt;type_traits&gt;</tt></h3>
<p><b>Section:</b> X [func.ret] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-11-19 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#func.ret">issues</a> in [func.ret].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses UK 198</b></p>

<p>
NB Comment: UK-198 makes this request among others.  It refers to a more
detailed issue that BSI did not manage to submit by the CD1 ballot deadline
though.
</p>

<p>
<tt>result_of</tt> is essentially a metafunction to return the type of an
expression, and belongs with the other library metafunctions in
<tt>&lt;type_traits&gt;</tt> rather than lurking in <tt>&lt;functional&gt;</tt>.
 The current definition in <tt>&lt;functional&gt;</tt> made sense when
<tt>result_of</tt> was nothing more than a protocol to enable several components
in <tt>&lt;functional&gt;</tt> to provide their own result types, but it has
become a more general tool.  For instance, <tt>result_of</tt> is now used in the
threading and futures components.
</p>

<p>
Now that <tt>&lt;type_traits&gt;</tt> is a required header for free-standing
implementations it will be much more noticeable (in such environments) that a
particularly useful trait is missing, unless that implementation also chooses to
offer <tt>&lt;functional&gt;</tt> as an extension.
</p>

<p>
The simplest proposal is to simply move the wording (editorial direction below)
although a more consistent form for type_traits would reformat this as a table.
</p>

<p>
Following the acceptance of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1255">1255</a>, <tt>result_of</tt> now
depends on the <tt>declval</tt> function template, tentatively provided
in <tt>&lt;utility&gt;</tt> which is <em>not</em> (yet) required of a
free-standing implementation.
</p>

<p>
This dependency is less of an issue when <tt>result_of</tt> continues to
live in <tt>&lt;functional&gt;</tt>.
</p>

<p>
Personally, I would prefer to clean up the dependencies so both
<tt>result_of</tt> and <tt>declval</tt> are available in a free-standing
implementation, but that would require slightly more work than suggested
here.  A minimal tweak would be to require <tt>&lt;utility&gt;</tt> in a
free-standing implementation, although there are a couple of subtle
issues with <tt>make_pair</tt>, which uses <tt>reference_wrapper</tt> in
its protocol and that is much harder to separate cleanly from
<tt>&lt;functional&gt;</tt>.
</p>

<p>
An alternative would be to enact the other half of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2979.html">N2979</a>
and create a new minimal header for the new C++0x library facilities to
be added to the freestanding requirements (plus <tt>swap</tt>.)
</p>

<p>
I have a mild preference for the latter, although there are clearly
reasons to consider better library support for free-standing in general,
and adding the whole of <tt>&lt;utility&gt;</tt> could be considered a step in that
direction.  See NB comment
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n3009.html#JP23">JP-23</a>
for other suggestions (<tt>array</tt>, <tt>ratio</tt>)
</p>

<p><i>[
2010-01-27 Beman updated wording.
]</i></p>


<blockquote>
<p>
The original wording is preserved here:
</p>
<blockquote>

<p>
Move X [func.ret] to a heading below 20.7 [meta].  Note
that in principle we should not change the tag, although this is a new tag for
0x.  If it has been stable since TR1 it is clearly immutable though.
</p>

<p>
This wording should obviously adopt any other changes currently in (Tentatively)
Ready status that touch this wording, such as <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1255">1255</a>.
</p>

</blockquote>
</blockquote>

<p><i>[
2010-02-09 Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p><i>From Function objects 20.8 [function.objects], Header &lt;functional&gt; 
synopsis, remove:</i></p>
<blockquote>
  <pre>// 20.7.4 result_of:
template &lt;class&gt; class result_of; <i>// undefined</i>
template &lt;class F, class... Args&gt; class result_of&lt;F(ArgTypes...)&gt;;</pre>
</blockquote>

<p><i>Remove Function object return types X [func.ret] in its entirety. 
This sub-section reads:</i></p>
<blockquote>
  <pre>namespace std {
  template &lt;class&gt; class result_of; <i>// undefined</i>

  template &lt;class Fn, class... ArgTypes&gt;
  class result_of&lt;Fn(ArgTypes...)&gt; {
  public :
    // types
    typedef see below type;
  };
}</pre>
  <p>Given an rvalue <code>fn</code> of type <code>Fn</code> and values <code>
  t1, t2, ..., tN</code> of types T1, T2, ..., TN in <code>ArgTypes</code>, 
  respectively, the type member is the result type of the expression <code>
  fn(t1, t2, ...,tN)</code>. The values <code>ti</code> are lvalues when the 
  corresponding type <code>Ti</code> is an lvalue-reference type, and rvalues 
  otherwise.</p>
</blockquote>
<p><i>To Header &lt;type_traits&gt; synopsis 20.7.2 [meta.type.synop], add at 
the indicated location:</i></p>
<blockquote>
  <pre>template &lt;class T&gt; struct underlying_type;
<ins>template &lt;class T&gt; struct result_of; <i>// not defined
</i>template &lt;class Fn, class... ArgTypes&gt; struct result_of&lt;Fn(ArgTypes...)&gt;;</ins></pre>
</blockquote>
<p><i>To Other transformations 20.7.7.6 [meta.trans.other], Table 51  
Other transformations, add:</i></p>
<blockquote>
  <table style="border-collapse: collapse;" border="1" bordercolor="#111111" cellpadding="3" cellspacing="0">
    <tbody><tr>
      <td><b>Template</b></td>
      <td><b>Condition</b></td>
      <td><b>Comments</b></td>
    </tr>
    <tr>
      <td valign="top"><code>template &lt;class T&gt;<br>
      struct underlying_type;</code></td>
      <td valign="top"><code>T</code> shall be an enumeration type 
      (7.2)</td>
      <td valign="top">The member typedef <code>type</code> shall 
      name the underlying type of <code>T</code>.</td>
    </tr>
    <tr>
      <td valign="top"><ins><code>template &lt;class Fn, class... ArgTypes&gt;
      struct result_of&lt;Fn(ArgTypes...)&gt;;</code></ins></td>
      <td valign="top"><ins><code>Fn</code> shall be a function object type
      20.8 [function.objects], reference to function, or reference to
      function object type.
      <tt>decltype(declval&lt;Fn&gt;()(declval&lt;ArgTypes&gt;()...))</tt> shall
      be well formed.</ins></td>
      <td valign="top"><ins>The member typedef <code>type</code> 
      shall name the type <code>decltype(declval&lt;Fn&gt;()(declval&lt;ArgTypes&gt;()...))</code>.</ins></td>
    </tr>
  </tbody></table>
</blockquote>
<p>At the end of Other transformations 20.7.7.6 [meta.trans.other] add:</p>

<blockquote>
<p>[<i>Example:</i> Given these definitions:</p>

  <pre>typedef bool(&amp;PF1)();
typedef short(*PF2)(long);

struct S {
&nbsp; operator PF2() const;
&nbsp; double operator()(char, int&amp;);
 };</pre>
<p>the following assertions will hold:</p>
  <pre>static_assert(std::is_same&lt;<wbr>std::result_of&lt;S(int)&gt;::type, short&gt;::value, "Error!");
static_assert(std::is_same&lt;<wbr>std::result_of&lt;S&amp;(unsigned char, int&amp;)&gt;::type, double&gt;::value, "Error!");
static_assert(std::is_same&lt;<wbr>std::result_of&lt;PF1()&gt;::type, bool&gt;::value, "Error!");</pre>
  <p><i>&nbsp; end example</i>]</p>
</blockquote>





<hr>
<h3><a name="1271"></a>1271. CR undefined in duration operators</h3>
<p><b>Section:</b> 20.11.3.5 [time.duration.nonmember] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2009-11-21 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#time.duration.nonmember">issues</a> in [time.duration.nonmember].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
IMO <tt>CR</tt> alone is not really defined (it should be <tt>CR(Rep1,
Rep2)</tt>).
</p>

<p><i>[
2009-12-24 Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
Change 20.11.3.5 [time.duration.nonmember] paragraphs 9 and 12:
</p>

<blockquote><pre>template &lt;class Rep1, class Period, class Rep2&gt;
  duration&lt;typename common_type&lt;Rep1, Rep2&gt;::type, Period&gt;
  operator/(const duration&lt;Rep1, Period&gt;&amp; d, const Rep2&amp; s);
</pre>
<blockquote>
9 <i>Returns:</i> <tt>duration&lt;CR<ins>(Rep1, Rep2)</ins>, Period&gt;(d) /= s</tt>.
</blockquote>

<pre>template &lt;class Rep1, class Period, class Rep2&gt;
  duration&lt;typename common_type&lt;Rep1, Rep2&gt;::type, Period&gt;
  operator%(const duration&lt;Rep1, Period&gt;&amp; d, const Rep2&amp; s);
</pre>
<blockquote>
12 <i>Returns:</i> <tt>duration&lt;CR<ins>(Rep1, Rep2)</ins>, Period&gt;(d) %= s</tt>.
</blockquote>

</blockquote>





<hr>
<h3><a name="1276"></a>1276. <tt>forwardlist</tt> missing allocator constructors</h3>
<p><b>Section:</b> 23.3.3 [forwardlist] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2009-12-12 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#forwardlist">issues</a> in [forwardlist].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I found that forward_list has only
</p>

<blockquote><pre>forward_list(const forward_list&lt;T,Allocator&gt;&amp; x);
forward_list(forward_list&lt;T,Allocator&gt;&amp;&amp; x);
</pre></blockquote>

<p>
but misses
</p>

<blockquote><pre>forward_list(const forward_list&amp; x, const Allocator&amp;);
forward_list(forward_list&amp;&amp; x, const Allocator&amp;);
</pre></blockquote>

<p>
Note to other reviewers: I also checked the container adaptors for similar
inconsistencies, but as far as I can see these are already handled by the
current active issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1194">1194</a> and <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1199">1199</a>.
</p>

<p><i>[
2010-01-14 Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
In 23.3.3 [forwardlist]/3, class template forward_list synopsis change as
indicated:
</p>

<blockquote><pre>forward_list(const forward_list<del>&lt;T,Allocator&gt;</del>&amp; x);
forward_list(forward_list<del>&lt;T,Allocator&gt;</del>&amp;&amp; x);
<ins>forward_list(const forward_list&amp;, const Allocator&amp;);</ins>
<ins>forward_list(forward_list&amp;&amp;, const Allocator&amp;);</ins>
</pre></blockquote>






<hr>
<h3><a name="1277"></a>1277. <tt>std::thread::id</tt> should be trivially copyable</h3>
<p><b>Section:</b> 30.3.1.1 [thread.thread.id] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Anthony Williams <b>Opened:</b> 2009-11-24 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.thread.id">issues</a> in [thread.thread.id].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The class definition of <tt>std::thread::id</tt> in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n3000.pdf">N3000</a>
is:
</p>

<blockquote><pre>class thread::id {
public:
  id();
};
</pre></blockquote>

<p>
Typically, I expect that the internal data members will either be
pointers or integers, so that in practice the class will be trivially
copyable. However, I don't think the current wording guarantees it, and
I think it would be useful. In particular, I can see a use for
<tt>std::atomic&lt;std::thread::id&gt;</tt> to allow a <tt>thread</tt>
to claim ownership of a data structure atomicly, and
<tt>std::atomic&lt;T&gt;</tt> requires that <tt>T</tt> is trivially
copyable.
</p>

<p><i>[
2010-02-12 Moved to Tentatively Ready after 7 positive votes on c++std-lib.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
Add a new sentence to 30.3.1.1 [thread.thread.id] p1:
</p>

<blockquote>
1 An object of type <tt>thread::id</tt> provides a unique identifier for
each thread of execution and a single distinct value for all
<tt>thread</tt> objects that do not represent a thread of execution
(30.3.1 [thread.thread.class]). Each thread of execution has an
associated <tt>thread::id</tt> object that is not equal to the
<tt>thread::id</tt> object of any other thread of execution and that is
not equal to the <tt>thread::id</tt> object of any <tt>std::thread</tt>
object that does not represent threads of execution. The library may
reuse the value of a <tt>thread::id</tt> of a terminated thread that can
no longer be joined. <ins><tt>thread::id</tt> shall be a trivially
copyable class (9 [class]).</ins>
</blockquote>






<hr>
<h3><a name="1278"></a>1278. inconsistent return values for <tt>forward_list::insert_after</tt></h3>
<p><b>Section:</b> 23.3.3.4 [forwardlist.modifiers] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Bo Persson <b>Opened:</b> 2009-11-25 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#forwardlist.modifiers">issues</a> in [forwardlist.modifiers].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
After applying LDR<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#149">149</a>, <tt>forward_list</tt> now has 5
overloads of <tt>insert_after</tt>, all returning an iterator.
</p>

<p>
However, two of those - inserting a single object - return "An iterator
pointing to a copy of <tt>x</tt> [the inserted object]" while the other
three - inserting zero or more objects - return an iterator equivalent
to the position parameter, pointing before any possibly inserted
objects.
</p>

<p>
Is this the intended change? 
</p>

<p>
I don't really know what <tt>insert_after(position, empty_range)</tt>
should really return, but always returning <tt>position</tt> seems less
than useful.
</p>

<p><i>[
2010-02-04 Howard adds:
]</i></p>


<blockquote>
<p>
I agree this inconsistency will be error prone and needs to be fixed. 
Additionally <tt>emplace_after</tt>'s return value is unspecified.
</p>
</blockquote>

<p><i>[
2010-02-04 Nico provides wording.
]</i></p>


<p><i>[
2010 Pittsburgh:
]</i></p>


<blockquote>
We prefer to return an iterator to the last inserted element.  Modify the
proposed wording and then set to Ready.
</blockquote>

<p><i>[
2010-03-15 Howard adds:
]</i></p>


<blockquote>
Wording updated and set to Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
In <tt>forward_list</tt> modifiers 23.3.3.4 [forwardlist.modifiers]
make the following modifications:
</p>

<blockquote>
<pre>iterator insert_after(const_iterator position, size_type n, const T&amp; x);
</pre>
<blockquote>
<p>...</p>
<p>
10 <i>Returns:</i> <del>position.</del> <ins>An iterator pointing to the last
inserted copy of <tt>x</tt> or <tt>position</tt> if <tt>n == 0</tt>.</ins>
</p>
</blockquote>

<pre>template &lt;class InputIterator&gt;
  iterator insert_after(const_iterator position, InputIterator first, InputIterator last);
</pre>
<blockquote>
<p>...</p>

<p>
13 <i>Returns:</i> <del>position.</del> <ins>An iterator pointing to the last
inserted element or <tt>position</tt> if <tt>first == last</tt>.</ins>
</p>
</blockquote>

<pre>iterator insert_after(const_iterator position, initializer_list&lt;T&gt; il);
</pre>
<blockquote>
<p>...</p>

<p>
15 <i>Returns:</i> <del>position.</del> <ins>An iterator pointing to the last
inserted element or <tt>position</tt> if <tt>il</tt> is empty.</ins>
</p>
</blockquote>

<pre>template &lt;class... Args&gt;
  iterator emplace_after(const_iterator position, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>...</p>
<p>17 ...</p>

<p><ins>
<i>Returns:</i> An iterator pointing to the new constructed element from
args.
</ins></p>
</blockquote>

</blockquote>






<hr>
<h3><a name="1280"></a>1280. initialization of stream iterators</h3>
<p><b>Section:</b> 24.6.1.1 [istream.iterator.cons], 24.6.2.1 [ostream.iterator.cons.des] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2009-12-04 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#istream.iterator.cons">issues</a> in [istream.iterator.cons].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
24.6.1.1 [istream.iterator.cons] describes the effects in terms of:
</p>

<blockquote><pre>basic_istream&lt;charT,traits&gt;* in_stream; // exposition only
</pre>

<p>
3 <i>Effects:</i> Initializes <i>in_stream</i> with <tt>s</tt>.
</p>
</blockquote>

<p>
That should be <tt>&amp;s</tt> and similarly for 24.6.2.1 [ostream.iterator.cons.des].
</p>

<p><i>[
2009-12-23 Moved to Tentatively Ready after 6 positive votes on c++std-lib.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
Change 24.6.1.1 [istream.iterator.cons] like so:
</p>

<blockquote><pre>istream_iterator(istream_type&amp; s);
</pre>
<blockquote>
3 <i>Effects:</i> Initializes <i>in_stream</i> with <tt><ins>&amp;</ins>s</tt>.
<i>value</i> ...
</blockquote>
</blockquote>

<p>
And 24.6.2.1 [ostream.iterator.cons.des] like so:
</p>

<blockquote><pre>ostream_iterator(ostream_type&amp; s);
</pre>
<blockquote>
1 <i>Effects:</i> Initializes <i>out_stream</i> with <tt><ins>&amp;</ins>s</tt>
and <i>delim</i> with null.
</blockquote>

<pre>ostream_iterator(ostream_type&amp; s, const charT* delimiter);
</pre>
<blockquote>
2 <i>Effects:</i> Initializes <i>out_stream</i> with <tt><ins>&amp;</ins>s</tt>
and <i>delim</i> with <tt>delimiter</tt>.
</blockquote>
</blockquote>






<hr>
<h3><a name="1283"></a>1283. <tt>MoveConstructible</tt> and <tt>MoveAssignable</tt> need clarification
of moved-from state</h3>
<p><b>Section:</b> 20.2.1 [utility.arg.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-12-12 <b>Last modified:</b> 2010-11-19</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#utility.arg.requirements">issues</a> in [utility.arg.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses UK 150</b></p>

<p>
There is on going confusion over what one can and can not do with a moved-from
object (e.g.
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n3009.html#UK150">UK 150</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#910">910</a>).
This issue attempts to clarify that moved-from objects are valid objects with an
unknown state.
</p>

<p><i>[
2010-01-22 Wording tweaked by Beman.
]</i></p>


<p><i>[
2010-01-22 Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>


<p><i>[
2010-01-23 Alisdair opens:
]</i></p>


<blockquote>
<p>
I'm afraid I must register an objection.
</p>

<p>
My primary objection is that I have always been opposed to this kind of a
resolution as over-constraining.  My preferred example is a call implementing
the pImpl idiom via <tt>unique_ptr</tt>.  Once the pImpl has been moved from, it
is no longer safe to call the vast majority of the object's methods, yet I see
no reason to make such a type unusable in the standard library.  I would prefer
a resolution along the lines suggested in the UK comment, which only requires
that the object can be safely destroyed, and serve as the target of an
assignment operator (if supported.)
</p>

<p>
However, I will not hold the issue up if I am a lone dissenting voice on this
(yes, that is a call to hear more support, or I will drop that objection in
Pittsburgh)
</p>

<p>
With the proposed wording, I'm not clear what the term 'valid object' means.  In
my example above, is a pImpl holding a null pointer 'valid'?  What about a float
holding a signalling NaN?  What determines if an object is valid?  Without a
definition of a valid/invalid object, I don't think this wording adds anything,
and this is an objection that I do want resolved.
</p>

<p><i>[
2010-01-24 Alisdair removes his objection.
]</i></p>


<p><i>[
2010-01-24 Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>


</blockquote>

<p><i>[
2010-02-10 Reopened.  The wording here has been merged into <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1309">1309</a>.
]</i></p>


<p><i>[
2010-02-10 Moved to Tentatively <del>NAD Editorial</del><ins>Resolved</ins> after 5 postive votes on
c++std-lib.  Rationale added below.
]</i></p>




<p><b>Rationale:</b></p>
<p>
This issue is now addressed by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1309">1309</a>.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change the follwing tables in 20.2.1 [utility.arg.requirements] as shown:
</p>

<blockquote>

<table border="1">
<caption>Table 33  <tt>MoveConstructible</tt> requirements <b>[moveconstructible]</b></caption>
<tbody><tr>
<th>Expression</th>
<th>Post-condition</th>
</tr>
<tr>
<td>
<tt>T t(rv)</tt>
</td>
<td>
<tt>t</tt> is equivalent to the value of <tt>rv</tt> before the construction.
</td>
</tr>
<tr>
<td colspan="2">
[<i>Note:</i>
<del>There is no requirement on the value of <tt>rv</tt> after the
construction.</del>
<ins><tt>rv</tt> remains a valid object.  Its state is unspecified.</ins>
 <i>end note</i>]
</td>
</tr>
</tbody></table>

</blockquote>
<blockquote>

<table border="1">
<caption>Table 35  <tt>MoveAssignable</tt> requirements <b>[moveassignable]</b></caption>
<tbody><tr>
<th>Expression</th>
<th>Return type</th>
<th>Return value</th>
<th>Post-condition</th>
</tr>
<tr>
<td>
<tt>t = rv</tt>
</td>
<td>
<tt>T&amp;</tt>
</td>
<td>
<tt>t</tt>
</td>
<td>
<tt>t</tt> is equivalent to the value of <tt>rv</tt> before the assigment.
</td>
</tr>
<tr>
<td colspan="4">
[<i>Note:</i>
<del>There is no requirement on the value of <tt>rv</tt> after the
assignment.</del>
<ins><tt>rv</tt> remains a valid object.  Its state is unspecified.</ins>
 <i>end note</i>]
</td>
</tr>
</tbody></table>

</blockquote>





<hr>
<h3><a name="1284"></a>1284. <tt>vector&lt;bool&gt; initializer_list</tt> constructor missing an allocator argument</h3>
<p><b>Section:</b> 23.4.2 [vector.bool] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Bo Persson <b>Opened:</b> 2009-12-09 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#vector.bool">issues</a> in [vector.bool].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The specialization for <tt>vector&lt;bool&gt;</tt> (23.4.2 [vector.bool])
has a constructor
</p>

<blockquote><pre>vector(initializer_list&lt;bool&gt;);
</pre></blockquote>

<p>
which differs from the base template's constructor (and other containers) in
that it has no <tt>allocator</tt> parameter.
</p>

<p><i>[
2009-12-16 Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
Change the signature in the synopsis of 23.4.2 [vector.bool] to 
</p>

<blockquote><pre>vector(initializer_list&lt;bool&gt;<ins>, const Allocator&amp; = Allocator()</ins>);
</pre></blockquote>





<hr>
<h3><a name="1285"></a>1285. <tt>allocator_traits</tt> call to <tt>new</tt></h3>
<p><b>Section:</b> 20.9.4.2 [allocator.traits.members] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-12-10 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#allocator.traits.members">issues</a> in [allocator.traits.members].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
LWG issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#402">402</a> added "<tt>::</tt>" to the call to <tt>new</tt>
within <tt>allocator::construct</tt>.  I suspect we want to retain that fix.
</p>

<p><i>[
2009-12-13 Moved to Tentatively Ready after 7 positive votes on c++std-lib.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
Change 20.2.5 [allocator.requirements], table 40 "Allocator requirements":
</p>

<blockquote>
<table border="1">
<caption>Table 40  Allocator requirements</caption>
<tbody><tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion/note<br>pre-/post-condition</th>
<th>Default</th>
</tr>
<tr>
<td>
<tt>a.construct(c,args)</tt>
</td>
<td>
(not used)
</td>
<td>
Effect: Constructs an object of type <tt>C</tt> at <tt>c</tt>
</td>
<td>
<tt><ins>::</ins>new ((void*)c) C(forward&lt;Args&gt;(args)...)</tt>
</td>
</tr>
</tbody></table>
</blockquote>

<p>
Change 20.9.4.2 [allocator.traits.members], p4:
</p>

<blockquote><pre>template &lt;class T, class... Args&gt;
  static void construct(Alloc&amp; a, T* p, Args&amp;&amp;... args);
</pre>
<blockquote>
4 <i>Effects:</i> calls <tt>a.construct(p,
std::forward&lt;Args&gt;(args)...)</tt> if that call is well-formed; otherwise,
invokes <tt><ins>::</ins>new (static_cast&lt;void*&gt;(p))
T(std::forward&lt;Args&gt;(args)...)</tt>.
</blockquote>
</blockquote>





<hr>
<h3><a name="1286"></a>1286. <tt>allocator_traits::select_on_container_copy_construction</tt> type-o</h3>
<p><b>Section:</b> 20.9.4.2 [allocator.traits.members] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-12-10 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#allocator.traits.members">issues</a> in [allocator.traits.members].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>allocator_traits::select_on_container_copy_construction</tt> refers to an
unknown "<tt>a</tt>":
</p>

<blockquote><pre>static Alloc select_on_container_copy_construction(const Alloc&amp; rhs);
</pre>

<blockquote>
7 <i>Returns:</i> <tt>rhs.select_on_container_copy_construction(a)</tt> if that
expression is well-formed; otherwise, <tt>rhs</tt>.
</blockquote>
</blockquote>

<p><i>[
2009-12-13 Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
Change 20.9.4.2 [allocator.traits.members], p7:
</p>

<blockquote><pre>static Alloc select_on_container_copy_construction(const Alloc&amp; rhs);
</pre>

<blockquote>
7 <i>Returns:</i>
<tt>rhs.select_on_container_copy_construction(<del>a</del>)</tt> if that
expression is well-formed; otherwise, <tt>rhs</tt>.
</blockquote>
</blockquote>





<hr>
<h3><a name="1287"></a>1287. <tt>std::function</tt> requires <tt>CopyConstructible</tt> target object</h3>
<p><b>Section:</b> 20.8.14.2.1 [func.wrap.func.con] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2009-12-13 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#func.wrap.func.con">issues</a> in [func.wrap.func.con].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I think <tt>std::function</tt> should require <tt>CopyConstructible</tt> for the
target object.
</p>

<p>
I initially thought that <tt>MoveConstructible</tt> was enough, but it's not. If
<tt>F</tt> is move-only then function's copy constructor cannot be called, but
because function uses type erasure, <tt>F</tt> is not known and so the copy
constructor cannot be disabled via <tt>enable_if</tt>.  One option would be to
throw an exception if you try to copy a function with a non-copyable target
type, but I think that would be a terrible idea.
</p>

<p>
So although the constructors require that the target be initialised by
<tt>std::move(f)</tt>, that's only an optimisation, and a copy constructor is
required.
</p>

<p><i>[
2009-12-24 Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
Add to 20.8.14.2.1 [func.wrap.func.con] paragraph 9:
</p>

<blockquote><pre>template&lt;class F&gt; function(F f);
template &lt;class F, class A&gt; function(allocator_arg_t, const A&amp; a, F f);
</pre>

<blockquote>
9  <i>Requires:</i> <ins><tt>F</tt> shall be <tt>CopyConstructible</tt>.</ins>
<tt>f</tt> shall be callable for argument types <tt>ArgTypes</tt> and return
type <tt>R</tt>. The copy constructor and destructor of <tt>A</tt> shall not
throw exceptions.
</blockquote>
</blockquote>






<hr>
<h3><a name="1288"></a>1288. <tt>std::function</tt> assignment from rvalues</h3>
<p><b>Section:</b> 20.8.14.2.1 [func.wrap.func.con] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2009-12-13 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#func.wrap.func.con">issues</a> in [func.wrap.func.con].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 20.8.14.2.1 [func.wrap.func.con]
</p>

<blockquote><pre>template&lt;class F&gt; function&amp; operator=(F f);
</pre>
<blockquote>
<p>
20        <i>Effects:</i> <tt>function(f).swap(*this);</tt>
</p>
<p>
21        <i>Returns:</i> <tt>*this</tt>
</p>
</blockquote>
</blockquote>

<p>
This assignment operator can be called such that <tt>F</tt> is an rvalue-reference e.g.
</p>

<blockquote><pre>func.operator=&lt;F&amp;&amp;&gt;(f);
</pre></blockquote>

<p>
There are two issues with this.
</p>

<ol>
<li>
the effects mean that <tt>f</tt> is passed as an lvalue and so there will be an
unnecessary copy. The argument should be forwarded, so that the copy can be
avoided.
</li>
<li>
It should not be necessary to use that syntax to pass an rvalue. As <tt>F</tt>
is a deduced context it can be made to work with either lvalues or rvalues.
</li>
</ol>

<p>
The same issues apply to <tt>function::assign</tt>.
</p>

<p>
N.B. this issue is not related to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1287">1287</a> and applies whether that
issue is resolved or not. The wording below assumes the resolution of LWG <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1258">1258</a> has been applied.
</p>

<p><i>[
2009-12-16 Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>


<p><i>[
201002-11 Opened by Alisdair for the purpose of merging <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1258">1258</a> into
this issue as there is a minor conflict.
]</i></p>


<p><i>[
2010-02-11 Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
In 20.8.14.2.1 [func.wrap.func.con]
</p>

<blockquote><pre>template&lt;class F&gt; function&amp; operator=(F<ins>&amp;&amp;</ins> f);
</pre>
<blockquote>
<p>
20 <i>Effects:</i>
<tt>function(<ins>std::forward&lt;F&gt;(</ins>f<ins>)</ins>).swap(*this);</tt>
</p>
<p>
21        <i>Returns:</i> <tt>*this</tt>
</p>
</blockquote>
</blockquote>

<p>
In 20.8.14.2.2 [func.wrap.func.mod]
</p>

<blockquote><pre>template&lt;class F, <del>Allocator Alloc</del><ins>class A</ins>&gt;
  void assign(F<ins>&amp;&amp; f</ins>, const A<del>lloc</del>&amp; a);
</pre>
<blockquote>
<p>
<ins>3</ins> <i>Effects:</i> <tt>function(<del>f, a</del><ins>allocator_arg, a,
std::forward&lt;F&gt;(f)</ins>).swap(*this);</tt>
</p>
</blockquote>
</blockquote>

<p>
Update member function signature for class template in 20.8.14.2 [func.wrap.func]
</p>

<blockquote><pre>template&lt;class F&gt; function&amp; operator=(F<ins>&amp;&amp;</ins>);

template&lt;class F, class A&gt; void assign(F<ins>&amp;&amp;</ins>, const A&amp;);
</pre></blockquote>







<hr>
<h3><a name="1290"></a>1290. Don't require <tt>[u|bi]nary_function</tt> inheritance</h3>
<p><b>Section:</b> 20.8 [function.objects] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2009-12-14 <b>Last modified:</b> 2010-11-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#function.objects">issues</a> in [function.objects].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p>
This issue is a follow-up of the discussion on issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#870">870</a> during
the 2009 Santa Cruz meeting.
</p>

<p>
The class templates <tt>unary_function</tt> and <tt>binary_function</tt> are
actually very simple typedef providers,
</p>

<blockquote><pre>namespace std {

template &lt;class Arg, class Result&gt;
struct unary_function {
 typedef Arg argument_type;
 typedef Result result_type;
};

template &lt;class Arg1, class Arg2, class Result&gt;
struct binary_function {
 typedef Arg1 first_argument_type;
 typedef Arg2 second_argument_type;
 typedef Result result_type;
};

}
</pre></blockquote>

<p>
which <i>may</i> be used as base classes (similarly to the iterator template),
but were originally <i>not</i> intended as a customization point. The SGI
documentation introduced the concept <a href="http://www.sgi.com/tech/stl/AdaptableUnaryFunction.html">Adaptable Unary
Function</a> as function objects "with nested typedefs that define its argument
type and result type" and a similar definition for <a href="http://www.sgi.com/tech/stl/AdaptableBinaryFunction.html">Adaptable Binary
Function</a> related to <tt>binary_function</tt>. But as of TR1 a protocol was
introduced that relies on inheritance relations based on these types. 20.8.4 [refwrap]/3 b. 3 requires that a specialization of
<tt>reference_wrapper&lt;T&gt;</tt> shall derive from <tt>unary_function</tt>,
if type <tt>T</tt> is "a class type that is derived from
<tt>std::unary_function&lt;T1, R&gt;</tt>" and a similar inheritance-based rule
for <tt>binary_function</tt> exists as well.
</p>

<p>
As another disadvantage it has been pointed out in the TR1 issue list, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1837.pdf">N1837</a>
(see section 10.39), that the requirements of <tt>mem_fn</tt> 20.8.13 [func.memfn]/2+3 to <em>derive</em> from
<tt>std::unary_function/std::binary_function</tt> under circumstances, where the
provision of corresponding typedefs would be sufficient, unnecessarily prevent
implementations that take advantage of empty-base-class- optimizations.
</p>

<p>
Both requirements should be relaxed in the sense that the
<tt>reference_wrapper</tt> should provide typedef's <tt>argument_type</tt>,
<tt>first_argument_type</tt>, and <tt>second_argument_type</tt> based on similar
rules as the <i>weak result type</i> rule (20.8.2 [func.require]/3) does
specify the presence of <tt>result_type</tt> member types.
</p>

<p>
For a related issue see also <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1279">1279</a>.
</p>

<p><i>[
2010-10-24 Daniel adds:
]</i></p>


<blockquote>
Accepting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3145.html">n3145</a> would resolve this issue as NAD editorial.
</blockquote>



<p><i>[
2010-11 Batavia: Solved by N3198
]</i></p>

<p>
Resolved by adopting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3198.html">n3198</a>.
</p>

<p>
Previous proposed resolution:

</p><p><i>[
The here proposed resolution is an attempt to realize the common denominator of
the reflector threads c++std-lib-26011, c++std-lib-26095, and c++std-lib-26124.
]</i></p>


<ol>
<li>
<p>
Change X [base]/1 as indicated: <i>[The intend is to provide an
alternative fix for issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1279">1279</a> and some editorial harmonization
with existing wording in the library, like 24.4.2 [iterator.basic]/1]</i>
</p>

<blockquote>
<p>
1 The following class<ins> templat</ins>es are provided to simplify the
<ins>definition of</ins> typedefs of the argument and result types <ins>for
function objects. The behavior of a program that adds specializations for any of
these templates is undefined.</ins><del>:</del>
</p>

<blockquote><pre>namespace std {
 template &lt;class Arg, class Result&gt;
 struct unary_function {
   typedef Arg argument_type;
   typedef Result result_type;
 };
}

namespace std {
 template &lt;class Arg1, class Arg2, class Result&gt;
 struct binary_function {
   typedef Arg1 first_argument_type;
   typedef Arg2 second_argument_type;
   typedef Result result_type;
 };
}
</pre></blockquote>
</blockquote>
</li>

<li>
<p>
Change 20.8.4 [refwrap], class template <tt>reference_wrapper</tt>
synopsis as indicated: <i>[The intent is to remove the requirement that
<tt>reference_wrapper</tt> derives from <tt>unary_function</tt> or
<tt>binary_function</tt> if the situation requires the definition of the
typedefs <tt>argument_type</tt>, <tt>first_argument_type</tt>, or
<tt>second_argument_type</tt>. This change is suggested, because the new way of
definition uses the same strategy as the <em>weak result type</em> specification
applied to argument types, which provides the following advantages: It creates
less potential conflicts between <tt>[u|bi]nary_function</tt> bases and typedefs
in a function object and it ensures that user-defined function objects which
provide typedefs but no such bases are handled as first class citizens.]</i>
</p>

<blockquote><pre>namespace std {
 template &lt;class T&gt; class reference_wrapper
   <del>: public unary_function&lt;T1, R&gt; // <i>see below</i></del>
   <del>: public binary_function&lt;T1, T2, R&gt; // <i>see below</i></del>
 {
 public :
   // types
   typedef T type;
   typedef <i>see below</i> result_type; // not always defined
   <ins>typedef <i>see below</i> argument_type; // not always defined</ins>
   <ins>typedef <i>see below</i> first_argument_type; // not always defined</ins>
   <ins>typedef <i>see below</i> second_argument_type; // not always defined</ins>

   // construct/copy/destroy
   ...
 };
</pre></blockquote>
</li>

<li>
<p>
Change 20.8.4 [refwrap]/3 as indicated: <i>[The intent is to remove the
requirement that <tt>reference_wrapper</tt> derives from <tt>unary_function</tt>
if the situation requires the definition of the typedef <tt>argument_type</tt>
and <tt>result_type</tt>. Note that this clause does concentrate on
<tt>argument_type</tt> alone, because the <tt>result_type</tt> is already ruled
by p. 2 via the <em>weak result type</em> specification. The new way of
specifying <tt>argument_type</tt> is equivalent to the <em>weak result type</em>
specification]</i>
</p>

<blockquote>
<p>
3 The template instantiation <tt>reference_wrapper&lt;T&gt;</tt> shall <del>be
derived from <tt>std::unary_function&lt;T1, R&gt;</tt></del><ins>define a nested
type named <tt>argument_type</tt> as a synonym for <tt>T1</tt></ins> only if the
type <tt>T</tt> is any of the following:
</p>
<ul>
<li>a function type or a pointer to function type taking one argument
of type <tt>T1</tt><del> and returning <tt>R</tt></del>
</li>
<li>a pointer to member function <tt>R T0::f</tt> <em>cv</em> (where
<em>cv</em> represents the member function's cv-qualifiers);
the type <tt>T1</tt> is <em>cv</em> <tt>T0*</tt>
</li>
<li>a class type <del>that is derived from
<tt>std::unary_function&lt;T1, R&gt;</tt></del><ins>with a member type
<tt>argument_type</tt>;
	the type <tt>T1</tt> is <tt>T::argument_type</tt></ins>
</li>
</ul>
</blockquote>
</li>

<li>
<p>
Change 20.8.4 [refwrap]/4 as indicated: <i>[The intent is to remove the
requirement that <tt>reference_wrapper</tt> derives from
<tt>binary_function</tt> if the situation requires the definition of the typedef
<tt>first_argument_type</tt>, <tt>second_argument_type</tt>, and
<tt>result_type</tt>. Note that this clause does concentrate on
<tt>first_argument_type</tt> and <tt>second_argument_type</tt> alone, because
the <tt>result_type</tt> is already ruled by p. 2 via the <em>weak result
type</em> specification. The new way of specifying <tt>first_argument_type</tt>
and <tt>second_argument_type</tt> is equivalent to the <em>weak result type</em>
specification]</i>
</p>

<blockquote>
<p>
The template instantiation <tt>reference_wrapper&lt;T&gt;</tt> shall <del>be
derived from <tt>std::binary_function&lt;T1, T2, R&gt;</tt></del><ins>define two
nested types named <tt>first_argument_type</tt> and
<tt>second_argument_type</tt> as a synonym for <tt>T1</tt> and <tt>T2</tt>,
respectively,</ins> only if the type <tt>T</tt> is any of the following:
</p>
<ul>
<li>a function type or a pointer to function type taking two arguments
of types <tt>T1</tt> and <tt>T2</tt><del> and returning
<tt>R</tt></del>
</li>
<li>a pointer to member function <tt>R T0::f(T2)</tt> <em>cv</em>
(where <em>cv</em> represents the member function's cv-qualifiers);
	the type <tt>T1</tt> is <em>cv</em> <tt>T0*</tt>
</li>
<li>a class type <del>that is derived from
<tt>std::binary_function&lt;T1, T2, R&gt;</tt></del><ins>with member
types <tt>first_argument_type</tt>
	and <tt>second_argument_type</tt>; the type <tt>T1</tt> is
<tt>T::first_argument_type</tt> and the type <tt>T2</tt> is
	<tt>T::second_argument_type</tt></ins>
</li>
</ul>
</blockquote>
</li>

<li>
<p>
Change 20.8.13 [func.memfn]/2+3 as indicated: <i>[The intent is to remove
the requirement that mem_fn's return type has to derive
from <tt>[u|bi]nary_function</tt>. The reason for suggesting the
change here is to better support empty-base-class optimization
choices as has been pointed out in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1837.pdf">N1837</a>]</i>
</p>

<blockquote>
<p>
2 The simple call wrapper shall <del>be derived from
<tt>std::unary_function&lt;<em>cv</em> T*, <i>Ret</i>&gt;</tt></del><ins>define
two nested types named <tt>argument_type</tt> and <tt>result_type</tt> as a
synonym for <tt><em>cv</em> T*</tt> and <tt><i>Ret</i></tt>, respectively,</ins>
when <tt>pm</tt> is a pointer to member function with cv-qualifier <em>cv</em>
and taking no arguments, where <tt><i>Ret</i></tt> is <tt>pm</tt>'s return type.
</p>
<p>
3 The simple call wrapper shall <del>be derived from
<tt>std::binary_function&lt;<em>cv</em> T*, T1,
<i>Ret</i>&gt;</tt></del><ins>define three nested types named
<tt>first_argument_type</tt>, <tt>second_argument_type</tt>, and
<tt>result_type</tt> as a synonym for <tt><em>cv</em> T*</tt>, <tt>T1</tt>, and
<tt><i>Ret</i></tt>, respectively,</ins> when <tt>pm</tt> is a pointer to member
function with cv-qualifier <em>cv</em> and taking one argument of type
<tt>T1</tt>, where <tt><i>Ret</i></tt> is <tt>pm</tt>'s return type.
</p>
</blockquote>
</li>

</ol>
<p></p>

<p><b>Proposed resolution:</b></p>
Addressed by paper <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3198.html">n3198</a>.




<hr>
<h3><a name="1292"></a>1292. <tt>std::function</tt> should support all callable types</h3>
<p><b>Section:</b> 20.8.14.2.1 [func.wrap.func.con] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2009-12-19 <b>Last modified:</b> 2010-11-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#func.wrap.func.con">issues</a> in [func.wrap.func.con].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Some parts of the specification of <tt>std::function</tt> is unnecessarily
restricted to a subset of all callable types (as defined in 20.8.1 [func.def]/3), even though the intent clearly is to be usable for
<em>all</em> of them as described in 20.8.14.2 [func.wrap.func]/1. This
argument becomes strengthened by the fact that current C++0x-compatible
compilers work fine with them:
</p>

<blockquote><pre>#include &lt;functional&gt;
#include &lt;iostream&gt;

struct A
{
  int foo(int i) const {return i+1;}
};

struct B
{
  int mem;
};

int main()
{
  std::function&lt;int(const A&amp;, int)&gt; f(&amp;A::foo);
  A a;
  std::cout &lt;&lt; f(a, 1) &lt;&lt; '\n';
  std::cout &lt;&lt; f.target_type().name() &lt;&lt; '\n';
  typedef int (A::* target_t)(int) const;
  target_t* p = f.target&lt;target_t&gt;();
  std::cout &lt;&lt; (p != 0) &lt;&lt; '\n';
  std::function&lt;int(B&amp;)&gt; f2(&amp;B::mem);
  B b = { 42 };
  std::cout &lt;&lt; f2(b) &lt;&lt; '\n';
  std::cout &lt;&lt; f2.target_type().name() &lt;&lt; '\n';
  typedef int (B::* target2_t);
  target2_t* p2 = f2.target&lt;target2_t&gt;();
  std::cout &lt;&lt; (p2 != 0) &lt;&lt; '\n';
}
</pre></blockquote>

<p>
The problematics passages are 20.8.14.2.1 [func.wrap.func.con]/10:
</p>

<blockquote><pre>template&lt;class F&gt; function(F f);
template &lt;class F, class A&gt; function(allocator_arg_t, const A&amp; a, F f);
</pre>
<blockquote>
<p>...</p>
<p>
10 <i>Postconditions:</i> <tt>!*this</tt> if any of the following hold:
</p>
<ul>
<li>
<tt>f</tt> is a NULL function pointer.
</li>
<li>
<tt>f</tt> is a NULL member function pointer.
</li>
<li>
<tt>F</tt> is an instance of the function class template, and <tt>!f</tt>
</li>
</ul>
</blockquote>
</blockquote>

<p>
because it does not consider pointer to data member and all constraints based on
<em>function objects</em> which like 20.8.14.2 [func.wrap.func]/2 or 20.8.14.2.5 [func.wrap.func.targ]/3. The latter two will be resolved by the proposed
resolution of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#870">870</a> and are therefore not handled here.
</p>

<p><i>[
Post-Rapperswil:
]</i></p>


<blockquote>
Moved to Tentatively Ready after 5 positive votes on c++std-lib.
</blockquote>

<p><i>[
Adopted at 2010-11 Batavia
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
Change 20.8.14.2.1 [func.wrap.func.con]/10+11 as indicated:
</p>

<blockquote><pre>template&lt;class F&gt; function(F f);
template &lt;class F, class A&gt; function(allocator_arg_t, const A&amp; a, F f);
</pre>
<blockquote>
<p>...</p>
<p>
10 <i>Postconditions:</i> <tt>!*this</tt> if any of the following hold:
</p>
<ul>
<li>
<tt>f</tt> is a NULL function pointer.
</li>
<li>
<tt>f</tt> is a NULL <ins>pointer to</ins> member <del>function pointer</del>.
</li>
<li>
<tt>F</tt> is an instance of the function class template, and <tt>!f</tt>
</li>
</ul>

<p>
11 Otherwise, <tt>*this</tt> targets a copy of <tt>f</tt> <del>or</del><ins>,
initialized with</ins> <tt>std::move(f)</tt> <del>if <tt>f</tt> is not a pointer
to member function, and targets a copy of <tt>mem_fn(f)</tt> if <tt>f</tt> is a
pointer to member function</del>. [<i>Note:</i> implementations are encouraged
to avoid the use of dynamically allocated memory for small function objects, for
example, where <tt>f</tt>'s target is an object holding only a pointer or
reference to an object and a member function pointer.  <i>end note</i>]
</p>

</blockquote>
</blockquote>





<hr>
<h3><a name="1293"></a>1293. <tt>unique_ptr&lt;T[], D&gt;</tt> needs to get rid of <i>unspecified-pointer-type</i></h3>
<p><b>Section:</b> 20.9.9.3 [unique.ptr.runtime] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2009-12-20 <b>Last modified:</b> 2010-11-19</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses UK 211</b></p>

<p>
As a response to UK 211 LWG issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1021">1021</a> has replaced the
<i>unspecified-pointer-type</i> by <tt>nullptr_t</tt> to allow assignment of
type-safe null-pointer literals in the non-array form of
<tt>unique_ptr::operator=</tt>, but did not the same for the specialization for
arrays of runtime length. But without this parallel change of the signature we
have a status quo, where <tt>unique_ptr&lt;T[], D&gt;</tt> declares a member
function which is completely unspecified.
</p>

<p><i>[
2009-12-21 Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>


<p><i>[
2010-03-14 Howard adds:
]</i></p>


<blockquote>
We moved
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3073.html">N3073</a>
to the formal motions page in Pittsburgh which should obsolete this issue.  I've
moved this issue to NAD Editorial, solved by N3073.
</blockquote>



<p><b>Rationale:</b></p>
<p>
Solved by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3073.html">N3073</a>.
</p>


<p><b>Proposed resolution:</b></p>
<p>
In 20.9.9.3 [unique.ptr.runtime], class template <tt>unique_ptr&lt;T[],
D&gt;</tt> synopsis, change as indicated:
</p>

<blockquote><pre>// assignment
unique_ptr&amp; operator=(unique_ptr&amp;&amp; u);
unique_ptr&amp; operator=(<del><i>unspecified-pointer-type</i></del><ins>nullptr_t</ins>);
</pre></blockquote>






<hr>
<h3><a name="1294"></a>1294. Difference between callable wrapper and forwarding  call wrapper unclear</h3>
<p><b>Section:</b> 20.8.2 [func.require] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Jens Maurer <b>Opened:</b> 2009-12-21 <b>Last modified:</b> 2010-11-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#func.require">issues</a> in [func.require].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The current wording in the standard makes it hard to discriminate the difference
between a "call wrapper" as defined in 20.8.1 [func.def]/5+6:
</p>

<blockquote>
<p>
5 A <i>call wrapper type</i> is a type that holds a callable object and supports
a call operation that forwards to that object.
</p>
<p>
6 A <i>call wrapper</i> is an object of a call wrapper type.
</p>
</blockquote>

<p>
and a "forwarding call wrapper" as defined in 20.8.2 [func.require]/4:
</p>

<blockquote>
<p>
4 [..] A <i>forwarding call wrapper</i> is a call wrapper that can be called
with an argument list. [<i>Note:</i> in a typical implementation forwarding call
wrappers have an overloaded function call operator of the form
</p>

<blockquote><pre>template&lt;class... ArgTypes&gt;
R operator()(ArgTypes&amp;&amp;... args) <i>cv-qual</i>;
</pre></blockquote>

<p>
 <i>end note</i>]
</p>
</blockquote>

<p>
Reason for this lack of clear difference seems to be that the wording adaption
to variadics and rvalues that were applied after it's original proposal in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1673.html#call%20wrapper">N1673</a>:
</p>

<blockquote>
<p>
[..] A <b>forwarding call wrapper</b> is a call wrapper that can be called
with an argument list <tt>t1, t2, ..., tN</tt> where each <tt>ti</tt> is an lvalue.
The effect of calling a forwarding call wrapper with one or more
arguments that are rvalues is implementation defined. [<i>Note:</i> in
a typical implementation forwarding call wrappers have overloaded
function call operators of the form
</p>

<blockquote><pre>template&lt;class T1, class T2, ..., class TN&gt;
R operator()(T1&amp; t1, T2&amp; t2, ..., TN&amp; tN) <i>cv-qual</i>;
</pre></blockquote>

<p>
 <i>end note</i>]
</p>
</blockquote>

<p>
combined with the fact that the word "forward" has two different meanings in
this context. This issue attempts to clarify the difference better.
</p>

<p><i>[
2010-09-14 Daniel provides improved wording and verified that it is correct against N3126. Previous resolution is shown here:
]</i></p>


<blockquote>
<p>
4 [..] A <i>forwarding call wrapper</i> is a call wrapper that can be called
with an <ins>arbitrary</ins> argument list<ins> and uses perfect forwarding to
deliver the arguments to the wrapped callable object</ins>. [<i>Note:</i> in a
typical implementation forwarding call wrappers have an overloaded function call
operator of the form
</p>

<blockquote><pre>template&lt;class... ArgTypes&gt;
R operator()(ArgTypes&amp;&amp;... args) <i>cv-qual</i>;
</pre></blockquote>

<p>
 <i>end note</i>]
</p>
</blockquote>

<p><i>[
Adopted at 2010-11 Batavia
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
Change 20.8.2 [func.require]/4 as indicated:
</p>

<blockquote><p>
[..] A <em>forwarding call wrapper</em> is a call wrapper that can be called with an <ins>arbitrary</ins> argument 
list <ins>and delivers the arguments as references to the wrapped callable object. This forwarding step shall ensure
that rvalue arguments are delivered as rvalue-references and lvalue arguments are delivered as lvalue-references</ins>. 
[<em>Note</em>: in a typical implementation forwarding call wrappers have an overloaded function call operator of the 
form
</p>

<blockquote><pre>template&lt;class... UnBoundArgs&gt;
R operator()(UnBoundArgs&amp;&amp;... unbound_args) <em>cv-qual</em>;
</pre></blockquote>
<p>
 <em>end note</em> ]
</p>
</blockquote>






<hr>
<h3><a name="1295"></a>1295. Contradictory call wrapper requirements</h3>
<p><b>Section:</b> 20.8.2 [func.require] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2009-12-22 <b>Last modified:</b> 2010-11-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#func.require">issues</a> in [func.require].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
20.8.2 [func.require]/3 b 1 says
</p>

<blockquote>
<p>
3 If a call wrapper (20.8.1 [func.def]) has a <i>weak result type</i> the
type of its member type <tt>result_type</tt> is based on the type <tt>T</tt> of
the wrapper's target object (20.8.1 [func.def]):
</p>

<ul>
<li>
if <tt>T</tt> is a function, reference to function, or pointer to function type,
<tt>result_type</tt> shall be a synonym for the return type of <tt>T</tt>;
</li>
<li>
[..]
</li>
</ul>
</blockquote>

<p>
The first two enumerated types (function and reference to function)
can never be valid types for <tt>T</tt>, because
</p>

<p>
20.8.1 [func.def]/7
</p>

<blockquote>
7 A <i>target object</i> is the callable object held by a call wrapper.
</blockquote>

<p>
and 20.8.1 [func.def]/3
</p>

<blockquote>
3 A <i>callable type</i> is a pointer to function, a pointer to member function,
a pointer to member data, or a class type whose objects can appear immediately
to the left of a function call operator.
</blockquote>

<p>
exclude functions and references to function as "target objects".
</p>

<p><i>[
Post-Rapperswil:
]</i></p>


<blockquote>
Moved to Tentatively Ready after 5 positive votes on c++std-lib.
</blockquote>

<p><i>[
Adopted at 2010-11 Batavia
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
Change 20.8.2 [func.require]/3 b 1 as indicated:
</p>

<blockquote>
<p>
3 If a call wrapper (20.8.1 [func.def]) has a <i>weak result type</i> the
type of its member type <tt>result_type</tt> is based on the type <tt>T</tt> of
the wrapper's target object (20.8.1 [func.def]):
</p>

<ul>
<li>
if <tt>T</tt> is a <del>function, reference to function, or</del> pointer to
function type, <tt>result_type</tt> shall be a synonym for the return type of
<tt>T</tt>;
</li>
<li>
[..]
</li>
</ul>
</blockquote>






<hr>
<h3><a name="1298"></a>1298. Missing specialization of <tt>ctype_byname&lt;char&gt;</tt></h3>
<p><b>Section:</b> 22.2 [locale.syn] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-12-25 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <tt>&lt;locale&gt;</tt> synopsis in 22.2 [locale.syn] calls out an
explicit specialization for <tt>ctype_byname&lt;char&gt;</tt>, however no such
specialization is defined in the standard.  The only reference I can find to
<tt>ctype_byname&lt;char&gt;</tt> is 22.3.1.1.2 [locale.facet]:Table 77
 Required specializations (for facets) which also refers to
<tt>ctype_byname&lt;wchar_t&gt;</tt> which has no special consideration.
</p>

<p>
Is the intent an explicit <em>instantiation</em> which would use a slightly
different syntax? Should the explicit specialization simply be struck?
</p>

<p><i>[
2010-01-31 Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
22.2 [locale.syn]
</p>

<blockquote>
<p>
Strike the explicit specialization for <tt>ctype_byname&lt;char&gt;</tt> from
the <tt>&lt;locale&gt;</tt> synopsis
</p>
<blockquote><pre>...
template &lt;class charT&gt; class ctype_byname;
<del>template &lt;&gt;            class ctype_byname&lt;char&gt;;  // <i>specialization</i></del>
...
</pre></blockquote>
</blockquote>





<hr>
<h3><a name="1299"></a>1299. Confusing typo in specification for <tt>get_time</tt></h3>
<p><b>Section:</b> 27.7.4 [ext.manip] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-12-25 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#ext.manip">issues</a> in [ext.manip].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Extended Manipulators 27.7.4 [ext.manip] p8 defines the semantics of
<tt>get_time</tt> in terms of a function <tt>f</tt>.
</p>

<blockquote><pre>template &lt;class charT, class traits&gt;
void f(basic_ios&lt;charT, traits&gt;&amp; str, struct tm* tmb, const charT* fmt) {
   typedef istreambuf_iterator&lt;charT, traits&gt; Iter;
   typedef time_get&lt;charT, Iter&gt; TimeGet;

   ios_base::iostate err = ios_base::goodbit;
   const TimeGet&amp; tg = use_facet&lt;TimeGet&gt;(str.getloc());

   tm.get(Iter(str.rdbuf()), Iter(), str, err, tmb, fmt, fmt + traits::length(fmt));

   if (err != ios_base::goodbit)
       str.setstate(err):
}
</pre></blockquote>

<p>
Note the call to <tt>tm.get</tt>.  This is clearly an error, as <tt>tm</tt> is a
type and not an object.  I believe this should be <tt>tg.get</tt>, rather than
<tt>tm</tt>, but this is not my area of expertise.
</p>

<p><i>[
2010-01-14 Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
Change 27.7.4 [ext.manip] p8:
</p>

<blockquote><pre>template &lt;class charT, class traits&gt;
void f(basic_ios&lt;charT, traits&gt;&amp; str, struct tm* tmb, const charT* fmt) {
   typedef istreambuf_iterator&lt;charT, traits&gt; Iter;
   typedef time_get&lt;charT, Iter&gt; TimeGet;

   ios_base::iostate err = ios_base::goodbit;
   const TimeGet&amp; tg = use_facet&lt;TimeGet&gt;(str.getloc());

   t<ins>g</ins><del>m</del>.get(Iter(str.rdbuf()), Iter(), str, err, tmb, fmt, fmt + traits::length(fmt));

   if (err != ios_base::goodbit)
       str.setstate(err):
}
</pre></blockquote>





<hr>
<h3><a name="1303"></a>1303. <tt>shared_ptr</tt>, <tt>unique_ptr</tt>, and rvalue references v2</h3>
<p><b>Section:</b> 20.9.9.2 [unique.ptr.single], 20.9.10.2 [util.smartptr.shared] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2010-01-23 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#unique.ptr.single">issues</a> in [unique.ptr.single].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n3000.pdf">N3000</a>
20.9.10.2 [util.smartptr.shared]/1 still says:
</p>

<blockquote><pre>template &lt;class Y, class D&gt; explicit shared_ptr(const unique_ptr&lt;Y, D&gt;&amp; r) = delete;
template &lt;class Y, class D&gt; shared_ptr&amp; operator=(const unique_ptr&lt;Y, D&gt;&amp; r) = delete;
</pre></blockquote>

<p>
I believe that this is unnecessary now that "rvalue references v2"
prevents rvalue references from binding to lvalues, and I didn't
see a Library Issue tracking this.
</p>

<p><i>[
2010-02-12 Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>




<p><b>Proposed resolution:</b></p>

<p>
Strike from 20.9.9.2 [unique.ptr.single]:
</p>

<blockquote><pre>template &lt;class T, class D = default_delete&lt;T&gt;&gt; class unique_ptr {
  ...
  unique_ptr(const unique_ptr&amp;) = delete;
  <del>template &lt;class U, class E&gt; unique_ptr(const unique_ptr&lt;U, E&gt;&amp;) = delete;</del>
  unique_ptr&amp; operator=(const unique_ptr&amp;) = delete;
  <del>template &lt;class U, class E&gt; unique_ptr&amp; operator=(const unique_ptr&lt;U, E&gt;&amp;) = delete;</del>
};
</pre></blockquote>

<p>
Strike from 20.9.10.2 [util.smartptr.shared]:
</p>

<blockquote><pre>template&lt;class T&gt; class shared_ptr {
  ...
  <del>template &lt;class Y, class D&gt; explicit shared_ptr(const unique_ptr&lt;Y, D&gt;&amp; r) = delete;</del>
  ...
  <del>template &lt;class Y, class D&gt; shared_ptr&amp; operator=(const unique_ptr&lt;Y, D&gt;&amp; r) = delete;</del>
  ...
};
</pre></blockquote>






<hr>
<h3><a name="1306"></a>1306. <tt>pointer</tt> and <tt>const_pointer</tt> for <tt>&lt;array&gt;</tt></h3>
<p><b>Section:</b> 23.3.1 [array] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Nicolai Josuttis <b>Opened:</b> 2010-01-24 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#array">issues</a> in [array].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Class <tt>&lt;array&gt;</tt> is the only sequence container class that has no
types <tt>pointer</tt> and <tt>const_pointer</tt> defined. You might argue that
this makes no sense because there is no allocator support, but on the other
hand, types <tt>reference</tt> and <tt>const_reference</tt> are defined for
<tt>array</tt>.
</p>

<p><i>[
2010-02-11 Moved to Tentatively Ready after 6 positive votes on c++std-lib.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
Add to Class template array 23.3.1 [array]:
</p>

<blockquote><pre>namespace std {
  template &lt;class T, size_t N &gt;
  struct array {
    ...
    typedef T value_type;
    <ins>typedef T * pointer;</ins>
    <ins>typedef const T * const_pointer;</ins>
    ...
  };
}
</pre></blockquote>





<hr>
<h3><a name="1307"></a>1307. <tt>exception_ptr</tt> and <tt>allocator</tt> pointers don't understand !=</h3>
<p><b>Section:</b> 18.8.5 [propagation] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2010-01-26 <b>Last modified:</b> 2010-11-19</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#propagation">active issues</a> in [propagation].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#propagation">issues</a> in [propagation].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The current requirements for a conforming implementation of
<tt>std::exception_ptr</tt> (18.8.5 [propagation]/1-6) does not clarify
whether the expression
</p>

<blockquote><pre>e1 != e2
e1 != nullptr
</pre></blockquote>

<p>
with <tt>e1</tt> and <tt>e2</tt> being two values of type
<tt>std::exception_ptr</tt> are supported or not. Reason for this oddity is that
the concept <tt>EqualityComparable</tt> does not provide operator <tt>!=</tt>.
</p>

<p>
For the same reason programmers working against the types <tt>X::pointer</tt>,
<tt>X::const_pointer</tt>, <tt>X::void_pointer</tt>, and
<tt>X::const_void_pointer</tt> of any allocator concept <tt>X</tt> (20.2.5 [allocator.requirements]/4 + Table 40) in a generic context can not rely
on the availability of the != operation, which is rather unnatural and
error-prone.
</p>

<p><i>[
2010 Pittsburgh:  Moved to NAD Editorial.  Rationale added below.
]</i></p>




<p><b>Rationale:</b></p>
<p>
Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3073.html">N3073</a>.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1309"></a>1309. Missing expressions for <tt>Move/CopyConstructible</tt></h3>
<p><b>Section:</b> 20.2.1 [utility.arg.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2010-02-03 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#utility.arg.requirements">issues</a> in [utility.arg.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Table 33  MoveConstructible requirements [moveconstructible] and
Table 34  CopyConstructible requirements [copyconstructible] support
solely the following expression:
</p>

<blockquote><pre>T t(rv)
</pre></blockquote>

<p>
where <tt>rv</tt> is defined to be as "non-const rvalue of type <tt>T</tt>"  and
<tt>t</tt> as a "modifiable lvalue of type <tt>T</tt>" in 20.2.1 [utility.arg.requirements]/1.
</p>

<p>
This causes two different defects:
</p>

<ol type="a">
<li>
<p>
We cannot move/copy-initialize a <em>const</em> lvalue of type <tt>T</tt> as in:
</p>

<blockquote><pre>int get_i();

const int i1(get_i());
</pre></blockquote>

<p>
both in Table 33 and in Table 34.
</p>
</li>

<li>
<p>
The single support for
</p>

<blockquote><pre>T t(rv)
</pre></blockquote>

<p>
in case of <tt>CopyConstructible</tt> means that we cannot provide an
lvalue as a source of a copy as in
</p>

<blockquote><pre>const int&amp; get_lri();

int i2(get_lri());
</pre></blockquote>
</li>
</ol>

<p>
I believe this second defect is due to the fact that this single
expression supported <em>both</em> initialization situations according
to the old (implicit) lvalue reference -&gt; rvalue reference
conversion rules.
</p>

<p>
Finally [copyconstructible] refers to some name <tt>u</tt> which is not part of
the expression, and both [copyconstructible] and [moveconstructible] should
support construction expressions from temporaries - this would be a stylistic
consequence in the light of the new <tt>DefaultConstructible</tt> requirements
and compared with existing requirements (see e.g. Container requirements or the
output/forward iterator requirements)..
</p>

<p><i>[
2010-02-09 Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>


<p><i>[
2010-02-10 Reopened. The proposed wording of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1283">1283</a> has been
merged here.
]</i></p>


<p><i>[
2010-02-10 Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>




<p><b>Proposed resolution:</b></p>

<ol>

<li>
<p>
Change 20.2.1 [utility.arg.requirements]/1 as indicated: <i>[This change
suggestion is motivated to make type descriptions clearer: First, <tt>a</tt>,
<tt>b</tt>, and <tt>c</tt> <em>may</em> also be non-<tt>const T</tt>. Second, <tt>u</tt>
is described in a manner consistent with the container requirements tables.]</i>
</p>

<blockquote>
1 The template definitions in the C++ standard library refer to various named
requirements whose details are set out in tables 31-38. In these tables,
<tt>T</tt> is a<ins>n object or reference</ins> type to be supplied by a C++
program instantiating a template; <tt>a</tt>, <tt>b</tt>, and <tt>c</tt> are
values of type <ins>(possibly</ins> <tt>const<ins>)</ins> T</tt>; <tt>s</tt> and
<tt>t</tt> are modifiable lvalues of type <tt>T</tt>; <tt>u</tt> <ins>denotes an
identifier;</ins> <del>is a value of type (possibly <tt>const</tt>) <tt>T</tt>;
and</del> <tt>rv</tt> is a<ins>n</ins> <del>non-const</del> rvalue of type
<tt>T</tt><ins>; and <tt>v</tt> is an lvalue of type (possibly <tt>const</tt>)
<tt>T</tt> or an rvalue of type <tt>const T</tt></ins>.
</blockquote>
</li>

<li>
<p>
In 20.2.1 [utility.arg.requirements] Table 33 ([moveconstructible])
change as indicated <i>[Note: The symbol <tt>u</tt> is defined to be either a
const or a non-const value and is the right one we need here]</i>:
</p>

<blockquote>
<table border="1">
<caption>Table 33  <tt>MoveConstructible</tt> requirements [moveconstructible]</caption>

<tbody><tr>
<th>Expression</th>
<th>Post-condition</th>
</tr>

<tr>
<td>
<tt>T <del>t</del><ins>u</ins>(rv)<ins>;</ins></tt>
</td>
<td>
<tt><del>t</del><ins>u</ins></tt> is equivalent
to the value of <tt>rv</tt> before the construction
</td>
</tr>

<tr>
<td><ins><tt>T(rv)</tt></ins></td>
<td><ins><tt>T(rv)</tt> is equivalent to the value of <tt>rv</tt> before the
construction</ins></td>
</tr>

<tr>
<td colspan="2">[<i>Note:</i>
<del>There is no requirement on the value of <tt>rv</tt> after the
construction.</del>
<ins><tt>rv</tt> remains a valid object.  Its state is unspecified.</ins>
 <i>end note</i>]</td>
</tr>
</tbody></table>
</blockquote>
</li>

<li>
<p>
In 20.2.1 [utility.arg.requirements] Table 34 ([copyconstructible])
change as indicated <i>[Note: The symbol <tt>u</tt> is defined to be either a
const or a non-const value and is the right one we need here. The expressions
using <tt>a</tt> are recommended to ensure that lvalues are supported as sources
of the copy expression]</i>:
</p>

<blockquote>
<table border="1">
<caption>Table 34  <tt>CopyConstructible</tt> requirements [copyconstructible]<br>
<ins>(in addition to <tt>MoveConstructible</tt>)</ins></caption>

<tbody><tr>
<th>Expression</th>
<th>Post-condition</th>
</tr>

<tr>
<td>
<tt>T <del>t</del><ins>u</ins>(<del>r</del>v)<ins>;</ins></tt>
</td>
<td>
the value of <tt><del>u</del><ins>v</ins></tt>
is unchanged and is equivalent to <tt><del>t</del><ins>u</ins></tt>
</td>
</tr>

<tr>
<td>
<ins><tt>T(v)</tt></ins>
</td>
<td><ins>the value of <tt>v</tt> is unchanged and is equivalent to <tt>T(v)</tt></ins>
</td>
</tr>

<tr>
<td colspan="2"><del>[<i>Note:</i> A type that satisfies the
<tt>CopyConstructible</tt> requirements also satisfies the <tt>MoveConstructible</tt>
requirements.  <i>end note</i>]</del></td>
</tr>

</tbody></table>
</blockquote>

</li>

<li>
<p>
In Table 35  MoveAssignable requirements [moveassignable] change as
indicated:
</p>

<blockquote>

<table border="1">
<caption>Table 35  <tt>MoveAssignable</tt> requirements <b>[moveassignable]</b></caption>
<tbody><tr>
<th>Expression</th>
<th>Return type</th>
<th>Return value</th>
<th>Post-condition</th>
</tr>
<tr>
<td>
<tt>t = rv</tt>
</td>
<td>
<tt>T&amp;</tt>
</td>
<td>
<tt>t</tt>
</td>
<td>
<tt>t</tt> is equivalent to the value of <tt>rv</tt> before the assigment.
</td>
</tr>
<tr>
<td colspan="4">
[<i>Note:</i>
<del>There is no requirement on the value of <tt>rv</tt> after the
assignment.</del>
<ins><tt>rv</tt> remains a valid object.  Its state is unspecified.</ins>
 <i>end note</i>]
</td>
</tr>
</tbody></table>

</blockquote>
</li>

<li>
<p>
In 20.2.1 [utility.arg.requirements] change Table 36 as indicated:
</p>

<blockquote>
<table border="1">
<caption>Table 36  <tt>CopyAssignable</tt> requirements
[copyassignable]<br><ins>(in addition to <tt>MoveAssignable</tt>)</ins></caption>

<tbody><tr>
<th>Expression</th>
<th>Return type</th>
<th>Return value</th>
<th>Post-condition</th>
</tr>

<tr>
<td><tt>t = <del>u</del><ins>v</ins></tt></td>
<td><tt>T&amp;</tt></td>
<td><tt>t</tt></td>
<td><tt>t</tt> is equivalent to <tt><del>u</del><ins>v</ins></tt>, the value of
<tt><del>u</del><ins>v</ins></tt> is unchanged</td>
</tr>

<tr>
<td colspan="4"><del>[<i>Note:</i> A type that satisfies the <tt>CopyAssignable</tt>
requirements also satisfies the <tt>MoveAssignable</tt> requirements. 
<i>end note</i>]</del></td>
</tr>

</tbody></table>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="1312"></a>1312. <tt>vector::data</tt> no longer returns a raw pointer</h3>
<p><b>Section:</b> 23.4.1.3 [vector.data] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2010-02-07 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The original intent of <tt>vector::data</tt> was to match <tt>array::data</tt>
in providing a simple API with direct access to the contiguous buffer of
elements that could be passed to a "classic" C API.  At some point, the return
type became the '<tt>pointer</tt>' typedef, which is not derived from the
<tt>allocator</tt> via allocator traits - it is no longer specified to precisely
<tt>T *</tt>.  The return type of this function should be corrected to no longer
use the typedef.
</p>

<p><i>[
2010-02-10 Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
23.4.1 [vector]
</p>

<p>
Update the class definition in p2:
</p>

<blockquote><pre>// 23.3.6.3 data access
<del>pointer</del><ins>T *</ins> data();
<del>const_pointer</del><ins>const T *</ins> data() const;
</pre></blockquote>

<p>
23.4.1.3 [vector.data]
</p>

<p>
Adjust signatures:
</p>

<blockquote><pre><del>pointer</del><ins>T *</ins> data();
<del>const_pointer</del><ins>const T *</ins> data() const;
</pre></blockquote>





<hr>
<h3><a name="1316"></a>1316. <tt>scoped_allocator_adaptor operator==</tt> has no definition</h3>
<p><b>Section:</b> 20.10 [allocator.adaptor] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Pablo Halpern <b>Opened:</b> 2009-02-11 <b>Last modified:</b> 2010-11-24</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#allocator.adaptor">issues</a> in [allocator.adaptor].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The WP 
(<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n3000.pdf">N3000</a>)
contains these declarations:
</p>

<blockquote>
<pre>template &lt;class OuterA1, class OuterA2, class... InnerAllocs&gt;
  bool operator==(const scoped_allocator_adaptor&lt;OuterA1, InnerAllocs...&gt;&amp; a,
                  const scoped_allocator_adaptor&lt;OuterA2, InnerAllocs...&gt;&amp; b);
template &lt;class OuterA1, class OuterA2, class... InnerAllocs&gt;
  bool operator!=(const scoped_allocator_adaptor&lt;OuterA1, InnerAllocs...&gt;&amp; a,
                  const scoped_allocator_adaptor&lt;OuterA2, InnerAllocs...&gt;&amp; b);</pre>
</blockquote>

<p>
But does not define what the behavior of these operators are.
</p>

<p><i>[
Post-Rapperswil:
]</i></p>


<blockquote>
Moved to Tentatively Ready after 5 positive votes on c++std-lib.
</blockquote>

<p><i>[
Adopted at 2010-11 Batavia
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
Add a new section after 20.10.3 [allocator.adaptor.members]:
</p>

<blockquote>
<p><b>Scoped allocator operators  [scoped.adaptor.operators]</b></p>

<pre>template &lt;class OuterA1, class OuterA2, class... InnerAllocs&gt;
  bool operator==(const scoped_allocator_adaptor&lt;OuterA1, InnerAllocs...&gt;&amp; a,
                  const scoped_allocator_adaptor&lt;OuterA2, InnerAllocs...&gt;&amp; b);</pre>

<blockquote>
<i>Returns:</i> <code>a.outer_allocator() == b.outer_allocator()</code>
if <code>sizeof...(InnerAllocs)</code> is zero; otherwise,
<code>a.outer_allocator() == b.outer_allocator() &amp;&amp;
a.inner_allocator() == b.inner_allocator()</code>.
</blockquote>

<pre>template &lt;class OuterA1, class OuterA2, class... InnerAllocs&gt;
  bool operator!=(const scoped_allocator_adaptor&lt;OuterA1, InnerAllocs...&gt;&amp; a,
                  const scoped_allocator_adaptor&lt;OuterA2, InnerAllocs...&gt;&amp; b);</pre>

<blockquote>
<i>Returns:</i> <code>!(a == b)</code>.
</blockquote>

</blockquote>






<hr>
<h3><a name="1319"></a>1319. Containers should require an iterator that is at least a Forward Iterator</h3>
<p><b>Section:</b> 23.2.1 [container.requirements.general] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2010-02-16 <b>Last modified:</b> 2010-11-24</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#container.requirements.general">active issues</a> in [container.requirements.general].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#container.requirements.general">issues</a> in [container.requirements.general].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The requirements on container iterators are spelled out in
23.2.1 [container.requirements.general], table 91.
</p>

<blockquote>
<table border="1">
<caption>Table 91  Container requirements</caption>

<tbody><tr>
<th>Expression</th>
<th>Return type</th>
<th>Operational semantics</th>
<th>Assertion/note<br>pre-/post-condition</th>
<th>Complexity</th>
</tr>

<tr>
<td colspan="5"><center>...</center></td>
</tr>

<tr>
<td><tt>X::iterator</tt></td>
<td>iterator type whose value type is <tt>T</tt></td>
<td></td>
<td>any iterator category except output iterator. Convertible to
<tt>X::const_iterator</tt>.</td>
<td>compile time</td>
</tr>

<tr>
<td><tt>X::const_iterator</tt></td>
<td>constant iterator type whose value type is <tt>T</tt></td>
<td></td>
<td>any iterator category except output iterator</td>
<td>compile time</td>
</tr>

<tr>
<td colspan="5"><center>...</center></td>
</tr>

</tbody></table>
</blockquote>

<p>
As input iterators do not have the multi-pass guarantee, they are not suitable
for iterating over a container.  For example, taking two calls to
<tt>begin()</tt>, incrementing either iterator might invalidate the other. 
While data structures might be imagined where this behaviour produces
interesting and useful results, it is very unlikely to meet the full set of
requirements for a standard container.
</p>

<p><i>[
Post-Rapperswil:
]</i></p>


<p>
Daniel notes: I changed the currently suggested P/R slightly, because it is not robust in regard to new fundamental iterator
catagories. I recommend to say instead that each container::iterator shall satisfy (and thus may refine) the forward 
iterator requirements.
</p>

<blockquote>
Moved to Tentatively Ready with revised wording after 5 positive votes on c++std-lib.
</blockquote>

<p><i>[
Adopted at 2010-11 Batavia
]</i></p>




<p><b>Proposed resolution:</b></p>

<ol>
<li>Change Table 93  Container requirements in [container.requirements.general] as indicated:
<blockquote>
<table border="1">
<caption>Table 93  Container requirements</caption>

<tbody>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Operational<br>semantics</th>
<th>Assertion/note<br>pre-/post-condition</th>
<th>Complexity</th>
</tr>

<tr>
<td colspan="5" align="center"><tt>...</tt></td>
</tr>

<tr>
<td><tt>X::iterator</tt></td>
<td>iterator type<br>whose value<br>type is <tt>T</tt></td>
<td></td>
<td>any iterator category<br><del>except output iterator</del><ins><br>that meets the forward iterator requirements</ins>. convertible<br>to<br><tt>X::const_iterator</tt></td>
<td>compile time</td>
</tr>

<tr>
<td><tt>X::const_iterator</tt></td>
<td>constant iterator type<br>whose value<br>type is <tt>T</tt></td>
<td></td>
<td>any iterator category<br><del>except output iterator</del><ins><br>that meets the forward iterator requirements</ins>.</td>
<td>compile time</td>
</tr>

<tr>
<td colspan="5" align="center"><tt>...</tt></td>
</tr>

</tbody></table>
</blockquote>

</li>
</ol>






<hr>
<h3><a name="1321"></a>1321. <tt>scoped_allocator_adaptor construct</tt> and <tt>destroy</tt> don't
use <tt>allocator_traits</tt></h3>
<p><b>Section:</b> 20.10.3 [allocator.adaptor.members] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2010-02-16 <b>Last modified:</b> 2010-11-20</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p>
20.10.3 [allocator.adaptor.members] p8-9 says:
</p>

<blockquote>

<pre>template &lt;class T, class... Args&gt;
  void construct(T* p, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
8 <i>Effects:</i> let <tt><i>OUTERMOST</i>(x)</tt> be <tt>x</tt> if <tt>x</tt>
does not have an <tt>outer_allocator()</tt> function and
<tt><i>OUTERMOST</i>(x.outer_allocator())</tt> otherwise.
</p>

<ul>
<li>
If <tt>uses_allocator&lt;T, inner_allocator_type&gt;::value</tt> is
<tt>false</tt> and <tt>is_constructible&lt;T, Args...&gt;::value</tt> is
<tt>true</tt>, calls <tt><i>OUTERMOST</i>(*this).construct(p,
std::forward&lt;Args&gt;(args)...)</tt>.
</li>

<li>
Otherwise, if <tt>uses_allocator&lt;T, inner_allocator_type&gt;::value</tt> is
<tt>true</tt> and <tt>is_constructible&lt;T, allocator_arg_t,
inner_allocator_type, Args...&gt;::value</tt> is <tt>true</tt>, calls
<tt><i>OUTERMOST</i>(*this).construct(p, allocator_arg,
inner_allocator(),std::forward&lt;Args&gt;(args)...)</tt>.
</li>

<li>
Otherwise, if <tt>uses_allocator&lt;T, inner_allocator_type&gt;::value</tt> is
<tt>true</tt> and <tt>is_constructible&lt;T, Args...,
inner_allocator_type&gt;::value</tt> is <tt>true</tt>, calls
<tt><i>OUTERMOST</i>(*this).construct(p, std::forward&lt;Args&gt;(args)...,
inner_allocator())</tt>.
</li>

<li>
Otherwise, the program is ill-formed. [<i>Note:</i> an error will result if
<tt>uses_allocator</tt> evaluates to <tt>true</tt> but the specific constructor
does not take an allocator. This definition prevents a silent failure to pass an
inner allocator to a contained element.  <i>end note</i>]
</li>
</ul>

</blockquote>

<pre>template &lt;class T&gt;
  void destroy(T* p);
</pre>
<blockquote>
9 <i>Effects:</i> calls <tt>outer_allocator().destroy(p)</tt>.
</blockquote>

</blockquote>

<p>
In all other calls where applicable <tt>scoped_allocator_adaptor</tt> does not
call members of an allocator directly, but rather does so indirectly via
<tt>allocator_traits</tt>.  For example:
</p>

<blockquote>
<pre>size_type max_size() const;
</pre>
<blockquote>
7 <i>Returns:</i>
<tt><b>allocator_traits&lt;OuterAlloc&gt;::</b>max_size(outer_allocator())</tt>.
</blockquote>
</blockquote>

<p>
Indeed, without the indirection through <tt>allocator_traits</tt> the
definitions for <tt>construct</tt> and <tt>destroy</tt> are likely to fail at
compile time since the <tt>outer_allocator()</tt> may not have the members
<tt>construct</tt> and <tt>destroy</tt>.
</p>

<p><i>[
The proposed wording is a product of Pablo, Daniel and Howard.
]</i></p>


<p><i>[
2010 Pittsburgh:  Moved to NAD Editorial.  Rationale added below.
]</i></p>




<p><b>Rationale:</b></p>
<p>
Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3059.pdf">N3059</a>.
</p>


<p><b>Proposed resolution:</b></p>
<p>
In 20.10.3 [allocator.adaptor.members] move and change p8
as indicated, and change p9 as indicated:
</p>

<blockquote>

<p>
<ins>Let <tt><i>OUTERMOST(x)</i></tt> be <tt><i>x</i></tt> if <tt><i>x</i></tt>
does not have an <tt>outer_allocator()</tt> <ins>member</ins> function and
<tt><i>OUTERMOST(x.outer_allocator())</i></tt> otherwise. Let
<tt><i>OUTERMOST_ALLOC_TRAITS(x)</i></tt> be
<tt>allocator_traits&lt;decltype(<i>OUTERMOST(x)</i>)&gt;</tt>.
[<i>Note:</i> <tt><i>OUTERMOST(x)</i></tt> and
<tt><i>OUTERMOST_ALLOC_TRAITS(x)</i></tt> are recursive operations.  It is
incumbent upon the definition of <tt>outer_allocator()</tt> to ensure that the
recursion terminates.  It <em>will</em> terminate for all instantiations
of <tt>scoped_allocator_adaptor</tt>.  <i>end note</i>]
</ins>
</p>

<pre>template &lt;class T, class... Args&gt;
  void construct(T* p, Args&amp;&amp;... args);
</pre>
<blockquote>

<p>
8 <i>Effects:</i> <del>let <tt><i>OUTERMOST(x)</i></tt> be <tt><i>x</i></tt> if
<tt><i>x</i></tt> does not have an <tt>outer_allocator()</tt> function and
<tt><i>OUTERMOST(x.outer_allocator())</i></tt> otherwise.</del>
</p>

<ul>
<li>
If <tt>uses_allocator&lt;T, inner_allocator_type&gt;::value</tt> is
<tt>false</tt> and <tt>is_constructible&lt;T, Args...&gt;::value</tt> is
<tt>true</tt>, calls <tt><del><i>OUTERMOST(*this)</i>.</del>
<ins><i>OUTERMOST_ALLOC_TRAITS(outer_allocator())</i>::</ins>construct(
<ins><i>OUTERMOST(outer_allocator())</i>,</ins> p,
std::forward&lt;Args&gt;(args)... )</tt>.
</li>

<li>
Otherwise, if <tt>uses_allocator&lt;T, inner_allocator_type&gt;::value</tt> is
<tt>true</tt> and <tt>is_constructible&lt;T, allocator_arg_t,
inner_allocator_type, Args...&gt;::value</tt> is <tt>true</tt>, calls
<tt><del><i>OUTERMOST(*this)</i>.</del>
<ins><i>OUTERMOST_ALLOC_TRAITS(outer_allocator())</i>::</ins>construct(
<ins><i>OUTERMOST(outer_allocator())</i>,</ins> p, allocator_arg,
inner_allocator(), std::forward&lt;Args&gt;(args)... )</tt>.
</li>

<li>
Otherwise, if <tt>uses_allocator&lt;T, inner_allocator_type&gt;::value</tt> is
<tt>true</tt> and <tt>is_constructible&lt;T, Args...,
inner_allocator_type&gt;::value</tt> is <tt>true</tt>, calls
<tt><del><i>OUTERMOST(*this)</i>.</del>
<ins><i>OUTERMOST_ALLOC_TRAITS(outer_allocator())</i>::</ins>construct(
<ins><i>OUTERMOST(outer_allocator())</i>,</ins> p,
std::forward&lt;Args&gt;(args)..., inner_allocator() )</tt>.
</li>

<li>
Otherwise, the program is ill-formed. [<i>Note:</i> an error will result if
<tt>uses_allocator</tt> evaluates to <tt>true</tt> but the specific constructor
does not take an allocator. This definition prevents a silent failure to pass an
inner allocator to a contained element.  <i>end note</i>]
</li>
</ul>

</blockquote>

<pre>template &lt;class T&gt;
  void destroy(T* p);
</pre>
<blockquote>
9 <i>Effects:</i> calls <tt><del>outer_allocator().</del>
<ins><i>OUTERMOST_ALLOC_TRAITS(outer_allocator())</i>::</ins>destroy(
<ins><i>OUTERMOST(outer_allocator())</i>,</ins> p)</tt>.
</blockquote>

</blockquote>






<hr>
<h3><a name="1322"></a>1322. Explicit <tt>CopyConstructible</tt> requirements are insufficient</h3>
<p><b>Section:</b> 20.2.1 [utility.arg.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2010-02-16 <b>Last modified:</b> 2010-11-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#utility.arg.requirements">issues</a> in [utility.arg.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p>
With the acceptance of library defect <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#822">822</a> only
direct-initialization is supported, and not copy-initialization in the
requirement sets <tt>MoveConstructible</tt> and <tt>CopyConstructible</tt>. This
is usually a good thing, if only the library implementation needs to obey these
restrictions, but the Empire strikes back quickly:
</p>

<ol>
<li>
<p>
<em>Affects user-code</em>: <tt>std::exception_ptr</tt> is defined purely via
requirements, among them <tt>CopyConstructible</tt>. A strict reading of the
standard would make implementations conforming where <tt>std::exception_ptr</tt>
has an explicit copy-c'tor and user-code must code defensively. This is a very
unwanted effect for such an important component like
<tt>std::exception_ptr</tt>.
</p>
</li>

<li>
<p>
<em>Wrong re-use</em>: Recently proposed requirement sets
(<tt>NullablePointer</tt> as of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3025.html">N3025</a>,
Hash) or cleanup of existing requirement sets (e.g. iterator requirements as of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3046.html">N3046</a>)
tend to reuse existing requirement sets, so reusing <tt>CopyConstructible</tt>
is attempting, even in cases, where the intend is to support copy-initialization
as well.
</p>
</li>

<li>
<p>
<em>Inconsistency</em>: The current iterator requirements set Table 102 (output
iterator requirements) and Table 103 (forward iterator requirements) demonstrate
quite clearly a strong divergence of copy-semantics: The specified semantics of
</p>

<blockquote><pre>X u(a);
X u = a;
</pre></blockquote>

<p>
are underspecified compared to the most recent clarifications of the
<tt>CopyConstructible</tt> requirements, c.f. issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1309">1309</a> which is
very unsatisfactory. This will become worse for each further issue that involves
the <tt>CopyConstructible</tt> specification (for possible directions see <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1173">1173</a>).
</p>
</li>
</ol>

<p>
The suggested resolution is to define two further requirements
<tt>implicit-MoveConstructible</tt> and <tt>implicit-CopyConstructible</tt> (or
any other reasonable name like <tt>MoveConvertible</tt> and
<tt>CopyConvertible</tt>) each with a very succinct but precise meaning solving
all three problems mentioned above.
</p>

<p><i>[Batavia: Resolved by accepting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3215.html">n3215</a>.]</i></p>







<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>
Add the following new table ?? after Table 34  <tt>MoveConstructible</tt>
requirements [moveconstructible]:
</p>

<blockquote>

<table border="1">
<caption><ins>Table ??  <tt>Implicit MoveConstructible</tt> requirements
[implicit.moveconstructible] (in addition to
<tt>MoveConstructible</tt>)</ins></caption>

<tbody><tr>
<th><ins>Expression</ins></th>
<th><ins>Operational Semantics</ins></th>
</tr>

<tr>
<td><ins><tt>T u = rv;</tt></ins></td>
<td><ins>Equivalent to: <tt>T u(rv);</tt></ins></td>
</tr>

</tbody></table>
</blockquote>

</li>

<li>
<p>
Add the following new table ?? after Table 35  <tt>CopyConstructible</tt>
requirements [copyconstructible]:
</p>

<blockquote>

<table border="1">
<caption><ins>Table ??  <tt>Implicit CopyConstructible</tt> requirements
[implicit.copyconstructible] (in addition to
<tt>CopyConstructible</tt>)</ins></caption>

<tbody><tr>
<th><ins>Expression</ins></th>
<th><ins>Operational Semantics</ins></th>
</tr>

<tr>
<td><ins><tt>T u = v;</tt></ins></td>
<td><ins>Equivalent to: <tt>T u(v);</tt></ins></td>
</tr>

</tbody></table>
</blockquote>

</li>

<li>
<p>
Change 20.2.3 [nullablepointer.requirements]/1 as follows:
</p>

<blockquote>
<p>
A <tt>NullablePointer</tt> type is a pointer-like type that supports null
values. A type <tt>P</tt> meets the requirements of <tt>NullablePointer</tt> if:
</p>

<ul>
<li>
<tt>P</tt> satisfies the requirements of <tt>EqualityComparable</tt>,
<tt>DefaultConstructible</tt>, <tt><ins>implicit</ins> CopyConstructible</tt>,
<tt>CopyAssignable</tt>, and <tt>Destructible</tt>,
</li>

<li>[..]</li>
</ul>
</blockquote>
</li>

<li>
<p>
Change 20.2.4 [hash.requirements]/1 as indicated: <i>[explicit
copy-constructible functors could not be provided as arguments
to any algorithm that takes these by value. Also a typo is fixed.]</i>
</p>

<blockquote>
<p>
1 A type <tt>H</tt> meets the <i>Hash</i> requirements if:
</p>
<ul>
<li>
it is a function object type (20.8),
</li>
<li>
it satis<ins>fies</ins><del>ifes</del> the requirements of
<tt><ins>implicit</ins> CopyConstructible</tt> and <tt>Destructible</tt>
(20.2.1),
</li>
<li>
[..]
</li>
</ul>

</blockquote>

</li>

<li>
<p>
Change 20.7.1 [meta.rqmts]/1+2 as indicated:
</p>

<blockquote>
<p>
1 A <i>UnaryTypeTrait</i> describes a property of a type. It shall be a class
template that takes one template type argument and, optionally, additional
arguments that help define the property being described. It shall be
<tt>DefaultConstructible</tt>, <tt><ins>implicit</ins> CopyConstructible</tt>,
[..]
</p>

<p>
2 A <tt>BinaryTypeTrait</tt> describes a relationship between two types. It
shall be a class template that takes two template type arguments and,
optionally, additional arguments that help define the relationship being
described. It shall be <tt>DefaultConstructible</tt>,
<tt><ins>implicit </ins>CopyConstructible</tt>, and [..]
</p>

</blockquote>

</li>

<li>
<p>
Change 20.8.2 [func.require]/4 as indicated: <i>[explicit
copy-constructible functors could not be provided as arguments to any algorithm
that takes these by value]</i>
</p>

<blockquote>
4 Every call wrapper (20.8.1) shall be <tt><ins>implicit</ins>
MoveConstructible</tt>. A simple call wrapper is a call wrapper that is
<tt><ins>implicit</ins> CopyConstructible</tt> and <tt>CopyAssignable</tt> and
whose copy constructor, move constructor, and assignment operator do not throw
exceptions. [..]
</blockquote>
</li>

<li>
<p>
Change 20.8.4 [refwrap]/1 as indicated:
</p>

<blockquote>
1 <tt>reference_wrapper&lt;T&gt;</tt> is a<ins>n <tt>implicit</tt></ins>
<tt>CopyConstructible</tt> and <tt>CopyAssignable</tt> wrapper around a
reference to an object or function of type <tt>T</tt>.
</blockquote>
</li>

<li>
<p>
Change 20.8.10.1.2 [func.bind.bind]/5+9 as indicated:
</p>

<blockquote>
<p>
5 <i>Remarks:</i> The return type shall satisfy the requirements of
<tt><ins>implicit</ins> MoveConstructible</tt>. If all of <tt>FD</tt> and
<tt>TiD</tt> satisfy the requirements of <tt>CopyConstructible</tt>, then the
return type shall satisfy the requirements of <tt><ins>implicit</ins>
CopyConstructible</tt>. [<i>Note:</i> this implies that all of <tt>FD</tt> and
<tt>TiD</tt> are <tt>MoveConstructible</tt>.  <i>end note</i>]
</p>

<p>
[..]
</p>

<p>
9 <i>Remarks:</i> The return type shall satisfy the requirements of
<tt><ins>implicit</ins> MoveConstructible</tt>. If all of <tt>FD</tt> and
<tt>TiD</tt> satisfy the requirements of <tt>CopyConstructible</tt>, then the
return type shall satisfy the requirements of <tt><ins>implicit</ins>
CopyConstructible</tt>. [<i>Note:</i> this implies that all of <tt>FD</tt> and
<tt>TiD</tt> are <tt>MoveConstructible</tt>.  <i>end note</i>]
</p>
</blockquote>

</li>

<li>
<p>
Change 20.8.10.1.3 [func.bind.place] as indicated:
</p>

<blockquote>
1 All placeholder types shall be <tt>DefaultConstructible</tt> and
<tt><ins>implicit</ins> CopyConstructible</tt>, and [..]
</blockquote>
</li>

<li>
<p>
Change 20.9.9 [unique.ptr]/5 as indicated:
</p>

<blockquote>
5 Each object of a type <tt>U</tt> instantiated form the <tt>unique_ptr</tt>
template specified in this subclause has the strict ownership semantics,
specified above, of a unique pointer. In partial satisfaction of these
semantics, each such <tt>U</tt> is <tt><ins>implicit</ins>
MoveConstructible</tt> and <tt>MoveAssignable</tt>, but is not
<tt>CopyConstructible</tt> nor <tt>CopyAssignable</tt>. The template parameter
<tt>T</tt> of <tt>unique_ptr</tt> may be an incomplete type.
</blockquote>
</li>

<li>
<p>
Change 20.9.10.2 [util.smartptr.shared]/2 as indicated:
</p>

<blockquote>
2 Specializations of <tt>shared_ptr</tt> shall be
<tt><ins>implicit</ins> CopyConstructible</tt>, <tt>CopyAssignable</tt>, and
<tt>LessThanComparable</tt>, [..]
</blockquote>
</li>

<li>
<p>
Change 20.9.10.3 [util.smartptr.weak]/2 as indicated:
</p>

<blockquote>
2 Specializations of <tt>weak_ptr</tt> shall be <tt><ins>implicit</ins>
CopyConstructible</tt> and <tt>CopyAssignable</tt>, allowing their use in
standard containers. The template parameter <tt>T</tt> of <tt>weak_ptr</tt> may
be an incomplete type.
</blockquote>
</li>

<li>
<p>
Change 24.2.2 [iterator.iterators]/2 as indicated: <i>[This fixes a
defect in the Iterator requirements. None of the usual algorithms accepting
iterators would be usable with iterators with explicit copy-constructors]</i>
</p>

<blockquote>
<p>
2 A type <tt>X</tt> satisfies the Iterator requirements if:
</p>

<ul>
<li>
<tt>X</tt> satisfies the <tt><ins>implicit</ins> CopyConstructible</tt>,
<tt>CopyAssignable</tt>, and <tt>Destructible</tt> requirements (20.2.1)
and lvalues of type <tt>X</tt> are swappable (20.2.2), and [..]
</li>
<li>...</li>
</ul>

</blockquote>

</li>

<li>
<p>
Change D.12.1 [auto.ptr]/3 as indicated:
</p>

<blockquote>
3 [..] Instances of <tt>auto_ptr</tt> meet the requirements of
<tt><ins>implicit</ins> MoveConstructible</tt> and <tt>MoveAssignable</tt>, but
do not meet the requirements of <tt>CopyConstructible</tt> and
<tt>CopyAssignable</tt>.  <i>end note</i>]
</blockquote>
</li>

</ol>






<hr>
<h3><a name="1323"></a>1323. <tt>basic_string::replace</tt> should use <tt>const_iterator</tt></h3>
<p><b>Section:</b> 21.4.6.6 [string::replace] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2010-02-19 <b>Last modified:</b> 2010-11-24</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#string::replace">issues</a> in [string::replace].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>

<p>
In contrast to all library usages of purely positional iterator values several
overloads of <tt>std::basic_string::replace</tt> still use iterator instead of
<tt>const_iterator</tt> arguments. The paper
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3021.pdf">N3021</a>
quite nicely visualizes the purely positional responsibilities of the function
arguments.
</p>

<p>
This should be fixed to make the library consistent, the proposed changes are
quite mechanic.
</p>

<p><i>[
Post-Rapperswil:
]</i></p>


<blockquote>
Moved to Tentatively Ready after 5 positive votes on c++std-lib.
</blockquote>

<p><i>[
Adopted at 2010-11 Batavia
]</i></p>




<p><b>Proposed resolution:</b></p>
<ol>

<li>
<p>
In 21.4 [basic.string], class template <tt>basic_string</tt> synopsis
change as indicated:
</p>

<blockquote><pre>// 21.4.6 modifiers:
...
basic_string&amp; replace(<ins>const_</ins>iterator i1, <ins>const_</ins>iterator i2,
                      const basic_string&amp; str);
basic_string&amp; replace(<ins>const_</ins>iterator i1, <ins>const_</ins>iterator i2,
                      const charT* s, size_type n);
basic_string&amp; replace(<ins>const_</ins>iterator i1, <ins>const_</ins>iterator i2,
                      const charT* s);
basic_string&amp; replace(<ins>const_</ins>iterator i1, <ins>const_</ins>iterator i2,
                      size_type n, charT c);
template&lt;class InputIterator&gt;
  basic_string&amp; replace(<ins>const_</ins>iterator i1, <ins>const_</ins>iterator i2,
                        InputIterator j1, InputIterator j2);
basic_string&amp; replace(<ins>const_</ins>iterator, <ins>const_</ins>iterator,
                      initializer_list&lt;charT&gt;);
</pre></blockquote>
</li>

<li>
<p>
In 21.4.6.6 [string::replace] before p.18, change the following signatures
as indicated:
</p>

<blockquote><pre>basic_string&amp; replace(<ins>const_</ins>iterator i1, <ins>const_</ins>iterator i2, const basic_string&amp; str);
</pre></blockquote>
</li>

<li>
<p>
In 21.4.6.6 [string::replace] before p.21, change the following signatures
as indicated:
</p>

<blockquote><pre>basic_string&amp;
  replace(<ins>const_</ins>iterator i1, <ins>const_</ins>iterator i2, const charT* s, size_type n);
</pre></blockquote>
</li>

<li>
<p>
In 21.4.6.6 [string::replace] before p.24, change the following signatures
as indicated:
</p>

<blockquote><pre>basic_string&amp; replace(<ins>const_</ins>iterator i1, <ins>const_</ins>iterator i2, const charT* s);
</pre></blockquote>
</li>

<li>
<p>
In 21.4.6.6 [string::replace] before p.27, change the following signatures
as indicated:
</p>

<blockquote><pre>basic_string&amp; replace(<ins>const_</ins>iterator i1, <ins>const_</ins>iterator i2, size_type n,
                      charT c);
</pre></blockquote>
</li>

<li>
<p>
In 21.4.6.6 [string::replace] before p.30, change the following signatures
as indicated:
</p>

<blockquote><pre>template&lt;class InputIterator&gt;
  basic_string&amp; replace(<ins>const_</ins>iterator i1, <ins>const_</ins>iterator i2,
                        InputIterator j1, InputIterator j2);
</pre></blockquote>
</li>

<li>
<p>
In 21.4.6.6 [string::replace] before p.33, change the following signatures
as indicated:
</p>

<blockquote><pre>basic_string&amp; replace(<ins>const_</ins>iterator i1, <ins>const_</ins>iterator i2,
                      initializer_list&lt;charT&gt; il);
</pre></blockquote>
</li>

</ol>






<hr>
<h3><a name="1324"></a>1324. Still too many implicit conversions for <tt>pair</tt> and  <tt>tuple</tt></h3>
<p><b>Section:</b> 20.3.5.2 [pairs.pair], 20.4.2.1 [tuple.cnstr] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2010-03-20 <b>Last modified:</b> 2010-11-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#pairs.pair">issues</a> in [pairs.pair].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In analogy to library defect <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#811">811</a>, <tt>tuple</tt>'s variadic
constructor
</p>

<blockquote><pre>template &lt;class... UTypes&gt;
explicit tuple(UTypes&amp;&amp;... u);
</pre></blockquote>

<p>
creates the same problem as pair:
</p>

<blockquote><pre>#include &lt;tuple&gt;

int main()
{
  std::tuple&lt;char*&gt; p(0);
}
</pre></blockquote>

<p>
produces a similar compile error for a recent gcc implementation.
</p>

<p>
I suggest to follow the same resolution path as has been applied to
<tt>pair</tt>'s corresponding c'tor, that is require that these c'tors should
not participate in overload resolution, if the arguments are not implicitly
convertible to the element types.
</p>

<p>
Further-on both <tt>pair</tt> and <tt>tuple</tt> provide converting constructors
from different <tt>pairs</tt>/<tt>tuples</tt> that should be not available, if
the corresponding element types are not implicitly convertible. It seems
astonishing that in the following example
</p>

<blockquote><pre>struct A {
  explicit A(int);
};

A  a = 1; <font color="#C80000">// Error</font>

std::tuple&lt;A&gt; ta = std::make_tuple(1); <font color="#C80000">// # OK?</font>
</pre></blockquote>

<p>
the initialization marked with # could be well-formed.
</p>

<p><i>[
Only constraints on constructors are suggested. Adding similar constraints on
assignment operators is considered as QoI, because the assigments wouldn't be
well-formed anyway.
]</i></p>


<ol>

<li>
<p>
Following 20.3.5.2 [pairs.pair]/5 add a new Remarks element:
</p>

<blockquote><pre>template&lt;class U, class V&gt; pair(const pair&lt;U, V&gt;&amp; p);
</pre>

<blockquote>
<p>
5 <i>Effects:</i> Initializes members from the corresponding members of the
argument<del>, performing implicit conversions as needed</del>.
</p>

<p>
<ins><i>Remarks:</i> This constructor shall not participate in overload
resolution unless <tt>U</tt> is implicitly convertible to <tt>first_type</tt>
and <tt>V</tt> is implicitly convertible to <tt>second_type</tt>.</ins>
</p>
</blockquote>
</blockquote>

</li>

<li>
<p>
Following 20.3.5.2 [pairs.pair]/6 add a new Remarks element:
</p>

<blockquote><pre>template&lt;class U, class V&gt; pair(pair&lt;U, V&gt;&amp;&amp; p);
</pre>

<blockquote>
<p>
6 <i>Effects:</i> The constructor initializes <tt>first</tt> with
<tt>std::move(p.first)</tt> and second with <tt>std::move(p.second)</tt>.
</p>

<p>
<ins><i>Remarks:</i> This constructor shall not participate in overload
resolution unless <tt>U</tt> is implicitly convertible to <tt>first_type</tt>
and <tt>V</tt> is implicitly convertible to <tt>second_type</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>

<li>
<p>
Following 20.4.2.1 [tuple.cnstr]/7 add a new Remarks element:
</p>

<blockquote><pre>template &lt;class... UTypes&gt;
explicit tuple(UTypes&amp;&amp;... u);
</pre>

<blockquote>
<p>
6 <i>Requires:</i> Each type in <tt>Types</tt> shall satisfy the requirements of
<tt>MoveConstructible</tt> (Table 33) from the corresponding type in
<tt>UTypes</tt>. <tt>sizeof...(Types) == sizeof...(UTypes)</tt>.
</p>

<p>
7 <i>Effects:</i> Initializes the elements in the <tt>tuple</tt> with the
corresponding value in <tt>std::forward&lt;UTypes&gt;(u)</tt>.
</p>

<p>
<ins><i>Remarks:</i> This constructor shall not participate in overload
resolution unless each type in <tt>UTypes</tt> is implicitly convertible to its
corresponding type in <tt>Types</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>

<li>
<p>
Following 20.4.2.1 [tuple.cnstr]/13 add a new Remarks element:
</p>

<blockquote><pre>template &lt;class... UTypes&gt; tuple(const tuple&lt;UTypes...&gt;&amp; u);
</pre>

<blockquote>
<p>
12 <i>Requires:</i> Each type in <tt>Types</tt> shall be constructible from the
corresponding type in <tt>UTypes</tt>. <tt>sizeof...(Types) ==
sizeof...(UTypes)</tt>.
</p>

<p>
13 <i>Effects:</i> Constructs each element of <tt>*this</tt> with the
corresponding element of <tt>u</tt>.
</p>

<p>
<ins><i>Remarks:</i> This constructor shall not participate in overload
resolution unless each type in <tt>UTypes</tt> is implicitly convertible to its
corresponding type in <tt>Types</tt>.</ins>
</p>

<p>
14 [<i>Note:</i> <tt>enable_if</tt> can be used to make the converting
constructor and assignment operator exist only in the cases where the source and
target have the same number of elements.  <i>end note</i>]
</p>
</blockquote>
</blockquote>
</li>

<li>
<p>
Following 20.4.2.1 [tuple.cnstr]/16 add a new Remarks element:
</p>

<blockquote><pre>template &lt;class... UTypes&gt; tuple(tuple&lt;UTypes...&gt;&amp;&amp; u);
</pre>

<blockquote>
<p>
15 <i>Requires:</i> Each type in <tt>Types</tt> shall shall satisfy the
requirements of <tt>MoveConstructible</tt> (Table 33) from the corresponding
type in <tt>UTypes</tt>. <tt>sizeof...(Types) == sizeof...(UTypes)</tt>.
</p>

<p>
16 <i>Effects:</i> Move-constructs each element of <tt>*this</tt> with the
corresponding element of <tt>u</tt>.
</p>

<p>
<ins><i>Remarks:</i> This constructor shall not participate in overload
resolution unless each type in <tt>UTypes</tt> is implicitly convertible to its
corresponding type in <tt>Types</tt>.</ins>
</p>

<p>
[<i>Note:</i> <tt>enable_if</tt> can be used to make the converting constructor
and assignment operator exist only in the cases where the source and target have
the same number of elements.  <i>end note</i>]
</p>
</blockquote>
</blockquote>
</li>

<li>
<p>
Following 20.4.2.1 [tuple.cnstr]/18 add a new Remarks element:
</p>

<blockquote><pre>template &lt;class U1, class U2&gt; tuple(const pair&lt;U1, U2&gt;&amp; u);
</pre>

<blockquote>
<p>
17 <i>Requires:</i> The first type in <tt>Types</tt> shall be constructible from
<tt>U1</tt> and the second type in <tt>Types</tt> shall be constructible from
<tt>U2</tt>. <tt>sizeof...(Types) == 2</tt>.
</p>

<p>
18 <i>Effects:</i> Constructs the first element with <tt>u.first</tt> and the
second element with <tt>u.second</tt>.
</p>

<p>
<ins><i>Remarks:</i> This constructor shall not participate in overload
resolution unless <tt>U1</tt> is implicitly convertible to the first type in
<tt>Types</tt> and <tt>U2</tt> is implicitly convertible to the second type in
<tt>Types</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>

<li>
<p>
Following 20.4.2.1 [tuple.cnstr]/20 add a new Remarks element:
</p>

<blockquote><pre>template &lt;class U1, class U2&gt; tuple(pair&lt;U1, U2&gt;&amp;&amp; u);
</pre>

<blockquote>
<p>
19 <i>Requires:</i> The first type in <tt>Types</tt> shall shall satisfy the
requirements of <tt>MoveConstructible</tt>(Table 33) from <tt>U1</tt> and the
second type in <tt>Types</tt> shall be move-constructible from <tt>U2</tt>.
<tt>sizeof...(Types) == 2</tt>.
</p>

<p>
20 <i>Effects:</i> Constructs the first element with <tt>std::move(u.first)</tt>
and the second element with <tt>std::move(u.second)</tt>
</p>

<p>
<ins><i>Remarks:</i> This constructor shall not participate in overload
resolution unless <tt>U1</tt> is implicitly convertible to the first type in
<tt>Types</tt> and <tt>U2</tt> is implicitly convertible to the second type in
<tt>Types</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>

</ol>
<p><i>[
2010-10-24 Daniel adds:
]</i></p>


<blockquote>
Accepting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3140.html">n3140</a> would solve this issue.
</blockquote>


<p><b>Proposed resolution:</b></p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3140.html">n3140</a>.






<hr>
<h3><a name="1325"></a>1325. bitset</h3>
<p><b>Section:</b> 20.5.1 [bitset.cons] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Christopher Jefferson <b>Opened:</b> 2010-03-07 <b>Last modified:</b> 2010-11-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#bitset.cons">issues</a> in [bitset.cons].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
As mentioned on the boost mailing list:
</p>

<p>
The following code, valid in C++03, is broken in C++0x due to ambiguity
between the "<tt>unsigned long long</tt>" and "<tt>char*</tt>"
constructors.
</p>

<blockquote><pre>#include &lt;bitset&gt;
std::bitset&lt;10&gt; b(0);
</pre></blockquote>

<p><i>[
The proposed resolution has been reviewed by Stephan T. Lavavej.
]</i></p>


<p><i>[
Post-Rapperswil
]</i></p>


<p>
The proposed resolution has two problems:
</p>
<ul>
<li>
<p>it fails to provide support for non-terminated strings, which
could be easily added and constitutes an important use-case. For
example, the following code would invoke UB with the current
P/R:</p>
<blockquote>
<pre>char s[4] = { '0', '1', '0', '1' }; // notice: not null-terminated!
bitset&lt;4&gt; b(s, 0, 4);
</pre></blockquote>
because it requires the evaluation (under the as-if rule, to be fair,
but it doesn't matter) of <tt>basic_string&lt;char&gt;(s)</tt>
</li>
<li>
<p>it promotes a consistency between the two <tt>bitset</tt>
constructors that take a <tt>const std::string&amp;</tt> and a
<tt>const char*</tt>, respectively, while practice established by
<tt>std::basic_string</tt> would recommend a different set of
parameters. In particular, the constructor of
<tt>std::basic_string</tt> that takes a <tt>const char*</tt> does
not have a <tt>pos</tt> parameter</p>
</li>
</ul>

<blockquote>
Moved to Tentatively Ready with revised wording provided by Alberto Ganesh Babati after 5 positive votes on c++std-lib.
</blockquote>

<p><i>[
Adopted at 2010-11 Batavia
]</i></p>




<p><b>Proposed resolution:</b></p>


<ol>
<li>In the synopsis of header <tt>&lt;bitset&gt;</tt> in
20.5 [template.bitset]/1, replace the fourth bitset constructor:
<blockquote>
<pre><del>explicit bitset(const char *str);</del>
<ins>template &lt;class charT&gt;
  explicit bitset(
    const charT *str,
    typename basic_string&lt;charT&gt;::size_type n = basic_string&lt;charT&gt;::npos,
    charT zero = charT('0'), charT one = charT('1'));</ins>
</pre></blockquote>
</li>
<li>In 20.5.1 [bitset.cons]/8:
<blockquote>
<pre><del>explicit bitset(const char *str);</del>
<ins>template &lt;class charT&gt;
explicit
bitset(const charT *str,
       typename basic_string&lt;charT&gt;::size_type n = basic_string&lt;charT&gt;::npos,
       charT zero = charT('0'), charT one = charT('1'));</ins>
</pre></blockquote>
Effects: Constructs an object of class
<tt>bitset&lt;N&gt;</tt> as if by
<del>bitset(string(str)).</del>
<blockquote><pre><ins>
bitset(
  n == basic_string&lt;charT&gt;::npos
    ? basic_string&lt;charT&gt;(str)
    : basic_string&lt;charT&gt;(str, n),
  0, n, zero, one)
</ins></pre></blockquote>
</li>
</ol>






<hr>
<h3><a name="1326"></a>1326. Missing/wrong preconditions for <tt>pair</tt> and <tt>tuple</tt> functions</h3>
<p><b>Section:</b> 20.3.5.2 [pairs.pair], 20.4.2.1 [tuple.cnstr] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2010-03-07 <b>Last modified:</b> 2010-11-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#pairs.pair">issues</a> in [pairs.pair].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There are several constructors and creation functions of std::tuple
that impose requirements on it's arguments, that are unnecessary
restrictive and don't match the intention for the supported argument
types. This is related to the fact that tuple is supposed to accept both
object types and lvalue-references and the usual MoveConstructible and
CopyConstructible requirements are bad descriptions for non-const
references. Some examples:
</p>

<ol type="a">
<li>
<p>
20.4.2.1 [tuple.cnstr] before p.4 and p.8, resp.:
</p>

<blockquote><pre>explicit tuple(const Types&amp;...);
</pre>
<blockquote>
4 <i>Requires:</i> Each type in <tt>Types</tt> shall be copy constructible.
</blockquote>

<pre>tuple(const tuple&amp; u) = default;
</pre>
<blockquote>
8 <i>Requires:</i> Each type in <tt>Types</tt> shall satisfy the requirements of
<tt>CopyConstructible</tt> (Table 34).

</blockquote>
</blockquote>

<p>
A tuple that contains lvalue-references to non-const can never
satisfy the <tt>CopyConstructible</tt> requirements. <tt>CopyConstructible</tt>
requirements <i>refine</i> the <tt>MoveConstructible</tt> requirements and
this would require that these lvalue-references could bind
rvalues. But the core language does not allow that. Even, if we
would interpret that requirement as referring to the underlying
non-reference type, this requirement would be wrong as well,
because there is no reason to disallow a type such as
</p>

<blockquote><pre>struct NoMoveNoCopy {
  NoMoveNoCopy(NoMoveNoCopy&amp;&amp;) = delete;
  NoMoveNoCopy(const NoMoveNoCopy&amp;) = delete;
  ...
}:
</pre></blockquote>

<p>
for the instantiation of <tt>std::tuple&lt;NoMoveNoCopy&amp;&gt;</tt> and
that of it's copy constructor.
</p>

<p>
A more reasonable requirement for this example would be to require that
"<tt>is_constructible&lt;Ti, const Ti&amp;&gt;::value</tt> shall
evaluate to true for all <tt>Ti</tt> in <tt>Types</tt>". In this case
the special reference-folding and const-merging rules of references
would make this well-formed in all cases. We could also add the further
constraint "if <tt>Ti</tt> is an object type, it shall satisfy the
<tt>CopyConstructible</tt> requirements", but this additional
requirement seems not really to help here. Ignoring it would only mean
that if a user would provide a curious object type <tt>C</tt> that
satisfies the <tt>std::is_constructible&lt;C, const C&amp;&gt;</tt>
test, but not the "<tt>C</tt> is <tt>CopyConstructible</tt>" test would
produce a <tt>tuple&lt;C&gt;</tt> that does not satisfy the
<tt>CopyConstructible</tt> requirements as well.
</p>
</li>

<li>
<p>
20.4.2.1 [tuple.cnstr] before p.6 and p.10, resp.:
</p>

<blockquote><pre>template &lt;class... UTypes&gt;
explicit tuple(UTypes&amp;&amp;... u);
</pre>

<blockquote>
6 <i>Requires:</i> Each type in <tt>Types</tt> shall satisfy the
requirements of <tt>MoveConstructible</tt> (Table 33) from the
corresponding type in <tt>UTypes</tt>. <tt>sizeof...(Types) ==
sizeof...(UTypes)</tt>.
</blockquote>

<pre>tuple(tuple&amp;&amp; u);
</pre>
<blockquote>
10 <i>Requires:</i> Each <tt>type</tt> in <tt>Types</tt> shall shall
satisfy the requirements of <tt>MoveConstructible</tt> (Table 33).
</blockquote>
</blockquote>

<p>
We have a similar problem as in (a): Non-const lvalue-references
are intended template arguments for <tt>std::tuple</tt>, but cannot satisfy
the <tt>MoveConstructible</tt> requirements. In this case the correct
requirements would be
</p>

<blockquote>
<tt>is_constructible&lt;Ti, Ui&gt;::value</tt> shall evaluate to true
for all <tt>Ti</tt> in <tt>Types</tt> and for all <tt>Ui</tt> in
<tt>UTypes</tt>
</blockquote>

<p>
and
</p>

<blockquote>
<tt>is_constructible&lt;Ti, Ti&gt;::value</tt> shall evaluate to true
for all <tt>Ti</tt> in <tt>Types</tt>
</blockquote>

<p>
respectively.
</p>
</li>
</ol>

<p>
Many <tt>std::pair</tt> member functions do not add proper requirements, e.g.
the default c'tor does not require anything. This is corrected within the
suggested resolution. Further-on the P/R has been adapted to the FCD numbering.
</p>

<p><i>[
2010-03-25 Daniel updated wording:
]</i></p>


<blockquote>
The issue became updated to fix some minor inconsistencies and to ensure a
similarly required fix for <tt>std::pair</tt>, which has the same specification
problem as <tt>std::tuple</tt>, since <tt>pair</tt> became extended to support
reference members as well.
</blockquote>

<p><i>[Original proposed resolution:]</i></p>

<ol>

<li>
<p>
Change 20.3.5.2 [pairs.pair]/1 as indicated <i>[The changes for the effects
elements are not normative changes, they just ensure
harmonization with existing wording style]</i>:
</p>

<blockquote><pre>constexpr pair();
</pre>

<blockquote>
<p>
<ins><i>Requires:</i> <tt>first_type</tt> and <tt>second_type</tt> shall satisfy
the <tt>DefaultConstructible</tt> requirements.</ins>
</p>

<p>
1 <i>Effects:</i> <ins>Value-initializes <tt>first</tt> and
<tt>second</tt>.</ins><del>Initializes its members as if implemented: <tt>pair()
: first(), second() { }</tt>.</del>
</p>

</blockquote>
</blockquote>

</li>

<li>
<p>
Change 20.3.5.2 [pairs.pair]/2 as indicated:
</p>

<blockquote><pre>pair(const T1&amp; x, const T2&amp; y);
</pre>

<blockquote>
<p>
<ins><i>Requires:</i> <tt>is_constructible&lt;T1, const T1&amp;&gt;::value</tt>
is <tt>true</tt> and <tt>is_constructible&lt;T2, const T2&amp;&gt;::value</tt>
is <tt>true</tt>.</ins>
</p>

<p>
2 <i>Effects:</i> The constructor initializes <tt>first</tt> with <tt>x</tt> and
<tt>second</tt> with <tt>y</tt>.
</p>

</blockquote>
</blockquote>

</li>

<li>
<p>
Change 20.3.5.2 [pairs.pair]/3 as indicated:
</p>

<blockquote><pre>template&lt;class U, class V&gt; pair(U&amp;&amp; x, V&amp;&amp; y);
</pre>

<blockquote>
<p>
<ins><i>Requires:</i> <tt>is_constructible&lt;first_type, U&gt;::value</tt> is
<tt>true</tt> and <tt>is_constructible&lt;second_type, V&gt;::value</tt> is
<tt>true</tt>.</ins>
</p>

<p>
3 <i>Effects:</i> The constructor initializes <tt>first</tt> with
<tt>std::forward&lt;U&gt;(x)</tt> and <tt>second</tt> with
<tt>std::forward&lt;V&gt;(y)</tt>.
</p>

<p>
4 <i>Remarks:</i> If <tt>U</tt> is not implicitly convertible to
<tt>first_type</tt> or <tt>V</tt> is not implicitly convertible to
<tt>second_type</tt> this constructor shall not participate in overload
resolution.
</p>

</blockquote>
</blockquote>

</li>

<li>
<p>
Change 20.3.5.2 [pairs.pair]/5 as indicated <i>[The change in the effects
element should be non-normatively and is in compatible to the change suggestion
of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1324">1324</a>]</i>:
</p>

<blockquote><pre>template&lt;class U, class V&gt; pair(const pair&lt;U, V&gt;&amp; p);
</pre>

<blockquote>
<p>
<ins><i>Requires:</i> <tt>is_constructible&lt;first_type, const
U&amp;&gt;::value</tt> is <tt>true</tt> and <tt>is_constructible&lt;second_type,
const V&amp;&gt;::value</tt> is <tt>true</tt>.</ins>
</p>

<p>
5 <i>Effects:</i> Initializes members from the corresponding members of the
argument<del>, performing implicit conversions as needed</del>.
</p>

</blockquote>
</blockquote>

</li>

<li>
<p>
Change 20.3.5.2 [pairs.pair]/6 as indicated:
</p>

<blockquote><pre>template&lt;class U, class V&gt; pair(pair&lt;U, V&gt;&amp;&amp; p);
</pre>

<blockquote>
<p>
<ins><i>Requires:</i> <tt>is_constructible&lt;first_type, U&gt;::value</tt> is
<tt>true</tt> and <tt>is_constructible&lt;second_type, V&gt;::value</tt> is
<tt>true</tt>.</ins>
</p>

<p>
6 <i>Effects:</i> The constructor initializes <tt>first</tt> with
<tt>std::<del>move</del><ins>forward&lt;U&gt;</ins>(p.first)</tt> and
<tt>second</tt> with
<tt>std::<del>move</del><ins>forward&lt;V&gt;</ins>(p.second)</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li>
<p>
Change 20.3.5.2 [pairs.pair]/7+8 as indicated [The deletion in the effects
element should be non-normatively]:
</p>

<blockquote><pre>template&lt;class... Args1, class... Args2&gt;
  pair(piecewise_construct_t,
       tuple&lt;Args1...&gt; first_args, tuple&lt;Args2...&gt; second_args);
</pre>

<blockquote>
<p>
7 <i>Requires:</i> <ins><tt>is_constructible&lt;first_type,
Args1...&gt;::value</tt> is <tt>true</tt> and
<tt>is_constructible&lt;second_type, Args2...&gt;::value</tt> is
<tt>true</tt>.</ins> <del>All the types in <tt>Args1</tt> and <tt>Args2</tt>
shall be <tt>CopyConstructible</tt> (Table 35). <tt>T1</tt> shall be
constructible from <tt>Args1</tt>. <tt>T2</tt> shall be constructible from
<tt>Args2</tt>.</del>
</p>

<p>
8 <i>Effects:</i> The constructor initializes <tt>first</tt> with arguments of
types <tt>Args1...</tt> obtained by forwarding the elements of
<tt>first_args</tt> and initializes <tt>second</tt> with arguments of types
<tt>Args2...</tt> obtained by forwarding the elements of <tt>second_args</tt>.
<del>(Here, forwarding an element <tt>x</tt> of type <tt>U</tt> within a
<tt>tuple</tt> object means calling <tt>std::forward&lt;U&gt;(x)</tt>.)</del>
This form of construction, whereby constructor arguments for <tt>first</tt> and
<tt>second</tt> are each provided in a separate <tt>tuple</tt> object, is called
piecewise construction.
</p>

</blockquote>
</blockquote>

</li>

<li>
<p>
Change 20.3.5.2 [pairs.pair] before 12 as indicated:
</p>

<blockquote><pre>pair&amp; operator=(pair&amp;&amp; p);
</pre>

<blockquote>
<p>
<ins><i>Requires:</i> <tt>first_type</tt> and <tt>second_type</tt> shall satisfy
the <tt>MoveAssignable</tt> requirements.</ins>
</p>

<p>
12 <i>Effects:</i> Assigns to <tt>first</tt> with <tt>std::move(p.first)</tt>
and to <tt>second</tt> with <tt>std::move(p.second)</tt>.
</p>

<p>
13 <i>Returns:</i> <tt>*this</tt>.
</p>

</blockquote>
</blockquote>

</li>

<li>
<p>
Change [pairs.pair] before 14 as indicated: [The heterogeneous usage
of MoveAssignable is actually not defined,
but the library uses it at several places, so we follow this tradition
until a better term has been agreed on. One
alternative could be to write "first_type shall be assignable from an
rvalue of U [..]"]
</p>

<blockquote><pre>template&lt;class U, class V&gt; pair&amp; operator=(pair&lt;U, V&gt;&amp;&amp; p);
</pre>

<blockquote>

<p>
<ins><i>Requires:</i> <tt>first_type</tt> shall be <tt>MoveAssignable</tt> from
<tt>U</tt> and <tt>second_type</tt> shall be <tt>MoveAssignable</tt> from
<tt>V</tt>.</ins>
</p>

<p>
14 <i>Effects:</i> Assigns to <tt>first</tt> with <tt>std::move(p.first)</tt>
and to <tt>second</tt> with <tt>std::move(p.second)</tt>.
</p>

<p>
15 <i>Returns:</i> <tt>*this</tt>.
</p>

</blockquote>
</blockquote>

</li>

<li>
<p>
Change 20.4.2.1 [tuple.cnstr]/4+5 as indicated:
</p>

<blockquote><pre>explicit tuple(const Types&amp;...);
</pre>

<blockquote>
<p>
4 <i>Requires:</i> <ins><tt>is_constructible&lt;Ti, const
Ti&amp;&gt;::value == true</tt> for e</ins><del>E</del>ach type
<ins><tt>Ti</tt></ins> in <tt>Types</tt><del> shall be copy
constructible</del>.
</p>

<p>
5 <i>Effects:</i> <del>Copy i</del><ins>I</ins>nitializes each element with the
value of the corresponding parameter.
</p>

</blockquote>
</blockquote>

</li>

<li>
<p>
Change 20.4.2.1 [tuple.cnstr]/6 as indicated:
</p>

<blockquote><pre>template &lt;class... UTypes&gt;
explicit tuple(UTypes&amp;&amp;... u);
</pre>

<blockquote>
<p>
6 <i>Requires:</i> <ins><tt>is_constructible&lt;Ti, Ui&gt;::value ==
true</tt> for e</ins><del>E</del>ach type <ins><tt>Ti</tt></ins> in
<tt>Types</tt> <del>shall satisfy the requirements of
<tt>MoveConstructible</tt> (Table 33) from</del><ins>and for</ins> the
corresponding type <ins><tt>Ui</tt></ins> in <tt>UTypes</tt>.
<tt>sizeof...(Types) == sizeof...(UTypes)</tt>.
</p>

<p>
7 <i>Effects:</i> Initializes the elements in the <tt>tuple</tt> with the
corresponding value in <tt>std::forward&lt;UTypes&gt;(u)</tt>.
</p>

</blockquote>
</blockquote>
</li>

<li>
<p>
Change 20.4.2.1 [tuple.cnstr]/8+9 as indicated:
</p>

<blockquote><pre>tuple(const tuple&amp; u) = default;
</pre>

<blockquote>
<p>
8 <i>Requires:</i> <ins><tt>is_constructible&lt;Ti, const
Ti&amp;&gt;::value == true</tt> for e</ins><del>E</del>ach type
<ins><tt>Ti</tt></ins> in <tt>Types</tt><del> shall satisfy the
requirements of <tt>CopyConstructible</tt>(Table 34)</del>.
</p>

<p>
9 <i>Effects:</i> <ins>Initializes</ins><del>Copy constructs</del> each element
of <tt>*this</tt> with the corresponding element of <tt>u</tt>.
</p>

</blockquote>
</blockquote>
</li>

<li>
<p>
Change 20.4.2.1 [tuple.cnstr]/10+11 as indicated:
</p>

<blockquote><pre>tuple(tuple&amp;&amp; u);
</pre>

<blockquote>
<p>
10 <i>Requires:</i> <ins>Let <tt>i</tt> be in <tt>[0, sizeof...(Types))</tt> and
let <tt>Ti</tt> be the <tt>i</tt><sup><i>th</i></sup> type in <tt>Types</tt>.
Then <tt>is_constructible&lt;Ti, Ti&gt;::value</tt> shall be <tt>true</tt> for
all <tt>i</tt>.</ins> <del>Each type in <tt>Types</tt> shall shall satisfy the
requirements of <tt>MoveConstructible</tt> (Table 34)</del>.
</p>

<p>
11 <i>Effects:</i> <ins>For each <tt>Ti</tt> in <tt>Types</tt>, initializes the
<tt>i</tt><sup><i>th</i></sup></ins> <del>Move-constructs each</del> element of
<tt>*this</tt> with <del>the corresponding element of</del>
<ins><tt>std::forward&lt;Ti&gt;(get&lt;i&gt;(</tt></ins><tt>u</tt><ins><tt>))</tt></ins>.
</p>
</blockquote>
</blockquote>
</li>

<li>
<p>
Change 20.4.2.1 [tuple.cnstr]/15+16 as indicated:
</p>

<blockquote><pre>template &lt;class... UTypes&gt; tuple(tuple&lt;UTypes...&gt;&amp;&amp; u);
</pre>

<blockquote>
<p>
15 <i>Requires:</i> <ins>Let <tt>i</tt> be in <tt>[0, sizeof...(Types))</tt>,
<tt>Ti</tt> be the <tt>i</tt><sup><i>th</i></sup> type in <tt>Types</tt>, and
<tt>Ui</tt> be the <tt>i</tt><sup><i>th</i></sup> type in <tt>UTypes</tt>. Then
<tt>is_constructible&lt;Ti, Ui&gt;::value</tt> shall be <tt>true</tt> for all
<tt>i</tt>.</ins> <del>Each type in <tt>Types</tt> shall shall satisfy the
requirements of <tt>MoveConstructible</tt> (Table 34) from the corresponding
type in <tt>UTypes</tt></del>. <tt>sizeof...(Types) == sizeof...(UTypes)</tt>.
</p>

<p>
16 <i>Effects:</i> <ins>For each type <tt>Ti</tt>, initializes the
<tt>i</tt><sup><i>th</i></sup></ins> <del>Move-constructs each</del> element of
<tt>*this</tt> with <del>the corresponding element of</del>
<ins><tt>std::forward&lt;Ui&gt;(get&lt;i&gt;(</tt></ins><tt>u</tt><ins><tt>))</tt></ins>.
</p>

</blockquote>
</blockquote>

</li>

<li>
<p>
Change 20.4.2.1 [tuple.cnstr]/19+20 as indicated:
</p>

<blockquote><pre>template &lt;class U1, class U2&gt; tuple(pair&lt;U1, U2&gt;&amp;&amp; u);
</pre>

<blockquote>
<p>
19 <i>Requires:</i> <ins><tt>is_constructible&lt;T1, U1&gt;::value ==
true</tt> for <tt>t</tt></ins><del><tt>T</tt></del>he first type
<ins><tt>T1</tt></ins> in <tt>Types</tt> <del>shall shall satisfy the
requirements of <tt>MoveConstructible</tt>(Table 33) from
<tt>U1</tt></del> and <ins><tt>is_constructible&lt;T2, U2&gt;::value ==
true</tt> for</ins> the second type <ins><tt>T2</tt></ins> in
<tt>Types</tt> <del>shall be move-constructible from <tt>U2</tt></del>.
<tt>sizeof...(Types) == 2</tt>.
</p>

<p>
20 <i>Effects:</i> <ins>Initializes</ins><del>Constructs</del> the first
element with
<tt>std::<ins>forward&lt;U1&gt;</ins><del>move</del>(u.first)</tt> and
the second element with
<tt>std::<ins>forward&lt;U2&gt;</ins><del>move</del>(u.second)</tt>.
</p>

</blockquote>
</blockquote>
</li>

<li>
<p>
Change 20.4.2.4 [tuple.creation]/9-16 as indicated:
</p>

<blockquote><pre>template &lt;class... TTypes, class... UTypes&gt;
tuple&lt;TTypes..., UTypes...&gt; tuple_cat(const tuple&lt;TTypes...&gt;&amp; t, const tuple&lt;UTypes...&gt;&amp; u);
</pre>

<blockquote>
<p>
9 <i>Requires:</i> <ins><tt>is_constructible&lt;Ti, const
Ti&amp;&gt;::value == true</tt> for each type <tt>Ti</tt></ins><del>All
the types</del> in <tt>TTypes</tt> <del>shall be
<tt>CopyConstructible</tt> (Table 34)</del>.
<ins><tt>is_constructible&lt;Ui, const Ui&amp;&gt;::value == true</tt>
for each type <tt>Ui</tt></ins><del>All the types</del> in
<tt>UTypes</tt> <del>shall be <tt>CopyConstructible</tt> (Table
34)</del>.
</p>

<p>
10 <i>Returns:</i> A <tt>tuple</tt> object constructed by
<ins>initializing</ins><del>copy constructing</del> its first
<tt>sizeof...(TTypes)</tt> elements from the corresponding elements of
<tt>t</tt> and <ins>initializing</ins><del>copy constructing</del> its
last <tt>sizeof...(UTypes)</tt> elements from the corresponding elements
of <tt>u</tt>.
</p>
</blockquote>

<pre>template &lt;class... TTypes, class... UTypes&gt;
tuple&lt;TTypes..., UTypes...&gt; tuple_cat(tuple&lt;TTypes...&gt;&amp;&amp; t, const tuple&lt;UTypes...&gt;&amp; u);
</pre>

<blockquote>
<p>
11 <i>Requires:</i> <ins>Let <tt>i</tt> be in <tt>[0, sizeof...(TTypes))</tt>,
<tt>Ti</tt> be the <tt>i</tt><sup><i>th</i></sup> type in <tt>Types</tt>,
<tt>j</tt> be in <tt>[0, sizeof...(UTypes))</tt>, and <tt>Uj</tt> be the
<tt>j</tt><sup><i>th</i></sup> type in <tt>UTypes</tt>.
<tt>is_constructible&lt;Ti, Ti&gt;::value</tt> shall be <tt>true</tt> for each
type <tt>Ti</tt> and <tt>is_constructible&lt;Uj, const Uj&amp;&gt;::value</tt>
shall be <tt>true</tt> for each type <tt>Uj</tt></ins> <del>All the types in
<tt>TTypes</tt> shall be <tt>MoveConstructible</tt> (Table 34). All the types in
<tt>UTypes</tt> shall be <tt>CopyConstructible</tt> (Table 35)</del>.
</p>

<p>
12 <i>Returns:</i> A <tt>tuple</tt> object constructed by <ins>initializing the
<tt>i</tt><sup><i>th</i></sup> element with
<tt>std::forward&lt;Ti&gt;(get&lt;i&gt;(t))</tt> for all <tt>Ti</tt> in
<tt>TTypes</tt> and initializing the
<tt>(j+sizeof...(TTypes))</tt><sup><i>th</i></sup> element with
<tt>get&lt;j&gt;(u)</tt> for all <tt>Uj</tt> in <tt>UTypes</tt>.</ins> <del>move
constructing its first <tt>sizeof...(TTypes)</tt> elements from the
corresponding elements of <tt>t</tt> and copy constructing its last
<tt>sizeof...(UTypes)</tt> elements from the corresponding elements of
<tt>u</tt></del>.
</p>
</blockquote>

<pre>template &lt;class... TTypes, class... UTypes&gt;
tuple&lt;TTypes..., UTypes...&gt; tuple_cat(const tuple&lt;TTypes...&gt;&amp; t, tuple&lt;UTypes...&gt;&amp;&amp; u);
</pre>

<blockquote>
<p>
13 <i>Requires:</i> <ins>Let <tt>i</tt> be in <tt>[0, sizeof...(TTypes))</tt>,
<tt>Ti</tt> be the <tt>i</tt><sup><i>th</i></sup> type in <tt>Types</tt>,
<tt>j</tt> be in <tt>[0, sizeof...(UTypes))</tt>, and <tt>Uj</tt> be the
<tt>j</tt><sup><i>th</i></sup> type in <tt>UTypes</tt>.
<tt>is_constructible&lt;Ti, const Ti&amp;&gt;::value</tt> shall be <tt>true</tt>
for each type <tt>Ti</tt> and <tt>is_constructible&lt;Uj, Uj&gt;::value</tt>
shall be <tt>true</tt> for each type <tt>Uj</tt></ins> <del>All the types in
<tt>TTypes</tt> shall be <tt>CopyConstructible</tt> (Table 35). All the types in
<tt>UTypes</tt> shall be <tt>MoveConstructible</tt> (Table 34)</del>.
</p>

<p>
14 <i>Returns:</i> A <tt>tuple</tt> object constructed by <ins>initializing the
<tt>i</tt><sup><i>th</i></sup> element with <tt>get&lt;i&gt;(t)</tt> for each
type <tt>Ti</tt> and initializing the
<tt>(j+sizeof...(TTypes))</tt><sup><i>th</i></sup> element with
<tt>std::forward&lt;Uj&gt;(get&lt;j&gt;(u))</tt> for each type <tt>Uj</tt></ins>
<del>copy constructing its first <tt>sizeof...(TTypes)</tt> elements from the
corresponding elements of <tt>t</tt> and move constructing its last
<tt>sizeof...(UTypes)</tt> elements from the corresponding elements of
<tt>u</tt></del>.
</p>
</blockquote>

<pre>template &lt;class... TTypes, class... UTypes&gt;
tuple&lt;TTypes..., UTypes...&gt; tuple_cat(tuple&lt;TTypes...&gt;&amp;&amp; t, tuple&lt;UTypes...&gt;&amp;&amp; u);
</pre>

<blockquote>
<p>
15 <i>Requires:</i> <ins>Let <tt>i</tt> be in <tt>[0, sizeof...(TTypes))</tt>,
<tt>Ti</tt> be the <tt>i</tt><sup><i>th</i></sup> type in <tt>Types</tt>,
<tt>j</tt> be in <tt>[0, sizeof...(UTypes))</tt>, and <tt>Uj</tt> be the
<tt>j</tt><sup><i>th</i></sup> type in <tt>UTypes</tt>.
<tt>is_constructible&lt;Ti, Ti&gt;::value</tt> shall be <tt>true</tt> for each
type <tt>Ti</tt> and <tt>is_constructible&lt;Uj, Uj&gt;::value</tt> shall be
<tt>true</tt> for each type <tt>Uj</tt></ins> <del>All the types in
<tt>TTypes</tt> shall be <tt>MoveConstructible</tt> (Table 34). All the types in
<tt>UTypes</tt> shall be <tt>MoveConstructible</tt> (Table 34)</del>.
</p>

<p>
16 <i>Returns:</i> A <tt>tuple</tt> object constructed by <ins>initializing the
<tt>i</tt><sup><i>th</i></sup> element with
<tt>std::forward&lt;Ti&gt;(get&lt;i&gt;(t))</tt> for each type <tt>Ti</tt> and
initializing the <tt>(j+sizeof...(TTypes))</tt><sup><i>th</i></sup> element with
<tt>std::forward&lt;Uj&gt;(get&lt;j&gt;(u))</tt> for each type <tt>Uj</tt></ins>
<del>move constructing its first <tt>sizeof...(TTypes)</tt> elements from the
corresponding elements of <tt>t</tt> and move constructing its last
<tt>sizeof...(UTypes)</tt> elements from the corresponding elements of
<tt>u</tt></del>.
</p>
</blockquote>
</blockquote>
</li>
</ol>


<p><i>[
2010-10-24 Daniel adds:
]</i></p>


<blockquote>
Accepting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3140.html">n3140</a> would solve this issue.
</blockquote>


<p><b>Proposed resolution:</b></p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3140.html">n3140</a>.






<hr>
<h3><a name="1327"></a>1327. templates defined in <tt>&lt;cmath&gt;</tt> replacing C macros with the same name</h3>
<p><b>Section:</b> 26.8 [c.math] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> Michael Wong <b>Opened:</b> 2010-03-07 <b>Last modified:</b> 2010-11-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#c.math">issues</a> in [c.math].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 26.8 [c.math]p12
The templates defined in <tt>&lt;cmath&gt;</tt> replace the C99 macros
with the same names. The templates have the following declarations:
</p>

<blockquote><pre>namespace std {
template &lt;class T&gt; bool signbit(T x);
template &lt;class T&gt; int fpclassify(T x);
template &lt;class T&gt; bool isfinite(T x);
template &lt;class T&gt; bool isinf(T x);
template &lt;class T&gt; bool isnan(T x);
template &lt;class T&gt; bool isnormal(T x);
template &lt;class T&gt; bool isgreater(T x, T y);
template &lt;class T&gt; bool isgreaterequal(T x, T y);
template &lt;class T&gt; bool isless(T x, T y);
template &lt;class T&gt; bool islessequal(T x, T y);
template &lt;class T&gt; bool islessgreater(T x, T y);
template &lt;class T&gt; bool isunordered(T x, T y);
}
</pre></blockquote>

<p>
and p13:
</p>

<blockquote>
13 The templates behave the same as the C99 macros with corresponding
names defined in C99 7.12.3, Classification macros, and C99 7.12.14,
Comparison macros in the C standard.
</blockquote>

<p>
The C Std versions look like this:
</p>

<blockquote>
<p>
7.12.14.1/p1:
</p>
<blockquote>
<p>
Synopsis
</p>
<p>
1 <tt>#include &lt;math.h&gt;</tt>
</p>
<pre>int isgreaterequal(real-floating x, real-floating y);
</pre>
</blockquote>
</blockquote>

<p>
which is not necessarily the same types as is required by C++ since the
two parameters may be different. Would it not be better if it were truly
aligned with C?
</p>

<p><i>[
2010 Pittsburgh:  Bill to ask WG-14 if heterogeneous support for the
two-parameter macros is intended.
]</i></p>


<p><i>[
2010-09-13 Daniel comments:
]</i></p>


<blockquote>
I recommend to resolve this issue as NAD Editorial because
the accepted resolution for NB comment <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3162.html#US136">US-136</a>
by motion 27 does address this.
</blockquote>

<p><i>[
2010-09-14 Bill comments:
]</i></p>


<blockquote>
Motion 27 directly addresses LWG 1327 and solves the problem
presented there. Moreover, the solution has been aired before
WG14 with no dissent. These functions now behave the same for
mixed-mode calls in both C and C++
</blockquote>



<p><b>Proposed resolution:</b></p>
Apply proposed resolution for <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3162.html#US136">US-136</a>





<hr>
<h3><a name="1328"></a>1328. istream extractors not setting failbit if eofbit is already set</h3>
<p><b>Section:</b> 27.7.1.1.3 [istream::sentry] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> Paolo Carlini <b>Opened:</b> 2010-02-17 <b>Last modified:</b> 2010-11-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#istream::sentry">issues</a> in [istream::sentry].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p>
basing on the recent discussion on the library reflector, see c++std-lib-27728
and follow ups, I hereby formally ask for LWG 419 to be re-opened, the rationale
being that according to the current specifications, per
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n3000.pdf">n3000</a>,
it seems actually impossible to seek away from end of file, contrary to the
rationale which led <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#342">342</a> to its closure as NAD. My request is also
supported by Martin Sebor, and I'd like also to add, as tentative proposed
resolution for the re-opened issue, the wording suggested by Sebor, thus, change
the beginning of 27.7.1.1.3 [istream::sentry]/2, to:
</p>

<blockquote>
2 <i>Effects:</i> If <tt><ins>(!noskipws &amp;&amp; !</ins>is.good())</tt> is
<tt><del>false</del> <ins>true</ins></tt>, calls <tt>is.setstate(failbit)</tt>.
Otherwise prepares for formatted or unformatted input. ...
</blockquote>

<p><i>[
2010-10 Batavia"
]</i></p>

<p>
Resolved by adopting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3168.htm">n3168</a>.
</p>

<p>
Previous proposed resolution:
</p><p>
Change 27.7.1.1.3 [istream::sentry]/2:
</p>

<blockquote>
2 <i>Effects:</i> If <tt><ins>(!noskipws &amp;&amp; !</ins>is.good())</tt> is
<tt><del>false</del> <ins>true</ins></tt>, calls <tt>is.setstate(failbit)</tt>.
Otherwise prepares for formatted or unformatted input. ...
</blockquote>



<p></p>


<p><b>Proposed resolution:</b></p>
Addressed by paper <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3168.htm">n3168</a>.





<hr>
<h3><a name="1333"></a>1333. Missing forwarding during std::function invocation</h3>
<p><b>Section:</b> 20.8.14.2.4 [func.wrap.func.inv] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2010-03-26 <b>Last modified:</b> 2010-11-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#func.wrap.func.inv">issues</a> in [func.wrap.func.inv].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The current wording of 20.8.14.2.4 [func.wrap.func.inv]/1:
</p>

<blockquote><pre>R operator()(ArgTypes... args) const
</pre>

<blockquote>
<i>Effects:</i> <tt><i>INVOKE</i>(f, t1, t2, ..., tN, R)</tt> (20.8.2), where
<tt>f</tt> is the target object (20.8.1) of <tt>*this</tt> and <tt>t1, t2, ...,
tN</tt> are the values in <tt>args...</tt>.
</blockquote>
</blockquote>

<p>
uses an unclear relation between the actual args and the used variables
<tt>ti</tt>. It should be made clear, that <tt>std::forward</tt> has to be used
to conserve the expression lvalueness.
</p>

<p><i>[
Post-Rapperswil:
]</i></p>


<blockquote>
Moved to Tentatively Ready after 5 positive votes on c++std-lib.
</blockquote>

<p><i>[
Adopted at 2010-11 Batavia
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
Change 20.8.14.2.4 [func.wrap.func.inv]/1+2 as indicated:
</p>

<blockquote><pre>R operator()(ArgTypes... args) const
</pre>

<blockquote>
<p>
1 <i>Effects:</i>: <tt><i>INVOKE</i>(f,
<ins>std::forward&lt;ArgTypes&gt;(args)...</ins><del>t1, t2, ..., tN</del>,
R)</tt> (20.8.2), where <tt>f</tt> is the target object (20.8.1) of
<tt>*this</tt> <del>and <tt>t1, t2, ..., tN</tt> are the values in
<tt>args...</tt></del>.
</p>

<p>
2 <i>Returns:</i> Nothing if <tt>R</tt> is <tt>void</tt>, otherwise the return
value of <tt><i>INVOKE</i>(f,
<ins>std::forward&lt;ArgTypes&gt;(args)...</ins><del>t1, t2, ..., tN</del>,
R)</tt>.
</p>

<p>
3 <i>Throws:</i> <tt>bad_function_call</tt> if <tt>!*this</tt>; otherwise, any
exception thrown by the wrapped callable object.
</p>
</blockquote>
</blockquote>






<hr>
<h3><a name="1334"></a>1334. Insert iterators are broken for some proxy  containers compared to C++03</h3>
<p><b>Section:</b> 24.5.2.2.2 [back.insert.iter.op=], 24.5.2.4.2 [front.insert.iter.op=], X [insert.insert.iter.op=] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2010-03-28 <b>Last modified:</b> 2010-11-24</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In C++03 this was valid code:
</p>

<blockquote><pre>#include &lt;vector&gt;
#include &lt;iterator&gt;

int main() {
  typedef std::vector&lt;bool&gt; Cont;
  Cont c;
  std::back_insert_iterator&lt;Cont&gt; it = std::back_inserter(c);
  *it = true;
}
</pre></blockquote>

<p>
In C++0x this code does no longer compile because of an ambiguity error for this
<tt>operator=</tt> overload pair:
</p>

<blockquote><pre>back_insert_iterator&lt;Container&gt;&amp;
operator=(typename Container::const_reference value);

back_insert_iterator&lt;Container&gt;&amp;
operator=(typename Container::value_type&amp;&amp; value);
</pre></blockquote>

<p>
This is so, because for proxy-containers like <tt>std::vector&lt;bool&gt;</tt>
the <tt>const_reference</tt> usually is a non-reference type and in this case
it's identical to <tt>Container::value_type</tt>, thus forming the ambiguous
overload pair
</p>

<blockquote><pre>back_insert_iterator&lt;Container&gt;&amp;
operator=(bool value);

back_insert_iterator&lt;Container&gt;&amp;
operator=(bool&amp;&amp; value);
</pre></blockquote>

<p>
The same problem exists for <tt>std::back_insert_iterator</tt>,
<tt>std::front_insert_iterator</tt>, and <tt>std::insert_iterator</tt>.
</p>

<p>
One possible fix would be to require that <tt>const_reference</tt> of a proxy
container must not be the same as the <tt>value_type</tt>, but this would break
earlier valid code. The alternative would be to change the first signature to
</p>

<blockquote><pre>back_insert_iterator&lt;Container&gt;&amp;
operator=(const typename Container::const_reference&amp; value);
</pre></blockquote>

<p>
This would have the effect that this signature <em>always</em> expects an lvalue
or rvalue, but it would not create an ambiguity relative to the second form with
rvalue-references. [For all non-proxy containers the signature will be the same
as before due to reference-collapsing and const folding rules]
</p>


<p><i>[
Post-Rapperswil
]</i></p>


<p>
This problem is not restricted to the unspeakable <tt>vector&lt;bool&gt;</tt>, but is already existing for other proxy 
containers like gcc's <tt>rope</tt> class. The following code does no longer work ([Bug libstdc++/44963]):
</p>
<blockquote><pre>#include &lt;iostream&gt;
#include &lt;ext/rope&gt;

using namespace std;

int main()
{
     __gnu_cxx::crope line("test");
     auto ii(back_inserter(line));

     *ii++ = 'm'; // #1
     *ii++ = 'e'; // #2

     cout &lt;&lt; line &lt;&lt; endl;
}
</pre></blockquote>
<p>
Both lines marked with #1 and #2 issue now an error because the library has properly implemented the current
wording state (Thanks to Paolo Calini for making me aware of this real-life example).
</p>
<p>
The following P/R is a revision of the orignal P/R and was initially suggested by Howard 
Hinnant. Paolo verified that the approach works in gcc.
</p>

<blockquote>
Moved to Tentatively Ready with revised wording after 6 positive votes on c++std-lib.
</blockquote>

<p><i>[
Adopted at 2010-11 Batavia
]</i></p>




<p><b>Proposed resolution:</b></p>
<p><i>The wording refers to N3126.</i></p>

<ol>
<li>Change [back.insert.iterator], class <tt>back_insert_iterator</tt> synopsis as indicated:
<blockquote><pre>template &lt;class Container&gt;
class back_insert_iterator :
 public iterator&lt;output_iterator_tag,void,void,void,void&gt; {
protected:
 Container* container;
public:
 [..]
 back_insert_iterator&lt;Container&gt;&amp;
   operator=(<ins>const</ins> typename Container::<del>const_reference</del><ins>value_type&amp;</ins> value);
 back_insert_iterator&lt;Container&gt;&amp;
   operator=(typename Container::value_type&amp;&amp; value);
 [..]
};
</pre></blockquote>
</li>
<li>Change [back.insert.iter.op=] before p. 1 as indicated:
<blockquote><pre>back_insert_iterator&lt;Container&gt;&amp;
   operator=(<ins>const</ins> typename Container::<del>const_reference</del><ins>value_type&amp;</ins> value);
</pre>
<blockquote>
1 <em>Effects</em>: <tt>container-&gt;push_back(value)</tt>;<br>
2 <em>Returns</em>: <tt>*this</tt>.
</blockquote></blockquote>
</li>
<li>Change [front.insert.iterator], class <tt>front_insert_iterator</tt> synposis as indicated:
<blockquote><pre>template &lt;class Container&gt;
class front_insert_iterator :
 public iterator&lt;output_iterator_tag,void,void,void,void&gt; {
protected:
 Container* container;
public:
 [..]
 front_insert_iterator&lt;Container&gt;&amp;
   operator=(<ins>const</ins> typename Container::<del>const_reference</del><ins>value_type&amp;</ins> value);
 front_insert_iterator&lt;Container&gt;&amp;
   operator=(typename Container::value_type&amp;&amp; value);
 [..]
};
</pre></blockquote>
</li>
<li>Change [front.insert.iter.op=] before p.1 as indicated:
<blockquote><pre>front_insert_iterator&lt;Container&gt;&amp;
   operator=(<ins>const</ins> typename Container::<del>const_reference</del><ins>value_type&amp;</ins> value);
</pre>
<blockquote>
1 <em>Effects</em>: <tt>container-&gt;push_front(value)</tt>;<br>
2 <em>Returns</em>: <tt>*this</tt>.
</blockquote></blockquote>
</li>
<li>Change [insert.iterator], class insert_iterator synopsis as indicated:
<blockquote><pre>template &lt;class Container&gt;
   class insert_iterator :
     public iterator&lt;output_iterator_tag,void,void,void,void&gt; {
   protected:
     Container* container;
     typename Container::iterator iter;
   public:
     [..]
     insert_iterator&lt;Container&gt;&amp;
       operator=(<ins>const</ins> typename Container::<del>const_reference</del><ins>value_type&amp;</ins> value);
     insert_iterator&lt;Container&gt;&amp;
       operator=(typename Container::value_type&amp;&amp; value);
     [..]
   };
</pre></blockquote>
</li>
<li>Change [insert.iter.op=] before p. 1 as indicated:
<blockquote><pre>insert_iterator&lt;Container&gt;&amp;
    operator=(<ins>const</ins> typename Container::<del>const_reference</del><ins>value_type&amp;</ins> value);
</pre>
<blockquote>
1 <em>Effects</em>: 
<blockquote><pre>  iter = container-&gt;insert(iter, value);
  ++iter;
</pre></blockquote>
2 <em>Returns</em>: <tt>*this</tt>.
</blockquote></blockquote>
</li>
</ol>






<hr>
<h3><a name="1335"></a>1335. Insufficient requirements for <tt>tuple::operator&lt;()</tt></h3>
<p><b>Section:</b> 20.4.2.7 [tuple.rel] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Joe Gottman <b>Opened:</b> 2010-05-15 <b>Last modified:</b> 2010-11-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#tuple.rel">issues</a> in [tuple.rel].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The requirements section for <tt>std::tuple</tt> says the following: 
</p>

<blockquote>
<i>Requires:</i> For all <tt>i</tt>, where <tt>0 &lt;= i and i &lt;
sizeof...(Types)</tt>, <tt>get&lt;i&gt;(t) &lt; get&lt;i&gt;(u)</tt> is a valid
expression returning a type that is convertible to <tt>bool</tt>.
<tt>sizeof...(TTypes) == sizeof...(UTypes)</tt>.
</blockquote>

<p>
This is necessary but not sufficient, as the algorithm for comparing
<tt>tuple</tt>s also computes <tt>get&lt;i&gt;(u) &lt; get&lt;i&gt;(t)</tt>
(note the order)
</p>

<p><i>[
Post-Rapperswil
]</i></p>


<blockquote>
Moved to Tentatively Ready with updated wording correcting change-bars after 6 positive votes on c++std-lib.
</blockquote>

<p><i>[
Adopted at 2010-11 Batavia
]</i></p>




<p><b>Proposed resolution:</b></p>

<ol>
<li>Change [tuple.rel] before p. 4 as indicated [<strong>Remark to the editor: This paragraph doesn't have a number yet,
but it seems to me as if it should have one</strong>]:
<blockquote><pre>template&lt;class... TTypes, class... UTypes&gt;
bool operator&lt;(const tuple&lt;TTypes...&gt;&amp; t, const tuple&lt;UTypes...&gt;&amp; u);
</pre>
<blockquote>
<em>Requires</em>: For all <tt>i</tt>, where <tt>0 &lt;= i</tt> and <tt>i &lt; sizeof...(Types)</tt>, 
<tt>get&lt;i&gt;(t) &lt; get&lt;i&gt;(u)</tt> <ins>and <tt>get&lt;i&gt;(u) &lt; get&lt;i&gt;(t)</tt></ins><del>is 
a valid expression returning a type that is</del><ins> are valid expressions returning types that 
are</ins> convertible to <tt>bool</tt>. <tt>sizeof...(TTypes) == sizeof...(UTypes)</tt>.
</blockquote></blockquote>
</li>
</ol>






<hr>
<h3><a name="1337"></a>1337. Swapped arguments in <tt>regex_traits::isctype</tt></h3>
<p><b>Section:</b> 28.7 [re.traits] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2010-06-21 <b>Last modified:</b> 2010-11-24</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#re.traits">issues</a> in [re.traits].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
28.7 [re.traits]/12 describes <tt>regex_traits::isctype</tt> in terms
of <tt>ctype::is(c, m)</tt>, where <tt>c</tt> is a <tt>charT</tt> and <tt>m</tt>
is a <tt>ctype_base::mask</tt>.  Unfortunately 22.4.1.1.1 [locale.ctype.members]
specifies this function as <tt>ctype::is(m, c)</tt>
</p>

<p><i>[
Post-Rapperswil:
]</i></p>


<blockquote>
Moved to Tentatively Ready after 5 positive votes on c++std-lib.
</blockquote>

<p><i>[
Adopted at 2010-11 Batavia
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
Change 28.7 [re.traits]/12:
</p>

<blockquote><pre>bool isctype(charT c, char_class_type f) const;
</pre>
<blockquote>
<p>
11 ...
</p>
<p>
12 <i>Returns:</i> Converts <tt>f</tt> into a value <tt>m</tt> of type
<tt>std::ctype_base::mask</tt> in an unspecified manner, and returns
<tt>true</tt> if <tt>use_facet&lt;ctype&lt;charT&gt;
&gt;(getloc()).is(<del>c</del><ins>m</ins>, <del>m</del><ins>c</ins>)</tt> is
<tt>true</tt>. Otherwise returns <tt>true</tt> if <tt>f</tt> bitwise or'ed with
the result of calling <tt>lookup_classname</tt> with an iterator pair that
designates the character sequence <tt>"w"</tt> is not equal to 0 and <tt>c ==
'_'</tt>, or if <tt>f</tt> bitwise or'ed with the result of calling
<tt>lookup_classname</tt> with an iterator pair that designates the character
sequence <tt>"blank"</tt> is not equal to 0 and <tt>c</tt> is one of an
implementation-defined subset of the characters for which <tt>isspace(c,
getloc())</tt> returns <tt>true</tt>, otherwise returns <tt>false</tt>.
</p>
</blockquote>
</blockquote>





<hr>
<h3><a name="1338"></a>1338. LWG 1205 incorrectly applied</h3>
<p><b>Section:</b> 25.2.13 [alg.search] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2010-06-25 <b>Last modified:</b> 2010-11-24</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.search">issues</a> in [alg.search].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
LWG <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1205">1205</a> (currently in WP) clarified the return value of several
algorithms when dealing with empty ranges.  In particular it recommended for
25.2.13 [alg.search]:
</p>

<blockquote><pre>template&lt;class ForwardIterator1, class ForwardIterator2&gt;
  ForwardIterator1
    search(ForwardIterator1 first1, ForwardIterator1 last1,
           ForwardIterator2 first2, ForwardIterator2 last2);

template&lt;class ForwardIterator1, class ForwardIterator2,
         class BinaryPredicate&gt;
  ForwardIterator1
    search(ForwardIterator1 first1, ForwardIterator1 last1,
           ForwardIterator2 first2, ForwardIterator2 last2,
           BinaryPredicate pred);
</pre>
<blockquote>
<p>
1 <i>Effects:</i> ...
</p>
<p>
2 <i>Returns:</i> ... Returns <tt>last1</tt> if no such iterator is found.
</p>
<p><ins>
3 <i>Remarks:</i> Returns <tt>first1</tt> if <tt>[first2,last2)</tt> is empty.
</ins></p>
</blockquote>
</blockquote>

<p>
Unfortunately this got translated to an incorrect specification for what gets
returned when no such iterator is found (N3092):
</p>

<blockquote><pre>template&lt;class ForwardIterator1, class ForwardIterator2&gt;
  ForwardIterator1
    search(ForwardIterator1 first1, ForwardIterator1 last1,
           ForwardIterator2 first2, ForwardIterator2 last2);

template&lt;class ForwardIterator1, class ForwardIterator2,
         class BinaryPredicate&gt;
  ForwardIterator1
    search(ForwardIterator1 first1, ForwardIterator1 last1,
           ForwardIterator2 first2, ForwardIterator2 last2,
           BinaryPredicate pred);
</pre>
<blockquote>
<p>
1 <i>Effects:</i> ...
</p>
<p>
2 <i>Returns:</i> ... Returns <tt>first1</tt> if <tt>[first2,last2)</tt> is
empty or if no such iterator is found.
</p>
</blockquote>
</blockquote>

<p>
LWG <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1205">1205</a> is correct and N3092 is not equivalent nor correct.
</p>

<p>
I have not reviewed the other 10 recommendations of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1205">1205</a>.
</p>

<p><i>[
Post-Rapperswil
]</i></p>


<blockquote>
It was verified that none of the remaining possibly affected algorithms does have any similar problems and a concrete P/R was added
that used a similar style as has been applied to the other cases.
</blockquote>

<blockquote>
Moved to Tentatively Ready after 5 positive votes on c++std-lib.
</blockquote>

<p><i>[
Adopted at 2010-11 Batavia
]</i></p>




<p><b>Proposed resolution:</b></p>
<ol>
<li>Change [alg.search]/2 as indicated:
<blockquote><pre>template&lt;class ForwardIterator1, class ForwardIterator2&gt;
  ForwardIterator1
    search(ForwardIterator1 first1, ForwardIterator1 last1,
           ForwardIterator2 first2, ForwardIterator2 last2);

template&lt;class ForwardIterator1, class ForwardIterator2,
            class BinaryPredicate&gt;
  ForwardIterator1
    search(ForwardIterator1 first1, ForwardIterator1 last1,
           ForwardIterator2 first2, ForwardIterator2 last2,
           BinaryPredicate pred);
</pre>
<blockquote><p>
1 - [...]
</p>
2 - <em>Returns</em>: The first iterator <tt>i</tt> in the range <tt>[first1,last1 - (last2-first2))</tt> such that for any nonnegative
integer <tt>n</tt> less than <tt>last2 - first2</tt> the following corresponding conditions hold: <tt>*(i + n) == *(first2 + n)</tt>, 
<tt>pred(*(i + n), *(first2 + n)) != false</tt>. Returns <tt>first1</tt> if <tt>[first2,last2)</tt> is empty <del>or</del><ins>, otherwise
	returns <tt>last1</tt></ins> if no such iterator is found.
</blockquote></blockquote>
</li>
</ol>





<hr>
<h3><a name="1339"></a>1339. <tt>uninitialized_fill_n</tt> should return the end of its range</h3>
<p><b>Section:</b> 20.9.8.4 [uninitialized.fill.n] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Jared Hoberock <b>Opened:</b> 2010-07-14 <b>Last modified:</b> 2010-11-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3092.pdf">N3092's</a>
specification of <tt>uninitialized_fill_n</tt> discards useful information and
is inconsistent with other algorithms such as <tt>fill_n</tt> which accept an
iterator and a size.  As currently specified, <tt>unintialized_fill_n</tt>
requires an additional linear traversal to find the end of the range.
</p>

<p>
Instead of returning <tt>void</tt>, <tt>unintialized_fill_n</tt> should return
one past the last iterator it dereferenced.
</p>

<p><i>[
Post-Rapperswil:
]</i></p>


<blockquote>
Moved to Tentatively Ready after 5 positive votes on c++std-lib.
</blockquote>

<p><i>[
Adopted at 2010-11 Batavia
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
In section 20.9 [memory] change:,
</p>

<blockquote><pre>template &lt;class ForwardIterator, class Size, class T&gt;
  <del>void</del> <ins>ForwardIterator</ins> uninitialized_fill_n(ForwardIterator first, Size n, const T&amp; x);
</pre></blockquote>


<p>
In section 20.9.8.4 [uninitialized.fill.n] change,
</p>

<blockquote><pre>template &lt;class ForwardIterator, class Size, class T&gt;
  <del>void</del> <ins>ForwardIterator</ins> uninitialized_fill_n(ForwardIterator first, Size n, const T&amp; x);
</pre>
<blockquote>
<p>
1 <i>Effects:</i>
</p>
<blockquote><pre>for (; n--; ++first)
  ::new (static_cast&lt;void*&gt;(&amp;*first))
    typename iterator_traits&lt;ForwardIterator&gt;::value_type(x);
<ins>return first;</ins>
</pre></blockquote>
</blockquote>
</blockquote>






<hr>
<h3><a name="1340"></a>1340. Why does <tt>forward_list::resize</tt> take the object to be copied by value?</h3>
<p><b>Section:</b> 23.3.3.4 [forwardlist.modifiers] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> 		
James McNellis <b>Opened:</b> 2010-07-16 <b>Last modified:</b> 2010-11-24</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#forwardlist.modifiers">issues</a> in [forwardlist.modifiers].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3092.pdf">N3092</a>
23.3.3.4 [forwardlist.modifiers], the <tt>resize()</tt> member function is 
declared as:
</p>

<blockquote><pre>void resize(size_type sz, value_type c); 
</pre></blockquote>

<p>
The other sequence containers (<tt>list</tt>, <tt>deque</tt>, and
<tt>vector</tt>) take <tt>'c'</tt> by const reference.
</p>

<p>
Is there a reason for this difference?  If not, then <tt>resize()</tt> should 
be declared as: 
</p>

<blockquote><pre>void resize(size_type sz, const value_type&amp; c); 
</pre></blockquote>

<p>
The declaration would need to be changed both at its declaration in the class
definition at 23.3.3 [forwardlist]/3 and where its behavior is specified
at 23.3.3.4 [forwardlist.modifiers]/22.
</p>

<p>
This would make <tt>forward_list</tt> consistent with the CD1 issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#679">679</a>.
</p>

<p><i>[
Post-Rapperswil
]</i></p>


<p>
Daniel changed the P/R slightly, because one paragraph number has been changed since the issue
had been submitted. He also added a similar Requires element that exists in all other containers with
a <tt>resize</tt> member function. He deliberately did not touch the wrong usage of "default-constructed" because that
will be taken care of by LWG issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#868">868</a>.
</p>

<blockquote>
Moved to Tentatively Ready with revised wording after 5 positive votes on c++std-lib.
</blockquote>

<p><i>[
Adopted at 2010-11 Batavia
]</i></p>




<p><b>Proposed resolution:</b></p>


<ol>
<li>Change [forwardlist]/3, class template <tt>forward_list</tt> synopsis, as indicated:
<blockquote><pre>...
void resize(size_type sz);
void resize(size_type sz, <ins>const</ins> value_type<ins>&amp;</ins> c);
void clear();
...
</pre></blockquote>
</li>
<li>Change [forwardlist.modifiers]/27 as indicated: 
<blockquote><pre>	
void resize(size_type sz);
void resize(size_type sz, <ins>const</ins> value_type<ins>&amp;</ins> c);
</pre>
<blockquote>
27 <em>Effects</em>: If <tt>sz &lt; distance(begin(), end())</tt>, erases the last <tt>distance(begin(), end()) - sz</tt> elements
from the list. Otherwise, inserts <tt>sz - distance(begin(), end())</tt> elements at the end of the list. For the first 
signature the inserted elements are default constructed, and for the second signature they are copies of <tt>c</tt>.
<p>
<ins>28 - <em>Requires</em>: <tt>T</tt> shall be <tt>DefaultConstructible</tt> for the first form and	it shall be <tt>CopyConstructible</tt> 
	for the second form.</ins></p>
</blockquote></blockquote>
</li>
</ol>






<hr>
<h3><a name="1344"></a>1344. [FCD] Replace <tt>throw()</tt> with <tt>noexcept</tt></h3>
<p><b>Section:</b> 17 [library] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-29</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1351">1351</a></p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-60, CH-16</b></p>
<p>
Dynamic exception specifications are deprecated; the
library should recognise this by replacing all non-throwing
exception specifications of the form <tt>throw()</tt> with the
<tt>noexcept</tt> form.
</p>

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<p>
Replace all non-throwing exception specifications
of the form 'throw()' with the 'noexcept' form.
</p>

<p><i>[
2010-10-31 Daniel comments:
]</i></p>


<blockquote>
The proposed resolution of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3148.html">n3148</a>
would satisfy this request.
</blockquote>

<p><i>[
2010-Batavia:
]</i></p>

<blockquote>
Resolved by adopting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3148.html">n3148</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3148.html">n3148</a>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3150.html">n3150</a>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3195.html">n3195</a>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3155.html">n3155</a>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3156.html">n3156</a>





<hr>
<h3><a name="1346"></a>1346. [FCD] Apply <tt>noexcept</tt> where library specification does not permit exceptions</h3>
<p><b>Section:</b> 17 [library] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-29</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1352">1352</a></p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-62, CH-17</b></p>
<p>
Issues with efficiency and unsatisfactory semantics mean
many library functions document they do not throw
exceptions with a Throws: Nothing clause, but do not
advertise it with an exception specification. The semantic
issues are largely resolved with the new 'noexcept'
specifications, and the noexcept operator means we will
want to detect these guarantees programatically in order
to construct programs taking advantage of the guarantee.
</p>

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<p>
Add a <tt>noexcept</tt> exception specification on each
libary API that offers an unconditional <i>Throws</i>:
Nothing guarantee. Where the guarantee is
conditional, add the appropriate
<tt>noexcept(<i>constant-expression</i>)</tt> if an appropriate
constant expression exists.
</p>

<p><i>[
2010-10-31 Daniel comments:
]</i></p>


<blockquote>
The proposed resolution of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3149.html">n3149</a>
would satisfy this request.
</blockquote>

<p><i>[
2010-Batavia:
]</i></p>

<blockquote>
Resolved by adopting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3149.html">n3149</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>
This issue is resolved by the adoption of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3195.html">n3195</a>





<hr>
<h3><a name="1347"></a>1347. [FCD] Apply <tt>noexcept</tt> judiciously throughout the library</h3>
<p><b>Section:</b> 17 [library] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-29</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-63, US-80</b></p>
<p>
Since the newly introduced operator <tt>noexcept</tt> makes it
easy (easier than previously) to detect whether or not a
function has been declared with the empty exception
specification (including <tt>noexcept</tt>) library functions that
cannot throw should be decorated with the empty
exception specification. Failing to do so and leaving it as a
matter of QoI would be detrimental to portability and
efficiency.
</p>

<p><i>[
Resolution proposed by ballot comment
]</i></p>

<p>
Review the whole library, and apply the <tt>noexcept</tt>
specification where it is appropriate.
</p>

<p><i>[
2010-10-31 Daniel comments:
]</i></p>


<blockquote>
The proposed resolution of the combination of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3155.html">n3155</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3156.html">n3156</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3157.html">n3157</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3167.html">n3167</a>
would satisfy this request. The paper <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3150.html">n3150</a> is related
to this as well.
</blockquote>

<p><i>[
2010 Batavia:
]</i></p>

<p>
While the LWG expects to see further papers in this area, sufficient action was taken in Batavia to close the issue as Resolved by the listed papers.
</p>



<p><b>Proposed resolution:</b></p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3155.html">n3155</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3156.html">n3156</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3157.html">n3157</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3167.html">n3167</a> and remotely
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3150.html">n3150</a>





<hr>
<h3><a name="1354"></a>1354. [FCD] The definition of deadlock excludes cases involving a single thread</h3>
<p><b>Section:</b> 17.3.8 [defns.deadlock] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-24</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-52</b></p>
<p>
The definition of deadlock in 17.3.7 excludes cases
involving a single thread making it incorrect.
</p>

<p><i>[
Resolution proposed by ballot comment
]</i></p>

<p>
The definition should be corrected.
</p>

<p><i>[
2010 Batavia Concurrency group provides a Proposed Resolution
]</i></p>


<p><i>[
Adopted at 2010-11 Batavia
]</i></p>




<p><b>Proposed resolution:</b></p>
Change 17.3.8 [defns.deadlock] as indicated:
<blockquote>
<b>deadlock</b>
<p>
<del>two</del><ins>one</ins> or more threads are unable to continue execution because each is blocked waiting for one or more of the
others to satisfy some condition.
</p></blockquote>





<hr>
<h3><a name="1355"></a>1355. [FCD] The definition of move-assignment operator is redundant</h3>
<p><b>Section:</b> 17.3.16 [defns.move.assign.op] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-50</b></p>
<p>
This definition of move-assignment operator is redundant
and confusing now that the term move-assignment
operator is defined by the core language in subclause
12.8p21.
</p>

<p><i>[
2010-10-24 Daniel adds:
]</i></p>


<blockquote>
Accepting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3142.html">n3142</a> provides a superior resolution.
</blockquote>

<p><i>[
Resolution proposed by ballot comment
]</i></p>

<p>
Strike subclause 17.3.16 [defns.move.assign.op].
Add a cross-reference to (12.8) to 17.3.12.
</p>



<p><b>Proposed resolution:</b></p>
Resolved by paper <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3142.html">n3142</a>.





<hr>
<h3><a name="1356"></a>1356. [FCD] The definition of move-constructor is redundant</h3>
<p><b>Section:</b> 17.3.17 [defns.move.ctor] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-51</b></p>
<p>
This definition of move-constructor is redundant and
confusing now that the term constructor is defined by the
core language in subclause 12.8p3.
</p>

<p><i>[
2010-10-24 Daniel adds:
]</i></p>


<blockquote>
Accepting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3142.html">n3142</a> provides a superior resolution.
</blockquote>

<p><i>[
2010 Batavia: resolved as NAD Editorial by adopting paper <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3142.html">n3142</a>.
]</i></p>

<p>
Original proposed resolution preserved for reference:
</p>
<blockquote>
<p>
Strike subclause 17.3.14, [defns.move.ctor]
</p>

<blockquote><del>
<b>17.3.14	[defns.move.ctor]</b><br>
move constructor a constructor which accepts only an rvalue argument of the type being constructed and might modify the argument as a side effect during construction.
</del></blockquote>
</blockquote>



<p><b>Proposed resolution:</b></p>
Resolved by paper <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3142.html">n3142</a>.





<hr>
<h3><a name="1357"></a>1357. [FCD] Library bitmask types to not satisfy the bimask type requirements</h3>
<p><b>Section:</b> 17.5.2.1.3 [bitmask.types] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#bitmask.types">issues</a> in [bitmask.types].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-53</b></p>
<p>
The bitmask types defined in 27.5.2 and 28.5 contradict
the bitmask type requirements in 17.5.2.1.3, and have
missing or incorrectly defined operators.
</p>

<p><i>[
Resolution proposed by ballot comment
]</i></p>

<p>
See Appendix 1 - Additional Details
</p>

<p><i>[
2010 - Rapperswil
]</i></p>

<p>
The paper <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3110.html">n3110</a>
was made available during the meeting to resolve this comment, but withdrawn from formal motions
to give others time to review the document.  There was no technical objection, and it is expected
that this paper will go forward at the next meeting. 
</p>



<p><b>Proposed resolution:</b></p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3110.html">n3110</a>.





<hr>
<h3><a name="1360"></a>1360. [FCD] Add <tt>&lt;atomic&gt;</tt> to free-standing implementations</h3>
<p><b>Section:</b> 17.6.1.3 [compliance] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-10-24</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#compliance">issues</a> in [compliance].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-57</b></p>
<p>
The atomic operations facility is closely tied to clause 1
and the memory model. It is not easily supplied as an
after-market extension, and should be trivial to implement
of a single-threaded serial machine. The consequence of
not having this facility will be poor interoperability with
future C++ libraries that memory model concerns
seriously, and attempt to treat them in a portable way.
</p>

<p><i>[
Resolved in Rapperswil by a motion to directly apply the words from the ballot comment in N3102.
]</i></p>




<p><b>Proposed resolution:</b></p>
Add <tt>&lt;atomic&gt;</tt> to table 15, headers required for a
free-standing implementation.





<hr>
<h3><a name="1362"></a>1362. [FCD] Description of binding to rvalue-references should use the new 'xvalue' vocabulary</h3>
<p><b>Section:</b> 17.6.3.9 [res.on.arguments] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-24</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#res.on.arguments">issues</a> in [res.on.arguments].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-82</b></p>
<p>
17.6.3.9 [res.on.arguments] p.1. b.3: The second Note can benefit by adopting recent nomenclature.
</p>


<p><i>[
Resolution proposed by the ballot comment:
]</i></p>

<p>
Rephrase the Note in terms of xvalue.
</p>

<p><i>[
Pre-Batavia:
]</i></p>

<p>
Walter Brown provides wording.
</p>

<p><i>[Batavia: Immediate]</i></p>


<p><i>[
Adopted at 2010-11 Batavia
]</i></p>


<p><b>Proposed resolution:</b></p>

<p>
Amend the note in 17.6.3.9 [res.on.arguments] p1 bullet 3.
</p>
<blockquote>
[ <i>Note</i>: If a program casts an lvalue to an <del>rvalue</del><ins>xvalue</ins> while passing that lvalue to a library function (e.g. by calling the function with the argument <tt>move(x)</tt>), the program is effectively asking that function to treat that lvalue as a temporary. The implementation is free to optimize away aliasing checks which might be needed if the argument was anlvalue. <i>endnote</i>]
</blockquote>






<hr>
<h3><a name="1363"></a>1363. [FCD] <tt>offsetof</tt> should be marked <tt>noexcept</tt></h3>
<p><b>Section:</b> 18.2 [support.types] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-10-24</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#support.types">issues</a> in [support.types].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-68</b></p>
<p>
There is no reason for the offsetof macro to invoke
potentially throwing operations, so the result of
noexcept(offsetof(type,member-designator)) should be
true.
</p>

<p><i>[
Resolved in Rapperswil by a motion to directly apply the words from the ballot comment in N3102.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>Add to the end of 18.2p4:</p>
<blockquote><ins>
No operation invoked by the offsetof macro shall
throw an exception, and
<tt>noexcept(offsetof(type,member-designator))</tt> shall
be true.</ins>
</blockquote>





<hr>
<h3><a name="1365"></a>1365. [FCD] Thread-safety of handler functions</h3>
<p><b>Section:</b> 18.6.2 [alloc.errors] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-71</b></p>
<p>
The thread safety of <tt>std::set_new_handler()</tt>,
<tt>std::set_unexpected()</tt>, <tt>std::set_terminate()</tt>, is
unspecified making the the functions impossible to use in a thread
safe manner.
</p>

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<blockquote>
The thread safety guarantees for the functions
must be specified and new interfaces should be
provided to make it possible to query and install
handlers in a thread safe way.
</blockquote>

<p><i>[
2010-10-31 Daniel comments:
]</i></p>


<blockquote>
The proposed resolution of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3122.html">n3122</a>
partially addresses this request. This issue is related to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1366">1366</a>.
</blockquote>


<p><i>[
2010-Batavia:
]</i></p>

<blockquote>
Resolved by adopting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3189.html">n3189</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>
Resolved in Batavia by accepting  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3189.html">n3189</a>.





<hr>
<h3><a name="1366"></a>1366. [FCD] New-handler and data races</h3>
<p><b>Section:</b> 18.6.1.4 [new.delete.dataraces] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> DIN <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses DE-14</b></p>
<p>
It is unclear how a user replacement function can
simultaneously satisfy the race-free conditions imposed in
this clause and query the new-handler in case of a failed
allocation with the only available, mutating interface
<tt>std::set_new_handler</tt>.
</p>

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<p>
Offer a non-mutating interface to query the current new-handler.
</p>

<p><i>[
2010-10-24 Daniel adds:
]</i></p>


<blockquote>
Accepting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3122.html">n3122</a> would solve this issue.
This issue is related to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1365">1365</a>.
</blockquote>

<p><i>[
2010-Batavia:
]</i></p>

<blockquote>
Resolved by adopting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3189.html">n3189</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>
Resolved in Batavia by accepting  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3189.html">n3189</a>.





<hr>
<h3><a name="1367"></a>1367. [FCD] Deprecate library support for checking dynamic exception specifications</h3>
<p><b>Section:</b> D.13 [exception.unexpected] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-10-24</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-72</b></p>
<p>
Dynamic exception specifications are deprecated, so
clause 18.8.2 that describes library support for this facility
should move to Annex D, with the exception of the
<tt>bad_exception</tt> class which is retained to indicate other
failures in the exception dispatch mechanism (e.g. calling
<tt>current_exception()</tt>).
</p>

<p><i>[
Resolved in Rapperswil by a motion to directly apply the words from the ballot comment in N3102.
]</i></p>




<p><b>Proposed resolution:</b></p>
With the exception of 18.8.2.1 [bad.exception],
move clause 18.8.2 diectly to Annex D.
[bad.exception] should simply become the new
18.8.2.





<hr>
<h3><a name="1368"></a>1368. [FCD] Thread safety of <tt>std::uncaught_exception()</tt></h3>
<p><b>Section:</b> 18.8.4 [uncaught] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-24</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-73</b></p>
<p>
The thread safety <tt>std::uncaught_exception()</tt> and the
result of the function when multiple threads throw
exceptions at the same time are unspecified. To make the
function safe to use in the presence of exceptions in
multiple threads the specification needs to be updated.
</p>

<p><i>[
Resolution proposed by ballot comment
]</i></p>

<p>
Update this clause to support safe calls from
multiple threads without placing synchronization
requirements on the user.
</p>

<p><i>[
2010 Batavia Concurrency group provides a Proposed Resolution
]</i></p>


<p><i>[
Adopted at 2010-11 Batavia
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>Change 18.8.4 [uncaught] p. 1 as follows:</p>
<p>
<i>Returns</i>: <tt>true</tt> after <ins> the current thread has initialized </ins><del>initializing</del>
 an exception object (15.1) until a handler for the exception (including <tt>unexpected()</tt> or <tt>terminate()</tt>) 
 is activated (15.3). [ <i>Note</i>: This includes stack unwinding (15.2).  <i>end note</i> ]
</p>






<hr>
<h3><a name="1370"></a>1370. [FCD] <tt>throw_with_nested</tt> should not use perfect forwarding</h3>
<p><b>Section:</b> 18.8.6 [except.nested] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-24</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#except.nested">issues</a> in [except.nested].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-84</b></p>
<p>
The <tt>throw_with_nested</tt> specification passes in its argument as
<tt>T&amp;&amp;</tt> (perfect forwarding pattern), but then discusses
requirements on <tt>T</tt> without taking into account that <tt>T</tt>
may be an lvalue-reference type. It is also not clear in the spec that
<tt>t</tt> is intended to be perfectly forwarded.
</p>

<p><i>[
Resolution proposed by ballot comment
]</i></p>

<p>
Patch [except.nested] p6-7 to match the intent with regards to
requirements on <tt>T</tt> and the use of
<tt>std::forward&lt;T&gt;(t)</tt>.
</p>

<p><i>[
2010-10-24 Daniel adds:
]</i></p>


<blockquote>
Accepting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3144.html">n3144</a> would solve this issue.
</blockquote>

<p><i>[2010-11-10 Batavia: LWG accepts Howard's updated wording with
corrected boo boos reported by Sebastian Gesemann and Pete Becker,
which is approved for Immediate adoption this meeting.]</i></p>


<p><i>[
Adopted at 2010-11 Batavia
]</i></p>




<p><b>Proposed resolution:</b></p> 
<p><i>Change 18.8.7 nested_exception [except.nested] as indicated:</i></p>
<blockquote>
  <pre>[[noreturn]] template &lt;class T&gt; void throw_with_nested(T&amp;&amp; t);
</pre>
  <blockquote>
    <p><ins>Let <tt>U</tt> be <tt>remove_reference&lt;T&gt;::type</tt> </ins></p>
    <p>6 <i>Requires:</i> <tt><del>T</del> <ins>U</ins></tt> shall be <tt>
    CopyConstructible</tt>. </p>
    <p>7 <i>Throws:</i> If <tt><del>T</del> <ins>U</ins></tt> is a non-union 
    class type not derived from <tt>nested_exception</tt>, an exception of 
    unspecified type that is publicly derived from both <tt><del>T</del> <ins>U</ins></tt> 
    and <tt>nested_exception</tt> <ins>and constructed from <tt>std::forward&lt;T&gt;(t)</tt></ins>, 
    otherwise <ins>throws</ins> <tt><ins>std::forward&lt;T&gt;(</ins>t<ins>)</ins></tt>.
    </p>
  </blockquote>
</blockquote>





<hr>
<h3><a name="1372"></a>1372. [FCD] Adopt recommended practice for standard error categories</h3>
<p><b>Section:</b> 19.5.1.5 [syserr.errcat.objects] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-19</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-76</b></p>
<p>
The C++0x FCD recommends, in a note (see 19.5.1.1/1), that users
create a single <tt>error_category</tt> object for each user defined error
category and specifies <tt>error_category</tt> equality comparsions based on
equality of addresses (19.5.1.3). The Draft apparently ignores this
when specifying standard error category objects in section 19.5.1.5,
by allowing the <tt>generic_category()</tt> and <tt>system_category()</tt>
functions to return distinct objects for each invocation.
</p>
<p><i>[
Resolved in Rapperswil by a motion to directly apply the words from the ballot comment in N3102.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
Append a new sentence to 19.5.1.5 [syserr.errcat.objects]/1, and append
the same sentence to 19.5.1.5/3.
</p>
<blockquote><ins>
All calls of this function return references to the same object.
</ins></blockquote>





<hr>
<h3><a name="1377"></a>1377. [FCD] The revised <tt>forward</tt> is not compatible with access-control</h3>
<p><b>Section:</b> 20.3 [utility] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#utility">issues</a> in [utility].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-90</b></p>
<p>
In n3090, at variance with previous iterations of the idea
discussed in papers and incorporated in WDs,
<tt>std::forward</tt> is constrained via <tt>std::is_convertible</tt>,
thus is not robust wrt access control. This causes problems in
normal uses as implementation detail of member
functions. For example, the following snippet leads to a
compile time failure, whereas that was not the case for an
implementation along the lines of n2835 (using <tt>enable_if</tt>s
instead of concepts for the constraining, of course)
</p>
<pre>#include &lt;utility&gt;
struct Base { Base(Base&amp;&amp;); };

struct Derived
  : private Base
{
  Derived(Derived&amp;&amp; d)
    : Base(std::forward&lt;Base&gt;(d)) { }
};
</pre>
<p>
In other terms, LWG 1054 can be resolved in a better
way, the present status is not acceptable.
</p>

<p><i>[
2010-10-24 Daniel adds:
]</i></p>


<blockquote>
Accepting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3143.html">n3143</a> would solve this issue.
</blockquote>



<p><b>Proposed resolution:</b></p>
Resolved as NAD Editorial by paper <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3143.html">n3143</a>.





<hr>
<h3><a name="1378"></a>1378. [FCD] <tt>pair</tt> and <tt>tuple</tt> have too many conversions</h3>
<p><b>Section:</b> 20.3.5 [pairs] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> DIN <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#pairs">issues</a> in [pairs].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses DE-15</b></p>
<p>
Several function templates of <tt>pair</tt> and <tt>tuple</tt> allow for too
many implicit conversions, for example:
</p>
<pre>#include &lt;tuple&gt;
std::tuple&lt;char*&gt; p(0); // Error?

struct A { explicit A(int){} };
A a = 1; // Error
std::tuple&lt;A&gt; ta = std::make_tuple(1); // OK?
</pre>

<p><i>[
Resolution proposed by ballot comment
]</i></p>

<p>
Consider to add wording to constrain these function templates.
</p>

<p><i>[
2010-10-24 Daniel adds:
]</i></p>


<blockquote>
Accepting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3140.html">n3140</a> would solve this issue.
</blockquote>




<p><b>Proposed resolution:</b></p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3140.html">n3140</a>.





<hr>
<h3><a name="1379"></a>1379. [FCD] <tt>pair</tt> copy-assignment not consistent for references</h3>
<p><b>Section:</b> 20.3.5.2 [pairs.pair] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#pairs.pair">issues</a> in [pairs.pair].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-95</b></p>
<p>
Copy-assignment for <tt>pair</tt> is defaulted and does not work
for pairs with reference members. This is inconsistent with
conversion-assignment, which deliberately succeeds even
if one or both elements are reference types, just as for
<tt>tuple</tt>. The copy-assignment operator should be
consistent with the conversion-assignment operator and
with <tt>tuple</tt>'s assignment operators.
</p>

<p><i>[
2010-10-24 Daniel adds:
]</i></p>


<blockquote>
Accepting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3140.html">n3140</a> would provide a superior resolution,
because <tt>pair</tt> does not depend on the semantic requirements of <tt>CopyAssignable</tt>.
</blockquote>

<p><i>[
2010-11 Batavia
]</i></p>

<p>
Resolved by adopting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3140.html">n3140</a>.
</p>



<p><b>Proposed resolution:</b></p>
Add to <tt>pair</tt> synopsis:
<blockquote>
<tt>pair&amp; operator=(const pair&amp; p);</tt>
</blockquote>
<p>
Add before paragraph 9:
</p>
<blockquote>
<tt>pair&amp; operator=(const pair&amp; p);</tt>
<blockquote>
<p>
<i>Requires</i>: <tt>T1</tt> and <tt>T2</tt> shall satisfy the
requirements of <tt>CopyAssignable</tt>.
</p>
<p>
<i>Effects</i>: Assigns <tt>p.first</tt> to <tt>first</tt> and <tt>p.second</tt> to
<tt>second</tt>.
<i>Returns</i>: <tt>*this</tt>.
</p>
</blockquote>
</blockquote>





<hr>
<h3><a name="1380"></a>1380. [FCD] <tt>pair</tt> and <tt>tuple</tt> of references need to better specify move-semantics</h3>
<p><b>Section:</b> 20.3.5 [pairs] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> DIN <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#pairs">issues</a> in [pairs].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses DE-16</b></p>
<p>
Several <tt>pair</tt> and <tt>tuple</tt> functions in regard to move
operations are incorrectly specified if the member types
are references, because the result of a <tt>std::move</tt> cannot
be assigned to lvalue-references. In this context the usage
of the requirement sets <tt>MoveConstructible</tt> and
<tt>CopyConstructible</tt> also doesn't make sense, because
non-const lvalue-references cannot satisfy these requirements.
</p>

<p><i>[
Resolution proposed by ballot comment
]</i></p>

<p>
Replace the usage of <tt>std::move</tt> by that of
<tt>std::forward</tt> and replace <tt>MoveConstructible</tt> and
<tt>CopyConstructible</tt> requirements by other requirements.
</p>

<p><i>[
2010-10-24 Daniel adds:
]</i></p>


<blockquote>
Accepting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3140.html">n3140</a> would solve this issue.
</blockquote>

<p><i>[
2010-11 Batavia:
]</i></p>


<blockquote>
Resolved by adopting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3140.html">n3140</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3140.html">n3140</a>.





<hr>
<h3><a name="1381"></a>1381. [FCD] Ballot Comment GB-85</h3>
<p><b>Section:</b> X [pair.range] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-19</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-85</b></p>
<p>
While <tt>std::pair</tt> may happen to hold a pair of iterators
forming a valid range, this is more likely a coincidence
than a feature guaranteed by the semantics of the <tt>pair</tt>
template. A distinct range-type should be supplied to
enable the new for-loop syntax rather than overloading an
existing type with a different semantic.
</p>

<p>
If a replacement facility is required for C++0x,
consider n2995.
</p>

<p><i>[
Resolved in Rapperswil by a motion to directly apply the words from the ballot comment in N3102.
]</i></p>




<p><b>Proposed resolution:</b></p>
Strike 20.3.5.4 and the matching declarations in
20.3 header synopsis.





<hr>
<h3><a name="1382"></a>1382. [FCD] <tt>pair</tt> and <tt>tuple</tt> constructors should <tt>forward</tt> arguments</h3>
<p><b>Section:</b> 20.3.5 [pairs] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#pairs">issues</a> in [pairs].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-96</b></p>
<p>
<tt>pair</tt> and <tt>tuple</tt> constructors and assignment operators use
<tt>std::move</tt> when they should use <tt>std::forward</tt>. This
causes lvalue references to be erroneously converted to
rvalue references. Related requirements clauses are also
wrong.
</p>

<p><i>[
Resolution proposed by ballot comment
]</i></p>

<blockquote>
See Appendix 1 - Additional Details
</blockquote>

<p><i>[
2010-10-24 Daniel adds:
]</i></p>


<blockquote>
Accepting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3140.html">n3140</a> would solve this issue.
</blockquote>

<p><i>[
2010-11 Batavia
]</i></p>

<p>
Resolved by adopting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3140.html">n3140</a>.
</p>



<p><b>Proposed resolution:</b></p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3140.html">n3140</a>.





<hr>
<h3><a name="1383"></a>1383. [FCD] Inconsistent defaulted move/copy members in <tt>pair</tt> and <tt>tuple</tt></h3>
<p><b>Section:</b> 20.3.5 [pairs] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#pairs">issues</a> in [pairs].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-97</b></p>
<p>
<tt>pair</tt>'s class definition in N3092 20.3.5.2 [pairs.pair]
contains "<tt>pair(const pair&amp;) = default;</tt>" and 
"<tt>pair&amp; operator=(pair&amp;&amp; p);</tt>". The latter is described by
20.3.5.2 [pairs.pair] p.12-13.
</p>
"<tt>pair(const pair&amp;) = default;</tt>" is a user-declared explicitly defaulted
copy constructor. According to 12.8 [class.copy]/10, this inhibits 
the implicitly-declared move constructor. <tt>pair</tt> should be move constructible. 
(12.8 [class.copy]/7 explains that "<tt>pair(pair&lt;U, V&gt;&amp;&amp; p)</tt>" 
will never be instantiated to move <tt>pair&lt;T1, T2&gt;</tt> to <tt>pair&lt;T1, T2&gt;</tt>.)<br>
"<tt>pair&amp; operator=(pair&amp;&amp; p);</tt>" is a user-provided move
assignment operator (according to 8.4.2 [dcl.fct.def.default]/4: "A 
special member function is user-provided if it is user-declared and not explicitly defaulted
on its first declaration."). According to 12.8 [class.copy]/20, this inhibits
the implicitly-declared copy assignment operator. <tt>pair</tt>
should be copy assignable, and was in C++98/03. (Again,
12.8 [class.copy]/7 explains that "<tt>operator=(const pair&lt;U, V&gt;&amp; p)</tt>" 
will never be instantiated to copy <tt>pair&lt;T1, T2&gt;</tt> to <tt>pair&lt;T1, T2&gt;</tt>.)<br>
Additionally, "<tt>pair&amp; operator=(pair&amp;&amp; p);</tt>" is
unconditionally defined, whereas according to 12.8 [class.copy]/25,
defaulted copy/move assignment operators are defined as
deleted in several situations, such as when non-static data
members of reference type are present.
<p>
If "<tt>pair(const pair&amp;) = default;</tt>" and "<tt>pair&amp; operator=(pair&amp;&amp; p);</tt>" 
were removed from <tt>pair</tt>'s class definition in 20.3.5.2 [pairs.pair] and from 
20.3.5.2 [pairs.pair]/12-13, <tt>pair</tt> would
receive implicitly-declared copy/move constructors and
copy/move assignment operators, and 12.8 [class.copy]/25 would
apply. The implicitly-declared copy/move constructors
would be trivial when <tt>T1</tt> and <tt>T2</tt> have trivial copy/move
constructors, according to 12.8 [class.copy]/13, and similarly for the
assignment operators, according to12.8 [class.copy]/27. Notes could
be added as a reminder that these functions would be
implicitly-declared, but such notes would not be necessary
(the Standard Library specification already assumes a
high level of familiarity with the Core Language, and
casual readers will simply assume that <tt>pair</tt> is copyable
and movable).
</p><p>
Alternatively, <tt>pair</tt> could be given explicitly-defaulted
copy/move constructors and copy/move assignment
operators. This is a matter of style.
</p><p>
<tt>tuple</tt> is also affected. <tt>tuple</tt>'s class definition in 20.4 [tuple] contains:
</p><pre>tuple(const tuple&amp;) = default;
tuple(tuple&amp;&amp;);
tuple&amp; operator=(const tuple&amp;);
tuple&amp; operator=(tuple&amp;&amp;);
</pre>
They should all be removed or all be explicitly-defaulted,
to be consistent with <tt>pair</tt>. Additionally, 20.4.2.1 [tuple.cnstr]/8-9 specifies the 
behavior of an explicitly defaulted function, which is currently inconsistent with
<tt>pair</tt>.

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<blockquote>
Either remove "<tt>pair(const pair&amp;) = default;</tt>" and
"<tt>pair&amp; operator=(pair&amp;&amp; p);</tt>" from <tt>pair</tt>'s class
definition in  20.3.5.2 [pairs.pair] and from  20.3.5.2 [pairs.pair] p.12-13, or
give pair explicitly-defaulted copy/move constructors and copy/move assignment operators.<br>
Change <tt>tuple</tt> to match.
</blockquote>

<p><i>[
2010-10-24 Daniel adds:
]</i></p>


<blockquote>
Accepting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3140.html">n3140</a> would solve this issue:
The move/copy constructor will be defaulted, but the corresponding assignment operators need a non-default implementation
because they are supposed to work for references as well.
</blockquote>



<p><b>Proposed resolution:</b></p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3140.html">n3140</a>.





<hr>
<h3><a name="1384"></a>1384. [FCD] Ballot Comment US-98</h3>
<p><b>Section:</b> 20.4.2.4 [tuple.creation] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-04</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#tuple.creation">issues</a> in [tuple.creation].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-98</b></p>
<p>
pack_arguments is poorly named. It does not reflect the
fact that it is a tuple creation function and that it forwards
arguments.
</p>

<p><i>[
Resolved in Rapperswil by a motion to directly apply the words from the ballot comment in N3102.
]</i></p>




<p><b>Proposed resolution:</b></p>
Rename pack_arguments to forward_as_tuple
throughout the standard.





<hr>
<h3><a name="1386"></a>1386. FCD Ballot Comment US-99</h3>
<p><b>Section:</b> 20.4.2.4 [tuple.creation] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-04</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#tuple.creation">issues</a> in [tuple.creation].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-99</b></p>
<p>
pack_arguments is overly complex.
</p>

<p><i>[
Resolved in Rapperswil by a motion to directly apply the words from the ballot comment in N3102.
]</i></p>




<p><b>Proposed resolution:</b></p>
This issue resulted from a lack of understanding of
how references are forwarded. The definition of
pack_arguments should be simply:<br>
template &lt;class... Types&gt;
tuple&lt;<del>A</del>Types<ins>&amp;&amp;</ins>&gt;
pack_arguments(Types&amp;&amp;...t);<br>
<del>Types:Let Ti be each type in Types....</del><br>
Effects: ...<br>
Returns:<br>
tuple&lt;<del>A</del>Types<ins>&amp;&amp;</ins>...&gt;(std::forward&lt;Types&gt;(t)...)<br>
The synopsis should also change to reflect this
simpler signature.





<hr>
<h3><a name="1387"></a>1387. [FCD] Ballot Comment GB-87</h3>
<p><b>Section:</b> X [tuple.range] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-10-24</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-87</b></p>
<p>
There is no compelling reason to assume a
heterogeneous tuple of two elements holds a pair of
iterators forming a valid range. Unlike std::pair, there are
no functions in the standard library using this as a return
type with a valid range, so there is even less reason to try
to adapt this type for the new for-loop syntax.
</p>

<p><i>[
Resolved in Rapperswil by a motion to directly apply the words from the ballot comment in N3102.
]</i></p>




<p><b>Proposed resolution:</b></p>
Strike 20.4.2.10 and the matching declarations in
the header synopsis in 20.4.





<hr>
<h3><a name="1388"></a>1388. FCD Ballot Comment US-100</h3>
<p><b>Section:</b> 20.6.1 [ratio.ratio] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-04</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#ratio.ratio">issues</a> in [ratio.ratio].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-100</b></p>
<p>
LWG 1281 was discussed in Pittsburgh, and the decision
there was to accept the typedef as proposed and move to
Review. Unfortunately the issue was accidentally applied
to the FCD, and incorrectly. The FCD version of the
typedef refers to ratio&lt;N, D&gt;, but the typedef is intended
to refer to ratio&lt;num, den&gt; which in general is not the
same type.
</p>

<p><i>[
Resolved in Rapperswil by a motion to directly apply the words from the ballot comment in N3102.
]</i></p>




<p><b>Proposed resolution:</b></p>
Accept the current proposed wording of LWG
1281 which adds:<br>
typedef ratio&lt;num, den&gt; type;





<hr>
<h3><a name="1389"></a>1389. [FCD] Compile-time rational arithmetic and overflow</h3>
<p><b>Section:</b> 20.6.2 [ratio.arithmetic] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#ratio.arithmetic">issues</a> in [ratio.arithmetic].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-89</b></p>
<p>
The alias representations of the <tt>ratio</tt> arithmetic templates
do not allow implementations to avoid overflow, since they
explicitly specify the form of the aliased template
instantiation. For example
<tt>ratio_multiply</tt>, <tt>ratio&lt;2, LLONG_MAX&gt;</tt> is <em>required</em> to
alias <tt>ratio&lt;2*LLONG_MAX, LLONG_MAX*2&gt;</tt>, which
overflows, so is ill-formed. However, this is trivially equal
to <tt>ratio&lt;1, 1&gt;</tt>. It also contradicts the opening statement of
20.6.2 [ratio.arithmetic] p. 1 "implementations may use other algorithms to
compute these values".
</p>

<p><i>[
2010-10-25 Daniel adds:
]</i></p>


<blockquote>
Accepting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3131.html">n3131</a> would solve this issue.
</blockquote>

<p><i>[Batavia: Resoved by accepting
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3210.html">n3210</a>.]</i></p>




<p><b>Proposed resolution:</b></p>
Change the wording in 20.6.2 [ratio.arithmetic] p. 2-5 as follows:
<p>
</p><blockquote><pre>template &lt;class R1, class R2&gt; using ratio_add = <em>see below</em>;
</pre><blockquote>
2 The type <tt>ratio_add&lt;R1, R2&gt;</tt> shall be a synonym for <del><tt>ratio&lt;T1, T2&gt;</tt></del>
<ins><tt>ratio&lt;U, V&gt;</tt> such that <tt>ratio&lt;U, V&gt;::num</tt> and <tt>ratio&lt;U, V&gt;::den</tt> 
are the same as the corresponding members of <tt>ratio&lt;T1, T2&gt;</tt> would be in the absence of 
arithmetic overflow</ins> where <tt>T1</tt> has the value <tt>R1::num * R2::den + R2::num * R1::den</tt> 
and <tt>T2</tt> has the value <tt>R1::den * R2::den</tt>. <ins>If the required values of <tt>ratio&lt;U, V&gt;::num</tt> 
and <tt>ratio&lt;U, V&gt;::den</tt> cannot be represented in <tt>intmax_t</tt> then the program is ill-formed.</ins>
</blockquote></blockquote>
<blockquote><pre>template &lt;class R1, class R2&gt; using ratio_subtract = <em>see below</em>;
</pre><blockquote>
3 The type <tt>ratio_subtract&lt;R1, R2&gt;</tt> shall be a synonym for <del><tt>ratio&lt;T1, T2&gt;</tt></del>
<ins><tt>ratio&lt;U, V&gt;</tt> such that <tt>ratio&lt;U, V&gt;::num</tt> and <tt>ratio&lt;U, V&gt;::den</tt> 
are the same as the corresponding members of <tt>ratio&lt;T1, T2&gt;</tt> would be in the absence of 
arithmetic overflow</ins> where <tt>T1</tt> has the value <tt>R1::num * R2::den - R2::num * R1::den</tt> 
and <tt>T2</tt> has the value <tt>R1::den * R2::den</tt>. <ins>If the required values of <tt>ratio&lt;U, V&gt;::num</tt> 
and <tt>ratio&lt;U, V&gt;::den</tt> cannot be represented in <tt>intmax_t</tt> then the program is ill-formed.</ins>
</blockquote></blockquote>
<blockquote><pre>template &lt;class R1, class R2&gt; using ratio_multiply = <em>see below</em>;
</pre><blockquote>
4 The type <tt>ratio_multiply&lt;R1, R2&gt;</tt> shall be a synonym for <del><tt>ratio&lt;T1, T2&gt;</tt></del>
<ins><tt>ratio&lt;U, V&gt;</tt> such that <tt>ratio&lt;U, V&gt;::num</tt> and <tt>ratio&lt;U, V&gt;::den</tt> 
are the same as the corresponding members of <tt>ratio&lt;T1, T2&gt;</tt> would be in the absence of 
arithmetic overflow</ins> where <tt>T1</tt> has the value <tt>R1::num * R2::num</tt> and <tt>T2</tt> 
has the value <tt>R1::den * R2::den</tt>. <ins>If the required values of <tt>ratio&lt;U, V&gt;::num</tt> 
and <tt>ratio&lt;U, V&gt;::den</tt> cannot be represented in <tt>intmax_t</tt> then the program is ill-formed.</ins>
</blockquote></blockquote>
<blockquote><pre>template &lt;class R1, class R2&gt; using ratio_divide = <em>see below</em>;
</pre><blockquote>
5 The type <tt>ratio_divide&lt;R1, R2&gt;</tt> shall be a synonym for <del><tt>ratio&lt;T1, T2&gt;</tt></del>
<ins><tt>ratio&lt;U, V&gt;</tt> such that <tt>ratio&lt;U, V&gt;::num</tt> and <tt>ratio&lt;U, V&gt;::den</tt> 
are the same as the corresponding members of <tt>ratio&lt;T1, T2&gt;</tt> would be in the absence of 
arithmetic overflow</ins> where <tt>T1</tt> has the value <tt>R1::num * R2::den</tt> and <tt>T2</tt> 
has the value <tt>R1::den * R2::num</tt>. <ins>If the required values of <tt>ratio&lt;U, V&gt;::num</tt> 
and <tt>ratio&lt;U, V&gt;::den</tt> cannot be represented in <tt>intmax_t</tt> then the program is ill-formed.</ins>
</blockquote></blockquote>





<hr>
<h3><a name="1390"></a>1390. [FCD] Limit speculative compilation for constructible/convertible traits</h3>
<p><b>Section:</b> 20.7 [meta] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> DIN <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#meta">issues</a> in [meta].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses DE-17</b></p>
<p>
Speculative compilation for <tt>std::is_constructible</tt> and
<tt>std::is_convertible</tt> should be limited, similar to the core
language (see 14.8.2 paragraph 8).
</p>

<p><i>[
2010-10-24 Daniel adds:
]</i></p>


<blockquote>
Accepting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3142.html">n3142</a> would solve this issue.
</blockquote>



<p><b>Proposed resolution:</b></p>
Resolved by paper <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3142.html">n3142</a>.





<hr>
<h3><a name="1391"></a>1391. [FCD] constructible/convertible traits and access control</h3>
<p><b>Section:</b> 20.7 [meta] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> DIN <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#meta">issues</a> in [meta].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses DE-18</b></p>
<p>
Several type traits require compiler support, e.g.
<tt>std::is_constructible</tt> or <tt>std::is_convertible</tt>.
Their current specification seems to imply, that the corresponding
test expressions should be well-formed, even in absense of access:
</p>
<pre>class X { X(int){} };
constexpr bool test = std::is_constructible&lt;X, int&gt;::value;
</pre>
<p>
The specification does not clarify the context of this test
and because it already goes beyond normal language
rules, it's hard to argue by means of normal language
rules what the context and outcome of the test should be.
</p>

<p><i>[
Resolution proposed by ballot comment
]</i></p>

<p>
Specify that <tt>std::is_constructible</tt> and
<tt>std::is_convertible</tt> will return <tt>true</tt> only for
public constructors/conversion functions.
</p>

<p><i>[
2010-10-24 Daniel adds:
]</i></p>


<blockquote>
Accepting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3142.html">n3142</a> would solve this issue.
</blockquote>



<p><b>Proposed resolution:</b></p>
Resolved by paper <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3142.html">n3142</a>.





<hr>
<h3><a name="1392"></a>1392. [FCD] <tt>result_of</tt> should support pointer-to-data-member</h3>
<p><b>Section:</b> 20.7.4 [meta.unary] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#meta.unary">issues</a> in [meta.unary].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-102</b></p>
<p>
Despite Library Issue 520's ("<tt>result_of</tt> and pointers to
data members") resolution of CD1, the FCD's <tt>result_of</tt>
supports neither pointers to member functions nor
pointers to data members. It should.
</p>

<p><i>[
Resolution proposed by ballot comment
]</i></p>

<p>
Ensure <tt>result_of</tt> supports pointers to member
functions and pointers to data members.
</p>

<p><i>[
2010-10-24 Daniel adds:
]</i></p>


<blockquote>
Accepting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3123.html">n3123</a> would solve this issue.
</blockquote>



<p><b>Proposed resolution:</b></p>
Resolved by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3123.html">n3123</a>.





<hr>
<h3><a name="1393"></a>1393. [FCD] Trivial traits imply noexcept</h3>
<p><b>Section:</b> 20.7.4.3 [meta.unary.prop] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#meta.unary.prop">issues</a> in [meta.unary.prop].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-92</b></p>
<p>
Trivial functions implicitly declare a <tt>noexcept</tt> exception
specification, so the references to <tt>has_trivial_*</tt> traits in the
<tt>has_nothrow_*</tt> traits are redundant, and should be struck for clarity.
</p>

<p><i>[
Resolution proposed by ballot comment
]</i></p>

<p>
For each of the <tt>has_nothrow_<i>something</i></tt> traits,
remove all references to the matching
<tt>has_trivial_<i>something</i></tt> traits.
</p>

<p><i>[
2010-10-24 Daniel adds:
]</i></p>


<blockquote>
Accepting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3142.html">n3142</a> would solve this issue.
</blockquote>



<p><b>Proposed resolution:</b></p>
Resolved by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3142.html">n3142</a>.





<hr>
<h3><a name="1394"></a>1394. [FCD] Ballot Comment DE-19</h3>
<p><b>Section:</b> 20.7.4.3 [meta.unary.prop] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> DIN <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-19</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#meta.unary.prop">issues</a> in [meta.unary.prop].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses DE-19</b></p>
<p>
The fundamental trait is_constructible reports false
positives, e.g.
</p>
<pre>is_constructible&lt;char*, void*&gt;::value
</pre>
evaluates to true, even though a corresponding variable
initialization would be ill-formed.

<p><i>[
Resolved in Rapperswil by paper N3047.
]</i></p>




<p><b>Proposed resolution:</b></p>
Remove all false positives from the domain of
is_constructible.





<hr>
<h3><a name="1397"></a>1397. [FCD] Deprecate '98 binders</h3>
<p><b>Section:</b> 20.8 [function.objects] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#function.objects">issues</a> in [function.objects].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-95</b></p>
<p>
The adaptable function protocol supported by
<tt>unary_function</tt>/<tt>binary_function</tt> has been superceded by
lambda expressions and <tt>std::bind</tt>. Despite the name, the
protocol is not very adaptable as it requires intrusive
support in the adaptable types, rather than offering an
external traits-like adaption mechanism. This protocol and
related support functions should be deprecated, and we
should not make onerous requirements for the
specification to support this protocol for callable types
introduced in this standard revision, including those
adopted from TR1. It is expected that high-quality
implementations will provide such support, but we should
not have to write robust standard specifications mixing this
restricted support with more general components such as
<tt>function</tt>, <tt>bind</tt> and <tt>reference_wrapper</tt>.
</p>

<p><i>[
Resolution proposed by ballot comment
]</i></p>

<p>
Move clauses 20.8.3, 20.8.9, 20.8.11 and 20.8.12
to Annex D.
</p>
<p>
Remove the requirements to conditionally derive from
<tt>unary</tt>/<tt>binary_function</tt> from <tt>function</tt>,
<tt>reference_wrapper</tt>, and the results of calling <tt>mem_fn</tt>
and <tt>bind</tt>.
</p>

<p><i>[
2010-10-24 Daniel adds:
]</i></p>


<blockquote>
Accepting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3145.html">n3145</a> would solve this issue.
</blockquote>



<p><b>Proposed resolution:</b></p>
Resolved by paper <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3198.html">N3198</a>.





<hr>
<h3><a name="1399"></a>1399. [FCD] <tt>function</tt> does not need an <tt>explicit</tt> default constructor</h3>
<p><b>Section:</b> 20.8.14.2 [func.wrap.func] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Japan <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-10-24</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#func.wrap.func">issues</a> in [func.wrap.func].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses JP-3</b></p>
<p>
<tt>explicit</tt> default contructor is defined in <tt>std::function</tt>.
Although it is allowed according to 12.3.1, it seems
unnecessary to qualify the constructor as <tt>explicit</tt>.
If it is <tt>explicit</tt>, there will be a limitation in <tt>initializer_list</tt>.
</p>

<p><i>[
Resolved in Rapperswil by a motion to directly apply the words from the ballot comment in N3102.
]</i></p>




<p><b>Proposed resolution:</b></p>
Remove <tt>explicit</tt>.
<pre>namespace std {
template&lt;class&gt; class function;
// undefined
template&lt;class R, class... ArgTypes&gt;
class function&lt;R(ArgTypes...)&gt;
: public unary_function&lt;T1, R&gt;
// iff sizeof...(ArgTypes) == 1 and ArgTypes contains T1
: public binary_function&lt;T1, T2, R&gt;
// iff sizeof...(ArgTypes) == 2 and ArgTypes contains T1 andT2
{
public:typedef R result_type;
// 20.8.14.2.1, construct/copy/destroy:
  <del>explicit</del> function();
</pre>





<hr>
<h3><a name="1400"></a>1400. FCD <tt>function</tt> does not need an <tt>explicit</tt> default constructor</h3>
<p><b>Section:</b> 20.8.14.2.1 [func.wrap.func.con] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Japan <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-10-24</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#func.wrap.func.con">issues</a> in [func.wrap.func.con].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses JP-4</b></p>
<p>
Really does the <tt>function</tt> require that default constructor is <tt>explicit</tt>?
</p>

<p><i>[
Resolved in Rapperswil by a motion to directly apply the words from the ballot comment in N3102.
]</i></p>




<p><b>Proposed resolution:</b></p>
Remove explicit.
<pre>function();
template &lt;class A&gt;
function(allocator_arg_t, const A&amp; a);
</pre>





<hr>
<h3><a name="1402"></a>1402. [FCD] <tt>nullptr</tt> constructors for smart pointers should be <tt>constexpr</tt></h3>
<p><b>Section:</b> 20.9 [memory] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-10-24</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#memory">issues</a> in [memory].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-100</b></p>

The <tt>unique_ptr</tt> and <tt>shared_ptr</tt> constructors taking
<tt>nullptr_t</tt> delegate to a <tt>constexpr</tt> constructor, and could be
<tt>constexpr</tt> themselves.

<p><i>[
Resolved in Rapperswil by a motion to directly apply the words from the ballot comment in N3102.
]</i></p>




<p><b>Proposed resolution:</b></p>
In the 20.9.10.2 [unique.ptr.single] synopsis add
"constexpr" to unique_ptr(nullptr_t).<br>
In the 20.9.10.3 [unique.ptr.runtime] synopsis add
"constexpr" to unique_ptr(nullptr_t).<br>
In the 20.9.11.2 [util.smartptr.shared] synopsis
add "constexpr" to shared_ptr(nullptr_t).





<hr>
<h3><a name="1403"></a>1403. [FCD] Inconsistent definitions for <tt>allocator_arg</tt></h3>
<p><b>Section:</b> 20.9.1 [allocator.tag] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Japan <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-10-24</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses JP-85</b></p>
<p>
There are inconsistent definitions for <tt>allocator_arg</tt>.
In 20.9 [memory] paragraph 1,
</p>
<pre>constexpr allocator_arg_t allocator_arg = allocator_arg_t();
</pre>
and in 20.9.1,
<pre>const allocator_arg_t allocator_arg = allocator_arg_t();
</pre>

<p><i>[
Resolved in Rapperswil by a motion to directly apply the words from the ballot comment in N3102.
]</i></p>




<p><b>Proposed resolution:</b></p>
Change "const" to "constexpr" in 20.9.1 as
follows.
<pre>constexpr allocator_arg_t allocator_arg = allocator_arg_t();
</pre>





<hr>
<h3><a name="1404"></a>1404. [FCD] <tt>pointer_traits</tt> should have a <tt>size_type</tt> member</h3>
<p><b>Section:</b> 20.9.3 [pointer.traits] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-106</b></p>
<p>
<tt>pointer_traits</tt> should have a <tt>size_type</tt> member for completeness.
</p>
<p>
Add <tt>typedef <i>see below</i> size_type;</tt> to the generic
<tt>pointer_traits</tt> template and <tt>typedef size_t
size_type;</tt> to <tt>pointer_traits&lt;T*&gt;</tt>. Use
<tt>pointer_traits::size_type</tt> and
<tt>pointer_traits::difference_type</tt> as the defaults for
<tt>allocator_traits::size_type</tt> and
<tt>allocator_traits::difference_type</tt>.
</p>
<p>
See Appendix 1 - Additional Details
</p>

<p><i>[
Post-Rapperswil, Pablo provided wording:
]</i></p>


<p>
The original ballot comment reads simply: "<tt>pointer_traits</tt> should have a 
<tt>size_type</tt> for completeness."  The additional details reveal, however,
that the desire for a <tt>size_type</tt> is actually driven by the needs
of <tt>allocator_traits</tt>.  The <tt>allocator_traits</tt> template should get its
default <tt>difference_type</tt> from <tt>pointer_traits</tt> but if it did,
it should get its <tt>size_type</tt> from the same source.  Unfortunately,
there is no obvious meaning for <tt>size_type</tt> in <tt>pointer_traits</tt>.
</p>
<p>
Alisdair suggested, however, that the natural relationship between
<tt>difference_type</tt> and <tt>size_type</tt> can be expressed simply by the
<tt>std::make_unsigned&lt;T&gt;</tt> metafunction.  Using this metafunction,
we can easily define <tt>size_type</tt> for <tt>allocator_traits</tt> without
artificially adding <tt>size_type</tt> to <tt>pointer_traits</tt>.
</p>

<blockquote>
Moved to Tentatively Ready after 6 positive votes on c++std-lib.
</blockquote>

<p><i>[
Adopted at 2010-11 Batavia
]</i></p>





<p><b>Proposed resolution:</b></p>
<p>
In [allocator.requirements], Table 42, change two rows as follows:
</p>
<blockquote>
<table border="1">
  <tbody><tr>
    <td><tt>X::size_type</tt></td>
    <td>unsigned integral type</td>
    <td>a type that can represent the size of the largest object in the
    allocation model</td>
    <td><tt>
      <del>size_t</del>
      <ins>make_unsigned&lt;X::difference_type&gt;::type</ins>
    </tt></td>
  </tr>
  <tr>
    <td><tt>X::difference_type</tt></td>
    <td>signed integral type</td>
    <td>a type that can represent the difference between any two pointers in
    the allocation model</td>
    <td><tt>
      <del>ptrdiff_t</del>
      <ins>pointer_traits&lt;X::pointer&gt;::difference_type</ins>
    </tt></td>
  </tr>
</tbody></table>
</blockquote>
<p>
In [allocator.traits.types], Change the definition of difference_type and
size_type as follows:
</p>
<blockquote>
  <tt>typedef</tt> <i>see below</i> <tt>difference_type;</tt>
  <blockquote>
    <i>Type:</i> <tt>Alloc::difference_type</tt> if such a type exists,
    else <tt><del>ptrdiff_t</del>
    <ins>pointer_traits&lt;pointer&gt;::difference_type</ins></tt>.
  </blockquote>

  <tt>typedef</tt> <i>see below</i> <tt>size_type;</tt>
  <blockquote>
    <i>Type:</i> <tt>Alloc::size_type</tt> if such a type exists,
    else <tt><del>size_t</del>
    <ins>make_unsigned&lt;difference_type&gt;::type</ins></tt>.
  </blockquote>
</blockquote>





<hr>
<h3><a name="1405"></a>1405. [FCD] Ballot Comment US-107</h3>
<p><b>Section:</b> 20.10 [allocator.adaptor] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-19</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#allocator.adaptor">issues</a> in [allocator.adaptor].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-107</b></p>

scoped_allocator_adaptor should have its own header.

<p><i>[
Resolved in Rapperswil by a motion to directly apply the words from the ballot comment in N3102.
]</i></p>




<p><b>Proposed resolution:</b></p>
See Appendix 1 - Additional Details





<hr>
<h3><a name="1407"></a>1407. [FCD] Synch <tt>shared_ptr</tt> constructors taking movable types</h3>
<p><b>Section:</b> 20.9.10.2.1 [util.smartptr.shared.const] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-19</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#util.smartptr.shared.const">issues</a> in [util.smartptr.shared.const].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-108</b></p>

<tt>shared_ptr</tt> should have the same policy for constructing
from <tt>auto_ptr</tt> as <tt>unique_ptr</tt>. Currently it does not.

<p><i>[
Resolved in Rapperswil by paper N3109.
]</i></p>




<p><b>Proposed resolution:</b></p>
Add template &lt;class Y&gt; explicit
shared_ptr(auto_ptr&lt;Y&gt;&amp;); to
[util.smartptr.shared.const] (and to the synopsis).





<hr>
<h3><a name="1409"></a>1409. [FCD] Specify whether <tt>monotonic_clock</tt> is a distinct type or a typedef</h3>
<p><b>Section:</b> X [time.clock.monotonic] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#time.clock.monotonic">issues</a> in [time.clock.monotonic].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-111</b></p>
<p>
What it means for <tt>monotonic_clock</tt> to be a synonym is
undefined. If it may or may not be a typedef, then certain
classes of programs become unportable.
</p>

<p><i>[
Resolution proposed in ballot comment:
]</i></p>

<p>
Require that it be a distinct class type.
</p>

<p><i>[
2010-11-01 Daniel comments:
]</i></p>

<blockquote>
Paper <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3128.html">n3128</a> addresses
this issue by replacing <tt>monotonic_clock</tt> with <tt>steady_clock</tt>, which is not a typedef.
</blockquote>



<p><b>Proposed resolution:</b></p>
This is resolved by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3191.html">n3191</a>.





<hr>
<h3><a name="1410"></a>1410. [FCD] Add a feature-detect macro for <tt>monotonic_clock</tt></h3>
<p><b>Section:</b> X [time.clock.monotonic] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#time.clock.monotonic">issues</a> in [time.clock.monotonic].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1411">1411</a></p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-107, DE-20</b></p>
<p>
1.4 [intro.compliance] p.9 states that which conditionally
supported constructs are available should be provided in the 
documentation for the implementation. This doesn't help programmers trying
to write portable code, as they must then rely on
implementation-specific means to determine the
availability of such constructs. In particular, the presence
or absence of <tt>std::chrono::monotonic_clock</tt> may require
different code paths to be selected. This is the only
conditionally-supported library facility, and differs from the
conditionally-supported language facilities in that it has
standard-defined semantics rather than implementation-defined
semantics.
</p>

<p><i>[
Resolution proposed in ballot comment:
]</i></p>

<p>
Provide feature test macro for determining the
presence of <tt>std::chrono::monotonic_clock</tt>. Add
<tt>_STDCPP_HAS_MONOTONIC_CLOCK</tt> to the
<tt>&lt;chrono&gt;</tt> header, which is defined if
<tt>monotonic_clock</tt> is present, and not defined if it is
not present.
</p>

<p><i>[
2010-11-01 Daniel comments:
]</i></p>

<blockquote>
Paper <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3128.html">n3128</a> addresses
this issue by replacing <tt>monotonic_clock</tt> with <tt>steady_clock</tt>, which is not conditionally supported,
so there is no need to detect it.
</blockquote>



<p><b>Proposed resolution:</b></p>
This is resolved by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3191.html">n3191</a>.





<hr>
<h3><a name="1412"></a>1412. [FCD] Make monotonic clocks mandatory</h3>
<p><b>Section:</b> X [time.clock.monotonic] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> Switzerland <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#time.clock.monotonic">issues</a> in [time.clock.monotonic].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses CH-21</b></p>
<p>
Monotonic clocks are generally easy to provide on all
systems and are implicitely required by some of the library
facilities anyway.
</p>

<p><i>[
2010-11-01 Daniel comments:
]</i></p>

<blockquote>
Paper <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3128.html">n3128</a> addresses
this issue by replacing <tt>monotonic_clock</tt> with <tt>steady_clock</tt>, which is mandatory.
</blockquote>

<p><i>[
2010-11-13 Batavia meeting:
]</i></p>

<p>
This is resolved by adopting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3191.html">n3191</a>.
The original resolution is preserved for reference:
</p>
<blockquote>
<p>Make monotonic clocks mandatory.</p>
<p>Strike X [time.clock.monotonic] p.2</p>
<blockquote>
<tt>2</tt> <del>The class <tt>monotonic_clock</tt> is conditionally supported.</del>
</blockquote>

<p>Change 30.2.4 [thread.req.timing] p.2 accordingly</p>
<blockquote>
The member functions whose names end in <tt>_for</tt> take an argument that
specifies a relative time. Implementations should use a monotonic clock to
measure time for these functions. <del>[ <em>Note</em>: Implementations are not
required to use a monotonic clock because such a clock may not be available.
 <em>end note</em> ]</del>
</blockquote>
</blockquote>



<p><b>Proposed resolution:</b></p>
This is resolved by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3191.html">n3191</a>.





<hr>
<h3><a name="1414"></a>1414. [FCD] Fixing remaining dead links to <tt>POS_T</tt> and <tt>OFF_T</tt></h3>
<p><b>Section:</b> 21.2.3.2 [char.traits.specializations.char16_t] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-24</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1444">1444</a></p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-109, GB-123</b></p>

<p>
It is not clear what the specification means for
u16streampos, u32streampos or wstreampos when they
refer to the requirements for POS_T in 21.2.2, as there
are no longer any such requirements. Similarly the annex
D.7 refers to the requirements of type POS_T in 27.3 that
no longer exist either.
</p>
<p>
Clarify the meaning of all cross-reference to the
removed type POS_T.
</p>


<p><i>[
Post-Rapperswil, Daniel provides the wording.
]</i></p>


<p>
When preparing the wording for this issue I first thought about adding both <tt>u16streampos</tt> and <tt>u32streampos</tt>
to the [iostream.forward] header <tt>&lt;iosfwd&gt;</tt> synopsis similar to <tt>streampos</tt> and <tt>wstreampos</tt>,
but decided not to do so, because the IO library does not yet actively support the <tt>char16_t</tt> and <tt>char32_t</tt> 
character types. Adding those would misleadingly imply that they would be part of the iostreams. Also, the addition
would make them also similarly equal to a typedef to <tt>fpos&lt;mbstate_t&gt;</tt>, as for <tt>streampos</tt> and 
<tt>wstreampos</tt>, so there is no loss for users that would like to use the proper <tt>fpos</tt> instantiation for
these character types.
</p>
<p>
Additionally the way of referencing was chosen to follow the style suggested by NB comment 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3118.html#GB108">GB 108</a>.
</p>

<blockquote>
Moved to Tentatively Ready with proposed wording after 5 positive votes on c++std-lib.
</blockquote>

<p><i>[
Adopted at 2010-11 Batavia
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
<i>The following wording changes are against N3126.</i>
</p>

<ol>
<li>Change [char.traits.specializations.char16_t]/1 as indicated:
<blockquote><p>
1 - The type <tt>u16streampos</tt> shall be an implementation-defined type that satisfies the requirements 
for <del><tt>POS_T</tt> in 21.2.2</del><ins><tt>pos_type</tt> in [iostreams.limits.pos]</ins>.
</p></blockquote>
</li>
<li>Change [char.traits.specializations.char32_t]/1 as indicated:
<blockquote><p>
1 - The type <tt>u32streampos</tt> shall be an implementation-defined type that satisfies the requirements 
for <del><tt>POS_T</tt> in 21.2.2</del><ins><tt>pos_type</tt> in [iostreams.limits.pos]</ins>.
</p></blockquote>
</li>
<li>Change [char.traits.specializations.wchar.t]/2 as indicated:
<blockquote><p>
2 - The type <tt>wstreampos</tt> shall be an implementation-defined type that satisfies the requirements 
for <del><tt>POS_T</tt> in 21.2.2</del><ins><tt>pos_type</tt> in [iostreams.limits.pos]</ins>.
</p></blockquote>
</li>
<li>Change [fpos.operations], Table 124  Position type requirements as indicated:
<blockquote><p>
</p><table border="1">
<caption>Table 124  Position type requirements</caption>

<tbody>
<tr>
<th>Expression</th>
<th>Return type</th>
<th><tt>...</tt></th>
</tr>

<tr>
<td><tt>...</tt></td>
<td><tt>...</tt></td>
<td><tt>...</tt></td>
</tr>
<tr>
<td><tt>O(p)</tt></td>
<td><del><tt>OFF_T</tt></del><ins><tt>streamoff</tt></ins></td>
<td>...</td>
</tr>
<tr>
<td><tt>...</tt></td>
<td><tt>...</tt></td>
<td><tt>...</tt></td>
</tr>
<tr>
<td><tt>o = p - q</tt></td>
<td><del><tt>OFF_T</tt></del><ins><tt>streamoff</tt></ins></td>
<td><tt>...</tt></td>
</tr>
<tr>
<td><tt>streamsize(o)</tt><br><tt>O(sz)</tt></td>
<td><tt>streamsize</tt><br><del><tt>OFF_T</tt></del><ins><tt>streamoff</tt></ins></td>
<td><tt>...</tt></td>
</tr>

</tbody></table>
<p></p></blockquote>
</li>
<li>Change [depr.ios.members]/1 as indicated:
<p>
</p><blockquote><pre>namespace std {
 class ios_base {
 public:
   typedef T1 io_state;
   typedef T2 open_mode;
   typedef T3 seek_dir;
   typedef <del>OFF_T</del><ins><em>implementation-defined</em></ins> streamoff;
   typedef <del>POS_T</del><ins><em>implementation-defined</em></ins> streampos;
   // remainder unchanged
 };
}
</pre></blockquote>
<p></p>
</li>
<li>Change [depr.ios.members]/5+6 as indicated:
<blockquote><p>
5 - The type <tt>streamoff</tt> is an implementation-defined type that satisfies the requirements 
of <del>type <tt>OFF_T</tt> (27.5.1)</del><ins><tt>off_type</tt> in [iostreams.limits.pos]</ins>.
</p>
<p>
6 - The type <tt>streampos</tt> is an implementation-defined type that satisfies the requirements 
of <del>type <tt>POS_T</tt> (27.3)</del><ins><tt>pos_type</tt> in [iostreams.limits.pos]</ins>.
</p></blockquote>
</li>
</ol>






<hr>
<h3><a name="1416"></a>1416. [FCD] <tt>forward_list::erase_after</tt> should not be allowed to throw</h3>
<p><b>Section:</b> 23.2 [container.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> DIN <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-19</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#container.requirements">issues</a> in [container.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses DE-21</b></p>

23.2.1/11 provides a general no-throw guarantee for
erase() container functions, exceptions from this are
explicitly mentioned for individual containers. Because of
its different name, forward_list's erase_after() function is
not ruled by this but should so.

<p><i>[
Resolved in Rapperswil by a motion to directly apply the words from the ballot comment in N3102.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
Add a "<i>Throws</i>: Nothing" clause to both
<tt>erase_after</tt> overloads in 23.3.3.4, [forwardlist.modifiers].
</p>





<hr>
<h3><a name="1417"></a>1417. [FCD] <tt>front</tt>/<tt>back</tt> on a zero-sized
<tt>array</tt> should be undefined</h3>
<p><b>Section:</b> 23.3.1.7 [array.zero] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-10-26</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-112</b></p>
<p>
Should the effect of calling <tt>front</tt>/<tt>back</tt> on a zero-sized
<tt>array</tt> really be implementation defined i.e. require the
implementor to define behaviour?
</p>

<p><i>[
Resolved in Rapperswil by a motion to directly apply the words from the ballot comment in N3102.
]</i></p>




<p><b>Proposed resolution:</b></p>
Change "implementation defined" to "undefined"





<hr>
<h3><a name="1423"></a>1423. [FCD] Ballot Comment JP-6</h3>
<p><b>Section:</b> 23.6.1 [map] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Japan <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#map">issues</a> in [map].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses JP-6</b></p>

Constructor accepting an allocator as a single parameter
should be qualified as explicit.
<pre>namespace std {
template &lt;class Key, class T, class Compare =
less&lt;Key&gt;,
class Allocator = allocator&lt;pair&lt;const Key, T&gt; &gt; &gt;
class map {
public:
...
map(const Allocator&amp;);
</pre>

<p><i>[
Resolved in Rapperswil by a motion to directly apply the words from the ballot comment in N3102.
]</i></p>




<p><b>Proposed resolution:</b></p>
Add explicit.
<pre>namespace std {
template &lt;class Key, class T, class Compare =
less&lt;Key&gt;,
class Allocator = allocator&lt;pair&lt;const Key, T&gt; &gt; &gt;
class map {
public:
...
explicit map(const Allocator&amp;);
</pre>





<hr>
<h3><a name="1424"></a>1424. [FCD] Ballot Comment JP-7</h3>
<p><b>Section:</b> 23.6.2 [multimap] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Japan <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
Constructor accepting an allocator as a single parameter
should be qualified as explicit.

<p><i>[
Resolved in Rapperswil by a motion to directly apply the words from the ballot comment in N3102.
]</i></p>




<p><b>Proposed resolution:</b></p>
Add explicit.
<pre>namespace std {
template &lt;class Key, class T, class Compare =
less&lt;Key&gt;,
class Allocator = allocator&lt;pair&lt;const Key, T&gt; &gt; &gt;
class multimap {
public:
...
explicit multimap(const Allocator&amp;);
</pre>





<hr>
<h3><a name="1425"></a>1425. [FCD] Ballot Comment JP-8</h3>
<p><b>Section:</b> 23.6.3 [set] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Japan <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#set">issues</a> in [set].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses JP-8</b></p>
Constructor accepting an allocator as a single parameter
should be qualified as explicit.

<p><i>[
Resolved in Rapperswil by a motion to directly apply the words from the ballot comment in N3102.
]</i></p>




<p><b>Proposed resolution:</b></p>
Add explicit.
<pre>namespace std {
template &lt;class Key, class Compare = less&lt;Key&gt;,
class Allocator = allocator&lt;Key&gt; &gt;
class set {
public:
...
explicit set(const Allocator&amp;);
</pre>





<hr>
<h3><a name="1426"></a>1426. [FCD] Ballot Comment JP-9</h3>
<p><b>Section:</b> 23.6.4 [multiset] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Japan <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses JP-9</b></p>

Constructor accepting an allocator as a single parameter
should be qualified as explicit.

<p><i>[
Resolved in Rapperswil by a motion to directly apply the words from the ballot comment in N3102.
]</i></p>




<p><b>Proposed resolution:</b></p>
Add explicit.
<pre>namespace std {
template &lt;class Key, class Compare = less&lt;Key&gt;,
class Allocator = allocator&lt;Key&gt; &gt;
class multiset {
public:
...
explicit multiset(const Allocator&amp;);
</pre>





<hr>
<h3><a name="1427"></a>1427. [FCD] Ballot Comment JP-10</h3>
<p><b>Section:</b> 23.7.1 [unord.map] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Japan <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#unord.map">issues</a> in [unord.map].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses JP-10</b></p>

Constructor accepting an allocator as a single parameter
should be qualified as explicit.

<p><i>[
Resolved in Rapperswil by a motion to directly apply the words from the ballot comment in N3102.
]</i></p>




<p><b>Proposed resolution:</b></p>
Add explicit.
<pre>namespace std {
template &lt;class Key,
template &lt;class Key,
class T,
class Hash = hash&lt;Key&gt;,
class Pred = std::equal_to&lt;Key&gt;,
class Alloc = std::allocator&lt;std::pair&lt;const Key,
T&gt; &gt; &gt;
class unordered_map
{
public:
...
explicit unordered_map(const Allocator&amp;);
</pre>





<hr>
<h3><a name="1428"></a>1428. [FCD] Ballot Comment JP-11</h3>
<p><b>Section:</b> 23.7.2 [unord.multimap] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Japan <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses JP-11</b></p>

Constructor accepting an allocator as a single parameter
should be qualified as explicit.

<p><i>[
Resolved in Rapperswil by a motion to directly apply the words from the ballot comment in N3102.
]</i></p>




<p><b>Proposed resolution:</b></p>
Add explicit.
<pre>namespace std {
template &lt;class Key,
class T,
class Hash = hash&lt;Key&gt;,
class Pred = std::equal_to&lt;Key&gt;,
class Alloc = std::allocator&lt;std::pair&lt;const Key,
T&gt; &gt; &gt;
class unordered_multimap
{
public:
...
explicit unordered_multimap(const Allocator&amp;);
</pre>





<hr>
<h3><a name="1429"></a>1429. [FCD] Ballot Comment JP-12</h3>
<p><b>Section:</b> 23.7.3 [unord.set] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Japan <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses JP-12</b></p>

Constructor accepting an allocator as a single parameter
should be qualified as explicit.

<p><i>[
Resolved in Rapperswil by a motion to directly apply the words from the ballot comment in N3102.
]</i></p>




<p><b>Proposed resolution:</b></p>
Add explicit.
<pre>namespace std {
template &lt;class Key,
class Hash = hash&lt;Key&gt;,
class Pred = std::equal_to&lt;Key&gt;,
class Alloc = std::allocator&lt;Key&gt; &gt;
class unordered_set
{
public:
...
explicit unordered_set(const Allocator&amp;);
</pre>





<hr>
<h3><a name="1430"></a>1430. [FCD] Ballot Comment JP-13</h3>
<p><b>Section:</b> 23.7.4 [unord.multiset] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Japan <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses JP-13</b></p>

Constructor accepting an allocator as a single parameter
should be qualified as explicit.

<p><i>[
Resolved in Rapperswil by a motion to directly apply the words from the ballot comment in N3102.
]</i></p>




<p><b>Proposed resolution:</b></p>
Add explicit.
<pre>namespace std {
template &lt;class Key,
class Hash = hash&lt;Key&gt;,
class Pred = std::equal_to&lt;Key&gt;,
class Alloc = std::allocator&lt;Key&gt; &gt;
class unordered_multiset
{
public:
...
explicit unordered_multiset(const Allocator&amp;);
</pre>





<hr>
<h3><a name="1431"></a>1431. [FCD] Ballot Comment US-120</h3>
<p><b>Section:</b> 25.2.12 [alg.is_permutation] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-04</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-120</b></p>

is_permutation is underspecified for anything but the
simple case where both ranges have the same value type
and the comparison function is an equivalence relation.

<p><i>[
Resolved in Rapperswil by a motion to directly apply the words from the ballot comment in N3102.
]</i></p>




<p><b>Proposed resolution:</b></p>
Restrict is_permutation to the case where it is well
specified. See Appendix 1 - Additional Details





<hr>
<h3><a name="1432"></a>1432. [FCD] random_shuffle signatures</h3>
<p><b>Section:</b> 25.3.12 [alg.random.shuffle] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-24</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.random.shuffle">issues</a> in [alg.random.shuffle].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1433">1433</a></p>
<p><b>Discussion:</b></p>

<p><b>Addresses US-121, GB-119</b></p>

<p>
<tt>random_shuffle</tt> and <tt>shuffle</tt> should be consistent in how
they accept their source of randomness: either both by
rvalue reference or both by lvalue reference.
</p>

<p><i>[
Post-Rapperswil, Daniel provided wording
]</i></p>


<p>
The signatures of the <tt>shuffle</tt> and <tt>random_shuffle</tt> algorithms are different
in regard to the support of rvalues and lvalues of the provided generator:
</p>

<p>
</p><blockquote><pre>template&lt;class RandomAccessIterator, class RandomNumberGenerator&gt;
void random_shuffle(RandomAccessIterator first,
RandomAccessIterator last,
RandomNumberGenerator<b>&amp;&amp;</b> rand);
</pre></blockquote>
<p></p>

<p>
</p><blockquote><pre>template&lt;class RandomAccessIterator, class UniformRandomNumberGenerator&gt;
void shuffle(RandomAccessIterator first,
RandomAccessIterator last,
UniformRandomNumberGenerator<b>&amp;</b> g);
</pre></blockquote>
<p></p>

<p>
The first form uses the perfect forwarding signature and that change compared to
<tt>C++03</tt> was done intentionally as shown in the first rvalue proposal 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1690.html#Improved%20random_shuffle">papers</a>.
</p>

<p>
While it is true, that random generators are excellent examples of stateful
functors, there still exist good reasons to support rvalues as arguments:
</p>

<p>
</p><ol>
<li>If one of the shuffle algorithms is called with the intention to shuffle items with a reproducible ordering 
	from a given generator class, it makes sense to create a generator exactly at the call point.
</li>
<li>Other algorithms with similar need for stateful functors (like <tt>std::generate</tt> and <tt>std::generate_n</tt>) 
	accept both rvalues and lvalues as well.
</li>
<li>Given the deduction rules for perfect forwarding it is hard for a user to produce code that does the wrong thing 
unintentionally. Any lvalue generator will deduce an lvalue-reference and behave as in <tt>C++03</tt>. In the specific 
cases, where rvalues are provided, the argument will be accepted instead of being rejected.
</li>
</ol>
<p></p>

<p>
Arguments have been raised that accepting rvalues is error-prone or even fundamentally wrong. The author of this 
proposal disagrees with that position for two additional reasons:
</p>

<p>
</p><ol>
<li>Enforcing lvalues as arguments won't prevent user code to enforce what they
want. So given
<blockquote><pre>my_generator get_generator(int size);
</pre></blockquote>
instead of writing
<blockquote><pre>std::vector&lt;int&gt; v = ...;
std::shuffle(v.begin(), v.end(), get_generator(v.size()));
</pre></blockquote>
they will just write
<blockquote><pre>std::vector&lt;int&gt; v = ...;
auto gen = get_generator(v.size());
std::shuffle(v.begin(), v.end(), gen);
</pre></blockquote>
and feel annoyed about the need for it.
</li>
<li>Generators may be copyable and movable, and random number engines are <em>required</em> to be <tt>CopyConstructible</tt> 
and this is obviously a generally useful property for such objects. It is also useful and sometimes necessary to start a 
generator with exactly a specific seed again and again and thus to provide a new generator (or a copy) for each call. The 
<tt>CopyConstructible</tt> requirements allow providing rvalues of generators and thus this idiom must be useful as well. 
Therefore preventing <tt>[random_]shuffle</tt> to accept rvalues is an unnecessary restriction which doesn't prevent any 
user-error, if there would exist one.
</li>
</ol>
<p></p>

<p>
Thus this proposal recommends to make both <tt>shuffle</tt> functions consistent and perfectly forward-able.
</p>

<blockquote>
Moved to Tentatively Ready after 6 positive votes on c++std-lib.
</blockquote>

<p><i>[
Adopted at 2010-11 Batavia
]</i></p>




<p><b>Proposed resolution:</b></p>

<ol>
<li>Change [algorithms.general], header <tt>&lt;algorithm&gt;</tt> synopsis as indicated:
<blockquote><pre>template&lt;class RandomAccessIterator, class UniformRandomNumberGenerator&gt;
void shuffle(RandomAccessIterator first, RandomAccessIterator last,
UniformRandomNumberGenerator&amp;<ins>&amp;</ins> rand);
</pre></blockquote>
</li>
<li>Change the prototype description of [alg.random.shuffle] as indicated:
<blockquote><pre>template&lt;class RandomAccessIterator, class UniformRandomNumberGenerator&gt;
void shuffle(RandomAccessIterator first, RandomAccessIterator last,
UniformRandomNumberGenerator&amp;<ins>&amp;</ins> rand);
</pre></blockquote>
</li>
</ol>






<hr>
<h3><a name="1435"></a>1435. [FCD] Unclear returns specifications for C99 complex number functions</h3>
<p><b>Section:</b> 26.4.7 [complex.value.ops] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-24</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#complex.value.ops">issues</a> in [complex.value.ops].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-120</b></p>

The complex number functions added for compatibility
with the C99 standard library are defined purely as a
cross-reference, with no hint of what they should return.
This is distinct from the style of documentation for the
functions in the earlier standard. In the case of the
inverse-trigonometric and hyperbolic functions, a
reasonable guess of the functionality may be made from
the name, this is not true of the cproj function, which
apparently returns the projection on the Reimann Sphere.
A single line description of each function, associated with
the cross-reference, will greatly improve clarity.

<p><i>[2010-11-06 Beman provides proposed resolution wording.]</i></p>


<p><i>[
2010 Batavia: The working group concurred with the issue's Proposed Resolution
]</i></p>


<p><i>[
Adopted at 2010-11 Batavia
]</i></p>




<p><b>Proposed resolution:</b></p>

<p><i>Change 26.4.7 complex value operations [complex.value.ops] as indicated:</i></p>
<blockquote>
  <p><tt>template&lt;class T&gt; complex&lt;T&gt; proj(const complex&lt;T&gt;&amp; x);</tt></p>
  <blockquote>
    <p><ins><i>Returns:</i> the projection of <tt>x</tt> onto the Riemann 
    sphere.</ins></p>
    <p><del><i>Effects:</i></del> <ins><i>Remarks:</i></ins> Behaves the same as the C function <tt>cproj</tt>, 
    defined in 7.3.9.4.</p>
  </blockquote>
</blockquote>

<p><i>Change 26.4.8 complex transcendentals [complex.transcendentals] as indicated:</i></p>
<blockquote>
  <p><tt>template&lt;class T&gt; complex&lt;T&gt; acos(const complex&lt;T&gt;&amp; x);</tt></p>
  <blockquote>
    <p><ins><i>Returns:</i>&nbsp; the complex arc cosine  of <tt>x</tt>.</ins></p>
    <p><del><i>Effects:</i></del> <ins><i>Remarks:</i></ins> Behaves the same as the C function <tt>cacos</tt>, 
    defined in 7.3.5.1.</p>
  </blockquote>
</blockquote>

<p><i>Change 26.4.8 complex transcendentals [complex.transcendentals] as indicated:</i></p>
<blockquote>
  <p><tt>template&lt;class T&gt; complex&lt;T&gt; asin(const complex&lt;T&gt;&amp; x);</tt></p>
  <blockquote>
    <p><ins><i>Returns:</i>&nbsp; the complex arc sine  of <tt>x</tt>.</ins></p>
    <p><del><i>Effects:</i></del> <ins><i>Remarks:</i></ins> Behaves the same as the C function <tt>casin</tt>, 
    defined in 7.3.5.2.</p>
  </blockquote>
</blockquote>

<p><i>Change 26.4.8 complex transcendentals [complex.transcendentals] as indicated:</i></p>
<blockquote>
  <p><tt>template&lt;class T&gt; complex&lt;T&gt; atan(const complex&lt;T&gt;&amp; x);</tt></p>
  <blockquote>
    <p><ins><i>Returns:</i>&nbsp; the complex arc tangent  of <tt>x</tt>.</ins></p>
    <p><del><i>Effects:</i></del> <ins><i>Remarks:</i></ins> Behaves the same as the C function <tt>catan</tt>, 
    defined in 7.3.5.3.</p>
  </blockquote>
</blockquote>

<p><i>Change 26.4.8 complex transcendentals [complex.transcendentals] as indicated:</i></p>
<blockquote>
  <p><tt>template&lt;class T&gt; complex&lt;T&gt; acosh(const complex&lt;T&gt;&amp; x);</tt></p>
  <blockquote>
    <p><ins><i>Returns:</i>&nbsp; the complex arc hyperbolic cosine of
    <tt>x</tt>.</ins></p>
    <p><del><i>Effects:</i></del> <ins><i>Remarks:</i></ins> Behaves the same as the C function <tt>cacosh</tt>, 
    defined in 7.3.6.1.</p>
  </blockquote>
</blockquote>

<p><i>Change 26.4.8 complex transcendentals [complex.transcendentals] as indicated:</i></p>
<blockquote>
  <p><tt>template&lt;class T&gt; complex&lt;T&gt; asinh(const complex&lt;T&gt;&amp; x);</tt></p>
  <blockquote>
    <p><ins><i>Returns:</i>&nbsp; the complex arc hyperbolic sine  of <tt>
    x</tt>.</ins></p>
    <p><del><i>Effects:</i></del> <ins><i>Remarks:</i></ins> Behaves the same as the C function <tt>casinh</tt>, 
    defined in 7.3.6.2.</p>
  </blockquote>
</blockquote>

<p><i>Change 26.4.8 complex transcendentals [complex.transcendentals] as indicated:</i></p>
<blockquote>
  <p><tt>template&lt;class T&gt; complex&lt;T&gt; atanh(const complex&lt;T&gt;&amp; x);</tt></p>
  <blockquote>
    <p><ins><i>Returns:</i>&nbsp; the complex arc hyperbolic tangent  of
    <tt>x</tt>.</ins></p>
    <p><del><i>Effects:</i></del> <ins><i>Remarks:</i></ins> Behaves the same as the C function <tt>catanh</tt>, 
    defined in 7.3.6.2.</p>
  </blockquote>
</blockquote>







<hr>
<h3><a name="1436"></a>1436. [FCD] Random number engine constructor concerns</h3>
<p><b>Section:</b> 26.5.3 [rand.eng] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-24</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.eng">issues</a> in [rand.eng].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-121</b></p>

All the random number engine types in this clause have a
constructor taking an unsigned integer type, and a
constructor template for seed sequences. This means that
an attempt to create a random number engine seeded by
an integer literal must remember to add the appropriate
unsigned suffix to the literal, as a signed integer will
attempt to use the seed sequence template, yielding
undefined behaviour, as per 26.5.1.1p1a. It would be
helpful if at least these anticipated cases produced a
defined behaviour, either an erroneous program with
diagnostic, or a conversion to unsigned int forwarding to
the appropriate constructor.

<p><i>[
2010-11-03 Daniel comments and provides a proposed resolution:
]</i></p>


<p>
I suggest to apply a similar solution as recently suggested for <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1234">1234</a>.
It is basically a requirement for an implementation to constrain the template.
</p>

<p><i>[
2010-11-04 Howard suggests to use <tt>!is_convertible&lt;Sseq, result_type&gt;::value</tt>
as minimum requirement instead of the originally proposed <tt>!is_scalar&lt;Sseq&gt;::value</tt>.
This would allow for a user-defined type <tt>BigNum</tt>, that is convertible to <tt>result_type</tt>,
to be used as argument for a seed instead of a seed sequence. The wording has been updated to 
reflect this suggestion.
]</i></p>


<p><i>[
2010 Batavia: There were some initial concerns regarding the portability and reproducibility of results 
when seeded with a negative signed value, but these concerns were allayed after discussion. Thus, after
reviewing the issue, the working group concurred with the issue's Proposed Resolution. 
]</i></p>


<p><i>[
Adopted at 2010-11 Batavia
]</i></p>




<p><b>Proposed resolution:</b></p>
Add the following paragraph at the end of 26.5.3 [rand.eng]:
<blockquote>
<blockquote>
5 Each template specified in this section [rand.eng] requires one or more relationships, involving the value(s) of
its non-type template parameter(s), to hold. A program instantiating any of these templates is ill-formed if
any such required relationship fails to hold.
</blockquote>

<blockquote>
<ins>? For every random number engine and for every random number engine adaptor <tt>X</tt> defined in this sub-clause 
[rand.eng] and in sub-clause [rand.adapt]:</ins>
<ul>
<li><ins>If the constructor</ins>
<blockquote><pre><ins>template&lt;class Sseq&gt; explicit X(Sseq&amp; q);</ins>
</pre></blockquote>
<ins>is called with a type <tt>Sseq</tt> that does not qualify as a seed sequence, then this constructor 
shall not participate in overload resolution.
</ins>
</li>
<li><ins>If the member function</ins>
<blockquote><pre><ins>template&lt;class Sseq&gt; void seed(Sseq&amp; q);</ins>
</pre></blockquote>
<ins>is called with a type <tt>Sseq</tt> that does not qualify as a seed sequence, then this function 
shall not participate in overload resolution.
</ins>
</li>
</ul>
<ins>The extent to which an implementation determines that a type cannot be a seed sequence is unspecified,
except that as a minimum a type shall not qualify as seed sequence, if it is implicitly convertible
to <tt>X::result_type</tt>.</ins>
</blockquote>

</blockquote>





<hr>
<h3><a name="1437"></a>1437. [FCD] Mersenne twister meaningless for word sizes less than two</h3>
<p><b>Section:</b> 26.5.3.2 [rand.eng.mers] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-24</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.eng.mers">issues</a> in [rand.eng.mers].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-124</b></p>

The Mersenne twister algorithm is meaningless for word
sizes less than two, as there are then insufficient bits
available to be twisted.

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<blockquote>
Insert the following among the relations that are required to hold: <tt>2u &lt; w</tt>.
</blockquote>

<p><i>[
2010 Batavia: The working group concurred with the issue's Proposed Resolution
]</i></p>


<p><i>[
Adopted at 2010-11 Batavia
]</i></p>




<p><b>Proposed resolution:</b></p>
Change 26.5.3.2 [rand.eng.mers] p. 4 as indicated:
<p>
</p><blockquote>
4 The following relations shall hold: <tt>0 &lt; m</tt>, <tt>m &lt;= n</tt>, <ins><tt>2u &lt; w</tt>,</ins>
<tt>r &lt;= w</tt>, <tt>u &lt;= w</tt>, <tt>s &lt;= w</tt>, <tt>t &lt;= w</tt>, 
<tt>l &lt;= w</tt>, <tt>w &lt;= numeric_limits&lt;UIntType&gt;::digits</tt>, 
<tt>a &lt;= (1u&lt;&lt;w) - 1u</tt>, <tt>b &lt;= (1u&lt;&lt;w) - 1u</tt>, 
<tt>c &lt;= (1u&lt;&lt;w) - 1u</tt>, <tt>d &lt;= (1u&lt;&lt;w) - 1u</tt>, 
and <tt>f &lt;= (1u&lt;&lt;w) - 1u</tt>.
</blockquote>





<hr>
<h3><a name="1439"></a>1439. [FCD] Return from <tt>densities()</tt> functions?</h3>
<p><b>Section:</b> 26.5.8.5.2 [rand.dist.samp.pconst] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-24</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.dist.samp.pconst">issues</a> in [rand.dist.samp.pconst].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-134</b></p>

These two distributions have a member function called
<tt>densities()</tt> which returns a <tt>vector&lt;double&gt;</tt>. The
distribution is templated on <tt>RealType</tt>. The distribution
also has another member called <tt>intervals()</tt> which returns
a <tt>vector&lt;RealType&gt;</tt>. Why doesn't densities return
<tt>vector&lt;RealType&gt;</tt> as well? If <tt>RealType</tt> is <tt>long double</tt>,
the computed densities property isn't being computed to
the precision the client desires. If <tt>RealType</tt> is <tt>float</tt>, the
densities vector is taking up twice as much space as the client desires.

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<blockquote>
Change the piecewise constant and linear
distributions to hold / return the densities in a
<tt>vector&lt;result_type&gt;</tt>.
<p>
If this is not done, at least correct 26.5.8.5.2 [rand.dist.samp.pconst] p. 13 which describes
the return of densities as a <tt>vector&lt;result_type&gt;</tt>.
</p></blockquote>

<p><i>[
Batavia 2010: After reviewing this issue, the working group concurred with the first of the 
suggestions proposed by the NB comment: "Change the piecewise constant and linear distributions 
to hold / return the densities in a vector. "
]</i></p>


<p><i>[
Adopted at 2010-11 Batavia
]</i></p>




<p><b>Proposed resolution:</b></p>
<ol>
<li>Change 26.5.8.5.2 [rand.dist.samp.pconst] p. 2, class template <tt>piecewise_constant_distribution</tt> synopsis
and the prototype description 26.5.8.5.2 [rand.dist.samp.pconst] before p. 13 as indicated:
<blockquote><pre>vector&lt;<del>double</del><ins>result_type</ins>&gt; densities() const;
</pre></blockquote>
</li>

<li>Change 26.5.8.5.3 [rand.dist.samp.plinear] p. 2, class template <tt>piecewise_linear_distribution</tt> synopsis
and the prototype description 26.5.8.5.3 [rand.dist.samp.plinear] before p. 13 as indicated:
<blockquote><pre>vector&lt;<del>double</del><ins>result_type</ins>&gt; densities() const;
</pre></blockquote>
</li>
</ol>





<hr>
<h3><a name="1440"></a>1440. [FCD] Incorrect specification for rand.dist.samp.plinear</h3>
<p><b>Section:</b> 26.5.8.5.3 [rand.dist.samp.plinear] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-24</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-135</b></p>

This paragraph says: Let bk = xmin+k&#948; for k = 0,...,n,
and wk = fw(bk +&#948;) for k = 0,...,n.
However I believe that fw(bk) would be far more desirable.
I strongly suspect that this is nothing but a type-o.

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<blockquote>
Change p. 10 to read:<br>
Let bk = xmin+k&#948; for k = 0,...,n, and wk = fw(bk)
for k = 0,...,n.
</blockquote>

<p><i>[
2010-11-02 Daniel translates into a proposed resolution
]</i></p>


<p><i>[
2010 Batavia: The working group concurred with the issue's Proposed Resolution
]</i></p>


<p><i>[
Adopted at 2010-11 Batavia
]</i></p>




<p><b>Proposed resolution:</b></p>
Change 26.5.8.5.3 [rand.dist.samp.plinear] p. 10 as indicated:
<blockquote>
10 <em>Effects</em>: Constructs a <tt>piecewise_linear_distribution</tt> object with parameters taken or calculated
from the following values: Let <tt><em>b<sub>k</sub></em> = xmin+<em>k</em>&#948;</tt> for 
<tt><em>k</em> = 0, . . . , <em>n</em></tt>, and <tt><em>w<sub>k</sub></em> = fw(<em>b</em><sub><em>k</em></sub><del> +&#948;</del>)</tt> 
for <tt><em>k</em> = 0, . . . , <em>n</em></tt>.</blockquote>





<hr>
<h3><a name="1441"></a>1441. [FCD] Floating-point test functions are incorrectly specified</h3>
<p><b>Section:</b> 26.8 [c.math] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-04</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#c.math">issues</a> in [c.math].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-136</b></p>

Floating-point test functions are incorrectly specified.

<p><i>[
Resolved in Rapperswil by a motion to directly apply the words from the ballot comment in N3102.
]</i></p>




<p><b>Proposed resolution:</b></p>
See Appendix 1 - Additional Details





<hr>
<h3><a name="1445"></a>1445. [FCD] Several iostreams member functions incorrectly specified</h3>
<p><b>Section:</b> 27.7 [iostream.format] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> INCITS/PJ Plauger <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#iostream.format">issues</a> in [iostream.format].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-137</b></p>

Several iostreams member functions are incorrectly
specified.

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<p>
See Appendix 1 - Additional Details
</p>

<p><i>[
2010-10-24 Daniel adds:
]</i></p>


<blockquote>
Accepting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3168.htm">n3168</a> would solve this issue.
</blockquote>



<p><b>Proposed resolution:</b></p>
Addressed by paper <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3168.htm">n3168</a>.





<hr>
<h3><a name="1447"></a>1447. [FCD] Request to resolve issue LWG 1328</h3>
<p><b>Section:</b> 27.7 [iostream.format] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#iostream.format">issues</a> in [iostream.format].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-139</b></p>

Resolve issue LWG 1328 one way or the other, but
preferably in the direction outlined in the proposed
resolution, which, however, is not complete as-is: in any
case, the sentry must not set ok_ = false if is.good() ==
false, otherwise istream::seekg, being an unformatted
input function, does not take any action because the
sentry object returns false when converted to type bool.
Thus, it remains impossible to seek away from end of file.


<p><b>Proposed resolution:</b></p>
Addressed by paper <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3168.htm">n3168</a>.





<hr>
<h3><a name="1449"></a>1449. [FCD] Incomplete specification of header <tt>&lt;cinttypes&gt;</tt></h3>
<p><b>Section:</b> 27.8.2 [istringstream] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Canada <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-24</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses CA-4</b></p>

Subclause 27.9.2 [c.files] specifies that &lt;cinttypes&gt; has
declarations for abs() and div(); however, the signatures
are not present in this subclause. The signatures
proposed under TR1 ([tr.c99.inttypes]) are not present in
FCD (unless if intmax_t happened to be long long). It is
unclear as to which, if any of the abs() and div() functions
in [c.math] are meant to be declared by &lt;cinttypes&gt;. This
subclause mentions imaxabs() and imaxdiv(). These
functions, among other things, are not specified in FCD to
be the functions from Subclause 7.8 of the C Standard.
Finally, &lt;cinttypes&gt; is not specified in FCD to include
&lt;cstdint&gt; (whereas &lt;inttypes.h&gt; includes &lt;stdint.h&gt; in C).

<p><i>[
Post-Rapperswil, Daniel provides wording
]</i></p>


<p>
Subclause [c.files] specifies that <tt>&lt;cinttypes&gt;</tt> has declarations for <tt>abs()</tt> and <tt>div()</tt>; 
however, the signatures are not present in this subclause. The signatures proposed under TR1 ([tr.c99.inttypes]) are not 
present in FCD (unless if <tt>intmax_t</tt> happened to be <tt>long long</tt>). It is unclear as to which, if any of the 
<tt>abs()</tt> and <tt>div()</tt> functions in [c.math] are meant to be declared by <tt>&lt;cinttypes&gt;</tt>. This
subclause mentions <tt>imaxabs()</tt> and <tt>imaxdiv()</tt>. These functions, among other things, are not specified in 
FCD to be the functions from subclause 7.8 of the <tt>C</tt> Standard. Finally, <tt>&lt;cinttypes&gt;</tt> is not specified 
in FCD to include <tt>&lt;cstdint&gt;</tt> (whereas <tt>&lt;inttypes.h&gt;</tt> includes <tt>&lt;stdint.h&gt;</tt> in <tt>C</tt>).
</p>

<blockquote>
Moved to Tentatively Ready with proposed wording after 5 positive votes on c++std-lib.
</blockquote>

<p><i>[
Adopted at 2010-11 Batavia
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
<i>The wording refers to N3126.</i>
</p>
<ol>
<li>Add the following series of new paragraphs following [c.files] p.1:
<blockquote>
Table 132 describes header <tt>&lt;cinttypes&gt;</tt>. [<em>Note</em>: The macros defined by <tt>&lt;cinttypes&gt;</tt> are provided unconditionally.
In particular, the symbol <tt>__STDC_FORMAT_MACROS</tt>, mentioned in footnote 182 of the <tt>C</tt> standard, plays no role in <tt>C++</tt>. 
 <em>end note</em> ]
<p>
<ins>2 - The contents of header <tt>&lt;cinttypes&gt;</tt> are the same as the Standard <tt>C</tt> library header <tt>&lt;inttypes.h&gt;</tt>, 
with the following changes:</ins>
</p>
<p>
<ins>3 - The header <tt>&lt;cinttypes&gt;</tt> includes the header <tt>&lt;cstdint&gt;</tt> instead of <tt>&lt;stdint.h&gt;</tt>.</ins>
</p>
<p>
<ins>4 - If and only if the type <tt>intmax_t</tt> designates an extended integer type ([basic.fundamental]), the following function 
signatures are added:
</ins></p><blockquote><pre><ins>intmax_t abs(intmax_t);</ins>
<ins>imaxdiv_t div(intmax_t, intmax_t);</ins>
</pre></blockquote>
<ins>which shall have the same semantics as the function signatures <tt>intmax_t imaxabs(intmax_t)</tt> and 
<tt>imaxdiv_t imaxdiv(intmax_t, intmax_t)</tt>, respectively.</ins>

<p></p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="1453"></a>1453. [FCD] Default constructed match_results behavior for certain operations </h3>
<p><b>Section:</b> 28.10.4 [re.results.acc] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#re.results.acc">issues</a> in [re.results.acc].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-126</b></p>

It's unclear how match_results should behave if it has
been default-constructed. The sub_match objects
returned by operator[], prefix and suffix cannot point to the
end of the sequence that was searched if no search was
done. The iterators held by unmatched sub_match objects
might be singular.

<p><i>[
Resolution proposed by ballot comment:
]</i></p>


<blockquote>
Add to match_results::operator[],
match_results::prefix and match_results::suffix:<br>
Requires: !empty()
</blockquote>

<p><i>[
2010-10-24 Daniel adds:
]</i></p>


<blockquote>
Accepting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3158.html">n3158</a> would solve this issue.
</blockquote>



<p><b>Proposed resolution:</b></p>
Addressed by paper <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3158.html">n3158</a>.





<hr>
<h3><a name="1455"></a>1455. [FCD] C language compatibility for atomics</h3>
<p><b>Section:</b> 29 [atomics] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> Switzerland <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-26</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#atomics">active issues</a> in [atomics].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#atomics">issues</a> in [atomics].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1454">1454</a></p>
<p><b>Discussion:</b></p>
<p><b>Addresses CH-22, GB-128</b></p>
<p>
WG14 currently plans to introduce atomic facilities that are
intended to be compatible with the facilities of clause 29.
They should be compatible.
</p>

<p><i>[
Resolution proposed by ballot comment
]</i></p>

<p>
Make sure the headers in clause 29 are defined in
a way that is compatible with the planned C
standard.
</p>

<p><i>[
2010 Batavia
]</i></p>

<p>
Resolved by adoption of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3193.html">n3193</a>.
</p>


<p><b>Proposed resolution:</b></p>
Solved by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3193.html">n3193</a>.





<hr>
<h3><a name="1462"></a>1462. [FCD] Ambiguous value assignment to <tt>atomic_bool</tt></h3>
<p><b>Section:</b> 29.5.1 [atomics.types.integral] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#atomics.types.integral">issues</a> in [atomics.types.integral].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1463">1463</a></p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-132, US-157</b></p>

The <tt>atomic_<em>itype</em></tt> types and <tt>atomic_address</tt> have two
overloads of <tt>operator=</tt>; one is <tt>volatile</tt> qualified, and the
other is not. <tt>atomic_bool</tt> only has the <tt>volatile</tt> qualified
version:
<pre><blockquote>
bool operator=(bool) volatile;
</blockquote></pre>
On a non-<tt>volatile</tt>-qualified object this is ambiguous with
the deleted copy-assignment operator
<pre><blockquote>
atomic_bool&amp; operator=(atomic_bool const&amp;) = delete;
</blockquote></pre>
due to the need for a single standard conversion in each
case when assigning a bool to an <tt>atomic_bool</tt> as in:
<pre><blockquote>
atomic_bool b;
b = true;
</blockquote></pre>
The conversions are: 
<pre><blockquote>
atomic_bool&amp; &#8594; atomic_bool volatile&amp;
</blockquote></pre>
 vs 
<pre><blockquote>
bool &#8594; atomic_bool
</blockquote></pre>

<p><i>[
Proposed resolution as of NB comment:
]</i></p>


<p>
Change 29.5.1 [atomics.types.integral] as indicated:

</p><blockquote><pre>namespace std {
  typedef struct atomic_bool {
    [..]
    bool operator=(bool) volatile;
    <ins>bool operator=(bool);</ins>
  } atomic_bool;
  [..]
}
</pre></blockquote>
<p></p>

<p><i>[
2010-10-27 Daniel adds:
]</i></p>


<blockquote>
Accepting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3164.html">n3164</a> would solve this issue
by replacing <tt>atomic_bool</tt> by <tt>atomic&lt;bool&gt;</tt>.
</blockquote>

<p><i>[
2010 Batavia
]</i></p>

<p>
Resolved by adoption of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3193.html">n3193</a>.
</p>


<p><b>Proposed resolution:</b></p>
Solved by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3193.html">n3193</a>.





<hr>
<h3><a name="1464"></a>1464. [FCD] Underspecified typedefs for atomic integral types</h3>
<p><b>Section:</b> 29.5.1 [atomics.types.integral] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#atomics.types.integral">issues</a> in [atomics.types.integral].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-160</b></p>

The last sentence of 29.5.1 [atomics.types.integral] p.1 says:
<blockquote><p>
Table 143 shows typedefs to atomic integral classes and the corresponding <tt>&lt;cstdint&gt;</tt> typedefs.
</p></blockquote>
That's nice, but nothing says these are supposed to be part of the implementation, and
they are not listed in the synopsis.

<p><i>[
Proposed resolution as of NB comment
]</i></p>


<p>
</p><ol>
<li>Remove Table 143  Atomics for standard typedef types.
<p>
</p>
</li>
<li>Change 29.5.1 [atomics.types.integral] p.1 as indicated:
<blockquote><p>
1 The name <tt>atomic_<em>itype</em></tt> and the functions operating on it in the preceding synopsis are placeholders for a
set of classes and functions. Throughout the preceding synopsis, <tt>atomic_<em>itype</em></tt> should be replaced by each
of the class names in Table 142 and integral should be replaced by the integral type corresponding to the
class name. <del>Table 143 shows typedefs to atomic integral classes and the corresponding <tt>&lt;cstdint&gt;</tt> typedefs.</del>
</p></blockquote>
</li>
</ol>
<p></p>

<p><i>[
2010-10-27 Daniel adds:
]</i></p>


<blockquote>
Accepting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3164.html">n3164</a> would solve this issue.
</blockquote>

<p><i>[
2010-11 Batavia
]</i></p>

<p>
Resolved by adopting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3193.html">n3193</a>.
</p>



<p><b>Proposed resolution:</b></p>
Solved by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3193.html">n3193</a>.





<hr>
<h3><a name="1465"></a>1465. [FCD] Missing arithmetic operators for <tt>atomic_address</tt></h3>
<p><b>Section:</b> 29.5.2 [atomics.types.address] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#atomics.types.address">issues</a> in [atomics.types.address].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-161</b></p>

<tt>atomic_address</tt> has <tt>operator+=</tt> and <tt>operator-=</tt>, but no
<tt>operator++</tt> or <tt>operator--</tt>. The template specialization
<tt>atomic&lt;Ty*&gt;</tt> has all of them.

<p><i>[
2010-10-27 Daniel adds:
]</i></p>


<blockquote>
Accepting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3164.html">n3164</a> would solve this issue by
replacing <tt>atomic_address</tt> by <tt>atomic&lt;void*&gt;</tt>.
</blockquote>

<p><i>[
Resolved in Batavia by accepting 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3193.html">n3193</a>.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>Change 29.5.2 [atomics.types.address], class <tt>atomic_address</tt> synopsis, as indicated:
</p><blockquote><pre>namespace std {
  typedef struct atomic_address {
    [..]
    void* operator=(const void*) volatile;
    void* operator=(const void*);
    <ins>void* operator++(int) volatile;</ins>
    <ins>void* operator++(int);</ins>
    <ins>void* operator--(int) volatile;</ins>
    <ins>void* operator--(int);</ins>
    <ins>void* operator++() volatile;</ins>
    <ins>void* operator++();</ins>
    <ins>void* operator--() volatile;</ins>
    <ins>void* operator--();</ins>
    void* operator+=(ptrdiff_t) volatile;
    void* operator+=(ptrdiff_t);
    void* operator-=(ptrdiff_t) volatile;
    void* operator-=(ptrdiff_t);
  } atomic_address;
  [..]
}
</pre></blockquote>
<p></p>






<hr>
<h3><a name="1466"></a>1466. [FCD] Silent <tt>const</tt> breakage by <tt>compare_exchange_*</tt> member functions</h3>
<p><b>Section:</b> 29.5.2 [atomics.types.address] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#atomics.types.address">issues</a> in [atomics.types.address].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-162</b></p>

The <tt>compare_exchange_weak</tt> and <tt>compare_exchange_strong</tt> member functions that take
<tt>const void*</tt> arguments lead to a silent removal of <tt>const</tt>, because the <tt>load</tt> 
member function and other acessors return the stored value as a <tt>void*</tt>.

<p><i>[
Proposed resolution as of NB comment:
]</i></p>


<p>
Change 29.5.2 [atomics.types.address], class <tt>atomic_address</tt> synopsis, as indicated:

</p><blockquote><pre>namespace std {
  typedef struct atomic_address {
    [..]
    <del>bool compare_exchange_weak(const void*&amp;, const void*,
      memory_order, memory_order) volatile;</del>
    <del>bool compare_exchange_weak(const void*&amp;, const void*,
      memory_order, memory_order);</del>
    <del>bool compare_exchange_strong(const void*&amp;, const void*,
      memory_order, memory_order) volatile;</del>
    <del>bool compare_exchange_strong(const void*&amp;, const void*,
      memory_order, memory_order);</del>
    <del>bool compare_exchange_weak(const void*&amp;, const void*,
      memory_order = memory_order_seq_cst) volatile;</del>
    <del>bool compare_exchange_weak(const void*&amp;, const void*,
      memory_order = memory_order_seq_cst);</del>
    <del>bool compare_exchange_strong(const void*&amp;, const void*,
      memory_order = memory_order_seq_cst) volatile;</del>
    <del>bool compare_exchange_strong(const void*&amp;, const void*,
      memory_order = memory_order_seq_cst);</del>
    [..]
  } atomic_address;
  [..]
}
</pre></blockquote>

<p></p>

<p><i>[
2010-10-27 Daniel adds:
]</i></p>


<blockquote>
Accepting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3164.html">n3164</a> 
would solve this issue by replacing <tt>atomic_address</tt> by <tt>atomic&lt;void*&gt;</tt>.
</blockquote>

<p><i>[
Resolved in Batavia by accepting 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3193.html">n3193</a>.
]</i></p>




<p><b>Proposed resolution:</b></p>
Solved by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3193.html">n3193</a>.





<hr>
<h3><a name="1467"></a>1467. [FCD] Deriving <tt>atomic&lt;T*&gt;</tt> from <tt>atomic_address</tt> breaks type safety</h3>
<p><b>Section:</b> 29.5.2 [atomics.types.address] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#atomics.types.address">issues</a> in [atomics.types.address].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-163</b></p>

Requiring <tt>atomic&lt;T*&gt;</tt> to be derived from <tt>atomic_address</tt> breaks type safety:
<blockquote><pre>atomic&lt;double*&gt; ip;
char ch;
atomic_store(&amp;ip, &amp;ch);
*ip.load() = 3.14159;
</pre></blockquote>
The last line overwrites <tt>ch</tt> with a value of type <tt>double</tt>.

<p><i>[
2010-10-27 Daniel adds:
]</i></p>


<blockquote>
<p>
Resolving this issue will also solve <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1469">1469</a>
</p>
Accepting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3164.html">n3164</a> would solve this issue by
removing <tt>atomic_address</tt>.
</blockquote>
<p><i>[
Resolved in Batavia by accepting 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3193.html">n3193</a>.
]</i></p>



<p><b>Proposed resolution:</b></p>
<ol>
<li>Change 29.5 [atomics.types.generic], class template specialization <tt>atomic&lt;T*&gt;</tt> synopsis, as indicated:
<blockquote><pre>namespace std {
  template &lt;class T&gt; struct atomic&lt;T*&gt; <del>: atomic_address</del> {
    [..]
  };
  [..]
}
</pre></blockquote>
</li>
<li>Change 29.5 [atomics.types.generic] p. 4 as indicated:
<p></p><blockquote>
4 There are pointer partial specializations on the <tt>atomic</tt> class template. <del>These specializations shall be publicly
derived from <tt>atomic_address</tt>.</del> The unit of addition/subtraction for these specializations shall be the size
of the referenced type. These specializations shall have trivial default constructors and trivial destructors.
</blockquote><p></p>
</li>
</ol>






<hr>
<h3><a name="1468"></a>1468. [FCD] <tt>atomic_address::compare_exchange_*</tt> member functions should match <tt>atomic_compare_exchange_*</tt> free functions</h3>
<p><b>Section:</b> 29.5.2 [atomics.types.address] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#atomics.types.address">issues</a> in [atomics.types.address].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-164</b></p>

<tt>atomic_address</tt> has member functions <tt>compare_exchange_weak</tt> and
<tt>compare_exchange_strong</tt> that take arguments of type <tt>const void*</tt>, 
in addition to the <tt>void*</tt> versions. If these member functions survive, 
there should be corresponding free functions.

<p><i>[
2010-10-27 Daniel adds:
]</i></p>


<blockquote>
Accepting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3164.html">n3164</a> would solve this issue 
differently by removing the overloads with <tt>const void*</tt> arguments, because they break type-safety.
</blockquote>
<p><i>[
Resolved in Batavia by accepting 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3193.html">n3193</a>.
]</i></p>



<p><b>Proposed resolution:</b></p>
Extend the synopsis around <tt>atomic_address</tt> in 29.5.2 [atomics.types.address]
as indicated:
<blockquote><pre>namespace std {
  [..]
  bool atomic_compare_exchange_weak(volatile atomic_address*, void**, void*);
  bool atomic_compare_exchange_weak(atomic_address*, void**, void*);
  bool atomic_compare_exchange_strong(volatile atomic_address*, void**, void*);
  bool atomic_compare_exchange_strong(atomic_address*, void**, void*);
  bool atomic_compare_exchange_weak_explicit(volatile atomic_address*, void**, void*,
    memory_order, memory_order);
  bool atomic_compare_exchange_weak_explicit(atomic_address*, void**, void*,
    memory_order, memory_order);
  bool atomic_compare_exchange_strong_explicit(volatile atomic_address*, void**, void*,
    memory_order, memory_order);
  bool atomic_compare_exchange_strong_explicit(atomic_address*, void**, void*,
    memory_order, memory_order);
  <ins>bool atomic_compare_exchange_weak(volatile atomic_address*, const void**, const void*);</ins>
  <ins>bool atomic_compare_exchange_weak(atomic_address*, const void**, const void*);</ins>
  <ins>bool atomic_compare_exchange_strong(volatile atomic_address*, const void**, const void*);</ins>
  <ins>bool atomic_compare_exchange_strong(atomic_address*, const void**, const void*);</ins>
  <ins>bool atomic_compare_exchange_weak_explicit(volatile atomic_address*, const void**, const void*,
    memory_order, memory_order);</ins>
  <ins>bool atomic_compare_exchange_weak_explicit(atomic_address*, const void**, const void*,
    memory_order, memory_order);</ins>
  <ins>bool atomic_compare_exchange_strong_explicit(volatile atomic_address*, const void**, const void*,
    memory_order, memory_order);</ins>
  <ins>bool atomic_compare_exchange_strong_explicit(volatile atomic_address*, const void**, const void*,
    memory_order, memory_order);</ins>
  <ins>bool atomic_compare_exchange_strong_explicit(atomic_address*, const void**, const void*,
    memory_order, memory_order);</ins>
  [..]
}
</pre></blockquote>






<hr>
<h3><a name="1469"></a>1469. [FCD] <tt>atomic&lt;T*&gt;</tt> inheritance from <tt>atomic_address</tt> breaks type safety</h3>
<p><b>Section:</b> 29.5 [atomics.types.generic] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#atomics.types.generic">issues</a> in [atomics.types.generic].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-133</b></p>

The free functions that operate on <tt>atomic_address</tt> can be
used to store a pointer to an unrelated type in an <tt>atomic&lt;T*&gt;</tt> 
without a cast. e.g.
<blockquote><pre>int i;
atomic&lt;int*&gt; ai(&amp;i);
string s;
atomic_store(&amp;ai,&amp;s);
</pre></blockquote>
Overload the <tt>atomic_store</tt>, <tt>atomic_exchange</tt> and
<tt>atomic_compare_exchange_[weak/strong]</tt> operations for 
<tt>atomic&lt;T*&gt;</tt> to allow storing only pointers to <tt>T</tt>.

<p><i>[
2010-10-27 Daniel adds:
]</i></p>


<blockquote>
<p>
Resolving this issue will also solve <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1467">1467</a>
</p>
Accepting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3164.html">n3164</a> would solve this issue by
removing <tt>atomic_address</tt>.
</blockquote>

<p><i>[Resolved in Batavia by accepting
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3193.html">n3193</a>.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>Add the following overloads to 29.5 [atomics.types.generic], the synopsis around the specialization
<tt>atomic&lt;T*&gt;</tt>, as indicated:
</p><blockquote><pre>namespace std {
  [..]
  template &lt;class T&gt; struct atomic&lt;T*&gt; : atomic_address {
    [..]
  };

  <ins>template&lt;typename T&gt;</ins>
  <ins>void atomic_store(atomic&lt;T*&gt;&amp;,T*);</ins>
  <ins>template&lt;typename T&gt;</ins>
  <ins>void atomic_store(atomic&lt;T*&gt;&amp;,void*) = delete;</ins>
  <ins>template&lt;typename T&gt;</ins>
  <ins>void atomic_store_explicit(atomic&lt;T*&gt;&amp;,T*,memory_order);</ins>
  <ins>template&lt;typename T&gt;</ins>
  <ins>void atomic_store_explicit(atomic&lt;T*&gt;&amp;,void*,memory_order) = delete;</ins>
  <ins>template&lt;typename T&gt;</ins>
  <ins>T* atomic_exchange(atomic&lt;T*&gt;&amp;,T*);</ins>
  <ins>template&lt;typename T&gt;</ins>
  <ins>T* atomic_exchange(atomic&lt;T*&gt;&amp;,void*) = delete;</ins>
  <ins>template&lt;typename T&gt;</ins>
  <ins>T* atomic_exchange_explicit(atomic&lt;T*&gt;&amp;,T*,memory_order);</ins>
  <ins>template&lt;typename T&gt;</ins>
  <ins>T* atomic_exchange_explicit(atomic&lt;T*&gt;&amp;,void*,memory_order) = delete;</ins>
  <ins>template&lt;typename T&gt;</ins>
  <ins>T* atomic_compare_exchange_weak(atomic&lt;T*&gt;&amp;,T**,T*);</ins>
  <ins>template&lt;typename T&gt;</ins>
  <ins>T* atomic_compare_exchange_weak(atomic&lt;T*&gt;&amp;,void**,void*) = delete;</ins>
  <ins>template&lt;typename T&gt;</ins>
  <ins>T* atomic_compare_exchange_weak_explicit(atomic&lt;T*&gt;&amp;,T**,T*,memory_order);</ins>
  <ins>template&lt;typename T&gt;</ins>
  <ins>T* atomic_compare_exchange_weak_explicit(atomic&lt;T*&gt;&amp;,void**,void*,memory_order) = delete;</ins>
  <ins>template&lt;typename T&gt;</ins>
  <ins>T* atomic_compare_exchange_strong(atomic&lt;T*&gt;&amp;,T**,T*);</ins>
  <ins>template&lt;typename T&gt;</ins>
  <ins>T* atomic_compare_exchange_strong(atomic&lt;T*&gt;&amp;,void**,void*) = delete;</ins>
  <ins>template&lt;typename T&gt;</ins>
  <ins>T* atomic_compare_exchange_strong_explicit(atomic&lt;T*&gt;&amp;,T**,T*,memory_order);</ins>
  <ins>template&lt;typename T&gt;</ins>
  <ins>T* atomic_compare_exchange_strong_explicit(atomic&lt;T*&gt;&amp;,void**,void*,memory_order) = delete;</ins>

}
</pre></blockquote>
<p></p>





<hr>
<h3><a name="1481"></a>1481. [FCD] Missing Lockable requirements</h3>
<p><b>Section:</b> 30.2 [thread.req] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-26</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-138</b></p>

The FCD combines the requirements for lockable objects
with those for the standard mutex objects. These should
be separate. This is LWG issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1268">1268</a>.

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<blockquote>
See attached Appendix 1 - Additional Details
</blockquote>

<p><i>[
2010-11-01 Daniel comments:
]</i></p>

<blockquote>
Paper <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3130.html">n3130</a> addresses
this issue.
</blockquote>



<p><b>Proposed resolution:</b></p>
Resolved by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3197.html">n3197</a>.





<hr>
<h3><a name="1482"></a>1482. [FCD] Timeout operations are under-specified</h3>
<p><b>Section:</b> 30.2.4 [thread.req.timing] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.req.timing">issues</a> in [thread.req.timing].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-181</b></p>

The timeout operations are under-specified.

<p><i>[
Resolution proposed by ballot comment:
]</i></p>


<blockquote>
Define precise semantics for <tt>timeout_until</tt> and <tt>timeout_for</tt>. See 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3141.pdf">n3141</a> page 193 - Appendix 1 - Additional Details
</blockquote>

<p><i>[
2010-11-01 Daniel comments:
]</i></p>


<blockquote>
Accepting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3128.html">n3128</a> would solve this issue.
</blockquote>


<p><b>Proposed resolution:</b></p>
Resolved by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3128.html">n3191</a>.





<hr>
<h3><a name="1490"></a>1490. [FCD] Mutex requirements too stringent</h3>
<p><b>Section:</b> 30.4.1 [thread.mutex.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> Switzerland <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.mutex.requirements">issues</a> in [thread.mutex.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses CH-27</b></p>

The mutex requirements force <tt>try_lock</tt> to be
<tt>noexcept(true)</tt>. However, where they are used by the
generic algorithms, those relax this requirement and say
that <tt>try_lock</tt> may throw. This means the requirement is
too stringent, also a non-throwing <tt>try_lock</tt> does not allow
for a diagnostic such as <tt>system_error</tt> that <tt>lock()</tt> 
will give us.

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<blockquote>
delete p18, adjust 30.4.4 p1 and p4 accordingly
</blockquote>

<p><i>[
2010-11-01 Daniel comments:
]</i></p>


<blockquote>
Accepting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3130.html">n3130</a> would solve this issue.
</blockquote>


<p><b>Proposed resolution:</b></p>
Resolved by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3197.html">n3197</a>.





<hr>
<h3><a name="1491"></a>1491. [FCD] <tt>try_lock</tt> does not guarantee forward progress</h3>
<p><b>Section:</b> 30.4.1 [thread.mutex.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.mutex.requirements">issues</a> in [thread.mutex.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-186</b></p>

<tt>try_lock</tt> does not provide a guarantee of forward progress
because it is allowed to spuriously fail.

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<blockquote>
The standard mutex types must not fail spuriously
in <tt>try_lock</tt>. See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3141.pdf">n3141</a> page 205 - Appendix 1 - Additional Details
</blockquote>

<p><i>[
2010-11-01 Daniel comments:
]</i></p>

<blockquote>
Paper <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3152.html">n3152</a> addresses
this issue.
</blockquote>



<p><b>Proposed resolution:</b></p>
Resolved by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3209.html">n3209</a>.





<hr>
<h3><a name="1492"></a>1492. [FCD] Mutex requirements should not be bound to threads</h3>
<p><b>Section:</b> 30.4.1 [thread.mutex.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.mutex.requirements">issues</a> in [thread.mutex.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-188</b></p>

Mutex requirements should not be bound to threads

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<blockquote>
See Appendix 1 of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3141.pdf">n3141</a> - Additional Details, p. 208.
</blockquote>

<p><i>[
2010-10-24 Daniel adds:
]</i></p>


<blockquote>
Accepting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3130.html">n3130</a> would solve this issue.
</blockquote>


<p><b>Proposed resolution:</b></p>
Resolved by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3197.html">n3197</a>.





<hr>
<h3><a name="1498"></a>1498. [FCD] Unclear specification for [thread.condition]</h3>
<p><b>Section:</b> 30.5 [thread.condition] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> Switzerland <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.condition">issues</a> in [thread.condition].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses CH-29</b></p>

It is unclear if a spurious wake-up during the loop and reentering
of the blocked state due to a repeated execution
of the loop will adjust the timer of the blocking with the
respect to the previously specified rel_time value.

<p><i>[
Resolution proposed by ballot comment:
]</i></p>


<blockquote>
Make it clear (e.g. by a note) that when reexecuting
the loop the waiting time when blocked
will be adjusted with respect to the elapsed time of
the previous loop executions.
</blockquote>

<p><i>[
2010-08-13 Peter Sommerlad comments and provides wording:
]</i></p>


<blockquote>
Problem: It is unclear if a spurious wake-up during the loop and re-entering of the blocked state due 
to a repeated execution of the loop will adjust the timer of the blocking with the respect to the 
previously specified <tt>rel_time</tt> value.
<p>
Proposed Resolution from CH29:
</p><p>
Make it clear (e.g. by a note) that when re-executing the loop the waiting time when blocked will be 
adjusted with respect to the elapsed time of the previous loop executions.
</p><p>
Discussion in Rapperswil:
</p><p>
Assuming the introduction of a mandatory <tt>steady_clock</tt> proposed by US-181 to the FCD the 
specification of <tt>condition_variable::wait_for</tt> can be defined in terms of <tt>wait_until</tt> 
using the <tt>steady_clock</tt>. This is also interleaving with US-181, because that touches the 
same paragraph (30.5.1 p 25, p34 and 30.5.2 p 20, p 28 in n3092.pdf)
</p><p>
(The "as if" in the proposed solutions should be confirmed by the standardization terminology experts)
</p></blockquote>

<p><i>[
2010-11 Batavia: Resolved by applying <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3191.html">n3191</a>
]</i></p>


<blockquote>
<ol>
<li>Change 30.5.1 [thread.condition.condvar] paragraph 25, <tt>wait_for</tt> <i>Effects</i> as indicated:
<blockquote><pre>template &lt;class Rep, class Period&gt;
cv_status wait_for(unique_lock&lt;mutex&gt;&amp; lock,
  const chrono::duration&lt;Rep, Period&gt;&amp; rel_time);
</pre></blockquote>
<blockquote>
[..]
<p>
25 <i>Effects</i>: <ins>as if</ins>
</p><blockquote><pre><ins>return wait_until(lock, chrono::steady_clock::now() + rel_time);</ins>
</pre></blockquote>
<ul>
<li><del>Atomically calls <tt>lock.unlock()</tt> and blocks on <tt>*this</tt>.</del>
</li>
<li><del>When unblocked, calls <tt>lock.lock()</tt> (possibly blocking on the lock), then returns.</del>
</li>
<li><del>The function will unblock when signaled by a call to <tt>notify_one()</tt> or a call to <tt>notify_all()</tt>,
by the elapsed time <tt>rel_time</tt> passing (30.2.4), or spuriously.</del>
</li>
<li><del>If the function exits via an exception, <tt>lock.lock()</tt> shall be called prior to exiting the function scope.</del>
</li>
</ul>
</blockquote>
</li>
<li>Change 30.5.1 [thread.condition.condvar] paragraph 34, <tt>wait_for</tt> with predicate <i>Effects</i> as indicated:
<blockquote><pre>template &lt;class Rep, class Period, class Predicate&gt;
bool wait_for(unique_lock&lt;mutex&gt;&amp; lock,
  const chrono::duration&lt;Rep, Period&gt;&amp; rel_time,
  Predicate pred);
</pre></blockquote>
<blockquote>
[..]
<p>
34 <i>Effects</i>: <ins>as if</ins>
</p><blockquote><pre><ins>return wait_until(lock, chrono::steady_clock::now() + rel_time, std::move(pred));</ins>
</pre></blockquote>
<ul>
<li><del>Executes a loop: Within the loop the function first evaluates <tt>pred()</tt> and exits the loop if the
result is <tt>true</tt>.
</del></li>

<li><del>Atomically calls <tt>lock.unlock()</tt> and blocks on <tt>*this</tt>.
</del></li>

<li><del>When unblocked, calls <tt>lock.lock()</tt> (possibly blocking on the lock).
</del></li>

<li><del>The function will unblock when signaled by a call to <tt>notify_one()</tt> or a call to <tt>notify_all()</tt>,
by the elapsed time <tt>rel_time</tt> passing (30.2.4), or spuriously.
</del></li>

<li><del>If the function exits via an exception, <tt>lock.lock()</tt> shall be called prior to exiting the function
scope.
</del></li>

<li><del>The loop terminates when <tt>pred()</tt> returns <tt>true</tt> or when the time duration specified by <tt>rel_time</tt>
has elapsed.
</del></li>

</ul>
</blockquote>
</li>

<li>Change 30.5.2 [thread.condition.condvarany] paragraph 20, <tt>wait_for</tt> <i>Effects</i> as indicated:
<blockquote><pre>template &lt;class Lock, class Rep, class Period&gt;
cv_status wait_for(Lock&amp; lock, const chrono::duration&lt;Rep, Period&gt;&amp; rel_time);
</pre></blockquote>
<blockquote>
20 <i>Effects</i>: <ins>as if</ins>
<blockquote><pre><ins>return wait_until(lock, chrono::steady_clock::now() + rel_time);</ins>
</pre></blockquote>
<ul>
<li><del>Atomically calls <tt>lock.unlock()</tt> and blocks on <tt>*this</tt>.
</del></li>

<li><del>When unblocked, calls <tt>lock.lock()</tt> (possibly blocking on the lock), then returns.
</del></li>

<li><del>The function will unblock when signaled by a call to <tt>notify_one()</tt> or a call to <tt>notify_all()</tt>,
by the elapsed time <tt>rel_time</tt> passing (30.2.4), or spuriously.
</del></li>

<li><del>If the function exits via an exception, <tt>lock.unlock()</tt> shall be called prior to exiting the function
scope.
</del></li>
</ul>
</blockquote>
</li>

<li>Change 30.5.2 [thread.condition.condvarany] paragraph 28, <tt>wait_for</tt> with predicate <i>Effects</i> as indicated:
<blockquote><pre>template &lt;class Lock, class Rep, class Period, class Predicate&gt;
bool wait_for(Lock&amp; lock, const chrono::duration&lt;Rep, Period&gt;&amp; rel_time, Predicate pred);
</pre></blockquote>
<blockquote>
28 <i>Effects</i>: <ins>as if</ins>
<blockquote><pre><ins>return wait_until(lock, chrono::steady_clock::now() + rel_time, std::move(pred));</ins>
</pre></blockquote>
<ul>
<li><del>Executes a loop: Within the loop the function first evaluates <tt>pred()</tt> and exits the loop if the
result is <tt>true</tt>.
</del></li>

<li><del>Atomically calls <tt>lock.unlock()</tt> and blocks on <tt>*this</tt>.
</del></li>

<li><del>When unblocked, calls <tt>lock.lock()</tt> (possibly blocking on the lock).
</del></li>

<li><del>The function will unblock when signaled by a call to <tt>notify_one()</tt> or a call to <tt>notify_all()</tt>,
by the elapsed time <tt>rel_time</tt> passing (30.2.4), or spuriously.
</del></li>

<li><del>If the function exits via an exception, <tt>lock.unlock()</tt> shall be called prior to exiting the function
scope.
</del></li>

<li><del>The loop terminates when <tt>pred()</tt> returns <tt>true</tt> or when the time duration specified by <tt>rel_time</tt>
has elapsed.
</del></li>
</ul>
</blockquote>
</li>

</ol>

</blockquote>


<p><b>Proposed resolution:</b></p>
Resolved by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3191.html">n3191</a>.





<hr>
<h3><a name="1501"></a>1501. [FCD] spec for managing associated asynchronous
state has problems</h3>
<p><b>Section:</b> 30.6 [futures] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#futures">issues</a> in [futures].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-194</b></p>

The specification for managing associated asynchronous
state is confusing, sometimes omitted, and redundantly
specified.

<p><i>[
Resolution proposed by ballot comment:
]</i></p>


<blockquote>
Define terms-of-art for releasing, making ready,
and abandoning an associated asynchronous
state. Use those terms where appropriate. See
Appendix 1 - Additional Details
</blockquote>


<p><b>Proposed resolution:</b></p>
Resolved in Batavia by accepting
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3192.html">n3192</a>.





<hr>
<h3><a name="1508"></a>1508. [FCD] Rename <tt>packaged_task::operator bool()</tt></h3>
<p><b>Section:</b> 30.6.10 [futures.task] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#futures.task">issues</a> in [futures.task].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-201</b></p>
<p>
<tt>packaged_task</tt> provides <tt>operator bool()</tt> to check whether
an object has an associated asynchronous state. The various <tt>future</tt> 
types provide a member function <tt>valid()</tt> that does the same thing. 
The names of these members should be the same.
</p>

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<blockquote>
Replaced the name <tt>packaged_task::operator bool()</tt> with <tt>packaged_task::valid()</tt> in the synopsis
(30.6.10 [futures.task]/2) and the member function specification (before 30.6.10.1 [futures.task.members]/15).
</blockquote>

<p><i>[
2010-11-02 Daniel translates proposed wording changes into a proper proposed resolution
and verified that no other places implicitly take advantage of <tt>packaged_task</tt> 
conversion to bool.
]</i></p>


<p><i>[Resolved in Batavia by accepting
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3194.html">n3194</a>.
]</i></p>




<p><b>Proposed resolution:</b></p>
<ol>
<li>Change 30.6.10 [futures.task]/2, class template <tt>packaged_task</tt> synopsis as indicated:
<blockquote><pre>template&lt;class R, class... ArgTypes&gt;
class packaged_task&lt;R(ArgTypes...)&gt; {
public:
  typedef R result_type;
  [..]
  <del>explicit operator</del> bool <ins>valid</ins>() const;
  [..]
};
</pre></blockquote>
</li>
<li>Change 30.6.10 [futures.task] before p. 15 as indicated:
<blockquote><pre><del>explicit operator</del> bool <ins>valid</ins>() const;
</pre><blockquote>
15 <em>Returns</em>: true only if <tt>*this</tt> has an associated asynchronous state.
<p>
16 <em>Throws</em>: nothing.
</p></blockquote></blockquote>
</li>
</ol>





<hr>
<h3><a name="1513"></a>1513. [FCD] 'launch' enum too restrictive</h3>
<p><b>Section:</b> 30.6 [futures] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> Switzerland <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#futures">issues</a> in [futures].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses CH-36</b></p>

Providing only three different possible values for the enum
<tt>launch</tt> and saying that <tt>launch::any</tt> means either
<tt>launch::sync</tt> or <tt>launch::async</tt> is very restricting. This
hinders future implementors to provide clever
infrastructures that can simply by used by a call to
<tt>async(launch::any,...)</tt>. Also there is no hook for an
implementation to provide additional alternatives to <tt>launch</tt>
enumeration and no useful means to combine those (i.e.
interpret them like flags). We believe something like
<tt>async(launch::sync | launch::async, ...)</tt> should be allowed
and can become especially useful if one could say also
something like <tt>async(launch::any &amp; ~launch::sync, ....)</tt>
respectively. This flexibility might limit the features usable
in the function called through <tt>async()</tt>, but it will allow a
path to effortless profit from improved hardware/software
without complicating the programming model when just
using <tt>async(launch::any,...)</tt>

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<p>
Change in 30.6.1 [futures.overview] 'enum class launch' to allow
further implementation defined values and provide
the following bit-operators on the launch values
(<tt>operator|</tt>, <tt>operator&amp;</tt>, <tt>operator~</tt> delivering a
<tt>launch</tt> value).
</p><p>
Note: a possible implementation might use an
unsigned value to represent the <tt>launch</tt> enums,
but we shouldn't limit the standard to just 32 or 64
available bits in that case and also should keep
the launch enums in their own enum namespace.
</p><p>
Change [future.async] p3 according to the
changes to <tt>enum launch</tt>. change --<tt>launch::any</tt> to
"the implementation may choose any of the
policies it provides." Note: this can mean that an
implementation may restrict the called function to
take all required information by copy in case it will
be called in a different address space, or even, on
a different processor type. To ensure that a call is
either performed like <tt>launch::async</tt> or
<tt>launch::sync</tt> describe one should call
<tt>async(launch::sync|launch::async,...)</tt>
</p>

<p><i>[
2010-11-02 Daniel comments:
]</i></p>


<blockquote>
The new paper <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3113.html">n3113</a> provides concrete wording.
</blockquote>


<p><b>Proposed resolution:</b></p>
Resolved by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3188.html">n3188</a>.





<hr>
<h3><a name="1516"></a>1516. [FCD] No specification for which header contains <tt>auto_ptr</tt></h3>
<p><b>Section:</b> D.12 [depr.auto.ptr] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-142</b></p>
<p>
<tt>auto_ptr</tt> does not appear in the <tt>&lt;memory&gt;</tt> synopsis and
[depr.auto.ptr] doesn't say which header declares it.
Conversely, the deprecated binders <tt>bind1st</tt> etc. are in the
<tt>&lt;functional&gt;</tt> synopsis, this is inconsistent
</p>
<p>
Either <tt>auto_ptr</tt> should be declared in the
<tt>&lt;memory&gt;</tt> synopsis, or the deprecated binders
should be removed from the <tt>&lt;functional&gt;</tt> synopsis
and appendix D should say which header declares
the binders and <tt>auto_ptr</tt>.
</p>

<p><i>[
Post-Rapperswil
]</i></p>


<blockquote>
Moved to Tentatively Ready after 5 positive votes on c++std-lib.
</blockquote>

<p><i>[
Adopted at 2010-11 Batavia
]</i></p>




<p><b>Proposed resolution:</b></p>

<p>Add the following lines to the synopsis of header <tt>&lt;memory&gt;</tt>
in [memory]/1:<br></p>
<blockquote>
<pre><ins>// [depr.auto.ptr], Class auto_ptr (deprecated):
template &lt;class X&gt; class auto_ptr;<br></ins>
</pre></blockquote>





<hr>
<h3><a name="1517"></a>1517. default_delete's default constructor should be trivial</h3>
<p><b>Section:</b> 20.9.9.1.2 [unique.ptr.dltr.dflt] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2010-09-12 <b>Last modified:</b> 2010-11-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#unique.ptr.dltr.dflt">issues</a> in [unique.ptr.dltr.dflt].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The current working draft does specify the default c'tor of <tt>default_delete</tt> in a manner
to guarantee static initialization for default-constructed objects of static storage duration
as a consequence of the acceptance of the proposal <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2976.html">n2976</a>
but this paper overlooked the fact that the suggested declaration does not ensure that the type 
will be a trivial type. The type <tt>default_delete</tt> was always considered as a simple wrapper for 
calling <tt>delete</tt> or <tt>delete[]</tt>, respectivly and should be a trivial type.
</p>
<p>
In agreement with the new settled core language rules this easy to realize by just changing the declaration to
</p><blockquote><pre>constexpr default_delete()<ins> = default</ins>;
</pre></blockquote><p></p>
<p>
This proposal also automatically solves the problem, that the semantics of the default constructor of the 
partial specialization <tt>default_delete&lt;T[]&gt;</tt> is not specified at all. By defaulting its default constructor 
as well, the semantics are well-defined.
</p>

<p><i>[
Post-Rapperswil
]</i></p>


<blockquote>
Moved to Tentatively Ready after 5 positive votes on c++std-lib.
</blockquote>

<p><i>[
Adopted at 2010-11 Batavia
]</i></p>




<p><b>Proposed resolution:</b></p>
<p><i>The following wording changes are against N3126.</i></p>

<ol>
<li>Change the synopsis of the primary template definition of <tt>default_delete</tt> in [unique.ptr.dltr.dflt] as indicated:
<blockquote><pre>namespace std {
  template &lt;class T&gt; struct default_delete {
    constexpr default_delete()<ins> = default</ins>;
    template &lt;class U&gt; default_delete(const default_delete&lt;U&gt;&amp;);
    void operator()(T*) const;
  };
}
</pre></blockquote>
</li>
<li>
Remove the prototype specification of the <tt>default_delete</tt> default constructor in [unique.ptr.dltr.dflt]/1. This
brings it in harmony with the style used in the partial specialization <tt>default_delete&lt;T[]&gt;</tt>. Since there are
neither implied nor explicit members, there is no possibility to misinterpret what the constructor does:
<blockquote><pre><del>constexpr default_delete();</del>
</pre><blockquote>
<del>1 <em>Effects</em>: Default constructs a <tt>default_delete</tt> object.</del>
</blockquote></blockquote>
</li>
<li>Change the synopsis of the partial specialization of <tt>default_delete</tt> in [unique.ptr.dltr.dflt1] as indicated:
<blockquote><pre>namespace std {
  template &lt;class T&gt; struct default_delete&lt;T[]&gt; {
    constexpr default_delete()<ins> = default</ins>;
    void operator()(T*) const;
    template &lt;class U&gt; void operator()(U*) const = delete;
  };
}</pre></blockquote>
</li>
</ol>





<hr>
<h3><a name="1518"></a>1518. Waiting for deferred functions</h3>
<p><b>Section:</b> 30.6 [futures] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Alberto Ganesh Barbati <b>Opened:</b> 2010-09-14 <b>Last modified:</b> 2010-11-24</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#futures">issues</a> in [futures].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>The current WP N3126 contains ambiguous statements about the
behaviour of functions <tt>wait_for</tt>/<tt>wait_until</tt> in
case the future refers to a deferred function. Moreover, I believe
it describes a disputable intent, different from the one contained
in the original async proposals, that may have been introduced
inadvertently during the "async cleanup" that occurred recently.
Consider the following case:</p>
<blockquote>
<pre>int f();  
future&lt;int&gt; x = async(launch::deferred, f);
future_status s = x.wait_for(chrono::milliseconds(100));
</pre></blockquote>
<p>This example raises two questions:</p>
<ol>
<li>is <tt>f</tt> invoked?</li>
<li>what is the value of <tt>s</tt>?</li>
</ol>
<p>According to the current WP, the answer to question 1 is yes,
because 30.6.9/3 says "The first call to a function waiting for the
associated asynchronous state created by this async call to become
ready shall invoke the deferred function in the thread that called
the waiting function". The answer to question 2, however, is not as
clear. According to 30.6.6/23, s should be
<tt>future_status::deferred</tt> because <tt>x</tt> refers to a
deferred function that is not running, but it should also be
<tt>future_status::ready</tt> because after executing <tt>f</tt>
(and we saw that <tt>f</tt> is always executed) the state becomes
ready. By the way, the expression "deferred function that is not
running" is very unfortunate in itself, because it may apply to
both the case where the function hasn't yet started, as well as the
case where it was executed and completed.</p>
<p>While we clearly have a defect in the WP answering to question
2, it is my opinion that the answer to question 1 is wrong, which
is even worse. Consider that the execution of the function
<tt>f</tt> can take an arbitrarily long time. Having
<tt>wait_for()</tt> invoke <tt>f</tt> is a potential violation of
the reasonable expectation that the execution of
<tt>x.wait_for(chrono::milliseconds(100))</tt> shall take <u>at most</u>
100 milliseconds plus a delay dependent on the quality of implementation
and the quality of management (as described in paper N3128).
In fact, previous versions of the WP
clearly specified that only function <tt>wait()</tt> is required to
execute the deferred function, while <tt>wait_for()</tt> and
<tt>wait_until()</tt> shouldn't.</p>
<p>The proposed resolution captures the intent that
<tt>wait_for()</tt> and <tt>wait_until()</tt> should never attempt
to invoke the deferred function. In other words, the P/R provides
the following answers to the two questions above:</p>
<ol>
<li>no</li>
<li><tt>future_status::deferred</tt></li>
</ol>
<p>In order to simplify the wording, the definition of <i>deferred
function</i> has been tweaked so that the function is no longer
considered deferred once its evaluation has started, as suggested
by Howard.</p>
<p>Discussions in the reflector questioned whether
<tt>wait_for()</tt> and <tt>wait_until()</tt> should return
immediately or actually wait hoping for a second thread to execute
the deferred function. I believe that waiting could be useful only
in a very specific scenario but detrimental in the general case and
would introduce another source of ambiguity: should
<tt>wait_for()</tt> return <tt>future_status::deferred</tt> or
<tt>future_status::timeout</tt> after the wait? Therefore the P/R
specifies that <tt>wait_for</tt>/<tt>wait_until</tt> shall return
immediately, which is simpler, easier to explain and more useful in
the general case.</p>

<p><i>[
Post-Rapperswil
]</i></p>


<blockquote>
Moved to Tentatively Ready after 5 positive votes on c++std-lib.
</blockquote>

<p><i>[
Adopted at 2010-11 Batavia
]</i></p>




<p><b>Proposed resolution:</b></p>

<p>The proposed wording changes are relative to the Final Committee Draft,
N3126.</p>
<p><b>Note to the editor:</b> the proposed wording is meant not be in conflict
with any change proposed by paper N3128 "C++ Timeout Specification".
Ellipsis are deliberately used to avoid any unintended overlapping.</p>
<ol>
<li>
<p>In [futures.unique_future] 30.6.6/22:</p>
<p>Effects: <ins>none if the associated asynchronous state contains
a deferred function (30.6.9), otherwise</ins> blocks until the
associated asynchronous state is ready or [...].</p>
</li>
<li>
<p>In [futures.unique_future] 30.6.6/23 first bullet:</p>
<p> future_status::deferred if the associated asynchronous
state contains a deferred function <del>that is not
running</del>.</p>
</li>
<li>
<p>In [futures.unique_future] 30.6.6/25:</p>
<p>Effects: <ins>none if the associated asynchronous state contains
a deferred function (30.6.9), otherwise</ins> blocks until the
associated asynchronous state is ready or [...].</p>
</li>
<li>
<p>In [futures.unique_future] 30.6.6/26 first bullet:</p>
<p> future_status::deferred if the associated asynchronous
state contains a deferred function <del>that is not
running</del>.</p>
</li>
<li>
<p>In [futures.shared_future] 30.6.7/27</p>
<p>Effects: <ins>none if the associated asynchronous state contains
a deferred function (30.6.9), otherwise</ins> blocks until the
associated asynchronous state is ready or [...].</p>
</li>
<li>
<p>In [futures.unique_future] 30.6.7/28 first bullet:</p>
<p> future_status::deferred if the associated asynchronous
state contains a deferred function <del>that is not
running</del>.</p>
</li>
<li>
<p>In [futures.shared_future] 30.6.6/30:</p>
<p>Effects: <ins>none if the associated asynchronous state contains
a deferred function (30.6.9), otherwise</ins> blocks until the
associated asynchronous state is ready or [...].</p>
</li>
<li>
<p>In [futures.unique_future] 30.6.7/31 first bullet:</p>
<p> future_status::deferred if the associated asynchronous
state contains a deferred function <del>that is not
running</del>.</p>
</li>
<li>
<p>In [futures.atomic_future] 30.6.8/23</p>
<p>Effects: <ins>none if the associated asynchronous state contains
a deferred function (30.6.9), otherwise</ins> blocks until the
associated asynchronous state is ready or [...].</p>
</li>
<li>
<p>In [futures.unique_future] 30.6.8/24 first bullet:</p>
<p> future_status::deferred if the associated asynchronous
state contains a deferred function <del>that is not
running</del>.</p>
</li>
<li>
<p>In [futures.atomic_future] 30.6.8/27:</p>
<p>Effects: <ins>none if the associated asynchronous state contains
a deferred function (30.6.9), otherwise</ins> blocks until the
associated asynchronous state is ready or [...].</p>
</li>
<li>
<p>In [futures.unique_future] 30.6.8/28 first bullet:</p>
<p> future_status::deferred if the associated asynchronous
state contains a deferred function <del>that is not
running</del>.</p>
</li>
<li>
<p>In [futures.async] 30.6.9/3 second bullet:</p>
<p>[...] The first call to a function
<del>waiting</del><ins>requiring a non-timed wait</ins> for the
associated asynchronous state created by this async call to become
ready shall invoke the deferred function in the thread that called
the waiting function; <ins>once evaluation of <tt><i>INVOKE</i>(g,
xyz)</tt> begins, the function is no longer considered
deferred</ins> <del>all other calls waiting for the same associated
asynchronous state to become ready shall block until the deferred
function has completed</del>.</p>
</li>
</ol>






<hr>
<h3><a name="1519"></a>1519. bucketsize() const only for unordered set</h3>
<p><b>Section:</b> 23.7.1 [unord.map], 23.7.2 [unord.multimap], 23.7.4 [unord.multiset] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Nicolai Josuttis <b>Opened:</b> 2010-10-09 <b>Last modified:</b> 2010-11-24</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#unord.map">issues</a> in [unord.map].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
While <tt>bucket_size()</tt> is const for <tt>unordered_set</tt>, for all other unordered containers it is not defined as
constant member function.
</p>

<p><i>[
Post-Rapperswil
]</i></p>


<blockquote>
Moved to Tentatively Ready after 5 positive votes on c++std-lib.
</blockquote>

<p><i>[
Adopted at 2010-11 Batavia
]</i></p>




<p><b>Proposed resolution:</b></p>

<p><i>The wording refers to N3126.</i></p>

<ol>
<li>Change 23.7.1 Class template unordered_map [unord.map]/3, as indicated:
<blockquote><pre>  namespace std {
    template &lt;class Key,
      class T,
      class Hash = hash&lt;Key&gt;,
      class Pred = std::equal_to&lt;Key&gt;,
      class Alloc = std::allocator&lt;std::pair&lt;const Key, T&gt; &gt; &gt;
    class unordered_map
    {
    public:
      [..]
      // bucket interface
      size_type bucket_count() const;
      size_type max_bucket_count() const;
      size_type bucket_size(size_type n) <ins>const</ins>;
      [..]
</pre></blockquote>
</li>
<li>Change 23.7.2 Class template unordered_multimap [unord.multimap]/3, as indicated:
<blockquote><pre>  namespace std {
    template &lt;class Key,
      class T,
      class Hash = hash&lt;Key&gt;,
      class Pred = std::equal_to&lt;Key&gt;,
      class Alloc = std::allocator&lt;std::pair&lt;const Key, T&gt; &gt; &gt;
    class unordered_multimap
    {
    public:
      [..]
      // bucket interface
      size_type bucket_count() const;
      size_type max_bucket_count() const;
      size_type bucket_size(size_type n) <ins>const</ins>;
      [..]
</pre></blockquote>
</li>
<li>Change 23.7.4 Class template unordered_multiset [unord.multiset]/3, as indicated:
<blockquote><pre>  namespace std {
    template &lt;class Key,
      class Hash = hash&lt;Key&gt;,
      class Pred = std::equal_to&lt;Key&gt;,
      class Alloc = std::allocator&lt;Key&gt; &gt;
    class unordered_multiset
    {
    public:
      [..]
      // bucket interface
      size_type bucket_count() const;
      size_type max_bucket_count() const;
      size_type bucket_size(size_type n) <ins>const</ins>;
      [..]
</pre></blockquote>
</li>
</ol>






<hr>
<h3><a name="1520"></a>1520. <tt>INVOKE</tt> on member data pointer with too many arguments</h3>
<p><b>Section:</b> 20.8.2 [func.require] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2010-10-10 <b>Last modified:</b> 2010-11-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#func.require">issues</a> in [func.require].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>

<p>
20.8.2 [func.require] p1 says:
</p>

<blockquote>
<p>
1 Define <tt><i>INVOKE</i>(f, t1, t2, ..., tN)</tt> as follows:
</p>

<ul>
<li>
<tt>(t1.*f)(t2, ..., tN)</tt> when <tt>f</tt> is a pointer to a member function
of a class <tt>T</tt> and <tt>t1</tt> is an object of type <tt>T</tt> or a
reference to an object of type <tt>T</tt> or a reference to an object of a type
derived from <tt>T</tt>;
</li>
<li>
<tt>((*t1).*f)(t2, ..., tN)</tt> when <tt>f</tt> is a pointer to a member
function of a class <tt>T</tt> and <tt>t1</tt> is not one of the types described
in the previous item;
</li>
<li>
<tt>t1.*f</tt> when <tt>f</tt> is a pointer to member data of a class <tt>T</tt>
and <tt>t1</tt> is an object of type <tt>T</tt> or a reference to an object of
type <tt>T</tt> or a reference to an object of a type derived from <tt>T</tt>;
</li>
<li>
<tt>(*t1).*f</tt> when <tt>f</tt> is a pointer to member data of a class
<tt>T</tt> and <tt>t1</tt> is not one of the types described in the previous
item;
</li>
<li>
<tt>f(t1, t2, ..., tN)</tt> in all other cases.
</li>
</ul>
</blockquote>

<p>
The question is:  What happens in the 3<sup><i>rd</i></sup> and
4<sup><i>th</i></sup> bullets when <tt>N &gt; 1</tt>?
</p>

<p>
Does the presence of <tt>t2, ..., tN</tt> get ignored, or does it make the
<tt><i>INVOKE</i></tt> ill formed?
</p>

<p>
Here is sample code which presents the problem in a concrete example:
</p>

<blockquote><pre>#include &lt;functional&gt;
#include &lt;cassert&gt;

struct S {
   char data;
};

typedef char S::*PMD;

int main()
{
   S s;
   PMD pmd = &amp;S::data;
   std::reference_wrapper&lt;PMD&gt; r(pmd);
   r(s, 3.0) = 'a';  // well formed?
   assert(s.data == 'a');
}
</pre></blockquote>

<p>
Without the "<tt>3.0</tt>" the example is well formed.
</p>
<p>
[Note: Daniel provided wording to make it explicit that the above example is ill-formed.  end note ]
</p>

<p><i>[
Post-Rapperswil
]</i></p>


<blockquote>
Moved to Tentatively Ready after 5 positive votes on c++std-lib.
</blockquote>

<p><i>[
Adopted at 2010-11 Batavia
]</i></p>




<p><b>Proposed resolution:</b></p>

<p><i>The wording refers to N3126.</i></p>

<p>
Change 20.8.2 [func.require]/1 as indicated:
</p>
<blockquote>
<p>
1 Define <tt><i>INVOKE</i>(f, t1, t2, ..., tN)</tt> as follows:
</p>

<ul>
<li>
...
</li>
<li>
...
</li>
<li>
<tt>t1.*f</tt> when <ins><tt>N == 1</tt> and</ins> <tt>f</tt> is a pointer to
member data of a class <tt>T</tt> and <tt>t1</tt> is an object of type
<tt>T</tt> or a reference to an object of type <tt>T</tt> or a reference to an
object of a type derived from <tt>T</tt>;
</li>
<li>
<tt>(*t1).*f</tt> when <ins><tt>N == 1</tt> and</ins> <tt>f</tt> is a pointer to
member data of a class <tt>T</tt> and <tt>t1</tt> is not one of the types
described in the previous item;
</li>
<li>
...
</li>
</ul>
</blockquote>






<hr>
<h3><a name="1522"></a>1522. <tt>conj</tt> specification is now nonsense</h3>
<p><b>Section:</b> 26.4.9 [cmplx.over] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP">WP</a>
 <b>Submitter:</b> P.J. Plauger <b>Opened:</b> 2010-10-14 <b>Last modified:</b> 2010-11-24</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#cmplx.over">issues</a> in [cmplx.over].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In Pittsburgh, we accepted the resolution of library issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1137">1137</a>, to add
a sentence 3 to [cmplx.over]:
</p>
<blockquote>
All the specified overloads shall have a return type which is the nested
<tt>value_type</tt> of the effectively cast arguments.
</blockquote>
<p>
This was already true for four of the six functions except <tt>conj</tt> and
<tt>proj</tt>. It is not completely unreasonable to make <tt>proj</tt> return
the real value only, but the IEC specification does call for an imaginary part
of -0 in some circumstances. The people who care about these distinctions really
care, and it <em>is</em> required by an international standard.
</p>
<p>
Making <tt>conj</tt> return just the real part breaks it horribly, however. It is
well understood in mathematics that <tt>conj(re + i*im)</tt> is <tt>(re - i*im)</tt>,
and it is widely used. The accepted new definition makes <tt>conj</tt> useful only
for pure real operations. This botch <em>absolutely must</em> be fixed.
</p>

<p><i>[
2010 Batavia: The working group concurred with the issue's Proposed Resolution
]</i></p>


<p><i>[
Adopted at 2010-11 Batavia
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
Remove the recently added paragraph 3 from [cmplx.over]:
</p>
<blockquote>
<del>3 All the specified overloads shall have a return type which is the nested 
<tt>value_type</tt> of the effectively cast arguments.</del>
</blockquote>





<hr>
<h3><a name="2002"></a>2002. Class template <tt>match_results</tt> does not specify the semantics of <tt>operator==</tt></h3>
<p><b>Section:</b> 28.10.8 [re.results.nonmember] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Resolved">Resolved</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2010-10-24 <b>Last modified:</b> 2010-11-26</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Resolved">Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <em>Returns</em> element of <tt>operator==</tt> says:
</p>

<blockquote>
<tt>true</tt> only if the two objects refer to the same match
</blockquote>

<p>
It is not really clear what this means: The current specification would allow for an
implementation to return <tt>true</tt>, only if the address values of <tt>m1</tt> and
<tt>m2</tt> are the same. While this approach is unproblematic in terms of used operations 
this is also a bit unsatisfactory. With identity equality alone there seems to be no convincing
reason to provide this operator at all. It could for example also refer to an comparison based
on iterator values. In this case a user should better know that this will be done, because 
there is no guarantee at all that inter-container comparison of iterators 
is a feasible operation. This was a clear outcome of the resolution provided in 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3066.html">N3066</a> 
for LWG issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#446">446</a>.
It could also mean that a character-based comparison of the individual <tt>sub_match</tt>
elements should be done - this would be equivalent to applying <tt>operator==</tt> to
the subexpressions, prefix and suffix.
</p>



<p><b>Proposed resolution:</b></p>
Addressed by paper <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3158.html">n3158</a>.







</body></html>