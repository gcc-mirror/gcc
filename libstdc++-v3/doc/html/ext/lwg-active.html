<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">


<title>C++ Standard Library Active Issues List</title>
<style type="text/css">
p {text-align:justify}
li {text-align:justify}
blockquote.note
{
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
}
ins {background-color:#A0FFA0}
del {background-color:#FFA0A0}
</style>
</head><body>
<table>
<tbody><tr>
<td align="left">Doc. no.</td>
<td align="left">N3011=09-0201</td>
</tr>
<tr>
<td align="left">Date:</td>
<td align="left">2009-11-08</td>
</tr>
<tr>
<td align="left">Project:</td>
<td align="left">Programming Language C++</td>
</tr>
<tr>
<td align="left">Reply to:</td>
<td align="left">Howard Hinnant &lt;<a href="mailto:howard.hinnant@gmail.com">howard.hinnant@gmail.com</a>&gt;</td>
</tr>
</tbody></table>
<h1>C++ Standard Library Active Issues List (Revision R68)</h1>

  <p>Reference ISO/IEC IS 14882:2003(E)</p>
  <p>Also see:</p>
  <ul>
      <li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-toc.html">Table of Contents</a> for all library issues.</li>
      <li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html">Index by Section</a> for all library issues.</li>
      <li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html">Index by Status</a> for all library issues.</li>
      <li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html">Library Defect Reports List</a></li>
      <li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html">Library Closed Issues List</a></li>
  </ul>
  <p>The purpose of this document is to record the status of issues
  which have come before the Library Working Group (LWG) of the ANSI
  (J16) and ISO (WG21) C++ Standards Committee. Issues represent
  potential defects in the ISO/IEC IS 14882:2003(E) document.  
  </p>

  <p>This document contains only library issues which are actively being
  considered by the Library Working Group, i.e., issues which have a
  status of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>, 
  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>, or <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Review">Review</a>. See
  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html">Library Defect Reports List</a> for issues considered defects and 
  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html">Library Closed Issues List</a> for issues considered closed.</p>

  <p>The issues in these lists are not necessarily formal ISO Defect
  Reports (DR's). While some issues will eventually be elevated to
  official Defect Report status, other issues will be disposed of in
  other ways. See <a href="#Status">Issue Status</a>.</p>

  <p>Prior to Revision 14, library issues lists existed in two slightly
  different versions; a Committee Version and a Public
  Version. Beginning with Revision 14 the two versions were combined
  into a single version.</p>

  <p>This document includes <i>[bracketed italicized notes]</i> as a
  reminder to the LWG of current progress on issues. Such notes are
  strictly unofficial and should be read with caution as they may be
  incomplete or incorrect. Be aware that LWG support for a particular
  resolution can quickly change if new viewpoints or killer examples are
  presented in subsequent discussions.</p>

  <p>For the most current official version of this document see 
  <a href="http://www.open-std.org/jtc1/sc22/wg21/">http://www.open-std.org/jtc1/sc22/wg21/</a>.
  Requests for further information about this document should include
  the document number above, reference ISO/IEC 14882:2003(E), and be
  submitted to Information Technology Industry Council (ITI), 1250 Eye
  Street NW, Washington, DC 20005.</p>

  <p>Public information as to how to obtain a copy of the C++ Standard,
  join the standards committee, submit an issue, or comment on an issue
  can be found in the comp.std.c++ FAQ.
  </p>

<p><a name="submit_issue"></a><b>How to submit an issue</b></p>

<ol type="A">
<a name="submit_issue_A"></a><li>
Mail your issue to the author of this list.
</li>
<a name="submit_issue_B"></a><li>
Specify a short descriptive title.  If you fail to do so, the subject line of your
mail will be used as the issue title.
</li>
<a name="submit_issue_C"></a><li>
If the "From" on your email is not the name you wish to appear as issue submitter,
then specify issue submitter.
</li>
<a name="submit_issue_D"></a><li>
Provide a brief discussion of the problem you wish to correct.  Refer to the latest
working draft or standard using [section.tag] and paragraph numbers where appropriate.
</li>
<a name="submit_issue_E"></a><li>
Provide proposed wording.  This should indicate exactly how you want the standard
to be changed.  General solution statements belong in the discussion area.  This
area contains very clear and specific directions on how to modify the current
draft.  If you are not sure how to word a solution, you may omit this part.
But your chances of a successful issue greatly increase if you attempt wording.
</li>
<a name="submit_issue_F"></a><li>
It is not necessary for you to use html markup.  However, if you want to, you can
&lt;ins&gt;<ins>insert text like this</ins>&lt;/ins&gt; and &lt;del&gt;<del>delete text like
this</del>&lt;/del&gt;.  The only strict requirement is to communicate clearly to
the list maintainer exactly how you want your issue to look.
</li>
<a name="submit_issue_G"></a><li>
It is not necessary for you to specify other html font/formatting
mark-up, but if you do the list maintainer will attempt to respect your
formatting wishes (as described by html markup, or other common idioms).
</li>
<a name="submit_issue_H"></a><li>
It is not necessary for you to specify open date or last modified date (the date
of your mail will be used).
</li>
<a name="submit_issue_I"></a><li>
It is not necessary for you to cross reference other issues, but you can if you
like.  You do not need to form the hyperlinks when you do, the list maintainer will
take care of that.
</li>
<a name="submit_issue_J"></a><li>
One issue per email is best.
</li>
<a name="submit_issue_K"></a><li>
Between the time you submit the issue, and the next mailing deadline
(date at the top of the Revision History), you <em>own</em> this issue. 
You control the content, the stuff that is right, the stuff that is
wrong, the format, the misspellings, etc.  You can even make the issue
disappear if you want.  Just let the list maintainer know how you want
it to look, and he will try his best to accommodate you.  After the
issue appears in an official mailing, you no longer enjoy exclusive
ownership of it.
</li>
</ol>


<h2>Revision History</h2>
<ul>
<li>R68: 
2009-11-06 post-Santa Cruz mailing.
<ul>
<li><b>Summary:</b><ul>
<li>205 open issues, down by 77.</li>
<li>1055 closed issues, up by 120.</li>
<li>1260 issues total, up by 43.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following Dup issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1230">1230</a>.</li>
<li>Added the following NAD issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1229">1229</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1236">1236</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1243">1243</a>.</li>
<li>Added the following NAD Editorial issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1232">1232</a>.</li>
<li>Added the following NAD Future issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1235">1235</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1242">1242</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1248">1248</a>.</li>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1218">1218</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1219">1219</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1221">1221</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1222">1222</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1223">1223</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1224">1224</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1225">1225</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1234">1234</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1240">1240</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1244">1244</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1245">1245</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1246">1246</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1249">1249</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1250">1250</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1251">1251</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1252">1252</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1253">1253</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1254">1254</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1255">1255</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1256">1256</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1257">1257</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1258">1258</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1259">1259</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1260">1260</a>.</li>
<li>Added the following Open issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1228">1228</a>.</li>
<li>Added the following Ready issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1227">1227</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1237">1237</a>.</li>
<li>Added the following Review issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1247">1247</a>.</li>
<li>Added the following Tentatively NAD Editorial issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1233">1233</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1239">1239</a>.</li>
<li>Added the following Tentatively NAD Future issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1238">1238</a>.</li>
<li>Added the following Tentatively Ready issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1220">1220</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1226">1226</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1231">1231</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1241">1241</a>.</li>
<li>Changed the following issues from New to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1132">1132</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1148">1148</a>.</li>
<li>Changed the following issues from Open to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#96">96</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#458">458</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#463">463</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#916">916</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#917">917</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#919">919</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#955">955</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#977">977</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1009">1009</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1020">1020</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1035">1035</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1042">1042</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1051">1051</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1064">1064</a>.</li>
<li>Changed the following issues from Review to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#668">668</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#930">930</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1091">1091</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1102">1102</a>.</li>
<li>Changed the following issues from Tentatively NAD to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#588">588</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#617">617</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#971">971</a>.</li>
<li>Changed the following issues from Tentatively NAD Future to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1062">1062</a>.</li>
<li>Changed the following issues from NAD Concepts to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1143">1143</a>.</li>
<li>Changed the following issues from New to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1116">1116</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1117">1117</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1122">1122</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1129">1129</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1145">1145</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1146">1146</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1147">1147</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1155">1155</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1166">1166</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1172">1172</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1174">1174</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1179">1179</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1195">1195</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1196">1196</a>.</li>
<li>Changed the following issues from Open to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#431">431</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#580">580</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#635">635</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#719">719</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#823">823</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#827">827</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#879">879</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#880">880</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#908">908</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#923">923</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#924">924</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#926">926</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#944">944</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#947">947</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#958">958</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1046">1046</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1048">1048</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1054">1054</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1055">1055</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1075">1075</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1088">1088</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1160">1160</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1161">1161</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1162">1162</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1163">1163</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1165">1165</a>.</li>
<li>Changed the following issues from Review to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#828">828</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#897">897</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#976">976</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1043">1043</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1047">1047</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1049">1049</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1050">1050</a>.</li>
<li>Changed the following issues from New to NAD Future: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1120">1120</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1150">1150</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1184">1184</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1203">1203</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1217">1217</a>.</li>
<li>Changed the following issues from Open to NAD Future: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#484">484</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#532">532</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#851">851</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#933">933</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#935">935</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#936">936</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#961">961</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1041">1041</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1053">1053</a>.</li>
<li>Changed the following issues from Tentatively NAD Future to NAD Future: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1031">1031</a>.</li>
<li>Changed the following issues from New to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1118">1118</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1119">1119</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1151">1151</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1153">1153</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1156">1156</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1171">1171</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1173">1173</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1183">1183</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1191">1191</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1211">1211</a>.</li>
<li>Changed the following issues from Ready to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#430">430</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#834">834</a>.</li>
<li>Changed the following issues from Review to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#397">397</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#408">408</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#835">835</a>.</li>
<li>Changed the following issues from Tentatively NAD to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#625">625</a>.</li>
<li>Changed the following issues from New to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1123">1123</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1134">1134</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1135">1135</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1136">1136</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1144">1144</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1177">1177</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1194">1194</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1204">1204</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1216">1216</a>.</li>
<li>Changed the following issues from Open to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#296">296</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#471">471</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#485">485</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#539">539</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#816">816</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#860">860</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#865">865</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#872">872</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#920">920</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#932">932</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#939">939</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#940">940</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#960">960</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#963">963</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#974">974</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#978">978</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1011">1011</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1030">1030</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1079">1079</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1098">1098</a>.</li>
<li>Changed the following issues from Review to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#473">473</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#671">671</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#836">836</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#854">854</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#868">868</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#871">871</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#889">889</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#893">893</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#921">921</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#950">950</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#954">954</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#957">957</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#962">962</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#967">967</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#968">968</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#983">983</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1052">1052</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1094">1094</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1095">1095</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1097">1097</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1100">1100</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1104">1104</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1157">1157</a>.</li>
<li>Changed the following issues from New to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1130">1130</a>.</li>
<li>Changed the following issues from Open to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#556">556</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#631">631</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#676">676</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#727">727</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#929">929</a>.</li>
<li>Changed the following issues from Open to Tentatively NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1056">1056</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1099">1099</a>.</li>
<li>Changed the following issues from New to Tentatively NAD Concepts: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1186">1186</a>.</li>
<li>Changed the following issues from New to Tentatively NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1115">1115</a>.</li>
<li>Changed the following issues from New to Tentatively NAD Future: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1121">1121</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1201">1201</a>.</li>
<li>Changed the following issues from Open to Tentatively NAD Future: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1112">1112</a>.</li>
<li>Changed the following issues from New to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1126">1126</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1138">1138</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1152">1152</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1158">1158</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1189">1189</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1192">1192</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1208">1208</a>.</li>
<li>Changed the following issues from Open to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#987">987</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#999">999</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1071">1071</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1090">1090</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1108">1108</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1113">1113</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1114">1114</a>.</li>
<li>Changed the following issues from Ready to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#149">149</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#419">419</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#498">498</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#564">564</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#565">565</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#630">630</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#659">659</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#696">696</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#711">711</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#716">716</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#723">723</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#788">788</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#822">822</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#838">838</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#847">847</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#857">857</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#859">859</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#876">876</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#881">881</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#883">883</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#886">886</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#934">934</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1004">1004</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1178">1178</a>.</li>
<li>Changed the following issues from Tentatively Ready to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1012">1012</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1019">1019</a>.</li>
</ul></li>
</ul>
</li>
<li>R67: 
2009-09-25 pre-Santa Cruz mailing.
<ul>
<li><b>Summary:</b><ul>
<li>282 open issues, up by 32.</li>
<li>935 closed issues, down by 1.</li>
<li>1217 issues total, up by 31.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1187">1187</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1188">1188</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1189">1189</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1190">1190</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1191">1191</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1192">1192</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1193">1193</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1194">1194</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1195">1195</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1196">1196</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1197">1197</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1198">1198</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1199">1199</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1200">1200</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1201">1201</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1202">1202</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1203">1203</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1204">1204</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1205">1205</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1206">1206</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1207">1207</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1208">1208</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1209">1209</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1210">1210</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1211">1211</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1212">1212</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1213">1213</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1214">1214</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1215">1215</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1216">1216</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1217">1217</a>.</li>
<li>Changed the following issues from NAD to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#296">296</a>.</li>
<li>Changed the following issues from WP to Pending WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#970">970</a>.</li>
<li>Changed the following issues from Open to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#976">976</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1052">1052</a>.</li>
<li>Changed the following issues from Ready to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#780">780</a>.</li>
</ul></li>
</ul>
</li>
<li>R66: 
2009-07-31 post-Frankfurt mailing.
<ul>
<li><b>Summary:</b><ul>
<li>250 open issues, down by 128.</li>
<li>936 closed issues, up by 171.</li>
<li>1186 issues total, up by 43.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following NAD issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1164">1164</a>.</li>
<li>Added the following NAD Concepts issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1149">1149</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1167">1167</a>.</li>
<li>Added the following NAD Editorial issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1168">1168</a>.</li>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1144">1144</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1145">1145</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1146">1146</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1147">1147</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1148">1148</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1150">1150</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1151">1151</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1152">1152</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1153">1153</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1154">1154</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1155">1155</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1156">1156</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1158">1158</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1159">1159</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1166">1166</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1169">1169</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1170">1170</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1171">1171</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1172">1172</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1173">1173</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1174">1174</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1175">1175</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1176">1176</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1177">1177</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1179">1179</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1180">1180</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1181">1181</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1182">1182</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1183">1183</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1184">1184</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1185">1185</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1186">1186</a>.</li>
<li>Added the following Open issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1160">1160</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1161">1161</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1162">1162</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1163">1163</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1165">1165</a>.</li>
<li>Added the following Ready issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1178">1178</a>.</li>
<li>Added the following Review issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1157">1157</a>.</li>
<li>Changed the following issues from Open to Dup: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#750">750</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#895">895</a>.</li>
<li>Changed the following issues from Open to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#111">111</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#128">128</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#138">138</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#190">190</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#219">219</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#290">290</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#309">309</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#342">342</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#343">343</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#382">382</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#394">394</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#398">398</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#417">417</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#418">418</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#421">421</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#459">459</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#466">466</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#492">492</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#502">502</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#503">503</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#546">546</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#573">573</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#582">582</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#585">585</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#597">597</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#606">606</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#614">614</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#632">632</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#721">721</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#747">747</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#751">751</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#833">833</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#941">941</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#992">992</a>.</li>
<li>Changed the following issues from Review to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1003">1003</a>.</li>
<li>Changed the following issues from Tentatively NAD to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#568">568</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#644">644</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#667">667</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#669">669</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#701">701</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#702">702</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#785">785</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#863">863</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#901">901</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#903">903</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#946">946</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#988">988</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#995">995</a>.</li>
<li>Changed the following issues from Tentatively Ready to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1002">1002</a>.</li>
<li>Changed the following issues from New to NAD Concepts: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1124">1124</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1127">1127</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1128">1128</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1139">1139</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1140">1140</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1141">1141</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1142">1142</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1143">1143</a>.</li>
<li>Changed the following issues from Open to NAD Concepts: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#902">902</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#989">989</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1000">1000</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1007">1007</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1010">1010</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1015">1015</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1016">1016</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1017">1017</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1018">1018</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1026">1026</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1027">1027</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1028">1028</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1029">1029</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1032">1032</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1036">1036</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1057">1057</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1059">1059</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1072">1072</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1078">1078</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1081">1081</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1082">1082</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1083">1083</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1084">1084</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1085">1085</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1086">1086</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1092">1092</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1096">1096</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1105">1105</a>.</li>
<li>Changed the following issues from Review to NAD Concepts: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1001">1001</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1005">1005</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1080">1080</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1087">1087</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1111">1111</a>.</li>
<li>Changed the following issues from Tentatively NAD to NAD Concepts: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#912">912</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#918">918</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1074">1074</a>.</li>
<li>Changed the following issues from Tentatively NAD Editorial to NAD Concepts: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#927">927</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1109">1109</a>.</li>
<li>Changed the following issues from Tentatively Ready to NAD Concepts: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#906">906</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#913">913</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#914">914</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#928">928</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1024">1024</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1063">1063</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1067">1067</a>.</li>
<li>Changed the following issues from Open to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#718">718</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#873">873</a>.</li>
<li>Changed the following issues from Tentatively NAD Editorial to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#424">424</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#825">825</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#830">830</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#837">837</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#862">862</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#867">867</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#884">884</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#945">945</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#952">952</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#969">969</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#972">972</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#973">973</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#979">979</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1023">1023</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1058">1058</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1060">1060</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1061">1061</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1077">1077</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1101">1101</a>.</li>
<li>Changed the following issues from Tentatively Ready to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1013">1013</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1107">1107</a>.</li>
<li>Changed the following issues from Open to NAD Future: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#255">255</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#423">423</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#523">523</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#708">708</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#760">760</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#839">839</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#877">877</a>.</li>
<li>Changed the following issues from CD1 to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#823">823</a>.</li>
<li>Changed the following issues from NAD Editorial to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#299">299</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#484">484</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#532">532</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#556">556</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#594">594</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#631">631</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#676">676</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#704">704</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#724">724</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#742">742</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#811">811</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#870">870</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#872">872</a>.</li>
<li>Changed the following issues from Review to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#879">879</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#919">919</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#929">929</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#939">939</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#987">987</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1009">1009</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1093">1093</a>.</li>
<li>Changed the following issues from Tentatively NAD to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#458">458</a>.</li>
<li>Changed the following issues from Tentatively NAD Future to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#96">96</a>.</li>
<li>Changed the following issues from Tentatively Ready to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#910">910</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#915">915</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#932">932</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#940">940</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#974">974</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#976">976</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#999">999</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1011">1011</a>.</li>
<li>Changed the following issues from Open to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#149">149</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#419">419</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#430">430</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#498">498</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#564">564</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#565">565</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#630">630</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#659">659</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#696">696</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#711">711</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#716">716</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#723">723</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#788">788</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#834">834</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#838">838</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#847">847</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#857">857</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#859">859</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#876">876</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#881">881</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#883">883</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#886">886</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1004">1004</a>.</li>
<li>Changed the following issues from Review to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#780">780</a>.</li>
<li>Changed the following issues from Tentatively NAD to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#822">822</a>.</li>
<li>Changed the following issues from Tentatively Ready to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#934">934</a>.</li>
<li>Changed the following issues from NAD to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#871">871</a>.</li>
<li>Changed the following issues from Open to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#397">397</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#408">408</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#473">473</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#671">671</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#836">836</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#868">868</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#889">889</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#893">893</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#930">930</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#954">954</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#962">962</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#967">967</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#968">968</a>.</li>
<li>Changed the following issues from Tentatively NAD to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#668">668</a>.</li>
<li>Changed the following issues from Tentatively Ready to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#950">950</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1100">1100</a>.</li>
<li>Changed the following issues from Open to Tentatively NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#588">588</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#617">617</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#625">625</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#971">971</a>.</li>
<li>Changed the following issues from Open to Tentatively NAD Future: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1031">1031</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1062">1062</a>.</li>
<li>Changed the following issues from Open to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1012">1012</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1019">1019</a>.</li>
<li>Changed the following issues from Tentatively Ready to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#688">688</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#765">765</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#810">810</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#814">814</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#853">853</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#869">869</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#878">878</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#888">888</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#890">890</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#898">898</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#899">899</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#904">904</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#907">907</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#909">909</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#922">922</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#925">925</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#931">931</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#938">938</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#943">943</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#948">948</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#949">949</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#965">965</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#970">970</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#975">975</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#981">981</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#982">982</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#984">984</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#986">986</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#990">990</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#991">991</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#993">993</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#994">994</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#997">997</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#998">998</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1006">1006</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1014">1014</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1021">1021</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1037">1037</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1038">1038</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1039">1039</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1040">1040</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1044">1044</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1045">1045</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1065">1065</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1066">1066</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1070">1070</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1073">1073</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1103">1103</a>.</li>
</ul></li>
</ul>
</li>
<li>R65: 
2009-06-19 pre-Frankfurt mailing.
<ul>
<li><b>Summary:</b><ul>
<li>378 open issues, up by 32.</li>
<li>765 closed issues, up by 0.</li>
<li>1143 issues total, up by 32.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1115">1115</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1116">1116</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1117">1117</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1118">1118</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1119">1119</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1120">1120</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1121">1121</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1122">1122</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1123">1123</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1124">1124</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1125">1125</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1126">1126</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1127">1127</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1128">1128</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1129">1129</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1130">1130</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1131">1131</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1132">1132</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1133">1133</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1134">1134</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1135">1135</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1136">1136</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1137">1137</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1138">1138</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1139">1139</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1140">1140</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1141">1141</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1142">1142</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1143">1143</a>.</li>
<li>Added the following Open issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1112">1112</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1113">1113</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1114">1114</a>.</li>
<li>Changed the following issues from Pending NAD Editorial to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#937">937</a>.</li>
<li>Changed the following issues from New to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#696">696</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#716">716</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#727">727</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#865">865</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#900">900</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#911">911</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#916">916</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#917">917</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#920">920</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#933">933</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#935">935</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#941">941</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#947">947</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#951">951</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#953">953</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#954">954</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#955">955</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#956">956</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#977">977</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#978">978</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#985">985</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#989">989</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#996">996</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1033">1033</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1054">1054</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1056">1056</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1057">1057</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1059">1059</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1062">1062</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1068">1068</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1069">1069</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1071">1071</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1072">1072</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1076">1076</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1090">1090</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1092">1092</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1096">1096</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1098">1098</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1099">1099</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1105">1105</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1106">1106</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1108">1108</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1110">1110</a>.</li>
<li>Changed the following issues from Review to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#817">817</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#971">971</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#992">992</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1004">1004</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1010">1010</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1012">1012</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1015">1015</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1019">1019</a>.</li>
<li>Changed the following issues from New to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#780">780</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#835">835</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#897">897</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#919">919</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#939">939</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#957">957</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#983">983</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1001">1001</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1080">1080</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1091">1091</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1093">1093</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1094">1094</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1095">1095</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1097">1097</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1102">1102</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1104">1104</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1111">1111</a>.</li>
<li>Changed the following issues from Open to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#921">921</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#987">987</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1087">1087</a>.</li>
<li>Changed the following issues from New to Tentatively NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#568">568</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#701">701</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#702">702</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#785">785</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#863">863</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#903">903</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#912">912</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#918">918</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#946">946</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#995">995</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1074">1074</a>.</li>
<li>Changed the following issues from Open to Tentatively NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#458">458</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#644">644</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#667">667</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#668">668</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#669">669</a>.</li>
<li>Changed the following issues from Review to Tentatively NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#901">901</a>.</li>
<li>Changed the following issues from Tentatively Ready to Tentatively NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#822">822</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#988">988</a>.</li>
<li>Changed the following issues from New to Tentatively NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#837">837</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#862">862</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#867">867</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#927">927</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#945">945</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#952">952</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#969">969</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#972">972</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#973">973</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#979">979</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1058">1058</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1060">1060</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1061">1061</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1077">1077</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1101">1101</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1109">1109</a>.</li>
<li>Changed the following issues from Open to Tentatively NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#424">424</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#825">825</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#830">830</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#884">884</a>.</li>
<li>Changed the following issues from Review to Tentatively NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1023">1023</a>.</li>
<li>Changed the following issues from Open to Tentatively NAD Future: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#96">96</a>.</li>
<li>Changed the following issues from New to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#810">810</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#898">898</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#906">906</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#910">910</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#913">913</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#914">914</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#915">915</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#925">925</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#974">974</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#976">976</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#981">981</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#982">982</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#984">984</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#990">990</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#998">998</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#999">999</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1063">1063</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1067">1067</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1070">1070</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1073">1073</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1100">1100</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1103">1103</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1107">1107</a>.</li>
<li>Changed the following issues from Open to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#688">688</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#814">814</a>.</li>
<li>Changed the following issues from Review to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#899">899</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#907">907</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#909">909</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#934">934</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#938">938</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#940">940</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#943">943</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#950">950</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#965">965</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#970">970</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#975">975</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#986">986</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#991">991</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#993">993</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#994">994</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#997">997</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1002">1002</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1006">1006</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1011">1011</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1013">1013</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1014">1014</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1021">1021</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1024">1024</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1037">1037</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1038">1038</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1039">1039</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1040">1040</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1044">1044</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1045">1045</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1065">1065</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1066">1066</a>.</li>
</ul></li>
</ul>
</li>
<li>R64: 
2009-05-01 mid-term mailing.
<ul>
<li><b>Summary:</b><ul>
<li>346 open issues, up by 19.</li>
<li>765 closed issues, up by 0.</li>
<li>1111 issues total, up by 19.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1093">1093</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1094">1094</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1095">1095</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1096">1096</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1097">1097</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1098">1098</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1099">1099</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1100">1100</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1101">1101</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1102">1102</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1103">1103</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1104">1104</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1105">1105</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1106">1106</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1107">1107</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1108">1108</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1109">1109</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1110">1110</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1111">1111</a>.</li>
<li>Changed the following issues from DR to CD1: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#130">130</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#386">386</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#406">406</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#409">409</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#413">413</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#434">434</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#438">438</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#444">444</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#445">445</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#455">455</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#457">457</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#460">460</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#469">469</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#533">533</a>.</li>
<li>Changed the following issues from Review to New: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1070">1070</a>.</li>
</ul></li>
</ul>
</li>
<li>R63: 
2009-03-20 post-Summit mailing.
<ul>
<li><b>Summary:</b><ul>
<li>327 open issues, up by 96.</li>
<li>765 closed issues, up by 14.</li>
<li>1092 issues total, up by 110.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following NAD Editorial issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1022">1022</a>.</li>
<li>Added the following NAD Future issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1025">1025</a>.</li>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#983">983</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#984">984</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#985">985</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#989">989</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#990">990</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#995">995</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#996">996</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#998">998</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#999">999</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1001">1001</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1033">1033</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1054">1054</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1056">1056</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1057">1057</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1058">1058</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1059">1059</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1060">1060</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1061">1061</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1062">1062</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1063">1063</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1067">1067</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1068">1068</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1069">1069</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1071">1071</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1072">1072</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1073">1073</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1074">1074</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1076">1076</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1077">1077</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1080">1080</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1090">1090</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1091">1091</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1092">1092</a>.</li>
<li>Added the following Open issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#987">987</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1000">1000</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1007">1007</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1008">1008</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1016">1016</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1017">1017</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1018">1018</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1020">1020</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1026">1026</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1027">1027</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1028">1028</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1029">1029</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1030">1030</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1031">1031</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1032">1032</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1034">1034</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1035">1035</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1036">1036</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1041">1041</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1042">1042</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1046">1046</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1048">1048</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1051">1051</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1052">1052</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1053">1053</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1055">1055</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1064">1064</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1075">1075</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1078">1078</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1079">1079</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1081">1081</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1082">1082</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1083">1083</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1084">1084</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1085">1085</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1086">1086</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1087">1087</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1088">1088</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1089">1089</a>.</li>
<li>Added the following Review issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#986">986</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#991">991</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#992">992</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#993">993</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#994">994</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#997">997</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1002">1002</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1003">1003</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1004">1004</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1005">1005</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1006">1006</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1009">1009</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1010">1010</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1011">1011</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1012">1012</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1013">1013</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1014">1014</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1015">1015</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1019">1019</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1021">1021</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1023">1023</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1024">1024</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1037">1037</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1038">1038</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1039">1039</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1040">1040</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1043">1043</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1044">1044</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1045">1045</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1047">1047</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1049">1049</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1050">1050</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1065">1065</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1066">1066</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1070">1070</a>.</li>
<li>Added the following Tentatively Ready issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#988">988</a>.</li>
<li>Changed the following issues from New to Dup: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#905">905</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#942">942</a>.</li>
<li>Changed the following issues from New to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#980">980</a>.</li>
<li>Changed the following issues from New to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#874">874</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#875">875</a>.</li>
<li>Changed the following issues from Open to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#732">732</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#793">793</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#794">794</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#800">800</a>.</li>
<li>Changed the following issues from Pending NAD Editorial to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#683">683</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#892">892</a>.</li>
<li>Changed the following issues from Ready to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#803">803</a>.</li>
<li>Changed the following issues from NAD to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#466">466</a>.</li>
<li>Changed the following issues from NAD Future to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#111">111</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#138">138</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#149">149</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#219">219</a>.</li>
<li>Changed the following issues from New to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#880">880</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#891">891</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#893">893</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#902">902</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#908">908</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#921">921</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#923">923</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#924">924</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#926">926</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#930">930</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#936">936</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#944">944</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#958">958</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#959">959</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#960">960</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#961">961</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#962">962</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#963">963</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#964">964</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#966">966</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#967">967</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#968">968</a>.</li>
<li>Changed the following issues from Ready to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#788">788</a>.</li>
<li>Changed the following issues from New to Pending NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#937">937</a>.</li>
<li>Changed the following issues from New to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#879">879</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#899">899</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#901">901</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#907">907</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#909">909</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#929">929</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#934">934</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#938">938</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#940">940</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#943">943</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#950">950</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#965">965</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#970">970</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#971">971</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#975">975</a>.</li>
<li>Changed the following issues from Open to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#817">817</a>.</li>
<li>Changed the following issues from New to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#904">904</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#922">922</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#928">928</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#931">931</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#932">932</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#948">948</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#949">949</a>.</li>
<li>Changed the following issues from Open to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#890">890</a>.</li>
<li>Changed the following issues from Review to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#765">765</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#822">822</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#853">853</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#869">869</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#878">878</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#888">888</a>.</li>
<li>Changed the following issues from Ready to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#752">752</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#753">753</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#758">758</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#821">821</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#866">866</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#894">894</a>.</li>
</ul></li>
</ul>
</li>
<li>R62: 
2009-02-06 pre-Summit mailing.
<ul>
<li><b>Summary:</b><ul>
<li>231 open issues, up by 44.</li>
<li>751 closed issues, up by 0.</li>
<li>982 issues total, up by 44.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#939">939</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#940">940</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#941">941</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#942">942</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#943">943</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#944">944</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#945">945</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#946">946</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#947">947</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#948">948</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#949">949</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#950">950</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#951">951</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#952">952</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#953">953</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#954">954</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#955">955</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#956">956</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#957">957</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#958">958</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#959">959</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#960">960</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#961">961</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#962">962</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#963">963</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#964">964</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#965">965</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#966">966</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#967">967</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#968">968</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#969">969</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#970">970</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#971">971</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#972">972</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#973">973</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#974">974</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#975">975</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#976">976</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#977">977</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#978">978</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#979">979</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#980">980</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#981">981</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#982">982</a>.</li>
</ul></li>
</ul>
</li>
<li>R61: 
2008-12-05 mid-term mailing.
<ul>
<li><b>Summary:</b><ul>
<li>187 open issues, up by 20.</li>
<li>751 closed issues, up by 0.</li>
<li>938 issues total, up by 20.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#919">919</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#920">920</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#921">921</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#922">922</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#923">923</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#924">924</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#925">925</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#926">926</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#927">927</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#928">928</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#929">929</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#930">930</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#931">931</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#932">932</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#933">933</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#934">934</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#935">935</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#936">936</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#937">937</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#938">938</a>.</li>
</ul></li>
</ul>
</li>
<li>R60: 
2008-10-03 post-San Francisco mailing.
<ul>
<li><b>Summary:</b><ul>
<li>167 open issues, down by 25.</li>
<li>751 closed issues, up by 65.</li>
<li>918 issues total, up by 40.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following CD1 issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#882">882</a>.</li>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#879">879</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#880">880</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#891">891</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#893">893</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#897">897</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#898">898</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#899">899</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#900">900</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#901">901</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#902">902</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#903">903</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#904">904</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#905">905</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#906">906</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#907">907</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#908">908</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#909">909</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#910">910</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#911">911</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#912">912</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#913">913</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#914">914</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#915">915</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#916">916</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#917">917</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#918">918</a>.</li>
<li>Added the following Open issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#881">881</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#883">883</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#884">884</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#885">885</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#886">886</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#887">887</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#889">889</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#890">890</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#895">895</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#896">896</a>.</li>
<li>Added the following Pending NAD Editorial issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#892">892</a>.</li>
<li>Added the following Ready issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#894">894</a>.</li>
<li>Added the following Review issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#888">888</a>.</li>
<li>Changed the following issues from New to CD1: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#818">818</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#820">820</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#843">843</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#845">845</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#846">846</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#856">856</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#858">858</a>.</li>
<li>Changed the following issues from Ready to CD1: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#180">180</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#387">387</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#396">396</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#522">522</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#629">629</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#691">691</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#713">713</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#714">714</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#720">720</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#728">728</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#762">762</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#769">769</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#771">771</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#772">772</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#776">776</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#779">779</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#787">787</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#805">805</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#806">806</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#807">807</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#808">808</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#809">809</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#813">813</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#824">824</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#829">829</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#842">842</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#844">844</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#848">848</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#850">850</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#852">852</a>.</li>
<li>Changed the following issues from Review to CD1: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#23">23</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#675">675</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#692">692</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#698">698</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#709">709</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#734">734</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#804">804</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#823">823</a>.</li>
<li>Changed the following issues from WP to CD1: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#44">44</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#49">49</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#76">76</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#91">91</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#92">92</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#98">98</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#103">103</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#109">109</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#117">117</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#118">118</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#120">120</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#123">123</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#136">136</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#153">153</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#165">165</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#167">167</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#171">171</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#179">179</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#182">182</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#183">183</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#184">184</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#185">185</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#186">186</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#187">187</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#198">198</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#200">200</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#201">201</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#202">202</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#206">206</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#214">214</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#221">221</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#225">225</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#226">226</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#228">228</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#229">229</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#230">230</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#231">231</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#232">232</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#233">233</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#234">234</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#235">235</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#237">237</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#238">238</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#239">239</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#240">240</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#241">241</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#242">242</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#243">243</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#247">247</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#248">248</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#250">250</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#251">251</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#252">252</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#253">253</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#254">254</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#256">256</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#258">258</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#259">259</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#260">260</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#261">261</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#262">262</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#263">263</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#264">264</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#265">265</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#266">266</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#268">268</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#270">270</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#271">271</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#272">272</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#273">273</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#274">274</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#275">275</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#276">276</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#278">278</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#280">280</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#281">281</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#282">282</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#283">283</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#284">284</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#285">285</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#286">286</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#288">288</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#291">291</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#292">292</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#294">294</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#295">295</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#297">297</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#298">298</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#300">300</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#301">301</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#303">303</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#305">305</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#306">306</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#307">307</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#308">308</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#310">310</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#311">311</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#312">312</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#315">315</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#316">316</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#317">317</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#318">318</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#319">319</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#320">320</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#321">321</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#322">322</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#324">324</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#325">325</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#327">327</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#328">328</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#329">329</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#331">331</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#333">333</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#334">334</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#335">335</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#336">336</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#337">337</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#338">338</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#339">339</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#340">340</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#341">341</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#345">345</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#346">346</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#347">347</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#349">349</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#352">352</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#354">354</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#355">355</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#358">358</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#359">359</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#360">360</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#362">362</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#363">363</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#364">364</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#365">365</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#369">369</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#370">370</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#371">371</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#373">373</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#375">375</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#376">376</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#379">379</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#380">380</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#381">381</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#383">383</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#384">384</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#389">389</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#391">391</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#395">395</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#400">400</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#401">401</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#402">402</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#403">403</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#404">404</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#405">405</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#407">407</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#410">410</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#411">411</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#412">412</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#414">414</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#415">415</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#416">416</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#420">420</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#422">422</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#425">425</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#426">426</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#428">428</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#432">432</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#435">435</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#436">436</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#441">441</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#442">442</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#443">443</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#448">448</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#449">449</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#453">453</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#456">456</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#461">461</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#464">464</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#465">465</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#467">467</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#468">468</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#474">474</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#475">475</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#478">478</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#488">488</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#495">495</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#496">496</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#497">497</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#505">505</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#507">507</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#508">508</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#518">518</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#519">519</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#520">520</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#521">521</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#524">524</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#527">527</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#530">530</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#531">531</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#534">534</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#535">535</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#537">537</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#538">538</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#540">540</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#541">541</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#542">542</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#543">543</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#545">545</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#550">550</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#551">551</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#552">552</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#559">559</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#561">561</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#562">562</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#563">563</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#566">566</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#567">567</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#574">574</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#575">575</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#576">576</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#577">577</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#578">578</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#581">581</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#586">586</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#589">589</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#593">593</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#595">595</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#596">596</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#607">607</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#608">608</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#609">609</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#610">610</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#611">611</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#612">612</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#613">613</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#616">616</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#618">618</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#619">619</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#620">620</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#621">621</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#622">622</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#623">623</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#624">624</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#628">628</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#634">634</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#638">638</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#640">640</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#643">643</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#646">646</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#650">650</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#651">651</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#652">652</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#654">654</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#655">655</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#660">660</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#661">661</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#664">664</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#665">665</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#666">666</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#672">672</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#673">673</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#674">674</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#677">677</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#678">678</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#679">679</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#680">680</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#681">681</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#682">682</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#685">685</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#687">687</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#689">689</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#693">693</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#694">694</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#695">695</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#699">699</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#700">700</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#703">703</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#705">705</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#706">706</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#710">710</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#712">712</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#715">715</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#722">722</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#740">740</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#743">743</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#744">744</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#746">746</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#749">749</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#755">755</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#759">759</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#761">761</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#766">766</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#768">768</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#770">770</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#775">775</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#777">777</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#778">778</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#781">781</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#782">782</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#783">783</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#789">789</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#792">792</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#798">798</a>.</li>
<li>Changed the following issues from Open to Dup: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#670">670</a>.</li>
<li>Changed the following issues from New to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#849">849</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#855">855</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#871">871</a>.</li>
<li>Changed the following issues from Open to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#454">454</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#832">832</a>.</li>
<li>Changed the following issues from New to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#811">811</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#812">812</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#841">841</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#864">864</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#870">870</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#872">872</a>.</li>
<li>Changed the following issues from Open to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#299">299</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#484">484</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#556">556</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#631">631</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#676">676</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#704">704</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#724">724</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#742">742</a>.</li>
<li>Changed the following issues from Pending NAD Editorial to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#532">532</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#594">594</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#717">717</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#725">725</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#738">738</a>.</li>
<li>Changed the following issues from New to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#721">721</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#751">751</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#814">814</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#816">816</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#817">817</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#819">819</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#827">827</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#836">836</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#838">838</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#847">847</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#857">857</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#859">859</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#860">860</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#861">861</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#868">868</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#873">873</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#876">876</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#877">877</a>.</li>
<li>Changed the following issues from Pending NAD Editorial to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#424">424</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#625">625</a>.</li>
<li>Changed the following issues from Review to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#851">851</a>.</li>
<li>Changed the following issues from New to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#788">788</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#821">821</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#866">866</a>.</li>
<li>Changed the following issues from Open to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#753">753</a>.</li>
<li>Changed the following issues from Review to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#752">752</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#758">758</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#803">803</a>.</li>
<li>Changed the following issues from New to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#765">765</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#822">822</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#853">853</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#854">854</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#869">869</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#878">878</a>.</li>
<li>Changed the following issues from TC to TC1: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1">1</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#3">3</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#5">5</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#7">7</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#8">8</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#9">9</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#11">11</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#13">13</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#14">14</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#15">15</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#16">16</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#17">17</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#18">18</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#19">19</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#20">20</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#21">21</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#22">22</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#24">24</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#25">25</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#26">26</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#27">27</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#28">28</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#29">29</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#30">30</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#31">31</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#32">32</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#33">33</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#34">34</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#35">35</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#36">36</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#37">37</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#38">38</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#39">39</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#40">40</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#41">41</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#42">42</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#46">46</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#47">47</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#48">48</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#50">50</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#51">51</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#52">52</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#53">53</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#54">54</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#55">55</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#56">56</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#57">57</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#59">59</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#60">60</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#61">61</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#62">62</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#63">63</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#64">64</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#66">66</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#68">68</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#69">69</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#70">70</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#71">71</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#74">74</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#75">75</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#78">78</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#79">79</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#80">80</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#83">83</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#86">86</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#90">90</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#106">106</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#108">108</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#110">110</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#112">112</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#114">114</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#115">115</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#119">119</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#122">122</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#124">124</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#125">125</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#126">126</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#127">127</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#129">129</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#132">132</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#133">133</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#134">134</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#137">137</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#139">139</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#141">141</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#142">142</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#144">144</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#146">146</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#147">147</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#148">148</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#150">150</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#151">151</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#152">152</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#154">154</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#155">155</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#156">156</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#158">158</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#159">159</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#160">160</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#161">161</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#164">164</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#168">168</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#169">169</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#170">170</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#172">172</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#173">173</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#174">174</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#175">175</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#176">176</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#181">181</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#189">189</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#193">193</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#195">195</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#199">199</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#208">208</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#209">209</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#210">210</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#211">211</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#212">212</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#217">217</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#220">220</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#222">222</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#223">223</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#224">224</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#227">227</a>.</li>
</ul></li>
</ul>
</li>
<li>R59: 
2008-08-22 pre-San Francisco mailing.
<ul>
<li><b>Summary:</b><ul>
<li>192 open issues, up by 9.</li>
<li>686 closed issues, up by 0.</li>
<li>878 issues total, up by 9.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#870">870</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#871">871</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#872">872</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#873">873</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#874">874</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#875">875</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#876">876</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#877">877</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#878">878</a>.</li>
</ul></li>
</ul>
</li>
<li>R58: 
2008-07-28 mid-term mailing.
<ul>
<li><b>Summary:</b><ul>
<li>183 open issues, up by 12.</li>
<li>686 closed issues, down by 4.</li>
<li>869 issues total, up by 8.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#862">862</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#863">863</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#864">864</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#865">865</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#866">866</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#867">867</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#868">868</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#869">869</a>.</li>
<li>Changed the following issues from Pending NAD Editorial to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#393">393</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#557">557</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#592">592</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#754">754</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#757">757</a>.</li>
<li>Changed the following issues from Pending WP to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#644">644</a>.</li>
<li>Changed the following issues from WP to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#387">387</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#629">629</a>.</li>
<li>Changed the following issues from Pending NAD Editorial to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#709">709</a>.</li>
</ul></li>
</ul>
</li>
<li>R57: 
2008-06-27 post-Sophia Antipolis mailing.
<ul>
<li><b>Summary:</b><ul>
<li>171 open issues, down by 20.</li>
<li>690 closed issues, up by 43.</li>
<li>861 issues total, up by 23.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following NAD issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#840">840</a>.</li>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#841">841</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#843">843</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#845">845</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#846">846</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#847">847</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#849">849</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#853">853</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#854">854</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#855">855</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#856">856</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#857">857</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#858">858</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#859">859</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#860">860</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#861">861</a>.</li>
<li>Added the following Open issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#839">839</a>.</li>
<li>Added the following Ready issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#842">842</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#844">844</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#848">848</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#850">850</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#852">852</a>.</li>
<li>Added the following Review issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#851">851</a>.</li>
<li>Changed the following issues from New to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#826">826</a>.</li>
<li>Changed the following issues from Open to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#570">570</a>.</li>
<li>Changed the following issues from New to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#786">786</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#831">831</a>.</li>
<li>Changed the following issues from Open to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#756">756</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#767">767</a>.</li>
<li>Changed the following issues from New to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#723">723</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#726">726</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#794">794</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#815">815</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#825">825</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#830">830</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#833">833</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#834">834</a>.</li>
<li>Changed the following issues from Ready to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#471">471</a>.</li>
<li>Changed the following issues from Review to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#539">539</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#711">711</a>.</li>
<li>Changed the following issues from New to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#713">713</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#714">714</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#769">769</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#772">772</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#779">779</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#787">787</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#805">805</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#806">806</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#807">807</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#808">808</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#809">809</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#813">813</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#824">824</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#829">829</a>.</li>
<li>Changed the following issues from Open to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#180">180</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#396">396</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#522">522</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#720">720</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#762">762</a>.</li>
<li>Changed the following issues from Review to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#691">691</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#728">728</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#771">771</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#776">776</a>.</li>
<li>Changed the following issues from New to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#692">692</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#698">698</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#752">752</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#804">804</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#823">823</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#828">828</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#832">832</a>.</li>
<li>Changed the following issues from Open to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#23">23</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#675">675</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#734">734</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#803">803</a>.</li>
<li>Changed the following issues from Ready to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#758">758</a>.</li>
<li>Changed the following issues from Ready to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#387">387</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#518">518</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#550">550</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#574">574</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#595">595</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#596">596</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#612">612</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#618">618</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#629">629</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#638">638</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#672">672</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#673">673</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#685">685</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#710">710</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#715">715</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#722">722</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#740">740</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#743">743</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#744">744</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#746">746</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#749">749</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#755">755</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#759">759</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#761">761</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#766">766</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#768">768</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#770">770</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#775">775</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#777">777</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#778">778</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#781">781</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#782">782</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#783">783</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#789">789</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#792">792</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#798">798</a>.</li>
</ul></li>
</ul>
</li>
<li>R56: 
2008-05-16 pre-Sophia Antipolis mailing.
<ul>
<li><b>Summary:</b><ul>
<li>191 open issues, up by 24.</li>
<li>647 closed issues, up by 1.</li>
<li>838 issues total, up by 25.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#814">814</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#815">815</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#816">816</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#817">817</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#818">818</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#819">819</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#820">820</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#821">821</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#822">822</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#823">823</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#824">824</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#825">825</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#826">826</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#827">827</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#828">828</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#829">829</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#830">830</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#831">831</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#832">832</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#833">833</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#834">834</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#835">835</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#836">836</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#837">837</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#838">838</a>.</li>
<li>Changed the following issues from New to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#802">802</a>.</li>
</ul></li>
</ul>
</li>
<li>R55: 
2008-03-14 post-Bellevue mailing.
<ul>
<li><b>Summary:</b><ul>
<li>167 open issues, down by 39.</li>
<li>646 closed issues, up by 65.</li>
<li>813 issues total, up by 26.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following Dup issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#795">795</a>.</li>
<li>Added the following NAD issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#790">790</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#791">791</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#796">796</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#797">797</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#799">799</a>.</li>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#788">788</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#794">794</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#802">802</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#804">804</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#805">805</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#806">806</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#807">807</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#808">808</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#809">809</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#810">810</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#811">811</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#812">812</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#813">813</a>.</li>
<li>Added the following Open issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#793">793</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#800">800</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#801">801</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#803">803</a>.</li>
<li>Added the following Ready issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#789">789</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#792">792</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#798">798</a>.</li>
<li>Changed the following issues from NAD Future to Dup: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#116">116</a>.</li>
<li>Changed the following issues from NAD Future to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#188">188</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#323">323</a>.</li>
<li>Changed the following issues from New to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#729">729</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#730">730</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#731">731</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#733">733</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#735">735</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#736">736</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#737">737</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#739">739</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#741">741</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#745">745</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#748">748</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#763">763</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#764">764</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#773">773</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#784">784</a>.</li>
<li>Changed the following issues from Open to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#388">388</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#462">462</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#579">579</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#627">627</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#653">653</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#686">686</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#707">707</a>.</li>
<li>Changed the following issues from NAD Future to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#140">140</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#390">390</a>.</li>
<li>Changed the following issues from Open to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#529">529</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#626">626</a>.</li>
<li>Changed the following issues from Review to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#645">645</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#684">684</a>.</li>
<li>Changed the following issues from NAD Future to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#128">128</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#180">180</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#190">190</a>.</li>
<li>Changed the following issues from New to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#617">617</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#718">718</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#719">719</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#720">720</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#724">724</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#732">732</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#734">734</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#742">742</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#747">747</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#750">750</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#753">753</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#756">756</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#760">760</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#762">762</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#767">767</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#774">774</a>.</li>
<li>Changed the following issues from Ready to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#675">675</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#676">676</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#688">688</a>.</li>
<li>Changed the following issues from New to Pending NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#709">709</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#717">717</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#725">725</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#738">738</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#754">754</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#757">757</a>.</li>
<li>Changed the following issues from Open to Pending NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#424">424</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#557">557</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#625">625</a>.</li>
<li>Changed the following issues from New to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#710">710</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#715">715</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#722">722</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#740">740</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#743">743</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#744">744</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#746">746</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#749">749</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#755">755</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#758">758</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#759">759</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#761">761</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#766">766</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#768">768</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#770">770</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#775">775</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#777">777</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#778">778</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#781">781</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#782">782</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#783">783</a>.</li>
<li>Changed the following issues from Open to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#387">387</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#471">471</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#550">550</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#612">612</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#629">629</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#673">673</a>.</li>
<li>Changed the following issues from Review to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#518">518</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#574">574</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#596">596</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#618">618</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#638">638</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#672">672</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#685">685</a>.</li>
<li>Changed the following issues from New to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#711">711</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#728">728</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#771">771</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#776">776</a>.</li>
<li>Changed the following issues from Open to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#539">539</a>.</li>
<li>Changed the following issues from Ready to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#561">561</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#562">562</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#563">563</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#567">567</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#581">581</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#620">620</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#621">621</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#622">622</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#623">623</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#624">624</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#661">661</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#664">664</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#665">665</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#666">666</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#674">674</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#679">679</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#680">680</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#687">687</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#689">689</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#693">693</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#694">694</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#695">695</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#700">700</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#703">703</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#705">705</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#706">706</a>.</li>
<li>Changed the following issues from Tentatively Ready to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#527">527</a>.</li>
</ul></li>
</ul>
</li>
<li>R54: 
2008-02-01 pre-Bellevue mailing.
<ul>
<li><b>Summary:</b><ul>
<li>206 open issues, up by 23.</li>
<li>581 closed issues, up by 0.</li>
<li>787 issues total, up by 23.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#765">765</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#766">766</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#767">767</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#768">768</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#769">769</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#770">770</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#771">771</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#772">772</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#773">773</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#774">774</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#775">775</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#776">776</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#777">777</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#778">778</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#779">779</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#780">780</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#781">781</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#782">782</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#783">783</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#784">784</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#785">785</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#786">786</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#787">787</a>.</li>
<li>Changed the following issues from NAD Future to Dup: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#105">105</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#348">348</a>.</li>
<li>Changed the following issues from NAD Future to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#353">353</a>.</li>
<li>Changed the following issues from New to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#697">697</a>.</li>
<li>Changed the following issues from NAD Future to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#388">388</a>.</li>
<li>Changed the following issues from Open to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#527">527</a>.</li>
</ul></li>
</ul>
</li>
<li>R53: 
2007-12-09 mid-term mailing.
<ul>
<li><b>Summary:</b><ul>
<li>183 open issues, up by 11.</li>
<li>581 closed issues, down by 1.</li>
<li>764 issues total, up by 10.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#755">755</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#756">756</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#757">757</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#758">758</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#759">759</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#760">760</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#761">761</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#762">762</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#763">763</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#764">764</a>.</li>
<li>Changed the following issues from NAD to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#463">463</a>.</li>
<li>Changed the following issues from Pending WP to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#607">607</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#608">608</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#654">654</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#655">655</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#677">677</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#682">682</a>.</li>
</ul></li>
</ul>
</li>
<li>R52: 
2007-10-19 post-Kona mailing.
<ul>
<li><b>Summary:</b><ul>
<li>172 open issues, up by 4.</li>
<li>582 closed issues, up by 27.</li>
<li>754 issues total, up by 31.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#724">724</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#725">725</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#726">726</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#727">727</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#728">728</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#729">729</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#730">730</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#731">731</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#732">732</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#733">733</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#734">734</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#735">735</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#736">736</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#737">737</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#738">738</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#739">739</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#740">740</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#741">741</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#742">742</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#743">743</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#744">744</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#745">745</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#746">746</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#747">747</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#748">748</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#749">749</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#750">750</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#751">751</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#752">752</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#753">753</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#754">754</a>.</li>
<li>Changed the following issues from NAD Future to Dup: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#77">77</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#350">350</a>.</li>
<li>Changed the following issues from New to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#639">639</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#657">657</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#663">663</a>.</li>
<li>Changed the following issues from Open to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#548">548</a>.</li>
<li>Changed the following issues from New to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#546">546</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#550">550</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#564">564</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#565">565</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#573">573</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#585">585</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#588">588</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#627">627</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#629">629</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#630">630</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#632">632</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#635">635</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#653">653</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#659">659</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#667">667</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#668">668</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#669">669</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#670">670</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#671">671</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#673">673</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#686">686</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#704">704</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#707">707</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#708">708</a>.</li>
<li>Changed the following issues from New to Pending NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#393">393</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#592">592</a>.</li>
<li>Changed the following issues from New to Pending WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#607">607</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#608">608</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#654">654</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#655">655</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#677">677</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#682">682</a>.</li>
<li>Changed the following issues from New to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#561">561</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#562">562</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#563">563</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#567">567</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#581">581</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#595">595</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#620">620</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#621">621</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#622">622</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#623">623</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#624">624</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#661">661</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#664">664</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#665">665</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#666">666</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#674">674</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#675">675</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#676">676</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#679">679</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#687">687</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#688">688</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#689">689</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#693">693</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#694">694</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#695">695</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#700">700</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#703">703</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#705">705</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#706">706</a>.</li>
<li>Changed the following issues from Open to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#680">680</a>.</li>
<li>Changed the following issues from New to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#574">574</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#596">596</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#618">618</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#638">638</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#645">645</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#672">672</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#684">684</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#685">685</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#691">691</a>.</li>
<li>Changed the following issues from New to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#552">552</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#634">634</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#650">650</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#651">651</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#652">652</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#678">678</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#681">681</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#699">699</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#712">712</a>.</li>
<li>Changed the following issues from Open to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#258">258</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#401">401</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#524">524</a>.</li>
<li>Changed the following issues from Ready to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#488">488</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#577">577</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#660">660</a>.</li>
</ul></li>
</ul>
</li>
<li>R51: 
2007-09-09 pre-Kona mailing.
<ul>
<li><b>Summary:</b><ul>
<li>168 open issues, up by 15.</li>
<li>555 closed issues, up by 0.</li>
<li>723 issues total, up by 15.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#709">709</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#710">710</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#711">711</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#712">712</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#713">713</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#714">714</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#715">715</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#716">716</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#717">717</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#718">718</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#719">719</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#720">720</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#721">721</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#722">722</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#723">723</a>.</li>
</ul></li>
</ul>
</li>
<li>R50: 
2007-08-05 post-Toronto mailing.
<ul>
<li><b>Summary:</b><ul>
<li>153 open issues, down by 5.</li>
<li>555 closed issues, up by 17.</li>
<li>708 issues total, up by 12.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#697">697</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#698">698</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#699">699</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#700">700</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#701">701</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#702">702</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#703">703</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#704">704</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#705">705</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#706">706</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#707">707</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#708">708</a>.</li>
<li>Changed the following issues from New to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#583">583</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#584">584</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#662">662</a>.</li>
<li>Changed the following issues from Open to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#528">528</a>.</li>
<li>Changed the following issues from New to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#637">637</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#647">647</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#658">658</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#690">690</a>.</li>
<li>Changed the following issues from Open to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#525">525</a>.</li>
<li>Changed the following issues from Pending NAD Editorial to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#553">553</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#571">571</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#591">591</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#633">633</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#636">636</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#641">641</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#642">642</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#648">648</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#649">649</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#656">656</a>.</li>
<li>Changed the following issues from New to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#579">579</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#631">631</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#680">680</a>.</li>
<li>Changed the following issues from Pending WP to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#258">258</a>.</li>
<li>Changed the following issues from Ready to Pending WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#644">644</a>.</li>
<li>Changed the following issues from New to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#577">577</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#660">660</a>.</li>
<li>Changed the following issues from Open to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#488">488</a>.</li>
<li>Changed the following issues from Open to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#518">518</a>.</li>
<li>Changed the following issues from Ready to TRDec: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#604">604</a>.</li>
<li>Changed the following issues from DR to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#453">453</a>.</li>
<li>Changed the following issues from Ready to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#531">531</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#551">551</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#566">566</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#628">628</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#640">640</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#643">643</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#646">646</a>.</li>
</ul></li>
</ul>
</li>
<li>R49: 
2007-06-23 pre-Toronto mailing.
<ul>
<li><b>Summary:</b><ul>
<li>158 open issues, up by 13.</li>
<li>538 closed issues, up by 7.</li>
<li>696 issues total, up by 20.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#677">677</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#678">678</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#679">679</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#680">680</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#681">681</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#682">682</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#684">684</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#685">685</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#686">686</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#687">687</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#688">688</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#689">689</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#690">690</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#691">691</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#692">692</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#693">693</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#694">694</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#695">695</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#696">696</a>.</li>
<li>Added the following Pending NAD Editorial issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#683">683</a>.</li>
<li>Changed the following issues from New to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#587">587</a>.</li>
<li>Changed the following issues from Open to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#590">590</a>.</li>
<li>Changed the following issues from New to Pending NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#636">636</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#642">642</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#648">648</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#649">649</a>.</li>
</ul></li>
</ul>
</li>
<li>R48: 
2007-05-06 post-Oxford mailing.
<ul>
<li><b>Summary:</b><ul>
<li>145 open issues, down by 33.</li>
<li>531 closed issues, up by 53.</li>
<li>676 issues total, up by 20.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#657">657</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#658">658</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#659">659</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#660">660</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#661">661</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#662">662</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#663">663</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#664">664</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#665">665</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#666">666</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#667">667</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#668">668</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#669">669</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#670">670</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#671">671</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#672">672</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#673">673</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#674">674</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#675">675</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#676">676</a>.</li>
<li>Changed the following issues from Tentatively Ready to Dup: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#479">479</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#536">536</a>.</li>
<li>Changed the following issues from Tentatively Ready to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#385">385</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#463">463</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#466">466</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#470">470</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#515">515</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#526">526</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#547">547</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#560">560</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#572">572</a>.</li>
<li>Changed the following issues from NAD to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#351">351</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#357">357</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#368">368</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#499">499</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#504">504</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#512">512</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#513">513</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#514">514</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#516">516</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#544">544</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#549">549</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#555">555</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#558">558</a>.</li>
<li>Changed the following issues from Tentatively Ready to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#482">482</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#615">615</a>.</li>
<li>Changed the following issues from NAD_Future to NAD Future: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#77">77</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#105">105</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#111">111</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#116">116</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#128">128</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#138">138</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#140">140</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#149">149</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#180">180</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#188">188</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#190">190</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#219">219</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#323">323</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#348">348</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#350">350</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#353">353</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#388">388</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#390">390</a>.</li>
<li>Changed the following issues from Tentatively Ready to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#471">471</a>.</li>
<li>Changed the following issues from New to Pending NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#633">633</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#641">641</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#656">656</a>.</li>
<li>Changed the following issues from Tentatively Ready to Pending NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#532">532</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#553">553</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#571">571</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#591">591</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#594">594</a>.</li>
<li>Changed the following issues from Tentatively Ready to Pending WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#258">258</a>.</li>
<li>Changed the following issues from New to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#566">566</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#628">628</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#640">640</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#643">643</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#644">644</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#646">646</a>.</li>
<li>Changed the following issues from Review to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#531">531</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#551">551</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#604">604</a>.</li>
<li>Changed the following issues from Ready to TRDec: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#598">598</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#599">599</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#600">600</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#601">601</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#602">602</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#603">603</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#605">605</a>.</li>
<li>Changed the following issues from Ready to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#543">543</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#545">545</a>.</li>
<li>Changed the following issues from Tentatively Ready to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#201">201</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#206">206</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#233">233</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#254">254</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#416">416</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#422">422</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#456">456</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#534">534</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#542">542</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#559">559</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#575">575</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#576">576</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#578">578</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#586">586</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#589">589</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#593">593</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#609">609</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#610">610</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#611">611</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#613">613</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#616">616</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#619">619</a>.</li>
</ul></li>
</ul>
</li>
<li>R47: 
2007-03-09 pre-Oxford mailing.
<ul>
<li><b>Summary:</b><ul>
<li>178 open issues, up by 37.</li>
<li>478 closed issues, up by 0.</li>
<li>656 issues total, up by 37.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#620">620</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#621">621</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#622">622</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#623">623</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#624">624</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#627">627</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#628">628</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#629">629</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#630">630</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#631">631</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#632">632</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#633">633</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#634">634</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#635">635</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#636">636</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#637">637</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#638">638</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#639">639</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#640">640</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#641">641</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#642">642</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#643">643</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#644">644</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#645">645</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#646">646</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#647">647</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#648">648</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#649">649</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#650">650</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#651">651</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#652">652</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#653">653</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#654">654</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#655">655</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#656">656</a>.</li>
<li>Added the following Open issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#625">625</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#626">626</a>.</li>
<li>Changed the following issues from New to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#570">570</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#580">580</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#582">582</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#590">590</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#612">612</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#614">614</a>.</li>
<li>Changed the following issues from New to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#547">547</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#553">553</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#560">560</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#571">571</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#572">572</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#575">575</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#576">576</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#578">578</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#586">586</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#589">589</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#591">591</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#593">593</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#594">594</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#609">609</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#610">610</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#611">611</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#613">613</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#615">615</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#616">616</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#619">619</a>.</li>
<li>Changed the following issues from Open to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#201">201</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#206">206</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#233">233</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#254">254</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#258">258</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#385">385</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#416">416</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#422">422</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#456">456</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#463">463</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#466">466</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#470">470</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#471">471</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#479">479</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#482">482</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#515">515</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#526">526</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#532">532</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#536">536</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#542">542</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#559">559</a>.</li>
<li>Changed the following issues from Review to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#534">534</a>.</li>
</ul></li>
</ul>
</li>
<li>R46: 
2007-01-12 mid-term mailing.
<ul>
<li><b>Summary:</b><ul>
<li>141 open issues, up by 11.</li>
<li>478 closed issues, down by 1.</li>
<li>619 issues total, up by 10.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#610">610</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#611">611</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#612">612</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#613">613</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#614">614</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#615">615</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#616">616</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#617">617</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#618">618</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#619">619</a>.</li>
</ul></li>
</ul>
</li>
<li>R45: 
2006-11-03 post-Portland mailing.
<ul>
<li><b>Summary:</b><ul>
<li>130 open issues, up by 0.</li>
<li>479 closed issues, up by 17.</li>
<li>609 issues total, up by 17.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Moved issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#520">520</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#521">521</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#530">530</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#535">535</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#537">537</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#538">538</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#540">540</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#541">541</a> to WP.</li>
<li>Moved issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#504">504</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#512">512</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#516">516</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#544">544</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#549">549</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#554">554</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#555">555</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#558">558</a> to NAD.</li>
<li>Moved issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#569">569</a> to Dup.</li>
<li>Moved issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#518">518</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#523">523</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#524">524</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#542">542</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#556">556</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#557">557</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#559">559</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#597">597</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#606">606</a> to Open.</li>
<li>Moved issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#543">543</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#545">545</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#549">549</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#549">549</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#598">598</a> - <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#603">603</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#605">605</a> to Ready.</li>
<li>Moved issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#531">531</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#551">551</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#604">604</a> to Review.</li>
<li>Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#593">593</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#594">594</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#595">595</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#596">596</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#597">597</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#598">598</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#599">599</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#600">600</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#601">601</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#602">602</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#603">603</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#604">604</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#605">605</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#606">606</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#607">607</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#608">608</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#609">609</a>.</li>
</ul></li>
</ul>
</li>
<li>R44: 
2006-09-08 pre-Portland mailing.
<ul>
<li><b>Summary:</b><ul>
<li>130 open issues, up by 6.</li>
<li>462 closed issues, down by 1.</li>
<li>592 issues total, up by 5.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#583">583</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#584">584</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#585">585</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#586">586</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#587">587</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#588">588</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#589">589</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#590">590</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#591">591</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#592">592</a>.</li>
</ul></li>
</ul>
</li>
<li>R43: 
2006-06-23 mid-term mailing.
<ul>
<li><b>Summary:</b><ul>
<li>124 open issues, up by 14.</li>
<li>463 closed issues, down by 1.</li>
<li>587 issues total, up by 13.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#575">575</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#576">576</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#577">577</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#578">578</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#579">579</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#580">580</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#581">581</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#582">582</a>.</li>
<li>Reopened <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#255">255</a>.</li>
<li>Moved issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#520">520</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#541">541</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#544">544</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#569">569</a> to Tentatively Ready.</li>
</ul></li>
</ul>
</li>
<li>R42: 
2006-04-21 post-Berlin mailing.
<ul>
<li><b>Summary:</b><ul>
<li>110 open issues, down by 16.</li>
<li>464 closed issues, up by 24.</li>
<li>574 issues total, up by 8.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#567">567</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#568">568</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#569">569</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#570">570</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#571">571</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#572">572</a>.</li>
<li>Moved issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#499">499</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#501">501</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#506">506</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#509">509</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#510">510</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#511">511</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#513">513</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#514">514</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#517">517</a> to NAD.</li>
<li>Moved issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#502">502</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#503">503</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#515">515</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#516">516</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#522">522</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#525">525</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#526">526</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#527">527</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#528">528</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#529">529</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#532">532</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#536">536</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#539">539</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#548">548</a> to Open.</li>
<li>Moved issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#504">504</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#512">512</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#521">521</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#530">530</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#531">531</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#535">535</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#537">537</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#538">538</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#540">540</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#549">549</a> to Ready.</li>
<li>Moved issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#247">247</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#294">294</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#362">362</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#369">369</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#371">371</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#376">376</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#384">384</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#475">475</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#478">478</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#495">495</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#497">497</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#505">505</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#507">507</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#508">508</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#519">519</a> to WP.</li>
<li>Moved issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#534">534</a> to Review.</li>
</ul></li>
</ul>
</li>
<li>R41: 
2006-02-24 pre-Berlin mailing.
<ul>
<li><b>Summary:</b><ul>
<li>126 open issues, up by 31.</li>
<li>440 closed issues, up by 0.</li>
<li>566 issues total, up by 31.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#536">536</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#537">537</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#538">538</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#539">539</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#540">540</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#541">541</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#542">542</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#543">543</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#544">544</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#545">545</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#546">546</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#547">547</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#548">548</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#549">549</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#550">550</a> ,<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#551">551</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#552">552</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#553">553</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#554">554</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#555">555</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#556">556</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#557">557</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#558">558</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#559">559</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#560">560</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#561">561</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#562">562</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#563">563</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#564">564</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#565">565</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#566">566</a>.</li>
<li>Moved <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#342">342</a> from Ready to Open.</li>
<li>Reopened <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#309">309</a>.</li>
</ul></li>
</ul>
</li>
<li>R40: 
2005-12-16 mid-term mailing.
<ul>
<li><b>Summary:</b><ul>
<li>95 open issues.</li>
<li>440 closed issues.</li>
<li>535 issues total.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#529">529</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#530">530</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#531">531</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#532">532</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#533">533</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#534">534</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#535">535</a>.</li>
</ul></li>
</ul>
</li>
<li>R39: 
2005-10-14 post-Mont Tremblant mailing.
Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#526">526</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#528">528</a>.
Moved issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#280">280</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#461">461</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#464">464</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#465">465</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#467">467</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#468">468</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#474">474</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#496">496</a> from Ready to WP as per the vote from Mont Tremblant.
Moved issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#247">247</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#294">294</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#342">342</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#362">362</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#369">369</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#371">371</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#376">376</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#384">384</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#475">475</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#478">478</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#495">495</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#497">497</a> from Review to Ready.
Moved issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#498">498</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#504">504</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#506">506</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#509">509</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#510">510</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#511">511</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#512">512</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#513">513</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#514">514</a> from New to Open.
Moved issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#505">505</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#507">507</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#508">508</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#519">519</a> from New to Ready.
Moved issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#500">500</a> from New to NAD.
Moved issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#518">518</a> from New to Review.
</li>
<li>R38: 
2005-07-03 pre-Mont Tremblant mailing.
Merged open TR1 issues in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#504">504</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#522">522</a>.
Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#523">523</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#523">523</a>
</li>
<li>R37: 
2005-06 mid-term mailing.
Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#498">498</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#503">503</a>.
</li>
<li>R36: 
2005-04 post-Lillehammer mailing. All issues in "ready" status except
for <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#454">454</a> were moved to "DR" status, and all issues
previously in "DR" status were moved to "WP".
</li>
<li>R35: 
2005-03 pre-Lillehammer mailing.
</li>
<li>R34: 
2005-01 mid-term mailing.  Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#488">488</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#494">494</a>.
</li>
<li>R33: 
2004-11 post-Redmond mailing. Reflects actions taken in Redmond.
</li>
<li>R32: 
2004-09 pre-Redmond mailing: reflects new proposed resolutions and
new issues received after the 2004-07 mailing.  Added
new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#479">479</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#481">481</a>.
</li>
<li>R31: 
2004-07 mid-term mailing: reflects new proposed resolutions and
new issues received after the post-Sydney mailing.  Added
new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#463">463</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#478">478</a>.
</li>
<li>R30: 
Post-Sydney mailing: reflects decisions made at the Sydney meeting.
Voted all "Ready" issues from R29 into the working paper.
Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#460">460</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#462">462</a>.
</li>
<li>R29: 
Pre-Sydney mailing.  Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#441">441</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#457">457</a>.
</li>
<li>R28: 
Post-Kona mailing: reflects decisions made at the Kona meeting.
Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#432">432</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#440">440</a>.
</li>
<li>R27: 
Pre-Kona mailing.  Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#404">404</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#431">431</a>.
</li>
<li>R26: 
Post-Oxford mailing: reflects decisions made at the Oxford meeting.
All issues in Ready status were voted into DR status.  All issues in
DR status were voted into WP status.
</li>
<li>R25: 
Pre-Oxford mailing.  Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#390">390</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#402">402</a>.
</li>
<li>R24: 
Post-Santa Cruz mailing: reflects decisions made at the Santa Cruz
meeting.  All Ready issues from R23 with the exception of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#253">253</a>, which has been given a new proposed resolution, were
moved to DR status.  Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#383">383</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#389">389</a>.  (Issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#387">387</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#389">389</a> were discussed
at the meeting.)  Made progress on issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#225">225</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#226">226</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#229">229</a>: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#225">225</a> and <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#229">229</a> have been moved to Ready status, and the only remaining
concerns with <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#226">226</a> involve wording.
</li>
<li>R23: 
Pre-Santa Cruz mailing.  Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#367">367</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#382">382</a>.
Moved issues in the TC to TC status.
</li>
<li>R22: 
Post-Curaao mailing.  Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#362">362</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#366">366</a>.
</li>
<li>R21: 
Pre-Curaao mailing.  Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#351">351</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#361">361</a>.
</li>
<li>R20: 
Post-Redmond mailing; reflects actions taken in Redmond.  Added
new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#336">336</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#350">350</a>, of which issues 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#347">347</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#350">350</a> were added since Redmond, hence
not discussed at the meeting.  

All Ready issues were moved to DR status, with the exception of issues
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#284">284</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#241">241</a>, and <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#267">267</a>.

Noteworthy issues discussed at Redmond include 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#120">120</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#202">202</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#226">226</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#233">233</a>, 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#270">270</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#253">253</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#254">254</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#323">323</a>.
</li>
<li>R19: 
Pre-Redmond mailing.  Added new issues 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#323">323</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#335">335</a>.
</li>
<li>R18: 
Post-Copenhagen mailing; reflects actions taken in Copenhagen.
Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#312">312</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#317">317</a>, and discussed
new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#271">271</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#314">314</a>.

Changed status of issues
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#103">103</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#118">118</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#136">136</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#153">153</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#165">165</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#171">171</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#183">183</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#184">184</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#185">185</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#186">186</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#214">214</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#221">221</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#234">234</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#237">237</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#243">243</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#248">248</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#251">251</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#252">252</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#256">256</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#260">260</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#261">261</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#262">262</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#263">263</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#265">265</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#268">268</a>
to DR.

Changed status of issues
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#49">49</a>  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#109">109</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#117">117</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#182">182</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#228">228</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#230">230</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#232">232</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#235">235</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#238">238</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#241">241</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#242">242</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#250">250</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#259">259</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#264">264</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#266">266</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#267">267</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#271">271</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#272">272</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#273">273</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#275">275</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#281">281</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#284">284</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#285">285</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#286">286</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#288">288</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#292">292</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#295">295</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#297">297</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#298">298</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#301">301</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#303">303</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#306">306</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#307">307</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#308">308</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#312">312</a>
to Ready.

Closed issues 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#111">111</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#277">277</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#279">279</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#287">287</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#289">289</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#293">293</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#302">302</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#313">313</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#314">314</a>
as NAD.

</li>
<li>R17: 
Pre-Copenhagen mailing.  Converted issues list to XML.  Added proposed
resolutions for issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#49">49</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#76">76</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#91">91</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#235">235</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#250">250</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#267">267</a>.
Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#278">278</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#311">311</a>.
</li>
<li>R16:  
post-Toronto mailing; reflects actions taken in Toronto. Added new
issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#265">265</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#277">277</a>.  Changed status of issues
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#3">3</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#8">8</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#9">9</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#19">19</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#26">26</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#31">31</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#61">61</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#63">63</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#86">86</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#108">108</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#112">112</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#114">114</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#115">115</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#122">122</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#127">127</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#129">129</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#134">134</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#137">137</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#142">142</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#144">144</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#146">146</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#147">147</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#159">159</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#164">164</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#170">170</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#181">181</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#199">199</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#208">208</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#209">209</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#210">210</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#211">211</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#212">212</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#217">217</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#220">220</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#222">222</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#223">223</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#224">224</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#227">227</a> to "DR".  Reopened issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#23">23</a>. Reopened
issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#187">187</a>. Changed issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#2">2</a> and
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#4">4</a> to NAD. Fixed a typo in issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#17">17</a>. Fixed
issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#70">70</a>: signature should be changed both places it
appears. Fixed issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#160">160</a>: previous version didn't fix
the bug in enough places.
</li>
<li>R15: 
pre-Toronto mailing. Added issues
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#233">233</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#264">264</a>. Some small HTML formatting
changes so that we pass Weblint tests.
</li>
<li>R14: 
post-Tokyo II mailing; reflects committee actions taken in
Tokyo. Added issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#228">228</a> to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#232">232</a>. (00-0019R1/N1242)
</li>
<li>R13: 
pre-Tokyo II updated: Added issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#212">212</a> to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#227">227</a>.
</li>
<li>R12: 
pre-Tokyo II mailing: Added issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#199">199</a> to
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#211">211</a>. Added "and paragraph 5" to the proposed resolution
of issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#29">29</a>.  Add further rationale to issue
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#178">178</a>.
</li>
<li>R11: 
post-Kona mailing: Updated to reflect LWG and full committee actions
in Kona (99-0048/N1224). Note changed resolution of issues
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#4">4</a> and <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#38">38</a>. Added issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#196">196</a>
to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#198">198</a>. Closed issues list split into "defects" and
"closed" documents.  Changed the proposed resolution of issue
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#4">4</a> to NAD, and changed the wording of proposed resolution
of issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#38">38</a>.
</li>
<li>R10: 
pre-Kona updated.  Added proposed resolutions <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#83">83</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#86">86</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#91">91</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#92">92</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#109">109</a>. Added issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#190">190</a> to
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#195">195</a>. (99-0033/D1209, 14 Oct 99)
</li>
<li>R9: 
pre-Kona mailing.  Added issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#140">140</a> to
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#189">189</a>. Issues list split into separate "active" and
"closed" documents. (99-0030/N1206, 25 Aug 99)
</li>
<li>R8: 
post-Dublin mailing. Updated to reflect LWG and full committee actions
in Dublin. (99-0016/N1193, 21 Apr 99)
</li>
<li>R7: 
pre-Dublin updated: Added issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#130">130</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#131">131</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#132">132</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#133">133</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#134">134</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#135">135</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#136">136</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#137">137</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#138">138</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#139">139</a> (31 Mar 99)
</li>
<li>R6: 
pre-Dublin mailing. Added issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#127">127</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#128">128</a>,
and <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#129">129</a>.  (99-0007/N1194, 22 Feb 99)
</li>
<li>R5: 
update issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#103">103</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#112">112</a>; added issues
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#114">114</a> to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#126">126</a>. Format revisions to prepare
for making list public. (30 Dec 98)
</li>
<li>R4: 
post-Santa Cruz II updated: Issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#110">110</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#111">111</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#112">112</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#113">113</a> added, several
issues corrected. (22 Oct 98)
</li>
<li>R3: 
post-Santa Cruz II: Issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#94">94</a> to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#109">109</a>
added, many issues updated to reflect LWG consensus (12 Oct 98)
</li>
<li>R2: 
pre-Santa Cruz II: Issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#73">73</a> to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#93">93</a> added,
issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#17">17</a> updated. (29 Sep 98)
</li>
<li>R1: 
Correction to issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#55">55</a> resolution, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#60">60</a> code
format, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#64">64</a> title. (17 Sep 98)
</li>
</ul>

<h2><a name="Status"></a>Issue Status</h2>

  <p><b><a name="New">New</a></b> - The issue has not yet been
  reviewed by the LWG. Any <b>Proposed Resolution</b> is purely a
  suggestion from the issue submitter, and should not be construed as
  the view of LWG.</p>

  <p><b><a name="Open">Open</a></b> - The LWG has discussed the issue
  but is not yet ready to move the issue forward. There are several
  possible reasons for open status:</p>
     <ul>
        <li>Consensus may have not yet have been reached as to how to deal
            with the issue.</li>
        <li>Informal consensus may have been reached, but the LWG awaits
            exact <b>Proposed Resolution</b> wording for review.</li>
        <li>The LWG wishes to consult additional technical experts before
            proceeding.</li>
        <li>The issue may require further study.</li>
     </ul>

  <p>A <b>Proposed Resolution</b> for an open issue is still not be
  construed as the view of LWG. Comments on the current state of
  discussions are often given at the end of open issues in an italic
  font. Such comments are for information only and should not be given
  undue importance.</p>

  <p><b><a name="Dup">Dup</a></b> - The LWG has reached consensus that
  the issue is a duplicate of another issue, and will not be further
  dealt with. A <b>Rationale</b> identifies the duplicated issue's
  issue number.  </p>

  <p><b><a name="NAD">NAD</a></b> - The LWG has reached consensus that
  the issue is not a defect in the Standard.</p>

  <p><b><a name="NAD Editorial">NAD Editorial</a></b> - The LWG has reached consensus that
  the issue can either be handled editorially, or is handled by a paper (usually
  linked to in the rationale).</p>

  <p><b><a name="NAD Concepts">NAD Concepts</a></b> - The LWG has reached consensus that
  the issue is NAD for now, but represents a real issue when the library is
  done with language-supported concepts.</p>

  <p><b><a name="NAD Future">NAD Future</a></b> - In addition to the regular
  status, the LWG believes that this issue should be revisited at the
  next revision of the standard.</p>

  <p><b><a name="Review">Review</a></b> - Exact wording of a
  <b>Proposed Resolution</b> is now available for review on an issue
  for which the LWG previously reached informal consensus.</p>

  <p><b><a name="Ready">Ready</a></b> - The LWG has reached consensus
  that the issue is a defect in the Standard, the <b>Proposed
  Resolution</b> is correct, and the issue is ready to forward to the
  full committee for further action as a Defect Report (DR).</p>

  <p><b><a name="DR">DR</a></b> - (Defect Report) - The full J16
  committee has voted to forward the issue to the Project Editor to be
  processed as a Potential Defect Report. The Project Editor reviews
  the issue, and then forwards it to the WG21 Convenor, who returns it
  to the full committee for final disposition. This issues list
  accords the status of DR to all these Defect Reports regardless of
  where they are in that process.</p>

  <p><b><a name="TC1">TC1</a></b> - (Technical Corrigenda 1) - The full
  WG21 committee has voted to accept the Defect Report's Proposed
  Resolution as a Technical Corrigenda.  Action on this issue is thus
  complete and no further action is possible under ISO rules.</p>

  <p><b><a name="CD1">CD1</a></b> - (Committee Draft 2008) - The full
  WG21 committee has voted to accept the Defect Report's Proposed
  Resolution into the Fall 2008 Committee Draft.</p>

  <p><b><a name="TRDec">TRDec</a></b> - (Decimal TR defect) - The 
  LWG has voted to accept the Defect Report's Proposed
  Resolution into the Decimal TR.  Action on this issue is thus
  complete and no further action is expected.</p>

  <p><b><a name="WP">WP</a></b> - (Working Paper) - The proposed
  resolution has not been accepted as a Technical Corrigendum, but
  the full WG21 committee has voted to apply the Defect Report's Proposed
  Resolution to the working paper.</p>

  <p><b>Tentatively</b> - This is a <i>status qualifier</i>.  The issue has
  been reviewed online, or at an unofficial meeting, but not in an official meeting, and some support has been formed
  for the qualified status.  Tentatively qualified issues may be moved to the unqualified status
  and forwarded to full committee (if Ready) within the same meeting.  Unlike Ready issues, Tentatively Ready issues
  will be reviewed in subcommittee prior to forwarding to full committee.  When a status is
  qualified with Tentatively, the issue is still considered active.</p>

  <p><b>Pending</b> - This is a <i>status qualifier</i>.  When prepended to
  a status this indicates the issue has been
  processed by the committee, and a decision has been made to move the issue to
  the associated unqualified status.  However for logistical reasons the indicated
  outcome of the issue has not yet appeared in the latest working paper.

  </p><p>Issues are always given the status of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a> when
  they first appear on the issues list. They may progress to
  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a> or <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Review">Review</a> while the LWG
  is actively working on them. When the LWG has reached consensus on
  the disposition of an issue, the status will then change to
  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>, or
  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a> as appropriate.  Once the full J16 committee votes to
  forward Ready issues to the Project Editor, they are given the
  status of Defect Report ( <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#DR">DR</a>). These in turn may
  become the basis for Technical Corrigenda (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC">TC</a>),
  or are closed without action other than a Record of Response
  (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#RR">RR</a> ). The intent of this LWG process is that
  only issues which are truly defects in the Standard move to the
  formal ISO DR status.
  </p>


<h2>Active Issues</h2>
<hr>
<h3><a name="296"></a>296. Missing descriptions and requirements of pair operators</h3>
<p><b>Section:</b> 20.3.4 [pairs] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2001-01-14  <b>Last modified:</b> 2009-10-26</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#pairs">active issues</a> in [pairs].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#pairs">issues</a> in [pairs].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>The synopsis of the header <tt>&lt;utility&gt;</tt> in 20.3 [utility]
lists the complete set of equality and relational operators for <tt>pair</tt>
but the section describing the template and the operators only describes
<tt>operator==()</tt> and <tt>operator&lt;()</tt>, and it fails to mention
any requirements on the template arguments. The remaining operators are
not mentioned at all.
</p>

<p><i>[
2009-09-27 Alisdair reopens.
]</i></p>


<blockquote>
<p>
The issue is a lack of wording specifying the semantics of <tt>std::pair</tt>
relational operators.  The rationale is that this is covered by
catch-all wording in the relops component, and that as relops directly
precedes <tt>pair</tt> in the document this is an easy connection to make.
</p>

<p>
Reading the current working paper I make two observations:
</p>

<ol type="i">
<li>
relops no longer immediately precedes <tt>pair</tt> in the order of
specification.  However, even if it did, there is a lot of <tt>pair</tt>
specification itself between the (apparently) unrelated relops and the
relational operators for <tt>pair</tt>.  (The catch-all still requires
<tt>operator==</tt> and <tt>operator&lt;</tt> to be specified
explicitly)
</li>

<li>
No other library component relies on the catch-all clause. The following
all explicitly document all six relational operators, usually in a
manner that could have deferred to the relops clause.
</li>
</ol>

<blockquote><pre>tuple
unique_ptr
duration
time_point
basic_string
queue
stack
move_iterator
reverse_iterator 
regex submatch
thread::id
</pre></blockquote>

<p>
The container components provide their own (equivalent) definition in
23.2.1 [container.requirements.general] Table 90 -- Container
requirements and do so do not defer to relops.
</p>

<p>
<tt>Shared_ptr</tt> explicitly documents <tt>operator!=</tt> and does
not supply the other 3 missing operators
(<tt>&gt;</tt>,<tt>&gt;=</tt>,<tt>&lt;=</tt>) so does not meet the
reqirements of the relops clause.
</p>

<p>
<tt>Weak_ptr</tt> only supports <tt>operator&lt;</tt> so would not be
covered by relops.
</p>

<p>
At the very least I would request a note pointing to the relops clause
we rely on to provide this definition.  If this route is taken, I would
recommend reducing many of the above listed clauses to a similar note
rather than providing redundant specification.
</p>

<p>
My preference would be to supply the 4 missing specifications consistent
with the rest of the library.
</p>

</blockquote>

<p><i>[
2009-10-11 Daniel opens <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1233">1233</a> which deals with the same issue as
it pertains to <tt>unique_ptr</tt>.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Move to Ready
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
After p20 20.3.4 [pairs] add:
</p>

<blockquote><pre>template &lt;class T1, class T2&gt;
bool operator!=(const pair&lt;T1,T2&gt;&amp; x, const pair&lt;T1,T2&gt;&amp; y);
</pre>

<blockquote>
<i>Returns:</i> <tt>!(x==y)</tt>
</blockquote>

<pre>template &lt;class T1, class T2&gt;
bool operator&gt; (const pair&lt;T1,T2&gt;&amp; x, const pair&lt;T1,T2&gt;&amp; y);
</pre>

<blockquote>
<i>Returns:</i> <tt>y &lt; x</tt>
</blockquote>

<pre>template &lt;class T1, class T2&gt;
bool operator&gt;=(const pair&lt;T1,T2&gt;&amp; x, const pair&lt;T1,T2&gt;&amp; y);
</pre>

<blockquote>
<i>Returns:</i> <tt>!(x &lt; y)</tt>
</blockquote>

<pre>template &lt;class T1, class T2&gt;
bool operator&lt;=(const pair&lt;T1,T2&gt;&amp; x, const pair&lt;T1,T2&gt;&amp; y);
</pre>

<blockquote>
<i>Returns:</i> <tt>!(y &lt; x)</tt>
</blockquote>
</blockquote>


<p><b>Rationale:</b></p>
<p>20.3.1 [operators] paragraph 10 already specifies the semantics.
That paragraph says that, if declarations of operator!=, operator&gt;,
operator&lt;=, and operator&gt;= appear without definitions, they are
defined as specified in 20.3.1 [operators].  There should be no user
confusion, since that paragraph happens to immediately precede the
specification of <tt>pair</tt>.</p>





<hr>
<h3><a name="299"></a>299. Incorrect return types for iterator dereference</h3>
<p><b>Section:</b> 24.2.4 [bidirectional.iterators], 24.2.5 [random.access.iterators] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> John Potter <b>Opened:</b> 2001-01-22  <b>Last modified:</b> 2009-10-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#bidirectional.iterators">issues</a> in [bidirectional.iterators].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In section 24.2.4 [bidirectional.iterators],
Table 75 gives the return type of *r-- as convertible to T.  This is
not consistent with Table 74 which gives the return type of *r++ as
T&amp;.  *r++ = t is valid while *r-- = t is invalid.
</p>

<p>
In section 24.2.5 [random.access.iterators],
Table 76 gives the return type of a[n] as convertible to T.  This is
not consistent with the semantics of *(a + n) which returns T&amp; by
Table 74.  *(a + n) = t is valid while a[n] = t is invalid.
</p>

<p>
Discussion from the Copenhagen meeting: the first part is
uncontroversial.  The second part, operator[] for Random Access
Iterators, requires more thought.  There are reasonable arguments on
both sides.  Return by value from operator[] enables some potentially
useful iterators, e.g. a random access "iota iterator" (a.k.a
"counting iterator" or "int iterator").  There isn't any obvious way
to do this with return-by-reference, since the reference would be to a
temporary.  On the other hand, <tt>reverse_iterator</tt> takes an
arbitrary Random Access Iterator as template argument, and its
operator[] returns by reference.  If we decided that the return type
in Table 76 was correct, we would have to change
<tt>reverse_iterator</tt>.  This change would probably affect user
code.
</p>

<p>
History: the contradiction between <tt>reverse_iterator</tt> and the
Random Access Iterator requirements has been present from an early
stage.  In both the STL proposal adopted by the committee
(N0527==94-0140) and the STL technical report (HPL-95-11 (R.1), by
Stepanov and Lee), the Random Access Iterator requirements say that
operator[]'s return value is "convertible to T".  In N0527
reverse_iterator's operator[] returns by value, but in HPL-95-11
(R.1), and in the STL implementation that HP released to the public,
reverse_iterator's operator[] returns by reference.  In 1995, the
standard was amended to reflect the contents of HPL-95-11 (R.1).  The
original intent for operator[] is unclear.
</p>

<p>
In the long term it may be desirable to add more fine-grained 
iterator requirements, so that access method and traversal strategy
can be decoupled.  (See "Improved Iterator Categories and
Requirements", N1297 = 01-0011, by Jeremy Siek.)  Any decisions
about issue 299 should keep this possibility in mind.
</p>

<p>Further discussion: I propose a compromise between John Potter's
resolution, which requires <tt>T&amp;</tt> as the return type of
<tt>a[n]</tt>, and the current wording, which requires convertible to
<tt>T</tt>. The compromise is to keep the convertible to <tt>T</tt>
for the return type of the expression <tt>a[n]</tt>, but to also add
<tt>a[n] = t</tt> as a valid expression. This compromise "saves" the
common case uses of random access iterators, while at the same time
allowing iterators such as counting iterator and caching file
iterators to remain random access iterators (iterators where the
lifetime of the object returned by <tt>operator*()</tt> is tied to the
lifetime of the iterator).
</p>

<p>
Note that the compromise resolution necessitates a change to
<tt>reverse_iterator</tt>. It would need to use a proxy to support
<tt>a[n] = t</tt>.
</p>

<p>
Note also there is one kind of mutable random access iterator that
will no longer meet the new requirements. Currently, iterators that
return an r-value from <tt>operator[]</tt> meet the requirements for a
mutable random access iterartor, even though the expression <tt>a[n] =
t</tt> will only modify a temporary that goes away. With this proposed
resolution, <tt>a[n] = t</tt> will be required to have the same
operational semantics as <tt>*(a + n) = t</tt>.
</p>

<p><i>[
2009-07-28 Reopened by Alisdair.  No longer solved by concepts.
]</i></p>


<p><i>[
2009-09-18 Alisdair adds:
]</i></p>


<blockquote>
<p>
Why can't we write through the reference returned from operator[] on a
random access iterator?
</p>

<p>
Recommended solution:
</p>

<p>
In table Table 104 -- Random access iterator requirements, replace
</p>

<blockquote>
a[n] : convertible to <del><tt>const T &amp;</tt></del>
<ins><tt>T&amp;</tt> if <tt>X</tt> is mutable, otherwise convertible to <tt>const T&amp;</tt></ins>
</blockquote>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Leave Open. Alisdair to spearhead a paper on revivification.
</blockquote>



<p><b>Proposed resolution:</b></p>

<p>
In section 24.1.4 [lib.bidirectdional.iterators], change the return
type in table 75 from "convertible to <tt>T</tt>" to
<tt>T&amp;</tt>.
</p>

<p>
In section 24.1.5 [lib.random.access.iterators], change the
operational semantics for <tt>a[n]</tt> to " the r-value of
<tt>a[n]</tt> is equivalent to the r-value of <tt>*(a +
n)</tt>". Add a new row in the table for the expression <tt>a[n] = t</tt>
with a return type of convertible to <tt>T</tt> and operational semantics of
<tt>*(a + n) = t</tt>.
</p>

<p><i>[Lillehammer: Real problem, but should be addressed as part of
  iterator redesign]</i></p>




<p><b>Rationale:</b></p>
<p><i>[
San Francisco:
]</i></p>


<blockquote>
Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2758.pdf">N2758</a>.
</blockquote>







<hr>
<h3><a name="397"></a>397. ostream::sentry dtor throws exceptions</h3>
<p><b>Section:</b> 27.7.2.4 [ostream::sentry] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2003-01-05  <b>Last modified:</b> 2009-10-20</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#ostream::sentry">issues</a> in [ostream::sentry].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
    <p>
17.4.4.8, p3 prohibits library dtors from throwing exceptions.
    </p>
    <p>
27.6.2.3, p4 says this about the ostream::sentry dtor:
    </p>
    <pre>    -4- If ((os.flags() &amp; ios_base::unitbuf) &amp;&amp; !uncaught_exception())
        is true, calls os.flush().
    </pre>
    <p>
27.6.2.6, p7 that describes ostream::flush() says:
    </p>
    <pre>    -7- If rdbuf() is not a null pointer, calls rdbuf()-&gt;pubsync().
        If that function returns ?-1 calls setstate(badbit) (which
        may throw ios_base::failure (27.4.4.3)).
    </pre>
    <p>
That seems like a defect, since both pubsync() and setstate() can
throw an exception. 
    </p>
<p><i>[
The contradiction is real.  Clause 17 says destructors may never
throw exceptions, and clause 27 specifies a destructor that does
throw.  In principle we might change either one.  We're leaning
toward changing clause 17: putting in an "unless otherwise specified"
clause, and then putting in a footnote saying the sentry destructor
is the only one that can throw.  PJP suggests specifying that
sentry::~sentry() should internally catch any exceptions it might cause.
]</i></p>


<p><i>[
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#418">418</a> and <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#622">622</a> for related issues.
]</i></p>


<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
Move to Review. Add "Throws: nothing" to the specification of ostream::sentry::~sentry().
</p>
</blockquote>

<p><i>[
2009-10-13 Daniel adds:
]</i></p>


<blockquote>
The proposed resolution of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#835">835</a> is written to match the outcome
of this issue.
</blockquote>

<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote>
Move to Open.  Our intent is to solve this issue with <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#835">835</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add after 27.7.2.4 [ostream::sentry] p17:
</p>

<blockquote>
<pre>~sentry();
</pre>
<blockquote>
<p>
-17- If <tt>((os.flags() &amp; ios_base::unitbuf) &amp;&amp; !uncaught_exception())</tt>
is <tt>true</tt>, calls <tt>os.flush()</tt>.
</p>

<p><ins>
<i>Throws:</i> Nothing.
</ins></p>
</blockquote>
</blockquote>





<hr>
<h3><a name="408"></a>408. Is vector&lt;reverse_iterator&lt;char*&gt; &gt; forbidden?</h3>
<p><b>Section:</b> 24.2 [iterator.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Nathan Myers <b>Opened:</b> 2003-06-03  <b>Last modified:</b> 2009-11-03</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#iterator.requirements">active issues</a> in [iterator.requirements].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#iterator.requirements">issues</a> in [iterator.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I've been discussing iterator semantics with Dave Abrahams, and a 
surprise has popped up.  I don't think this has been discussed before.
</p>

<p>
X [iterator.concepts] says that the only operation that can be performed on "singular"
iterator values is to assign a non-singular value to them.  (It 
doesn't say they can be destroyed, and that's probably a defect.)  
Some implementations have taken this to imply that there is no need 
to initialize the data member of a reverse_iterator&lt;&gt; in the default
constructor.  As a result, code like
</p>
<blockquote><pre>  std::vector&lt;std::reverse_iterator&lt;char*&gt; &gt; v(7);
  v.reserve(1000);
</pre></blockquote>
<p>
invokes undefined behavior, because it must default-initialize the
vector elements, and then copy them to other storage.  Of course many 
other vector operations on these adapters are also left undefined,
and which those are is not reliably deducible from the standard.
</p>

<p>
I don't think that 24.1 was meant to make standard-library iterator 
types unsafe.  Rather, it was meant to restrict what operations may 
be performed by functions which take general user- and standard 
iterators as arguments, so that raw pointers would qualify as
iterators.  However, this is not clear in the text, others have come 
to the opposite conclusion.
</p>

<p>
One question is whether the standard iterator adaptors have defined
copy semantics.  Another is whether they have defined destructor
semantics: is
</p>
<blockquote><pre>  { std::vector&lt;std::reverse_iterator&lt;char*&gt; &gt;  v(7); }
</pre></blockquote>
<p>
undefined too?
</p>

<p>
Note this is not a question of whether algorithms are allowed to
rely on copy semantics for arbitrary iterators, just whether the
types we actually supply support those operations.  I believe the 
resolution must be expressed in terms of the semantics of the 
adapter's argument type.  It should make clear that, e.g., the 
reverse_iterator&lt;T&gt; constructor is actually required to execute
T(), and so copying is defined if the result of T() is copyable.
</p>

<p>
Issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#235">235</a>, which defines reverse_iterator's default
constructor more precisely, has some relevance to this issue.
However, it is not the whole story.
</p>

<p>
The issue was whether 
</p>
<blockquote><pre>  reverse_iterator() { }
</pre></blockquote>
<p>
is allowed, vs. 
</p>
<blockquote><pre>  reverse_iterator() : current() { }
</pre></blockquote>

<p>
The difference is when T is char*, where the first leaves the member
uninitialized, and possibly equal to an existing pointer value, or
(on some targets) may result in a hardware trap when copied.
</p>

<p>
8.5 paragraph 5 seems to make clear that the second is required to
satisfy DR <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#235">235</a>, at least for non-class Iterator argument
types.
</p>

<p>
But that only takes care of reverse_iterator, and doesn't establish
a policy for all iterators.  (The reverse iterator adapter was just
an example.)  In particular, does my function
</p>
<blockquote><pre>  template &lt;typename Iterator&gt;
    void f() { std::vector&lt;Iterator&gt;  v(7); } 
</pre></blockquote>
<p>
evoke undefined behavior for some conforming iterator definitions?
I think it does, now, because vector&lt;&gt; will destroy those singular
iterator values, and that's explicitly disallowed.
</p>

<p>
24.1 shouldn't give blanket permission to copy all singular iterators,
because then pointers wouldn't qualify as iterators.  However, it
should allow copying of that subset of singular iterator values that
are default-initialized, and it should explicitly allow destroying any
iterator value, singular or not, default-initialized or not.
</p>

<p>Related issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#407">407</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1012">1012</a></p>
<p><i>[
We don't want to require all singular iterators to be copyable,
because that is not the case for pointers.  However, default
construction may be a special case.  Issue: is it really default
construction we want to talk about, or is it something like value
initialization?  We need to check with core to see whether default
constructed pointers are required to be copyable; if not, it would be
wrong to impose so strict a requirement for iterators.
]</i></p>


<p><i>[
2009-05-10 Alisdair provided wording.
]</i></p>


<blockquote>
The comments regarding destroying singular iterators have already been
resolved.  That just leaves copying (with moving implied).
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
This is related to LWG <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1012">1012</a>.
</p>
<p>
Note that there is a bug in the proposed resolution to LWG <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1012">1012</a>. The
change to  [reverse.iter.con] should be modified so that the word
"default" in the second sentence of the Effects clause is replaced by
"value."
</p>
<p>
We believe that the proposed fix to LWG <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1012">1012</a> (now corrected) is
sufficient to solve the problem for reverse_iterator. However, Alisdair
pointed out that LWG <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1012">1012</a> does not solve the general problem for authors
of iterator adaptors.
</p>
<p>
There are some problems with the proposed resolution. The phrase "safely
copyable" is not a term of art. Also, it mentions a
DefaultConstructible? concept.
</p>
<p>
Move to Review after Alisdair updates the wording.
</p>
</blockquote>

<p><i>[
2009-07-31 Alisdair revised wording:
]</i></p>


<p><i>[
2009-08-17 Alisdair and Daniel collaborate on slightly revised wording.
This issue depends upon <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#724">724</a>
]</i></p>


<p><i>[
2009-10-14 Daniel adds:
]</i></p>


<blockquote>
There is a clear dependency on <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1213">1213</a>, because the term "singular",
which is used as part of the resolution, is not properly defined yet.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Moved to Open. Alisdair will provide improved wording to make
this have "value semantics" and otherwise behave like a valid iterator.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add a new paragrpah to Iterator concepts 24.2 [iterator.requirements] after para 5 (the one describing
singular iterators)
</p>
<blockquote>
<p>
Just as a regular pointer to an array guarantees that there is a pointer
value pointing past the last element of the array, so for any iterator
type there is an iterator value that points past the last element of a
corresponding container. These values are called <i>past-the-end</i> values.
Values of an iterator <tt>i</tt> for which the expression <tt>*i</tt> is defined are called
<i>dereferenceable</i>. The library never assumes that past-the-end values are
dereferenceable. Iterators can also have singular values that are not
associated with any container. [<i>Example:</i> After the declaration of an
uninitialized pointer <tt>x</tt> (as with <tt>int* x;</tt>), <tt>x</tt> must always be assumed to
have a singular value of a pointer. &#8212; <i>end example</i>] Results of most
expressions are undefined for singular values; the only exceptions are
destroying an iterator that holds a singular value and the assignment of
a non-singular value to an iterator that holds a singular value. In this
case the singular value is overwritten the same way as any other value.
Dereferenceable values are always non-singular.
</p>
<p><ins>
After value-initialization, any iterator that satisfies the
<tt>DefaultConstructible</tt> requirements ([defaultconstructible]) shall not introduce undefined behaviour
when used <ins>as</ins> the
source of a copy or move operation, even if it would
otherwise be singular. [<i>Note:</i> This guarantee is not offered for
default-initialization (8.5 [dcl.init]), although the distinction only
matters for types with trivial default constructors such as pointers. &#8212;
<i>end note</i>]
</ins></p>


</blockquote>






<hr>
<h3><a name="427"></a>427. stage 2 and rationale of DR 221</h3>
<p><b>Section:</b> 22.4.2.1.2 [facet.num.get.virtuals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2003-09-18  <b>Last modified:</b> 2009-10-26</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#facet.num.get.virtuals">active issues</a> in [facet.num.get.virtuals].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#facet.num.get.virtuals">issues</a> in [facet.num.get.virtuals].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The requirements specified in Stage 2 and reiterated in the rationale
of DR 221 (and echoed again in DR 303) specify that num_get&lt;charT&gt;::
do_get() compares characters on the stream against the widened elements
of "012...abc...ABCX+-"
</p>

<p>
An implementation is required to allow programs to instantiate the num_get
template on any charT that satisfies the requirements on a user-defined
character type. These requirements do not include the ability of the
character type to be equality comparable (the char_traits template must
be used to perform tests for equality). Hence, the num_get template cannot
be implemented to support any arbitrary character type. The num_get template
must either make the assumption that the character type is equality-comparable
(as some popular implementations do), or it may use char_traits&lt;charT&gt; to do
the comparisons (some other popular implementations do that). This diversity
of approaches makes it difficult to write portable programs that attempt to
instantiate the num_get template on user-defined types.
</p>

<p><i>[Kona: the heart of the problem is that we're theoretically
  supposed to use traits classes for all fundamental character
  operations like assignment and comparison, but facets don't have
  traits parameters.  This is a fundamental design flaw and it
  appears all over the place, not just in this one place.  It's not
  clear what the correct solution is, but a thorough review of facets
  and traits is in order.  The LWG considered and rejected the
  possibility of changing numeric facets to use narrowing instead of
  widening.  This may be a good idea for other reasons (see issue
  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#459">459</a>), but it doesn't solve the problem raised by this
  issue.  Whether we use widen or narrow the <tt>num_get</tt> facet
  still has no idea which traits class the user wants to use for 
  the comparison, because only streams, not facets, are passed traits
  classes.   The standard does not require that two different
  traits classes with the same <tt>char_type</tt> must necessarily 
  have the same behavior.]</i></p>


<p>Informally, one possibility: require that some of the basic
character operations, such as <tt>eq</tt>, <tt>lt</tt>,
and <tt>assign</tt>, must behave the same way for all traits classes
with the same <tt>char_type</tt>.  If we accept that limitation on
traits classes, then the facet could reasonably be required to
use <tt>char_traits&lt;charT&gt;</tt>.</p>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
There was general agreement that the standard only needs to specify the
behavior when the character type is char or wchar_t.
</p>
<p>
Beman: we don't need to worry about C++1x because there is a non-zero
possibility that we would have a replacement facility for iostreams that
would solve these problems.
</p>
<p>
We need to change the following sentence in [locale.category], paragraph
6 to specify that C is char and wchar_t:
</p>
<p>
"A template formal parameter with name C represents the set of all
possible specializations on a parameter that satisfies the requirements
for a character on which any member of the iostream components can be
instantiated."
</p>
<p>
We also need to specify in 27 that the basic character operations, such
as eq, lt, and assign use std::char_traits.
</p>
<p>
Daniel volunteered to provide wording.
</p>
</blockquote>

<p><i>[
2009-09-19 Daniel provided wording.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Leave as Open. Alisdair and/or Tom will provide wording based on discussions.
We want to clearly state that streams and locales work just on <tt>char</tt>
and <tt>wchar_t</tt> (except where otherwise specified).
</blockquote>



<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>
Change 22.3.1.1.1 [locale.category]/6:
</p>

<blockquote>
[..] A template formal parameter with name <tt>C</tt> represents the set of all possible
specializations on a <ins><tt>char</tt> or <tt>wchar_t</tt></ins> parameter<del> that satisfies
the requirements for a character on which any of the iostream components
can be instantiated</del>. [..]
</blockquote>
</li>

<li>
<p>
Add the following sentence to the end of 22.4.2 [category.numeric]/2:
</p>

<blockquote>
[..] These specializations refer to [..], and also for the <tt>ctype&lt;&gt;</tt> facet to
perform character classification. <ins>Implementations are encouraged
but not required to use the <tt>char_traits&lt;charT&gt;</tt> functions for all
comparisons and assignments of characters of type <tt>charT</tt> that do
not belong to the set of required specializations.</ins>
</blockquote>
</li>

<li>
<p>
Change 22.4.2.1.2 [facet.num.get.virtuals]/3:
</p>

<blockquote>
<p>
Stage 2: If <tt>in==end</tt> then stage 2 terminates. Otherwise a <tt>charT</tt> is taken
from <tt>in</tt> and local variables are initialized as if by
</p>

<blockquote><pre>char_type ct = *in;
<ins>using tr = char_traits&lt;char_type&gt;;
const char_type* pos = tr::find(atoms, sizeof(src) - 1, ct);</ins>
char c = src[<del>find(atoms, atoms + sizeof(src) - 1, ct) - atoms</del>
             <ins>pos ? pos - atoms : sizeof(src) - 1</ins>];
if (<ins>tr::eq(ct, </ins><del>ct == </del>use_facet&lt;numpunct&lt;charT&gt;(loc).decimal_point()<ins>)</ins>)
    c = '.';
bool discard =
    <ins>tr::eq(ct, </ins><del>ct == </del>use_facet&lt;numpunct&lt;charT&gt;(loc).thousands_sep()<ins>)</ins>
    &amp;&amp; use_facet&lt;numpunct&lt;charT&gt; &gt;(loc).grouping().length() != 0;
</pre></blockquote>

<p>
where the values <tt>src</tt> and <tt>atoms</tt> are defined as if by: [..]
</p>
</blockquote>

<p>
[Remark of the author: I considered to replace the initialization
"<tt>char_type ct = *in;</tt>"
by the sequence "<tt>char_type ct; tr::assign(ct, *in);</tt>", but decided
against it, because
it is a copy-initialization context, not an assignment]
</p>
</li>

<li>
<p>
Add the following sentence to the end of 22.4.5 [category.time]/1:
</p>

<blockquote>
[..] Their members use [..] , to determine formatting details.
<ins>Implementations are encouraged but not required to use the
<tt>char_traits&lt;charT&gt;</tt> functions for all comparisons and assignments
of characters of type <tt>charT</tt> that do
not belong to the set of required specializations.</ins>
</blockquote>
</li>

<li>
<p>
Change 22.4.5.1.1 [locale.time.get.members]/8 bullet 4:
</p>

<ul>
<li>
<del>The next element of <tt>fmt</tt> is equal to <tt>'%'</tt></del> <ins>For the next element <tt>c</tt>
of <tt>fmt char_traits&lt;char_type&gt;::eq(c, use_facet&lt;ctype&lt;char_type&gt;&gt;(f.getloc()).widen('%')) == true</tt></ins>,
[..]
</li>
</ul>
</li>

<li>
<p>
Add the following sentence to the end of 22.4.6 [category.monetary]/2:
</p>

<blockquote>
Their members use [..] to determine formatting details.
<ins>Implementations are encouraged but not required to use the
<tt>char_traits&lt;charT&gt;</tt> functions for all comparisons and assignments
of characters of type <tt>charT</tt> that do
not belong to the set of required specializations.</ins>
</blockquote>
</li>

<li>
<p>
Change 22.4.6.1.2 [locale.money.get.virtuals]/4:
</p>

<blockquote>
<p>
[..] The value <tt>units</tt> is produced as if by:
</p>

<blockquote><pre>for (int i = 0; i &lt; n; ++i)
  buf2[i] = src[<ins>char_traits&lt;charT&gt;::</ins>find(atoms, <del>atoms+</del>sizeof(src), buf1[i]) - atoms];
buf2[n] = 0;
sscanf(buf2, "%Lf", &amp;units);
</pre></blockquote>
</blockquote>
</li>

<li>
<p>
Change 22.4.6.2.2 [locale.money.put.virtuals]/1:
</p>

<blockquote>
[..] for character buffers <tt>buf1</tt> and <tt>buf2</tt>. If <ins>for</ins> the first
character <ins><tt>c</tt></ins>
in <tt>digits</tt> or <tt>buf2</tt> <del>is equal to
<tt>ct.widen('-')</tt></del><ins><tt>char_traits&lt;charT&gt;::eq(c,
ct.widen('-')) == true</tt></ins>, [..]
</blockquote>
</li>

<li>
<p>
Add a footnote to the first sentence of 27.7.1.2.2 [istream.formatted.arithmetic]/1:
</p>

<blockquote>
<p>
As in the case of the inserters, these extractors depend on the locale's
<tt>num_get&lt;&gt;</tt> (22.4.2.1) object to perform parsing the input stream
data.<ins><sup>(footnote)</sup></ins> [..]
</p>

<p>
<ins>
<sup>footnote)</sup> If the traits of the input stream has different semantics for <tt>lt()</tt>,
<tt>eq()</tt>, and <tt>assign()</tt> than <tt>char_traits&lt;char_type&gt;</tt>, this may give surprising
results.
</ins>
</p>
</blockquote>
</li>

<li>
<p>
Add a footnote to the second sentence of 27.7.2.6.2 [ostream.inserters.arithmetic]/1:
</p>

<blockquote>
<p>
<i>Effects:</i> The classes <tt>num_get&lt;&gt;</tt> and
<tt>num_put&lt;&gt;</tt> handle locale-dependent numeric formatting and
parsing. These inserter functions use the imbued locale value to perform
numeric formatting.<ins><sup>(footnote)</sup></ins> [..]
</p>

<p>
<ins>
<sup>footnote)</sup> If the traits of the output stream has different semantics for <tt>lt()</tt>,
<tt>eq()</tt>, and <tt>assign()</tt> than <tt>char_traits&lt;char_type&gt;</tt>, this may give surprising
results.
</ins>
</p>
</blockquote>
</li>

<li>
<p>
Add a footnote after the first sentence of 27.7.4 [ext.manip]/4:
</p>

<blockquote>
<p>
<i>Returns:</i> An object of unspecified type such that if in is an object of type
<tt>basic_istream&lt;charT, traits&gt;</tt> then the expression <tt>in &gt;&gt; get_money(mon, intl)</tt>
behaves as if it called <tt>f(in, mon, intl)</tt>, where the function <tt>f</tt> is defined
as:<ins><sup>(footnote)</sup></ins> [..]
</p>

<p>
<ins>
<sup>footnote)</sup> If the traits of the input stream has different semantics for <tt>lt()</tt>,
<tt>eq()</tt>, and <tt>assign()</tt> than <tt>char_traits&lt;char_type&gt;</tt>, this may give surprising
results.
</ins>
</p>
</blockquote>
</li>

<li>
<p>
Add a footnote after the first sentence of 27.7.4 [ext.manip]/5:
</p>

<blockquote>
<p>
<i>Returns:</i> An object of unspecified type such that if <tt>out</tt> is an object of type
<tt>basic_ostream&lt;charT, traits&gt;</tt> then the expression <tt>out &lt;&lt; put_money(mon, intl)</tt>
behaves as a formatted input function that calls <tt>f(out, mon, intl)</tt>, where the
function <tt>f</tt> is defined as:<ins><sup>(footnote)</sup></ins> [..]
</p>

<p>
<ins>
<sup>footnote)</sup> If the traits of the output stream has different semantics for <tt>lt()</tt>,
<tt>eq()</tt>, and <tt>assign()</tt> than <tt>char_traits&lt;char_type&gt;</tt>, this may give surprising
results.
</ins>
</p>
</blockquote>
</li>

<li>
<p>
13) Add a footnote after the first sentence of 27.7.4 [ext.manip]/8:
</p>

<blockquote>
<p>
<i>Returns:</i> An object of unspecified type such that if <tt>in</tt> is an
object of type b<tt>asic_istream&lt;charT, traits&gt;</tt> then the expression
<tt>in &gt;&gt;get_time(tmb, fmt)</tt> behaves as if it called <tt>f(in, tmb, fmt)</tt>,
where the function <tt>f</tt> is defined as:<ins><sup>(footnote)</sup></ins> [..]
</p>

<p>
<ins>
<sup>footnote)</sup> If the traits of the input stream has different semantics for <tt>lt()</tt>,
<tt>eq()</tt>, and <tt>assign()</tt> than <tt>char_traits&lt;char_type&gt;</tt>, this may give surprising
results.
</ins>
</p>
</blockquote>
</li>

<li>
<p>
Add a footnote after the first sentence of 27.7.4 [ext.manip]/10:
</p>

<blockquote>
<p>
Returns: An object of unspecified type such that if <tt>out</tt> is an object of type
<tt>basic_ostream&lt;charT, traits&gt;</tt> then the expression <tt>out &lt;&lt;put_time(tmb, fmt)</tt>
behaves as if it called <tt>f(out, tmb, fmt)</tt>, where the function <tt>f</tt> is defined
as:<ins><sup>(footnote)</sup></ins> [..]
</p>

<p>
<ins>
<sup>footnote)</sup> If the traits of the output stream has different semantics for <tt>lt()</tt>,
<tt>eq()</tt>, and <tt>assign()</tt> than <tt>char_traits&lt;char_type&gt;</tt>, this may give surprising
results.
</ins>
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="430"></a>430. valarray subset operations</h3>
<p><b>Section:</b> 26.6.2.4 [valarray.sub] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2003-09-18  <b>Last modified:</b> 2009-11-04</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The standard fails to specify the behavior of valarray::operator[](slice)
and other valarray subset operations when they are passed an "invalid"
slice object, i.e., either a slice that doesn't make sense at all (e.g.,
slice (0, 1, 0) or one that doesn't specify a valid subset of the valarray
object (e.g., slice (2, 1, 1) for a valarray of size 1).
</p>
<p><i>[Kona: the LWG believes that invalid slices should invoke
  undefined behavior.  Valarrays are supposed to be designed for high
  performance, so we don't want to require specific checking.  We
  need wording to express this decision.]</i></p>


<p><i>[
Bellevue:
]</i></p>


<blockquote>
Please note that the standard also fails to specify the behavior of
slice_array and gslice_array in the valid case. Bill Plauger will
endeavor to provide revised wording for slice_array and gslice_array.
</blockquote>

<p><i>[
post-Bellevue:  Bill provided wording.
]</i></p>


<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
Move to Ready.
</p>
</blockquote>

<p><i>[
2009-11-04 Pete opens:
]</i></p>


<blockquote>
The resolution to LWG issue 430 has not been applied --- there have been
changes to the underlying text, and the resolution needs to be reworked.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Insert after 26.6.2.4 [valarray.sub], paragraph 1:
</p>

<blockquote>
<p>
The member operator is overloaded to provide several ways to select
sequences
of elements from among those controlled by <tt>*this</tt>. The first group of five
member operators work in conjunction with various overloads of <tt>operator=</tt>
(and other assigning operators) to allow selective replacement (slicing) of
the controlled sequence. The selected elements must exist.
</p>
<p>
The first member operator selects element off. For example:
</p>

<blockquote><pre>valarray&lt;char&gt; v0("abcdefghijklmnop", 16);
v0[3] = 'A';
// v0 == valarray&lt;char&gt;("abcAefghijklmnop", 16)
</pre></blockquote>

<p>
The second member operator selects those elements of the controlled sequence
designated by <tt>slicearr</tt>. For example:
</p>

<blockquote><pre>valarray&lt;char&gt; v0("abcdefghijklmnop", 16);
valarray&lt;char&gt; v1("ABCDE", 5);
v0[slice(2, 5, 3)] = v1;
// v0 == valarray&lt;char&gt;("abAdeBghCjkDmnEp", 16)
</pre></blockquote>

<p>
The third member operator selects those elements of the controlled sequence
designated by <tt>gslicearr</tt>. For example:
</p>

<blockquote><pre>valarray&lt;char&gt; v0("abcdefghijklmnop", 16);
valarray&lt;char&gt; v1("ABCDEF", 6);
const size_t lv[] = {2, 3};
const size_t dv[] = {7, 2};
const valarray&lt;size_t&gt; len(lv, 2), str(dv, 2);
v0[gslice(3, len, str)] = v1;
// v0 == valarray&lt;char&gt;("abcAeBgCijDlEnFp", 16)
</pre></blockquote>

<p>
The fourth member operator selects those elements of the controlled sequence
designated by <tt>boolarr</tt>. For example:
</p>

<blockquote><pre>valarray&lt;char&gt; v0("abcdefghijklmnop", 16);
valarray&lt;char&gt; v1("ABC", 3);
const bool vb[] = {false, false, true, true, false, true};
v0[valarray&lt;bool&gt;(vb, 6)] = v1;
// v0 == valarray&lt;char&gt;("abABeCghijklmnop", 16)
</pre></blockquote>

<p>
The fifth member operator selects those elements of the controlled sequence
designated by indarr. For example:
</p>

<blockquote><pre>valarray&lt;char&gt; v0("abcdefghijklmnop", 16);
valarray&lt;char&gt; v1("ABCDE", 5);
const size_t vi[] = {7, 5, 2, 3, 8};
v0[valarray&lt;size_t&gt;(vi, 5)] = v1;
// v0 == valarray&lt;char&gt;("abCDeBgAEjklmnop", 16)
</pre></blockquote>

<p>
The second group of five member operators each construct an object that
represents the value(s) selected. The selected elements must exist.
</p>

<p>
The sixth member operator returns the value of element off. For example:
</p>

<blockquote><pre>valarray&lt;char&gt; v0("abcdefghijklmnop", 16);
// v0[3] returns 'd'
</pre></blockquote>

<p>
The seventh member operator returns an object of class <tt>valarray&lt;Ty&gt;</tt>
containing those elements of the controlled sequence designated by <tt>slicearr</tt>.
For example:
</p>

<blockquote><pre>valarray&lt;char&gt; v0("abcdefghijklmnop", 16);
// v0[slice(2, 5, 3)] returns valarray&lt;char&gt;("cfilo", 5)
</pre></blockquote>

<p>
The eighth member operator selects those elements of the controlled sequence
designated by <tt>gslicearr</tt>. For example:
</p>

<blockquote><pre>valarray&lt;char&gt; v0("abcdefghijklmnop", 16);
const size_t lv[] = {2, 3};
const size_t dv[] = {7, 2};
const valarray&lt;size_t&gt; len(lv, 2), str(dv, 2);
// v0[gslice(3, len, str)] returns
//    valarray&lt;char&gt;("dfhkmo", 6)
</pre></blockquote>

<p>
The ninth member operator selects those elements of the controlled sequence
designated by <tt>boolarr</tt>. For example:
</p>

<blockquote><pre>valarray&lt;char&gt; v0("abcdefghijklmnop", 16);
const bool vb[] = {false, false, true, true, false, true};
// v0[valarray&lt;bool&gt;(vb, 6)] returns
//    valarray&lt;char&gt;("cdf", 3)
</pre></blockquote>

<p>
The last member operator selects those elements of the controlled sequence
designated by <tt>indarr</tt>. For example:
</p>

<blockquote><pre>valarray&lt;char&gt; v0("abcdefghijklmnop", 16);
const size_t vi[] = {7, 5, 2, 3, 8};
// v0[valarray&lt;size_t&gt;(vi, 5)] returns
//    valarray&lt;char&gt;("hfcdi", 5)
</pre></blockquote>

</blockquote>





<hr>
<h3><a name="446"></a>446. Iterator equality between different containers</h3>
<p><b>Section:</b> 24.2 [iterator.requirements], 23.2 [container.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Andy Koenig <b>Opened:</b> 2003-12-16  <b>Last modified:</b> 2009-11-03</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#iterator.requirements">active issues</a> in [iterator.requirements].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#iterator.requirements">issues</a> in [iterator.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
What requirements does the standard place on equality comparisons between
iterators that refer to elements of different containers.  For example, if
v1 and v2 are empty vectors, is v1.end() == v2.end() allowed to yield true?
Is it allowed to throw an exception?
</p>

<p>
The standard appears to be silent on both questions.
</p>
<p><i>[Sydney: The intention is that comparing two iterators from
different containers is undefined, but it's not clear if we say that,
or even whether it's something we should be saying in clause 23 or in
clause 24.  Intuitively we might want to say that equality is defined
only if one iterator is reachable from another, but figuring out how
to say it in any sensible way is a bit tricky: reachability is defined
in terms of equality, so we can't also define equality in terms of
reachability.
]</i></p>


<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
Daniel volunteered to work on this.
</blockquote>

<p><i>[
2009-09-20 Daniel provided wording.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Leave as Open. Alisdair has volunteered to refine the wording.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Insert a new paragraph between 24.2 [iterator.requirements]/7+8:
</p>

<blockquote>
<p>
[..] The result of the application of functions in the library to invalid
ranges is undefined.
</p>

<p><ins>The result of directly or indirectly evaluating any comparison function
or the binary - operator with two iterator values as arguments that
were obtained
from two different ranges <tt>r1</tt> and <tt>r2</tt> (including their past-the-end values) which
are not subranges of one common range is undefined, unless explicitly
described otherwise.</ins>
</p>

</blockquote>






<hr>
<h3><a name="471"></a>471. result of what() implementation-defined</h3>
<p><b>Section:</b> 18.8.1 [exception] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2004-06-28  <b>Last modified:</b> 2009-10-26</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>

<p>[lib.exception] specifies the following:</p>
<pre>    exception (const exception&amp;) throw();
    exception&amp; operator= (const exception&amp;) throw();

    -4- Effects: Copies an exception object.
    -5- Notes: The effects of calling what() after assignment
        are implementation-defined.
</pre>

<p>
First, does the Note only apply to the assignment operator? If so,
what are the effects of calling what() on a copy of an object? Is
the returned pointer supposed to point to an identical copy of
the NTBS returned by what() called on the original object or not?
</p>

<p>
Second, is this Note intended to extend to all the derived classes
in section 19? I.e., does the standard provide any guarantee for
the effects of what() called on a copy of any of the derived class
described in section 19?
</p>

<p>
Finally, if the answer to the first question is no, I believe it
constitutes a defect since throwing an exception object typically
implies invoking the copy ctor on the object. If the answer is yes,
then I believe the standard ought to be clarified to spell out
exactly what the effects are on the copy (i.e., after the copy
ctor was called).
</p>

<p><i>[Redmond: Yes, this is fuzzy.  The issue of derived classes is
  fuzzy too.]</i></p>


<p><i>[
Batavia: Howard provided wording.
]</i></p>


<p><i>[
Bellevue:
]</i></p>


<blockquote>
<p>
Eric concerned this is unimplementable, due to nothrow guarantees.
Suggested implementation would involve reference counting.
</p>
<p>
Is the implied reference counting subtle enough to call out a note on
implementation? Probably not.
</p>
<p>
If reference counting required, could we tighten specification further
to require same pointer value? Probably an overspecification, especially
if exception classes defer evalutation of final string to calls to
what().
</p>
<p>
Remember issue moved open and not resolved at Batavia, but cannot
remember who objected to canvas a disenting opinion - please speak up if
you disagree while reading these minutes!
</p>
<p>
Move to Ready as we are accepting words unmodified.
</p>
</blockquote>

<p><i>[
Sophia Antipolis:
]</i></p>


<blockquote>
The issue was pulled from Ready.  It needs to make clear that only homogenous copying
is intended to be supported, not coping from a derived to a base.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Howard supplied the following replacement wording
for paragraph 7 of the proposed resolution:
</p>
<blockquote>
<ins>-7- <i>Postcondition:</i> <tt>what()</tt> shall return the same NTBS
  as would be obtained by using <tt>static_cast</tt>
  to cast the rhs to the same types as the lhs
  and then calling <tt>what()</tt> on that possibly sliced object.</ins>
</blockquote>
<p>
Pete asks what "the same NTBS" means.
</p>
</blockquote>

<p><i>[
2009-07-30 Niels adds:
]</i></p>


<blockquote>
Further discussion in the thread starting with c++std-lib-24512.
</blockquote>

<p><i>[
2009-09-24 Niels provided updated wording:
]</i></p>


<blockquote>
<p>
I think the resolution should at least guarantee
that the result of <tt>what()</tt> is independent of whether the compiler does
copy-elision. And for any class derived from <tt>std::excepion</tt> that has a
constructor that allows specifying a <tt>what_arg</tt>, it should make sure that
the text of a user-provided <tt>what_arg</tt> is preserved, when the object is
copied. Note that all the implementations I've tested already appear to
satisfy the proposed resolution, including MSVC 2008 SP1, Apache
stdcxx-4.2.1, GCC 4.1.2, GCC 4.3.2, and CodeGear C++ 6.13.
</p>
<p>
The proposed resolution was updated with help from Daniel Krgler;
the update aims to clarify that the proposed postcondition only
applies to homogeneous copying.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Moved to Ready after inserting "publicly accessible" in two places.
</blockquote>



<p><b>Proposed resolution:</b></p>

<p>
Change 18.8.1 [exception] to:
</p>

<blockquote>
<p>
-1- The class <tt>exception</tt> defines the base class for the types of
objects thrown as exceptions by C++ standard library components, and
certain expressions, to report errors detected during program execution.
</p>
<p><ins>
Each standard library class <tt>T</tt> that derives from class
<tt>exception</tt> shall have a publicly accessible copy constructor and a publicly accessible copy assignment
operator that do not exit with an exception. These member functions
shall preserve the following postcondition: If two objects <i>lhs</i>
and <i>rhs</i> both have dynamic type <tt>T</tt>, and <i>lhs</i> is a
copy of <i>rhs</i>, then <tt>strcmp(<i>lhs</i>.what(),
<i>rhs</i>.what()) == 0</tt>.
</ins></p>
<p>
 ...
</p>

<pre>exception(const exception&amp; <ins>rhs</ins>) throw();
exception&amp; operator=(const exception&amp; <ins>rhs</ins>) throw();</pre>

<blockquote>
<p>
-4- <i>Effects:</i> Copies an exception object.
</p>
<p>
<del> -5- <i>Remarks:</i> The effects of calling <tt>what()</tt> after assignment
are implementation-defined.</del>
</p>
<p>
<ins>-5- <i>Postcondition:</i>
	If <tt>*this</tt>
	and <i>rhs</i> both have dynamic type <tt>exception</tt>
	then <tt>strcmp(what(), <i>rhs</i>.what()) == 0</tt>.</ins>
</p>

</blockquote>

</blockquote>





<hr>
<h3><a name="473"></a>473. underspecified ctype calls</h3>
<p><b>Section:</b> 22.4.1.1 [locale.ctype] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2004-07-01  <b>Last modified:</b> 2009-10-21</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Most ctype member functions come in two forms: one that operates
on a single character at a time and another form that operates
on a range of characters. Both forms are typically described by
a single Effects and/or Returns clause.
</p>
<p>
The Returns clause of each of the single-character non-virtual forms
suggests that the function calls the corresponding single character
virtual function, and that the array form calls the corresponding
virtual array form. Neither of the two forms of each virtual member
function is required to be implemented in terms of the other.
</p>
<p>
There are three problems:
</p>
<p>
1. One is that while the standard does suggest that each non-virtual
member function calls the corresponding form of the virtual function,
it doesn't actually explicitly require it.
</p>
<p>
Implementations that cache results from some of the virtual member
functions for some or all values of their arguments might want to
call the array form from the non-array form the first time to fill
the cache and avoid any or most subsequent virtual calls. Programs
that rely on each form of the virtual function being called from
the corresponding non-virtual function will see unexpected behavior
when using such implementations.
</p>
<p>
2. The second problem is that either form of each of the virtual
functions can be overridden by a user-defined function in a derived
class to return a value that is different from the one produced by
the virtual function of the alternate form that has not been
overriden.
</p>
<p>
Thus, it might be possible for, say, ctype::widen(c) to return one
value, while for ctype::widen(&amp;c, &amp;c + 1, &amp;wc) to set
wc to another value. This is almost certainly not intended. Both
forms of every function should be required to return the same result
for the same character, otherwise the same program using an
implementation that calls one form of the functions will behave
differently than when using another implementation that calls the
other form of the function "under the hood."
</p>
<p>
3. The last problem is that the standard text fails to specify whether
one form of any of the virtual functions is permitted to be implemented
in terms of the other form or not, and if so, whether it is required
or permitted to call the overridden virtual function or not.
</p>
<p>
Thus, a program that overrides one of the virtual functions so that
it calls the other form which then calls the base member might end
up in an infinite loop if the called form of the base implementation
of the function in turn calls the other form.
</p>
<p>
Lillehammer: Part of this isn't a real problem. We already talk about
caching. 22.1.1/6 But part is a real problem. ctype virtuals may call
each other, so users don't know which ones to override to avoid avoid
infinite loops.</p>

<p>This is a problem for all facet virtuals, not just ctype virtuals,
so we probably want a blanket statement in clause 22 for all
facets. The LWG is leaning toward a blanket prohibition, that a
facet's virtuals may never call each other. We might want to do that
in clause 27 too, for that matter. A review is necessary.  Bill will
provide wording.</p>

<p><i>[
2009-07 Frankfurt, Howard provided wording directed by consensus.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Move to Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add paragraph 3 to 22.4 [locale.categories]:
</p>

<blockquote><ins>
-3- Within this clause it is unspecified if one virtual function calls another
virtual function.
</ins></blockquote>



<p><b>Rationale:</b></p>
<p>
We are explicitly not addressing bullet
item #2, thus giving implementors more latitude. Users will have to
override both virtual functions, not just one.
</p>




<hr>
<h3><a name="485"></a>485. output iterator insufficiently constrained</h3>
<p><b>Section:</b> 24.2.2 [output.iterators] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Chris Jefferson <b>Opened:</b> 2004-10-13  <b>Last modified:</b> 2009-10-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#output.iterators">issues</a> in [output.iterators].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The note on 24.1.2 Output iterators insufficiently limits what can be
performed on output iterators. While it requires that each iterator is
progressed through only once and that each iterator is written to only
once, it does not require the following things:</p>

<p>Note: Here it is assumed that x is an output iterator of type X which
has not yet been assigned to.</p>

<p>a) That each value of the output iterator is written to:
The standard allows:
++x; ++x; ++x;
</p>

<p>
b) That assignments to the output iterator are made in order
X a(x); ++a; *a=1; *x=2; is allowed
</p>

<p>
c) Chains of output iterators cannot be constructed:
X a(x); ++a; X b(a); ++b; X c(b); ++c; is allowed, and under the current
wording (I believe) x,a,b,c could be written to in any order.
</p>

<p>I do not believe this was the intension of the standard?</p>
<p><i>[Lillehammer: Real issue.  There are lots of constraints we
  intended but didn't specify.  Should be solved as part of iterator
  redesign.]</i></p>


<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
Bill provided wording according to consensus.
</blockquote>

<p><i>[
2009-07-21 Alisdair requests change from Review to Open.  See thread starting
with c++std-lib-24459 for discussion.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Modified wording.  Set to Review.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Move to Ready after looking at again in a larger group in Santa Cruz.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change Table 101 &#8212; Output iterator requirements in 24.2.2 [output.iterators]:
</p>
<blockquote>
<table border="1">
<caption>Table 101 &#8212; Output iterator requirements</caption>
<tbody><tr>
<th>Expression</th>
<th>Return type</th>
<th>Operational semantics</th>
<th>Assertion/note pre-/post-condition</th>
</tr>

<tr>
<td>
<tt>X(a)</tt>
</td>
<td>
&nbsp;
</td>
<td>
&nbsp;
</td>
<td>
<tt>a = t</tt> is equivalent to <tt>X(a) = t</tt>. note: a destructor is assumed.
</td>
</tr>

<tr>
<td>
<tt>X u(a);</tt><br>
<tt>X u = a;</tt>
</td>
<td>
&nbsp;
</td>
<td>
&nbsp;
</td>
<td>
&nbsp;
</td>
</tr>

<tr>
<td>
<tt>*r = o</tt>
</td>
<td>
result is not used
</td>
<td>
&nbsp;
</td>
<td>
<ins>
Post: <tt>r</tt> is not required to be dereferenceable.  <tt>r</tt> is incrementable.
</ins>
</td>
</tr>

<tr>
<td>
<tt>++r</tt>
</td>
<td>
<tt>X&amp;</tt>
</td>
<td>
&nbsp;
</td>
<td>
<tt>&amp;r == &amp;++r</tt>
<ins>
Post: <tt>r</tt> is dereferenceable, unless otherwise specified.  <tt>r</tt> is not required to be incrementable.
</ins>
</td>
</tr>

<tr>
<td>
<tt>r++</tt>
</td>
<td>
convertible to <tt>const X&amp;</tt>
</td>
<td>
<tt>{X tmp = r;<br>++r;<br>return tmp;}</tt>
</td>
<td>
<ins>
Post: <tt>r</tt> is dereferenceable, unless otherwise specified. <tt>r</tt> is not required to be incrementable.
</ins>
</td>
</tr>

<tr>
<td>
<tt>*r++ = o;</tt>
</td>
<td>
result is not used
</td>
<td>
&nbsp;
</td>
<td>

</td>
</tr>

</tbody></table>
</blockquote>





<hr>
<h3><a name="539"></a>539. partial_sum and adjacent_difference should mention requirements</h3>
<p><b>Section:</b> 26.7.3 [partial.sum] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Marc Schoolderman <b>Opened:</b> 2006-02-06  <b>Last modified:</b> 2009-10-24</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There are some problems in the definition of partial_sum and
adjacent_difference in 26.4 [lib.numeric.ops]
</p>

<p>
Unlike <tt>accumulate</tt> and <tt>inner_product</tt>, these functions are not
parametrized on a "type T", instead, 26.4.3 [lib.partial.sum] simply
specifies the effects clause as;
</p>

<blockquote><p>
Assigns to every element referred to by iterator <tt>i</tt> in the range
<tt>[result,result + (last - first))</tt> a value correspondingly equal to
</p>
<blockquote><pre>((...(* first + *( first + 1)) + ...) + *( first + ( i - result )))
</pre></blockquote>
</blockquote>

<p>
And similarly for BinaryOperation. Using just this definition, it seems
logical to expect that:
</p>


<blockquote><pre>char i_array[4] = { 100, 100, 100, 100 };
int  o_array[4];

std::partial_sum(i_array, i_array+4, o_array);
</pre></blockquote>

<p>
Is equivalent to
</p>

<blockquote><pre>int o_array[4] = { 100, 100+100, 100+100+100, 100+100+100+100 };
</pre></blockquote>

<p>
i.e. 100, 200, 300, 400, with addition happening in the <tt>result type</tt>,
<tt>int</tt>.
</p>

<p>
Yet all implementations I have tested produce 100, -56, 44, -112,
because they are using an accumulator of the <tt>InputIterator</tt>'s
<tt>value_type</tt>, which in this case is <tt>char</tt>, not <tt>int</tt>.
</p>

<p>
The issue becomes more noticeable when the result of the expression <tt>*i +
*(i+1)</tt> or <tt>binary_op(*i, *i-1)</tt> can't be converted to the
<tt>value_type</tt>. In a contrived example:
</p>

<blockquote><pre>enum not_int { x = 1, y = 2 };
...
not_int e_array[4] = { x, x, y, y };
std::partial_sum(e_array, e_array+4, o_array);
</pre></blockquote>

<p>
Is it the intent that the operations happen in the <tt>input type</tt>, or in
the <tt>result type</tt>?
</p>

<p>
If the intent is that operations happen in the <tt>result type</tt>, something
like this should be added to the "Requires" clause of 26.4.3/4
[lib.partial.sum]:
</p>

<blockquote><p>
The type of <tt>*i + *(i+1)</tt> or <tt>binary_op(*i, *(i+1))</tt> shall meet the
requirements of <tt>CopyConstructible</tt> (20.1.3) and <tt>Assignable</tt>
(23.1) types.
</p></blockquote>

<p>
(As also required for <tt>T</tt> in 26.4.1 [lib.accumulate] and 26.4.2
[lib.inner.product].)
</p>

<p>
The "auto initializer" feature proposed in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1894.pdf">N1894</a>
is not required to
implement <tt>partial_sum</tt> this way. The 'narrowing' behaviour can still be
obtained by using the <tt>std::plus&lt;&gt;</tt> function object.
</p>

<p>
If the intent is that operations happen in the <tt>input type</tt>, then
something like this should be added instead;
</p>

<blockquote><p>
The type of *first shall meet the requirements of
<tt>CopyConstructible</tt> (20.1.3) and <tt>Assignable</tt> (23.1) types.
The result of <tt>*i + *(i+1)</tt> or <tt>binary_op(*i, *(i+1))</tt> shall be
convertible to this type.
</p></blockquote>

<p>
The 'widening' behaviour can then be obtained by writing a custom proxy
iterator, which is somewhat involved.
</p>

<p>
In both cases, the semantics should probably be clarified.
</p>

<p>
26.4.4 [lib.adjacent.difference] is similarly underspecified, although
all implementations seem to perform operations in the 'result' type:
</p>

<blockquote><pre>unsigned char i_array[4] = { 4, 3, 2, 1 };
int o_array[4];

std::adjacent_difference(i_array, i_array+4, o_array);
</pre></blockquote>

<p>
o_array is 4, -1, -1, -1 as expected, not 4, 255, 255, 255.
</p>

<p>
In any case, <tt>adjacent_difference</tt> doesn't mention the requirements on the
<tt>value_type</tt>; it can be brought in line with the rest of 26.4
[lib.numeric.ops] by adding the following to 26.4.4/2
[lib.adjacent.difference]:
</p>

<blockquote><p>
The type of <tt>*first</tt> shall meet the requirements of
<tt>CopyConstructible</tt> (20.1.3) and <tt>Assignable</tt> (23.1) types."
</p></blockquote>
<p><i>[
Berlin: Giving output iterator's value_types very controversial. Suggestion of
adding signatures to allow user to specify "accumulator".
]</i></p>


<p><i>[
Bellevue:
]</i></p>


<blockquote>
The intent of the algorithms is to perform their calculations using the type of the input iterator.
Proposed wording provided.
</blockquote>

<p><i>[
Sophia Antipolis:
]</i></p>


<blockquote>
We did not agree that the proposed resolution was correct. For example,
when the arguments are types <tt>(float*, float*, double*)</tt>, the
highest-quality solution would use double as the type of the
accumulator. If the intent of the wording is to require that the type of
the accumulator must be the <tt>input_iterator</tt>'s <tt>value_type</tt>, the wording
should specify it.
</blockquote>

<p><i>[
2009-05-09 Alisdair adds:
]</i></p>


<blockquote>
<p>
Now that we have the facility, the 'best' accumulator type could probably be
deduced as:
</p>
<blockquote><pre>std::common_type&lt;InIter::value_type, OutIter::reference&gt;::type
</pre></blockquote>
<p>
This type would then have additional requirements of constructability and
incrementability/assignability.
</p>
<p>
If this extracting an accumulator type from a pair/set of iterators (with
additional requirements on that type) is a problem for multiple functions,
it might be worth extracting into a SharedAccumulator concept or similar.
</p>
<p>
I'll go no further in writing up wording now, until the group gives a
clearer indication of preferred direction.
</p>
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
The proposed resolution isn't quite right. For example, "the type of
*first" should be changed to "iterator::value_type" or similar. Daniel
volunteered to correct the wording.
</blockquote>

<p><i>[
2009-07-29 Daniel corrected wording.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Move to Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>



<ol>
<li>
<p>
Change 26.7.3 [partial.sum]/1 as indicated:
</p>

<blockquote>
<p>
<i>Effects:</i> <ins>Let <tt>VT</tt> be <tt>InputIterator</tt>'s value type. For a nonempty range,
initializes an accumulator <tt>acc</tt> of type <tt>VT</tt> with <tt>*first</tt> and performs
<tt>*result = acc</tt>. For every iterator <tt>i</tt> in <tt>[first + 1, last)</tt> in order, <tt>acc</tt> is then
modified by <tt>acc = acc + *i</tt> or <tt>acc = binary_op(acc, *i)</tt> and is assigned
to <tt>*(result + (i - first))</tt>.</ins> <del>Assigns to every element referred to by
iterator <tt>i</tt> in the range <tt>[result,result + (last - first))</tt> a value
correspondingly
equal to</del>
</p>

<blockquote><pre><del>
((...(*first + *(first + 1)) + ...) + *(first + (i - result)))
</del></pre></blockquote>

<p><del>
or
</del></p>

<blockquote><pre><del>
binary_op(binary_op(...,
   binary_op(*first, *(first + 1)),...), *(first + (i - result)))
</del></pre></blockquote>
</blockquote>
</li>

<li>
<p>
Change 26.7.3 [partial.sum]/3 as indicated:
</p>

<blockquote>
<i>Complexity:</i> Exactly <tt><ins>max(</ins>(last - first) - 1<ins>, 0)</ins></tt>
applications
of <tt><del>binary_op</del></tt><ins>the binary operation</ins>.
</blockquote>
</li>

<li>
<p>
Change 26.7.3 [partial.sum]/4 as indicated:
</p>

<blockquote>
<i>Requires:</i> <ins><tt>VT</tt> shall be constructible from the type of <tt>*first</tt>, the result of
<tt>acc + *i</tt> or <tt>binary_op(acc, *i)</tt> shall be implicitly convertible to <tt>VT</tt>, and
the result of the expression <tt>acc</tt> shall be writable to the <tt>result</tt>
output iterator.</ins> In the ranges <tt>[first,last]</tt> and
<tt>[result,result + (last - first)]</tt> [..]
</blockquote>
</li>

<li>
<p>
Change 26.7.4 [adjacent.difference]/1 as indicated:
</p>

<blockquote>
<p>
<i>Effects:</i> <ins>Let <tt>VT</tt> be <tt>InputIterator</tt>'s value type. For a nonempty range,
initializes an accumulator <tt>acc</tt> of type <tt>VT</tt> with <tt>*first</tt> and performs
<tt>*result = acc</tt>. For every iterator <tt>i</tt> in <tt>[first + 1, last)</tt> in order,
initializes a
value <tt>val</tt> of type <tt>VT</tt> with <tt>*i</tt>, assigns the result of <tt>val - acc</tt> or
<tt>binary_op(val, acc)</tt>
to <tt>*(result + (i - first))</tt> and modifies <tt>acc = std::move(val)</tt>.</ins>
<del>Assigns to every element referred to by iterator <tt>i</tt> in the range
<tt>[result + 1,
result + (last - first))</tt> a value correspondingly equal to</del>
</p>

<blockquote><pre><del>
*(first + (i - result)) - *(first + (i - result) - 1)
</del></pre></blockquote>

<p><del>
or
</del></p>

<blockquote><pre><del>
binary_op(*(first + (i - result)), *(first + (i - result) - 1)).
</del></pre></blockquote>

<p><del>
result gets the value of *first.</del>
</p>
</blockquote>
</li>

<li>
<p>
Change 26.7.4 [adjacent.difference]/2 as indicated:
</p>

<blockquote>
<i>Requires:</i> <ins><tt>VT</tt> shall be <tt>MoveAssignable</tt> ([moveassignable])
and shall be
constructible from the type of <tt>*first</tt>. The result
of the expression <tt>acc</tt> and the result of the expression <tt>val - acc</tt> or
<tt>binary_op(val, acc)</tt>
shall be writable to the <tt>result</tt> output iterator.</ins> In the ranges
<tt>[first,last]</tt> [..]
</blockquote>
</li>

<li>
<p>
Change 26.7.4 [adjacent.difference]/5 as indicated:
</p>

<blockquote>
<i>Complexity:</i> Exactly <tt><ins>max(</ins>(last - first) - 1<ins>, 0)</ins></tt>
applications
of <del><tt>binary_op</tt></del><ins>the binary operation</ins>.
</blockquote>
</li>
</ol>








<hr>
<h3><a name="556"></a>556. is Compare a BinaryPredicate?</h3>
<p><b>Section:</b> 25.4 [alg.sorting] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Review">Review</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2006-02-05  <b>Last modified:</b> 2009-10-25</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.sorting">issues</a> in [alg.sorting].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Review">Review</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 25, p8 we allow BinaryPredicates to return a type that's convertible
to bool but need not actually be bool. That allows predicates to return
things like proxies and requires that implementations be careful about
what kinds of expressions they use the result of the predicate in (e.g.,
the expression in if (!pred(a, b)) need not be well-formed since the
negation operator may be inaccessible or return a type that's not
convertible to bool).
</p>
<p>
Here's the text for reference:
</p>
<blockquote><p>
  ...if an algorithm takes BinaryPredicate binary_pred as its argument
 and first1 and first2 as its iterator arguments, it should work
 correctly in the construct if (binary_pred(*first1, first2)){...}.
</p></blockquote>

<p>
In 25.3, p2 we require that the Compare function object return true
of false, which would seem to preclude such proxies. The relevant text
is here:
</p>
<blockquote><p>
  Compare is used as a function object which returns true if the first
  argument is less than the second, and false otherwise...
</p></blockquote>

<p><i>[
Portland:  Jack to define "convertible to bool" such that short circuiting isn't
destroyed.
]</i></p>


<p><i>[
2009-07-28 Reopened by Alisdair.  No longer solved by concepts.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Move to Review once wording received. Stefanus to send proposed wording.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Move to Review once wording received. Stefanus to send proposed wording.
</blockquote>

<p><i>[
2009-10-24 Stefanus supplied wording.
]</i></p>


<blockquote>
Move to Review once wording received. Stefanus to send proposed wording.
Current proposed wording proposed here:
<blockquote>
<p>
I think we could fix this by rewording 25.3, p2 to read somthing like:
</p>
<blockquote><p>
-2- <tt>Compare</tt> is <del>used as a function object which returns
<tt>true</tt> if the first argument</del> <ins>a <tt>BinaryPredicate</tt>. The
return value of the function call operator applied to an object of type
<tt>Compare</tt>, when converted to type <tt>bool</tt>, yields <tt>true</tt>
if the first argument of the call</ins> is less than the second, and
<tt>false</tt> otherwise. <tt>Compare <i>comp</i></tt> is used throughout for
algorithms assuming an ordering relation. It is assumed that <tt><i>comp</i></tt>
will not apply any non-constant function through the dereferenced iterator.
</p></blockquote>
</blockquote>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 25.4 [alg.sorting] p2:
</p>
<blockquote>
<tt>Compare</tt> is used as a function object<ins>. The return value of
the function call operator applied to an object of type Compare, when
converted to type bool, yields true if the first argument of the
call</ins> <del>which returns <tt>true</tt> if the first argument</del>
is less than the second, and <tt>false</tt> otherwise. <tt>Compare
comp</tt> is used throughout for algorithms assuming an ordering
relation. It is assumed that <tt>comp</tt> will not apply any
non-constant function through the dereferenced iterator.
</blockquote>


<p><b>Rationale:</b></p>
<p><i>[
San Francisco:
]</i></p>


<blockquote>
Solved by
(<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2774.pdf">N2774</a>).
</blockquote>






<hr>
<h3><a name="594"></a>594. Disadvantages of defining Swappable in terms of CopyConstructible and Assignable</h3>
<p><b>Section:</b> 20.2.1 [utility.arg.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Niels Dekker <b>Opened:</b> 2006-11-02  <b>Last modified:</b> 2009-11-08</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#utility.arg.requirements">active issues</a> in [utility.arg.requirements].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#utility.arg.requirements">issues</a> in [utility.arg.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It seems undesirable to define the Swappable requirement in terms of
CopyConstructible and Assignable requirements. And likewise, once the
MoveConstructible and MoveAssignable requirements (N1860) have made it
into the Working Draft, it seems undesirable to define the Swappable
requirement in terms of those requirements. Instead, it appears
preferable to have the Swappable requirement defined exclusively in
terms of the existence of an appropriate swap function.
</p>
<p>
Section 20.1.4 [lib.swappable] of the current Working Draft (N2009)
says:
</p>
<blockquote><p>
The Swappable requirement is met by satisfying one or more of the
following conditions:</p>
<ul>
<li>
T is Swappable if T satisfies the CopyConstructible requirements
(20.1.3) and the Assignable requirements (23.1);
</li>
<li>
T is Swappable if a namespace scope function named swap exists in the
same namespace as the definition of T, such that the expression
swap(t,u) is valid and has the semantics described in Table 33.
</li>
</ul>
</blockquote>
<p>
I can think of three disadvantages of this definition:
</p>
<ol>
<li>
<p>
If a client's type T satisfies the first condition (T is both
CopyConstructible and Assignable), the client cannot stop T from
satisfying the Swappable requirement without stopping T from
satisfying the first condition.
</p>
<p>
A client might want to stop T from satisfying the Swappable
requirement, because swapping by means of copy construction and
assignment might throw an exception, and she might find a throwing
swap unacceptable for her type. On the other hand, she might not feel
the need to fully implement her own swap function for this type. In
this case she would want to be able to simply prevent algorithms that
would swap objects of type T from being used, e.g., by declaring a
swap function for T, and leaving this function purposely undefined.
This would trigger a link error, if an attempt would be made to use
such an algorithm for this type. For most standard library
implementations, this practice would indeed have the effect of
stopping T from satisfying the Swappable requirement.
</p>
</li>
<li>
<p>
A client's type T that does not satisfy the first condition can not be
made Swappable by providing a specialization of std::swap for T.
</p>
<p>
While I'm aware about the fact that people have mixed feelings about
providing a specialization of std::swap, it is well-defined to do so.
It sounds rather counter-intuitive to say that T is not Swappable, if
it has a valid and semantically correct specialization of std::swap.
Also in practice, providing such a specialization will have the same
effect as satisfying the Swappable requirement.
</p>
</li>
<li>
<p>
For a client's type T that satisfies both conditions of the Swappable
requirement, it is not specified which of the two conditions prevails.
After reading section 20.1.4 [lib.swappable], one might wonder whether
objects of T will be swapped by doing copy construction and
assignments, or by calling the swap function of T.
</p>
<p>
I'm aware that the intention of the Draft is to prefer calling the
swap function of T over doing copy construction and assignments. Still
in my opinion, it would be better to make this clear in the wording of
the definition of Swappable. 
</p>
</li>
</ol>
<p>
I would like to have the Swappable requirement defined in such a way
that the following code fragment will correctly swap two objects of a
type T, if and only if T is Swappable:
</p>
<pre>   using std::swap;
   swap(t, u);  // t and u are of type T.
</pre>
<p>
This is also the way Scott Meyers recommends calling a swap function,
in Effective C++, Third Edition, item 25.
</p>
<p>
Most aspects of this issue have been dealt with in a discussion on
comp.std.c++ about the Swappable requirement, from 13 September to 4
October 2006, including valuable input by David Abrahams, Pete Becker,
Greg Herlihy, Howard Hinnant and others.
</p>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
Recommend NAD.  Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2774.pdf">N2774</a>.
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
Moved to Open.  Waiting for non-concepts draft.
</blockquote>

<p><i>[
2009-11-08 Howard adds:
]</i></p>


<blockquote>
This issue is very closely related to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#742">742</a>.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change section 20.1.4 [lib.swappable] as follows:
</p>
<blockquote><p>
The Swappable requirement is met by satisfying
<del>one or more of the following conditions:</del>
<ins>the following condition:</ins></p>
<ul>

<li>
<del>T is Swappable if T satisfies the CopyConstructible requirements
(20.1.3) and the Assignable requirements (23.1);</del>
</li>
<li>
<del>
T is Swappable if a namespace scope function named swap exists in the
same namespace as the definition of T, such that the expression
swap(t,u) is valid and has the semantics described in Table 33.
</del>
T is Swappable if an unqualified function call swap(t,u) is valid
within the namespace std, and has the semantics described in Table 33.
</li>
</ul>
</blockquote>





<hr>
<h3><a name="625"></a>625. mixed up <i>Effects</i> and <i>Returns</i> clauses</h3>
<p><b>Section:</b> 17 [library] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2007-01-20  <b>Last modified:</b> 2009-10-20</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#895">895</a></p>
<p><b>Discussion:</b></p>
 <p>

Many member functions of <code>basic_string</code> are overloaded,
with some of the overloads taking a <code>string</code> argument,
others <code>value_type*</code>, others <code>size_type</code>, and
others still <code>iterators</code>. Often, the requirements on one of
the overloads are expressed in the form of <i>Effects</i>,
<i>Throws</i>, and in the Working Paper
(<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2134.pdf">N2134</a>)
also <i>Remark</i> clauses, while those on the rest of the overloads
via a reference to this overload and using a <i>Returns</i> clause.
</p>

<p>
The difference between the two forms of specification is that per
17.5.1.4 [structure.specifications], p3, an <i>Effects</i> clause specifies
<i>"actions performed by the functions,"</i> i.e., its observable
effects, while a <i>Returns</i> clause is <i>"a description of the
return value(s) of a function"</i> that does not impose any
requirements on the function's observable effects.
</p>

<p>
Since only <i>Notes</i> are explicitly defined to be informative and
all other paragraphs are explicitly defined to be normative, like
<i>Effects</i> and <i>Returns</i>, the new <i>Remark</i> clauses also
impose normative requirements.
</p>

<p>
So by this strict reading of the standard there are some member
functions of <code>basic_string</code> that are required to throw an
exception under some conditions or use specific traits members while
many other otherwise equivalent overloads, while obliged to return the
same values, aren't required to follow the exact same requirements
with regards to the observable effects.
</p>

<p>
Here's an example of this problem that was precipitated by the change
from informative Notes to normative <i>Remark</i>s (presumably made to
address <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#424">424</a>):
</p>

<p>
In the Working Paper, <code>find(string, size_type)</code> contains a
<i>Remark</i> clause (which is just a <i>Note</i> in the current
standard) requiring it to use <code>traits::eq()</code>.
</p>

<p>
<code>find(const charT *s, size_type pos)</code> is specified to
return <code>find(string(s), pos)</code> by a <i>Returns</i> clause
and so it is not required to use <code>traits::eq()</code>. However,
the Working Paper has replaced the original informative <i>Note</i>
about the function using <code>traits::length()</code> with a
normative requirement in the form of a <i>Remark</i>. Calling
<code>traits::length()</code> may be suboptimal, for example when the
argument is a very long array whose initial substring doesn't appear
anywhere in <code>*this</code>.
</p>

<p>
Here's another similar example, one that existed even prior to the
introduction of <i>Remark</i>s:
</p>

<p>
<code> insert(size_type pos, string, size_type, size_type)</code> is
required to throw <code>out_of_range</code> if <code>pos &gt;
size()</code>.
</p>

<p>
<code>insert(size_type pos, string str)</code> is specified to return
<code>insert(pos, str, 0, npos)</code> by a <i>Returns</i> clause and
so its effects when <code>pos &gt; size()</code> are strictly speaking
unspecified.
</p><p>

</p>
I believe a careful review of the current <i>Effects</i> and
<i>Returns</i> clauses is needed in order to identify all such
problematic cases. In addition, a review of the Working Paper should
be done to make sure that the newly introduced normative <i>Remark</i>
clauses do not impose any undesirable normative requirements in place
of the original informative <i>Notes</i>.


<p><i>[
Batavia: Alan and Pete to work.
]</i></p>


<p><i>[
Bellevue: Marked as NAD Editorial.
]</i></p>


<p><i>[
Post-Sophia Antipolis:
Martin indicates there is still work to be done on this issue.
Reopened.
]</i></p>


<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Tom proposes we say that, unless specified otherwise,
it is always the caller's responsibility to verify that supplied arguments
meet the called function's requirements.
If further semantics are specified
(e.g., that the function throws under certain conditions),
then it is up to the implementer to check those conditions.
Alan feels strongly that our current use of Requires in this context
is confusing, especially now that <tt>requires</tt> is a new keyword.
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
Move to Tentatively NAD.
</blockquote>

<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote>
Move to Open.  Martin will work on proposed wording.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="631"></a>631. conflicting requirements for <tt>BinaryPredicate</tt></h3>
<p><b>Section:</b> 25 [algorithms] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Review">Review</a>
 <b>Submitter:</b> James Kanze <b>Opened:</b> 2007-01-31  <b>Last modified:</b> 2009-10-24</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#algorithms">active issues</a> in [algorithms].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#algorithms">issues</a> in [algorithms].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Review">Review</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The general requirements for <tt><tt>BinaryPredicate</tt></tt> (in 25 [algorithms]/8) contradict the implied specific requirements for
some functions. In particular, it says that:
</p>

<blockquote><p>
[...] if an algorithm takes <tt>BinaryPredicate <i>binary_pred</i></tt>
as its argument and <tt><i>first1</i></tt> and <i>first2</i> as its
iterator arguments, it should work correctly in the construct <tt>if
(binary_pred (*<i>first1</i> , *<i>first2</i> )){...}</tt>.
<tt>BinaryPredicate</tt> always takes the first iterator type as its
first argument, that is, in those cases when <tt>T <i>value</i></tt> is
part of the signature, it should work correctly in the context of <tt>if
(binary_pred (*<i>first1</i> , <i>value</i>)){...}</tt>.
</p></blockquote>

<p>
In the description of <tt>upper_bound</tt> (25.4.3.2 [upper.bound]/2), however, the use is described as
"<tt>!comp(<i>value</i>, <i>e</i>)</tt>", where <tt><i>e</i></tt> is an
element of the sequence (a result of dereferencing
<tt>*<i>first</i></tt>).
</p>

<p>
In the description of <tt>lexicographical_compare</tt>, we have both
"<tt>*<i>first1</i> &lt; *<i>first2</i></tt>" and "<tt>*<i>first2</i>
&lt; *<i>first1</i></tt>" (which presumably implies "<tt>comp(
*<i>first1</i>, *<i>first2</i> )</tt>" and "<tt>comp( *<i>first2</i>,
*<i>first1</i> )</tt>".
</p>

<p><i>[
Toronto:  Moved to Open.  ConceptGCC seems to get <tt>lower_bound</tt>
and <tt>upper_bound</tt> to work withoutt these changes.
]</i></p>


<p><i>[
2009-07-28 Reopened by Alisdair.  No longer solved by concepts.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Move to Review. The small problem with the "iterator type"
will be fixed. The cited functions (<tt>lower_bound</tt>, <tt>uppwer_bound</tt>,
<tt>equal_range</tt>) don't actually use <tt>BinaryPredicate</tt> , and where it is used,
it is consistent with  [algorithm]/8, so the main complaint of the issue
is moot.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Logically, the <tt>BinaryPredicate</tt> is used as an ordering
relationship, with the semantics of "less than".  Depending on the
function, it may be used to determine equality, or any of the inequality
relationships; doing this requires being able to use it with either
parameter first.  I would thus suggest that the requirement be:
</p>

<blockquote><p>
[...] <tt>BinaryPredicate</tt> always takes the first iterator
<tt>value_type</tt> as one of its arguments, it is unspecified which. If
an algorithm takes <tt>BinaryPredicate <i>binary_pred</i></tt> as its
argument and <tt><i><i>first1</i></i></tt> and <i>first2</i> as its
iterator arguments, it should work correctly both in the construct
<tt>if (binary_pred (*<i>first1</i> , *<i>first2</i> )){...}</tt> and
<tt>if (binary_pred (*<i>first2</i>, *<i>first1</i>)){...}</tt>.  In
those cases when <tt>T <i>value</i></tt> is part of the signature, it
should work correctly in the context of <tt>if (binary_pred
(*<i>first1</i> , <i>value</i>)){...}</tt> and of <tt>if (binary_pred
(<i>value</i>, *<i>first1</i>)){...}</tt>. [<i>Note:</i> if the two
types are not identical, and neither is convertable to the other, this
may require that the <tt>BinaryPredicate</tt> be a functional object
with two overloaded <tt>operator()()</tt> functions. <i>--end note</i>]
</p></blockquote>

<p>
Alternatively, one could specify an order for each function. IMHO, this
would be more work for the committee, more work for the implementors,
and of no real advantage for the user: some functions, such as
<tt>lexicographical_compare</tt> or <tt>equal_range</tt>, will still require both
functions, and it seems like a much easier rule to teach that both
functions are always required, rather than to have a complicated list of
when you only need one, and which one.
</p>


<p><b>Rationale:</b></p>
<p><i>[
post San Francisco:
]</i></p>


<blockquote>
Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2759.pdf">N2759</a>.
</blockquote>






<hr>
<h3><a name="671"></a>671. precision of hexfloat</h3>
<p><b>Section:</b> 22.4.2.2.2 [facet.num.put.virtuals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> John Salmon <b>Opened:</b> 2007-04-20  <b>Last modified:</b> 2009-10-21</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#facet.num.put.virtuals">active issues</a> in [facet.num.put.virtuals].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#facet.num.put.virtuals">issues</a> in [facet.num.put.virtuals].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I am trying to understand how TR1 supports hex float (%a) output.
</p>
<p>
As far as I can tell, it does so via the following:
</p>
<p>
8.15 Additions to header &lt;locale&gt; [tr.c99.locale]
</p>
<p>
In subclause 22.4.2.2.2 [facet.num.put.virtuals], Table 58 Floating-point conversions, after
the line:
floatfield == ios_base::scientific %E
</p>
<p>
add the two lines:
</p>
<blockquote><pre>floatfield == ios_base::fixed | ios_base::scientific &amp;&amp; !uppercase %a
floatfield == ios_base::fixed | ios_base::scientific %A 2
</pre></blockquote>
<p>
[Note: The additional requirements on print and scan functions, later
in this clause, ensure that the print functions generate hexadecimal
floating-point fields with a %a or %A conversion specifier, and that
the scan functions match hexadecimal floating-point fields with a %g
conversion specifier.  end note]
</p>
<p>
Following the thread, in 22.4.2.2.2 [facet.num.put.virtuals], we find:
</p>
<p>
For conversion from a floating-point type, if (flags &amp; fixed) != 0 or
if str.precision() &gt; 0, then str.precision() is specified in the
conversion specification.
</p>
<p>
This would seem to imply that when floatfield == fixed|scientific, the
precision of the conversion specifier is to be taken from
str.precision().  Is this really what's intended?  I sincerely hope
that I'm either missing something or this is an oversight.  Please
tell me that the committee did not intend to mandate that hex floats
(and doubles) should by default be printed as if by %.6a.
</p>

<p><i>[
Howard: I think the fundamental issue we overlooked was that with %f,
%e, %g, the default precision was always 6.  With %a the default
precision is not 6, it is infinity.  So for the first time, we need to
distinguish between the default value of precision, and the precision
value 6.
]</i></p>


<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
Leave this open for Robert and Daniel to work on.
</p>
<p>
Straw poll: Disposition?
</p>
<ul>
<li>Default is %.6a (i.e. NAD): 2</li>
<li>Always %a (no precision): 6</li>
<li>precision(-1) == %a: 3</li>
</ul>
<p>
Daniel and Robert have direction to write up wording for the "always %a" solution.
</p>

<p><i>[
2009-07-15 Robert provided wording.
]</i></p>

</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Move to Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 22.4.2.2.2 [facet.num.put.virtuals], Stage 1, under p5 (near the end
of Stage 1):
</p>

<blockquote>
For conversion from a floating-point type, <tt>str.precision()</tt> is specified
<ins>as precision</ins> in the conversion specification
<ins>if <tt>floatfield != (ios_base::fixed | ios_base::scientific)</tt>, else no
precision is specified</ins>.
</blockquote>



<p><i>[
Kona (2007): Robert volunteers to propose wording.
]</i></p>





<hr>
<h3><a name="676"></a>676. Moving the unordered containers</h3>
<p><b>Section:</b> 23.5 [unord] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Review">Review</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2007-05-05  <b>Last modified:</b> 2009-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#unord">issues</a> in [unord].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Review">Review</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Move semantics are missing from the <tt>unordered</tt> containers.  The proposed
resolution below adds move-support consistent with
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1858.html">N1858</a>
and the current working draft.
</p>

<p>
The current proposed resolution simply lists the requirements for each function.
These might better be hoisted into the requirements table for unordered associative containers.
Futhermore a mild reorganization of the container requirements could well be in order.
This defect report is purposefully ignoring these larger issues and just focusing
on getting the unordered containers "moved".
</p>

<p><i>[
2009-07-28 Reopened by Alisdair.  No longer solved by concepts.
]</i></p>


<p><i>[
2009-10-17 Removed rvalue-swaps from wording.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Move to Review. Alisdair will review proposed wording.
</blockquote>

<p><i>[
2009-10-29 Daniel updates wording.
]</i></p>




<p><b>Proposed resolution:</b></p>

<p><b><tt>unordered_map</tt></b></p>

<p>
Change 23.5.1 [unord.map]:
</p>

<blockquote><pre>class unordered_map
{
    ...
    unordered_map(const unordered_map&amp;);
    <ins>unordered_map(unordered_map&amp;&amp;);</ins>
    ~unordered_map();
    unordered_map&amp; operator=(const unordered_map&amp;);
    <ins>unordered_map&amp; operator=(unordered_map&amp;&amp;);</ins>
    ...
    // modifiers 
    <del>std::</del>pair&lt;iterator, bool&gt; insert(const value_type&amp; obj); 
    <ins>template &lt;class P&gt; pair&lt;iterator, bool&gt; insert(P&amp;&amp; obj);</ins>
    iterator       insert(const_iterator hint, const value_type&amp; obj);
    <ins>template &lt;class P&gt; iterator       insert(const_iterator hint, P&amp;&amp; obj);</ins>
    ...
    mapped_type&amp; operator[](const key_type&amp; k);
    <ins>mapped_type&amp; operator[](key_type&amp;&amp; k);</ins>
    ...
};

</pre></blockquote>

<p>
Add to 23.5.1.1 [unord.map.cnstr]:
</p>

<blockquote>
<pre>template &lt;class InputIterator&gt;
  unordered_map(InputIterator f, InputIterator l, 
                size_type n = <i>implementation-defined</i>, 
                const hasher&amp; hf = hasher(), 
                const key_equal&amp; eql = key_equal(), 
                const allocator_type&amp; a = allocator_type());
</pre>

<blockquote><p>
<ins>
<i>Requires:</i> If the iterator's dereference operator returns an
lvalue or a const rvalue <tt>pair&lt;key_type, mapped_type&gt;</tt>,
then both <tt>key_type</tt> and <tt>mapped_type</tt> shall be
<tt>CopyConstructible</tt>.
</ins>
</p></blockquote>
</blockquote>

<p>
Add to 23.5.1.2 [unord.map.elem]:
</p>

<blockquote>

<pre>mapped_type&amp; operator[](const key_type&amp; k);</pre>

<blockquote>
<p>...</p>
<p><ins>
<i>Requires:</i> <tt>key_type</tt> shall be <tt>CopyConstructible</tt>
and <tt>mapped_type</tt> shall be <tt>DefaultConstructible</tt>.
</ins></p>
</blockquote>

<pre><ins>mapped_type&amp; operator[](key_type&amp;&amp; k);</ins></pre>

<blockquote>
<p><ins>
<i>Effects:</i> If the <tt>unordered_map</tt> does not already contain an
element whose key is equivalent to <tt>k</tt> , inserts the value
<tt>std::pair&lt;const key_type, mapped_type&gt;(std::move(k), mapped_type())</tt>.
</ins></p>

<p><ins>
<i>Requires:</i> <tt>mapped_type</tt> shall be <tt>DefaultConstructible</tt>.
</ins></p>

<p><ins>
<i>Returns:</i> A reference to <tt>x.second</tt>, where <tt>x</tt> is the
(unique) element whose key is equivalent to <tt>k</tt>.
</ins></p>

</blockquote>

</blockquote>

<p>
Add new section [unord.map.modifiers]:
</p>

<blockquote>
<pre><ins>pair&lt;iterator, bool&gt; insert(const value_type&amp; x);</ins>
<ins>template &lt;class P&gt; pair&lt;iterator, bool&gt; insert(P&amp;&amp; x);</ins>
<ins>iterator       insert(const_iterator hint, const value_type&amp; x);</ins>
<ins>template &lt;class P&gt; iterator       insert(const_iterator hint, P&amp;&amp; x);</ins>
<ins>template &lt;class InputIterator&gt;
  void insert(InputIterator first, InputIterator last);</ins>
</pre>

<blockquote>
<p><ins>
<i>Requires:</i> Those signatures taking a <tt>const value_type&amp;</tt> parameter
requires both the <tt>key_type</tt> and the <tt>mapped_type</tt> to be
<tt>CopyConstructible</tt>.
 If <tt>P</tt> is instantiated as a reference
type, then the argument <tt>x</tt> is copied from. Otherwise <tt>x</tt>
is considered to be an rvalue as it is converted to <tt>value_type</tt>
and inserted into the <tt>unordered_map</tt>. Specifically, in such
cases <tt>CopyConstructible</tt> is not required for <tt>key_type</tt> or
<tt>mapped_type</tt> unless the conversion from <tt>P</tt> specifically
requires it (e.g. if <tt>P</tt> is a <tt>tuple&lt;const key_type,
mapped_type&gt;</tt>, then <tt>key_type</tt> must be
<tt>CopyConstructible</tt>).
</ins></p>

<p><ins>
The signature taking <tt>InputIterator</tt>
parameters requires <tt>CopyConstructible</tt> of both
<tt>key_type</tt> and <tt>mapped_type</tt> if the dereferenced
<tt>InputIterator</tt> returns an lvalue or <tt>const</tt> rvalue
<tt>value_type</tt>.
</ins></p>

</blockquote>

</blockquote>

<p><b><tt>unordered_multimap</tt></b></p>

<p>
Change 23.5.2 [unord.multimap]:
</p>

<blockquote><pre>class unordered_multimap
{
    ...
    unordered_multimap(const unordered_multimap&amp;);
    <ins>unordered_multimap(unordered_multimap&amp;&amp;);</ins>
    ~unordered_multimap();
    unordered_multimap&amp; operator=(const unordered_multimap&amp;);
    <ins>unordered_multimap&amp; operator=(unordered_multimap&amp;&amp;);</ins>
    ...
    // modifiers 
    iterator insert(const value_type&amp; obj); 
    <ins>template &lt;class P&gt; iterator insert(P&amp;&amp; obj);</ins>
    iterator       insert(const_iterator hint, const value_type&amp; obj);
    <ins>template &lt;class P&gt; iterator       insert(const_iterator hint, P&amp;&amp; obj);</ins>
    ...
};

</pre></blockquote>

<p>
Add to 23.5.2.1 [unord.multimap.cnstr]:
</p>

<blockquote>
<pre>template &lt;class InputIterator&gt;
  unordered_multimap(InputIterator f, InputIterator l, 
                size_type n = <i>implementation-defined</i>, 
                const hasher&amp; hf = hasher(), 
                const key_equal&amp; eql = key_equal(), 
                const allocator_type&amp; a = allocator_type());
</pre>

<blockquote><p>
<ins>
<i>Requires:</i> If the iterator's dereference operator returns an
lvalue or a const rvalue <tt>pair&lt;key_type, mapped_type&gt;</tt>,
then both <tt>key_type</tt> and <tt>mapped_type</tt> shall be
<tt>CopyConstructible</tt>.
</ins>
</p></blockquote>
</blockquote>

<p>
Add new section [unord.multimap.modifiers]:
</p>

<blockquote>
<pre><ins>iterator insert(const value_type&amp; x);</ins>
<ins>template &lt;class P&gt; iterator       insert(P&amp;&amp; x);</ins>
<ins>iterator       insert(const_iterator hint, const value_type&amp; x);</ins>
<ins>template &lt;class P&gt; iterator       insert(const_iterator hint, P&amp;&amp; x);</ins>
<ins>template &lt;class InputIterator&gt;
  void insert(InputIterator first, InputIterator last);</ins>
</pre>

<blockquote>
<p><ins>
<i>Requires:</i> Those signatures taking a <tt>const value_type&amp;</tt> parameter
requires both the <tt>key_type</tt> and the <tt>mapped_type</tt> to be
<tt>CopyConstructible</tt>.
If <tt>P</tt> is instantiated as a reference
type, then the argument <tt>x</tt> is copied from. Otherwise <tt>x</tt>
is considered to be an rvalue as it is converted to <tt>value_type</tt>
and inserted into the <tt>unordered_multimap</tt>. Specifically, in such
cases <tt>CopyConstructible</tt> is not required for <tt>key_type</tt> or
<tt>mapped_type</tt> unless the conversion from <tt>P</tt> specifically
requires it (e.g. if <tt>P</tt> is a <tt>tuple&lt;const key_type,
mapped_type&gt;</tt>, then <tt>key_type</tt> must be
<tt>CopyConstructible</tt>).
</ins></p>

<p><ins>
The signature taking <tt>InputIterator</tt>
parameters requires <tt>CopyConstructible</tt> of both
<tt>key_type</tt> and <tt>mapped_type</tt> if the dereferenced
<tt>InputIterator</tt> returns an lvalue or <tt>const</tt> rvalue
<tt>value_type</tt>.
</ins></p>
</blockquote>

</blockquote>

<p><b><tt>unordered_set</tt></b></p>

<p>
Change 23.5.3 [unord.set]:
</p>

<blockquote><pre>class unordered_set
{
    ...
    unordered_set(const unordered_set&amp;);
    <ins>unordered_set(unordered_set&amp;&amp;);</ins>
    ~unordered_set();
    unordered_set&amp; operator=(const unordered_set&amp;);
    <ins>unordered_set&amp; operator=(unordered_set&amp;&amp;);</ins>
    ...
    // modifiers 
    <del>std::</del>pair&lt;iterator, bool&gt; insert(const value_type&amp; obj); 
    <ins>pair&lt;iterator, bool&gt; insert(value_type&amp;&amp; obj);</ins>
    iterator       insert(const_iterator hint, const value_type&amp; obj);
    <ins>iterator       insert(const_iterator hint, value_type&amp;&amp; obj);</ins>
    ...
};
</pre></blockquote>

<p>
Add to 23.5.3.1 [unord.set.cnstr]:
</p>

<blockquote>
<pre>template &lt;class InputIterator&gt;
  unordered_set(InputIterator f, InputIterator l, 
                size_type n = <i>implementation-defined</i>, 
                const hasher&amp; hf = hasher(), 
                const key_equal&amp; eql = key_equal(), 
                const allocator_type&amp; a = allocator_type());
</pre>

<blockquote><p>
<ins>
<i>Requires:</i> If the iterator's dereference operator returns an
lvalue or a const rvalue <tt>value_type</tt>, then the
<tt>value_type</tt> shall be <tt>CopyConstructible</tt>.
</ins>
</p></blockquote>
</blockquote>

<p>
Add new section [unord.set.modifiers]:
</p>

<blockquote>
<pre><ins>pair&lt;iterator, bool&gt; insert(const value_type&amp; x);</ins>
<ins>pair&lt;iterator, bool&gt; insert(value_type&amp;&amp; x);</ins>
<ins>iterator       insert(const_iterator hint, const value_type&amp; x);</ins>
<ins>iterator       insert(const_iterator hint, value_type&amp;&amp; x);</ins>
<ins>template &lt;class InputIterator&gt;
  void insert(InputIterator first, InputIterator last);</ins>
</pre>

<blockquote>

<p><ins>
<i>Requires:</i> Those signatures taking a <tt>const
value_type&amp;</tt> parameter requires the <tt>value_type</tt> to
be <tt>CopyConstructible</tt>.
</ins></p>

<p><ins>
The signature taking <tt>InputIterator</tt> parameters requires
<tt>CopyConstructible</tt> of <tt>value_type</tt> if the dereferenced
<tt>InputIterator</tt> returns an lvalue or <tt>const</tt> rvalue
<tt>value_type</tt>.
</ins></p>

</blockquote>

</blockquote>

<p><b><tt>unordered_multiset</tt></b></p>

<p>
Change 23.5.4 [unord.multiset]:
</p>

<blockquote><pre>class unordered_multiset
{
    ...
    unordered_multiset(const unordered_multiset&amp;);
    <ins>unordered_multiset(unordered_multiset&amp;&amp;);</ins>
    ~unordered_multiset();
    unordered_multiset&amp; operator=(const unordered_multiset&amp;);
    <ins>unordered_multiset&amp; operator=(unordered_multiset&amp;&amp;);</ins>
    ...
    // modifiers 
    iterator insert(const value_type&amp; obj); 
    <ins>iterator insert(value_type&amp;&amp; obj);</ins>
    iterator       insert(const_iterator hint, const value_type&amp; obj);
    <ins>iterator       insert(const_iterator hint, value_type&amp;&amp; obj);</ins>
    ...
};

</pre></blockquote>

<p>
Add to 23.5.4.1 [unord.multiset.cnstr]:
</p>

<blockquote>
<pre>template &lt;class InputIterator&gt;
  unordered_multiset(InputIterator f, InputIterator l, 
                size_type n = <i>implementation-defined</i>, 
                const hasher&amp; hf = hasher(), 
                const key_equal&amp; eql = key_equal(), 
                const allocator_type&amp; a = allocator_type());
</pre>

<blockquote><p>
<ins>
<i>Requires:</i> If the iterator's dereference operator returns an
lvalue or a const rvalue <tt>value_type</tt>, then the
<tt>value_type</tt> shall be <tt>CopyConstructible</tt>.
</ins>
</p></blockquote>
</blockquote>

<p>
Add new section [unord.multiset.modifiers]:
</p>

<blockquote>
<pre><ins>iterator insert(const value_type&amp; x);</ins>
<ins>iterator insert(value_type&amp;&amp; x);</ins>
<ins>iterator       insert(const_iterator hint, const value_type&amp; x);</ins>
<ins>iterator       insert(const_iterator hint, value_type&amp;&amp; x);</ins>
<ins>template &lt;class InputIterator&gt;
  void insert(InputIterator first, InputIterator last);</ins>
</pre>

<blockquote>

<p><ins>
<i>Requires:</i> Those signatures taking a <tt>const
value_type&amp;</tt> parameter requires the <tt>value_type</tt> to
be <tt>CopyConstructible</tt>.
</ins></p>

<p><ins>
The signature taking <tt>InputIterator</tt> parameters requires
<tt>CopyConstructible</tt> of <tt>value_type</tt> if the dereferenced
<tt>InputIterator</tt> returns an lvalue or <tt>const</tt> rvalue
<tt>value_type</tt>.
</ins></p>

</blockquote>

</blockquote>



<p><i>[
Voted to WP in Bellevue.
]</i></p>


<p><i>[
post Bellevue, Pete notes:
]</i></p>


<blockquote>
<p>
Please remind people who are reviewing issues to check that the text
modifications match the current draft. Issue 676, for example, adds two
overloads for unordered_map::insert taking a hint. One takes a
const_iterator and returns a const_iterator, and the other takes an
iterator and returns an iterator. This was correct at the time the issue
was written, but was changed in Toronto so there is only one hint
overload, taking a const_iterator and returning an iterator.
</p>
<p>
This issue is not ready. In addition to the relatively minor signature
problem I mentioned earlier, it puts requirements in the wrong places.
Instead of duplicating requirements throughout the template
specifications, it should put them in the front matter that talks about
requirements for unordered containers in general. This presentation
problem is editorial, but I'm not willing to do the extensive rewrite
that it requires. Please put it back into Open status.
</p>
</blockquote>

<p><b>Rationale:</b></p>
<p><i>[
San Francisco:
]</i></p>


<blockquote>
Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2776.pdf">N2776</a>.
</blockquote>






<hr>
<h3><a name="704"></a>704. MoveAssignable requirement for container value type overly strict</h3>
<p><b>Section:</b> 23.2 [container.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2007-05-20  <b>Last modified:</b> 2009-10-20</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#container.requirements">active issues</a> in [container.requirements].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#container.requirements">issues</a> in [container.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The move-related changes inadvertently overwrote the intent of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#276">276</a>.
Issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#276">276</a> removed the requirement of <tt>CopyAssignable</tt> from
most of the member functions of node-based containers.  But the move-related changes
unnecessarily introduced the <tt>MoveAssignable</tt> requirement for those members which used to
require <tt>CopyAssignable</tt>.
</p>

<p>
We also discussed (c++std-lib-18722) the possibility of dropping <tt>MoveAssignable</tt>
from some of the sequence requirements.  Additionally the <i>in-place</i> construction
work may further reduce requirements.  For purposes of an easy reference, here are the
minimum sequence requirements as I currently understand them.  Those items in requirements
table in the working draft which do not appear below have been purposefully omitted for
brevity as they do not have any requirements of this nature.  Some items which do not
have any requirements of this nature are included below just to confirm that they were
not omitted by mistake.
</p>

<table border="1">
<caption>Container Requirements</caption>
<tbody><tr><td><tt>X u(a)</tt></td><td><tt>value_type</tt> must be <tt>CopyConstructible</tt></td></tr>
<tr><td><tt>X u(rv)</tt></td><td><tt>array</tt> and containers with a <tt>propagate_never</tt> allocator require <tt>value_type</tt> to be <tt>MoveConstructible</tt></td></tr>
<tr><td><tt>a = u</tt></td><td>Sequences require <tt>value_type</tt> to be <tt>CopyConstructible</tt> and <tt>CopyAssignable</tt>.
                               Associative containers require <tt>value_type</tt> to be <tt>CopyConstructible</tt>.</td></tr>
<tr><td><tt>a = rv</tt></td><td><tt>array</tt> requires <tt>value_type</tt> to be <tt>MoveAssignable</tt>.
                                Sequences and Associative containers with <tt>propagate_never</tt> and <tt>propagate_on_copy_construction</tt> allocators require <tt>value_type</tt> to be <tt>MoveConstructible</tt>.</td></tr>
<tr><td><tt>swap(a,u)</tt></td><td><tt>array</tt> and containers with <tt>propagate_never</tt> and
                  <tt>propagate_on_copy_construction</tt> allocators require <tt>value_type</tt> to be <tt>Swappable</tt>.</td></tr>
</tbody></table>

<p>
</p>

<table border="1">
<caption>Sequence Requirements</caption>
<tbody><tr><td><tt>X(n)</tt></td><td><tt>value_type</tt> must be <tt>DefaultConstructible</tt></td></tr>
<tr><td><tt>X(n, t)</tt></td><td><tt>value_type</tt> must be <tt>CopyConstructible</tt></td></tr>
<tr><td><tt>X(i, j)</tt></td><td>If the iterators return an lvalue the <tt>value_type</tt> must be <tt>CopyConstructible</tt>.
                                 If the iterators return an rvalue the <tt>value_type</tt> must be <tt>MoveConstructible</tt>.</td></tr>
<tr><td><tt>a.insert(p, t)</tt></td><td>The <tt>value_type</tt> must be <tt>CopyConstructible</tt>.
                                        The sequences <tt>vector</tt> and <tt>deque</tt> also require the <tt>value_type</tt> to be <tt>CopyAssignable</tt>.</td></tr>
<tr><td><tt>a.insert(p, rv)</tt></td><td>The <tt>value_type</tt> must be <tt>MoveConstructible</tt>.
                                        The sequences <tt>vector</tt> and <tt>deque</tt> also require the <tt>value_type</tt> to be <tt>MoveAssignable</tt>.</td></tr>
<tr><td><tt>a.insert(p, n, t)</tt></td><td>The <tt>value_type</tt> must be <tt>CopyConstructible</tt>.
                                        The sequences <tt>vector</tt> and <tt>deque</tt> also require the <tt>value_type</tt> to be <tt>CopyAssignable</tt>.</td></tr>
<tr><td><tt>a.insert(p, i, j)</tt></td><td>If the iterators return an lvalue the <tt>value_type</tt> must be <tt>CopyConstructible</tt>.
                                        The sequences <tt>vector</tt> and <tt>deque</tt> also require the <tt>value_type</tt> to be <tt>CopyAssignable</tt> when the iterators return an lvalue.
                                        If the iterators return an rvalue the <tt>value_type</tt> must be <tt>MoveConstructible</tt>.
                                        The sequences <tt>vector</tt> and <tt>deque</tt> also require the <tt>value_type</tt> to be <tt>MoveAssignable</tt> when the iterators return an rvalue.</td></tr>
<tr><td><tt>a.erase(p)</tt></td><td>The sequences <tt>vector</tt> and <tt>deque</tt> require the <tt>value_type</tt> to be <tt>MoveAssignable</tt>.</td></tr>
<tr><td><tt>a.erase(q1, q2)</tt></td><td>The sequences <tt>vector</tt> and <tt>deque</tt> require the <tt>value_type</tt> to be <tt>MoveAssignable</tt>.</td></tr>
<tr><td><tt>a.clear()</tt></td><td></td></tr>
<tr><td><tt>a.assign(i, j)</tt></td><td>If the iterators return an lvalue the <tt>value_type</tt> must be <tt>CopyConstructible</tt> and <tt>CopyAssignable</tt>.
                                        If the iterators return an rvalue the <tt>value_type</tt> must be <tt>MoveConstructible</tt> and <tt>MoveAssignable</tt>.</td></tr>
<tr><td><tt>a.assign(n, t)</tt></td><td>The <tt>value_type</tt> must be <tt>CopyConstructible</tt> and <tt>CopyAssignable</tt>.</td></tr>
<tr><td><tt>a.resize(n)</tt></td><td>The <tt>value_type</tt> must be <tt>DefaultConstructible</tt>.
                                     The sequence <tt>vector</tt> also requires the <tt>value_type</tt> to be <tt>MoveConstructible</tt>.</td></tr>
<tr><td><tt>a.resize(n, t)</tt></td><td>The <tt>value_type</tt> must be <tt>CopyConstructible</tt>.</td></tr>
</tbody></table>

<p>
</p>

<table border="1">
<caption>Optional Sequence Requirements</caption>
<tbody><tr><td><tt>a.front()</tt></td><td></td></tr>
<tr><td><tt>a.back()</tt></td><td></td></tr>
<tr><td><tt>a.push_front(t)</tt></td><td>The <tt>value_type</tt> must be <tt>CopyConstructible</tt>.</td></tr>
<tr><td><tt>a.push_front(rv)</tt></td><td>The <tt>value_type</tt> must be <tt>MoveConstructible</tt>.</td></tr>
<tr><td><tt>a.push_back(t)</tt></td><td>The <tt>value_type</tt> must be <tt>CopyConstructible</tt>.</td></tr>
<tr><td><tt>a.push_back(rv)</tt></td><td>The <tt>value_type</tt> must be <tt>MoveConstructible</tt>.</td></tr>
<tr><td><tt>a.pop_front()</tt></td><td></td></tr>
<tr><td><tt>a.pop_back()</tt></td><td></td></tr>
<tr><td><tt>a[n]</tt></td><td></td></tr>
<tr><td><tt>a.at[n]</tt></td><td></td></tr>
</tbody></table>

<p>
</p>

<table border="1">
<caption>Associative Container Requirements</caption>
<tbody><tr><td><tt>X(i, j)</tt></td><td>If the iterators return an lvalue the <tt>value_type</tt> must be <tt>CopyConstructible</tt>.
                                 If the iterators return an rvalue the <tt>value_type</tt> must be <tt>MoveConstructible</tt>.</td></tr>
<tr><td><tt>a_uniq.insert(t)</tt></td><td>The <tt>value_type</tt> must be <tt>CopyConstructible</tt>.</td></tr>
<tr><td><tt>a_uniq.insert(rv)</tt></td><td>The <tt>key_type</tt> and the <tt>mapped_type</tt> (if it exists) must be <tt>MoveConstructible</tt>.</td></tr>
<tr><td><tt>a_eq.insert(t)</tt></td><td>The <tt>value_type</tt> must be <tt>CopyConstructible</tt>.</td></tr>
<tr><td><tt>a_eq.insert(rv)</tt></td><td>The <tt>key_type</tt> and the <tt>mapped_type</tt> (if it exists) must be <tt>MoveConstructible</tt>.</td></tr>
<tr><td><tt>a.insert(p, t)</tt></td><td>The <tt>value_type</tt> must be <tt>CopyConstructible</tt>.</td></tr>
<tr><td><tt>a.insert(p, rv)</tt></td><td>The <tt>key_type</tt> and the <tt>mapped_type</tt> (if it exists) must be <tt>MoveConstructible</tt>.</td></tr>
<tr><td><tt>a.insert(i, j)</tt></td><td>If the iterators return an lvalue the <tt>value_type</tt> must be <tt>CopyConstructible</tt>.
                                        If the iterators return an rvalue the <tt>key_type</tt> and the <tt>mapped_type</tt> (if it exists) must be <tt>MoveConstructible</tt>..</td></tr>
</tbody></table>

<p>
</p>

<table border="1">
<caption>Unordered Associative Container Requirements</caption>
<tbody><tr><td><tt>X(i, j, n, hf, eq)</tt></td><td>If the iterators return an lvalue the <tt>value_type</tt> must be <tt>CopyConstructible</tt>.
                                 If the iterators return an rvalue the <tt>value_type</tt> must be <tt>MoveConstructible</tt>.</td></tr>
<tr><td><tt>a_uniq.insert(t)</tt></td><td>The <tt>value_type</tt> must be <tt>CopyConstructible</tt>.</td></tr>
<tr><td><tt>a_uniq.insert(rv)</tt></td><td>The <tt>key_type</tt> and the <tt>mapped_type</tt> (if it exists) must be <tt>MoveConstructible</tt>.</td></tr>
<tr><td><tt>a_eq.insert(t)</tt></td><td>The <tt>value_type</tt> must be <tt>CopyConstructible</tt>.</td></tr>
<tr><td><tt>a_eq.insert(rv)</tt></td><td>The <tt>key_type</tt> and the <tt>mapped_type</tt> (if it exists) must be <tt>MoveConstructible</tt>.</td></tr>
<tr><td><tt>a.insert(p, t)</tt></td><td>The <tt>value_type</tt> must be <tt>CopyConstructible</tt>.</td></tr>
<tr><td><tt>a.insert(p, rv)</tt></td><td>The <tt>key_type</tt> and the <tt>mapped_type</tt> (if it exists) must be <tt>MoveConstructible</tt>.</td></tr>
<tr><td><tt>a.insert(i, j)</tt></td><td>If the iterators return an lvalue the <tt>value_type</tt> must be <tt>CopyConstructible</tt>.
                                        If the iterators return an rvalue the <tt>key_type</tt> and the <tt>mapped_type</tt> (if it exists) must be <tt>MoveConstructible</tt>..</td></tr>
</tbody></table>

<p>
</p>

<table border="1">
<caption>Miscellaneous Requirements</caption>
<tbody><tr><td><tt>map[lvalue-key]</tt></td><td>The <tt>key_type</tt> must be <tt>CopyConstructible</tt>.
                                         The <tt>mapped_type</tt> must be <tt>DefaultConstructible</tt> and <tt>MoveConstructible</tt>.</td></tr>
<tr><td><tt>map[rvalue-key]</tt></td><td>The <tt>key_type</tt> must be <tt>MoveConstructible</tt>.
                                         The <tt>mapped_type</tt> must be <tt>DefaultConstructible</tt> and <tt>MoveConstructible</tt>.</td></tr>
</tbody></table>

<p><i>[
Kona (2007): Howard and Alan to update requirements table in issue with emplace signatures.
]</i></p>


<p><i>[
Bellevue: This should be handled as part of the concepts work.
]</i></p>


<p><i>[
2009-07-20 Reopened by Howard:
]</i></p>


<blockquote>
<p>
This is one of the issues that was "solved by concepts" and is now no longer solved.
</p>

<p>
In a nutshell, concepts adopted the "minimum requirements" philosophy outlined
in the discussion of this issue, and enforced it.  My strong suggestion is that
we translate the concepts specification into documentation for the containers.
</p>

<p>
What this means for vendors is that they will have to implement container members
being careful to only use those characteristics of a type that the concepts specification
formally allowed.  Note that I <em>am not</em> talking about <tt>enable_if</tt>'ing
everything.  I am simply suggesting that (for example) we tell the vendor he can't call <tt>T's</tt>
copy constructor or move constructor within the <tt>emplace</tt> member function, etc.
</p>

<p>
What this means for customers is that they will be able to use types within C++03
containers which are sometimes not CopyConstructible, and sometimes not even
MoveConstructible, etc.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Leave open. Howard to provide wording.
</blockquote>



<p><b>Proposed resolution:</b></p>



<p><b>Rationale:</b></p>
<p><i>[
post San Francisco:
]</i></p>


<blockquote>
Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2776.pdf">N2776</a>.
</blockquote>






<hr>
<h3><a name="724"></a>724. <tt>DefaultConstructible</tt> is not defined</h3>
<p><b>Section:</b> 20.2.1 [utility.arg.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Pablo Halpern <b>Opened:</b> 2007-09-12  <b>Last modified:</b> 2009-10-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#utility.arg.requirements">active issues</a> in [utility.arg.requirements].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#utility.arg.requirements">issues</a> in [utility.arg.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <tt>DefaultConstructible</tt> requirement is referenced in
several places in the August 2007 working draft
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2369.pdf">N2369</a>,
but is not defined anywhere.
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
<p>
Walking into the default/value-initialization mess...
</p>
<p>
Why two lines? Because we need both expressions to be valid.
</p>
<p>
AJM not sure what the phrase "default constructed" means. This is
unfortunate, as the phrase is already used 24 times in the library!
</p>
<p>
Example: const int would not accept first line, but will accept the second.
</p>
<p>
This is an issue that must be solved by concepts, but we might need to solve it independantly first.
</p>
<p>
It seems that the requirements are the syntax in the proposed first
column is valid, but not clear what semantics we need.
</p>
<p>
A table where there is no post-condition seems odd, but appears to sum up our position best.
</p>
<p>
At a minimum an object is declared and is destuctible.
</p>
<p>
Move to open, as no-one happy to produce wording on the fly.
</p>
</blockquote>

<p><i>[
2009-07-28 Reopened by Alisdair.  No longer solved by concepts.
]</i></p>


<p><i>[
2009-08-17 Daniel adds "[defaultconstructible]" to table title.  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#408">408</a>
depends upon this issue.
]</i></p>


<p><i>[
2009-08-18 Alisdair adds:
]</i></p>


<blockquote>
<p>
Looking at the proposed table in this issue, it really needs two rows:
</p>

<blockquote>
<table border="1">
<caption>Table 33: <tt>DefaultConstructible</tt> requirements [defaultconstructible]</caption>
<tbody><tr>
<th>expression</th><th>post-condition</th>
</tr>

<tr>
<td><tt>T t;</tt></td><td><tt>t</tt> is default-initialized.</td>
</tr>

<tr>
<td><tt>T{}</tt></td><td>Object of type <tt>T</tt> is value-initialized.</td>
</tr>
</tbody></table>
</blockquote>

<p>
Note I am using the new brace-initialization syntax that is unambiguous
in all use cases (no most vexing parse.)
</p>
</blockquote>

<p><i>[
2009-10-03 Daniel adds:
]</i></p>


<blockquote>
<p>
The suggested definition <tt>T{}</tt> describing it as
value-initialization is wrong, because it belongs to list-initialization
which would - as the current rules are - always prefer a
initializer-list constructor over a default-constructor. I don't
consider this as an appropriate definition of
<tt>DefaultConstructible</tt>. My primary suggestion is to ask core,
whether the special case <tt>T{}</tt> (which also easily leads to
ambiguity situations for more than one initializer-list in a class)
would always prefer a default-constructor - if any - before considering
an initializer-list constructor or to provide another syntax form to
prefer value-initialization over list-initialization. If that fails I
would fall back to suggest to use the expression <tt>T()</tt> instead of
<tt>T{}</tt> with all it's disadvantages for the meaning of the
expression
</p>

<blockquote><pre>T t();
</pre></blockquote>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Leave Open. Core is looking to make Alisdair's proposed
resolution correct.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
In section 20.2.1 [utility.arg.requirements], before table 33, add the
following table:
</p>

<p style="text-align: center;" align="center">Table 33: <tt>DefaultConstructible</tt> requirements [defaultconstructible]</p>

<div align="center">

<table style="border-collapse: collapse;" border="0" cellpadding="0" cellspacing="0">
 <tbody><tr>
  <td style="border-style: solid none double solid; border-color: navy -moz-use-text-color navy navy; border-width: 1pt medium 1.5pt 1pt; padding: 0in 5.4pt; width: 85.5pt;" valign="top" width="114">
  <p style="margin: 0in 0in 0.0001pt; text-align: center;" align="center">expression</p>
  </td>
  <td style="border-style: solid solid double none; border-color: navy navy navy -moz-use-text-color; border-width: 1pt 1pt 1.5pt medium; padding: 0in 5.4pt; width: 243pt;" valign="top" width="324">
  <p style="margin: 0in 0in 0.0001pt; text-align: center;" align="center">post-condition</p>
  </td>
 </tr>
 <tr>
  <td style="border-style: none none solid solid; border-color: -moz-use-text-color -moz-use-text-color navy navy; border-width: medium medium 1pt 1pt; padding: 0in 5.4pt; width: 85.5pt;" valign="top" width="114">
  <p style="margin: 0in 0in 0.0001pt;"><tt>T
  t;</tt><br>
  <tt>T()</tt></p>
  </td>
  <td style="border-style: none solid solid none; border-color: -moz-use-text-color navy navy -moz-use-text-color; border-width: medium 1pt 1pt medium; padding: 0in 5.4pt; width: 243pt;" valign="top" width="324">
  <p style="margin: 0in 0in 0.0001pt;"><tt>T</tt>
  is <i>default constructed.</i></p>
  </td>
 </tr>
</tbody></table>

</div>



<p><b>Rationale:</b></p>
<p><i>[
San Francisco:
]</i></p>

<blockquote>
We believe concepts will solve this problem
(<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2774.pdf">N2774</a>).
</blockquote>





<hr>
<h3><a name="726"></a>726. Missing <tt>regex_replace()</tt> overloads</h3>
<p><b>Section:</b> 28.11.4 [re.alg.replace] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2007-09-22  <b>Last modified:</b> 2009-10-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#re.alg.replace">active issues</a> in [re.alg.replace].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#re.alg.replace">issues</a> in [re.alg.replace].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Two overloads of <tt>regex_replace()</tt> are currently provided:
</p>

<blockquote><pre>template &lt;class OutputIterator, class BidirectionalIterator, 
    class traits, class charT&gt; 
  OutputIterator 
  regex_replace(OutputIterator out, 
                BidirectionalIterator first, BidirectionalIterator last, 
                const basic_regex&lt;charT, traits&gt;&amp; e, 
                const basic_string&lt;charT&gt;&amp; fmt, 
                regex_constants::match_flag_type flags = 
                  regex_constants::match_default);
 
template &lt;class traits, class charT&gt; 
  basic_string&lt;charT&gt; 
  regex_replace(const basic_string&lt;charT&gt;&amp; s, 
                const basic_regex&lt;charT, traits&gt;&amp; e, 
                const basic_string&lt;charT&gt;&amp; fmt, 
                regex_constants::match_flag_type flags = 
                  regex_constants::match_default);
</pre></blockquote>

<ol>
<li>Overloads taking <tt>const charT *</tt> are provided for <tt>regex_match()</tt> and
<tt>regex_search()</tt>, but not <tt>regex_replace()</tt>.  This is inconsistent.</li>
<li>
<p>The absence of <tt>const charT *</tt> overloads prevents ordinary-looking code from compiling, such as:</p>

<blockquote><pre>const string s("kitten");
const regex r("en");
cout &lt;&lt; regex_replace(s, r, "y") &lt;&lt; endl;
</pre></blockquote>

<p>
The compiler error message will be something like "could not deduce
template argument for 'const std::basic_string&lt;_Elem&gt; &amp;' from 'const
char[1]'".
</p>

<p>
Users expect that anything taking a <tt>basic_string&lt;charT&gt;</tt> can also take a
<tt>const charT *</tt>.  In their own code, when they write a function taking
<tt>std::string</tt> (or <tt>std::wstring</tt>), they can pass a <tt>const char *</tt> (or <tt>const
wchar_t *</tt>), thanks to <tt>basic_string</tt>'s implicit constructor.  Because the
regex algorithms are templated on <tt>charT</tt>, they can't rely on
<tt>basic_string</tt>'s implicit constructor (as the compiler error message
indicates, template argument deduction fails first).
</p>

<p>
If a user figures out what the compiler error message means, workarounds
are available - but they are all verbose.  Explicit template arguments
could be given to <tt>regex_replace()</tt>, allowing <tt>basic_string</tt>'s implicit
constructor to be invoked - but <tt>charT</tt> is the last template argument, not
the first, so this would be extremely verbose.  Therefore, constructing
a <tt>basic_string</tt> from each C string is the simplest workaround.
</p>
</li>

<li>
There is an efficiency consideration: constructing <tt>basic_string</tt>s can
impose performance costs that could be avoided by a library
implementation taking C strings and dealing with them directly. 
(Currently, for replacement sources, C strings can be converted into
iterator pairs at the cost of verbosity, but for format strings, there
is no way to avoid constructing a <tt>basic_string</tt>.)
</li>
</ol>

<p><i>[
Sophia Antipolis:
]</i></p>


<blockquote>
We note that Boost already has these overloads. However, the proposed
wording is provided only for 28.11.4 [re.alg.replace]; wording is needed for the synopsis
as well. We also note that this has impact on <tt>match_results::format</tt>,
which may require further overloads.
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
Daniel to tweak for us.
</blockquote>

<p><i>[
2009-07-25 Daniel tweaks both this issue and <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#727">727</a>.
]</i></p>


<blockquote>
<p>
This is solved by the proposed resolution of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#727">727</a>.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Leave Open. Though we believe this is solved by the proposed resolution
to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#727">727</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>

<p>
Provide additional overloads for <tt>regex_replace()</tt>: one additional
overload of the iterator-based form (taking <tt>const charT* fmt</tt>), and three
additional overloads of the convenience form (one taking <tt>const charT*
str</tt>, another taking <tt>const charT* fmt</tt>, and the third taking both <tt>const
charT* str</tt> and <tt>const charT* fmt</tt>).  28.11.4 [re.alg.replace]:
</p>

<blockquote>
<pre>template &lt;class OutputIterator, class BidirectionalIterator, 
    class traits, class charT&gt; 
  OutputIterator 
  regex_replace(OutputIterator out, 
                BidirectionalIterator first, BidirectionalIterator last, 
                const basic_regex&lt;charT, traits&gt;&amp; e, 
                const basic_string&lt;charT&gt;&amp; fmt, 
                regex_constants::match_flag_type flags = 
                  regex_constants::match_default);

<ins>template &lt;class OutputIterator, class BidirectionalIterator, 
    class traits, class charT&gt; 
  OutputIterator 
  regex_replace(OutputIterator out, 
                BidirectionalIterator first, BidirectionalIterator last, 
                const basic_regex&lt;charT, traits&gt;&amp; e, 
                const charT* fmt, 
                regex_constants::match_flag_type flags = 
                  regex_constants::match_default);</ins>
</pre>
<p>...</p>
<pre>template &lt;class traits, class charT&gt; 
  basic_string&lt;charT&gt; 
  regex_replace(const basic_string&lt;charT&gt;&amp; s, 
                const basic_regex&lt;charT, traits&gt;&amp; e, 
                const basic_string&lt;charT&gt;&amp; fmt, 
                regex_constants::match_flag_type flags = 
                  regex_constants::match_default);

<ins>template &lt;class traits, class charT&gt; 
  basic_string&lt;charT&gt; 
  regex_replace(const basic_string&lt;charT&gt;&amp; s, 
                const basic_regex&lt;charT, traits&gt;&amp; e, 
                const charT* fmt, 
                regex_constants::match_flag_type flags = 
                  regex_constants::match_default);</ins>

<ins>template &lt;class traits, class charT&gt; 
  basic_string&lt;charT&gt; 
  regex_replace(const charT* s, 
                const basic_regex&lt;charT, traits&gt;&amp; e, 
                const basic_string&lt;charT&gt;&amp; fmt, 
                regex_constants::match_flag_type flags = 
                  regex_constants::match_default);</ins>

<ins>template &lt;class traits, class charT&gt; 
  basic_string&lt;charT&gt; 
  regex_replace(const charT* s, 
                const basic_regex&lt;charT, traits&gt;&amp; e, 
                const charT* fmt, 
                regex_constants::match_flag_type flags = 
                  regex_constants::match_default);</ins>
</pre>
</blockquote>






<hr>
<h3><a name="727"></a>727. <tt>regex_replace()</tt> doesn't accept <tt>basic_string</tt>s with custom traits and allocators</h3>
<p><b>Section:</b> 28.11.4 [re.alg.replace] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Review">Review</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2007-09-22  <b>Last modified:</b> 2009-10-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#re.alg.replace">active issues</a> in [re.alg.replace].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#re.alg.replace">issues</a> in [re.alg.replace].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Review">Review</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>regex_match()</tt> and <tt>regex_search()</tt> take <tt>const basic_string&lt;charT, ST,
SA&gt;&amp;</tt>.  <tt>regex_replace()</tt> takes <tt>const basic_string&lt;charT&gt;&amp;</tt>.  This prevents
<tt>regex_replace()</tt> from accepting <tt>basic_string</tt>s with custom traits and
allocators.
</p>

<p>
Overloads of <tt>regex_replace()</tt> taking <tt>basic_string</tt> should be additionally
templated on <tt>class ST, class SA</tt> and take <tt>const basic_string&lt;charT, ST,
SA&gt;&amp;</tt>.  Consistency with <tt>regex_match()</tt> and <tt>regex_search()</tt> would place
<tt>class ST, class SA</tt> as the first template arguments; compatibility with
existing code using TR1 and giving explicit template arguments to
<tt>regex_replace()</tt> would place <tt>class ST, class SA</tt> as the last template
arguments.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Bill comments, "We need to look at the depth of this change."
</p>
<p>
Pete remarks that we are here dealing with a convenience function
that saves a user from calling the iterato-based overload.
</p>
<p>
Move to Open.
</p>
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
Howard to ask Stephan Lavavej to provide wording.
</blockquote>

<p><i>[
2009-07-17 Stephan provided wording.
]</i></p>


<p><i>[
2009-07-25 Daniel tweaks both this issue and <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#726">726</a>.
]</i></p>


<blockquote>
<p>
One relevant part of the proposed resolution below suggests
to add a new overload of the format member function in the
<tt>match_results</tt> class template that accepts two character pointers
defining the <tt>begin</tt> and <tt>end</tt> of a format range. A more general
approach could have proposed a pair of iterators instead, but
the used pair of char pointers reflects existing practice. If the
committee strongly favors an iterator-based signature, this
could be simply changed. I think that the minimum requirement
should be a <tt>BidirectionalIterator</tt>, but current implementations
take advantage (at least partially) of the <tt>RandomAccessIterator</tt>
sub interface of the char pointers.
</p>

<p><b>Suggested Resolution:</b></p>

<p><i>[Moved into the proposed resloution]</i></p>



</blockquote>

<p><i>[
2009-07-30 Stephan agrees with Daniel's wording.  Howard places Daniel's wording
in the Proposed Resolution.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Move to Review. Chair is anxious to move this to Ready in Pittsburgh.
</blockquote>



<p><b>Proposed resolution:</b></p>

<ol>
<li>
<p>
Change 28.4 [re.syn] as indicated:
</p>

<blockquote><pre>// 28.11.4, function template regex_replace:
template &lt;class OutputIterator, class BidirectionalIterator,
          class traits, class charT<ins>, class ST, class SA</ins>&gt;
  OutputIterator
  regex_replace(OutputIterator out,
                BidirectionalIterator first, BidirectionalIterator last,
                const basic_regex&lt;charT, traits&gt;&amp; e,
                const basic_string&lt;charT<ins>, ST, SA</ins>&gt;&amp; fmt,
                regex_constants::match_flag_type flags =
                  regex_constants::match_default);

<ins>
template &lt;class OutputIterator, class BidirectionalIterator,
          class traits, class charT&gt;
  OutputIterator
  regex_replace(OutputIterator out,
                BidirectionalIterator first, BidirectionalIterator last,
                const basic_regex&lt;charT, traits&gt;&amp; e,
                const charT* fmt,
                regex_constants::match_flag_type flags =
                  regex_constants::match_default);
</ins>

template &lt;class traits, class charT<ins>, class ST, class SA,
          class FST, class FSA</ins>&gt;
  basic_string&lt;charT<ins>, ST, SA</ins>&gt;
  regex_replace(const basic_string&lt;charT<ins>, ST, SA</ins>&gt;&amp; s,
                const basic_regex&lt;charT, traits&gt;&amp; e,
                const basic_string&lt;charT<ins>, FST, FSA</ins>&gt;&amp; fmt,
                regex_constants::match_flag_type flags =
                  regex_constants::match_default);

<ins>
template &lt;class traits, class charT, class ST, class SA&gt;
  basic_string&lt;charT, ST, SA&gt;
  regex_replace(const basic_string&lt;charT, ST, SA&gt;&amp; s,
                const basic_regex&lt;charT, traits&gt;&amp; e,
                const charT* fmt,
                regex_constants::match_flag_type flags =
                  regex_constants::match_default);
</ins>

<ins>
template &lt;class traits, class charT, class ST, class SA&gt;
  basic_string&lt;charT&gt;
  regex_replace(const charT* s,
                const basic_regex&lt;charT, traits&gt;&amp; e,
                const basic_string&lt;charT, ST, SA&gt;&amp; fmt,
                regex_constants::match_flag_type flags =
                  regex_constants::match_default);
</ins>

<ins>
template &lt;class traits, class charT&gt;
  basic_string&lt;charT&gt;
  regex_replace(const charT* s,
                const basic_regex&lt;charT, traits&gt;&amp; e,
                const charT* fmt,
                regex_constants::match_flag_type flags =
                  regex_constants::match_default);
</ins>
</pre></blockquote>
</li>

<li>
<p>
Change 28.10 [re.results]/3, class template <tt>match_results</tt> as
indicated:
</p>

<blockquote><pre><ins>
template &lt;class OutputIter&gt;
  OutputIter
  format(OutputIter out,
         const char_type* fmt_first, const char_type* fmt_last,
         regex_constants::match_flag_type flags =
           regex_constants::format_default) const;
</ins>

template &lt;class OutputIter<ins>, class ST, class SA</ins>&gt;
  OutputIter
  format(OutputIter out,
         const <del>string_type</del><ins>basic_string&lt;char_type, ST, SA&gt;</ins>&amp; fmt,
         regex_constants::match_flag_type flags =
           regex_constants::format_default) const;

<ins>template &lt;class ST, class SA&gt;</ins>
  <del>string_type</del><ins>basic_string&lt;char_type, ST, SA&gt;</ins>
  format(const <del>string_type</del><ins>basic_string&lt;char_type, ST, SA&gt;</ins>&amp; fmt,
         regex_constants::match_flag_type flags =
           regex_constants::format_default) const;

<ins>
string_type
format(const char_type* fmt,
       regex_constants::match_flag_type flags =
         regex_constants::format_default) const;
</ins>
</pre></blockquote>
</li>

<li>
<p>
Insert at the very beginning of 28.10.4 [re.results.form] the following:
</p>

<blockquote><pre><ins>
template &lt;class OutputIter&gt;
  OutputIter
  format(OutputIter out,
         const char_type* fmt_first, const char_type* fmt_last,
         regex_constants::match_flag_type flags =
           regex_constants::format_default) const;
</ins>
</pre>
<blockquote>

<p><ins>
1 <i>Requires:</i> The type <tt>OutputIter</tt> shall satisfy the requirements for an
Output Iterator (24.2.2 [output.iterators]).
</ins></p>

<p><ins>
2 <i>Effects:</i> Copies the character sequence <tt>[fmt_first,fmt_last)</tt> to
<tt>OutputIter out</tt>. Replaces each
format specifier or escape sequence in the copied range with either
the character(s) it represents
or the sequence of characters within <tt>*this</tt> to which it refers. The
bitmasks specified in <tt>flags</tt>
determines what format specifiers and escape sequences are recognized.
</ins></p>

<p><ins>
3 <i>Returns:</i> <tt>out</tt>.
</ins></p>
</blockquote>
</blockquote>
</li>

<li>
<p>
Change 28.10.4 [re.results.form], before p. 1 until p. 3 (according to
previous numbering)
as indicated:
</p>

<blockquote><pre>template &lt;class OutputIter<ins>, class ST, class SA</ins>&gt;
  OutputIter
  format(OutputIter out,
         const <del>string_type</del><ins>basic_string&lt;char_type, ST, SA&gt;</ins>&amp; fmt,
         regex_constants::match_flag_type flags =
           regex_constants::format_default) const;
</pre>

<blockquote>
<p>
<del><i>Requires:</i> The type <tt>OutputIter</tt> shall satisfy the requirements for
an Output Iterator (24.2.3).</del>
</p>

<p>
<del><i>Effects:</i> Copies the character sequence <tt>[fmt.begin(),fmt.end())</tt> to
<tt>OutputIter out</tt>. Replaces each
format specifier or escape sequence in <tt>fmt</tt> with either the
character(s) it represents or the sequence of
characters within <tt>*this</tt> to which it refers. The bitmasks specified in
<tt>flags</tt> determines what format
specifiers and escape sequences are recognized.</del>
</p>

<p>
<i>Returns:</i> <tt><del>out</del><ins>format(out, fmt.data(), fmt.data() +
fmt.size(), flags)</ins></tt>.
</p>
</blockquote>
</blockquote>
</li>

<li>
<p>
Change 28.10.4 [re.results.form], before p. 4 until p. 4 (according to
previous numbering) as indicated:
</p>

<blockquote><pre><ins>template &lt;class ST, class SA&gt;</ins>
  <del>string_type</del><ins>basic_string&lt;char_type, ST, SA&gt;</ins>
  format(const <del>string_type</del><ins>basic_string&lt;char_type, ST, SA&gt;</ins>&amp; fmt,
         regex_constants::match_flag_type flags =
           regex_constants::format_default) const;
</pre>

<blockquote>
<p>
<i>Effects:</i> <del>Returns a copy of the string <tt>fmt</tt>. Replaces each format
specifier or escape sequence
in <tt>fmt</tt> with either the character(s) it represents or the sequence of
characters within <tt>*this</tt> to which
it refers. The bitmasks specified in flags determines what format
specifiers and escape sequences are
recognized.</del> <ins>Constructs an empty string <tt>result</tt> of type
<tt>basic_string&lt;char_type, ST, SA&gt;</tt>,
and calls <tt>format(back_inserter(result), fmt, flags)</tt>.</ins>
</p>

<p>
<ins><i>Returns:</i> <tt>result</tt></ins>
</p>
</blockquote>
</blockquote>
</li>

<li>
<p>
At the end of 28.10.4 [re.results.form] insert as indicated:
</p>

<blockquote><pre><ins>
string_type
  format(const char_type* fmt,
         regex_constants::match_flag_type flags =
           regex_constants::format_default) const;
</ins></pre>

<blockquote>
<p>
<ins><i>Effects:</i> Constructs an empty string <tt>result</tt> of type <tt>string_type</tt>, and calls
<tt>format(back_inserter(result), fmt, fmt +
char_traits&lt;char_type&gt;::length(fmt), flags)</tt>.</ins>
</p>
<p>
<ins><i>Returns:</i> <tt>result</tt></ins>
</p>
</blockquote>
</blockquote>

</li>

<li>
<p>
Change 28.11.4 [re.alg.replace] before p. 1 as indicated:
</p>

<blockquote><pre>template &lt;class OutputIterator, class BidirectionalIterator,
          class traits, class charT<ins>, class ST, class SA</ins>&gt;
  OutputIterator
  regex_replace(OutputIterator out,
                BidirectionalIterator first, BidirectionalIterator last,
                const basic_regex&lt;charT, traits&gt;&amp; e,
                const basic_string&lt;charT<ins>, ST, SA</ins>&gt;&amp; fmt,
                regex_constants::match_flag_type flags =
                  regex_constants::match_default);

<ins>
template &lt;class OutputIterator, class BidirectionalIterator,
          class traits, class charT&gt;
  OutputIterator
  regex_replace(OutputIterator out,
                BidirectionalIterator first, BidirectionalIterator last,
                const basic_regex&lt;charT, traits&gt;&amp; e,
                const charT* fmt,
                regex_constants::match_flag_type flags =
                  regex_constants::match_default);
</ins></pre>

<blockquote>
<i>Effects:</i> [..]. If any matches are found then, for each such match, if <tt>!(flags &amp;
 regex_constants::format_no_copy)</tt> calls <tt>std::copy(m.prefix().first,
m.prefix().second,
 out)</tt>, and then calls <tt>m.format(out, fmt, flags)</tt> <ins>for the first
form of the function
 and <tt>m.format(out, fmt, fmt + char_traits&lt;charT&gt;::length(fmt), flags)</tt>
for the second
 form</ins>. [..].
</blockquote>
</blockquote>
</li>

<li>
<p>
Change 28.11.4 [re.alg.replace] before p. 3 as indicated:
</p>

<blockquote><pre>template &lt;class traits, class charT<ins>, class ST, class SA,
          class FST, class FSA</ins>&gt;
  basic_string&lt;charT<ins>, ST, SA</ins>&gt;
  regex_replace(const basic_string&lt;charT<ins>, ST, SA</ins>&gt;&amp; s,
                const basic_regex&lt;charT, traits&gt;&amp; e,
                const basic_string&lt;charT<ins>, FST, FSA</ins>&gt;&amp; fmt,
                regex_constants::match_flag_type flags =
                  regex_constants::match_default);

<ins>
template &lt;class traits, class charT, class ST, class SA&gt;
  basic_string&lt;charT, ST, SA&gt;
  regex_replace(const basic_string&lt;charT, ST, SA&gt;&amp; s,
                const basic_regex&lt;charT, traits&gt;&amp; e,
                const charT* fmt,
                regex_constants::match_flag_type flags =
                  regex_constants::match_default);
</ins></pre>

<blockquote>
<i>Effects:</i> Constructs an empty string <tt>result</tt> of type <tt>basic_string&lt;charT<ins>,
ST, SA</ins>&gt;</tt>, calls <tt>regex_replace(back_inserter(result), s.begin(), s.end(),
e, fmt, flags)</tt>, and then returns <tt>result</tt>.
</blockquote>
</blockquote>
</li>

<li>
<p>
At the end of 28.11.4 [re.alg.replace] add the following new prototype description:
</p>

<blockquote><pre><ins>
template &lt;class traits, class charT, class ST, class SA&gt;
  basic_string&lt;charT&gt;
  regex_replace(const charT* s,
                const basic_regex&lt;charT, traits&gt;&amp; e,
                const basic_string&lt;charT, ST, SA&gt;&amp; fmt,
                regex_constants::match_flag_type flags =
                  regex_constants::match_default);
</ins>

<ins>
template &lt;class traits, class charT&gt;
  basic_string&lt;charT&gt;
  regex_replace(const charT* s,
                const basic_regex&lt;charT, traits&gt;&amp; e,
                const charT* fmt,
                regex_constants::match_flag_type flags =
                  regex_constants::match_default);
</ins></pre>

<blockquote>
<ins>
<i>Effects:</i> Constructs an empty string <tt>result</tt> of type <tt>basic_string&lt;charT&gt;</tt>,
calls <tt>regex_replace(back_inserter(result), s, s +
char_traits&lt;charT&gt;::length(s),
e, fmt, flags)</tt>, and then returns <tt>result</tt>.
</ins>
</blockquote>
</blockquote>
</li>

</ol>







<hr>
<h3><a name="742"></a>742. Enabling <tt>swap</tt> for proxy iterators</h3>
<p><b>Section:</b> 20.2.1 [utility.arg.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2007-10-10  <b>Last modified:</b> 2009-11-08</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#utility.arg.requirements">active issues</a> in [utility.arg.requirements].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#utility.arg.requirements">issues</a> in [utility.arg.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
This issue was split from <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#672">672</a>. <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#672">672</a> now just
deals with changing the requirements of <tt>T</tt> in the <tt>Swappable</tt>
requirement from <tt>CopyConstructible</tt> and <tt>CopyAssignable</tt> to
<tt>MoveConstructible</tt> and <tt>MoveAssignable</tt>.
</p>

<p>
This issue seeks to widen the <tt>Swappable</tt> requirement to support proxy iterators.  Here
is example code:
</p>

<blockquote><pre>namespace Mine {

template &lt;class T&gt;
struct proxy {...};

template &lt;class T&gt;
struct proxied_iterator
{
   typedef T value_type;
   typedef proxy&lt;T&gt; reference;
   reference operator*() const;
   ...
};

struct A
{
   // heavy type, has an optimized swap, maybe isn't even copyable or movable, just swappable
   void swap(A&amp;);
   ...
};

void swap(A&amp;, A&amp;);
void swap(proxy&lt;A&gt;, A&amp;);
void swap(A&amp;, proxy&lt;A&gt;);
void swap(proxy&lt;A&gt;, proxy&lt;A&gt;);

}  // Mine

...

Mine::proxied_iterator&lt;Mine::A&gt; i(...)
Mine::A a;
<b>swap(*i1, a);</b>
</pre></blockquote>

<p>
The key point to note in the above code is that in the call to <tt>swap</tt>, <tt>*i1</tt>
and <tt>a</tt> are different types (currently types can only be <tt>Swappable</tt> with the
same type).  A secondary point is that to support proxies, one must be able to pass rvalues
to <tt>swap</tt>.  But note that I am not stating that the general purpose <tt>std::swap</tt>
should accept rvalues!  Only that overloaded <tt>swap</tt>s, as in the example above, be allowed
to take rvalues.
</p>

<p>
That is, no standard library code needs to change.  We simply need to have a more flexible
definition of <tt>Swappable</tt>.
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
<p>
While we believe Concepts work will define a swappable concept, we
should still resolve this issue if possible to give guidance to the
Concepts work.
</p>
<p>
Would an ambiguous swap function in two namespaces found by ADL break
this wording? Suggest that the phrase "valid expression" means such a
pair of types would still not be swappable.
</p>
<p>
Motivation is proxy-iterators, but facility is considerably more
general. Are we happy going so far?
</p>
<p>
We think this wording is probably correct and probably an improvement on
what's there in the WP. On the other hand, what's already there in the
WP is awfully complicated. Why do we need the two bullet points? They're
too implementation-centric. They don't add anything to the semantics of
what swap() means, which is there in the post-condition. What's wrong
with saying that types are swappable if you can call swap() and it
satisfies the semantics of swapping?
</p>
</blockquote>

<p><i>[
2009-07-28 Reopened by Alisdair.  No longer solved by concepts.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Leave as Open. Dave to provide wording.
</blockquote>

<p><i>[
2009-11-08 Howard adds:
]</i></p>


<blockquote>
Updated wording to sync with
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n3000.pdf">N3000</a>.
Also this issue is very closely related to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#594">594</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 20.2.1 [utility.arg.requirements]:
</p>

<blockquote>

<p>
-1- The template definitions in the C++ Standard Library refer to various
named requirements whose details are set out in tables 31-38. In these
tables, <tt>T</tt> <ins>and <tt>V</tt> are</ins> <del>is a</del> type<ins>s</ins> to be supplied by a C++ program
instantiating a template; <tt>a</tt>, <tt>b</tt>, and <tt>c</tt> are
values of type <tt>const T</tt>; <tt>s</tt> and <tt>t</tt> are modifiable
lvalues of type <tt>T</tt>; <tt>u</tt> is a value of type (possibly
<tt>const</tt>) <tt>T</tt>; <del>and</del> <tt>rv</tt> is a non-<tt>const</tt>
rvalue of type <tt>T</tt><ins>; <tt>w</tt> is a value of type <tt>T</tt>; and <tt>v</tt> is a value of type <tt>V</tt></ins>.
</p>

<table border="1">
<caption>Table 37: <tt>Swappable</tt> requirements <b>[swappable]</b></caption>
<tbody><tr><th>expression</th><th>Return type</th><th>Post-condition</th></tr>
<tr><td><tt>swap(<del>s</del><ins>w</ins>,<del>t</del><ins>v</ins>)</tt></td><td><tt>void</tt></td>
<td><del><tt>t</tt></del><ins><tt>w</tt></ins> has the value originally
held by <del><tt>u</tt></del><ins><tt>v</tt></ins>, and
<del><tt>u</tt></del><ins><tt>v</tt></ins> has the value originally held
by <del><tt>t</tt></del><ins><tt>w</tt></ins></td></tr>
<tr><td colspan="3">
<p>
The <tt>Swappable</tt> requirement is met by satisfying one or more of the following conditions:
</p>
<ul>
<li>
<tt>T</tt> is <tt>Swappable</tt> if <ins><tt>T</tt> and <tt>V</tt> are
the same type and </ins> <tt>T</tt> satisfies the
<tt>MoveConstructible</tt> requirements (Table 
33) and the 
<tt>MoveAssignable</tt> requirements (Table 
35);
</li>
<li>
<tt>T</tt> is <tt>Swappable</tt> <ins>with <tt>V</tt></ins> if a namespace scope function named
<tt>swap</tt> exists in the same namespace as the definition of
<tt>T</tt> <ins>or <tt>V</tt></ins>, such that the expression
<tt>swap(<del>s</del><ins>w</ins>,<del>t</del> <ins>v</ins>)</tt> is valid and has the
semantics described in this table.
</li>
<li>
<tt>T</tt> is <tt>Swappable</tt> if <tt>T</tt> is an array type whose
element type is <tt>Swappable</tt>.
</li>
</ul>
</td></tr>
</tbody></table>
</blockquote>



<p><b>Rationale:</b></p>
<p><i>[
post San Francisco:
]</i></p>


<blockquote>
Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2758.pdf">N2758</a>.
</blockquote>






<hr>
<h3><a name="774"></a>774. Member swap undefined for most containers</h3>
<p><b>Section:</b> 23 [containers] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2008-01-14  <b>Last modified:</b> 2009-10-31</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#containers">active issues</a> in [containers].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#containers">issues</a> in [containers].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It appears most containers declare but do not define a member-swap
function.
</p>

<p>
This is unfortunate, as all overload the <tt>swap</tt> algorithm to call the
member-swap function!
(required for <tt>swappable</tt> guarantees [Table 37] and Container Requirements
[Table 87])
</p>

<p>
Note in particular that Table 87 gives semantics of <tt>a.swap(b)</tt> as <tt>swap(a,b)</tt>,
yet for all containers we define <tt>swap(a,b)</tt> to call <tt>a.swap(b)</tt> - a circular
definition.
</p>

<p>
A quick survey of clause 23 shows that the following containers provide a
definition for member-swap:
</p>

<blockquote><pre>array
queue
stack
vector
</pre></blockquote>

<p>
Whereas the following declare it, but do not define the semantics:
</p>

<blockquote><pre>deque
list
map
multimap
multiset
priority_queue
set
unordered_map
unordered_multi_map
unordered_multi_set
unordered_set
</pre></blockquote>

<p>
Suggested resolution:
</p>
<blockquote>
Provide a definition for each of the affected containers...
</blockquote>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
Move to Open and ask Alisdair to provide wording.
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
Daniel to provide wording.
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2590.pdf">N2590</a>
is no longer applicable.
</blockquote>

<p><i>[
2009-07-28 Daniel provided wording.
]</i></p>


<blockquote>
<ol>
<li>
It assumes that the proposed resolution for <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#883">883</a> is applied,
which breaks the circularity of definition between member
<tt>swap</tt> and free <tt>swap</tt>.
</li>

<li>
It uses the notation of the pre-concept allocator trait
<tt>allocator_propagation_map</tt>, which might be renamed after the
next refactoring phase of generalized allocators.
</li>

<li>
It requires that compare objects, key equal functions and
hash functions in containers are swapped via unqualified free
<tt>swap</tt> according to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#594">594</a>.
</li>
</ol>
</blockquote>

<p><i>[
2009-09-30 Daniel adds:
]</i></p>


<blockquote>
The outcome of this issue should be considered with the outcome of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1198">1198</a> both in style and in content (e.g. bullet 9 suggests to
define the semantic of <tt>void
priority_queue::swap(priority_queue&amp;)</tt> in terms of the member
<tt>swap</tt> of the container).
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Looked at, but took no action on as it overlaps too much with
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2982.pdf">N2982</a>.
Waiting for a new draft WP.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Leave as open. Pablo to provide wording.
</blockquote>

<p><i>[
2009-10-26 Pablo updated wording.  Here is the wording he replaced:
]</i></p>


<blockquote class="note">
<ol>
<li>
<p>
Add a new Throws clause just after X [allocator.propagation.map]/5:
</p>

<blockquote><pre>static void swap(Alloc&amp; a, Alloc&amp; b);
</pre>
<blockquote>
<p>
<i>Effects:</i> [..]
</p>

<p>
<ins><i>Throws:</i> Nothing.</ins>
</p>
</blockquote>
</blockquote>
<p><i>[
This exception requirement is added, such that it's combination with the
general container requirements of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2723.pdf">N2723</a>
[container.requirements.general]/9
make it unambiguously clear that the following descriptions of "swaps the
allocators" have the following meaning: (a) This swap is done by calling
<tt>allocator_propagation_map&lt;allocator_type&gt;::swap</tt> and (b) This allocator
swap does never propagate an exception
]</i></p>

</li>

<li>
<p>
Change 23.2.4.1 [associative.reqmts.except]/3 as indicated:
</p>

<blockquote>
For associative containers, no <tt>swap</tt> function throws an exception unless that
exception is thrown by the <del>copy constructor or copy assignment
operator</del>
<ins><tt>swap</tt></ins> of the container's <tt>Pred</tt> object<ins>s</ins><del> (if any)</del>.
</blockquote>
</li>

<li>
<p>
Change 23.2.5.1 [unord.req.except]/3 as indicated:
</p>

<blockquote>
For unordered associative containers, no <tt>swap</tt> function throws an
exception unless
that exception is thrown by the <del>copy constructor or copy
assignment operator</del>
<ins><tt>swap</tt></ins> of the container's <tt>Hash</tt> or <tt>Pred</tt> object<ins>s,
respectively</ins><del> (if any)</del>.
</blockquote>
</li>

<li>
<p>
Insert a new paragraph just after 23.3 [sequences]/1:
</p>

<blockquote>
<ins>In addition to being available via inclusion of the <tt>&lt;algorithm&gt;</tt> header,
the <tt>swap</tt> function templates in 25.3.3 [alg.swap] are also available when the
header <tt>&lt;queue&gt;</tt> is included.</ins>
</blockquote>

<p><i>[
There is a new issue in process that will suggest a minimum header for <tt>swap</tt>
and <tt>move</tt>. If this one is provided, this text can be removed and the header
dependency should be added to <tt>&lt;queue&gt;</tt>
]</i></p>


</li>

<li>
<p>
Add one further clause at the end of 23.3.1.2 [array.special]:
</p>
<p><i>[This part is added, because otherwise <tt>array::swap</tt> would otherwise
contradict the
general contract of 23.2.1 [container.requirements.general] p. 10 b. 5]</i></p>


<blockquote>
<ins><i>Throws:</i> Nothing, unless one of the element-wise <tt>swap</tt> calls throws
an exception.</ins>
</blockquote>
</li>

<li>
<ol type="a">
<li>
<p>
In 23.3.2 [deque], class template deque synopsis change as indicated:
</p>
<blockquote><pre>void swap(deque<del>&lt;T,Alloc&gt;</del>&amp;);
</pre></blockquote>
</li>

<li>
<p>
At the end of 23.3.2.3 [deque.modifiers] add as indicated:
</p>

<blockquote><pre><ins>void swap(deque&amp; x);</ins>
</pre>
<blockquote>
<p>
<ins><i>Effects:</i> Exchanges the contents and swaps the allocators of <tt>*this</tt>
with that of <tt>x</tt>.</ins>
</p>
<p>
<ins><i>Complexity:</i> Constant time.</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>
</li>

<li>
<ol type="a">
<li>
<p>
In 23.3.3 [forwardlist], class template <tt>forward_list</tt> synposis change as indicated:
</p>

<blockquote><pre>void swap(forward_list<del>&lt;T,Allocator&gt;</del>&amp;);
</pre></blockquote>
</li>

<li>
<p>
At the end of 23.3.3.4 [forwardlist.modifiers] add as indicated:
</p>

<blockquote><pre><ins>void swap(forward_list&amp; x);</ins>
</pre>
<blockquote>
<p>
<ins><i>Effects:</i> Exchanges the contents and swaps the allocators of <tt>*this</tt>
with that of <tt>x</tt>.</ins>
</p>
<p>
<ins><i>Complexity:</i> Constant time.</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>
</li>

<li>
<ol type="a">
<li>
<p>
In 23.3.4 [list], class template <tt>list</tt> synopsis change as indicated:
</p>

<blockquote><pre>void swap(list<del>&lt;T,Allocator&gt;</del>&amp;);
</pre></blockquote>
</li>

<li>
<p>
At the end of 23.3.4.3 [list.modifiers] add as indicated:
</p>

<blockquote><pre><ins>void swap(list&amp; x);</ins>
</pre>

<blockquote>
<p>
<ins><i>Effects:</i> Exchanges the contents and swaps the allocators of <tt>*this</tt>
with that of <tt>x</tt>.</ins>
</p>

<p>
<ins><i>Complexity:</i> Constant time.</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>
</li>

<li>
<p>
At the end of 23.3.5.2.2 [priqueue.members] add a new prototype description:
</p>

<blockquote><pre><ins>void swap(priority_queue&amp; q);</ins>
</pre>
<blockquote>
<p>
<ins><i>Requires:</i> <tt>Compare</tt> shall satisfy the <tt>Swappable</tt> requirements
( [swappable]).</ins>
</p>

<p><i>[
This requirement is added to ensure that even a user defined <tt>swap</tt>
which is found by
ADL for <tt>Compare</tt> satisfies the <tt>Swappable</tt> requirements
]</i></p>


<p>
<ins><i>Effects:</i> <tt>this-&gt;c.swap(q.c); swap(this-&gt;comp, q.comp);</tt></ins>
</p>
<p>
<ins><i>Throws:</i> What and if <tt>c.swap(q.c)</tt> and <tt>swap(comp, q.comp)</tt> throws.</ins>
</p>
</blockquote>
</blockquote>
<p><i>[
This part is added, because otherwise <tt>priority_queue::swap</tt> would otherwise
contradict the general contract of 23.2.1 [container.requirements.general] p. 10 b. 5
]</i></p>

</li>

<li>
<ol type="a">
<li>
<p>
In 23.3.6 [vector], class template <tt>vector</tt> synopsis change as indicated:
</p>

<blockquote><pre>void swap(vector<del>&lt;T,Allocator&gt;</del>&amp;);
</pre></blockquote>
</li>

<li>
<p>
Change 23.3.6.2 [vector.capacity]/8 as indicated:
</p>

<blockquote><pre>void swap(vector<del>&lt;T,Allocator&gt;</del>&amp; x);
</pre>

<blockquote>
<i>Effects:</i> Exchanges the contents and <tt>capacity()</tt> <ins>and swaps the
allocators</ins>
of <tt>*this</tt> with that of <tt>x</tt>.
</blockquote>
</blockquote>
</li>
</ol>
</li>

<li>
<p>
Insert a new paragraph just before 23.4 [associative]/1:
</p>

<blockquote>
<ins>In addition to being available via inclusion of the <tt>&lt;algorithm&gt;</tt> header,
the <tt>swap</tt> function templates in 25.3.3 [alg.swap] are also available when any of the
headers <tt>&lt;map&gt;</tt> or <tt>&lt;set&gt;</tt> are included.</ins>
</blockquote>
</li>

<li>
<ol type="a">
<li>
<p>
In 23.4.1 [map], class template <tt>map</tt> synopsis change as indicated:
</p>

<blockquote><pre>void swap(map<del>&lt;Key,T,Compare,Allocator&gt;</del>&amp;);
</pre></blockquote>
</li>

<li>
<p>
At the end of 23.4.1.3 [map.modifiers] add as indicated:
</p>

<blockquote><pre><ins>void swap(map&amp; x);</ins>
</pre>

<blockquote>
<p>
<ins><i>Requires:</i> Compare shall satisfy the <tt>Swappable</tt> requirements
( [swappable]).</ins>
</p>

<p><i>[
This requirement is added to ensure that even a user defined <tt>swap</tt>
which is found by ADL for <tt>Compare</tt> satisfies the <tt>Swappable</tt>
requirements
]</i></p>


<p>
<ins><i>Effects:</i> Exchanges the contents and swaps the allocators of <tt>*this</tt>
with that of <tt>x</tt>, followed by an unqualified <tt>swap</tt> of the comparison objects
of <tt>*this</tt> and <tt>x</tt>.</ins>
</p>

<p>
<ins><i>Complexity:</i> Constant time</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>
</li>

<li>
<ol type="a">
<li>
<p>
In 23.4.2 [multimap], class template <tt>multimap</tt> synopsis change as indicated:
</p>

<blockquote><pre>void swap(multimap<del>&lt;Key,T,Compare,Allocator&gt;</del>&amp;);
</pre></blockquote>
</li>

<li>
<p>
At the end of 23.4.2.2 [multimap.modifiers] add as indicated:
</p>

<blockquote><pre><ins>void swap(multimap&amp; x);</ins>
</pre>

<blockquote>
<p>
<ins><i>Requires:</i> Compare shall satisfy the <tt>Swappable</tt> requirements
( [swappable]).</ins>
</p>
<p>
<ins><i>Effects:</i> Exchanges the contents and swaps the allocators of <tt>*this</tt>
with that of <tt>x</tt>, followed by an unqualified <tt>swap</tt> of the comparison objects
of <tt>*this</tt> and <tt>x</tt>.</ins>
</p>
<p>
<ins><i>Complexity:</i> Constant time</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>
</li>

<li>
<ol type="a">
<li>
<p>
In 23.4.3 [set], class template <tt>set</tt> synopsis change as indicated:
</p>

<blockquote><pre>void swap(set<del>&lt;Key,Compare,Allocator&gt;</del>&amp;);
</pre></blockquote>
</li>

<li>
<p>
After section 23.4.3.1 [set.cons] add a new section <ins><tt>set</tt> modifiers
 [set.modifiers]</ins>
and add the following paragraphs:
</p>

<blockquote><pre><ins>void swap(set&amp; x);</ins>
</pre>

<blockquote>
<p>
<ins><i>Requires:</i> Compare shall satisfy the <tt>Swappable</tt> requirements
( [swappable]).</ins>
</p>

<p>
<ins><i>Effects:</i> Exchanges the contents and swaps the allocators of <tt>*this</tt>
with that of <tt>x</tt>, followed by an unqualified <tt>swap</tt> of the comparison objects
of <tt>*this</tt> and <tt>x</tt>.</ins>
</p>

<p>
<ins>Complexity: Constant time</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>
</li>

<li>
<ol type="a">
<li>
<p>
In 23.4.4 [multiset], class template <tt>multiset</tt> synosis, change as indicated:
</p>

<blockquote><pre>void swap(multiset<del>&lt;Key,Compare,Allocator&gt;</del>&amp;);
</pre></blockquote>
</li>

<li>
<p>
After section 23.4.4.1 [multiset.cons] add a new section <ins><tt>multiset</tt> modifiers
 [multiset.modifiers]</ins> and add the following paragraphs:
</p>

<blockquote><pre><ins>void swap(multiset&amp; x);</ins>
</pre>

<blockquote>
<p>
<ins><i>Requires:</i> Compare shall satisfy the <tt>Swappable</tt> requirements
( [swappable]).</ins>
</p>

<p>
<ins><i>Effects:</i> Exchanges the contents and swaps the allocators of <tt>*this</tt>
with that of <tt>x</tt>, followed by an unqualified <tt>swap</tt> of the comparison objects
of <tt>*this</tt> and <tt>x</tt>.</ins>
</p>

<p>
<ins><i>Complexity:</i> Constant time</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>
</li>

<li>
<p>
Insert a new paragraph just before 23.5 [unord]/1:
</p>

<blockquote>
<ins>In addition to being available via inclusion of the <tt>&lt;algorithm&gt;</tt> header,
the <tt>swap</tt> function templates in 25.3.3 [alg.swap] are also available when any of the
headers <tt>&lt;unordered_map&gt;</tt> or <tt>&lt;unordered_set&gt;</tt> are included.</ins>
</blockquote>

</li>

<li>
<p>
After section 23.5.1.2 [unord.map.elem] add a new section <ins>unordered_map
modifiers  [unord.map.modifiers]</ins> and add the following paragraphs:
</p>

<blockquote><pre><ins>void swap(unordered_map&amp; x);</ins>
</pre>

<blockquote>
<p>
<ins><i>Requires:</i> <tt>Hash</tt> and <tt>Pred</tt> shall satisfy the <tt>Swappable</tt> requirements
( [swappable]).</ins>
</p>

<p><i>[
This requirement is added to ensure that even a user defined <tt>swap</tt>
which is found by ADL for <tt>Hash</tt> and <tt>Pred</tt> satisfies the <tt>Swappable</tt>
requirements
]</i></p>


<p>
<ins><i>Effects:</i> Exchanges the contents and hash policy and swaps the
allocators of <tt>*this</tt>
with that of <tt>x</tt>, followed by an unqualified <tt>swap</tt> of the <tt>Pred</tt> objects
and an unqualified <tt>swap</tt> of the <tt>Hash</tt> objects of <tt>*this</tt> and <tt>x</tt>.</ins>
</p>

<p>
<ins><i>Complexity:</i> Constant time</ins>
</p>
</blockquote>
</blockquote>
</li>

<li>
<p>
After section 23.5.2.1 [unord.multimap.cnstr] add a new section
<ins>unordered_multimap
modifiers  [unord.multimap.modifiers]</ins> and add the following paragraphs:
</p>

<blockquote><pre><ins>void swap(unordered_multimap&amp; x);</ins>
</pre>

<blockquote>
<p>
<ins><i>Requires:</i> <tt>Hash</tt> and <tt>Pred</tt> shall satisfy the <tt>Swappable</tt> requirements
( [swappable]).</ins>
</p>

<p>
<ins><i>Effects:</i> Exchanges the contents and hash policy and swaps the
allocators of <tt>*this</tt>
with that of <tt>x</tt>, followed by an unqualified <tt>swap</tt> of the <tt>Pred</tt> objects
and an unqualified <tt>swap</tt> of the <tt>Hash</tt> objects of <tt>*this</tt> and <tt>x</tt></ins>
</p>
<p>
<ins><i>Complexity:</i> Constant time</ins>
</p>
</blockquote>
</blockquote>
</li>

<li>
<p>
After section 23.5.3.1 [unord.set.cnstr] add a new section
<ins>unordered_set modifiers
 [unord.set.modifiers]</ins> and add the following paragraphs:
</p>

<blockquote><pre><ins>void swap(unordered_set&amp; x);</ins>
</pre>

<blockquote>
<p>
<ins><i>Requires:</i> <tt>Hash</tt> and <tt>Pred</tt> shall satisfy the <tt>Swappable</tt> requirements
( [swappable]).</ins>
</p>

<p>
<ins><i>Effects:</i> Exchanges the contents and hash policy and swaps the
allocators of <tt>*this</tt>
with that of <tt>x</tt>, followed by an unqualified <tt>swap</tt> of the <tt>Pred</tt> objects
and an unqualified <tt>swap</tt> of the <tt>Hash</tt> objects of <tt>*this</tt> and <tt>x</tt></ins>
</p>

<p>
<ins><i>Complexity:</i> Constant time</ins>
</p>
</blockquote>
</blockquote>
</li>

<li>
<p>
After section 23.5.4.1 [unord.multiset.cnstr] add a new section
<ins>unordered_multiset
modifiers  [unord.multiset.modifiers]</ins> and add the following paragraphs:
</p>

<blockquote><pre><ins>void swap(unordered_multiset&amp; x);</ins>
</pre>

<blockquote>
<p>
<ins><i>Requires:</i> <tt>Hash</tt> and <tt>Pred</tt> shall satisfy the <tt>Swappable</tt> requirements
( [swappable]).</ins>
</p>

<p>
<ins><i>Effects:</i> Exchanges the contents and hash policy and swaps the
allocators of <tt>*this</tt>
with that of <tt>x</tt>, followed by an unqualified <tt>swap</tt> of the <tt>Pred</tt> objects
and an unqualified <tt>swap</tt> of the <tt>Hash</tt> objects of <tt>*this</tt> and <tt>x</tt></ins>
</p>
<p>
<ins><i>Complexity:</i> Constant time</ins>
</p>
</blockquote>
</blockquote>
</li>

</ol>

</blockquote>

<p><i>[
2009-10-30 Pablo and Daniel updated wording.
]</i></p>




<p><b>Proposed resolution:</b></p>

<p><i>[
This resolution is based on the September 2009 WP,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2960.pdf">N2960</a>,
except that it
assumes that
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2982.pdf">N2982</a>
and issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#883">883</a> and <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1232">1232</a> have already been applied.  Note in
particular that Table 91 in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2960.pdf">N2960</a>
is refered to as Table 90 because
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2982.pdf">N2982</a>
removed the old Table 90.  This resolution also addresses issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#431">431</a>.
]</i></p>

<p>
In 23.2.1 [container.requirements.general], replace the a.swap(b) row in table 90,
"container requirements" (was table 91 before the application of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2982.pdf">N2982</a> to the
WP):
</p>
<blockquote>
<table border="1">
  <tbody><tr>
    <td><code>a.swap(b)</code></td>
    <td><code>void</code></td>
    <td>&nbsp;&nbsp;&nbsp;</td>
    <td><code><del>swap(a,b)</del><ins>Exchange the contents of <tt>a</tt> and <tt>b</tt>.</ins></code></td>
    <td>(Note A)</td>
  </tr>
  <tr>
    <td><ins><code>swap(a,b)</code></ins></td>
    <td><ins><code>void</code></ins></td>
    <td><code>&nbsp;&nbsp;&nbsp;</code></td>
    <td><ins><code>a.swap(b)</code></ins></td>
    <td><ins>(Note A)</ins></td>
  </tr>
</tbody></table>
</blockquote>
<p>
Modify the notes immediately following Table 90 in
23.2.1 [container.requirements.general] as follows (The wording below is after the
application of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2982.pdf">N2982</a> to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2960.pdf">N2960</a>.  The editor might also want to combine Notes
A and B into one.):
</p>
<blockquote><p>
Notes: the algorithms<del> swap(),</del> equal() and lexicographical_compare()
are defined in Clause 25.  Those entries marked "(Note A)" or "(Note B)"
<del>should</del> have <ins>linear complexity for array and</ins> constant
complexity <ins>for all other standard containers</ins>.
</p></blockquote>
<p>
In 23.2.1 [container.requirements.general], after paragraph 9, add:
</p>
<blockquote><p><ins>
The expression <code>a.swap(b)</code>, for containers <code>a</code>
and <code>b</code> of a standard container type other than <code>array</code>,
exchanges the values of <code>a</code> and <code>b</code> without invoking any
move, copy, or swap operations on the individual container elements.
Any <code>Compare</code>, <code>Pred</code>, or <code>Hash</code> function
objects belonging to <code>a</code> and <code>b</code> shall satisfy
the <code>Swappable</code> requirements and are exchanged by unqualified calls
to non-member <code>swap</code>.  If
<code>allocator_traits&lt;allocator_type&gt;::propagate_on_container_swap::value
== true</code>, then the allocators of <code>a</code> and <code>b</code> are
also exchanged using an unqualified call to non-member <code>swap</code>.
Otherwise, the behavior is undefined unless <code>a.get_allocator() ==
b.get_allocator()</code>.  Each iterator refering to an element in one
container before the swap shall refer to the same element in the other
container after the swap.  It is unspecified whether an iterator with
value <code>a.end()</code> before the swap will have
value <code>b.end()</code> after the swap.  In addition to being available via
inclusion of the <code>&lt;utility&gt;</code> header, the <code>swap</code>
function template in 25.3.3 [alg.swap] is also available within the definition of
every standard container's <code>swap</code> function.
</ins></p></blockquote>
<p><i>[
Note to the editor: Paragraph 2 starts with a sentence fragment,
clearly from an editing or source-control error.
]</i></p>

<p>
Modify 23.2.4.1 [associative.reqmts.except] as follows:
</p>
<blockquote>
<p>
<b>23.2.4.1 Exception safety guarantees 23.2.4.1 [associative.reqmts.except]</b>
</p>
<p>
For associative containers, no <code>clear()</code> function throws an
exception. <code>erase(k)</code> does not throw an exception unless that
exception is thrown by the
container's <code><del>Pred</del><ins>Compare</ins></code> object (if any).
</p>
<p>
For associative containers, if an exception is thrown by any operation from
within an <code>insert()</code> function inserting a single element,
the <code>insert()</code> function has no effect.
</p>
<p>
For associative containers, no <code>swap</code> function throws an exception
unless that exception is thrown by the <del>copy constructor
or copy assignment operator</del><ins>swap</ins> of the
container's <code><del>Pred</del><ins>Compare</ins></code> object (if any).
</p></blockquote>
<p>
Modify 23.2.5.1 [unord.req.except], paragraph 3 as follows:
</p>
<blockquote><p>
For unordered associative containers, no <code>swap</code> function throws an
exception unless that exception is thrown by the <del>copy constructor or copy
assignment operator</del><ins>swap</ins> of the container's <code>Hash</code>
or <code>Pred</code> object (if any).
</p></blockquote>
<p>
Modify section 23.3.1.2 [array.special]:
</p>
<blockquote>
<p>
<b>array specialized algorithms 23.3.1.2 [array.special]</b>
</p>
<p>
<code>template &lt;class T, size_t N&gt; void swap(array&lt;T,N&gt;&amp; x,array&lt;T,N&gt;&amp; y);</code>
</p>
<blockquote>
<p>
<i>Effects:</i> <code><del>swap_ranges(x.begin(), x.end(), y.begin() );</del><ins>x.swap(y);</ins></code>
</p>
</blockquote>
</blockquote>
<p>
Add a new section after 23.3.1.5 [array.fill] (Note to the editor: array::fill make use
of a concept requirement that must be removed or changed to text.):
</p>
<blockquote>
<p>
<ins><b>array::swap [array.swap]</b></ins>
</p>
<p>
<ins><code>void swap(array&amp; y);</code></ins>
</p>
<blockquote>
<p><ins>
<i>Effects:</i> <code>swap_ranges(this-&gt;begin(), this-&gt;end(), y.begin() );</code>
</ins></p>
<p><ins>
<i>Throws:</i> Nothing unless one of the element-wise swap calls throws an
exception.
</ins></p>
<p><ins>
[<i>Note</i>: Unlike other containers' <code>swap</code> functions,
<code>array::swap</code> takes linear, not constant, time, may exit via an
exception, and does not cause iterators to become associated with the other
container. &#8212; <i>end note</i>]
</ins></p>
</blockquote>
</blockquote>

<p>
Insert a new paragraph just after 23.3.5 [container.adaptors]/1:
</p>
<blockquote><p><ins>
For container adaptors, no <code>swap</code> function throws an exception
unless that exception is thrown by the swap of the
adaptor's <code>Container</code> or <code>Compare</code> object (if any).
</ins></p></blockquote>












<hr>
<h3><a name="780"></a>780. <tt>std::merge()</tt> specification incorrect/insufficient</h3>
<p><b>Section:</b> 25.4.4 [alg.merge] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Review">Review</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2008-01-25  <b>Last modified:</b> 2009-10-22</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Review">Review</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Though issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#283">283</a> has fixed many open issues, it seems that some are still open:
</p>

<p>
Both 25.3.4 [lib.alg.merge] in 14882:2003 and 25.4.4 [alg.merge] in N2461
have no Requires element and the Effects element contains some requirements,
which is probably editorial. Worse is that:
</p>

<ul>
<li>
no assignment requirements are specified (neither implicit nor explicit).
</li>

<li>
the effects clause just speaks of "merges", which is badly worded
near to a circular definition.
</li>

<li>
p. 2 mentions a range <tt>[first, last)</tt>, which is not defined by the
function arguments or otherwise.
</li>

<li>
p. 2 says "according to the ordering defined by comp" which is both
incomplete (because
this excludes the first variant with &lt;) and redundant (because the
following subordinate
clause mentions comp again)
</li>
</ul>

<p><i>[
Post Summit Alisdair adds:
]</i></p>


<blockquote>
<p>
Suggest:
</p>
<blockquote>
(where <tt>last</tt> is equal to <tt>next(result, distance(first1, last1) +
distance(first2, last2))</tt>, such that resulting range will be sorted in
non-decreasing order; that is, for every iterator <tt>i</tt> in <tt>[result,last)</tt> other
than <tt>result</tt>, the condition <tt>*i &lt; *prev(i)</tt> or, respectively, <tt>comp(*i,
*prev(i))</tt> will be <tt>false</tt>.
</blockquote>

<p>
Note that this might still not be technically accurate in the case of
<tt>InputIterators</tt>, depending on other resolutions working their way through the
system (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1011">1011</a>).
</p>
</blockquote>

<p><i>[
Post Summit Daniel adds:
]</i></p>


<blockquote>
If we want to use <tt>prev</tt> and <tt>next</tt> here (Note: <tt>merge</tt>
is sufficiently satisfied with <tt>InputIterator</tt>) we should instead *add* more to
25 [algorithms]/6, but I can currently not propose any good wording for this.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Pete points out the existing wording in [algorithms]/4
that permits the use of + in algorithm specifications.
</p>
<p>
Alisdair points out that that wording may not apply to input iterators.
</p>
<p>
Move to Review.
</p>
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
Move to Ready.
</blockquote>

<p><i>[
2009-08-23 Daniel reopens:
]</i></p>


<blockquote>
<p>
The proposed wording must be rephrased, because the part
</p>

<blockquote>
for every iterator <tt>i</tt> in <tt>[result,last)</tt> other than <tt>result</tt>, the condition
<tt>*i &lt; *(i - 1)</tt> or, respectively, <tt>comp(*i, *(i - 1))</tt> will be <tt>false</tt>"
</blockquote>

<p>
isn't meaningful, because the range <tt>[result,last)</tt> is that of a pure
<tt>OutputIterator</tt>, which is not <em>readable</em> in general.
</p>

<p><i>[Howard:  Proposed wording updated by Daniel, status moved from Ready to Review.]</i></p>

</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
<p>
Matt has some different words to propose.  Those words have been moved into
the proposed wording section, and the original proposed wording now appears
here:
</p>
<blockquote>
<p>
In 25.4.4 [alg.merge] replace p.1+ 2:
</p>

<blockquote>
<p>
<i>Effects:</i> <del>Merges</del><ins>Copies all the elements of the</ins>
two sorted ranges
<tt>[first1,last1)</tt> and <tt>[first2,last2)</tt> into the range <tt>[result,result +
(last1 - first1) + (last2 - first2))</tt>
<ins>, such that resulting range will be sorted in non-decreasing
order; that is for every
pair of iterators <tt>i</tt> and <tt>j</tt> of either input ranges, where <tt>*i</tt> was copied
to the output range
before <tt>*j</tt> was copied to the output range, the condition <tt>*j &lt; *i</tt> or,
respectively, <tt>comp(*j, *i)</tt>
will be <tt>false</tt>.</ins>
</p>

<p>
<ins><i>Requires:</i></ins>The resulting range shall not overlap with either
of the original ranges.
<del>The list will be sorted in non-decreasing order according to the
ordering defined by
<tt>comp</tt>; that is, for every iterator <tt>i</tt> in <tt>[first,last)</tt> other than <tt>first</tt>,
the condition <tt>*i &lt; *(i - 1)</tt> or
<tt>comp(*i, *(i - 1))</tt> will be <tt>false</tt>.</del>
</p>
</blockquote>
</blockquote>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p><del>
<i>Effects:</i> Merges two sorted ranges <tt>[first1,last1)</tt> and
<tt>[first2,last2)</tt> into the range <tt>[result, result + (last1 -
first1) + (last2 - first2))</tt>.
</del></p>
<p><ins>
<i>Effects:</i> Copies all the elements of the two sorted ranges
<tt>[first1,last1)</tt> and <tt>[first2,last2)</tt> into the range
<tt>[result, result_last)</tt>, where <tt>result_last</tt> is <tt>result
+ (last1 - first1) + (last2 - first2)</tt>, such that the resulting
range satisfies <tt>is_sorted(result, result_last)</tt> or
<tt>is_sorted(result, result_last, comp)</tt>, respectively.
</ins></p>

<p>
<ins><i>Requires:</i></ins> The resulting range shall not overlap with
either of the original ranges.  <del>The list will be sorted in
non-decreasing order according to the ordering defined by <tt>comp</tt>;
that is, for every iterator <tt>i</tt> in <tt>[first,last)</tt> other
than <tt>first</tt>, the condition <tt>*i &lt; *(i - 1)</tt> or
<tt>comp(*i, *(i - 1))</tt> will be <tt>false</tt>.</del>
</p>






<hr>
<h3><a name="801"></a>801. <tt>tuple</tt> and <tt>pair</tt> trivial members</h3>
<p><b>Section:</b> 20.5 [tuple] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Lawrence Crowl <b>Opened:</b> 2008-02-18  <b>Last modified:</b> 2009-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#tuple">issues</a> in [tuple].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Classes with trivial special member functions are inherently more
efficient than classes without such functions.  This efficiency is
particularly pronounced on modern ABIs that can pass small classes
in registers.  Examples include value classes such as complex numbers
and floating-point intervals.  Perhaps more important, though, are
classes that are simple collections, like <tt>pair</tt> and <tt>tuple</tt>.  When the
parameter types of these classes are trivial, the <tt>pair</tt>s and <tt>tuple</tt>s
themselves can be trivial, leading to substantial performance wins.
</p>
<p>
The current working draft make specification of trivial functions
(where possible) much easer through <tt>default</tt>ed and <tt>delete</tt>d functions.
As long as the semantics of defaulted and deleted functions match
the intended semantics, specification of defaulted and deleted
functions will yield more efficient programs.
</p>
<p>
There are at least two cases where specification of an explicitly
defaulted function may be desirable.
</p>
<p>
First, the <tt>std::pair</tt> template has a non-trivial default constructor,
which prevents static initialization of the pair even when the
types are statically initializable.  Changing the definition to
</p>

<blockquote><pre>pair() = default;
</pre></blockquote>

<p>
would enable such initialization.  Unfortunately, the change is
not semantically neutral in that the current definition effectively
forces value initialization whereas the change would not value
initialize in some contexts.
</p>

<p>
** Does the committee confirm that forced value initialization
was the intent?  If not, does the committee wish to change the
behavior of <tt>std::pair</tt> in C++0x?
</p>
<p>
Second, the same default constructor issue applies to <tt>std::tuple</tt>.
Furthermore, the <tt>tuple</tt> copy constructor is current non-trivial,
which effectively prevents passing it in registers.  To enable
passing <tt>tuples</tt> in registers, the copy constructor should be
make explicitly <tt>default</tt>ed.  The new declarations are:
</p>

<blockquote><pre>tuple() = default;
tuple(const tuple&amp;) = default;
</pre></blockquote>

<p>
This changes is not implementation neutral.  In particular, it
prevents implementations based on pointers to the parameter
types.  It does however, permit implementations using the
parameter types as bases.
</p>
<p>
** How does the committee wish to trade implementation
efficiency versus implementation flexibility?
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
<p>
General agreement; the first half of the issue is NAD.
</p>
<p>
Before voting on the second half, it was agreed that a "Strongly Favor"
vote meant support for trivial tuples (assuming usual requirements met),
even at the expense of other desired qualities. A "Weakly Favor" vote
meant support only if not at the expense of other desired qualities.
</p>
<p>
Concensus: Go forward, but not at expense of other desired qualities.
</p>
<p>
It was agreed to Alisdair should fold this work in with his other
pair/tuple action items, above, and that issue 801 should be "open", but
tabled until Alisdair's proposals are disposed of.
</p>
</blockquote>

<p><i>[
2009-05-27 Daniel adds:
]</i></p>


<blockquote>
This is partly solved by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1117">1117</a>.
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
Wait for dust to settle from fixing exception safety problem
with rvalue refs.
</blockquote>

<p><i>[
2009-07-20 Alisdair adds:
]</i></p>


<blockquote>
<p>
Basically, this issue is what should we do with the default constructor
for pairs and tuples of trivial types.  The motivation of the issue was
to force static initialization rather than dynamic initialization, and
was rejected in the case of pair as it would change the meaning of
existing programs.  The advice was "do the best we can" for tuple
without changing existing meaning.
</p>

<p>
Frankfurt seems to simply wait and see the resolution on no-throw move
constructors, which (I believe) is only tangentially related to this
issue, but as good as any to defer until Santa Cruz.
</p>

<p>
Looking again now, I think constant (static) initialization for pair can
be salvaged by making the default construct constexpr.  I have a
clarification from Core that this is intended to work, even if the
constructor is not trivial/constexpr, so long as no temporaries are
implied in the process (even if elided).
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Leave as open. Alisdair to provide wording.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="811"></a>811. <tt>pair</tt> of pointers no longer works with literal 0</h3>
<p><b>Section:</b> 20.3.4 [pairs] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Doug Gregor <b>Opened:</b> 2008-03-14  <b>Last modified:</b> 2009-10-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#pairs">active issues</a> in [pairs].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#pairs">issues</a> in [pairs].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<blockquote><pre>#include &lt;utility&gt;

int main()
{
   std::pair&lt;char *, char *&gt; p (0,0);
}
</pre></blockquote>

<p>
I just got a bug report about that, because it's valid C++03, but not
C++0x. The important realization, for me, is that the emplace
proposal---which made <tt>push_back</tt> variadic, causing the <tt>push_back(0)</tt>
issue---didn't cause this break in backward compatibility. The break
actually happened when we added this pair constructor as part of adding
rvalue references into the language, long before variadic templates or
emplace came along:
</p>

<blockquote><pre>template&lt;class U, class V&gt; pair(U&amp;&amp; x, V&amp;&amp; y);
</pre></blockquote>

<p>
Now, concepts will address this issue by constraining that <tt>pair</tt>
constructor to only <tt>U</tt>'s and <tt>V</tt>'s that can properly construct "first" and
"second", e.g. (from
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2322.pdf">N2322</a>):
</p>

<blockquote><pre>template&lt;class U , class V &gt;
requires Constructible&lt;T1, U&amp;&amp;&gt; &amp;&amp; Constructible&lt;T2, V&amp;&amp;&gt;
pair(U&amp;&amp; x , V&amp;&amp; y );
</pre></blockquote>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
<p>
Suggested to resolve using pass-by-value for that case.
</p>
<p>
Side question: Should pair interoperate with tuples? Can construct a
tuple of a pair, but not a pair from a two-element tuple.
</p>
<p>
Related to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#885">885</a>.
</p>
</blockquote>

<p><i>[
2009-07-28 Reopened by Alisdair.  No longer solved by concepts.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Leave as open. Howard to provide wording.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>


<p><b>Rationale:</b></p>
<p><i>[
San Francisco:
]</i></p>


<blockquote>
Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2770.pdf">N2770</a>.
</blockquote>







<hr>
<h3><a name="815"></a>815. <tt>std::function</tt> and <tt>reference_closure</tt> do not use perfect forwarding</h3>
<p><b>Section:</b> 20.7.15.2.4 [func.wrap.func.inv] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2008-03-16  <b>Last modified:</b> 2009-10-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>std::function</tt> and <tt>reference_closure</tt> should use "perfect forwarding" as
described in the rvalue core proposal.
</p>

<p><i>[
Sophia Antipolis:
]</i></p>


<blockquote>
According to Doug Gregor, as far as <tt>std::function</tt> is concerned, perfect
forwarding can not be obtained because of type erasure. Not everyone
agreed with this diagnosis of forwarding.
</blockquote>

<p><i>[
2009-05-01 Howard adds:
]</i></p>


<blockquote>
<p>
Sebastian Gesemann brought to my attention that the <tt>CopyConstructible</tt>
requirement on <tt>function</tt>'s <tt>ArgTypes...</tt> is an unnecessary
restriction.
</p>

<blockquote><pre>template&lt;Returnable R, <b>CopyConstructible</b>... ArgTypes&gt;
class function&lt;R(ArgTypes...)&gt;
...
</pre></blockquote>

<p>
On further investigation, this complaint seemed to be the same
issue as this one.  I believe the reason <tt>CopyConstructible</tt> was put
on <tt>ArgTypes</tt> in the first place was because of the nature of the
<i>invoke</i> member:
</p>

<blockquote><pre>template&lt;class R, class ...ArgTypes&gt;
R
function&lt;R(ArgTypes...)&gt;::operator()(ArgTypes... arg) const
{
    if (f_ == 0)
        throw bad_function_call();
    return (*f_)(arg...);
}
</pre></blockquote>

<p>
However now with rvalue-refs, "by value" no longer implies <tt>CopyConstructible</tt>
(as Sebastian correctly points out).  If rvalue arguments are supplied, <tt>MoveConstructible</tt>
is sufficient.  Furthermore, the constraint need not be applied in <tt>function</tt>
if I understand correctly.  Rather the client must apply the proper constraints
at the call site.  Therefore, at the very least, I recommend that <tt>CopyConstructible</tt>
be removed from the template class <tt>function</tt>.
</p>

<p>
Furthermore we need to mandate that the <i>invoker</i> is coded as:
</p>

<blockquote><pre>template&lt;class R, class ...ArgTypes&gt;
R
function&lt;R(ArgTypes...)&gt;::operator()(ArgTypes... arg) const
{
    if (f_ == 0)
        throw bad_function_call();
    return (*f_)(<b>std::forward&lt;ArgTypes&gt;(</b>arg<b>)</b>...);
}
</pre></blockquote>

<p>
Note that <tt>ArgTypes&amp;&amp;</tt> (the "perfect forwarding signature") is not 
appropriate here as this is not a deduced context for <tt>ArgTypes</tt>.  Instead
the client's arguments must implicitly convert to the non-deduced <tt>ArgType</tt>
type.  Catching these arguments by value makes sense to enable decay.
</p>

<p>
Next <tt>forward</tt> is used to move the <tt>ArgTypes</tt> as efficiently as
possible, and also with minimum requirements (not <tt>CopyConstructible</tt>)
to the type-erased functor.  For object types, this will be a <tt>move</tt>.  For
reference type <tt>ArgTypes</tt>, this will be a copy.  The end result <em>must</em> be
that the following is a valid program:
</p>

<blockquote><pre>#include &lt;functional&gt;
#include &lt;memory&gt;
#include &lt;cassert&gt;

std::unique_ptr&lt;int&gt;
f(std::unique_ptr&lt;int&gt; p, int&amp; i)
{
    ++i;
    return std::move(p);
}

int main()
{
    int i = 2;
    std::function&lt;std::unique_ptr&lt;int&gt;(std::unique_ptr&lt;int&gt;,
                                       int&amp;&gt; g(f);
    std::unique_ptr&lt;int&gt; p = g(std::unique_ptr&lt;int&gt;(new int(1)), i);
    assert(*p == 1);
    assert(i == 3);
}
</pre></blockquote>

<p><i>[
Tested in pre-concepts rvalue-ref-enabled compiler.
]</i></p>


<p>
In the example above, the first <tt>ArgType</tt> is <tt>unique_ptr&lt;int&gt;</tt>
and the second <tt>ArgType</tt> is <tt>int&amp;</tt>.  Both <em>must</em> work!
</p>

</blockquote>

<p><i>[
2009-05-27 Daniel adds:
]</i></p>


<blockquote>
<p>
in the 2009-05-01 comment of above mentioned issue Howard
</p>

<ol type="a">
<li>
Recommends to replace the <tt>CopyConstructible</tt> requirement by a
<tt>MoveConstructible</tt> requirement
</li>
<li>
Says: "Furthermore, the constraint need not be applied in <tt>function</tt> if I
understand correctly. Rather the client must apply the proper constraints
at the call site"
</li>
</ol>
<p>
I'm fine with (a), but I think comment (b) is incorrect, at least in the
sense I read these sentences. Let's look at Howard's example code:
</p>

<blockquote><pre>function&lt;R(ArgTypes...)&gt;::operator()(ArgTypes... arg) const
{
   if (f_ == 0)
       throw bad_function_call();
   return (*f_)(std::forward&lt;ArgTypes&gt;(arg)...);
}
</pre></blockquote>

<p>
In the constrained scope of this <tt>operator()</tt> overload the expression
"<tt>(*f_)(std::forward&lt;ArgTypes&gt;(arg)...)</tt>" must be valid. How can it
do so, if <tt>ArgTypes</tt> aren't at least <tt>MoveConstructible</tt>?
</p>
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
Leave this open and wait until concepts are removed from the Working
Draft so that we know how to write the proposed resolution in terms of
diffs to otherwise stable text.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Leave as open. Howard to provide wording. Howard welcomes any help.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="816"></a>816. Should <tt>bind()</tt>'s returned functor have a nofail copy ctor when <tt>bind()</tt> is nofail?</h3>
<p><b>Section:</b> 20.7.11.1.3 [func.bind.bind] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2008-02-08  <b>Last modified:</b> 2009-11-07</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#func.bind.bind">active issues</a> in [func.bind.bind].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#func.bind.bind">issues</a> in [func.bind.bind].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Library Issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#527">527</a> notes that <tt>bind(f, t1, ..., tN)</tt>
should be nofail when <tt>f, t1, ..., tN</tt> have nofail copy ctors.
</p>
<p>
However, no guarantees are provided for the copy ctor of the functor
returned by <tt>bind()</tt>.  (It's guaranteed to have a copy ctor, which can
throw implementation-defined exceptions: <tt>bind()</tt> returns a forwarding
call wrapper, TR1 3.6.3/2.  A forwarding call wrapper is a call wrapper,
TR1 3.3/4.  Every call wrapper shall be CopyConstructible, TR1 3.3/4.
Everything without an exception-specification may throw
implementation-defined exceptions unless otherwise specified, C++03
17.4.4.8/3.)
</p>
<p>
Should the nofail guarantee requested by Library Issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#527">527</a> be extended
to cover both calling <tt>bind()</tt> and copying the returned functor?
</p>

<p><i>[
Howard adds:
]</i></p>


<blockquote>
<tt>tuple</tt> construction should probably have a similar guarantee.
</blockquote>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
Howard to provide wording.
</blockquote>

<p><i>[
Post Summit, Anthony provided wording.
]</i></p>


<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Part of all of this issue appears to be rendered moot
by the proposed resolution to issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#817">817</a> (q.v.).
We recommend the issues be considered simultaneously
(or possibly even merged)
to ensure there is no overlap.
Move to Open, and likewise for issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#817">817</a>.
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
Related to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#817">817</a> (see below). Leave Open.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Move to Ready. Decoupling from issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#817">817</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add a new sentence to the end of paragraphs 2 and 4 of 20.7.11.1.3 [func.bind.bind]:
</p>

<blockquote>
<p>
-2- <i>Returns:</i> A forwarding call wrapper <tt>g</tt> with a weak result type (20.6.2). The effect of <tt>g(u1, u2,
..., uM)</tt> shall be <tt><i>INVOKE</i>(f, v1, v2, ..., vN, Callable&lt;F cv,V1, V2, ..., VN&gt;::result_type)</tt>, where <i>cv</i>
represents the <i>cv</i>-qualifiers of <tt>g</tt> and the values and types of the bound arguments
<tt>v1, v2, ..., vN</tt> are determined as specified below.
<ins>The copy constructor and move constructor of the forwarding call wrapper shall throw an
exception if and only if the corresponding constructor of <tt>F</tt> or any of the types
in <tt>BoundArgs...</tt> throw an exception.</ins>
</p>
<p>...</p>
<p>
-5- <i>Returns:</i> A forwarding call wrapper <tt>g</tt> with a nested type <tt>result_type</tt> defined as a synonym
for <tt>R</tt>. The effect of <tt>g(u1, u2, ..., uM)</tt> shall be <tt><i>INVOKE</i>(f, v1, v2, ..., vN, R)</tt>, where the
values and types of the bound arguments <tt>v1, v2, ..., vN</tt> are determined as specified below.
<ins>The copy constructor and move constructor of the forwarding call wrapper shall throw an
exception if and only if the corresponding constructor of <tt>F</tt> or any of the types
in <tt>BoundArgs...</tt> throw an exception.</ins>
</p>

</blockquote>





<hr>
<h3><a name="817"></a>817. <tt>bind</tt> needs to be moved</h3>
<p><b>Section:</b> 20.7.11.1.3 [func.bind.bind] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2008-03-17  <b>Last modified:</b> 2009-11-08</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#func.bind.bind">active issues</a> in [func.bind.bind].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#func.bind.bind">issues</a> in [func.bind.bind].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US 72, JP 38 and DE 21</b></p>

<p>
The functor returned by <tt>bind()</tt> should have a move constructor that
requires only move construction of its contained functor and bound arguments.
That way move-only functors can be passed to objects such as <tt>thread</tt>.
</p>
<p>
This issue is related to issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#816">816</a>.
</p>

<p>
US 72:
</p>

<blockquote>
<tt>bind</tt> should support move-only functors and bound arguments.
</blockquote>

<p>
JP 38:
</p>

<blockquote>
<p>
add the move requirement for bind's return type.
</p>
<p>
For example, assume following <tt>th1</tt> and <tt>th2</tt>,
</p>

<blockquote><pre>void f(vector&lt;int&gt; v) { }

vector&lt;int&gt; v{ ... };
thread th1([v]{ f(v); });
thread th2(bind(f, v));
</pre></blockquote>

<p>
When function object are set to thread, <tt>v</tt> is moved to <tt>th1</tt>'s lambda
expression in a Move Constructor of lambda expression because <tt>th1</tt>'s lambda
expression has a Move Constructor. But <tt>bind</tt> of <tt>th2</tt>'s
return type doesn't have the requirement of Move, so it may not
moved but copied.
</p>
<p>
Add the requirement of move to get rid of this useless copy.
</p>
<p>
And also, add the <tt>MoveConstructible</tt> as well as <tt>CopyConstructible</tt>.
</p>
</blockquote>

<p>
DE 21
</p>

<blockquote>
The specification for bind claims twice that "the values and types for
the bound arguments v1, v2, ..., vN are determined as specified below".
No such specification appears to exist.
</blockquote>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
Howard to provide wording.
</blockquote>

<p><i>[
Post Summit Alisdair and Howard provided wording.
]</i></p>


<blockquote>
<p>
Several issues are being combined in this resolution.  They are all touching the
same words so this is an attempt to keep one issue from stepping on another, and
a place to see the complete solution in one place.
</p>

<ol>
<li>
<tt>bind</tt> needs to be "moved".
</li>
<li>
20.7.11.1.3 [func.bind.bind]/p3, p6 and p7 were accidently removed from N2798.
</li>
<li>
Issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#929">929</a> argues for a way to pass by &amp;&amp; for
efficiency but retain the decaying behavior of pass by value for the
<tt>thread</tt> constructor.  That same solution is applicable here.
</li>
</ol>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We were going to recommend moving this issue to Tentatively Ready
until we noticed potential overlap with issue 816 (q.v.).
</p>
<p>
Move to Open,
and recommend both issues be considered together
(and possibly merged).
</p>
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
The proposed resolution uses concepts. Leave Open.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Leave as Open. Howard to provide deconceptified wording.
</blockquote>

<p><i>[
2009-11-07 Howard updates wording.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
Change 20.7 [function.objects] p2:
</p>

<blockquote><pre>template&lt;class F<del>n</del>, class... <del>Types</del> <ins>BoundArgs</ins>&gt;
  <i>unspecified</i> bind(F<del>n</del><ins>&amp;&amp;</ins>, <del>Types</del> <ins>BoundArgs&amp;&amp;</ins>...);
template&lt;class R, class F<del>n</del>, class... <del>Types</del> <ins>BoundArgs</ins>&gt;
  <i>unspecified</i> bind(F<del>n</del><ins>&amp;&amp;</ins>, <del>Types</del> <ins>BoundArgs&amp;&amp;</ins>...);
</pre></blockquote>

<p>
Change 20.7.11.1.3 [func.bind.bind]:
</p>

<blockquote>
<p><ins>
Within this clause:
</ins></p>

<ul>
<li><ins>
Let <tt>FD</tt> be a synonym for the type <tt>decay&lt;F&gt;::type</tt>.
</ins></li>
<li><ins>
Let <tt>fd</tt> be an lvalue of type <tt>FD</tt> constructed from
<tt>std::forward&lt;F&gt;(f)</tt>.
</ins></li>
<li><ins>
Let <tt>Ti</tt> be a synonym for the i<sup><i>th</i></sup> type in the
parameter pack <tt>BoundArgs</tt>.
</ins></li>
<li><ins>
Let <tt>TiD</tt> be a synonym for the type <tt>decay&lt;Ti&gt;::type</tt>.
</ins></li>
<li><ins>
Let <tt>ti</tt> be the i<sup><i>th</i></sup> argument in <tt>bound_args</tt>.
</ins></li>
<li><ins>
Let <tt>tid</tt> be an lvalue of type <tt>TiD</tt> constructed from
<tt>std::forward&lt;Ti&gt;(ti)</tt>.
</ins></li>
</ul>

<pre>template&lt;class F, class... BoundArgs&gt;
  <i>unspecified</i> bind(F<ins>&amp;&amp;</ins> f, BoundArgs<ins>&amp;&amp;</ins>... bound_args);
</pre>

<blockquote>
<p>
-1- <i>Requires:</i>
<ins><tt>is_constructible&lt;FD, F&gt;::value</tt>
shall be <tt>true</tt>.</ins>
<ins><tt>is_constructible&lt;TiD, Ti&gt;::value</tt>
shall be <tt>true</tt></ins>.
<del><tt>F</tt> and each <tt>Ti</tt> in
<tt>BoundArgs</tt> shall be CopyConstructible.</del>
<tt><i>INVOKE</i>(f<ins>d</ins>, w1, w2, ..., wN)</tt> (20.7.2 [func.require]) shall be a valid expression for some values
<i>w1, w2, ..., wN</i>, where <tt>N == sizeof...(bound_args)</tt>.
</p>
<p>
-2- <i>Returns:</i> A forwarding call wrapper <tt>g</tt> with a weak
result type (20.7.2 [func.require]). The effect of <tt>g(u1, u2,
..., uM)</tt> shall be <tt><i>INVOKE</i>(f<ins>d</ins>, v1, v2, ..., vN,
result_of&lt;F<ins>D</ins> <i>cv</i> (V1, V2, ..., VN)&gt;::type)</tt>, where
<i>cv</i> represents the <i>cv</i>-qualifiers of <tt>g</tt> and the
values and types of the bound arguments <tt>v1, v2, ..., vN</tt> are
determined as specified below.
<ins>The copy constructor and move constructor of the forwarding call wrapper shall throw an
exception if and only if the corresponding constructor of <tt>FD</tt> or any of the types
<tt>TiD</tt> throw an exception.</ins>
</p>
<p>
-3- <i>Throws:</i> Nothing unless the <del>copy</del>
construct<ins>ion</ins><del>or</del> of
<tt><del>F</del><ins>fd</ins></tt> or of one of the <ins>values
<tt>tid</tt></ins> <del>types in the <tt>BoundArgs...</tt> pack
expansion</del> throws an exception.
</p>
<p>
<ins>
<i>Remarks:</i> The <i>unspecified</i> return type shall be
<tt>MoveConstructible</tt>.  If all of <tt>FD</tt> and <tt>TiD</tt> are
<tt>CopyConstructible</tt> then the <i>unspecified</i> return type shall
be <tt>CopyConstructible</tt>. [<i>Note:</i> This implies that all of
<tt>FD</tt> and <tt>TiD</tt> shall be <tt>MoveConstructible</tt> &#8212;
<i>end note</i>]
</ins>
</p>
</blockquote>

<pre>template&lt;class R, class F, class... BoundArgs&gt;
  <i>unspecified</i> bind(F<ins>&amp;&amp;</ins> f, BoundArgs<ins>&amp;&amp;</ins>... bound_args);
</pre>

<blockquote>
<p>
-4- <i>Requires:</i>
<ins><tt>is_constructible&lt;FD, F&gt;::value</tt>
shall be <tt>true</tt>.</ins>
<ins><tt>is_constructible&lt;TiD, Ti&gt;::value</tt>
shall be <tt>true</tt></ins>.
<del><tt>F</tt> and each <tt>Ti</tt> in
<tt>BoundArgs</tt> shall be CopyConstructible.</del>
<tt><i>INVOKE</i>(f<ins>d</ins>, w1,
w2, ..., wN)</tt> shall be a valid expression for some values <i>w1, w2,
..., wN</i>, where <tt>N == sizeof...(bound_args)</tt>.
</p>
<p>
-5- <i>Returns:</i> A forwarding call wrapper <tt>g</tt> with a nested
type <tt>result_type</tt> defined as a synonym for <tt>R</tt>. The
effect of <tt>g(u1, u2, ..., uM)</tt> shall be <tt><i>INVOKE</i>(f<ins>d</ins>, v1,
v2, ..., vN, R)</tt>, where the values and types of the bound arguments
<tt>v1, v2, ..., vN</tt> are determined as specified below.
<ins>The copy constructor and move constructor of the forwarding call wrapper shall throw an
exception if and only if the corresponding constructor of <tt>FD</tt> or any of the types
<tt>TiD</tt> throw an exception.</ins>
</p>
<p>
-6- <i>Throws:</i> Nothing unless the <del>copy</del>
construct<ins>ion</ins><del>or</del> of
<tt><del>F</del><ins>fd</ins></tt> or of one of the <ins>values
<tt>tid</tt></ins> <del>types in the <tt>BoundArgs...</tt> pack
expansion</del> throws an exception.
</p>
<p>
<ins>
<i>Remarks:</i> The <i>unspecified</i> return type shall be
<tt>MoveConstructible</tt>.  If all of <tt>FD</tt> and <tt>TiD</tt> are
<tt>CopyConstructible</tt> then the <i>unspecified</i> return type shall
be <tt>CopyConstructible</tt>. [<i>Note:</i> This implies that all of
<tt>FD</tt> and <tt>TiD</tt> shall be <tt>MoveConstructible</tt> &#8212;
<i>end note</i>]
</ins>
</p>
</blockquote>

<p>
-7- The values of the <i>bound arguments</i> <tt>v1, v2, ..., vN</tt> and
their corresponding types <tt>V1, V2, ..., VN</tt> depend on the type<ins>s
<tt>TiD</tt> derived from</ins>
<del>of the corresponding argument <tt>ti</tt> in <tt>bound_args</tt> of type
<tt>Ti</tt> in <tt>BoundArgs</tt> in</del>
the call to <tt>bind</tt> and the
<i>cv</i>-qualifiers <i>cv</i> of the call wrapper <tt>g</tt> as
follows:
</p>

<ul>
<li>
if <tt><del>ti</del> <ins>TiD</ins></tt> <del>is of</del> <ins>has</ins>
type <tt>reference_wrapper&lt;T&gt;</tt> the argument is
<tt>ti<ins>d</ins>.get()</tt> and its type <tt>Vi</tt> is
<tt>T&amp;</tt>;
</li>
<li>
if the value of
<tt>std::is_bind_expression&lt;Ti<ins>D</ins>&gt;::value</tt> is
<tt>true</tt> the argument is <tt>ti<ins>d</ins>(u1, u2, ..., uM)</tt>
and its type <tt>Vi</tt> is <tt>result_of&lt;Ti<ins>D</ins> <i>cv</i>
(U1&amp;, U2&amp;, ..., UM&amp;)&gt;::type</tt>;
</li>
<li>
if the value <tt>j</tt> of
<tt>std::is_placeholder&lt;Ti<ins>D</ins>&gt;::value</tt> is not zero
the argument is <tt>std::forward&lt;Uj&gt;(uj)</tt> and its type
<tt>Vi</tt> is <tt>Uj&amp;&amp;</tt>;
</li>
<li>
otherwise the value is <tt>ti<ins>d</ins></tt> and its type <tt>Vi</tt>
is <tt>Ti<ins>D</ins> <i>cv</i> &amp;</tt>.
</li>
</ul>

</blockquote>






<hr>
<h3><a name="819"></a>819. rethrow_if_nested</h3>
<p><b>Section:</b> 18.8.6 [except.nested] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2008-03-25  <b>Last modified:</b> 2009-10-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#except.nested">active issues</a> in [except.nested].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#except.nested">issues</a> in [except.nested].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Looking at the wording I submitted for <tt>rethrow_if_nested</tt>, I don't think I
got it quite right.
</p>

<p>
The current wording says:
</p>

<blockquote>
<pre>template &lt;class E&gt; void rethrow_if_nested(const E&amp; e);
</pre>
<blockquote>
<p>
<i>Effects:</i> Calls <tt>e.rethrow_nested()</tt> only if <tt>e</tt>
is publicly derived from <tt>nested_exception</tt>.
</p>
</blockquote>
</blockquote>

<p>
This is trying to be a bit subtle, by requiring <tt>e</tt> (not <tt>E</tt>) to be publicly
derived from <tt>nested_exception</tt> the idea is that a <tt>dynamic_cast</tt> would be
required to be sure.  Unfortunately, if <tt>e</tt> is dynamically but not statically
derived from <tt>nested_exception</tt>, <tt>e.rethrow_nested()</tt> is ill-formed.
</p>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
Alisdair was volunteered to provide wording.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Leave as Open. Alisdair to provide wording.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="834"></a>834. Unique_ptr::pointer requirements underspecified</h3>
<p><b>Section:</b> 20.8.14.2 [unique.ptr.single] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2008-05-14  <b>Last modified:</b> 2009-10-26</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#unique.ptr.single">active issues</a> in [unique.ptr.single].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#unique.ptr.single">issues</a> in [unique.ptr.single].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#673">673</a> (including recent updates by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#821">821</a>) proposes a useful
extension point for <tt>unique_ptr</tt> by granting support for an optional
<tt>deleter_type::pointer</tt> to act as pointer-like replacement for <tt>element_type*</tt>
(In the following: <tt>pointer</tt>).
</p>
<p>
Unfortunately no requirements are specified for the type <tt>pointer</tt> which has
impact on at least two key features of <tt>unique_ptr</tt>:
</p>

<ol>
<li>Operational fail-safety.</li>
<li>(Well-)Definedness of expressions.</li>
</ol>

<p>
<tt>Unique_ptr</tt> specification makes great efforts to require that essentially *all*
operations cannot throw and therefore adds proper wording to the affected
operations of the deleter as well. If user-provided <tt>pointer</tt>-emulating types
("smart pointers") will be allowed, either *all* throw-nothing clauses have to
be replaced by weaker "An exception is thrown only if <tt>pointer</tt>'s {op} throws
an exception"-clauses or it has to be said explicitly that all used
operations of
<tt>pointer</tt> are required *not* to throw. I understand the main focus of <tt>unique_ptr</tt>
to be as near as possible to the advantages of native pointers which cannot
fail and thus strongly favor the second choice. Also, the alternative position
would make it much harder to write safe and simple template code for
<tt>unique_ptr</tt>. Additionally, I assume that a general statement need to be given
that all of the expressions of <tt>pointer</tt> used to define semantics are required to
be well-formed and well-defined (also as back-end for <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#762">762</a>).
</p>

<p><i>[
Sophia Antipolis:
]</i></p>


<blockquote>
<p>
Howard: We maybe need a core concept <tt>PointerLike</tt>, but we don't need the
arithmetic (see <tt>shared_ptr</tt> vs. <tt>vector&lt;T&gt;::iterator</tt>.
</p>
<p>
Howard will go through and enumerate the individual requirements wrt. <tt>pointer</tt> for each member function.
</p>
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
Move to Ready.
</blockquote>

<p><i>[
2009-10-15 Alisdair pulls from Ready:
]</i></p>


<blockquote>
<p>
I hate to pull an issue out of Ready status, but I don't think 834 is
fully baked yet.
</p>

<p>
For reference the proposed resolution is to add the following words:
</p>

<blockquote>
<tt>unique_ptr&lt;T, D&gt;::pointer</tt>'s operations shall be
well-formed, shall have well defined behavior, and shall not throw
exceptions.
</blockquote>

<p>
This leaves me with a big question : which operations?
</p>

<p>
Are all pointer operations required to be nothrow, including operations
that have nothing to do with interactions with <tt>unique_ptr</tt>?  This was
much simpler with concepts where we could point to operations within a
certain concept, and so nail down the interactions.
</p>
</blockquote>

<p><i>[
2009-10-15 Daniel adds:
]</i></p>


<blockquote>
I volunteer to prepare a more fine-grained solution, but I would like
to ask for feedback that helps me doing so. If this question is asked
early in the meeting I might be able to fix it within the week, but I
cannot promise that now.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Leave in open. Daniel to provide wording as already suggested.
</blockquote>




<p><b>Proposed resolution:</b></p>
<p>
Add the following sentence just at the end of the newly proposed
20.8.14.2 [unique.ptr.single]/p. 3:
</p>

<blockquote>
<tt>unique_ptr&lt;T, D&gt;::pointer</tt>'s operations shall be well-formed, shall have well
defined behavior, and shall not throw exceptions.
</blockquote>





<hr>
<h3><a name="835"></a>835. tying two streams together (correction to DR 581)</h3>
<p><b>Section:</b> 27.5.4.2 [basic.ios.members] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2008-05-17  <b>Last modified:</b> 2009-10-20</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#basic.ios.members">active issues</a> in [basic.ios.members].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#basic.ios.members">issues</a> in [basic.ios.members].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
       <p>

The fix for
issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#581">581</a>,
now integrated into the working paper, overlooks a couple of minor
problems.

       </p>
       <p>

First, being an unformatted function once again, <code>flush()</code>
is required to create a sentry object whose constructor must, among
other things, flush the tied stream. When two streams are tied
together, either directly or through another intermediate stream
object, flushing one will also cause a call to <code>flush()</code> on
the other tied stream(s) and vice versa, ad infinitum. The program
below demonstrates the problem.

       </p>
       <p>

Second, as Bo Persson notes in his
comp.lang.c++.moderated <a href="http://groups.google.com/group/comp.lang.c++.moderated/tree/browse_frm/thread/f2187794e9cc036d/305df31dc583054a">post</a>,
for streams with the <code>unitbuf</code> flag set such
as <code>std::stderr</code>, the destructor of the sentry object will
again call <code>flush()</code>. This seems to create an infinite
recursion for <code>std::cerr &lt;&lt; std::flush;</code>

       </p>
       <blockquote>
           <pre>#include &lt;iostream&gt;

int main ()
{
   std::cout.tie (&amp;std::cerr);
   std::cerr.tie (&amp;std::cout);
   std::cout &lt;&lt; "cout\n";
   std::cerr &lt;&lt; "cerr\n";
} 
</pre>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution.
Move to Review.
</blockquote>

<p><i>[
2009-05-26 Daniel adds:
]</i></p>


<blockquote>
<p>
I think that the most recently suggested change in
27.7.2.4 [ostream::sentry] need some further word-smithing. As
written, it would make the behavior undefined, if under
conditions when <tt>pubsync()</tt> should be called, but when
in this scenario <tt>os.rdbuf()</tt> returns 0.
</p>
<p>
This case is explicitly handled in <tt>flush()</tt> and needs to be
taken care of. My suggested fix is:
</p>

<blockquote>
If <tt>((os.flags() &amp; ios_base::unitbuf) &amp;&amp; !uncaught_exception()</tt>
<ins><tt>&amp;&amp; os.rdbuf() != 0</tt></ins>) is true, calls <del><tt>os.flush()</tt></del>
<ins><tt>os.rdbuf()-&gt;pubsync()</tt></ins>.
</blockquote>

<p>
Two secondary questions are:
</p>

<ol>
<li>
Should <tt>pubsync()</tt> be invoked in any case or shouldn't a
base requirement for this trial be that <tt>os.good() == true</tt>
as required in the original <tt>flush()</tt> case?
</li>
<li>
Since <tt>uncaught_exception()</tt> is explicitly tested, shouldn't
a return value of -1 of <tt>pubsync()</tt> produce <tt>setstate(badbit)</tt>
(which may throw <tt>ios_base::failure</tt>)?
</li>
</ol>
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
<p>
Daniel volunteered to modify the proposed resolution to address his two questions.
</p>
<p>
Move back to Open.
</p>
</blockquote>

<p><i>[
2009-07-26 Daniel provided wording.  Moved to Review.
]</i></p>


<p><i>[
2009-10-13 Daniel adds:
]</i></p>


<blockquote>
This proposed wording is written to match the outcome
of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#397">397</a>.
</blockquote>

<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote>
Move to Open. Martin to propose updated wording that will also resolve
issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#397">397</a> consistently.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p><i>[
based on
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2960.pdf">N2960</a>
numbering
]</i></p>


<ol>
<li>
<p>
Just before 27.5.4.2 [basic.ios.members]/2 insert a new paragraph:
</p>

<blockquote>
<ins><i>Requires:</i> If <tt>(tiestr != 0)</tt> is <tt>true</tt>, <tt>tiestr</tt> must not be reachable
by traversing the linked list of tied stream objects starting from
<tt>tiestr-&gt;tie()</tt>.</ins>
</blockquote>
</li>

<li>
<p>
Change 27.7.2.4 [ostream::sentry]/4 as indicated:
</p>

<blockquote>
If <tt>((os.flags() &amp; ios_base::unitbuf) &amp;&amp; !uncaught_exception()<ins>&amp;&amp;
os.good()</ins>)</tt> is <tt>true</tt>, calls <del><tt>os.flush()</tt></del>
<ins><tt>os.rdbuf()-&gt;pubsync()</tt>. If that function returns -1 sets
<tt>badbit</tt> in <tt>os.rdstate()</tt> without propagating an exception</ins>.
</blockquote>
</li>

</ol>


   



<hr>
<h3><a name="836"></a>836. 
       effects of <code>money_base::space</code> and
       <code>money_base::none</code> on <code>money_get</code>
   </h3>
<p><b>Section:</b> 22.4.6.1.2 [locale.money.get.virtuals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2008-05-17  <b>Last modified:</b> 2009-10-21</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.money.get.virtuals">issues</a> in [locale.money.get.virtuals].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#670">670</a></p>
<p><b>Discussion:</b></p>

       <p>

In paragraph 2, 22.4.6.1.2 [locale.money.get.virtuals] specifies the following:

       </p>
       <blockquote>

Where <code>space</code> or <code>none</code> appears in the format
pattern, except at the end, optional white space (as recognized
by <code>ct.is</code>) is consumed after any required space.

       </blockquote>
       <p>

This requirement can be (and has been) interpreted two mutually
exclusive ways by different readers. One possible interpretation
is that:

       </p>
       <blockquote>
           <ol>
               <li>

where <code>money_base::space</code> appears in the format, at least
one space is required, and

               </li>
               <li>

where <code>money_base::none</code> appears in the format, space is
allowed but not required.

               </li>
           </ol>
       </blockquote>
       <p>

The other is that:

       </p>
       <blockquote>

where either <code>money_base::space</code> or <code>money_base::none</code> appears in the format, white space is optional.

       </blockquote>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
Martin will revise the proposed resolution.
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
<p>
There is a noun missing from the proposed resolution. It's not clear
that the last sentence would be helpful, even if the word were not
missing:
</p>
<blockquote>
In either case, any required MISSINGWORD followed by all optional whitespace (as recognized by ct.is()) is consumed.
</blockquote>
<p>
Strike this sentence and move to Review.
</p>

<p><i>[
Howard: done.
]</i></p>

</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Move to Ready.
</blockquote>

   

   <p><b>Proposed resolution:</b></p>
       <p>

I propose to change the text to make it clear that the first
interpretation is intended, that is, to make following change to
22.4.6.1.2 [locale.money.get.virtuals], p2:

       </p>

       <blockquote>

When <code><ins>money_base::</ins>space</code>
or <code><ins>money_base::</ins>none</code> appears <ins>as the last
element </ins>in the format pattern, <del>except at the end, optional
white space (as recognized by <code>ct.is</code>) is consumed after
any required space.</del> <ins>no white space is consumed. Otherwise,
where <code>money_base::space</code> appears in any of the initial
elements of the format pattern, at least one white space character is
required. Where <code>money_base::none</code> appears in any of the
initial elements of the format pattern, white space is allowed but not
required.</ins>
If <code>(str.flags() &amp; str.showbase)</code> is <code>false</code>, ...

       </blockquote>
   



<hr>
<h3><a name="854"></a>854. <tt>default_delete</tt> converting constructor underspecified</h3>
<p><b>Section:</b> 20.8.14.1.1 [unique.ptr.dltr.dflt] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2008-06-18  <b>Last modified:</b> 2009-10-21</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
No relationship between <tt>U</tt> and <tt>T</tt> in the converting constructor for <tt>default_delete</tt> template.
</p>
<p>
Requirements: <tt>U*</tt> is convertible to <tt>T*</tt> and <tt>has_virtual_destructor&lt;T&gt;</tt>;
the latter should also become a concept.
</p>
<p>
Rules out cross-casting.
</p>
<p>
The requirements for <tt>unique_ptr</tt> conversions should be the same as those on the deleter.
</p>

<p><i>[
Howard adds 2008-11-26:
]</i></p>


<blockquote>
<p>
I believe we need to be careful to not outlaw the following use case, and
I believe the current proposed wording
(<tt>requires Convertible&lt;U*, T*&gt; &amp;&amp; HasVirtualDestructor&lt;T&gt;</tt>) does so:
</p>

<blockquote><pre>#include &lt;memory&gt;

int main()
{
    std::unique_ptr&lt;int&gt; p1(new int(1));
    std::unique_ptr&lt;const int&gt; p2(move(p1));
    int i = *p2;
<font color="#c80000">//    *p2 = i;  // should not compile</font>
}
</pre></blockquote>

<p>
I've removed "<tt>&amp;&amp; HasVirtualDestructor&lt;T&gt;</tt>" from the
<tt>requires</tt> clause in the proposed wording.
</p>

</blockquote>

<p><i>[
Post Summit:
]</i></p>


<blockquote>
<p>
Alisdair: This issue has to stay in review pending a paper constraining
<tt>unique_ptr</tt>.
</p>
<p>
Consensus: We agree with the resolution, but <tt>unique_ptr</tt> needs
to be constrained, too.
</p>
<p>
Recommend Keep in Review.
</p>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Keep in Review status for the reasons cited.
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
<p>
The proposed resolution uses concepts. Howard needs to rewrite the
proposed resolution.
</p>
<p>
Move back to Open.
</p>
</blockquote>

<p><i>[
2009-07-26 Howard provided rewritten proposed wording and moved to Review.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Move to Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add after 20.8.14.1.1 [unique.ptr.dltr.dflt], p1:
</p>

<blockquote><pre>template &lt;class U&gt; default_delete(const default_delete&lt;U&gt;&amp; other);
</pre>
<blockquote>
<p>
-1- <i>Effects:</i> ...
</p>
<p><ins>
<i>Remarks:</i> This constructor shall participate in overload resolution
if and only if <tt>U*</tt> is implicitly convertible to <tt>T*</tt>.
</ins></p>
</blockquote>
</blockquote>






<hr>
<h3><a name="860"></a>860. Floating-Point State</h3>
<p><b>Section:</b> 26 [numerics] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Lawrence Crowl <b>Opened:</b> 2008-06-23  <b>Last modified:</b> 2009-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#numerics">issues</a> in [numerics].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There are a number of functions that affect the floating point state.
These function need to be thread-safe, but I'm unsure of the right
approach in the standard, as we inherit them from C.
</p>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
<p>
Nick: I think we already say that these functions do not introduce data
races; see 17.6.5.6/20
</p>
<p>
Pete: there's more to it than not introducing data races; are these
states maintained per thread?
</p>
<p>
Howard: 21.5/14 says that strtok and strerror are not required to avoid
data races, and 20.9/2 says the same about asctime, gmtime, ctime, and
gmtime.
</p>
<p>
Nick: POSIX has a list of not-safe functions. All other functions are
implicitly thread safe.
</p>
<p>
Lawrence is to form a group between meetings to attack this issue. Nick
and Tom volunteered to work with Lawrence.
</p>
<p>
Move to Open.
</p>
</blockquote>

<p><i>[
Post Summit:
]</i></p>


<blockquote>
<p>
Hans: Sane oses seem ok. Sensible thing is implementable and makes sense.
</p>
<p>
Nick: Default wording seems to cover this? Hole in POSIX, these
functions need to be added to list of thread-unsafe functions.
</p>
<p>
Lawrence: Not sufficient, not "thread-safe" per our definition, but
think of state as a thread-local variable. Need something like "these
functions only affect state in the current thread."
</p>
<p>
Hans: Suggest the following wording: "The floating point environment is
maintained per-thread."
</p>
<p>
Walter: Any other examples of state being thread safe that are not
already covered elsewhere?
</p>
<p>
Have thread unsafe functions paper which needs to be updated. Should
just fold in 26.3 [cfenv] functions.
</p>
<p>
Recommend Open. Lawrence instead suggests leaving it open until we have
suitable wording that may or may not include the thread local
commentary.
</p>
</blockquote>

<p><i>[
2009-09-23 Hans provided wording.
]</i></p>


<blockquote>
If I understand the history correctly, Nick, as the Posix liaison,
should probably get a veto on this, since I think it came from Posix (?)
via WG14 and should probably really be addressed there (?).  But I think
we are basically in agreement that there is no other sane way to do
this, and hence we don't have to worry too much about stepping on toes. 
As far as I can tell, this same issue also exists in the latest Posix
standard (?).
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Moved to Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add at the end of 26.3.1 [cfenv.syn]:
</p>

<blockquote>
<p>
2 The header defines all functions, types, and macros the same as C99 7.6.
</p>

<p><ins>
A separate floating point environment shall be maintained for each
thread.  Each function accesses the environment corresponding to its
calling thread.
</ins></p>
</blockquote>





<hr>
<h3><a name="861"></a>861. Incomplete specification of EqualityComparable for std::forward_list</h3>
<p><b>Section:</b> 23.2 [container.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2008-06-24  <b>Last modified:</b> 2009-10-24</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#container.requirements">active issues</a> in [container.requirements].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#container.requirements">issues</a> in [container.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Table 89, Container requirements, defines <tt>operator==</tt> in terms of the container
member function <tt>size()</tt> and the algorithm <tt>std::equal</tt>:
</p>

<blockquote>
<tt>==</tt> is an equivalence relation. <tt>a.size() == b.size() &amp;&amp;
equal(a.begin(), a.end(), b.begin()</tt>
</blockquote>

<p>
The new container <tt>forward_list</tt> does not provide a <tt>size</tt> member function
by design but does provide <tt>operator==</tt> and <tt>operator!=</tt> without specifying it's semantic.
</p>
<p>
Other parts of the (sequence) container requirements do also depend on
<tt>size()</tt>, e.g. <tt>empty()</tt>
or <tt>clear()</tt>, but this issue explicitly attempts to solve the missing
<tt>EqualityComparable</tt> specification,
because of the special design choices of <tt>forward_list</tt>.
</p>
<p>
I propose to apply one of the following resolutions, which are described as:
</p>

<ol type="A">
<li>
Provide a definition, which is optimal for this special container without
previous size test. This choice prevents two <tt>O(N)</tt> calls of <tt>std::distance()</tt>
with the corresponding container ranges and instead uses a special
<tt>equals</tt> implementation which takes two container ranges instead of 1 1/2.
</li>
<li>
The simple fix where the usual test is adapted such that <tt>size()</tt> is replaced
by <tt>distance</tt> with corresponding performance disadvantages.
</li>
</ol>
<p>
Both proposal choices are discussed, the preferred choice of the author is
to apply (A).
</p>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
<p>
There's an Option C: change the requirements table to use distance().
</p>
<p>
LWG found Option C acceptable.
</p>
<p>
Martin will draft the wording for Option C.
</p>
</blockquote>

<p><i>[
post San Francisco:
]</i></p>


<blockquote>
Martin provided wording for Option C.
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
Other operational semantics (see, for example, Tables 82 and 83) are
written in terms of a container's size() member. Daniel to update
proposed resolution C.
</p>
<p><i>[
Howard: Commented out options A and B.
]</i></p>

</blockquote>

<p><i>[
2009-07-26 Daniel updated proposed resolution C.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Mark NAD Editorial. Addressed by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2986.pdf">N2986</a>.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Reopened.
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2986.pdf">N2986</a>
was rejected in full committee on procedural grounds.
</blockquote>



<p><b>Proposed resolution:</b></p>


<p>
Option (C):
</p>
<blockquote>

<p><i>[
The changes are relative to
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2914.pdf">N2914</a>
but concept-free.
]</i></p>


<ol>
<li>
<p>
In 23.2.1 [container.requirements.general] change Table 80 -- Container requirements as indicated:
</p>

<ol type="a">
<li>
<p>
Change the text in the Assertion/note column in the row for "<tt>X u</tt>;"
as follows:
</p>

<blockquote>
post: <tt>u.<del>size() == 0</del><ins>empty() == true</ins></tt>
</blockquote>
</li>

<li>
<p>
Change the text in the Assertion/note column in the row for "<tt>X();</tt>"
as follows:
</p>

<blockquote>
<tt>X().<del>size() == 0</del><ins>empty() == true</ins></tt>
</blockquote>
</li>

<li>
<p>
Change the text in the Operational Semantics column in the row for
"<tt>a == b</tt>" as follows:
</p>
<blockquote>
<tt>==</tt> is an equivalence relation.
<tt><del>a.size()</del><ins>distance(a.begin(), a.end())</ins> ==
   <del>b.size()</del><ins>distance(b.begin(), b.end())</ins> &amp;&amp;
equal(a.begin(), a.end(), b.begin())</tt>
</blockquote>
</li>

<li>
<p>
Change the text in the Operational Semantics column in the row for
"<tt>a.size()</tt>" as follows:
</p>

<blockquote>
<tt><del>a.end() - a.begin()</del><ins>distance(a.begin(), a.end())</ins></tt>
</blockquote>
</li>

<li>
<p>
Change the text in the Operational Semantics column in the row for
"<tt>a.max_size()</tt>" as follows:
</p>

<blockquote>
<tt><del>size()</del><ins>distance(begin(), end())</ins></tt> of the largest
possible container
</blockquote>
</li>

<li>
<p>
Change the text in the Operational Semantics column in the row for
"<tt>a.empty()</tt>" as follows:
</p>

<blockquote>
<tt><del>a.size() == 0</del><ins>a.begin() == a.end()</ins></tt>
</blockquote>
</li>
</ol>
</li>

<li>
<p>
In 23.2.1 [container.requirements.general] change Table 82 -- Allocator-aware container requirements as indicated:
</p>

<ol type="a">
<li>
<p>
Change the text in the Assertion/note column in the row for "<tt>X() /
X u;</tt>" as follows:
</p>

<blockquote>
<i>Requires:</i> <tt>A</tt> is <tt>DefaultConstructible</tt> post: <tt><del>u.size() ==
0</del><ins>u.empty() == true</ins></tt>, <tt>get_allocator() == A()</tt>
</blockquote>
</li>

<li>
<p>
Change the text in the Assertion/note column in the row for "<tt>X(m) /
X u(m);</tt>" as follows:
</p>

<blockquote>
post: <tt><del>u.size() == 0</del><ins>u.empty() == true</ins>,
get_allocator() == m</tt>
</blockquote>
</li>
</ol>
</li>

<li>
<p>
In 23.2.3 [sequence.reqmts] change Table 83 -- Sequence container requirements as indicated:
</p>

<ol type="a">
<li>
<p>
Change the text in the Assertion/note column in the row for "<tt>X(n,
t) / X a(n, t)</tt>" as follows:
</p>

<blockquote>
post: <tt><del>size()</del><ins>distance(begin(), end())</ins> == n [..]</tt>
</blockquote>
</li>

<li>
<p>
Change the text in the Assertion/note column in the row for "<tt>X(i,
j) / X a(i, j)</tt>" as follows:
</p>

<blockquote>
[..] post: <del><tt>size() ==</tt> distance between <tt>i</tt> and
<tt>j</tt></del><ins><tt>distance(begin(), end()) == distance(i, j)</tt></ins> [..]
</blockquote>
</li>

<li>
<p>
Change the text in the Assertion/note column in the row for
"<tt>a.clear()</tt>" as follows:
</p>
<blockquote>
<tt><ins>a.</ins>erase(<ins>a.</ins>begin(), <ins>a.</ins>end())</tt> post:
<tt><del>size() == 0</del><ins>a.empty() == true</ins></tt>
</blockquote>
</li>
</ol>
</li>

<li>
<p>
In 23.2.4 [associative.reqmts] change Table 85 -- Associative container requirements as indicated:
</p>

<p><i>[
Not every occurrence of <tt>size()</tt> was replaced, because all current
associative containers
have a <tt>size</tt>. The following changes ensure consistency regarding the
semantics of "<tt>erase</tt>"
for all tables and adds some missing objects
]</i></p>


<ol type="a">
<li>
<p>
Change the text in the Complexity column in the row for
"<tt>a.insert(i, j)</tt>" as follows:
</p>
<blockquote>
<tt>N log(<ins>a.</ins>size() + N)</tt> <del>(<tt>N</tt> is the distance from <tt>i</tt> to
<tt>j</tt>)</del><ins> where <tt>N == distance(i, j)</tt></ins>
</blockquote>
</li>

<li>
<p>
Change the text in the Complexity column in the row for
"<tt>a.erase(k)</tt>" as follows:
</p>
<blockquote>
<tt>log(<ins>a.</ins>size()) + <ins>a.</ins>count(k)</tt>
</blockquote>
</li>

<li>
<p>
Change the text in the Complexity column in the row for
"<tt>a.erase(q1, q2)</tt>" as follows:
</p>

<blockquote>
<tt>log(<ins>a.</ins>size()) + N</tt> where <tt>N</tt> <del>is the distance from <tt>q1</tt>
to <tt>q2</tt></del>
   <ins><tt>== distance(q1, q2)</tt></ins>.
</blockquote>
</li>

<li>
<p>
Change the text in the Assertion/note column in the row for
"<tt>a.clear()</tt>" as follows:
</p>

<blockquote>
<tt><ins>a.</ins>erase(a.begin(),a.end())</tt> post: <tt><del>size() ==
0</del><ins>a.empty() == true</ins></tt>
</blockquote>
</li>

<li>
<p>
Change the text in the Complexity column in the row for "<tt>a.clear()</tt>"
as follows:
</p>

<blockquote>
linear in <tt><ins>a.</ins>size()</tt>
</blockquote>
</li>

<li>
<p>
Change the text in the Complexity column in the row for
"<tt>a.count(k)</tt>" as follows:
</p>

<blockquote>
<tt>log(<ins>a.</ins>size()) + <ins>a.</ins>count(k)</tt>
</blockquote>
</li>
</ol>
</li>

<li>
<p>
In 23.2.5 [unord.req] change Table 87 -- Unordered associative container requirements as indicated:
</p>
<p><i>[
The same rational as for Table 85 applies here
]</i></p>


<ol type="a">
<li>
<p>
Change the text in the Assertion/note column in the row for
"<tt>a.clear()</tt>" as follows:
</p>

<blockquote>
[..] Post: <tt>a.<del>size() == 0</del><ins>empty() == true</ins></tt>
</blockquote>
</li>
</ol>
</li>
</ol>


</blockquote>





<hr>
<h3><a name="865"></a>865. More algorithms that throw away information</h3>
<p><b>Section:</b> 25.3.6 [alg.fill], 25.3.7 [alg.generate] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2008-07-13  <b>Last modified:</b> 2009-10-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In regard to library defect <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#488">488</a> I found some more algorithms which
unnecessarily throw away information. These are typically algorithms,
which sequentially write into an <tt>OutputIterator</tt>, but do not return the
final value of this output iterator. These cases are:
</p>

<ol>
<li>
<pre>template&lt;class OutputIterator, class Size, class T&gt;
void fill_n(OutputIterator first, Size n, const T&amp; value);</pre></li>

<li>
<pre>template&lt;class OutputIterator, class Size, class Generator&gt;
void generate_n(OutputIterator first, Size n, Generator gen);</pre></li>
</ol>
<p>
In both cases the minimum requirements on the iterator are
<tt>OutputIterator</tt>, which means according to the requirements of
24.2.2 [output.iterators]/2 that only single-pass iterations are guaranteed.
So, if users of <tt>fill_n</tt> and <tt>generate_n</tt> have *only* an <tt>OutputIterator</tt>
available, they have no chance to continue pushing further values
into it, which seems to be a severe limitation to me.
</p>

<p><i>[
Post Summit Daniel "conceptualized" the wording.
]</i></p>


<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Alisdair likes the idea, but has concerns about the specific wording
about the returns clauses.
</p>
<p>
Alan notes this is a feature request.
</p>
<p>
Bill notes we have made similar changes to other algorithms.
</p>
<p>
Move to Open.
</p>
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
We have a consensus for moving forward on this issue, but Daniel needs
to deconceptify it.
</blockquote>

<p><i>[
2009-07-25 Daniel provided non-concepts wording.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Moved to Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>

<ol>
<li>
<p>
Replace the current declaration of <tt>fill_n</tt> in 25 [algorithms]/2, header
<tt>&lt;algorithm&gt;</tt> synopsis and in 25.3.6 [alg.fill] by
</p>

<blockquote><pre>template&lt;class OutputIterator, class Size, class T&gt;
  <del>void</del><ins>OutputIterator</ins> fill_n(OutputIterator first, Size n, const T&amp; value);
</pre></blockquote>

<p>
Just after the effects clause add a new returns clause saying:
</p>

<blockquote>
<ins><i>Returns:</i> For <tt>fill_n</tt> and positive <tt>n</tt>, returns <tt>first + n</tt>. Otherwise
returns <tt>first</tt> for <tt>fill_n</tt>.</ins>
</blockquote>
</li>

<li>
<p>
Replace the current declaration of <tt>generate_n</tt> in 25 [algorithms]/2,
header <tt>&lt;algorithm&gt;</tt> synopsis and in 25.3.7 [alg.generate] by
</p>

<blockquote><pre>template&lt;class OutputIterator, class Size, class Generator&gt;
  <del>void</del><ins>OutputIterator</ins> generate_n(OutputIterator first, Size n, Generator gen);
</pre></blockquote>

<p>
Just after the effects clause add a new returns clause saying:
</p>

<blockquote>
<ins>For <tt>generate_n</tt> and positive <tt>n</tt>, returns <tt>first + n</tt>. Otherwise
returns <tt>first</tt> for <tt>generate_n</tt>.</ins>
</blockquote>
</li>
</ol>







<hr>
<h3><a name="868"></a>868. default construction and value-initialization</h3>
<p><b>Section:</b> 23 [containers] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Alberto Ganesh Barbati <b>Opened:</b> 2008-07-22  <b>Last modified:</b> 2009-10-20</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#containers">active issues</a> in [containers].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#containers">issues</a> in [containers].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The term "default constructed" is often used in wording that predates
the introduction of the concept of value-initialization. In a few such
places the concept of value-initialization is more correct than the
current wording (for example when the type involved can be a built-in)
so a replacement is in order. Two of such places are already covered by
issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#867">867</a>. This issue deliberately addresses the hopefully
non-controversial changes in the attempt of being approved more quickly.
A few other occurrences (for example in <tt>std::tuple</tt>,
<tt>std::reverse_iterator</tt> and <tt>std::move_iterator</tt>) are left to separate
issues. For <tt>std::reverse_iterator</tt>, see also issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#408">408</a>. This issue is
related with issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#724">724</a>.
</p>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
<p>
The list provided in the proposed resolution is not complete. James
Dennett will review the library and provide a complete list and will
double-check the vocabulary.
</p>
<p>
This issue relates to Issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#886">886</a> tuple construction
</p>
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
The proposed resolution is incomplete.
</p>
<p>
Move to Tentatively NAD Future. Howard will contact Ganesh for wording.
If wording is forthcoming, Howard will move it back to Review.
</p>
</blockquote>

<p><i>[
2009-07-18 Ganesh updated the proposed wording.
]</i></p>


<blockquote>
<p>
Howard:  Moved back to Review.  Note that 20.2.1 [utility.arg.requirements]
refers to a section that is not in the current working paper, but does refer to
a section that we expect to reappear after the de-concepts merge.  This was a
point of confusion we did not recognize when we reviewed this issue in Frankfurt.
</p>
<p>
Howard:  Ganesh also includes a survey of places in the WP surveyed for changes
of this nature and purposefully <em>not</em> treated:
</p>

<blockquote>
<p>
Places where changes are <u>not</u> being
proposed
</p>
<p>
In the following paragraphs, we are not proposing changes because
it's not clear whether we actually prefer value-initialization over
default-initialization (now partially covered by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1012">1012</a>):
</p>
<ul>
    <li><p>20.8.14.2.1 [unique.ptr.single.ctor] para 3 e 7</p></li>
    <li><p>24.5.1.3.1 [reverse.iter.cons] para 1</p></li>
    <li><p>24.5.3.3.1 [move.iter.op.const] para 1</p></li>
</ul>
<p>In the following paragraphs, the expression "default
constructed" need not be changed, because the relevant type does
not depend on a template parameter and has a user-provided
constructor:</p>
<ul>
    <li><p> [func.referenceclosure.invoke] para 12, type:
    reference_closure</p></li>
    <li><p>30.3.1.2 [thread.thread.constr] para 30, type: thread</p></li>
    <li><p>30.3.1.5 [thread.thread.member] para 52, type: thread_id</p></li>
    <li><p>30.3.2 [thread.thread.this], para 1, type: thread_id</p></li>
</ul>
</blockquote>

</blockquote>

<p><i>[
2009-08-18 Daniel adds:
]</i></p>


<blockquote>
<p>
I have no objections against the currently suggested changes, but I
also cross-checked
with the list regarding intentionally excluded changes, and from this
I miss the discussion
of
</p>

<ol>
<li>
<p>
21.4.1 [string.require]/2:
</p>

<blockquote>
"[..] The <tt>Allocator</tt> object used shall be a copy of the <tt>Allocator&gt;</tt>
object passed to the <tt>basic_string</tt> object's
constructor or, if the constructor does not take an <tt>Allocator</tt>
argument, a copy of a default-constructed
<tt>Allocator</tt> object."
</blockquote>
</li>

<li>
<p>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2723.pdf">N2723</a>,
X [rand.req.eng], Table 109, expression "<tt>T()</tt>":
</p>
<blockquote>
Pre-/post-condition: "Creates an engine with the same initial state as
all other default-constructed engines of type <tt>X</tt>."
</blockquote>

<p>
as well as in 26.5.5 [rand.predef]/1-9 (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2914.pdf">N2914</a>), 26.5.7.1 [rand.util.seedseq]/3, 27.7.1.1.1 [istream.cons]/3, 27.7.2.2 [ostream.cons]/9 (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2914.pdf">N2914</a>), 28.13 [re.grammar]/2, 30.3.1.4 [thread.thread.assign]/1 (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2914.pdf">N2914</a>),
</p>
<p><i>[
Candidates for the "the expression "default constructed" need not be
changed" list
]</i></p>


<p>
I'm fine, if these would be added to the intentionally exclusion list,
but mentioning them makes it
easier for other potential reviewers to decide on the relevance or
not-relevance of them for this issue.
</p>
</li>

<li>
<p>
I suggest to remove the reference of  [func.referenceclosure.invoke]
in the "it's not clear" list, because
this component does no longer exist.
</p>
</li>

<li>
<p>
I also suggest to add a short comment that all paragraphs in the
resolution whether they refer to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2723.pdf">N2723</a> or to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2914.pdf">N2914</a> numbering, because e.g. "Change 23.3.2.1 [deque.cons] para 5" is an <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2723.pdf">N2723</a> coordinate, while "Change 23.3.2.2 [deque.capacity] para 1" is an <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2914.pdf">N2914</a> coordinate. Even better would be to use one default document
for the numbering (probably <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2914.pdf">N2914</a>) and mention special cases (e.g. "Change 20.2.1 [utility.arg.requirements] para 2" as referring to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2723.pdf">N2723</a> numbering).
</p>
</li>
</ol>

</blockquote>

<p><i>[
2009-08-18 Alisdair adds:
]</i></p>


<blockquote>
<p>
I strongly believe the term "default constructed" should not appear in
the library clauses unless we very clearly define a meaning for it, and
I am not sure what that would be.
</p>

<p>
In those cases where we do not want to replace "default constructed"
with "vale initialized" we should be using "default initialized".  If we
have a term that could mean either, we reduce portability of programs.
</p>

<p>
I have not done an exhaustive review to clarify if that is a vendor
freedom we have reason to support (e.g. value-init in debug,
default-init in release) so I may yet be convinced that LWG has reason
to define this new term of art, but generally C++ initialization is
confusing enough without supporting further ill-defined terms.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Move to Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 20.2.1 [utility.arg.requirements] para 2:
</p>

<blockquote>
In general, a default constructor is
not required. Certain container class member function signatures
specify <del>the default constructor</del><ins>T()</ins>
as a default argument. T() shall be a well-defined expression (8.5)
if one of those signatures is called using the default argument
(8.3.6).
</blockquote>

<p>
Change 23.3.2.1 [deque.cons] para 5:
</p>

<blockquote>
<i>Effects:</i> Constructs a deque with n
<del>default constructed</del><ins>value-initialized</ins>
elements. 
</blockquote>

<p>
Change 23.3.2.2 [deque.capacity] para 1:
</p>

<blockquote>
<i>Effects:</i> If sz &lt; size(), equivalent
to erase(begin() + sz, end());. If size() &lt; sz, appends sz -
size() <del>default
constructed</del><ins>value-initialized</ins>
elements to the sequence.
</blockquote>

<p>
Change 23.3.3.1 [forwardlist.cons] para 5:
</p>

<blockquote>
<i>Effects:</i> Constructs a forward_list object with n <del>default
constructed</del><ins>value-initialized</ins>
elements.
</blockquote>

<p>
Change 23.3.3.4 [forwardlist.modifiers] para 21:
</p>

<blockquote>
<i>Effects:</i> [...] For the first signature
the inserted elements are <del>default
constructed</del><ins>value-initialized</ins>,
and for the second signature they are copies of c.
</blockquote>

<p>
Change 23.3.4.1 [list.cons] para 5:
</p>

<blockquote>
<i>Effects:</i> Constructs a list with n <del>default
constructed</del><ins>value-initialized</ins>
elements. 
</blockquote>

<p>
Change 23.3.4.2 [list.capacity] para 15:
</p>

<blockquote>
<i>Effects:</i> If sz &lt; size(), equivalent
to list&lt;T&gt;::iterator it = begin(); advance(it, sz); erase(it,
end());. If size() &lt; sz, appends sz - size() <del>default
constructed</del><ins>value-initialized</ins>
elements to the sequence.
</blockquote>

<p>
Change 23.3.6.1 [vector.cons] para 3:
</p>

<blockquote>
<i>Effects:</i> Constructs a vector with n
<del>default constructed</del><ins>value-initialized</ins>
elements. 
</blockquote>

<p>
Change 23.3.6.2 [vector.capacity] para 24:
</p>

<blockquote>
<i>Effects:</i> If sz &lt; size(), equivalent
to erase(begin() + sz, end());. If size() &lt; sz, appends sz -
size() <del>default
constructed</del><ins>value-initialized</ins>
elements to the sequence.
</blockquote>






<hr>
<h3><a name="870"></a>870. Do unordered containers not support function pointers for predicate/hasher?</h3>
<p><b>Section:</b> 23.2.5 [unord.req] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2008-08-17  <b>Last modified:</b> 2009-10-20</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#unord.req">active issues</a> in [unord.req].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#unord.req">issues</a> in [unord.req].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Good ol' associative containers allow both function pointers and
function objects as feasible
comparators, as described in 23.2.4 [associative.reqmts]/2:
</p>

<blockquote>
Each associative container is parameterized on <tt>Key</tt> and an ordering
relation <tt>Compare</tt> that
induces a strict weak ordering (25.3) on elements of Key. [..]. The
object of type <tt>Compare</tt> is
called the comparison object of a container. This comparison object
may be a pointer to
function or an object of a type with an appropriate function call operator.[..]
</blockquote>

<p>
The corresponding wording for unordered containers is not so clear,
but I read it to disallow
function pointers for the hasher and I miss a clear statement for the
equality predicate, see
23.2.5 [unord.req]/3+4+5:
</p>

<blockquote>
<p>
Each unordered associative container is parameterized by <tt>Key</tt>, by a
function object <tt>Hash</tt> that
acts as a hash function for values of type <tt>Key</tt>, and by a binary
predicate <tt>Pred</tt> that induces an
equivalence relation on values of type <tt>Key</tt>.[..]
</p>
<p>
A hash function is a function object that takes a single argument of
type <tt>Key</tt> and returns a
value of type <tt>std::size_t</tt>.
</p>
<p>
Two values <tt>k1</tt> and <tt>k2</tt> of type <tt>Key</tt> are considered equal if the
container's equality function object
returns <tt>true</tt> when passed those values.[..]
</p>
</blockquote>

<p>
and table 97 says in the column "assertion...post-condition" for the
expression X::hasher:
</p>

<blockquote>
<tt>Hash</tt> shall be a unary function object type such that the expression
<tt>hf(k)</tt> has type <tt>std::size_t</tt>.
</blockquote>

<p>
Note that 20.7 [function.objects]/1 defines as "Function objects are
objects with an <tt>operator()</tt> defined.[..]"
</p>
<p>
Does this restriction exist by design or is it an oversight? If an
oversight, I suggest that to apply
the following
</p>

<p><i>[
2009-07-28 Reopened by Alisdair.  No longer solved by concepts.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Ask Daniel to provide proposed wording that: makes it explicit that
function pointers are function objects at the beginning of 20.7 [function.objects]; fixes the "requirements" for typedefs in
20.7.5 [refwrap] to instead state that the function objects
defined in that clause have these typedefs, but not that these typedefs
are requirements on function objects; remove the wording that explicitly
calls out that associative container comparators may be function
pointers.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
In 23.2.5 [unord.req]/3, just after the second sentence which is written as
</p>

<blockquote>
Additionally, <tt>unordered_map</tt> and <tt>unordered_multimap</tt> associate an
arbitrary mapped type <tt>T</tt> with the <tt>Key</tt>.
</blockquote>

<p>
add one further sentence:
</p>

<blockquote>
Both <tt>Hash</tt> and <tt>Pred</tt> may be pointers to function or objects of a type
with an appropriate function call operator.
</blockquote>

<p>
[Note1: Since the detailed requirements for <tt>Pred</tt> and <tt>Hash</tt> are given in
p.4 and p.5, it an alternative resolution
would be to insert a new paragraph just after p.5, which contains the
above proposed sentence]
</p>
<p>
[Note2: I do not propose a change of above quoted element in table 97,
because the mis-usage of the
notion of "function object" seems already present in the standard at
several places, even if it includes
function pointers, see e.g. 25 [algorithms]/7. The important point is
that in those places a statement is
given that the actually used symbol, like "Predicate" applies for
function pointers as well]
</p>


<p><b>Rationale:</b></p>
<p><i>[
San Francisco:
]</i></p>


<blockquote>
This is fixed by
<a href="" ref="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2776.pdf">N2776</a>.
</blockquote>






<hr>
<h3><a name="871"></a>871. Iota's requirements on T are too strong</h3>
<p><b>Section:</b> 26.7.5 [numeric.iota] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2008-08-20  <b>Last modified:</b> 2009-10-22</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
According to the recent WP
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2691.pdf">N2691</a>,
26.7.5 [numeric.iota]/1, the requires clause
of <tt>std::iota</tt> says:
</p>

<blockquote>
<tt>T</tt> shall meet the requirements of <tt>CopyConstructible</tt> and <tt>Assignable</tt> types, and
shall be convertible to <tt>ForwardIterator</tt>'s value type.[..]
</blockquote>

<p>
Neither <tt>CopyConstructible</tt> nor <tt>Assignable</tt> is needed, instead <tt>MoveConstructible</tt>
seems to be the correct choice. I guess the current wording resulted as an
artifact from comparing it with similar numerical algorithms like <tt>accumulate</tt>.
</p>

<p>
Note: If this function will be conceptualized, the here proposed
<tt>MoveConstructible</tt>
requirement can be removed, because this is an implied requirement of
function arguments, see
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2710.pdf">N2710</a>/[temp.req.impl]/3, last bullet.
</p>

<p><i>[
post San Francisco:
]</i></p>


<blockquote>
Issue pulled by author prior to review.
</blockquote>

<p><i>[
2009-07-30 Daniel reopened:
]</i></p>


<blockquote>
with the absence of concepts, this issue (closed) is valid again and I
suggest to reopen it.
I also revised by proposed resolution based on N2723 wording:
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Change 'convertible' to 'assignable', Move To Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change the first sentence of 26.7.5 [numeric.iota]/1:
</p>

<blockquote>
<i>Requires:</i> <tt>T</tt> shall <del>meet the requirements of <tt>CopyConstructible</tt> and
<tt>Assignable</tt> types, and shall</del> be
assignable to <tt>ForwardIterator</tt>'s value type. [..]
</blockquote>








<hr>
<h3><a name="872"></a>872. <tt>move_iterator::operator[]</tt> has wrong return type</h3>
<p><b>Section:</b> 24.5.3.3.12 [move.iter.op.index] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Doug Gregor <b>Opened:</b> 2008-08-21  <b>Last modified:</b> 2009-10-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>move_iterator</tt>'s <tt>operator[]</tt> is declared as:
</p>

<blockquote><pre>reference operator[](difference_type n) const;
</pre></blockquote>

<p>
This has the same problem that <tt>reverse_iterator</tt>'s <tt>operator[]</tt> used to
have: if the underlying iterator's <tt>operator[]</tt> returns a proxy, the
implicit conversion to <tt>value_type&amp;&amp;</tt> could end up referencing a temporary
that has already been destroyed. This is essentially the same issue that
we dealt with for <tt>reverse_iterator</tt> in DR <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#386">386</a>.
</p>

<p><i>[
2009-07-28 Reopened by Alisdair.  No longer solved by concepts.
]</i></p>


<p><i>[
2009-08-15 Howard adds:
]</i></p>


<blockquote>
I recommend closing this as  a duplicate of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1051">1051</a> which addresses
this issue for both <tt>move_iterator</tt> and <tt>reverse_iterator</tt>.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Move to Ready. Note that if <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1051">1051</a> is reopened, it may yield a
better resolution, but <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1051">1051</a> is currently marked NAD.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
In 24.5.3.1 [move.iterator] and 24.5.3.3.12 [move.iter.op.index], change the declaration of
<tt>move_iterator</tt>'s <tt>operator[]</tt> to:
</p>

<blockquote><pre><del>reference</del> <ins><i>unspecified</i></ins> operator[](difference_type n) const;
</pre></blockquote>



<p><b>Rationale:</b></p>
<p><i>[
San Francisco:
]</i></p>


<blockquote>
NAD Editorial, see
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2777.pdf">N2777</a>.
</blockquote>




<hr>
<h3><a name="885"></a>885. pair assignment</h3>
<p><b>Section:</b> 20.3.4 [pairs] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2008-09-15  <b>Last modified:</b> 2009-07-17</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#pairs">active issues</a> in [pairs].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#pairs">issues</a> in [pairs].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<blockquote><pre>20.2.3 pairs
Missing assignemnt operator:
template&lt;class U , class V&gt;
  requires CopyAssignable&lt;T1, U&gt; &amp;&amp; CopyAssignable&lt;T2, V&gt;
    pair&amp; operator=(pair&lt;U , V&gt; const &amp; p );
</pre></blockquote>

<p>
Well, that's interesting. This assignment operator isn't in the
current working paper, either. Perhaps we deemed it acceptable to
build a temporary of type <tt>pair</tt> from <tt>pair&lt;U, V&gt;</tt>, then move-assign
from that temporary?
</p>
<p>
It sounds more like an issue waiting to be opened, unless you want to plug
it now.  As written we risk moving from lvalues.
</p>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
<p>
Would be NAD if better ctors fixed it.
</p>
<p>
Related to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#811">811</a>.
</p>
</blockquote>

<p><i>[
post San Francisco:
]</i></p>


<blockquote>
Possibly NAD Editorial, solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2770.pdf">N2770</a>.
</blockquote>

<p><i>[
2009-05-25 Alisdair adds:
]</i></p>


<blockquote>
Issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#885">885</a> was something I reported while reviewing the library concepts
documents ahead of San Francisco.  The missing operator was added as part of
the paper adopted at that meeting
(<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2770.pdf">N2770</a>)
and I can confirm this operator is
present in the current working paper.  I recommend NAD.
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
We agree with the intent, but we need to wait for the dust to settle on concepts.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="887"></a>887. issue with condition::wait_...</h3>
<p><b>Section:</b> 30.5.1 [thread.condition.condvar] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Lawrence Crowl <b>Opened:</b> 2008-09-15  <b>Last modified:</b> 2009-10-26</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#thread.condition.condvar">active issues</a> in [thread.condition.condvar].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.condition.condvar">issues</a> in [thread.condition.condvar].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The Posix/C++ working group has identified an inconsistency between
Posix and the C++ working draft in that Posix requires the clock to be
identified at creation, whereas C++ permits identifying the clock at the
call to wait.  The latter cannot be implemented with the former.
</p>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
<p>
Howard recommends NAD with the following explanation:
</p>

<p>
The intent of the current wording is for the <tt>condtion_variable::wait_until</tt>
be able to handle user-defined clocks as well as clocks the system knows about.
This can be done by providing overloads for the known clocks, and another
overload for unknown clocks which synchs to a known clock before waiting.
For example:
</p>

<blockquote><pre>template &lt;class Duration&gt;
bool
condition_variable::wait_until(unique_lock&lt;mutex&gt;&amp; lock,
                               const chrono::time_point&lt;chrono::system_clock, Duration&gt;&amp; abs_time)
{
    using namespace chrono;
    nanoseconds d = __round_up&lt;nanoseconds&gt;(abs_time.time_since_epoch());
    __do_timed_wait(lock.mutex()-&gt;native_handle(), time_point&lt;system_clock, nanoseconds&gt;(d));
    return system_clock::now() &lt; abs_time;
}

template &lt;class Clock, class Duration&gt;
bool
condition_variable::wait_until(unique_lock&lt;mutex&gt;&amp; lock,
                               const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time)
{
    using namespace chrono;
    system_clock::time_point    s_entry = system_clock::now();
    typename Clock::time_point  c_entry = Clock::now();
    nanoseconds dn = __round_up&lt;nanoseconds&gt;(abs_time.time_since_epoch() -
                                              c_entry.time_since_epoch());
    __do_timed_wait(lock.mutex()-&gt;native_handle(), s_entry + dn);
    return Clock::now() &lt; abs_time;
}
</pre></blockquote>

<p>
In the above example, <tt>system_clock</tt> is the only clock which the underlying
condition variable knows how to deal with.  One overload just passes that clock
through.  The second overload (approximately) converts the unknown clock into
a <tt>system_clock  time_point</tt> prior to passing it down to the native
condition variable.
</p>

<p>
On Posix systems vendors are free to add implementation defined constructors which
take a clock.  That clock can be stored in the condition_variable, and converted
to (or not as necessary) as shown above.
</p>

<p>
If an implementation defined constructor takes a clock (for example), then part
of the semantics for that implementation defined ctor might include that a
<tt>wait_until</tt> using a clock other than the one constructed with results
in an error (exceptional condition) instead of a conversion to the stored clock.
Such a design is up to the vendor as once an implementation defined ctor is used,
the vendor is free to specifiy the behavior of waits and/or notifies however
he pleases (when the cv is constructed in an implementation defined manner).
</p>
</blockquote>

<p><i>[
Post Summit:
]</i></p>


<blockquote>
<p>
"POSIX people will review the proposed NAD resolution at their upcoming NY
meeting.
</p>

<p>
See the minutes at: <a href="http://wiki.dinkumware.com/twiki/bin/view/Posix/POSIX-CppBindingWorkingGroupNewYork2009">http://wiki.dinkumware.com/twiki/bin/view/Posix/POSIX-CppBindingWorkingGroupNewYork2009</a>.
</p>
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
Move to NAD.
</blockquote>

<p><i>[
2009-07-18 Detlef reopens the issue:
]</i></p>


<blockquote>
<p>
On Friday afternoon in Frankfurt is was decided that 887 is NAD.
This decision was mainly based on a sample implementation presented
by Howard that implemented one clock on top of another.
Unfortunately this implementation doesn't work for the probably most
important case where a system has a monotonic clock and a real-time
clock (or "wall time" clock):
</p>
<p>
If the underlying "system_clock" is a monotonic clock, and
the program waits on the real-time clock, and the real-time clock
is set forward, the wait will unblock too late.
</p>

<p>
If the underlying "system_clock" is a real-time clock, and the
program waits on the monotonic clock, and the real-time clock
is set back, the wait again will unblock too late.
</p>

<p>
Sorry that I didn't remember this on Friday, but it was Friday
afternoon after a busy week...
</p>

<p>
So as the decision was made on a wrong asumption, I propose to re-open
the issue.
</p>
</blockquote>

<p><i>[
2009-07-26 Howard adds:
]</i></p>


<blockquote>
<p>
Detlef correctly argues that <tt>condition_variable::wait_until</tt> could
return "too late" in the context of clocks being adjusted during the wait.  I agree
with his logic.  But I disagree that this makes this interface unimplementable
on POSIX.
</p>

<p>
The POSIX spec also does not guarantee that <tt>pthread_cond_timedwait</tt> does
not return "too late" when clocks are readjusted during the wait.  Indeed, the
POSIX specification lacks any requirements at all concerning how soon
<tt>pthread_cond_timedwait</tt> returns after a time out.  This is evidently a
QOI issue by the POSIX standard.  Here is a quote of the most relevant normative
text concerning <tt>pthread_cond_timedwait</tt> found
<a href="http://www.unix.org/single_unix_specification/">here</a>.
</p>

<blockquote>
The <tt>pthread_cond_timedwait()</tt> function shall be equivalent to
<tt>pthread_cond_wait()</tt>, except that an error is returned if the absolute
time specified by <tt>abstime</tt> passes (that is, system time equals or exceeds
<tt>abstime</tt>) before the condition <tt>cond</tt> is signaled or broadcasted, or if the
absolute time specified by <tt>abstime</tt> has already been passed at the time
of the call.
</blockquote>

<p>
I.e. the POSIX specification speaks of the error code returned in case of a time
out, but not on the timeliness of that return.
</p>

<p>
Might this simply be an oversight, or minor defect in the POSIX specification?
</p>

<p>
I do not believe so.  This same section goes on to say in <em>non-normative</em>
text:
</p>

<blockquote>
For cases when the system clock is advanced discontinuously by an
operator, it is expected that implementations process any timed wait
expiring at an intervening time as if that time had actually occurred.
</blockquote>

<p>
Here is non-normative wording encouraging the implementation to ignore an advancing
underlying clock and subsequently causing an early (spurious) return.  There is
no wording at all which addresses Detlef's example of a "late return".  With
<tt>pthread_cond_timedwait</tt> this would be caused by setting the system clock
backwards.  It seems reasonable to assume, based on the wording that is already
in the POSIX spec, that again, the discontinuously changed clock would be ignored
by <tt>pthread_cond_timedwait</tt>. 
</p>

<p>
A noteworthy difference between <tt>pthread_cond_timedwait</tt> and
<tt>condition_variable::wait_until</tt> is that the POSIX spec appears to
say that <tt>ETIMEDOUT</tt> should be returned if <tt>pthread_cond_timedwait</tt>
returns because of timeout signal, whether or not the system clock was discontinuously
advanced during the wait.  In contrast <tt>condition_variable::wait_until</tt>
always returns:
</p>

<blockquote><pre><tt>Clock::now() &lt; abs_time</tt>
</pre></blockquote>

<p>
That is, the C++ spec requires that the clock be rechecked (detecting discontinuous
adjustments during the wait) at the time of return.  <tt>condition_variable::wait_until</tt>
may indeed return early or late.  But regardless it will return a value
reflecting timeout status at the time of return (even if clocks have been adjusted).
Of course the clock may be adjusted after the return value is computed but before the client has
a chance to read the result of the return.  Thus there are no iron-clad guarantees
here.
</p>

<p>
<tt>condition_variable::wait_until</tt> (and <tt>pthread_cond_timedwait</tt>)
is little more than a convenience function for making sure
<tt>condition_variable::wait</tt> doesn't hang for an unreasonable amount of
time (where the client gets to define "unreasonable").  I do not think it
is in anyone's interest to try to make it into anything more than that.
</p>

<p>
I maintain that this is a useful and flexible specification in the spirit of
C++, and is implementable on POSIX.  The implementation technique described above
is a reasonable approach.  There may also be higher quality approaches.  This
specification, like the POSIX specification, gives a wide latitude for QOI.
</p>

<p>
I continue to recommend NAD, but would not object to a clarifying note regarding
the behavior of <tt>condition_variable::wait_until</tt>.  At the moment, I do
not have good wording for such a note, but welcome suggestions.
</p>

</blockquote>

<p><i>[
2009-09-30: See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2969.html">N2969</a>.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
The LWG is in favor of Detlef to supply revision which adopts Option 2 from
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2969.html">N2969</a>
but is modified by saying that <tt>system_clock</tt> must be available for <tt>wait_until</tt>.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="889"></a>889. thread::id comparisons</h3>
<p><b>Section:</b> 30.3.1.1 [thread.thread.id] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Lawrence Crowl <b>Opened:</b> 2008-09-15  <b>Last modified:</b> 2009-10-22</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.thread.id">issues</a> in [thread.thread.id].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 324</b></p>

<p>
The <tt>thread::id</tt> type supports the full set of comparison operators.  This
is substantially more than is required for the associative containers that
justified them.  Please place an issue against the threads library.
</p>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
<p>
Would depend on proposed extension to POSIX, or non-standard extension.
What about hash? POSIX discussing op. POSIX not known to be considering
support needed for hash, op.
</p>
<p>
Group expresses support for putting ids in both unordered and ordered containers.
</p>
</blockquote>

<p><i>[
post San Francisco:
]</i></p>


<blockquote>
<p>
Howard:  It turns out the current working paper
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2723.pdf">N2723</a>
<i>already has</i> <tt>hash&lt;thread::id&gt;</tt>
(20.7 [function.objects], 20.7.16 [unord.hash]).  We simply
overlooked it in the meeting.  It is a good thing we voted in favor of it
(again). :-)
</p>
<p>
Recommend NAD.
</p>

</blockquote>

<p><i>[
Post Summit:
]</i></p>


<blockquote>
Recommend to close as NAD. For POSIX, see if we need to add a function to
convert <tt>pthread_t</tt> to integer.
</blockquote>

<p><i>[
Post Summit, Alisdair adds:
]</i></p>


<blockquote>
<p>
The recommendation for LWG-889/UK-324 is NAD, already specified.
</p>
<p>
It is not clear to me that the specification is complete.
</p>
<p>
In particular, the synopsis of <tt>&lt;functional&gt;</tt> in 20.7 [function.objects] does not mention <tt>hash&lt; thread::id
&gt;</tt> nor <tt>hash&lt; error_code &gt;</tt>, although their
existence is implied by 20.7.16 [unord.hash], p1.
</p>
<p>
I am fairly uncomfortable putting the declaration for the
<tt>thread_id</tt> specialization into <tt>&lt;functional&gt;</tt> as
<tt>id</tt> is a nested class inside <tt>std::thread</tt>, so it implies
that <tt>&lt;functional&gt;</tt> would require the definition of the
<tt>thread</tt> class template in order to forward declared
<tt>thread::id</tt> and form this specialization.
</p>
<p>
It seems better to me that the dependency goes the other way around
(<tt>&lt;thread&gt;</tt> will more typically make use of
<tt>&lt;functional&gt;</tt> than vice-versa) and the
<tt>hash&lt;thread::id&gt;</tt> specialization be declared in the
<tt>&lt;thread&gt;</tt> header.
</p>
<p>
I think <tt>hash&lt;error_code&gt;</tt> could go into either
<tt>&lt;system_error&gt;</tt> or <tt>&lt;functional&gt;</tt> and have no
immediate preference either way.  However, it should clearly appear in
the synopsis of one of these two.
</p>
<p>
Recommend moving 889 back to open, and tying in a reference to UK-324.
</p>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Howard observes that <tt>thread::id</tt> need not be a nested class;
it could be a <tt>typedef</tt> for a more visible type.
</blockquote>

<p><i>[
2009-05-24 Alisdair adds:
]</i></p>

<blockquote>
I do not believe this is correct.  <tt>thread::id</tt> is explicitly documents as a
nested class, rather than as an unspecified typedef analogous to an
iterator.  If the intent is that this is not implemented as a nested class
(under the as-if freedoms) then this is a novel form of standardese.
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
Decided we want to move hash specialization for thread_id to the thread
header. Alisdair to provide wording.
</blockquote>

<p><i>[
2009-07-28 Alisdair provided wording, moved to Review.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Add a strike for <tt>hash&lt;thread::id&gt;</tt>. Move to Ready
</blockquote>



<p><b>Proposed resolution:</b></p>

<p>
Remove the following prototype from the synopsis in
20.7 [function.objects]:
</p>

<blockquote><pre><del>
template &lt;&gt; struct hash&lt;std::thread::id&gt;;
</del></pre></blockquote>

<p>
Add to 30.3 [thread.threads], p1 Header <tt>&lt;thread&gt;</tt> synopsis:
</p>

<blockquote><pre><ins>template &lt;class T&gt; struct hash;
template &lt;&gt; struct hash&lt;thread::id&gt;;</ins>
</pre></blockquote>

<p>
Add template specialization below class definition in 30.3.1.1 [thread.thread.id]
</p>

<blockquote><pre><ins>template &lt;&gt;
struct hash&lt;thread::id&gt; : public unary_function&lt;thread::id, size_t&gt; {
   size_t operator()(thread::id val) const;
};</ins>
</pre></blockquote>

<p>
Extend note in p2 30.3.1.1 [thread.thread.id] with second sentence:
</p>

<blockquote>
[<i>Note:</i> Relational operators allow <tt>thread::id</tt> objects to be used
as keys in associative containers.
<ins><tt>hash</tt> template specialization allow <tt>thread::id</tt> objects to be used as keys
in unordered containers.</ins>
&#8212; <i>end note</i>]
</blockquote>

<p>
Add new paragraph to end of 30.3.1.1 [thread.thread.id]
</p>

<blockquote><pre><ins>template &lt;&gt; struct hash&lt;thread::id&gt;;</ins>
</pre>
<blockquote><ins>
An explicit specializations of the class template hash (20.7.16 [unord.hash])
shall be provided for the values of type <tt>thread::id</tt>
suitable for use as keys in unordered associative containers (23.5 [unord]).
</ins></blockquote>
</blockquote>





<hr>
<h3><a name="891"></a>891. std::thread, std::call_once issue</h3>
<p><b>Section:</b> 30.3.1.2 [thread.thread.constr], 30.4.5.2 [thread.once.callonce] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Peter Dimov <b>Opened:</b> 2008-09-15  <b>Last modified:</b> 2009-10-24</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#thread.thread.constr">active issues</a> in [thread.thread.constr].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.thread.constr">issues</a> in [thread.thread.constr].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I notice that the vararg overloads of <tt>std::thread</tt> and <tt>std::call_once</tt>
(N2723 30.3.1.2 [thread.thread.constr] and 30.4.5.2 [thread.once.callonce]) are no longer specified in terms of
<tt>std::bind</tt>; instead, some of the <tt>std::bind</tt> wording has been inlined into
the specification.
</p>
<p>
There are two problems with this.
</p>
<p>
First, the specification (and implementation) in terms of <tt>std::bind</tt> allows, for example:
</p>

<blockquote><pre>std::thread th( f, 1, std::bind( g ) );
</pre></blockquote>

<p>
which executes <tt>f( 1, g() )</tt> in a thread. This can be useful. The
"inlined" formulation changes it to execute <tt>f( 1, bind(g) )</tt> in a thread.
</p>
<p>
Second, assuming that we don't want the above, the specification has copied the wording
</p>

<blockquote>
<tt>INVOKE(func, w1, w2, ..., wN)</tt> (20.6.2) shall be a valid
expression for some values <tt>w1, w2, ..., wN</tt>
</blockquote>

<p>
but this is not needed since we know that our argument list is args; it should simply be
</p>

<blockquote>
<tt>INVOKE(func, args...)</tt> (20.6.2) shall be a valid expression
</blockquote>

<p><i>[
Summit:
]</i></p>


<blockquote>
Move to open.
</blockquote>

<p><i>[
Post Summit Anthony provided proposed wording.
]</i></p>


<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
Leave Open. Await decision for thread variadic constructor.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
See proposed wording for <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#929">929</a> for this, for the formulation
on how to solve this.  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#929">929</a> modifies the thread constructor to
have "pass by value" behavior with pass by reference efficiency through the use
of the <tt>decay</tt> trait.  This same formula would be useful for <tt>call_once</tt>.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change paragraph 4 of 30.3.1.2 [thread.thread.constr] to:
</p>

<blockquote>
<pre>template &lt;class F&gt; explicit thread(F f);
template &lt;class F, class ...Args&gt; thread(F&amp;&amp; f, Args&amp;&amp;... args);
</pre>
<blockquote>
-4- <i>Requires:</i> <tt>F</tt> and each <tt>Ti</tt> in <tt>Args</tt>
shall be <tt>CopyConstructible</tt> if an lvalue and otherwise
<tt>MoveConstructible</tt>. <tt><i>INVOKE</i>(f, <del>w1, w2, ..., wN</del> <ins>args...</ins>)</tt>
(20.6.2) shall be a valid expression<del> for some values <i>w1, w2, ...,
wN</i>, where <tt>N == sizeof...(Args)</tt></del>.
</blockquote>
</blockquote>

<p>
Change paragraph 1 of 30.4.5.2 [thread.once.callonce] to:
</p>

<blockquote><pre>template&lt;class Callable, class ...Args&gt; 
  void call_once(once_flag&amp; flag, Callable func, Args&amp;&amp;... args);
</pre>
<blockquote>
-1- <i>Requires:</i> The template parameters <tt>Callable&gt;</tt> and each
<tt>Ti</tt> in <tt>Args</tt> shall be <tt>CopyConstructible</tt> if an
lvalue and otherwise <tt>MoveConstructible</tt>. <tt><i>INVOKE</i>(func,
<del>w1, w2, ..., wN</del> <ins>args...</ins>)</tt> (20.6.2) shall be a
valid expression<del> for some values <i>w1, w2, ..., wN</i>, where
<tt>N == sizeof...(Args)</tt></del>.
</blockquote>
</blockquote>





<hr>
<h3><a name="893"></a>893. std::mutex issue</h3>
<p><b>Section:</b> 30.4.1.1 [thread.mutex.class] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Peter Dimov <b>Opened:</b> 2008-09-15  <b>Last modified:</b> 2009-10-22</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.mutex.class">issues</a> in [thread.mutex.class].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#905">905</a></p>
<p><b>Discussion:</b></p>
<p>
30.4.1.1 [thread.mutex.class]/27 (in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2723.pdf">N2723</a>)
says that the behavior is undefined if:
</p>
<ul>
<li>a thread that owns a <tt>mutex</tt> object calls <tt>lock()</tt> or
<tt>try_lock()</tt> on that object</li>
</ul>
<p>
I don't believe that this is right. Calling <tt>lock()</tt> or <tt>try_lock()</tt> on a
locked <tt>mutex</tt> is well defined in the general case. <tt>try_lock()</tt> is required
to fail and return <tt>false</tt>. <tt>lock()</tt> is required to either throw an
exception (and is allowed to do so if it detects deadlock) or to block
until the <tt>mutex</tt> is free. These general requirements apply regardless of
the current owner of the <tt>mutex</tt>; they should apply even if it's owned by
the current thread.
</p>
<p>
Making double <tt>lock()</tt> undefined behavior probably can be justified (even
though I'd still disagree with the justification), but <tt>try_lock()</tt> on a
locked <tt>mutex</tt> must fail.
</p>

<p><i>[
Summit:
]</i></p>

<blockquote>
<p>
Move to open. Proposed resolution:
</p>
<ul>
<li>
In 30.4.1 [thread.mutex.requirements] paragraph 12, change the error
condition for <tt>resource_deadlock_would_occur</tt> to: "if the implementation
detects that a deadlock would occur"
</li>
<li>
Strike 30.4.1.1 [thread.mutex.class] paragraph 3 bullet 2 "a thread that owns a mutex object
calls <tt>lock()</tt> or <tt>try_lock()</tt> on that object, or"
</li>
</ul>
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
Move to Review. Alisdair to provide note.
</blockquote>

<p><i>[
2009-07-31 Alisdair provided note.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Moved to Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
In 30.4.1 [thread.mutex.requirements] paragraph 12 change:
</p>

<blockquote>
<ul>
<li>...</li>
<li>
<tt>resource_deadlock_would_occur</tt> -- if the <del>current thread already owns the mutex and is able 
to detect it</del> <ins>implementation detects that a deadlock would occur</ins>.
</li>
<li>...</li>
</ul>
</blockquote>

<p>
Strike 30.4.1.1 [thread.mutex.class] paragraph 3 bullet 2:
</p>
<blockquote>
<p>
-3- The behavior of a program is undefined if:
</p>
<ul>
<li>...</li>
<li>
<del>a thread that owns a <tt>mutex</tt> object calls <tt>lock()</tt> or <tt>try_lock()</tt> on that object, or</del>
</li>
<li>...</li>
</ul>
</blockquote>

<p>
Add the following note after p3 30.4.1.1 [thread.mutex.class]
</p>

<blockquote>
[<i>Note:</i> a program may deadlock if the thread that owns a <tt>mutex</tt>
object calls <tt>lock()</tt> or <tt>try_lock()</tt> on that object. If the program can
detect the deadlock, a <tt>resource_deadlock_would_occur</tt> error condition may
be observed. &#8212; <i>end note</i>]
</blockquote>






<hr>
<h3><a name="896"></a>896. Library thread safety issue</h3>
<p><b>Section:</b> 20.8.15.2 [util.smartptr.shared] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Hans Boehm <b>Opened:</b> 2008-09-16  <b>Last modified:</b> 2009-10-25</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#util.smartptr.shared">issues</a> in [util.smartptr.shared].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It is unclear whether <tt>shared_ptr</tt> is thread-safe in the sense that
multiple threads may simultaneously copy a <tt>shared_ptr</tt>.  However this
is a critical piece of information for the client, and it has significant
impact on usability for many applications.  (Detlef Vollman thinks it
is currently clear that it is not thread-safe.  Hans Boehm thinks
it currently requires thread safety, since the <tt>use_count</tt> is not an
explicit field, and constructors and assignment take a const reference
to an existing <tt>shared_ptr</tt>.)
</p>

<p>
Pro thread-safety:
</p>
<p>
Many multi-threaded usages are impossible.  A thread-safe version can
be used to destroy an object when the last thread drops it, something
that is often required, and for which we have no other easy mechanism.
</p>
<p>
Against thread-safety:
</p>
<p>
The thread-safe version is well-known to be far more expensive, even
if used by a single thread.  Many applications, including all single-threaded
ones, do not care.
</p>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
<p>
Beman: this is a complicated issue, and would like to move this to Open
and await comment from Peter Dimov; we need very careful and complete
rationale for any decision we make; let's go slow
</p>
<p>
Detlef: I think that <tt>shared_ptr</tt> should not be thread-safe.
</p>
<p>
Hans: When you create a thread with a lambda, it in some cases makes it
very difficult for the lambda to reference anything in the heap. It's
currently ambiguous as to whether you can use a <tt>shared_ptr</tt> to get at an
object.
</p>
<p>
Leave in Open. Detlef will submit an alternative proposed resolution
that makes <tt>shared_ptr</tt> explicitly unsafe.
</p>
<p>
A third option is to support both threadsafe and non-safe share_ptrs,
and to let the programmer decide which behavior they want.
</p>

<p>
Beman:  Peter, do you support the PR?
</p>

<p>
Peter:
</p>
<blockquote>
<p>
Yes, I support the proposed resolution, and I certainly oppose any
attempts to <tt>make shared_ptr</tt> thread-unsafe.
</p>
<p>
I'd mildly prefer if
</p>
<blockquote>
[<i>Note:</i> This is true in spite of that fact that such functions often
modify <tt>use_count()</tt> <i>--end note</i>]
</blockquote>
<p>
is changed to
</p>
<blockquote>
[<i>Note:</i> This is true in spite of that fact that such functions often
cause a change in <tt>use_count()</tt> <i>--end note</i>]
</blockquote>
<p>
(or something along these lines) to emphasise that <tt>use_count()</tt> is not,
conceptually, a variable, but a return value.
</p>
</blockquote>

</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
Vote: Do we want one thread-safe shared pointer or two? If two, one
would allow concurrent construction and destruction of shared pointers,
and one would not be thread-safe. If one, then it would be thread-safe.
</p>
<p>
No concensus on that vote.
</p>
<p>
Hans to improve wording in consultation with Pete. Leave Open.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Move to Ready. Ask Editor to clear up wording a little when integrating to
make it clear that the portion after the first comma only applies for
the presence of data races.
</blockquote>

<p><i>[
2009-10-24 Hans adds:
]</i></p>


<blockquote>
<p>
I think we need to pull 896 back from ready, unfortunately.  My wording
doesn't say the right thing.
</p>

<p>
I suspect we really want to say something along the lines of:
</p>

<blockquote>
For purposes of determining the presence of a data race, member
functions access and modify only the <tt>shared_ptr</tt> and
<tt>weak_ptr</tt> objects themselves and not objects they refer to.
Changes in <tt>use_count()</tt> do not reflect modifications that can
introduce data races.
</blockquote>

<p>
But I think this needs further discussion by experts to make sure this
is right.
</p>

<p>
Detlef and I agree continue to disagree on the resolution, but I think
we agree that it would be good to try to expedite this so that it can be
in CD2, since it's likely to generate NB comments no matter what we do.
And lack of clarity of intent is probably the worst option.  I think it
would be good to look at this between meetings.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Make it explicitly thread-safe, in this weak sense, as I believe was intended:
</p>
<p>
Insert in 20.8.15.2 [util.smartptr.shared], before p5:
</p>
<blockquote>
<p>
For purposes of determining the presence of a data race,
member functions do not modify <tt>const shared_ptr</tt> and
const <tt>weak_ptr</tt> arguments, nor any objects they
refer to.  [<i>Note:</i> This is true in spite of that fact that such functions often
cause a change in <tt>use_count()</tt> <i>--end note</i>]
</p>
</blockquote>
<p>
On looking at the text, I'm not sure we need a similar disclaimer
anywhere else, since nothing else has the problem with the modified
<tt>use_count()</tt>.  I think Howard arrived at a similar conclusion.
</p>





<hr>
<h3><a name="900"></a>900. stream move-assignment</h3>
<p><b>Section:</b> 27.9.1.8 [ifstream.assign] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Niels Dekker <b>Opened:</b> 2008-09-20  <b>Last modified:</b> 2009-10-20</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It
appears that we have an issue similar to issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#675">675</a> regarding the move-assignment of
stream types. For example, when assigning to an <tt>std::ifstream</tt>,
<tt>ifstream1</tt>, it seems preferable to close the file originally held by
<tt>ifstream1</tt>:
</p>

<blockquote><pre>ifstream1 = std::move(ifstream2); 
</pre></blockquote>

<p>
The current Draft
(<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2723.pdf">N2723</a>)
specifies that the move-assignment of
stream types like <tt>ifstream</tt> has the same effect as a swap:
</p>

<blockquote>
<p>
Assign and swap 27.9.1.8 [ifstream.assign]
</p>
<pre>basic_ifstream&amp; operator=(basic_ifstream&amp;&amp; rhs); 
</pre>
<blockquote>
<i>Effects:</i> <tt>swap(rhs)</tt>.
</blockquote>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Howard agrees with the analysis and the direction proposed.
</p>
<p>
Move to Open pending specific wording to be supplied by Howard.
</p>
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
Howard is going to write wording.
</blockquote>

<p><i>[
2009-07-26 Howard provided wording.
]</i></p>


<p><i>[
2009-09-13 Niels adds:
]</i></p>


<blockquote>
Note: The proposed change of 27.9.1.3 [filebuf.assign]/1 depends on the
resolution of LWG <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1204">1204</a>, which allows implementations to assume that
<tt>*this</tt> and <tt>rhs</tt> refer to different objects.
</blockquote>

<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote>
Leave as Open.  Too closely related to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#911">911</a> to move on at this time.
</blockquote>



<p><b>Proposed resolution:</b></p>

<p>
Change 27.8.1.2 [stringbuf.assign]/1:
</p>

<blockquote><pre>basic_stringbuf&amp; operator=(basic_stringbuf&amp;&amp; rhs);
</pre>
<blockquote>
-1- <i>Effects:</i> <del><tt>swap(rhs)</tt>.</del>
<ins>After the move assignment <tt>*this</tt> reflects the same observable
state it would have if it had been move constructed from <tt>rhs</tt>
(27.8.1.1 [stringbuf.cons]).
</ins>
</blockquote>
</blockquote>

<p>
Change 27.8.2.2 [istringstream.assign]/1:
</p>

<blockquote><pre>basic_istringstream&amp; operator=(basic_istringstream&amp;&amp; rhs);
</pre>
<blockquote>
-1- <i>Effects:</i> <del><tt>swap(rhs)</tt>.</del>
<ins>Move assigns the base and members of <tt>*this</tt> with the respective
base and members of <tt>rhs</tt>.
</ins>
</blockquote>
</blockquote>

<p>
Change 27.8.3.2 [ostringstream.assign]/1:
</p>

<blockquote><pre>basic_ostringstream&amp; operator=(basic_ostringstream&amp;&amp; rhs);
</pre>
<blockquote>
-1- <i>Effects:</i> <del><tt>swap(rhs)</tt>.</del>
<ins>Move assigns the base and members of <tt>*this</tt> with the respective
base and members of <tt>rhs</tt>.
</ins>
</blockquote>
</blockquote>

<p>
Change 27.8.5.1 [stringstream.assign]/1:
</p>

<blockquote><pre>basic_stringstream&amp; operator=(basic_stringstream&amp;&amp; rhs);
</pre>
<blockquote>
-1- <i>Effects:</i> <del><tt>swap(rhs)</tt>.</del>
<ins>Move assigns the base and members of <tt>*this</tt> with the respective
base and members of <tt>rhs</tt>.
</ins>
</blockquote>
</blockquote>

<p>
Change 27.9.1.3 [filebuf.assign]/1:
</p>

<blockquote><pre>basic_filebuf&amp; operator=(basic_filebuf&amp;&amp; rhs);
</pre>
<blockquote>
-1- <i>Effects:</i> <del><tt>swap(rhs)</tt>.</del>
<ins>Begins by calling <tt>this-&gt;close()</tt>.
After the move assignment <tt>*this</tt> reflects the same observable
state it would have if it had been move constructed from <tt>rhs</tt>
(27.9.1.2 [filebuf.cons]).
</ins>
</blockquote>
</blockquote>

<p>
Change 27.9.1.8 [ifstream.assign]/1:
</p>

<blockquote><pre>basic_ifstream&amp; operator=(basic_ifstream&amp;&amp; rhs);
</pre>
<blockquote>
-1- <i>Effects:</i> <del><tt>swap(rhs)</tt>.</del>
<ins>Move assigns the base and members of <tt>*this</tt> with the respective
base and members of <tt>rhs</tt>.</ins>
</blockquote>
</blockquote>

<p>
Change 27.9.1.12 [ofstream.assign]/1:
</p>

<blockquote><pre>basic_ofstream&amp; operator=(basic_ofstream&amp;&amp; rhs);
</pre>
<blockquote>
-1- <i>Effects:</i> <del><tt>swap(rhs)</tt>.</del>
<ins>Move assigns the base and members of <tt>*this</tt> with the respective
base and members of <tt>rhs</tt>.</ins>
</blockquote>
</blockquote>

<p>
Change 27.9.1.16 [fstream.assign]/1:
</p>

<blockquote><pre>basic_fstream&amp; operator=(basic_fstream&amp;&amp; rhs);
</pre>
<blockquote>
-1- <i>Effects:</i> <del><tt>swap(rhs)</tt>.</del>
<ins>Move assigns the base and members of <tt>*this</tt> with the respective
base and members of <tt>rhs</tt>.</ins>
</blockquote>
</blockquote>






<hr>
<h3><a name="910"></a>910. Effects of MoveAssignable</h3>
<p><b>Section:</b> 20.2.1 [utility.arg.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alberto Ganesh Barbati <b>Opened:</b> 2008-09-29  <b>Last modified:</b> 2009-11-03</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#utility.arg.requirements">active issues</a> in [utility.arg.requirements].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#utility.arg.requirements">issues</a> in [utility.arg.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses UK 150</b></p>

<p>
The description of the effect of <tt>operator=</tt> in the <tt>MoveAssignable</tt>
concept, given in paragraph 7 is:
</p>

<blockquote><pre>result_type  T::operator=(T&amp;&amp;  rv);  // inherited from HasAssign&lt;T, T&amp;&amp;&gt;
</pre>

<blockquote>
<i>Postconditions:</i> the constructed <tt>T</tt> object is equivalent to the value of
<tt>rv</tt> before the assignment. [<i>Note:</i> there is no
requirement on the value of <tt>rv</tt> after the assignment.  <i>--end note</i>]
</blockquote>
</blockquote>

<p>
The sentence contains a typo (what is the "constructed <tt>T</tt> object"?)
probably due to a cut&amp;paste from <tt>MoveConstructible</tt>. Moreover, the
discussion of LWG issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#675">675</a> shows that the postcondition is too generic
and might not reflect the user expectations. An implementation of the
move assignment that just calls <tt>swap()</tt> would always fulfill the
postcondition as stated, but might have surprising side-effects in case
the source rvalue refers to an object that is not going to be
immediately destroyed. See LWG issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#900">900</a> for another example. Due to
the sometimes intangible nature of the "user expectation", it seems
difficult to have precise normative wording that could cover all cases
without introducing unnecessary restrictions. However a non-normative
clarification could be a very helpful warning sign that swapping is not
always the correct thing to do.
</p>

<p><i>[
2009-05-09 Alisdair adds:
]</i></p>


<blockquote>
<p>
Issue 910 is exactly the reason BSI advanced the Editorial comment UK-150.
</p>
<p>
The post-conditions after assignment are at a minimum that the object
referenced by rv must be safely destructible, and the transaction should not
leak resources.  Ideally it should be possible to simply assign rv a new
valid state after the call without invoking undefined behaviour, but any
other use of the referenced object would depend upon additional guarantees
made by that type.
</p>
</blockquote>

<p><i>[
2009-05-09 Howard adds:
]</i></p>


<blockquote>
<p>
The intent of the rvalue reference work is that the moved from <tt>rv</tt> is
a valid object.  Not one in a singular state.  If, for example, the moved from
object is a <tt>vector</tt>, one should be able to do anything on that moved-from
<tt>vector</tt> that you can do with any other <tt>vector</tt>.  However you would
first have to query it to find out what its current state is.  E.g. it might have <tt>capacity</tt>,
it might not.  It might have a non-zero <tt>size</tt>, it might not.  But regardless,
you can <tt>push_back</tt> on to it if you want.
</p>

<p>
That being said, most standard code is now conceptized.  That is, the concepts
list the only operations that can be done with templated types - whether or not
the values have been moved from.
</p>

<p>
Here is user-written code which must be allowed to be legal:
</p>
<blockquote><pre>#include &lt;vector&gt;
#include &lt;cstdio&gt;

template &lt;class Allocator&gt;
void
inspect(std::vector&lt;double, Allocator&gt;&amp;&amp; v)
{
    std::vector&lt;double, Allocator&gt; result(move(v));
    std::printf("moved from vector has %u size and %u capacity\n", v.size(), v.capacity());
    std::printf("The contents of the vector are:\n");
    typedef typename std::vector&lt;double, Allocator&gt;::iterator I;
    for (I i = v.begin(), e = v.end(); i != e; ++i)
        printf("%f\n", *i);
}

int main()
{
    std::vector&lt;double&gt; v1(100, 5.5);
    inspect(move(v1));
}
</pre></blockquote>

<p>
The above program does not treat the moved-from <tt>vector</tt> as singular.  It
only treats it as a <tt>vector</tt> with an unknown value.
</p>
<p>
I believe the current proposed wording is consistent with my view on this.
</p>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree that the proposed resolution
is an improvement over the current wording.
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
Need to look at again without concepts.
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
Walter will consult with Dave and Doug.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
We believe this is handled by the resolution to issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1204">1204</a>,
but there is to much going on in this area to be sure.  Defer for now.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
In  [concept.copymove], replace the postcondition in paragraph 7 with:
</p>

<blockquote>
<i>Postconditions:</i> <tt>*this</tt> is equivalent to the value of <tt>rv</tt> before the
assignment. [<i>Note:</i> there is no requirement on the value of <tt>rv</tt> after the
assignment, but the
effect should be unsurprising to the user even in case <tt>rv</tt> is not
immediately destroyed. This may require that resources previously owned
by <tt>*this</tt> are released instead of transferred to <tt>rv</tt>. <i>-- end note</i>]
</blockquote>





<hr>
<h3><a name="911"></a>911. I/O streams and <tt>move/swap</tt> semantic</h3>
<p><b>Section:</b> 27.7.1 [input.streams], 27.7.2 [output.streams] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alberto Ganesh Barbati <b>Opened:</b> 2008-09-29  <b>Last modified:</b> 2009-10-20</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Class template <tt>basic_istream</tt>, <tt>basic_ostream</tt> and <tt>basic_iostream</tt>
implements public move constructors, move assignment operators and <tt>swap</tt>
method and free functions. This might induce both the user and the
compiler to think that those types are <tt>MoveConstructible</tt>, <tt>MoveAssignable</tt>
and <tt>Swappable</tt>. However, those class templates fail to fulfill the user
expectations. For example:
</p>

<blockquote><pre>std::ostream os(std::ofstream("file.txt"));
assert(os.rdbuf() == 0); // buffer object is not moved to os, file.txt has been closed

std::vector&lt;std::ostream&gt; v;
v.push_back(std::ofstream("file.txt"));
v.reserve(100); // causes reallocation
assert(v[0].rdbuf() == 0); // file.txt has been closed!

std::ostream&amp;&amp; os1 = std::ofstream("file1.txt");
os1 = std::ofstream("file2.txt");
os1 &lt;&lt; "hello, world"; // still writes to file1.txt, not to file2.txt!

std::ostream&amp;&amp; os1 = std::ofstream("file1.txt");
std::ostream&amp;&amp; os2 = std::ofstream("file2.txt");
std::swap(os1, os2);
os1 &lt;&lt; "hello, world"; // writes to file1.txt, not to file2.txt!
</pre></blockquote>

<p>
This is because the move constructor, the move assignment operator and
<tt>swap</tt> are all implemented through calls to <tt>std::basic_ios</tt> member
functions <tt>move()</tt> and <tt>swap()</tt> that do not move nor swap the controlled
stream buffers. That can't happen because the stream buffers may have
different types.
</p>

<p>
Notice that for <tt>basic_streambuf</tt>, the member function <tt>swap()</tt> is
protected. I believe that is correct and all of <tt>basic_istream</tt>,
<tt>basic_ostream</tt>, <tt>basic_iostream</tt> should do the same as the move ctor, move
assignment operator and swap member function are needed by the derived
<tt>fstream</tt>s and <tt>stringstream</tt>s template. The free swap functions for
<tt>basic_(i|o|io)stream</tt> templates should be removed for the same reason.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We note that the rvalue swap functions have already been removed.
</p>
<p>
Bill is unsure about making the affected functions protected;
he believes they may need to be public.
</p>
<p>
We are also unsure about removing the lvalue swap functions as proposed.
</p>
<p>
Move to Open.
</p>
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
<p>
It's not clear that the use case is compelling.
</p>
<p>
Howard: This needs to be implemented and tested.
</p>
</blockquote>

<p><i>[
2009-07-26 Howard adds:
]</i></p>


<blockquote>
<p>
I started out thinking I would recommend NAD for this one.  I've turned around
to agree with the proposed resolution (which I've updated to the current draft).
I did not fully understand Ganesh's rationale, and attempt to describe my
improved understanding below.
</p>

<p>
The move constructor, move assignment operator, and swap function are different
for <tt>basic_istream</tt>, <tt>basic_ostream</tt> and <tt>basic_iostream</tt>
than other classes.  A timely conversation with Daniel reminded me of this long
forgotten fact.  These members are sufficiently different that they would be
extremely confusing to use in general, but they are very much needed for derived
clients.
</p>

<ul>
<li>
The move constructor moves everything but the <tt>rdbuf</tt> pointer.
</li>
<li>
The move assignment operator moves everything but the <tt>rdbuf</tt> pointer.
</li>
<li>
The swap function swaps everything but the <tt>rdbuf</tt> pointer.
</li>
</ul>

<p>
The reason for this behavior is that for the std-derived classes (stringstreams,
filestreams), the <tt>rdbuf</tt> pointer points back into the class itself
(self referencing).  It can't be swapped or moved.  But this fact isn't born out
at the <tt>stream</tt> level.  Rather it is born out at the <tt>fstream</tt>/<tt>sstream</tt>
level.  And the lower levels just need to deal with that fact by not messing around
with the <tt>rdbuf</tt> pointer which is stored down at the lower levels.
</p>

<p>
In a nutshell, it is very confusing for all of those who are not so intimately
related with streams that they've implemented them.  And it is even fairly
confusing for some of those who have (including myself).  I do not think it is
safe to swap or move <tt>istreams</tt> or <tt>ostreams</tt> because this will
(by necessary design) separate stream state from streambuffer state.  Derived
classes (such as <tt>fstream</tt> and <tt>stringstream</tt> must be used to
keep the stream state and stream buffer consistently packaged as one unit during
a move or swap.
</p>

<p>
I've implemented this proposal and am living with it day to day.
</p>

</blockquote>

<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote>
Leave Open.  Pablo expected to propose alternative wording which would rename
move construction, move assignment and swap, and may or may not make them
protected.  This will impact issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#900">900</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
27.7.1.1 [istream]: make the following member functions protected:
</p>

<blockquote><pre>basic_istream(basic_istream&amp;&amp;  rhs);
basic_istream&amp;  operator=(basic_istream&amp;&amp;  rhs);
void  swap(basic_istream&amp;  rhs);
</pre></blockquote>

<p>
Ditto: remove the swap free function signature
</p>

<blockquote><pre><del>// swap: 
template &lt;class charT, class traits&gt; 
  void swap(basic_istream&lt;charT, traits&gt;&amp; x, basic_istream&lt;charT, traits&gt;&amp; y);</del>
</pre></blockquote>

<p>
27.7.1.1.2 [istream.assign]: remove paragraph 4
</p>

<blockquote><pre><del>template &lt;class charT, class traits&gt; 
  void swap(basic_istream&lt;charT, traits&gt;&amp; x, basic_istream&lt;charT, traits&gt;&amp; y);</del>
</pre>
<blockquote>
<del><i>Effects:</i> <tt>x.swap(y)</tt>.</del>
</blockquote>
</blockquote>

<p>
27.7.1.5 [iostreamclass]: make the following member function protected:
</p>

<blockquote><pre>basic_iostream(basic_iostream&amp;&amp;  rhs);
basic_iostream&amp;  operator=(basic_iostream&amp;&amp;  rhs);
void  swap(basic_iostream&amp;  rhs);
</pre></blockquote>

<p>
Ditto: remove the swap free function signature
</p>

<blockquote><pre><del>template &lt;class charT, class traits&gt; 
  void swap(basic_iostream&lt;charT, traits&gt;&amp; x, basic_iostream&lt;charT, traits&gt;&amp; y);</del>
</pre></blockquote>

<p>
27.7.1.5.3 [iostream.assign]: remove paragraph 3
</p>

<blockquote><pre><del>template &lt;class charT, class traits&gt; 
  void swap(basic_iostream&lt;charT, traits&gt;&amp; x, basic_iostream&lt;charT, traits&gt;&amp; y);</del>
</pre>
<blockquote>
<del><i>Effects:</i> <tt>x.swap(y)</tt>.</del>
</blockquote>
</blockquote>

<p>
27.7.2.1 [ostream]: make the following member function protected:
</p>

<blockquote><pre>basic_ostream(basic_ostream&amp;&amp;  rhs);
basic_ostream&amp;  operator=(basic_ostream&amp;&amp;  rhs);
void  swap(basic_ostream&amp;  rhs);
</pre></blockquote>

<p>
Ditto: remove the swap free function signature
</p>

<blockquote><pre><del>// swap: 
template &lt;class charT, class traits&gt; 
  void swap(basic_ostream&lt;charT, traits&gt;&amp; x, basic_ostream&lt;charT, traits&gt;&amp; y);</del>
</pre></blockquote>

<p>
27.7.2.3 [ostream.assign]: remove paragraph 4 
</p>

<blockquote><pre><del>template &lt;class charT, class traits&gt; 
  void swap(basic_ostream&lt;charT, traits&gt;&amp; x, basic_ostream&lt;charT, traits&gt;&amp; y);</del>
</pre>
<blockquote>
<del><i>Effects:</i> <tt>x.swap(y)</tt>.</del>
</blockquote>
</blockquote>






<hr>
<h3><a name="915"></a>915. <tt>minmax</tt> with <tt>initializer_list</tt> should return
<tt>pair</tt> of <tt>T</tt>, not <tt>pair</tt> of <tt>const T&amp;</tt></h3>
<p><b>Section:</b> 25.4.7 [alg.min.max] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2008-10-04  <b>Last modified:</b> 2009-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.min.max">issues</a> in [alg.min.max].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It seems that the proposed changes for
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2772.pdf">N2772</a>
were not clear enough in
this point:
</p>

<blockquote>
25.4.7 [alg.min.max], before p.23 + p.24 + before p. 27 + p. 28 say that the return
type of the <tt>minmax</tt> overloads with an <tt>initializer_list</tt> is
<tt>pair&lt;const T&amp;, const T&amp;&gt;</tt>,
which is inconsistent with the decision for the other <tt>min/max</tt> overloads which take
a <tt>initializer_list</tt> as argument and return a <tt>T</tt>, not a <tt>const T&amp;</tt>.
Doing otherwise for <tt>minmax</tt> would easily lead to unexpected life-time
problems by using <tt>minmax</tt> instead of <tt>min</tt> and <tt>max</tt> separately.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution.
Move to Tentatively Ready.
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
Moved from Tentatively Ready to Open only because the wording needs to be
tweaked for concepts removal.
</blockquote>

<p><i>[
2009-08-18 Daniel adds:
]</i></p>


<blockquote>
Recommend NAD since the proposed changes have already been performed
as part of editorial work of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2914.pdf">N2914</a>.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Can't find initializer_list form of minmax anymore, only variadic
version. Seems like we had an editing clash with concepts. Leave Open,
at least until editorial issues resolved. Bring this to Editor's
attention.
</blockquote>



<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>
In 25 [algorithms]/2, header <tt>&lt;algorithm&gt;</tt> synopsis change as indicated:
</p>

<blockquote><pre>template&lt;<del>class</del><ins>LessThanComparable</ins> T&gt;
<ins>requires CopyConstructible&lt;T&gt;</ins>
pair&lt;<del>const </del>T<del>&amp;</del>, <del>const </del>T<del>&amp;</del>&gt;
minmax(initializer_list&lt;T&gt; t);

template&lt;class T, <del>class</del><ins>StrictWeakOrder&lt;auto, T&gt;</ins> Compare&gt;
<ins>requires CopyConstructible&lt;T&gt;</ins>
pair&lt;<del>const </del>T<del>&amp;</del>, <del>const </del>T<del>&amp;</del>&gt;
minmax(initializer_list&lt;T&gt; t, Compare comp);
</pre></blockquote>
</li>
<li>
<p>
In 25.4.7 [alg.min.max] change as indicated (Begin: Just before p.20):
</p>
<blockquote><pre>template&lt;<del>class</del><ins>LessThanComparable</ins> T&gt;
  <ins>requires CopyConstructible&lt;T&gt;</ins>
  pair&lt;<del>const </del>T<del>&amp;</del>, <del>const </del>T<del>&amp;</del>&gt;
  minmax(initializer_list&lt;T&gt; t);
</pre>
<blockquote>
<p>
<del>-20- <i>Requires:</i> <tt>T</tt> is <tt>LessThanComparable</tt> and
<tt>CopyConstructible</tt>.</del>
</p>
<p>
-21- <i>Returns:</i> <tt>pair&lt;<del>const </del>T<del>&amp;</del>, <del>const
</del>T<del>&amp;</del>&gt;(x, y)</tt> where <tt>x</tt> is the
smallest value and <tt>y</tt> the largest value in the <tt>initializer_list</tt>.
</p>
</blockquote>

<p>[..]</p>
<pre>template&lt;class T, <del>class</del><ins>StrictWeakOrder&lt;auto, T&gt;</ins> Compare&gt;
  <ins>requires CopyConstructible&lt;T&gt;</ins>
  pair&lt;<del>const </del>T<del>&amp;</del>, <del>const </del>T<del>&amp;</del>&gt;
  minmax(initializer_list&lt;T&gt; t, Compare comp);
</pre>

<blockquote>
<p>
<del>-24- <i>Requires:</i> type <tt>T</tt> is <tt>LessThanComparable</tt> and <tt>CopyConstructible</tt>.</del>
</p>
<p>
-25- <i>Returns:</i> <tt>pair&lt;<del>const </del>T<del>&amp;</del>, <del>const
</del>T<del>&amp;</del>&gt;(x, y)</tt> where <tt>x</tt> is the
smallest value and <tt>y</tt> largest value in the <tt>initializer_list</tt>.
</p>
</blockquote>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="920"></a>920. Ref-qualification support in the library</h3>
<p><b>Section:</b> 20.7.14 [func.memfn] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Bronek Kozicki <b>Opened:</b> 2008-10-06  <b>Last modified:</b> 2009-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#func.memfn">issues</a> in [func.memfn].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1230">1230</a></p>
<p><b>Discussion:</b></p>
<p>
Daniel Krgler wrote:
</p>

<blockquote>
<p>
Shouldn't above list be completed for &amp;- and &amp;&amp;-qualified
member functions This would cause to add:
</p>
<blockquote><pre>template&lt;Returnable R, class T, CopyConstructible... Args&gt;
unspecified mem_fn(R (T::* pm)(Args...) &amp;);
template&lt;Returnable R, class T, CopyConstructible... Args&gt;
unspecified mem_fn(R (T::* pm)(Args...) const &amp;);
template&lt;Returnable R, class T, CopyConstructible... Args&gt;
unspecified mem_fn(R (T::* pm)(Args...) volatile &amp;);
template&lt;Returnable R, class T, CopyConstructible... Args&gt;
unspecified mem_fn(R (T::* pm)(Args...) const volatile &amp;);
template&lt;Returnable R, class T, CopyConstructible... Args&gt;
unspecified mem_fn(R (T::* pm)(Args...) &amp;&amp;);
template&lt;Returnable R, class T, CopyConstructible... Args&gt;
unspecified mem_fn(R (T::* pm)(Args...) const &amp;&amp;);
template&lt;Returnable R, class T, CopyConstructible... Args&gt;
unspecified mem_fn(R (T::* pm)(Args...) volatile &amp;&amp;);
template&lt;Returnable R, class T, CopyConstructible... Args&gt;
unspecified mem_fn(R (T::* pm)(Args...) const volatile &amp;&amp;);
</pre></blockquote>

</blockquote>

<p>
yes, absolutely. Thanks for spotting this. Without this change <tt>mem_fn</tt>
cannot be initialized from pointer to ref-qualified member function. I
believe semantics of such function pointer is well defined.
</p>

<p><i>[
Post Summit Daniel provided wording.
]</i></p>


<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We need to think about whether we really want to go down the proposed path
of combinatorial explosion.
Perhaps a Note would suffice.
</p>
<p>
We would really like to have an implementation before proceeding.
</p>
<p>
Move to Open, and recommend this be deferred until after the next
Committee Draft has been issued.
</p>
</blockquote>

<p><i>[
2009-10-10 Daniel updated wording to post-concepts.
]</i></p>


<blockquote>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1230">1230</a> has a similar proposed resolution
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Move to Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>
Change 20.7 [function.objects]/2, header
<tt>&lt;functional&gt;</tt> synopsis as follows:
</p>

<blockquote><pre>// 20.7.14, member function adaptors:
template&lt;class R, class T&gt; <i>unspecified</i> mem_fn(R T::*);

<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::*)(Args...));</ins>
<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::*)(Args...) const);</ins>
<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::*)(Args...) volatile);</ins>
<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::*)(Args...) const volatile);</ins>

<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::*)(Args...) &amp;);</ins>
<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::*)(Args...) const &amp;);</ins>
<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::*)(Args...) volatile &amp;);</ins>
<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::*)(Args...) const volatile &amp;);</ins>

<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::*)(Args...) &amp;&amp;);</ins>
<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::*)(Args...) const &amp;&amp;);</ins>
<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::*)(Args...) volatile &amp;&amp;);</ins>
<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::*)(Args...) const volatile &amp;&amp;);</ins>
</pre></blockquote>
</li>

<li>
<p>
Change the prototype list of 20.7.14 [func.memfn] as follows [NB: The
following text, most notably p.2 and p.3 which
discuss influence of the cv-qualification on the definition of the
base class's first template parameter remains
unchanged. ]:
</p>

<blockquote><pre>template&lt;class R, class T&gt; <i>unspecified</i> mem_fn(R T::* pm);

<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::* pm)(Args...));</ins>
<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::* pm)(Args...) const);</ins>
<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::* pm)(Args...) volatile);</ins>
<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::* pm)(Args...) const volatile);</ins>

<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::* pm)(Args...) &amp;);</ins>
<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::* pm)(Args...) const &amp;);</ins>
<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::* pm)(Args...) volatile &amp;);</ins>
<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::* pm)(Args...) const volatile &amp;);</ins>

<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::* pm)(Args...) &amp;&amp;);</ins>
<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::* pm)(Args...) const &amp;&amp;);</ins>
<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::* pm)(Args...) volatile &amp;&amp;);</ins>
<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::* pm)(Args...) const volatile &amp;&amp;);</ins>
</pre></blockquote>
</li>

<li>
<p>
Remove 20.7.14 [func.memfn]/5:
</p>

<blockquote>
<del><i>Remarks:</i> Implementations may implement <tt>mem_fn</tt> as a set of
overloaded function templates.</del>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="921"></a>921. Rational Arithmetic should use template aliases</h3>
<p><b>Section:</b> 20.4.1 [ratio.ratio] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Pablo Halpern <b>Opened:</b> 2008-10-07  <b>Last modified:</b> 2009-10-21</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#ratio.ratio">issues</a> in [ratio.ratio].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The compile-time functions that operate on <tt>ratio&lt;N,D&gt;</tt> require the
cumbersome and error-prone "evaluation" of a <tt>type</tt> member using a
meta-programming style that predates the invention of template aliases.
Thus, multiplying three ratios <tt>a</tt>, <tt>b</tt>, and <tt>c</tt> requires the expression:
</p>

<blockquote><pre>ratio_multiply&lt;a, ratio_multiply&lt;b, c&gt;::type&gt;::type
</pre></blockquote>

<p>
The simpler expression:
</p>

<blockquote><pre>ratio_multiply&lt;a, ratio_multiply&lt;b, c&gt;&gt;
</pre></blockquote>

<p>
Could be used by if template aliases were employed in the definitions.
</p>

<p><i>[
Post Summit:
]</i></p>


<blockquote>
<p>
Jens: not a complete proposed resolution: "would need to make similar change"
</p>
<p>
Consensus: We agree with the direction of the issue.
</p>
<p>
Recommend Open.
</p>
</blockquote>

<p><i>[
2009-05-11 Daniel adds:
]</i></p>


<blockquote>
<p>
Personally I'm <em>not</em> in favor for the addition of:
</p>
<blockquote><pre>typedef ratio type;
</pre></blockquote>
<p>
For a reader of the
standard it's usage or purpose is unclear. I haven't seen similar examples
of attempts to satisfy non-feature complete compilers.
</p>
</blockquote>

<p><i>[
2009-05-11 Pablo adds:
]</i></p>


<blockquote>
<p>
The addition of type to the <tt>ratio</tt> template allows the previous style
(i.e., in the prototype implementations) to remain valid and permits the
use of transitional library implementations for C++03 compilers.  I do
not feel strongly about its inclusion, however, and leave it up to the
reviewers to decide.
</p>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Bill asks for additional discussion in the issue
that spells out more details of the implementation.
Howard points us to issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#948">948</a>
which has at least most of the requested details.
Tom is strongly in favor of overflow-checking at compile time.
Pete points out that there is no change of functionality implied.
We agree with the proposed resolution,
but recommend moving the issue to Review
to allow time to improve the discussion if needed.
</blockquote>

<p><i>[
2009-07-21 Alisdair adds:
]</i></p>


<blockquote>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1121">1121</a> for a potentially incompatible proposal.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Move to Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>

 
 <ol start="0">
<li>
<p>
In 20.4 [ratio]/3 change as indicated:
</p>

<blockquote><pre>// ratio arithmetic
template &lt;class R1, class R2&gt; <del>struct</del><ins>using</ins> ratio_add<ins> = <em>see below</em></ins>;
template &lt;class R1, class R2&gt; <del>struct</del><ins>using</ins> ratio_subtract<ins> = <em>see below</em></ins>;
template &lt;class R1, class R2&gt; <del>struct</del><ins>using</ins> ratio_multiply<ins> = <em>see below</em></ins>;
template &lt;class R1, class R2&gt; <del>struct</del><ins>using</ins> ratio_divide<ins> = <em>see below</em></ins>;
</pre></blockquote>
</li>
<li>
<p>
In 20.4.1 [ratio.ratio], change as indicated:
</p>
<blockquote><pre>namespace std {
  template &lt;intmax_t N, intmax_t D = 1&gt;
  class ratio {
  public:
    <ins>typedef ratio type;</ins>
    static const intmax_t num;
    static const intmax_t den;
  };
}
</pre></blockquote>
</li>
<li>
<p>
In 20.4.2 [ratio.arithmetic] change as indicated:
</p>

<blockquote><pre>template &lt;class R1, class R2&gt; <del>struct</del><ins>using</ins> ratio_add<ins> = <em>see below</em></ins><del>{
  typedef <em>see below</em> type;
}</del>;
</pre>

<blockquote>
<p>
1 The <del>nested typedef</del> type <tt><ins>ratio_add&lt;R1, R2&gt;</ins></tt>
shall be a synonym for <tt>ratio&lt;T1, T2&gt;</tt>
where <tt>T1</tt> has the value <tt>R1::num * R2::den + R2::num * R1::den</tt> and <tt>T2</tt>
has the value <tt>R1::den * R2::den</tt>.
</p>
</blockquote>
</blockquote>
<blockquote><pre>template &lt;class R1, class R2&gt; <del>struct</del><ins>using</ins> ratio_subtract<ins> = <em>see below</em></ins><del>{
  typedef <em>see below</em> type;
}</del>;
</pre>
<blockquote>
<p>
2 The <del>nested typedef</del> type <tt><ins>ratio_subtract&lt;R1, R2&gt;</ins></tt>
shall be a synonym for <tt>ratio&lt;T1, T2&gt;</tt>
where <tt>T1</tt> has the value <tt>R1::num * R2::den - R2::num * R1::den</tt> and <tt>T2</tt>
has the value <tt>R1::den * R2::den</tt>.
</p>
</blockquote>
</blockquote>
<blockquote><pre>template &lt;class R1, class R2&gt; <del>struct</del><ins>using</ins> ratio_multiply<ins> = <em>see below</em></ins><del>{
  typedef <em>see below</em> type;
}</del>;
</pre>
<blockquote>
<p>
3 The <del>nested typedef</del> type <tt><ins>ratio_multiply&lt;R1, R2&gt;</ins></tt>
shall be a synonym for <tt>ratio&lt;T1, T2&gt;</tt>
where <tt>T1</tt> has the value <tt>R1::num * R2::num</tt> and <tt>T2</tt> has the value <tt>R1::den * R2::den</tt>.
</p>
</blockquote>
</blockquote>
<blockquote><pre>template &lt;class R1, class R2&gt; <del>struct</del><ins>using</ins> ratio_divide<ins> = <em>see below</em></ins><del>{
  typedef <em>see below</em> type;
}</del>;
</pre>
<blockquote>
<p>
4 The <del>nested typedef</del> type <tt><ins>ratio_divide&lt;R1, R2&gt;</ins></tt>
shall be a synonym for <tt>ratio&lt;T1, T2&gt;</tt>
where <tt>T1</tt> has the value <tt>R1::num * R2::den</tt> and <tt>T2</tt> has the value <tt>R1::den * R2::num</tt>.
</p>
</blockquote>
</blockquote>
</li>
<li>
<p>
In 20.9.3.1 [time.duration.cons]/4 change as indicated:
</p>
<blockquote>
<p>
<i>Requires:</i> <tt>treat_as_floating_point&lt;rep&gt;::value</tt> shall be true or
<tt>ratio_divide&lt;Period2, period&gt;::<del>type::</del>den</tt> shall be 1.[..]
</p>
</blockquote>
</li>
<li>
<p>
In 20.9.3.7 [time.duration.cast]/2 change as indicated:
</p>
<blockquote>
<p>
<i>Returns:</i> Let CF be <tt>ratio_divide&lt;Period, typename
ToDuration::period&gt;<del>::type</del></tt>, and [..]
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="929"></a>929. Thread constructor</h3>
<p><b>Section:</b> 30.3.1.2 [thread.thread.constr] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Review">Review</a>
 <b>Submitter:</b> Anthony Williams <b>Opened:</b> 2008-10-23  <b>Last modified:</b> 2009-10-25</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#thread.thread.constr">active issues</a> in [thread.thread.constr].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.thread.constr">issues</a> in [thread.thread.constr].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Review">Review</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 323</b></p>

<p>
The <tt>thread</tt> constructor for starting a new thread with a function and
arguments is overly constrained by the signature requiring rvalue
references for <tt>func</tt> and <tt>args</tt> and the <tt>CopyConstructible</tt> requirements
for the elements of <tt>args</tt>. The use of an rvalue reference for the
function restricts the potential use of a plain function name, since
the type of the bound parameter will be deduced to be a function
reference and decay to pointer-to-function will not happen. This
therefore complicates the implementation in order to handle a simple
case. Furthermore, the use of rvalue references for args prevents the
array to pointer decay. Since arrays are not <tt>CopyConstructible</tt> or even
<tt>MoveConstructible</tt>, this essentially prevents the passing of arrays as
parameters. In particular it prevents the passing of string literals.
Consequently a simple case such as
</p>

<blockquote><pre>void f(const char*);
std::thread t(f,"hello");
</pre></blockquote>

<p>
is ill-formed since the type of the string literal is <tt>const char[6]</tt>.
</p>

<p>
By changing the signature to take all parameters by value we can
eliminate the <tt>CopyConstructible</tt> requirement and permit the use of
arrays, as the parameter passing semantics will cause the necessary
array-to-pointer decay. They will also cause the function name to
decay to a pointer to function and allow the implementation to handle
functions and function objects identically.
</p>

<p>
The new signature of the <tt>thread</tt> constructor for a function and
arguments is thus:
</p>

<blockquote><pre>template&lt;typename F,typename... Args&gt;
thread(F,Args... args);
</pre></blockquote>

<p>
Since the parameter pack <tt>Args</tt> can be empty, the single-parameter
constructor that takes just a function by value is now redundant.
</p>

<p><i>[
Howard adds:
]</i></p>


<blockquote>
<p>
I agree with everything Anthony says in this issue.  However I believe we
can optimize in such a way as to get the pass-by-value behavior with the
pass-by-rvalue-ref performance.  The performance difference is that the latter
removes a <tt>move</tt> when passing in an lvalue.
</p>

<p>
This circumstance is very analogous to <tt>make_pair</tt> (20.3.4 [pairs])
where we started with passing by const reference, changed to pass by value to
get pointer decay, and then changed to pass by rvalue reference, but modified with
<tt>decay&lt;T&gt;</tt> to retain the pass-by-value behavior.  If we were to
apply the same solution here it would look like:
</p>

<blockquote><pre><del>template &lt;class F&gt; explicit thread(F f);</del>
template &lt;class F, class ...Args&gt; thread(F&amp;&amp; f, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-4- <i>Requires:</i> <tt>F</tt> and each <tt>Ti</tt> in <tt>Args</tt> shall be <del><tt>CopyConstructible</tt>
if an lvalue and otherwise</del> <tt>MoveConstructible</tt>.
<tt><i>INVOKE</i>(f, w1, w2, ..., wN)</tt> (20.7.2 [func.require]) shall be a valid expression for
some values <tt>w1, w2, ... , wN,</tt> where <tt>N == sizeof...(Args)</tt>.
</p>
<p>
-5- <i>Effects:</i> Constructs an object of type <tt>thread</tt>
<del>and executes <tt><i>INVOKE</i>(f, t1, t2, ..., tN)</tt> in a new
thread of execution, where <tt>t1, t2, ..., tN</tt> are the values in <tt>args...</tt></del>.
<ins>Constructs
the following objects in memory which is accessible to a new thread of execution
as if:</ins>
</p>
<blockquote><pre><ins>typename decay&lt;F&gt;::type g(std::forward&lt;F&gt;(f));</ins>
<ins>tuple&lt;typename decay&lt;Args&gt;::type...&gt; w(std::forward&lt;Args&gt;(args)...);</ins>
</pre></blockquote>
<p>
<ins>The new thread of
execution executes <tt><i>INVOKE</i>(g, wi...)</tt> where the <tt>wi...</tt> refers
to the elements stored in the <tt>tuple w</tt>.</ins>
Any return value from <tt>g</tt> is ignored.
<del>If <tt>f</tt> terminates with an uncaught exception, <tt>std::terminate()</tt> shall be called.</del>
<ins>If the evaluation of <tt><i>INVOKE</i>(g,  wi...)</tt> terminates
with an uncaught exception, <tt>std::terminate()</tt> shall be called [<i>Note:</i>
<tt>std::terminate()</tt> could be called before entering <tt>g</tt>. -- <i>end note</i>]. Any
exception thrown before the evaluation of <tt><i>INVOKE</i></tt> has started shall be
catchable in the calling thread.</ins>
</p>
</blockquote>
</blockquote>

<p>
Text referring to when <tt>terminate()</tt> is called was contributed by Ganesh.
</p>

</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution,
but would like the final sentence to be reworded
since "catchable" is not a term of art (and is used nowhere else).
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
<p>
This is linked to
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2901.pdf">N2901</a>.
</p>
<p>
Howard to open a separate issue to remove (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1176">1176</a>).
</p>
<p>
In Frankfurt there is no consensus for removing the variadic constructor.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
We want to move forward with this issue.  If we later take it out via <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1176">1176</a>
then that's ok too.  Needs small group to improve wording.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
<p>
Stefanus provided revised wording.  Moved to Review  Here is the original wording:
</p>
<blockquote>
<p>
Modify the class definition of <tt>std::thread</tt> in 30.3.1 [thread.thread.class] to remove the
following signature:
</p>

<blockquote><pre><del>template&lt;class F&gt; explicit thread(F f);</del>
template&lt;class F, class ... Args&gt; <ins>explicit</ins> thread(F&amp;&amp; f, Args&amp;&amp; ... args);
</pre></blockquote>

<p>
Modify 30.3.1.2 [thread.thread.constr] to replace the constructors prior to paragraph 4 with
the single constructor as above. Replace paragraph 4 - 6 with the
following:
</p>

<blockquote>
<p>
-4- <i>Requires:</i> <tt>F</tt> and each <tt>Ti</tt> in <tt>Args</tt> shall be <del><tt>CopyConstructible</tt>
if an lvalue and otherwise</del> <tt>MoveConstructible</tt>.
<tt><i>INVOKE</i>(f, w1, w2, ..., wN)</tt> (20.7.2 [func.require]) shall be a valid expression for
some values <tt>w1, w2, ... , wN,</tt> where <tt>N == sizeof...(Args)</tt>.
</p>
<p>
-5- <i>Effects:</i> Constructs an object of type <tt>thread</tt>
<del>and executes <tt><i>INVOKE</i>(f, t1, t2, ..., tN)</tt> in a new
thread of execution, where <tt>t1, t2, ..., tN</tt> are the values in <tt>args...</tt></del>.
<ins>Constructs
the following objects:</ins>
</p>
<blockquote><pre><ins>typename decay&lt;F&gt;::type g(std::forward&lt;F&gt;(f));</ins>
<ins>tuple&lt;typename decay&lt;Args&gt;::type...&gt; w(std::forward&lt;Args&gt;(args)...);</ins>
</pre></blockquote>
<p>
<ins>and executes <tt><i>INVOKE</i>(g, wi...)</tt> in a new thread of execution.
These objects shall be destroyed when the new thread of execution completes.</ins>
Any return value from <tt>g</tt> is ignored.
<del>If <tt>f</tt> terminates with an uncaught exception, <tt>std::terminate()</tt> shall be called.</del>
<ins>If the evaluation of <tt><i>INVOKE</i>(g,  wi...)</tt> terminates
with an uncaught exception, <tt>std::terminate()</tt> shall be called [<i>Note:</i>
<tt>std::terminate()</tt> could be called before entering <tt>g</tt>. -- <i>end note</i>]. Any
exception thrown before the evaluation of <tt><i>INVOKE</i></tt> has started shall be
catchable in the calling thread.</ins>
</p>
<p>
-6- <i>Synchronization:</i> The invocation of the constructor <i>happens before</i> the
invocation of <del><tt>f</tt></del> <ins><tt>g</tt></ins>.
</p>
</blockquote>

</blockquote>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Modify the class definition of <tt>std::thread</tt> in 30.3.1 [thread.thread.class] to remove the
following signature:
</p>

<blockquote><pre><del>template&lt;class F&gt; explicit thread(F f);</del>
template&lt;class F, class ... Args&gt; <ins>explicit</ins> thread(F&amp;&amp; f, Args&amp;&amp; ... args);
</pre></blockquote>

<p>
Modify 30.3.1.2 [thread.thread.constr] to replace the constructors prior to paragraph 4 with
the single constructor as above. Replace paragraph 4 - 6 with the
following:
</p>

<blockquote>
<p>
-4- <i>Requires:</i> <tt>F</tt> and each <tt>Ti</tt> in <tt>Args</tt>
shall be <del><tt>CopyConstructible</tt> if an lvalue and
otherwise</del> <tt>MoveConstructible</tt>. <tt><i>INVOKE</i>(f, w1, w2,
..., wN)</tt> (20.7.2 [func.require]) shall be a valid expression
for some values <tt>w1, w2, ... , wN,</tt> where <tt>N ==
sizeof...(Args)</tt>.
</p>

<p>
-5- <i>Effects:</i> Constructs an object of type <tt>thread</tt> <del>and executes
<tt>INVOKE(f, t1, t2, ..., tN)</tt> in a new thread of execution, where
<tt>t1, t2, ..., tN</tt> are the values in <tt>args...</tt></del>. 
<ins>Given a function as follows:</ins>
<del>Any return
value from <tt>f</tt> is ignored. If <tt>f</tt> terminates with an
uncaught exception, <tt>std::terminate()</tt> shall be called.</del>
</p>

<blockquote><pre><ins>
template&lt;typename T&gt; typename decay&lt;T&gt;::type decay_copy(T&amp;&amp; v)
    { return std::forward&lt;T&gt;(v); }
</ins></pre></blockquote>

<p><ins>
The new thread of execution executes <tt>INVOKE(decay_copy(f),
decay_copy(args)...)</tt> with the calls to <tt>decay_copy()</tt> being evaluated in
the constructing thread. Any return value from this invocation is
ignored. [<i>Note:</i> this implies any exceptions not thrown from the
invocation of the copy of <tt>f</tt> will be thrown in the constructing thread,
not the new thread. &#8212; <i>end note</i>].
</ins></p>

<p>
-6- <i>Synchronization:</i> The invocation of the constructor <i>happens before</i> the
invocation of <ins>copy of</ins> <tt>f</tt>.
</p>
</blockquote>






<hr>
<h3><a name="932"></a>932. <tt>unique_ptr(pointer p)</tt> for pointer deleter types</h3>
<p><b>Section:</b> 20.8.14.2.1 [unique.ptr.single.ctor] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2008-11-26  <b>Last modified:</b> 2009-10-22</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#unique.ptr.single.ctor">active issues</a> in [unique.ptr.single.ctor].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#unique.ptr.single.ctor">issues</a> in [unique.ptr.single.ctor].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses US 79</b></p>

<p>
20.8.14.2.1 [unique.ptr.single.ctor]/5 no longer requires for <tt>D</tt>
not to be a pointer type.  I believe this restriction was accidently removed
when we relaxed the completeness reuqirements on <tt>T</tt>. The restriction
needs to be put back in.  Otherwise we have a run time failure that could
have been caught at compile time:
</p>

<blockquote><pre>{
unique_ptr&lt;int, void(*)(void*)&gt; p1(malloc(sizeof(int)));  <font color="#c80000">// should not compile</font>
}  <font color="#c80000">// p1.~unique_ptr() dereferences a null function pointer</font>
unique_ptr&lt;int, void(*)(void*)&gt; p2(malloc(sizeof(int)), free);  <font color="#c80000">// ok</font>
</pre></blockquote>

<p><i>[
Post Summit:
]</i></p>


<blockquote>
Recommend Tentatively Ready.
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
Moved from Tentatively Ready to Open only because the wording needs to be
improved for enable_if type constraining, possibly following Robert's
formula.
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
<p>
We need to consider whether some requirements in the Requires paragraphs
of [unique.ptr] should instead be Remarks.
</p>
<p>
Leave Open. Howard to provide wording, and possibly demonstrate how this
can be implemented using enable_if.
</p>
</blockquote>

<p><i>[
2009-07-27 Howard adds:
]</i></p>


<blockquote>
<p>
The two constructors to which this issue applies are not easily constrained
with <tt>enable_if</tt> as they are not templated:
</p>

<blockquote><pre>unique_ptr();
explicit unique_ptr(pointer p);
</pre></blockquote>

<p>
To "SFINAE" these constructors away would take heroic effort such as specializing
the entire <tt>unique_ptr</tt> class template on pointer deleter types.  There
is insufficient motivation for such heroics.  Here is the expected and
reasonable implementation for these constructors:
</p>

<blockquote><pre>unique_ptr()
    : ptr_(pointer())
    {
        static_assert(!is_pointer&lt;deleter_type&gt;::value,
            "unique_ptr constructed with null function pointer deleter");
    }
explicit unique_ptr(pointer p)
    : ptr_(p)
    {
        static_assert(!is_pointer&lt;deleter_type&gt;::value,
            "unique_ptr constructed with null function pointer deleter");
    }
</pre></blockquote>

<p>
I.e. just use <tt>static_assert</tt> to verify that the constructor is not
instantiated with a function pointer for a deleter.  The compiler will automatically
take care of issuing a diagnostic if the deleter is a reference type (uninitialized
reference error).
</p>

<p>
In keeping with our discussions in Frankfurt, I'm moving this requirement on
the implementation from the Requires paragraph to a Remarks paragraph.
</p>

</blockquote>

<p><i>[
2009-08-17 Daniel adds:
]</i></p>


<blockquote>
<p>
It is insufficient to require a diagnostic. This doesn't imply an
ill-formed program
as of 1.3.3 [defns.diagnostic] (a typical alternative would be a compiler
warning), but
exactly that seems to be the intend. I suggest to use the following
remark instead:
</p>

<blockquote>
<i>Remarks:</i> The program shall be ill-formed if this constructor is
instantiated when <tt>D</tt> is a pointer type or reference type.
</blockquote>

<p>
Via the general standard rules of 1.4 [intro.compliance] the "diagnostic
required" is implied.
</p>

</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Moved to Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change the description of the default constructor in 20.8.14.2.1 [unique.ptr.single.ctor]:
</p>

<blockquote><pre>unique_ptr();
</pre>
<blockquote>
<p>
-1- <i>Requires:</i> <tt>D</tt> shall be default constructible, and that construction
shall not throw an exception. <del><tt>D</tt> shall 
not be a reference type or pointer type (diagnostic required).</del>
</p>
<p>...</p>
<p><ins>
<i>Remarks:</i> The program shall be ill-formed if this constructor is
instantiated when <tt>D</tt> is a pointer type or reference type.

</ins></p>
</blockquote>
</blockquote>

<p>
Add  after 20.8.14.2.1 [unique.ptr.single.ctor]/8:
</p>

<blockquote><pre>unique_ptr(pointer p);
</pre>
<blockquote>
<p>...</p>
<p><ins>
<i>Remarks:</i> The program shall be ill-formed if this constructor is
instantiated when <tt>D</tt> is a pointer type or reference type.

</ins></p>
</blockquote>
</blockquote>





<hr>
<h3><a name="939"></a>939. Problem with <tt>std::identity</tt> and reference-to-temporaries</h3>
<p><b>Section:</b> 20.3.3 [forward] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2008-12-11  <b>Last modified:</b> 2009-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#forward">issues</a> in [forward].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>std::identity</tt> takes an argument of type <tt>T const &amp;</tt>
and returns a result of <tt>T const &amp;</tt>.
</p>
<p>
Unfortunately, this signature will accept a value of type other than <tt>T</tt> that
is convertible-to-<tt>T</tt>, and then return a reference to the dead temporary.  The
constraint in the concepts version simply protects against returning
reference-to-<tt>void</tt>.
</p>
<p>
Solutions:
</p>
<blockquote>
<p>
i/  Return-by-value, potentially slicing bases and rejecting non-copyable
types
</p>
<p>
ii/ Provide an additional overload:
</p>
<blockquote><pre>template&lt; typename T &gt;
template operator( U &amp; ) = delete;
</pre></blockquote>
<p>
This seems closer on intent, but moves beyond the original motivation for
the operator, which is compatibility with existing (non-standard)
implementations.
</p>
<p>
iii/ Remove the <tt>operator()</tt> overload.  This restores the original definition
of the <tt>identity</tt>, although now effectively a type_trait rather than part of
the perfect forwarding protocol.
</p>
<p>
iv/ Remove <tt>std::identity</tt> completely; its original reason to exist is
replaced with the <tt>IdentityOf</tt> concept.
</p>
</blockquote>
<p>
My own preference is somewhere between (ii) and (iii) - although I stumbled
over the issue with a specific application hoping for resolution (i)!
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We dislike options i and iii, and option ii seems like overkill.
If we remove it (option iv), implementers can still provide it under a
different name.
</p>
<p>
Move to Open pending wording (from Alisdair) for option iv.
</p>
</blockquote>

<p><i>[
2009-05-23 Alisdair provided wording for option iv.
]</i></p>


<p><i>[
2009-07-20 Alisdair adds:
]</i></p>


<blockquote>
<p>
I'm not sure why this issue was not discussed at Frankfurt (or I missed
the discussion) but the rationale is now fundamentally flawed.  With the
removal of concepts, <tt>std::identity</tt> again becomes an important library
type so we cannot simply remove it.
</p>
<p>
At that point, we need to pick one of the other suggested resolutions,
but have no guidance at the moment.
</p>
</blockquote>

<p><i>[
2009-07-20 Howard adds:
]</i></p>


<blockquote>
<p>
I believe the rationale for not addressing this issue in Frankfurt was that it did
not address a national body comment.
</p>
<p>
I also believe that removal of <tt>identity</tt> is still a practical option as
my latest reformulation of <tt>forward</tt>, which is due to comments suggested
at Summit, no longer uses <tt>identity</tt>. :-)
</p>

<blockquote><pre>template &lt;class T, class U,
    class = typename enable_if
            &lt;
                !is_lvalue_reference&lt;T&gt;::value || 
                 is_lvalue_reference&lt;T&gt;::value &amp;&amp;
                 is_lvalue_reference&lt;U&gt;::value
            &gt;::type,
    class = typename enable_if
            &lt;
                is_same&lt;typename remove_all&lt;T&gt;::type,
                        typename remove_all&lt;U&gt;::type&gt;::value
            &gt;::type&gt;
inline
T&amp;&amp;
forward(U&amp;&amp; t)
{
    return static_cast&lt;T&amp;&amp;&gt;(t);

}
</pre>

<p><i>[
The above code assumes acceptance of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1120">1120</a> for the definition of
<tt>remove_all</tt>.  This is just to make the syntax a little more palatable.
Without this trait the above is still very implementable.
]</i></p>


</blockquote>

<p>
Paper with rationale is on the way ... <i>really</i>, I promise this time! ;-)
</p>
</blockquote>

<p><i>[
2009-07-30 Daniel adds:  See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#823">823</a> for an alternative resolution.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Move to Ready. Howard will update proposed wording to reflect current draft.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Strike from 20.3 [utility]:
</p>

<blockquote><pre><del>template &lt;class T&gt; struct identity;</del>
</pre></blockquote>

<p>
Remove from 20.3.3 [forward]:
</p>

<blockquote>
<pre><del>template &lt;class T&gt; struct identity {
  typedef T type;

  const T&amp; operator()(const T&amp; x) const;
};</del>

<del>const T&amp; operator()(const T&amp; x) const;</del>
</pre>
<blockquote>
<del>-2-  <i>Returns:</i> <tt>x</tt></del>
</blockquote>
</blockquote>






<hr>
<h3><a name="940"></a>940. <tt>std::distance</tt></h3>
<p><b>Section:</b> 24.4.4 [iterator.operations] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Thomas <b>Opened:</b> 2008-12-14  <b>Last modified:</b> 2009-10-22</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#iterator.operations">active issues</a> in [iterator.operations].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#iterator.operations">issues</a> in [iterator.operations].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 270</b></p>

<p>
Regarding the <tt>std::distance</tt> - function, 24.4.4 [iterator.operations]
/ 4 says:
</p>
<blockquote>
Returns the
number of increments or decrements needed to get from first to last.
</blockquote>
<p>
This sentence is completely silent about the sign of the return value.
24.4.4 [iterator.operations] / 1 gives more information about the
underlying operations, but
again no inferences about the sign can be made.
Strictly speaking, that is taking that sentence literally, I think this
sentence even implies a positive return value in all cases, as the
number of increments or decrements is clearly a ratio scale variable,
with a natural zero bound.
</p>
<p>
Practically speaking, my implementations did what common sense and
knowledge based on pointer arithmetic forecasts, namely a positive sign
for increments (that is, going from <tt>first</tt> to <tt>last</tt> by <tt>operator++</tt>), and a
negative sign for decrements (going from <tt>first</tt> to <tt>last</tt> by <tt>operator--</tt>).
</p>
<p>
Here are my two questions:
</p>
<p>
First, is that paragraph supposed to be interpreted in the way what I
called 'common sense', that is negative sign for decrements ? I am
fairly sure that's the supposed behavior, but a double-check here in
this group can't hurt.
</p>
<p>
Second, is the present wording (2003 standard version - no idea about
the draft for the upcoming standard) worth an edit to make it a bit more
sensible, to mention the sign of the return value explicitly ?
</p>

<p><i>[
Daniel adds:
]</i></p>


<blockquote>
<p>
My first thought was that resolution <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#204">204</a> would already cover the
issue report, but it seems that current normative wording is in
contradiction to that resolution:
</p>

<p>
Referring to
<a href="" ref="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2798.pdf">N2798</a>,
24.4.4 [iterator.operations]/ p.4 says:
</p>

<blockquote>
<i>Effects:</i> Returns the number of increments or decrements needed to get
from <tt>first</tt> to <tt>last</tt>.
</blockquote>

<p>
IMO the part " or decrements" is in contradiction to p. 5 which says
</p>

<blockquote>
<i>Requires:</i> <tt>last</tt> shall be reachable from <tt>first</tt>.
</blockquote>

<p>
because "reachable" is defined in X [iterator.concepts]/7 as
</p>

<blockquote>
An iterator <tt>j</tt> is called reachable from an iterator <tt>i</tt> if and only if
there is a finite
sequence of applications of the expression <tt>++i</tt> that makes <tt>i == j</tt>.[..]
</blockquote>

<p>
Here is wording that would be consistent with this definition of "reachable":
</p>

<p>
Change 24.4.4 [iterator.operations] p4 as follows:
</p>

<blockquote>
<i>Effects:</i> Returns the number of increments <del>or decrements</del>
needed to get from <tt>first</tt> to <tt>last</tt>.
</blockquote>

</blockquote>

<p>
Thomas adds more discussion and an alternative view point
<a href="http://groups.google.com/group/comp.std.c++/browse_thread/thread/e8e46dcda0a5d797#">here</a>.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
The proposed wording below was verbally agreed to.  Howard provided.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Pete reports that a recent similar change has been made
for the <tt>advance()</tt> function.
</p>
<p>
We agree with the proposed resolution.
Move to Tentatively Ready.
</p>
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
Moved from Tentatively Ready to Open only because the wording needs to be
tweaked for concepts removal.
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
Leave Open pending arrival of a post-Concepts WD.
</blockquote>

<p><i>[
2009-10-14 Daniel provided de-conceptified wording.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Move to Ready, replacing the Effects clause in the proposed wording with
"If InputIterator meets the requirements of random access iterator then
returns (last - first), otherwise returns the number of increments
needed to get from first to list.".
</blockquote>



<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>
Change 24.2.5 [random.access.iterators], Table 105 as indicated [This change is not
essential but it simplifies the specification] for the row with
expression "<tt>b - a</tt>"
and the column Operational semantics:
</p>

<blockquote><pre><del>(a &lt; b) ? </del>distance(a,b)
<del>: -distance(b,a)</del>
</pre></blockquote>
</li>

<li>
<p>
Change 24.4.4 [iterator.operations]/4+5 as indicated:
</p>

<blockquote><pre>template&lt;class InputIterator&gt;
  typename iterator_traits&lt;InputIterator&gt;::difference_type
    distance(InputIterator first, InputIterator last);
</pre>
<blockquote>
<p>
4 <i>Effects:</i> <ins>If <tt>InputIterator</tt> meets the requirements
of random access iterator then returns <tt>(last - first)</tt>,
otherwise</ins> <del>R</del><ins>r</ins>eturns the number of increments
<del>or decrements</del> needed to get from <tt>first</tt> to
<tt>last</tt>.
</p>

<p>
5 <i>Requires:</i> <ins>If <tt>InputIterator</tt> meets the requirements
of random access iterator then <tt>last</tt> shall be reachable from
<tt>first</tt> or <tt>first</tt> shall be reachable from <tt>last</tt>,
otherwise</ins> <tt>last</tt> shall be reachable from <tt>first</tt>.
</p>
</blockquote>
</blockquote>
</li>
</ol>









<hr>
<h3><a name="950"></a>950. unique_ptr converting ctor shouldn't accept array form</h3>
<p><b>Section:</b> 20.8.14.2.1 [unique.ptr.single.ctor] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-01-07  <b>Last modified:</b> 2009-10-21</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#unique.ptr.single.ctor">active issues</a> in [unique.ptr.single.ctor].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#unique.ptr.single.ctor">issues</a> in [unique.ptr.single.ctor].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>unique_ptr</tt>'s of array type should not convert to
<tt>unique_ptr</tt>'s which do not have an array type.
</p>

<blockquote><pre>struct Deleter
{
   void operator()(void*) {}
};

int main()
{
   unique_ptr&lt;int[], Deleter&gt; s;
   unique_ptr&lt;int, Deleter&gt; s2(std::move(s));  <font color="#c80000">// should not compile</font>
}
</pre></blockquote>

<p><i>[
Post Summit:
]</i></p>


<blockquote>
<p>
Walter: Does the "diagnostic required" apply to both arms of the "and"?
</p>
<p>
Tom Plum: suggest to break into several sentences
</p>
<p>
Walter: suggest "comma" before the "and" in both places
</p>
<p>
Recommend Review.
</p>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
The post-Summit comments have been applied to the proposed resolution.
We now agree with the proposed resolution.
Move to Tentatively Ready.
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
Moved from Tentatively Ready to Open only because the wording needs to be
improved for enable_if type constraining, possibly following Robert's
formula.
</blockquote>

<p><i>[
2009-08-01 Howard updates wording and sets to Review.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Move to Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 20.8.14.2.1 [unique.ptr.single.ctor]:
</p>

<blockquote>
<pre>template &lt;class U, class E&gt; unique_ptr(unique_ptr&lt;U, E&gt;&amp;&amp; u);
</pre>
<blockquote>
<p>
-20- <i>Requires:</i> If <tt>D</tt> is not a reference type,
construction of the deleter <tt>D</tt> from an rvalue of type <tt>E</tt>
shall be well formed and shall not throw an exception. <del>If <tt>D</tt> is
a reference type, then <tt>E</tt> shall be the same type as <tt>D</tt>
(diagnostic required). <tt>unique_ptr&lt;U, E&gt;::pointer</tt> shall be
implicitly convertible to <tt>pointer</tt>. [<i>Note:</i> These requirements
imply that <tt>T</tt> and <tt>U</tt> are complete types. &#8212; <i>end note</i>]</del>
</p>

<p><ins>
<i>Remarks:</i> If <tt>D</tt> is
a reference type, then <tt>E</tt> shall be the same type as <tt>D</tt>, else this
constructor shall not participate in overload resolution. <tt>unique_ptr&lt;U, E&gt;::pointer</tt> shall be
implicitly convertible to <tt>pointer</tt>, else this
constructor shall not participate in overload resolution. <tt>U</tt> shall not be
an array type, else this
constructor shall not participate in overload resolution. [<i>Note:</i> These requirements
imply that <tt>T</tt> and <tt>U</tt> are complete types. &#8212; <i>end note</i>]
</ins></p>

</blockquote>
</blockquote>

<p>
Change 20.8.14.2.3 [unique.ptr.single.asgn]:
</p>

<blockquote>
<pre>template &lt;class U, class E&gt; unique_ptr&amp; operator=(unique_ptr&lt;U, E&gt;&amp;&amp; u);
</pre>
<blockquote>
<p>
-6- <i>Requires:</i> Assignment of the deleter <tt>D</tt> from an rvalue
<tt>D</tt> shall not throw an exception. <del><tt>unique_ptr&lt;U,
E&gt;::pointer</tt> shall be implicitly convertible to <tt>pointer</tt>.
[<i>Note:</i> These requirements imply that <tt>T</tt> and <tt>U</tt>
are complete types. &#8212; <i>end note</i>]</del>
</p>

<p><ins>
<i>Remarks:</i> <tt>unique_ptr&lt;U,
E&gt;::pointer</tt> shall be implicitly convertible to <tt>pointer</tt>, else this
operator shall not participate in overload resolution.
<tt>U</tt> shall not be an array type, else this
operator shall not participate in overload resolution.
[<i>Note:</i> These requirements imply that <tt>T</tt> and <tt>U</tt>
are complete types. &#8212; <i>end note</i>]
</ins></p>

</blockquote>
</blockquote>






<hr>
<h3><a name="951"></a>951. Various threading bugs #1</h3>
<p><b>Section:</b> 20.9.2.1 [time.traits.is_fp] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2009-01-07  <b>Last modified:</b> 2009-10-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Related to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#953">953</a>.
</p>

<p>
20.9.2.1 [time.traits.is_fp] says that the type <tt>Rep</tt> "is
assumed to be ... a class emulating an integral type." What are the
requirements for such a type?
</p>
<p><i>[
2009-05-10 Howard adds:
]</i></p>


<blockquote>
<tt>IntegralLike</tt>.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
As with issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#953">953</a>,
we recommend this issue be addressed in the context of providing concepts for the entire <tt>thread</tt> header.
</p>
<p>
We look forward to proposed wording.
</p>
<p>
Move to Open.
</p>
</blockquote>

<p><i>[
2009-08-01 Howard adds:
]</i></p>


<blockquote>
<p>
I have surveyed all clauses of 20.9.2.2 [time.traits.duration_values],
20.9.2.3 [time.traits.specializations] and 20.9.3 [time.duration].
I can not find any clause which involves the use of a <tt>duration::rep</tt> type
where the requirements on the <tt>rep</tt> type are not clearly spelled out.
These requirements were carefully crafted to allow any arithmetic type, or
any user-defined type emulating an arithmetic type.
</p>

<p>
Indeed, <tt>treat_as_floating_point</tt>
becomes completely superfluous if <tt>duration::rep</tt> can never be a class type.
</p>

<p>
There will be some <tt>Rep</tt> types which will not meet the requirements of
<em>every</em> <tt>duration</tt> operation.  This is no different than the fact
that <tt>vector&lt;T&gt;</tt> can easily be used for types <tt>T</tt> which are
not <tt>DefaultConstructible</tt>, even though some members of <tt>vector&lt;T&gt;</tt>
require <tt>T</tt> to be <tt>DefaultConstructible</tt>.  This is why the requirements
on <tt>Rep</tt> are specified for each operation individually.
</p>

<p>
In 20.9.2.1 [time.traits.is_fp] p1:
</p>

<blockquote><pre>template &lt;class Rep&gt; struct treat_as_floating_point 
  : is_floating_point&lt;Rep&gt; { };
</pre>

<blockquote>
The <tt>duration</tt> template uses the <tt>treat_as_floating_point</tt> trait to help
determine if a <tt>duration</tt> object can be converted to another <tt>duration</tt>
with a different tick period. If <tt>treat_as_floating_point&lt;Rep&gt;::value</tt> is
<tt>true</tt>, then <tt>Rep</tt> is a floating-point type and implicit conversions are
allowed among <tt>duration</tt>s. Otherwise, the implicit convertibility depends
on the tick periods of the <tt>duration</tt>s. If <tt>Rep</tt> is <u>a class type which
emulates a floating-point type</u>, the author of <tt>Rep</tt> can specialize
<tt>treat_as_floating_point</tt> so that <tt>duration</tt> will treat this <tt>Rep</tt> as if it
were a floating-point type. Otherwise <tt>Rep</tt> is assumed to be an integral
type or <u>a class emulating an integral type</u>.
</blockquote>
</blockquote>

<p>
The phrases "a class type which emulates a floating-point type" and
"a class emulating an integral type" are clarifying phrases which refer to
the summation of all the requirements on the <tt>Rep</tt> type specified in
detail elsewhere (and <em>should not</em> be repeated here).
</p>

<p>
This specification has been implemented, now multiple times, and the experience
has been favorable.  The current specification clearly specifies the requirements
at each point of use (though I'd be happy to fix any place I may have missed,
but none has been pointed out).
</p>

<p>
I am amenable to improved wording of this paragraph (and any others), but do not have any
suggestions for improved wording at this time.  I am <em>strongly</em> opposed to
changes which would significantly alter the semantics of the
specification under 20.9 [time] without firmly grounded and
documented rationale, example implementation, testing, and user
experience which relates a positive experience.
</p>

<p>
I recommend NAD unless someone wants to produce some clarifying wording.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Stefanus to provide wording to turn this into a note.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="953"></a>953. Various threading bugs #3</h3>
<p><b>Section:</b> 20.9.1 [time.clock.req] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2009-01-07  <b>Last modified:</b> 2009-10-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#time.clock.req">active issues</a> in [time.clock.req].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#time.clock.req">issues</a> in [time.clock.req].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Related to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#951">951</a>.
</p>

<p>
20.9.1 [time.clock.req] says that a clock's <tt>rep</tt> member is "an
arithmetic type or a class emulating an arithmetic type." What are the
requirements for such a type?
</p>

<p><i>[
2009-05-10 Howard adds:
]</i></p>


<blockquote>
This wording was aimed directly at the <tt>ArithmeticLike</tt> concept.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We recommend this issue be addressed in the context of providing concepts
for the entire <tt>thread</tt> header.
</p>
<p>
May resolve for now by specifying arithmetic types,
and in future change to <tt>ArithmeticLike</tt>.
However, Alisdair believes this is not feasible.
</p>
<p>
Bill disagrees.
</p>
<p>
We look forward to proposed wording.  Move to Open.
</p>
</blockquote>

<p><i>[
2009-08-01 Howard adds:
]</i></p>


<blockquote>
See commented dated 2009-08-01 in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#951">951</a>.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Stefanus to provide wording to turn this into a note.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="954"></a>954. Various threading bugs #4</h3>
<p><b>Section:</b> 20.9.1 [time.clock.req] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2009-01-07  <b>Last modified:</b> 2009-10-21</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#time.clock.req">active issues</a> in [time.clock.req].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#time.clock.req">issues</a> in [time.clock.req].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Table 55 -- Clock Requirements (in 20.9.1 [time.clock.req])
</p>

<ol type="a">
<li>
the requirements for <tt>C1::time_point</tt> require <tt>C1</tt> and <tt>C2</tt>
to "refer to the same epoch", but "epoch" is not defined.
</li>
<li>
"Different clocks may share a <tt>time_point</tt> definition if it is
valid to compare their <tt>time_point</tt>s by comparing their
respective <tt>duration</tt>s." What does "valid" mean here? And, since
<tt>C1::rep</tt> is "**THE** representation type of the native
<tt>duration</tt> and <tt>time_point</tt>" (emphasis added), there
doesn't seem to be much room for some other representation.
</li>
<li>
<tt>C1::is_monotonic</tt> has type "<tt>const bool</tt>". The
"<tt>const</tt>" should be removed.
</li>
<li>
<tt>C1::period</tt> has type <tt>ratio</tt>. <tt>ratio</tt> isn't a type, 
it's a template. What is the required type?
</li>
</ol>

<p><i>[
2009-05-10 Howard adds:
]</i></p>


<ol type="a">
<li>
<p>
"epoch" is purposefully not defined beyond the common English
<a href="http://www.dictionary.net/epoch">definition</a>.  The C standard
also chose not to define epoch, though POSIX did.  I believe it is a strength
of the C standard that epoch is not defined.  When it is known that two <tt>time_point</tt>s
refer to the same epoch, then a definition of the epoch is not needed to compare
the two <tt>time_point</tt>s, or subtract them.
</p>
<p>
A <tt>time_point</tt> and a <tt>Clock</tt> implicitly refer to an (unspecified) epoch.
The <tt>time_point</tt> represents an offset (<tt>duration</tt>) from an epoch.
</p>
</li>
<li>
<p>
The sentence:
</p>
<blockquote>
Different clocks 
may share a <tt>time_point</tt>
definition if it is valid to 
compare their <tt>time_point</tt>s by 
comparing their respective 
<tt>duration</tt>s.
</blockquote>

<p>
is redundant and could be removed.  I believe the sentence which follows the above:
</p>

<blockquote>
<tt>C1</tt> and <tt>C2</tt> shall refer to the same epoch.
</blockquote>

<p>
is sufficient.  If two clocks share the same epoch, then by definition, comparing
their <tt>time_point</tt>s is valid.
</p>
</li>
<li>
<tt>is_monotonic</tt> is meant to never change (be <tt>const</tt>).  It is also
desired that this value be usable in compile-time computation and branching.
</li>
<li>
<p>
This should probably instead be worded:
</p>
<blockquote>
An instantiation of <tt>ratio</tt>.
</blockquote>
</li>
</ol>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Re (a): It is not clear to us whether "epoch" is a term of art.
</p>
<p>
Re (b), (c), and (d):  We agree with Howard's comments,
and would consider adding to (c) a <tt>static constexpr</tt> requirement.
</p>
<p>
Move to Open pending proposed wording.
</p>
</blockquote>

<p><i>[
2009-05-25 Daniel adds:
]</i></p>


<blockquote>
In regards to (d) I suggest to say "a specialization of ratio" instead of
"An instantiation of ratio". This seems to be the better matching standard
core language term for this kind of entity.
</blockquote>

<p><i>[
2009-05-25 Ganesh adds:
]</i></p>


<blockquote>
<p>
Regarding (a), I found this paper on the ISO website using the term "epoch" consistently with the current wording:
</p>

<p>
<a href="http://standards.iso.org/ittf/PubliclyAvailableStandards/C030811e_FILES/MAIN_C030811e/text/ISOIEC_18026E_TEMPORAL_CS.HTM">http://standards.iso.org/ittf/PubliclyAvailableStandards/C030811e_FILES/MAIN_C030811e/text/ISOIEC_18026E_TEMPORAL_CS.HTM</a>
</p>
<p>
which is part of ISO/IEC 18026 "Information technology -- Spatial Reference Model (SRM)".
</p>
</blockquote>

<p><i>[
2009-08-01 Howard: Moved to Reivew as the wording requested in Batavia has been provided.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Move to Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>
<ol type="a">
<li>
<p>
Change 20.9.1 [time.clock.req] p1:
</p>
<blockquote>
-1- A clock is a bundle consisting of a native <tt>duration</tt>, a native <tt>time_point</tt>, and a function <tt>now()</tt> to get the 
current <tt>time_point</tt>.  <ins>The origin of the clock's <tt>time_point</tt> is referred to as the clock's <i>epoch</i> as defined in 
section 6.3 of ISO/IEC 18026.</ins>
A clock shall meet the requirements in Table 45.
</blockquote>
</li>
<li>
<p>
Remove the sentence from the <tt>time_point</tt> row of the table "Clock Requirements":
</p>
<table border="1">
<caption>Clock requirements</caption>
<tbody><tr>
<td>
<tt>C1::time_point</tt>
</td>
<td>
<tt>chrono::time_point&lt;C1&gt;</tt> or <tt>chrono::time_point&lt;C2, C1::duration&gt;</tt>
</td>
<td>
The native <tt>time_point</tt> type of the clock.
<del>Different clocks may share a <tt>time_point</tt> definition if it is valid to compare their <tt>time_point</tt>s by comparing their respective <tt>duration</tt>s.</del>
<tt>C1</tt> and <tt>C2</tt> shall refer to the same epoch.
</td>
</tr>
</tbody></table>
</li>
</ol>
<ol start="4" type="a">
<li>
<p>
Change the row starting with <tt>C1::period</tt> of the table "Clock Requirements":
</p>
<table border="1">
<caption>Clock requirements</caption>
<tbody><tr>
<td>
<tt>C1::period</tt>
</td>
<td>
<ins>a specialization of</ins> <tt>ratio</tt>
</td>
<td>
The tick period of the clock in seconds.
</td>
</tr>
</tbody></table>

</li>
</ol>





<hr>
<h3><a name="956"></a>956. Various threading bugs #6</h3>
<p><b>Section:</b> 20.9.1 [time.clock.req] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2009-01-07  <b>Last modified:</b> 2009-10-24</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#time.clock.req">active issues</a> in [time.clock.req].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#time.clock.req">issues</a> in [time.clock.req].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
20.9.1 [time.clock.req] uses the word "native" in several places,
but doesn't define it. What is a "native <tt>duration</tt>"?
</p>

<p><i>[
2009-05-10 Howard adds:
]</i></p>


<blockquote>
The standard uses "native" in several places without defining it (e.g.
2.14.3 [lex.ccon]).  It is meant to mean "that which is defined
by the facility", or something along those lines.  In this case it refers
to the nested <tt>time_point</tt> and <tt>duration</tt> types of the clock.
Better wording is welcome.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Move to Open pending proposed wording from Pete.
</blockquote>

<p><i>[
2009-10-23 Pete provides wording:
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
Remove every occurrence of "native" in 20.9.1 [time.clock.req].
</p>

<p>
Add the following sentence at the end of 20.9.1 [time.clock.req]/1:
</p>

<blockquote>
A clock is a bundle consisting of a <del>native</del> <tt>duration</tt>, a <del>native</del>
<tt>time_point</tt>, and a function <tt>now()</tt> to get the current <tt>time_point</tt>. A clock
shall meet the requirements in Table 55.
<ins>The <tt>duration</tt> and <tt>time_point</tt> types have the natural size and resolution
suggested by the architecture of the execution environment.</ins>
</blockquote>





<hr>
<h3><a name="957"></a>957. Various threading bugs #7</h3>
<p><b>Section:</b> 20.9.5.1 [time.clock.system] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2009-01-07  <b>Last modified:</b> 2009-10-21</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#time.clock.system">issues</a> in [time.clock.system].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
20.9.5.1 [time.clock.system]: <tt>to_time_t</tt> is overspecified. It
requires truncation, but should allow rounding. For example, suppose a
system has a clock that gives times in milliseconds, but <tt>time()</tt> rounds
those times to the nearest second. Then <tt>system_clock</tt> can't use any
resolution finer than one second, because if it did, truncating times
between half a second and a full second would produce the wrong <tt>time_t</tt>
value.
</p>

<p><i>[
Post Summit Anthony Williams provided proposed wording.
]</i></p>


<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Move to Review pending input from Howard. and other stakeholders.
</blockquote>

<p><i>[
2009-05-23 Howard adds:
]</i></p>


<blockquote>
I am in favor of the wording provided by Anthony.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Move to Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
In 20.9.5.1 [time.clock.system] replace paragraphs 3 and 4 with:
</p>

<blockquote>
<pre>time_t to_time_t(const time_point&amp; t);
</pre>
<blockquote>
-3- <i>Returns:</i> A <tt>time_t</tt> object that represents the same
point in time as <tt>t</tt> when both values are <del>truncated</del>
<ins>restricted</ins> to the coarser of the precisions of
<tt>time_t</tt> and <tt>time_point</tt>. <ins> It is implementation
defined whether values are rounded or truncated to the required
precision.</ins>
</blockquote>

<pre>time_point from_time_t(time_t t);
</pre>
<blockquote>
-4- <i>Returns:</i> A <tt>time_point</tt> object that represents the
same point in time as <tt>t</tt> when both values are <del>truncated</del>
<ins>restricted</ins> to the
coarser of the precisions of <tt>time_t</tt> and <tt>time_point</tt>.
<ins>It is implementation defined whether values are
rounded or truncated to the required precision.</ins>
</blockquote>
</blockquote>





<hr>
<h3><a name="959"></a>959. Various threading bugs #9</h3>
<p><b>Section:</b> 30.5.1 [thread.condition.condvar] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2009-01-07  <b>Last modified:</b> 2009-10-26</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#thread.condition.condvar">active issues</a> in [thread.condition.condvar].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.condition.condvar">issues</a> in [thread.condition.condvar].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
30.5.1 [thread.condition.condvar]: <tt>condition_variable::wait_for</tt>
is required to compute the absolute time by adding the duration value to
<tt>chrono::monotonic_clock::now()</tt>, but <tt>monotonic_clock</tt> is not required to
exist.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Move to open. Associate with LWG <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#859">859</a> and any other monotonic-clock
related issues.
</blockquote>

<p><i>[
2009-08-01 Howard adds:
]</i></p>


<blockquote>
I believe that <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#859">859</a> (currently Ready) addresses this issue, and
that this issue should be marked NAD, solved by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#859">859</a> (assuming
it moves to WP).
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Leave open, but expect to be fixed by N2969 revision that Detlef is writing.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="960"></a>960. Various threading bugs #10</h3>
<p><b>Section:</b> 30.4.1 [thread.mutex.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2009-01-07  <b>Last modified:</b> 2009-10-26</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#thread.mutex.requirements">active issues</a> in [thread.mutex.requirements].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.mutex.requirements">issues</a> in [thread.mutex.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
30.4.1 [thread.mutex.requirements]: paragraph 4 is entitled
"Error conditions", but according to 17.5.1.4 [structure.specifications], "Error
conditions:" specifies "the error conditions for error codes reported by
the function." It's not clear what this should mean when there is no
function in sight.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Move to open.
</blockquote>

<p><i>[
Beman provided proposed wording.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Move to Ready. Fix the proposed wording with "functions of type Mutex"
-&gt; "functions of Mutex type"
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 30.4.1 [thread.mutex.requirements] Mutex requirements,
paragraph 4 as indicated:
</p>

<blockquote>
<p>
-4- <del><i>Error conditions:</i></del>
<ins>The error conditions for error codes, if any, reported by member
functions of Mutex type shall be:</ins>
</p>
<ul>
<li>
<tt>not_enough_memory</tt> -- if there is not enough memory to construct
the mutex object.
</li>
<li>
<tt>resource_unavailable_try_again</tt> -- if any native handle type
manipulated is not available.
</li>
<li>
<tt>operation_not_permitted</tt> -- if the thread does not have the
necessary permission to change the state of the mutex object.
</li>
<li>
<tt>device_or_resource_busy</tt> -- if any native handle type
manipulated is already locked.
</li>
<li>
<tt>invalid_argument</tt> -- if any native handle type manipulated as
part of mutex construction is incorrect.
</li>
</ul>
</blockquote>





<hr>
<h3><a name="962"></a>962. Various threading bugs #12</h3>
<p><b>Section:</b> 30.4.3.2.2 [thread.lock.unique.locking] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2009-01-07  <b>Last modified:</b> 2009-10-22</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#thread.lock.unique.locking">active issues</a> in [thread.lock.unique.locking].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.lock.unique.locking">issues</a> in [thread.lock.unique.locking].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
30.4.3.2.2 [thread.lock.unique.locking]:  <tt>unique_lock::lock</tt> is
required to throw an object of type <tt>std::system_error</tt> "when the
postcondition cannot be achieved." The postcondition is <tt>owns == true</tt>,
and this is trivial to achieve. Presumably, the requirement is intended
to mean something more than that.
</p>

<p><i>[
Summit:
]</i></p>

<blockquote>
Move to open.
</blockquote>

<p><i>[
Beman has volunteered to provide proposed wording.
]</i></p>


<p><i>[
2009-07-21 Beman added wording to address 30.2.2 [thread.req.exception]
in response to the Frankfurt notes in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#859">859</a>.
]</i></p>


<p><i>[
2009-09-25 Beman: minor update to wording.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Move to Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>

<p><i>Change Exceptions 30.2.2 [thread.req.exception] as indicated:</i></p>
<blockquote>
<p>Some functions described in this Clause are specified to throw exceptions of 
type <code>system_error</code> (19.5.5). Such exceptions shall be thrown if <ins>
any of the <i>Error conditions</i> are detected or</ins> a call to an operating 
system or other underlying API results in an error that prevents the library 
function from <del>satisfying its postconditions or from returning a meaningful 
value</del> <ins>meeting its specifications</ins>. <ins>Failure to
allocate storage shall be reported as described in
17.6.4.11 [res.on.exception.handling].</ins></p>
</blockquote>

<p><i>Change thread assignment 30.3.1.5 [thread.thread.member], join(), 
paragraph 8 as indicated:</i></p>
<blockquote>
<p><i>Throws:</i> <code>std::system_error</code> when <del>the postconditions cannot be achieved</del> <ins>an exception is required (30.2.2 [thread.req.exception])</ins>.</p>

</blockquote>

<p><i>Change thread assignment 30.3.1.5 [thread.thread.member], detach(), paragraph 
13 as indicated:</i></p>
<blockquote>

<p><i>Throws:</i> <code>std::system_error</code> when <del>the effects or 
postconditions cannot be achieved</del> <ins>an exception is required (30.2.2 [thread.req.exception])</ins>.</p>

</blockquote>

<p><i>Change Mutex requirements 30.4.1 [thread.mutex.requirements], paragraph 
11, as indicated:</i></p>
<blockquote>

<p><i>Throws:</i> <code>std::system_error</code> when <del>the effects or 
postcondition cannot be achieved</del> <ins>an exception is required (30.2.2 [thread.req.exception])</ins>.</p>
</blockquote>
<p><i>Change unique_lock locking 30.4.3.2.2 [thread.lock.unique.locking], 
paragraph 3, as indicated:</i></p>
<blockquote>

<p><i>Throws:</i> <code>std::system_error</code> when <del>the  postcondition cannot be achieved</del> <ins>an exception is required (30.2.2 [thread.req.exception])</ins>.</p>
</blockquote>
<p><i>Change unique_lock locking 30.4.3.2.2 [thread.lock.unique.locking], 
paragraph 8, as indicated:</i></p>
<blockquote>

<p><i>Throws:</i> <code>std::system_error</code> when <del>the  postcondition cannot be achieved</del> <ins>an exception is required (30.2.2 [thread.req.exception])</ins>.</p>
</blockquote>
<p><i>Change unique_lock locking 30.4.3.2.2 [thread.lock.unique.locking], 
paragraph 13, as indicated:</i></p>
<blockquote>

<p><i>Throws:</i> <code>std::system_error</code> when <del>the  postcondition cannot be achieved</del> <ins>an exception is required (30.2.2 [thread.req.exception])</ins>.</p>
</blockquote>
<p><i>Change unique_lock locking 30.4.3.2.2 [thread.lock.unique.locking], 
paragraph 18, as indicated:</i></p>
<blockquote>

<p><i>Throws:</i> <code>std::system_error</code> when <del>the  postcondition cannot be achieved</del> <ins>an exception is required (30.2.2 [thread.req.exception])</ins>.</p>
</blockquote>
<p><i>Change unique_lock locking 30.4.3.2.2 [thread.lock.unique.locking], 
paragraph 22, as indicated:</i></p>
<blockquote>

<p><i>Throws:</i> <code>std::system_error</code> when <del>the  postcondition cannot be achieved</del> <ins>an exception is required (30.2.2 [thread.req.exception])</ins>.</p>
</blockquote>
<p><i>Change Function call_once 30.4.5.2 [thread.once.callonce], paragraph 4, as 
indicated</i></p>
<blockquote>
  <p><i>Throws:</i> <code>std::system_error</code> when <del>the effects cannot be achieved</del> <ins>an exception is required (30.2.2 [thread.req.exception])</ins>, 
  or any exception thrown by <code>func</code>.</p>
</blockquote>
<p><i>Change Class condition_variable 30.5.1 [thread.condition.condvar], 
paragraph 12, as indicated:</i></p>
<blockquote>

<p><i>Throws:</i> <code>std::system_error</code> when <del>the effects or 
postcondition cannot be achieved</del> <ins>an exception is required (30.2.2 [thread.req.exception])</ins>.</p>
</blockquote>
<p><i>Change Class condition_variable 30.5.1 [thread.condition.condvar], 
paragraph 19, as indicated:</i></p>
<blockquote>

<p><i>Throws:</i> <code>std::system_error</code> when <del>the effects or 
postcondition cannot be achieved</del> <ins>an exception is required (30.2.2 [thread.req.exception])</ins>.</p>
</blockquote>
<p><i>Change Class condition_variable_any 30.5.2 [thread.condition.condvarany], 
paragraph 10, as indicated:</i></p>
<blockquote>

<p><i>Throws:</i> <code>std::system_error</code> when <del>the effects or 
postcondition cannot be achieved</del> <ins>an exception is required (30.2.2 [thread.req.exception])</ins>.</p>
</blockquote>
<p><i>Change Class condition_variable_any 30.5.2 [thread.condition.condvarany], 
paragraph 16, as indicated:</i></p>
<blockquote>

<p><i>Throws:</i> <code>std::system_error</code> when <del>the returned value, effects, or 
postcondition cannot be achieved</del> <ins>an exception is required (30.2.2 [thread.req.exception])</ins>.</p>
</blockquote>

<p><i>Assuming issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#859">859</a>, Monotonic Clock is Conditionally Supported?, has been 
applied to the working paper, change Change 30.5.1 [thread.condition.condvar] as 
indicated:</i></p>
<blockquote>
<pre>template &lt;class Rep, class Period&gt; 
bool wait_for(unique_lock&lt;mutex&gt;&amp; lock, 
              const chrono::duration&lt;Rep, Period&gt;&amp; rel_time);</pre>
<pre>...</pre>

<p><i>Throws:</i> <code>std::system_error</code> when <del>the effects or 
postcondition cannot be achieved</del> <ins>an exception is required ([thread.req.exception])</ins>.</p>
</blockquote>

<p><i>Assuming issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#859">859</a>, Monotonic Clock is Conditionally Supported?, has been 
applied to the working paper, change Change 30.5.1 [thread.condition.condvar] as 
indicated:</i></p>
<blockquote>
<pre>template &lt;class Rep, class Period, class Predicate&gt; 
  bool wait_for(unique_lock&lt;mutex&gt;&amp; lock, 
                const chrono::duration&lt;Rep, Period&gt;&amp; rel_time, 
                Predicate pred);</pre>
  <pre>...</pre>

<p><i>Throws:</i> <code>std::system_error</code> when <del>the effects or 
postcondition cannot be achieved</del> <ins>an exception is required (30.2.2 [thread.req.exception])</ins>.</p>
</blockquote>

<p><i>Assuming issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#859">859</a>, Monotonic Clock is Conditionally Supported?, has been 
applied to the working paper, change 30.5.2 [thread.condition.condvarany] as 
indicated:</i></p>
<blockquote>
<pre>template &lt;class Lock, class Rep, class Period&gt; 
  bool wait_for(Lock&amp; lock, const chrono::duration&lt;Rep, Period&gt;&amp; rel_time);</pre>
  <pre>...</pre>

<p><i>Throws:</i> <code>std::system_error</code> when <del>the returned value, effects or 
postcondition cannot be achieved</del> <ins>an exception is required (30.2.2 [thread.req.exception])</ins>.</p>
</blockquote>

<p><i>Assuming issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#859">859</a>, Monotonic Clock is Conditionally Supported?, has been 
applied to the working paper, change 30.5.2 [thread.condition.condvarany] as 
indicated:</i></p>
<blockquote>
<pre>template &lt;class Lock, class Rep, class Period, class Predicate&gt; 
  bool wait_for(Lock&amp; lock, const chrono::duration&lt;Rep, Period&gt;&amp; rel_time, Predicate pred);</pre>
  <pre>...</pre>

<p><i>Throws:</i> <code>std::system_error</code> when <del>the returned value, effects or 
postcondition cannot be achieved</del> <ins>an exception is required (30.2.2 [thread.req.exception])</ins>.</p>
</blockquote>






<hr>
<h3><a name="963"></a>963. Various threading bugs #13</h3>
<p><b>Section:</b> 30.3.1.5 [thread.thread.member] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2009-01-07  <b>Last modified:</b> 2009-10-26</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#thread.thread.member">active issues</a> in [thread.thread.member].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.thread.member">issues</a> in [thread.thread.member].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
30.3.1.5 [thread.thread.member]:  <tt>thread::detach</tt> is required to
throw an exception if the thread is "not a detachable thread".
"Detachable" is never defined.
</p>

<p><i>[
Howard adds:
]</i></p>


<blockquote>
Due to a mistake on my part, 3 proposed resolutions appeared at approximately
the same time.  They are all three noted below in the discussion.
</blockquote>

<p><i>[
Summit, proposed resolution:
]</i></p>


<blockquote>
<p>
In 30.3.1.5 [thread.thread.member] change:
</p>

<blockquote><pre>void detach();
</pre>
<blockquote>
<p>...</p>
<p>-14- <i>Error conditions:</i></p>
<ul>
<li><tt>no_such_process</tt> --  <ins>if the thread is</ins> not <del>a</del> valid<del> thread</del>.</li>
<li><tt>invalid_argument</tt> -- <ins>if the thread is</ins> not <del>a detachable</del> <ins>joinable</ins><del> thread</del>.</li>
</ul>
</blockquote>

</blockquote>

</blockquote>

<p><i>[
Post Summit, Jonathan Wakely adds:
]</i></p>


<blockquote>
<p>
A <tt>thread</tt> is detachable if it is joinable. As we've defined joinable,
we can just use that.
</p>
<p>
This corresponds to the pthreads specification, where pthread_detach
fails if the thread is not joinable:
</p>
<blockquote>
EINVAL: The  implementation  has  detected  that  the value specified by
thread does not refer to a joinable thread.
</blockquote>
<p>
Jonathan recommends this proposed wording:
</p>
<blockquote>
<p>
In 30.3.1.5 [thread.thread.member] change:
</p>

<blockquote><pre>void detach();
</pre>
<blockquote>
<p>...</p>
<p>-14- <i>Error conditions:</i></p>
<ul>
<li>...</li>
<li><tt>invalid_argument</tt> -- not a <del>detachable</del> <ins>joinable</ins> thread.</li>
</ul>
</blockquote>

</blockquote>
</blockquote>
</blockquote>

<p><i>[
Post Summit, Anthony Williams adds:
]</i></p>


<blockquote>
<p>
This is covered by the precondition that <tt>joinable()</tt> be <tt>true</tt>.
</p>
<p>
Anthony recommends this proposed wording:
</p>

<blockquote>
<p>
In 30.3.1.5 [thread.thread.member] change:
</p>

<blockquote><pre>void detach();
</pre>
<blockquote>
<p>...</p>
<p>-14- <i>Error conditions:</i></p>
<ul>
<li>...</li>
<li><del><tt>invalid_argument</tt> -- not a detachable thread.</del></li>
</ul>
</blockquote>

</blockquote>

</blockquote>

</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Mark as Ready with proposed resolution from Summit.
</blockquote>



<p><b>Proposed resolution:</b></p>

<p>
In 30.3.1.5 [thread.thread.member] change:
</p>

<blockquote><pre>void detach();
</pre>
<blockquote>
<p>...</p>
<p>-14- <i>Error conditions:</i></p>
<ul>
<li><tt>no_such_process</tt> --  <ins>if the thread is</ins> not <del>a</del> valid<del> thread</del>.</li>
<li><tt>invalid_argument</tt> -- <ins>if the thread is</ins> not <del>a detachable</del> <ins>joinable</ins><del> thread</del>.</li>
</ul>
</blockquote>

</blockquote>






<hr>
<h3><a name="964"></a>964. Various threading bugs #14</h3>
<p><b>Section:</b> 30.5.2 [thread.condition.condvarany] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2009-01-07  <b>Last modified:</b> 2009-10-26</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#thread.condition.condvarany">active issues</a> in [thread.condition.condvarany].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.condition.condvarany">issues</a> in [thread.condition.condvarany].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The requirements for the constructor for <tt>condition_variable</tt> has several
error conditions, but the requirements for the constructor for
<tt>condition_variable_any</tt> has none. Is this difference intentional?
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Move to open, pass to Howard. If this is intentional, a note may be
helpful. If the error conditions are to be copied from
<tt>condition_variable</tt>, this depends on LWG <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#965">965</a>.
</blockquote>

<p><i>[
Post Summit Howard adds:
]</i></p>


<blockquote>
The original intention 
(<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2447.htm#ConditionVariablesWording">N2447</a>)
was to let the OS return whatever errors it was going to return, and for
those to be translated into exceptions, for both
<tt>condition_variable</tt> and <tt>condition_variable_any</tt>.  I have not
received any complaints about specific error conditions from vendors on
non-POSIX platforms, but such complaints would not surprise me if they surfaced.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Leave open. Benjamin to provide wording.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="966"></a>966. Various threading bugs #16</h3>
<p><b>Section:</b> 30.5.1 [thread.condition.condvar] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2009-01-07  <b>Last modified:</b> 2009-10-26</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#thread.condition.condvar">active issues</a> in [thread.condition.condvar].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.condition.condvar">issues</a> in [thread.condition.condvar].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
30.5.1 [thread.condition.condvar]:
<tt>condition_variable::wait</tt> and
<tt>condition_variable::wait_until</tt> both have a postcondition that
<tt>lock</tt> is locked by the calling thread, and a throws clause that
requires throwing an exception if this postcondition cannot be achieved.
How can the implementation detect that this <tt>lock</tt> can never be
obtained?
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Move to open. Requires wording. Agreed this is an issue, and the
specification should not require detecting deadlocks.
</blockquote>

<p><i>[
2009-08-01 Howard provides wording.
]</i></p>


<blockquote>
<p>
The proposed wording is inspired by the POSIX spec which says:
</p>

<blockquote>
<dl>
<dt>[EINVAL]</dt>
<dd>The value specified by cond or mutex is invalid.</dd>
<dt>[EPERM]</dt>
<dd>The mutex was not owned by the current thread at the time of the call.</dd>
</dl>
</blockquote>

<p>
I do not believe [EINVAL] is possible without memory corruption (which we don't
specify).  [EPERM] is possible if this thread doesn't own the mutex, which is
listed as a precondition.  "May" is used instead of "Shall" because not all
OS's are POSIX.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Leave open, Detlef to provide improved wording.
</blockquote>

<p><i>[
2009-10-23 Detlef Provided wording.
]</i></p>


<blockquote>
<p>
Detlef's wording put in Proposed resolution.  Original wording here:
</p>
<blockquote>
<p>
Change 30.5.1 [thread.condition.condvar] p12, p19 and
30.5.2 [thread.condition.condvarany] p10, p16:
</p>

<blockquote>
<i>Throws:</i> <ins>May throw</ins> <tt>std::system_error</tt> 
<ins>
if a precondition is not met.
</ins>
<del>when the effects or postcondition
cannot be achieved.</del>
</blockquote>
</blockquote>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Leave open, Detlef to provide improved wording.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Replace 30.5.1 [thread.condition.condvar] p12, p19 and
30.5.2 [thread.condition.condvarany] p10, p16:
</p>

<blockquote>
<p><del>
<i>Throws:</i> <tt>std::system_error</tt> when the effects or
postcondition cannot be achieved.
</del></p>
<p><del>
Error conditions:
</del></p>
<ul>
<li><del>
equivalent error condition from <tt>lock.lock()</tt> or <tt>lock.unlock()</tt>.
</del></li>
</ul>

<p><ins>
<i>Throws:</i> It's implementation-defined whether a <tt>std::system_error</tt>
with implementation-defined error condition is thrown if the
precondition is not met.
</ins></p>
</blockquote>






<hr>
<h3><a name="967"></a>967. Various threading bugs #17</h3>
<p><b>Section:</b> 30.3.1.2 [thread.thread.constr] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2009-01-07  <b>Last modified:</b> 2009-10-22</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#thread.thread.constr">active issues</a> in [thread.thread.constr].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.thread.constr">issues</a> in [thread.thread.constr].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
the error handling for the constructor for <tt>condition_variable</tt>
distinguishes lack of memory from lack of other resources, but the error
handling for the thread constructor does not. Is this difference
intentional?
</p>

<p><i>[
Beman has volunteered to provide proposed wording.
]</i></p>


<p><i>[
2009-09-25 Beman provided proposed wording.
]</i></p>


<blockquote>
The proposed resolution assumes <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#962">962</a> has been accepted and
its proposed resolution applied to the working paper.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Move to Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>


<p><span style="font-style: italic;">Change Mutex requirements 30.4.1 [thread.mutex.requirements], 
paragraph 4, as indicated:</span></p>
<blockquote>

<p><i>Error conditions:</i></p>
  <blockquote>

<ul>
<li><del> <code>not_enough_memory</code> &#8212; if there is not enough memory to construct 
the mutex object.</del></li>

<li><code>resource_unavailable_try_again</code> &#8212; if any native handle type 
manipulated is not available.</li>

<li><code>operation_not_permitted</code> &#8212; if the thread does not have the 
necessary permission to change the state of the mutex object.</li>

<li><code>device_or_resource_busy</code> &#8212; if any native handle type 
manipulated is already locked.</li>

<li><code>invalid_argument</code> &#8212; if any native handle type manipulated as 
part of mutex construction is incorrect.</li>
</ul>
  </blockquote>
</blockquote>

<p><span style="font-style: italic;">Change Class condition_variable 30.5.1 [thread.condition.condvar], 
default constructor, as indicated:</span></p>
<blockquote>
  <p><code>condition_variable();</code></p>
  <blockquote>
    <p><i>Effects:</i> Constructs an object of type <code>condition_variable</code>.</p>
    <p><ins><i>Throws:</i> <code>std::system_error</code> when an exception is required (30.2.2 [thread.req.exception])</ins>.</p>
    <p><i>Error conditions:</i></p>
    <blockquote>
    <ul>
      <li><del><code>not_enough_memory</code> &#8212; if a memory limitation prevents 
      initialization.</del></li>
      <li> <code>resource_unavailable_try_again</code> &#8212; if some non-memory 
      resource limitation prevents initialization.</li>
      <li> <code>device_or_resource_busy</code> &#8212; if attempting to initialize a 
      previously-initialized but as of yet undestroyed <code>condition_variable</code>.</li>
    </ul>
    </blockquote>
  </blockquote>
</blockquote>





<hr>
<h3><a name="968"></a>968. Various threading bugs #18</h3>
<p><b>Section:</b> 30.4.1 [thread.mutex.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2009-01-07  <b>Last modified:</b> 2009-10-22</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#thread.mutex.requirements">active issues</a> in [thread.mutex.requirements].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.mutex.requirements">issues</a> in [thread.mutex.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
30.4.1 [thread.mutex.requirements]: several functions are
required to throw exceptions "if the thread does not have the necessary
permission ...". "The necessary permission" is not defined.
</p>

<p><i>[
Summit:
]</i></p>

<blockquote>
Move to open.
</blockquote>


<p><i>[
Beman has volunteered to provide proposed wording.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Moved to Ready with minor word-smithing in the example.
</blockquote>



<p><b>Proposed resolution:</b></p>


<p><i>Change Exceptions 30.2.2 [thread.req.exception] as indicated:</i></p>
<blockquote>
<p>Some functions described in this Clause are 
specified to throw exceptions of type <code>system_error</code> (19.5.5). Such exceptions 
shall be thrown if any of the <i>Error conditions</i> are detected or a call to an operating system or other underlying API 
results in an error that prevents the library function from meeting its specifications.
<i>[Note:</i> See 17.6.4.11 [res.on.exception.handling] for exceptions thrown to report 
storage allocation failures. <i>&#8212;end 
note]</i></p>

<p><ins><i>[Example:</i></ins></p>

<blockquote>

<p><ins>Consider a function in this clause that is specified to throw exceptions of type <code>
system_error</code> and specifies <i>Error conditions</i> that include <code>
operation_not_permitted</code> for a thread that does not have the privilege to 
perform the operation. Assume that, during the execution of this function, an <code>errno</code> 
of <code>EPERM</code> is reported by a POSIX API call used by the 
implementation. Since POSIX specifies an <code>errno</code> of <code>EPERM</code> 
when "the caller does not have the privilege to perform the operation", 
the implementation maps <code>EPERM</code>&nbsp; to an <code>error_condition</code> 
of <code>operation_not_permitted</code> (19.5 [syserr]) and an exception of type <code>
system_error</code> is thrown. </ins></p>

</blockquote>

<p><ins><i>&#8212;end example]</i></ins></p>

<p><span style="font-style: italic;">Editorial note: For the sake of exposition, 
the existing text above is shown with the changes proposed in issues 962 and 967. The 
proposed additional example is independent of whether or not the 962 and 967 
proposed resolutions are accepted.</span></p>

</blockquote>

<p><span style="font-style: italic;">Change Mutex requirements 30.4.1 [thread.mutex.requirements], 
paragraph 4, as indicated:</span></p>

<blockquote>

<p>&#8212; <code>operation_not_permitted</code> &#8212; if the thread does not have the 
<del>necessary permission to change the state of the mutex object</del> <ins>privilege to perform the operation</ins>.</p>

</blockquote>

<p><span style="font-style: italic;">Change Mutex requirements 30.4.1 [thread.mutex.requirements], 
paragraph 12, as indicated:</span></p>

<blockquote>

<p>&#8212; <code>operation_not_permitted</code> &#8212; if the thread does not have the 
<del>necessary permission to change the state of the mutex</del> <ins>privilege to perform the operation</ins>.</p>

</blockquote>






<hr>
<h3><a name="974"></a>974. <tt>duration&lt;double&gt;</tt> should not implicitly convert to <tt>duration&lt;int&gt;</tt></h3>
<p><b>Section:</b> 20.9.3.1 [time.duration.cons] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-01-21  <b>Last modified:</b> 2009-10-26</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The following code should not compile because it involves implicit truncation
errors (against the design philosophy of the <tt>duration</tt> library).
</p>

<blockquote><pre>duration&lt;double&gt; d(3.5);
duration&lt;int&gt; i = d;  <font color="#c80000">// implicit truncation, should not compile</font>
</pre></blockquote>

<p>
This intent was codified in the example implementation which drove this proposal
but I failed to accurately translate the code into the specification in this
regard.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We agree with the proposed resolution.
</p>
<p>
Move to Tentatively Ready.
</p>
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
Moved from Tentatively Ready to Open only because the wording needs to be
improved for enable_if type constraining, possibly following Robert's
formula.
</blockquote>

<p><i>[
2009-08-01 Howard adds:
]</i></p>


<blockquote>
Addressed by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1177">1177</a>.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Not completely addressed by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1177">1177</a>.  Move to Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 20.9.3.1 [time.duration.cons], p4:
</p>

<blockquote>
<pre>template &lt;class Rep2, class Period2&gt; 
  duration(const duration&lt;Rep2, Period2&gt;&amp; d);
</pre>
<blockquote>
-4- <i>Requires:</i> <tt>treat_as_floating_point&lt;rep&gt;::value</tt>
shall be <tt>true</tt> or <ins>both</ins> <tt>ratio_divide&lt;Period2,
period&gt;::type::den</tt> shall be 1
<ins>and <tt>treat_as_floating_point&lt;Rep2&gt;::value</tt>
shall be <tt>false</tt></ins>.
Diagnostic required.
[<i>Note:</i> This requirement prevents implicit truncation error when
converting between integral-based <tt>duration</tt> types. Such a
construction could easily lead to confusion about the value of the
<tt>duration</tt>. -- <i>end note</i>]
</blockquote>
</blockquote>





<hr>
<h3><a name="978"></a>978. Hashing smart pointers</h3>
<p><b>Section:</b> 20.7.16 [unord.hash] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-02-02  <b>Last modified:</b> 2009-10-27</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#unord.hash">active issues</a> in [unord.hash].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#unord.hash">issues</a> in [unord.hash].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses UK 208</b></p>
<p>
I don't see an open issue on supporting <tt>std::hash</tt> for smart pointers
(<tt>unique_ptr</tt> and <tt>shared_ptr</tt> at least).
</p>
<p>
It seems reasonable to at least expect support for the smart
pointers, especially as they support comparison for use in ordered
associative containers.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Howard points out that the client can always supply a custom hash function.
</p>
<p>
Alisdair replies that the smart pointer classes are highly likely
to be frequently used as hash keys.
</p>
<p>
Bill would prefer to be conservative.
</p>
<p>
Alisdair mentions that this issue may also be viewed as a subissue or
duplicate of issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1025">1025</a>.
</p>
<p>
Move to Open, and recommend the issue be deferred until after the next
Committee Draft is issued.
</p>
</blockquote>

<p><i>[
2009-05-31 Peter adds:
]</i></p>


<blockquote>
<blockquote>
Howard points out that the client can always supply a custom hash function.
</blockquote>
<p>
Not entirely true. The client cannot supply the function that hashes the
address of the control block (the equivalent of the old <tt>operator&lt;</tt>, now
proudly carrying the awkward name of '<tt>owner_before</tt>'). Only the
implementation can do that, not necessarily via specializing <tt>hash&lt;&gt;</tt>, of
course.
</p>
<p>
This hash function makes sense in certain situations for <tt>shared_ptr</tt>
(when one needs to switch from <tt>set/map</tt> using ownership ordering to
<tt>unordered_set/map</tt>) and is the only hash function that makes sense for
<tt>weak_ptr</tt>.
</p>
</blockquote>

<p><i>[
2009-07-28 Alisdair provides wording.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Move to Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add the following declarations to the synopsis of <tt>&lt;memory&gt;</tt>
in 20.8 [memory]
</p>

<blockquote><pre>// 20.8.10.X hash support
template &lt;class T&gt; struct hash;
template &lt;class T, class D&gt; struct hash&lt;unique_ptr&lt;T,D&gt;&gt;;
template &lt;class T&gt; struct hash&lt;shared_ptr&lt;T&gt;&gt;;
</pre></blockquote>

<p>
Add a new subclause 20.8.10.X hash support
</p>

<blockquote>
<p>
20.8.10.X hash support [util.smartptr.hash]
</p>

<pre>template &lt;class T, class D&gt; struct hash&lt;unique_ptr&lt;T,D&gt;&gt;;
</pre>

<blockquote>
A partial specialization of the class template <tt>hash</tt> (20.7.16 [unord.hash]) shall be provided for instances of the
<tt>unique_ptr</tt> template suitable for use as a key in unordered
associative containers (23.5 [unord]) if and only if there is a
<tt>hash</tt> specialization available for the type <tt>D::pointer</tt>.
For an object <tt>p</tt> of type <tt>unqiue_ptr&lt;T,D&gt;</tt> the
<tt>hash</tt> shall evaluate to the same value as <tt>hash&lt;typename
D::pointer&gt;{}(p.get())</tt>.
</blockquote>

<pre>template &lt;class T&gt; struct hash&lt;shared_ptr&lt;T&gt;&gt;;
</pre>

<blockquote>
A partial specialization of the class template <tt>hash</tt> (20.7.16 [unord.hash])
shall be provided for instances of the <tt>shared_ptr</tt> template
suitable for use as a key in unordered associative containers
(23.5 [unord]). For an object <tt>p</tt> of type <tt>shared_ptr&lt;T&gt;</tt>
the <tt>hash</tt> shall evaluate
to the same value as <tt>hash&lt;T*&gt;{}(p.get())</tt>.
</blockquote>
</blockquote>





<hr>
<h3><a name="983"></a>983. <tt>unique_ptr</tt> reference deleters should not be moved from</h3>
<p><b>Section:</b> 20.8.14.2 [unique.ptr.single] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-02-10  <b>Last modified:</b> 2009-10-21</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#unique.ptr.single">active issues</a> in [unique.ptr.single].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#unique.ptr.single">issues</a> in [unique.ptr.single].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Dave brought to my attention that when a <tt>unique_ptr</tt> has a non-const reference
type deleter, move constructing from it, even when the <tt>unique_ptr</tt> containing
the reference is an rvalue, could have surprising results:
</p>

<blockquote><pre>D d(some-state);
unique_ptr&lt;A, D&amp;&gt; p(new A, d);
unique_ptr&lt;A, D&gt; p2 = std::move(p);
<font color="#c80000">// has d's state changed here?</font>
</pre></blockquote>

<p>
I agree with him.  It is the <tt>unique_ptr</tt> that is the rvalue, not the
deleter.  When the deleter is a reference type, the <tt>unique_ptr</tt> should
respect the "lvalueness" of the deleter.
</p>

<p>
Thanks Dave.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Seems correct, but complicated enough that we recommend moving to Review.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Move to Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 20.8.14.2.1 [unique.ptr.single.ctor], p20-21
</p>

<blockquote>
<pre>template &lt;class U, class E&gt; unique_ptr(unique_ptr&lt;U, E&gt;&amp;&amp; u);
</pre>

<blockquote>

<p>
-20- <i>Requires:</i> If <tt><del>D</del> <ins>E</ins></tt> is not a reference type,
construction of the deleter <tt>D</tt> from an rvalue of type <tt>E</tt>
shall be well formed and shall not throw an exception.
<ins>
Otherwise <tt>E</tt> is a reference type and construction of the deleter
<tt>D</tt> from an lvalue of type <tt>E</tt> shall be well formed and
shall not throw an exception.
</ins>
If <tt>D</tt> is
a reference type, then <tt>E</tt> shall be the same type as <tt>D</tt>
(diagnostic required). <tt>unique_ptr&lt;U, E&gt;::pointer</tt> shall be
implicitly convertible to <tt>pointer</tt>. [<tt>Note:</tt> These
requirements imply that <tt>T</tt> and <tt>U</tt> are complete types.
<i>-- end note</i>]
</p>

<p>
-21- <i>Effects:</i> Constructs a <tt>unique_ptr</tt> which owns the
pointer which <tt>u</tt> owns (if any). If the deleter
<ins><tt>E</tt></ins> is not a reference type, <del>it</del> <ins>this
deleter</ins> is move constructed from <tt>u</tt>'s deleter, otherwise
<del>the reference</del> <ins>this deleter</ins> is copy constructed
from <tt>u</tt>.'s deleter. After the construction, <tt>u</tt> no longer
owns a pointer. [<i>Note:</i> The deleter constructor can be implemented
with <tt>std::forward&lt;<del>D</del><ins>E</ins>&gt;</tt>. <i>-- end
note</i>]
</p>

</blockquote>
</blockquote>

<p>
Change 20.8.14.2.3 [unique.ptr.single.asgn], p1-3
</p>

<blockquote>
<pre>unique_ptr&amp; operator=(unique_ptr&amp;&amp; u);
</pre>
<blockquote>

<p>
-1- <i>Requires:</i> <ins>If the deleter <tt>D</tt> is not a reference type,</ins>
<del>A</del><ins>a</ins>ssignment of the deleter <tt>D</tt> from an rvalue <tt>D</tt> shall not throw an exception.
<ins>
Otherwise the deleter <tt>D</tt> is a reference type,
and assignment of the deleter <tt>D</tt> from an lvalue <tt>D</tt> shall not throw an exception.</ins>
</p>

<p>
-2- <i>Effects:</i> reset(u.release()) followed by
a<ins>n</ins> <del>move</del> assignment from <del><tt>u</tt>'s deleter to this deleter</del>
<ins><tt>std::forward&lt;D&gt;(u.get_deleter())</tt></ins>.
</p>

<p>
-3- <i>Postconditions:</i> This <tt>unique_ptr</tt> now owns the pointer
which <tt>u</tt> owned, and <tt>u</tt> no longer owns it. <del>[<i>Note:</i> If
<tt>D</tt> is a reference type, then the referenced lvalue deleters are
move assigned. <i>-- end note</i>]</del>
</p>
</blockquote>
</blockquote>

<p>
Change 20.8.14.2.3 [unique.ptr.single.asgn], p6-7
</p>

<blockquote>
<pre>template &lt;class U, class E&gt; unique_ptr&amp; operator=(unique_ptr&lt;U, E&gt;&amp;&amp; u);
</pre>
<blockquote>

<p>
<i>Requires:</i> <ins>If the deleter <tt>E</tt> is not a reference type,</ins>
<del>A</del><ins>a</ins>ssignment of the deleter <tt>D</tt> from an rvalue
<tt><del>D</del><ins>E</ins></tt> shall not throw an exception.
<ins>
Otherwise the deleter <tt>E</tt> is a reference type,
and assignment of the deleter <tt>D</tt> from an lvalue <tt>E</tt> shall not throw an exception.</ins>
<tt>unique_ptr&lt;U, E&gt;::pointer</tt> shall be implicitly convertible to <tt>pointer</tt>.
[<i>Note:</i> These requirements imply that <tt>T</tt> and <tt>U&gt;</tt>
are complete types. <i>-- end note</i>]
</p>

<p>
<i>Effects:</i> <tt>reset(u.release())</tt> followed by
a<ins>n</ins> <del>move</del> assignment from <del><tt>u</tt>'s deleter to this deleter</del>
<ins><tt>std::forward&lt;E&gt;(u.get_deleter())</tt></ins>.
<del>If either
<tt>D</tt> or <tt>E</tt> is a reference type, then the referenced lvalue
deleter participates in the move assignment.</del>
</p>

</blockquote>
</blockquote>






<hr>
<h3><a name="985"></a>985. Allowing throwing move</h3>
<p><b>Section:</b> 23.2.1 [container.requirements.general] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Rani Sharoni <b>Opened:</b> 2009-02-12  <b>Last modified:</b> 2009-10-20</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#container.requirements.general">active issues</a> in [container.requirements.general].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#container.requirements.general">issues</a> in [container.requirements.general].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<b>Introduction</b>
</p>

<p>This proposal is meant to resolve potential regression of the
<a href="" ref="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2800.pdf">N2800</a>
draft, see
next section, and to relax the requirements for containers of types with
throwing move constructors.</p>

<p>The basic problem is that some containers operations, like <tt>push_back</tt>,
have a strong exception safety
guarantee (i.e. no side effects upon exception) that are not achievable when
throwing move constructors are used since there is no way to guarantee revert
after partial move. For such operations the implementation can at most provide
the basic guarantee (i.e. valid but unpredictable) as it does with multi
copying operations (e.g. range insert).</p>

<p>For example, <tt>vector&lt;T&gt;::push_back()</tt> (where <tt>T</tt> has a move
constructor) might resize the <tt>vector</tt> and move the objects to the new underlying
buffer. If move constructor throws it might
not be possible to recover the throwing object or to move the old objects back to
the original buffer.</p>

<p>The current draft is explicit by disallowing throwing move
for some operations (e.g. <tt>vector&lt;&gt;::reserve</tt>) and not clear about other
operations mentioned in 23.2.1 [container.requirements.general]/10
(e.g. single element <tt>insert</tt>): it guarantees strong exception
safety without explicitly disallowing a throwing move constructor.
</p>

<p>
<b>Regression</b>
</p>

<p>This section only refers to cases in which the contained object
is by itself a standard container.</p>

<p>Move constructors of standard containers are allowed to throw and therefore
existing operations are broken, compared with C++03, due to move optimization.
(In fact existing implementations like Dinkumware are actually throwing).</p>

<p>For example, <tt>vector&lt; list&lt;int&gt; &gt;::reserve</tt> yields
undefined behavior since <tt>list&lt;int&gt;</tt>'s move constructor is allowed to throw.
On the other hand, the same operation has strong exception safety guarantee in
C++03.</p>

<p>There are few options to solve this regression:</p>

<ol>
<li>
Disallow throwing move and throwing default constructor
</li>

<li>
Disallow throwing move but disallowing usage after move
</li>

<li>
Special casing
</li>

<li>
Disallow throwing move and making it optional
</li>

</ol>

<p>Option 1 is suggested by proposal
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2815.html">N2815</a>
but it might not be applicable for existing implementations for which
containers default constructors are throwing.</p>

<p>Option 2 limits the usage significantly and it's error prone
by allowing zombie objects that are nothing but destructible (e.g. no <tt>clear()</tt>
is allowed after move). It also potentially complicates the implementation by
introducing special state.</p>

<p>Option 3 is possible, for example, using default
construction and <tt>swap</tt> instead of move for standard containers case. The
implementation is also free to provide special hidden operation for non
throwing move without forcing the user the cope with the limitation of option-2
when using the public move.</p>

<p>Option 4 impact the efficiency in all use cases due to rare throwing move.</p>

<p>The proposed wording will imply option 1 or 3 though option 2 is also
achievable using more wording. I personally oppose to option 2 that has impact
on usability.</p>

<p>
<b>Relaxation for user types</b>
</p>

<p>Disallowing throwing move constructors in general seems very restrictive
since, for example, common implementation of move will be default construction
+ <tt>swap</tt> so move will throw if the
default constructor will throw. This is currently the case with the Dinkumware
implementation of node based containers (e.g. <tt>std::list</tt>)
though this section doesn't refer to standard types.</p>

<p>For throwing move constructors it seem that the implementation should have
no problems to provide the basic guarantee instead of the strong one. It's
better to allow throwing move constructors with basic guarantee than to
disallow it silently (compile and run), via undefined behavior.</p>

<p>There might still be cases in which the relaxation will break existing generic
code that assumes the strong guarantee but it's broken either way given a
throwing move constructor since this is not a preserving optimization. </p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Bjarne comments (referring to his draft paper):
"I believe that my suggestion simply solves that.
Thus, we don't need a throwing move."
</p>
<p>
Move to Open and recommend it be deferred until after the next
Committee Draft is issued.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Should wait to get direction from Dave/Rani
(<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2983.html">N2983</a>).
</blockquote>



<p><b>Proposed resolution:</b></p>

<p>
23.2.1 [container.requirements.general]  paragraph 10 add footnote:
</p>

<blockquote>
<p>
-10- Unless otherwise specified (see 23.1.4.1, 23.1.5.1, 23.2.2.3, and
23.2.6.4) all container types defined in this Clause meet the following
additional requirements:
</p>
<ul>
<li>...</li>
</ul>

<p>
<ins>[<i>Note</i>: for compatibility with C++
2003, when "no effect" is required, standard containers should not use the
value_type's throwing move constructor when the contained object is by itself a
standard container. -- <i>end note</i>]</ins>
</p>

</blockquote>

<p>23.2.5.1 [unord.req.except] change paragraph 2 to say: </p>

<blockquote>
<p>
-2- For unordered associative containers, if an exception is
thrown by any operation other than the container's hash function from within an
<tt>insert()</tt> function inserting a single element, the <tt>insert()</tt>
function has no effect<ins> unless the exception is thrown by the contained
object move constructor</ins>.
</p>

<p>
-4- For unordered associative containers, if an exception is
thrown from within a <tt>rehash()</tt> function other than by the container's hash
function or comparison function, the <tt>rehash()</tt> function has no effect
<ins>unless the exception is thrown by the contained
object move constructor</ins>.</p>

</blockquote>

<p>
23.3.2.3 [deque.modifiers] change paragraph 2 to say:
</p>

<blockquote>
-2- <i>Remarks:</i> If an exception is thrown other than by
the copy constructor<ins>, move constructor</ins>
or assignment operator of <tt>T</tt>
there are no effects.
<ins>If an exception is thrown by <tt>push_back()</tt> or <tt>emplace_back()</tt>
function, that function has no effects unless the exception is thrown by
the move constructor of <tt>T</tt>.</ins>
</blockquote>

<p>
23.3.2.3 [deque.modifiers] change paragraph 6 to say:
</p>

<blockquote>
-6- <i>Throws:</i> Nothing unless an exception is thrown by the copy
constructor<ins>, move constructor</ins> or assignment operator of <tt>T</tt>.
</blockquote>

<p>
23.3.6.2 [vector.capacity] remove paragraph 2
</p>

<blockquote>
<del>-2- <i>Requires:</i> If <tt>value_type</tt> has a move constructor,
that constructor shall not throw any exceptions.</del>
</blockquote>

<p>
23.3.6.2 [vector.capacity] paragraph 3 change to say:
</p>

<blockquote>
-3- <i>Effects:</i> A directive that informs a <tt>vector</tt>
of a planned change in size, so
that it can manage the storage allocation accordingly. After <tt>reserve()</tt>,
<tt>capacity()</tt> is greater or equal to the argument of <tt>reserve</tt>
if reallocation happens; and equal
to the previous value of <tt>capacity()</tt>
otherwise. Reallocation happens at this point if and only if the current
capacity is less than the argument of <tt>reserve()</tt>.
If an exception is thrown, there are no effects<ins>
unless the exception is thrown by the contained object move constructor</ins>.
</blockquote>

<p>
23.3.6.2 [vector.capacity] paragraph 12 change to say:
</p>

<blockquote>
-12- <i>Requires:</i> <del>If <tt>value_type</tt> has a move constructor,
that constructor shall not throw any exceptions.</del>
<ins>If an exception is thrown, there are no effects unless the exception is thrown by
the contained object move constructor.</ins>
</blockquote>

<p>
23.3.6.4 [vector.modifiers] change paragraph 1 to say:
</p>

<blockquote>
-1- <del><i>Requires:</i> If <tt>value_type</tt> has a move constructor,
that constructor shall not throw any exceptions.</del>
<ins><i>Remarks:</i> If an exception is thrown by <tt>push_back()</tt>
or <tt>emplace_back()</tt> function, that function has no effect unless the
exception is thrown by the move constructor of <tt>T</tt>.</ins>
</blockquote>

<p>
23.3.6.4 [vector.modifiers] change paragraph 2 to say:
</p>

<blockquote>
-2- <i>Remarks:</i> Causes reallocation if the new size is greater than
the old capacity. If no reallocation happens, all the iterators and
references before the insertion point remain valid. If an exception is
thrown other than by the copy constructor<ins>, move constructor</ins>
or assignment operator of <tt>T</tt> or by any <tt>InputIterator</tt>
operation there are no effects.
</blockquote>

<p>
23.3.6.4 [vector.modifiers] change paragraph 6 to say:
</p>

<blockquote>
-6- <i>Throws:</i> Nothing unless an exception is thrown by the copy
constructor<ins>, move constructor</ins> or assignment operator of <tt>T</tt>.
</blockquote>






<hr>
<h3><a name="987"></a>987. <tt>reference_wrapper</tt> and function types</h3>
<p><b>Section:</b> 20.7.5 [refwrap] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-02-18  <b>Last modified:</b> 2009-10-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#refwrap">issues</a> in [refwrap].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The synopsis in 20.7.5 [refwrap] says:
</p>

<blockquote><pre>template &lt;<b>ObjectType</b> T&gt; class reference_wrapper
...
</pre></blockquote>

<p>
And then paragraph 3 says:
</p>

<blockquote>
<p>
The template instantiation <tt>reference_wrapper&lt;T&gt;</tt> shall be
derived from <tt>std::unary_function&lt;T1, R&gt;</tt> only if the type
<tt>T</tt> is any of the following:
</p>

<ul>
<li>
a <b>function type</b> or a pointer to function type taking one argument of
type <tt>T1</tt> and returning <tt>R</tt>
</li>
</ul>
</blockquote>

<p>
But function types are not <tt>ObjectType</tt>s.
</p>

<p>
Paragraph 4 contains the same contradiction.
</p>

<p><i>[
Post Summit:
]</i></p>


<blockquote>
<p>
Jens: restricted reference to ObjectType
</p>
<p>
Recommend Review.
</p>
</blockquote>

<p><i>[
Post Summit, Peter adds:
]</i></p>


<blockquote>
<p>
In <a href="https://svn.boost.org/trac/boost/ticket/1846">https://svn.boost.org/trac/boost/ticket/1846</a>
however Eric Niebler makes the very reasonable point that <tt>reference_wrapper&lt;F&gt;</tt>,
where <tt>F</tt> is a function type, represents a reference to a function,
a legitimate entity. So <tt>boost::ref</tt> was changed to allow it.
</p>
<p>
<a href="https://svn.boost.org/trac/boost/browser/trunk/libs/bind/test/ref_fn_test.cpp">https://svn.boost.org/trac/boost/browser/trunk/libs/bind/test/ref_fn_test.cpp</a>
</p>
<p>
Therefore, I believe an alternative proposed resolution for issue 987 could simply
allow <tt>reference_wrapper</tt> to be used with function types.
</p>
</blockquote>

<p><i>[
Post Summit, Howard adds:
]</i></p>


<blockquote>
<p>
I agree with Peter (and Eric).  I got this one wrong on my first try.  Here
is code that demonstrates how easy (and useful) it is to instantiate
<tt>reference_wrapper</tt> with a function type:
</p>

<blockquote><pre>#include &lt;functional&gt;

template &lt;class F&gt;
void test(F f);

void f() {}

int main()
{
    test(std::ref(f));
}
</pre></blockquote>

<p>
Output (link time error shows type of <tt>reference_wrapper</tt> instantiated
with function type):
</p>

<blockquote><pre>Undefined symbols:
  "void test&lt;std::reference_wrapper&lt;void ()()&gt; &gt;(std::reference_wrapper&lt;void ()()&gt;)",...
</pre></blockquote>

<p>
I've taken the liberty of changing the proposed wording to allow function types
and set to Open.  I'll also freely admit that I'm not positive <tt>ReferentType</tt>
is the correct concept.
</p>

</blockquote>



<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Howard observed that <tt>FunctionType</tt>,
a concept not (yet?) in the Working Paper,
is likely the correct constraint to be applied.
However, the proposed resolution provides an adequate approximation.
</p>
<p>
Move to Review.
</p>
</blockquote>

<p><i>[
2009-05-23 Alisdair adds:
]</i></p>


<blockquote>
<p>
By constraining to <tt>PointeeType</tt> we rule out the ability for <tt>T</tt> to be a
reference, and call in reference-collapsing.  I'm not sure if this is
correct and intended, but would like to be sure the case was considered.
</p>
<p>
Is dis-allowing reference types and the
implied reference collapsing the intended result?
</p>
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
Moved from Review to Open only because the wording needs to be
tweaked for concepts removal.
</blockquote>

<p><i>[
2009-10-14 Daniel provided de-conceptified wording.
]</i></p>


<p><i>[
2009-10 post-Santa Cruz:
]</i></p>


<blockquote>
Move to Tentatively Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 20.7.5 [refwrap]/1 as indicated:
</p>

<blockquote>
<tt>reference_wrapper&lt;T&gt;</tt> is a <tt>CopyConstructible</tt> and
<tt><ins>Copy</ins>Assignable</tt> wrapper around a
reference to an object <ins>or function</ins> of type <tt>T</tt>.
</blockquote>





<p><b>Rationale:</b></p>
<p>
a) The occurrence of <tt>T&amp;</tt> in the function signature auto-implies
<tt>std::ReferentType</tt>,
this is due to  [temp.req.impl]/4 bullet 4
</p>
<p>
b) The occurrence of the constrained template <tt>reference_wrapper&lt;T&gt;</tt> in
the remaining
signatures lets kick in  [temp.req.impl]/4 bullet 1 and adds *all* requirements of
this template. But we need to add at least *one* requirement (and it
was an arbitrary,
but natural decision to require <tt>std::PointeeType</tt> here) to *activate*
this. If we hadn't done
this, we were in unconstrained mode!
</p>





<hr>
<h3><a name="996"></a>996. Move operation not well specified</h3>
<p><b>Section:</b> 17 [library] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> David Abrahams <b>Opened:</b> 2009-03-06  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There are lots of places in the standard where we talk about "the move
constructor" but where we mean "the move operation," i.e.  <tt>T( move( x ) )</tt>.
</p>
<p>
We also don't account for whether that operation modifies <tt>x</tt> or not, and
we need to.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Move to Open, pending proposed wording from Dave for further
review.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="999"></a>999. Taking the address of a function</h3>
<p><b>Section:</b> 20.8.13 [specialized.algorithms] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Peter Dimov <b>Opened:</b> 2009-03-09  <b>Last modified:</b> 2009-10-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#specialized.algorithms">issues</a> in [specialized.algorithms].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The same fix (reference <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#987">987</a>) may be applied to <tt>addressof</tt>, which is also constrained to
<tt>ObjectType</tt>. (That was why <tt>boost::ref</tt> didn't work with functions - it
tried to apply <tt>boost::addressof</tt> and the <tt>reinterpret_cast&lt;char&amp;&gt;</tt>
implementation of <tt>addressof</tt> failed.)
</p>



<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We agree.
</p>
<p>
Move to Tentatively Ready.
</p>
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
Moved from Tentatively Ready to Open only because the wording needs to be
tweaked for concepts removal.
</blockquote>

<p><i>[
2009-10-10 Daniel updates wording to concept-free.
]</i></p>


<p><i>[
2009-10 post-Santa Cruz:
]</i></p>


<blockquote>
Move to Tentatively Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p><i>[
The resolution assumes that <tt>addressof</tt> is reintroduced as described in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2946.pdf">n2946</a>
]</i></p>


<p>
In 20.8.13 [specialized.algorithms] change as described:
</p>

<blockquote><pre>template &lt;class T&gt; T* addressof(T&amp; r);
</pre>
<blockquote>
<i>Returns:</i> The actual address of the object <ins>or function</ins>
referenced by <tt>r</tt>, even in the
presence of an overloaded <tt>operator&amp;</tt>.
</blockquote>
</blockquote>




<p><b>Rationale:</b></p>
<p>
a) The occurrence of <tt>T&amp;</tt> in the function signature auto-implies
<tt>std::ReferentType</tt>,
this is due to  [temp.req.impl]/4 bullet 4
</p>





<hr>
<h3><a name="1008"></a>1008. <tt>nested_exception</tt> wording unclear</h3>
<p><b>Section:</b> 18.8.6 [except.nested] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11  <b>Last modified:</b> 2009-10-22</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#except.nested">active issues</a> in [except.nested].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#except.nested">issues</a> in [except.nested].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses JP 31</b></p>

<p>
It is difficult to understand in which case <tt>nested_exception</tt> is applied.
</p>

<p><i>[
Summit:
]</i></p>

 
<blockquote>
Alisdair will add an example in an update to
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2619.pdf">N2619</a>.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
It doesn't appear that N2619 really addresses this. Alisdair to propose wording.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1011"></a>1011. <tt>next/prev</tt> wrong iterator type</h3>
<p><b>Section:</b> 24.4.4 [iterator.operations] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11  <b>Last modified:</b> 2009-10-22</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#iterator.operations">active issues</a> in [iterator.operations].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#iterator.operations">issues</a> in [iterator.operations].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 271</b></p>

<p>
<tt>next/prev</tt> return an incremented iterator without changing the value of
the original iterator. However, even this may invalidate an
<tt>InputIterator</tt>. A <tt>ForwardIterator</tt> is required to guarantee the
'multipass' property.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution.
Move to Tentatively Ready.
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
Moved from Tentatively Ready to Open only because the wording needs to be
tweaked for concepts removal.
</blockquote>

<p><i>[
2009-10-14 Daniel provided de-conceptified wording.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Moved to Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>


<ol>
<li>
<p>
Change header <tt>&lt;iterator&gt;</tt> synopsis 24.3 [iterator.synopsis] as indicated:
</p>

<blockquote><pre>// 24.4.4, iterator operations:
...
template &lt;class <del>Input</del><ins>Forward</ins>Iterator&gt;
  <del>Input</del><ins>Forward</ins>Iterator
  next(<del>Input</del><ins>Forward</ins>Iterator x, typename std::iterator_traits&lt;<del>Input</del><ins>Forward</ins>Iterator&gt;::difference_type n = 1);
</pre></blockquote>
</li>

<li>
<p>
Change 24.4.4 [iterator.operations] before p.6 as indicated:
</p>

<blockquote><pre>template &lt;class <del>Input</del><ins>Forward</ins>Iterator&gt;
  <del>Input</del><ins>Forward</ins>Iterator
  next(<del>Input</del><ins>Forward</ins>Iterator x, typename std::iterator_traits&lt;<del>Input</del><ins>Forward</ins>Iterator&gt;::difference_type n = 1);
</pre></blockquote>
</li>
</ol>






<hr>
<h3><a name="1030"></a>1030. Response to JP 44</h3>
<p><b>Section:</b> 20.8.15.5 [util.smartptr.shared.atomic] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11  <b>Last modified:</b> 2009-10-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses JP 44</b></p>

<p>
The 1st parameter <tt>p</tt> and 2nd parameter <tt>v</tt> is now
<tt>shared_ptr&lt;T&gt;*</tt>.
</p>
<p>
It should be <tt>shared_ptr&lt;T&gt;&amp;</tt>, or if these are
<tt>shared_ptr&lt;T&gt;*</tt> then add the "<tt>p</tt> shall not be a
null pointer" at the requires.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Agree. All of the functions need a requirement that <tt>p</tt> (or
<tt>v</tt>) is a pointer to a valid object.
</blockquote>

<p><i>[
2009-07 post-Frankfurt:
]</i></p>


<blockquote>
<p>
Lawrence explained that these signatures match the regular atomics. The
regular atomics must not use references because these signatures are
shared with C. The decision to pass shared_ptrs by pointer rather than
by reference was deliberate and was motivated by the principle of least
surprise.
</p>
<p>
Lawrence to write wording that requires that the pointers not be null.
</p>
</blockquote>

<p><i>[
2009-09-20 Lawrence provided wording:
]</i></p>


<blockquote>
<p>
The parameter types for atomic shared pointer access
were deliberately chosen to be pointers
to match the corresponding parameters of the atomics chapter.
Those in turn were deliberately chosen
to match C functions,
which do not have reference parameters.
</p>
<p>
We adopt the second suggestion,
to require that such pointers not be null.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Moved to Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
In section "<code>shared_ptr</code> atomic access"
20.8.15.5 [util.smartptr.shared.atomic], add to each function the
following clause.
</p>
<blockquote><p>
<i>Requires:</i> <code>p</code> shall not be null.
</p></blockquote>





<hr>
<h3><a name="1033"></a>1033. <tt>thread::join()</tt> effects?</h3>
<p><b>Section:</b> 30.3.1.5 [thread.thread.member] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alberto Ganesh Barbati <b>Opened:</b> 2009-03-12  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#thread.thread.member">active issues</a> in [thread.thread.member].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.thread.member">issues</a> in [thread.thread.member].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
While looking at <tt>thread::join()</tt> I think I spotted a couple of
possible defects in the specifications. I could not find a previous
issue or NB comment about that, but I might have missed it.
</p>

<p>
The postconditions clause for <tt>thread::join()</tt> is:
</p>

<blockquote>
<i>Postconditions:</i> If <tt>join()</tt> throws an exception, the value
returned by <tt>get_id()</tt> is unchanged. Otherwise, <tt>get_id() == id()</tt>.
</blockquote>

<p>
and the throws clause is:
</p>

<blockquote>
<i>Throws:</i> <tt>std::system_error</tt> when the postconditions cannot be achieved.
</blockquote>

<p>
Now... how could the postconditions <em>not</em> be achieved?
It's just a matter of resetting the value of <tt>get_id()</tt> or leave it
unchanged! I bet we can always do that. Moreover, it's a chicken-and-egg
problem: in order to decide whether to throw or not I depend on the
postconditions, but the postconditions are different in the two cases.
</p>

<p>
I believe the throws clause should be:
</p>

<blockquote>
<i>Throws:</i> <tt>std::system_error</tt> when the effects or postconditions
cannot be achieved.
</blockquote>

<p>
as it is in <tt>detach()</tt>, or, even better, as the postcondition is
trivially satisfiable and to remove the circular dependency:
</p>


<blockquote>
<i>Throws:</i> <tt>std::system_error</tt> if the effects cannot be achieved.
</blockquote>

<p>
Problem is that... ehm... <tt>join()</tt> has no "Effects" clause. Is that intentional?
</p>

<p><i>[
See the thread starting at c++std-lib-23204 for more discussion.
]</i></p>


<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Pete believes there may be some more general language (in frontmatter)
that can address this and related issues such as <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#962">962</a>.
</p>
<p>
Move to Open.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1034"></a>1034. Response to UK 222</h3>
<p><b>Section:</b> 23.2.1 [container.requirements.general] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-12  <b>Last modified:</b> 2009-10-20</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#container.requirements.general">active issues</a> in [container.requirements.general].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#container.requirements.general">issues</a> in [container.requirements.general].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 222</b></p>

<p>
It is not clear what purpose the Requirement tables serve in the
Containers clause. Are they the definition of a library Container? Or
simply a conventient shorthand to factor common semantics into a single
place, simplifying the description of each subsequent container? This
becomes an issue for 'containers' like <tt>array</tt>, which does not meet the
default-construct-to-empty requirement, or <tt>forward_list</tt> which does not
support the size operation. Are these components no longer containers?
Does that mean the remaining requirements don't apply? Or are these
contradictions that need fixing, despite being a clear design decision?
</p>

<p>
Recommend:
</p>

<p>
Clarify all the tables in 23.2 [container.requirements] are
there as a convenience for documentation, rather than a strict set of
requirements. Containers should be allowed to relax specific
requirements if they call attention to them in their documentation. The
introductory text for <tt>array</tt> should be expanded to mention a
default constructed <tt>array</tt> is not empty, and
<tt>forward_list</tt> introduction should mention it does not provide
the required <tt>size</tt> operation as it cannot be implemented
efficiently.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Agree in principle.
</blockquote>

<p><i>[
2009-07 post-Frankfurt:
]</i></p>


<blockquote>
We agree in principle, but we have a timetable. This group feels that
the issue should be closed as NAD unless a proposed resolution is
submitted prior to the March 2010 meeting.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Looked at this and still intend to close as NAD in March
2010 unless there is proposed wording that we like.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1052"></a>1052. Response to UK 281</h3>
<p><b>Section:</b> 24.5.1.3.5 [reverse.iter.opref] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-12  <b>Last modified:</b> 2009-10-22</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 281</b></p>

<p>
The current specification for return value for <tt>reverse_iterator::operator-&gt;</tt>
will always be a true pointer type, but <tt>reverse_iterator</tt> supports proxy
iterators where the pointer type may be some kind of 'smart pointer'.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
<p>
<tt>move_iterator</tt> avoids this problem by returning a value of the wrapped
Iterator type.
study group formed to come up with a suggested resolution.
</p>
<p>
<tt>move_iterator</tt> solution shown in proposed wording.
</p>
</blockquote>

<p><i>[
2009-07 post-Frankfurt:
]</i></p>


<blockquote>
Howard to deconceptize. Move to Review after that happens.
</blockquote>

<p><i>[
2009-08-01 Howard deconceptized:
]</i></p>


<blockquote>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
<p>
We can't think of any reason we can't just define reverse
iterator's pointer types to be the same as the underlying iterator's
pointer type, and get it by calling the right arrow directly.
</p>
<p>
Here is the proposed wording that was replaced:
</p>
<blockquote><pre>template &lt;class Iterator&gt; 
class reverse_iterator { 
  ...
  typedef <del>typename iterator_traits&lt;</del>Iterator<del>&gt;::pointer</del> pointer;
</pre></blockquote>

<p>
Change 24.5.1.3.5 [reverse.iter.opref]:
</p>

<blockquote><pre>pointer operator-&gt;() const;
</pre>
<blockquote>
<i>Returns:</i>
<blockquote><pre><del>&amp;(operator*());</del>
<ins>this-&gt;tmp = current;</ins>
<ins>--this-&gt;tmp;</ins>
<ins>return this-&gt;tmp;</ins>
</pre></blockquote>
</blockquote>
</blockquote>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 24.5.1.3.5 [reverse.iter.opref]:
</p>

<blockquote><pre>pointer operator-&gt;() const;
</pre>
<blockquote>
<i>Returns:</i>
<blockquote><pre><del>&amp;(operator*());</del>
<ins>deref_tmp = current;
--deref_tmp;
return deref_tmp::operator-&gt;();</ins>
</pre></blockquote>
</blockquote>
</blockquote>









<hr>
<h3><a name="1056"></a>1056. Must all Engines and Distributions be Streamable?</h3>
<p><b>Section:</b> 26.5 [rand] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-12  <b>Last modified:</b> 2009-11-03</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand">issues</a> in [rand].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Both the concepts <tt>RandomNumberEngine</tt> and <tt>RandomNumberDistribution</tt> have
requirements to be <tt>InputStreamable</tt> and <tt>OutputStreamable</tt>.
</p>
<p>
I have no problems leaving the WP in an inconsistent state on the best-faith
assumption these concepts will be provided later, however disagree with the
proposers that these constraints are not separable, orthogonal to the basic
concepts of generating random number distributions.
</p>
<p>
These constraints should be dropped, and applied to specific algorithms as
needed.
</p>
<p>
If a more refined concept (certainly deemed useful by the proposers) is
proposed there is no objection, but the basic concept should not require
persistence via streaming.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Move to Open.
</blockquote>

<p><i>[
2009-05-31 Alisdair adds:
]</i></p>


<blockquote>
<p>
Working on constraining the stream iterators, I have a few more observations
to make on the concepts proposed while constraining the random number
facility.
</p>
<p>
While I still believe the concerns are orthogonal, I don't believe the
existing constraints go far enough either!  The goal we want to achieve is
not that a <tt>RandomNumberEngine</tt> / <tt>RandomNumberDistribution</tt> supports the stream
operators, but that it is <tt>Serializable</tt>.  I.e. there is a relationship
between the insert and extract operations that guarantees to restore the
state of the original object.  This implies a coupling of the concepts
together in a broader concept (<tt>Serializable</tt>) with at least one axiom to
assert the semantics.
</p>
<p>
One problem is that <tt>istream</tt> and <tt>ostream</tt> may be fundamentally different
types, although we can hook a relation if we are prepared to drop down to
the <tt>char</tt> type and <tt>char_traits</tt> template parameters.  Doing so ties us to a
form of serialization that demands implementation via the std iostreams
framework, which seems overly prescriptive.  I believe the goal is generally
to support serialization without regard to how it is expressed - although
this is getting even more inventive in terms of concepts we do not have
today.
</p>
</blockquote>

<p><i>[
2009-11-03 Alisdair adds:
]</i></p>


<blockquote>
<p>
I can't find the record in the wiki minutes, but it was agreed at both
Frankfurt and Santa Cruz that this issue is NAD.
</p>
<p>
The agreement in SC was that I would provide you with the rationale (see
below) to include when moving to NAD.
</p>
</blockquote>

<p><i>[
2009-11-03 Howard adds:
]</i></p>


<blockquote>
Moved to Tentatively NAD after 5 positive votes on c++std-lib.
</blockquote>


<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>
The issue suggests a more refined concept should be used if we want to
require streaming, to separate concerns from the basic
<tt>RandomNumberEngine</tt> behaviour.  In Frankfurt it was observed
that <tt>RandomNumberEngine</tt> <em>is</em> that more refined concept,
and the basic concept used in the framework is
<tt>UniformRandomNumberGenerator</tt>, which it refines.
</p>

<p>
We concur, and expect this to have no repurcussions re-writing this
clause now concepts are removed.
</p>





<hr>
<h3><a name="1068"></a>1068. class random_device should be movable</h3>
<p><b>Section:</b> 26.5.6 [rand.device] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-18  <b>Last modified:</b> 2009-10-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.device">issues</a> in [rand.device].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
class <tt>random_device</tt> should be movable.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Move to Open, and recommend this issue be deferred until after the next
Committee Draft is issued.
</blockquote>

<p><i>[
2009-10 post-Santa Cruz:
]</i></p>


<blockquote>
Leave open. Walter to provide drafting as part of his planned paper.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1069"></a>1069. class seed_seq should support efficient move operations</h3>
<p><b>Section:</b> 26.5.7.1 [rand.util.seedseq] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-18  <b>Last modified:</b> 2009-10-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.util.seedseq">issues</a> in [rand.util.seedseq].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
class <tt>seed_seq</tt> should support efficient move operations.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Move to Open, and recommend this issue be deferred until after the next
Committee Draft is issued.
</blockquote>

<p><i>[
2009-10 post-Santa Cruz:
]</i></p>


<blockquote>
Leave open. Walter to provide drafting as part of his planned paper.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1071"></a>1071. is_bind_expression should derive from integral_constant&lt;bool&gt;</h3>
<p><b>Section:</b> 20.7.11.1.1 [func.bind.isbind] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-19  <b>Last modified:</b> 2009-10-26</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Class template is_bind_expression 20.7.11.1.1 [func.bind.isbind]:
</p>

<blockquote><pre>namespace std {
  template&lt;class T&gt; struct is_bind_expression {
    static const bool value = see below;
  };
}
</pre></blockquote>
<p>
<tt>is_bind_expression</tt> should derive from <tt>std::integral_constant&lt;bool&gt;</tt> like
other similar trait types.
</p>

<p><i>[
Daniel adds:
]</i></p>

<blockquote>
We need the same thing for the trait <tt>is_placeholder</tt> as well.
</blockquote>
<p><i>[
2009-03-22 Daniel provided wording.
]</i></p>


<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We recommend this be deferred until after the next Committee Draft is issued.
</p>
<p>
Move to Open.
</p>
</blockquote>

<p><i>[
2009-05-31 Peter adds:
]</i></p>


<blockquote>
<p>
I am opposed to the proposed resolution and to the premise of the issue
in general. The traits's default definitions should NOT derive from
<tt>integral_constant</tt>, because this is harmful, as it misleads people into
thinking that <tt>is_bind_expression&lt;E&gt;</tt> always derives from
<tt>integral_constant</tt>, whereas it may not.
</p>
<p>
<tt>is_bind_expression</tt> and <tt>is_placeholder</tt> allow user
specializations, and in fact, this is their primary purpose. Such user
specializations may not derive from <tt>integral_constant</tt>, and the
places where <tt>is_bind_expression</tt> and <tt>is_placeholder</tt> are
used intentionally do not require such derivation.
</p>
<p>
The long-term approach here is to switch to
<tt>BindExpression&lt;E&gt;</tt> and <tt>Placeholder&lt;P&gt;</tt>
explicit concepts, of course, but until that happens, I say leave them
alone.
</p>
</blockquote>

<p><i>[
2009-10 post-Santa Cruz:
]</i></p>


<blockquote>
Move to Tentatively Ready.  We are comfortable with requiring user specializations
to derive from <tt>integral_constant</tt>.
</blockquote>



<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>
In 20.7.11.1.1 [func.bind.isbind] change as indicated:
</p>
<blockquote><pre>namespace std {
 template&lt;class T&gt; struct is_bind_expression <ins>: integral_constant&lt;bool, <i>see below</i>&gt; { };</ins><del>{
   static const bool value = <i>see below</i>;
 };</del>
}
</pre></blockquote>
</li>
<li>
<p>
In 20.7.11.1.1 [func.bind.isbind]/2 change as indicated:
</p>
<blockquote><pre><del>static const bool value;</del>
</pre>
<blockquote>
-2- <del><tt>true</tt> if <tt>T</tt> is a type returned from <tt>bind</tt>, <tt>false</tt> otherwise.</del>
  <ins>If <tt>T</tt> is a type returned from <tt>bind</tt>, <tt>is_bind_expression&lt;T&gt;</tt> shall
be publicly derived from
        <tt>integral_constant&lt;bool, true&gt;</tt>, otherwise it shall be
publicly derived from
          <tt>integral_constant&lt;bool, false&gt;</tt>.</ins>
</blockquote>
</blockquote>
</li>
<li>
<p>
In 20.7.11.1.2 [func.bind.isplace] change as indicated:
</p>
<blockquote><pre>namespace std {
 template&lt;class T&gt; struct is_placeholder <ins>: integral_constant&lt;int, <i>see below</i>&gt; { };</ins><del>{
   static const int value = <i>see below</i>;
 };</del>
}
</pre></blockquote>
</li>
<li>
<p>
In 20.7.11.1.2 [func.bind.isplace]/2 change as indicated:
</p>
<blockquote><pre><del>static const int value;</del>
</pre>
<blockquote>
-2- <del>value is <tt>J</tt> if <tt>T</tt> is the type of <tt>std::placeholders::_J</tt>, 0 otherwise.</del>
  <ins>If <tt>T</tt> is the type of <tt>std::placeholders::_J</tt>, <tt>is_placeholder&lt;T&gt;</tt>
shall be publicly
          derived from <tt>integral_constant&lt;int, J&gt;</tt> otherwise it shall
be publicly derived
          from <tt>integral_constant&lt;int, 0&gt;</tt>.</ins>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="1076"></a>1076. unary/binary_negate need constraining and move support</h3>
<p><b>Section:</b> 20.7.10 [negators] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-20  <b>Last modified:</b> 2009-10-26</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The class templates <tt>unary/binary_negate</tt> need constraining and move support.
</p>
<p>
Ideally these classes would be deprecated, allowing <tt>unary/binary_function</tt> to
also be deprecated.  However, until a generic negate adaptor is introduced
that can negate any <tt>Callable</tt> type, they must be supported so should be
constrained.  Likewise, they should be movable, and support adopting a
move-only predicate type.
</p>
<p>
In order to preserve ABI compatibility, new rvalue overloads are supplied in
preference to changing the existing pass-by-const-ref to pass-by-value.
</p>
<p>
Do not consider the issue of forwarding mutable lvalues at this point,
although remain open to another issue on the topic.
</p>

<p><i>[
2009-05-01 Daniel adds:
]</i></p>

<blockquote>
<p>
IMO the currently proposed resolution needs some updates
because it is ill-formed at several places:
</p>

<ol>
<li>
<p>
In concept AdaptableUnaryFunction change
</p>
<blockquote><pre>typename X::result_type;
typename X::argument_type;
</pre></blockquote>
<p>
to
</p>
<blockquote><pre>Returnable result_type = typename X::result_type;
typename argument_type = typename X::argument_type;
</pre></blockquote>
<p>
[The replacement "Returnable result_type" instead of "typename
result_type" is non-editorial, but maybe you prefer that as well]
</p>
</li>
<li>
<p>
In concept AdaptableBinaryFunction change
</p>
<blockquote><pre>typename X::result_type;
typename X::first_argument_type;
typename X::second_argument_type;
</pre></blockquote>
<p>
to
</p>
<blockquote><pre>Returnable result_type = typename X::result_type;
typename first_argument_type = typename X::first_argument_type;
typename second_argument_type = typename X::second_argument_type;
</pre></blockquote>
<p>
[The replacement "Returnable result_type" instead of "typename
result_type" is non-editorial, but maybe you prefer that as well.]
</p>
</li>

<li>
<p>
In class unary/binary_function
</p>
<ol type="a">
<li>
I suggest to change "ReturnType" to "Returnable" in both cases.
</li>
<li>
I think you want to replace the remaining occurrences of "Predicate" by "P"
(in both classes in copy/move from a predicate)
</li>
</ol>
</li>
<li>
<p>
I think you need to change the proposed signatures of not1 and not2, because
they would still remain unconstrained: To make them constrained at least a
single requirement needs to be added to enable requirement implication. This
could be done via a dummy ("requires True&lt;true&gt;") or just explicit as follows:
</p>
<ol type="a">
<li>
<blockquote><pre>template &lt;AdaptableUnaryFunction P&gt;
requires Predicate&lt; P, P::argument_type&gt;
unary_negate&lt;P&gt; not1(const P&amp;&amp; pred);
template &lt;AdaptableUnaryFunction P&gt;
requires Predicate&lt; P, P::argument_type &gt;
unary_negate&lt;P&gt; not1(P&amp;&amp; pred);
</pre>
<blockquote>
-3- Returns: unary_negate&lt;P&gt;(pred).
</blockquote>
</blockquote>
<p>
[Don't we want a move call for the second overload as in
</p>
<blockquote><pre>unary_negate&lt;P&gt;(std::move(pred))
</pre></blockquote>
<p>
in the Returns clause ?]
</p>
</li>
<li>
<pre>template &lt;AdaptableBinaryFunction P&gt;
requires Predicate&lt; P, P::first_argument_type, P::second_argument_type &gt;
binary_negate&lt;P&gt; not2(const P&amp; pred);
template &lt;AdaptableBinaryFunction P&gt;
requires Predicate&lt; P, P::first_argument_type, P::second_argument_type &gt;
binary_negate&lt;P&gt; not2(P&amp;&amp; pred);
</pre>
<p>
-5- Returns: binary_negate&lt;P&gt;(pred).
</p>
<p>
[Don't we want a move call for the second overload as in
</p>
<blockquote><pre>binary_negate&lt;P&gt;(std::move(pred))
</pre></blockquote>
<p>
in the Returns clause ?]
</p>
</li>
</ol>
</li>
</ol>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
There is concern that complicating the solution
to preserve the ABI seems unnecessary,
since we're not in general preserving the ABI.
</p>
<p>
We would prefer a separate paper consolidating all Clause 20
issues that are for the purpose of providing constrained versions
of the existing facilities.
</p>
<p>
Move to Open.
</p>
</blockquote>

<p><i>[
2009-10 post-Santa Cruz:
]</i></p>


<blockquote>
Leave open pending the potential move constructor paper. Note that
we consider the "constraining" part NAD Concepts.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add new concepts where appropriate::
</p>

<blockquote><pre>auto concept AdaptableUnaryFunction&lt; typename X &gt; {
  typename X::result_type;
  typename X::argument_type;
}

auto concept AdaptableBinaryFunction&lt; typename X &gt; {
  typename X::result_type;
  typename X::first_argument_type;
  typename X::second_argument_type;
}
</pre></blockquote>

<p>
Revise as follows:
</p>

<p>
Base 20.7.3 [base] (Only change is constrained Result)
</p>

<blockquote>
<p>
-1-  The following classes are provided to simplify the typedefs of the
argument and result types:
</p>
<pre>namespace std {
  template &lt;class Arg, <del>class</del> <ins>ReturnType</ins> Result&gt;
  struct unary_function {
     typedef Arg    argument_type;
     typedef Result result_type;
  };

  template &lt;class Arg1, class Arg2, <del>class</del> <ins>ReturnType</ins> Result&gt;
  struct binary_function {
     typedef Arg1   first_argument_type;
     typedef Arg2   second_argument_type;
     typedef Result result_type;
  };
}
</pre></blockquote>

<p>
Negators 20.7.10 [negators]:
</p>

<blockquote>
<p>
-1- Negators <tt>not1</tt> and <tt>not2</tt> take a unary and a binary predicate,
respectively, and return their complements (5.3.1).
</p>

<pre>template &lt;<del>class</del> <ins>AdaptableUnaryFunction</ins> P<del>redicate</del>&gt;
  <ins>requires Predicate&lt; P, P::argument_type &gt;</ins>
  class unary_negate
    : public unary_function&lt;<del>typename</del> P<del>redicate</del>::argument_type,bool&gt; {
  public:
    <ins>unary_negate(const unary_negate &amp; ) = default;</ins>
    <ins>unary_negate(unary_negate &amp;&amp; );</ins>

    <ins>requires CopyConstructible&lt; P &gt;</ins>
       explicit unary_negate(const Predicate&amp; pred); 
    <ins>requires MoveConstructible&lt; P &gt;
       explicit unary_negate(Predicate &amp;&amp; pred);</ins>

    bool operator()(const <del>typename</del> P<del>redicate</del>::argument_type&amp; x) const;
  };
</pre>
<blockquote>
-2 <tt>operator()</tt> returns <tt>!pred(x)</tt>.
</blockquote>

<pre>template &lt;class Predicate&gt;
  unary_negate&lt;Predicate&gt; not1(const Predicate&amp;amp; pred);
<ins>template &lt;class Predicate&gt;
  unary_negate&lt;Predicate&gt; not1(Predicate&amp;&amp; pred);</ins>
</pre>
<blockquote>
-3-  <i>Returns:</i> <tt>unary_negate&lt;Predicate&gt;(pred)</tt>.
</blockquote>

<pre>template &lt;<del>class</del> <ins>AdaptableBinaryFunction</ins> P<del>redicate</del> &gt;
  <ins>requires Predicate&lt; P, P::first_argument_type, P::second_argument_type &gt;</ins>
  class binary_negate
    : public binary_function&lt;<del>typename</del> P<del>redicate</del>::first_argument_type,
                              <del>typename</del> P<del>redicate</del>::second_argument_type, bool&gt; {
  public:
    <ins>biary_negate(const binary_negate &amp; ) = default;</ins>
    <ins>binary_negate(binary_negate &amp;&amp; );</ins>

    <ins>requires CopyConstructible&lt; P &gt;</ins>
       explicit binary_negate(const Predicate&amp; pred);
    <ins>requires MoveConstructible&lt; P &gt;
       explicit binary_negate(const Predicate&amp; pred);</ins>

    bool operator()(const <del>typename</del> P<del>redicate</del>::first_argument_type&amp; x,
                    const <del>typename</del> P<del>redicate</del>::second_argument_type&amp; y) const;
  };
</pre>
<blockquote>
-4- <tt>operator()</tt> returns <tt>!pred(x,y)</tt>.
</blockquote>

<pre>template &lt;class Predicate&gt;
  binary_negate&lt;Predicate&gt; not2(const Predicate&amp; pred);
<ins>template &lt;class Predicate&gt;
  binary_negate&lt;Predicate&gt; not2(Predicate&amp;&amp; pred);</ins>
</pre>

<blockquote>
-5- <i>Returns:</i> <tt>binary_negate&lt;Predicate&gt;(pred)</tt>.
</blockquote>
</blockquote>






<hr>
<h3><a name="1079"></a>1079. UK-265: <code>RandomAccessIterator</code>'s <code>operator-</code> has nonsensical effects clause</h3>
<p><b>Section:</b> 24.2.5 [random.access.iterators] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Doug Gregor <b>Opened:</b> 2009-03-20  <b>Last modified:</b> 2009-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#random.access.iterators">issues</a> in [random.access.iterators].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses UK 265</b></p>

<p>UK-265:</p>
<p>
This effects clause is nonesense. It looks more like an axiom stating
equivalence, and certainly an effects clause cannot change the state of
two arguments passed by const reference
</p>

<p><i>[
2009-09-18 Alisdair adds:
]</i></p>


<blockquote>
<p>
For random access iterators, the definitions of <tt>(b-a)</tt> and
<tt>(a&lt;b)</tt> are circular:
</p>

<p>
From table Table 104 -- Random access iterator requirements:
</p>

<blockquote><pre>b - a :==&gt;  (a &lt; b) ? distance(a,b) : -distance(b,a)

a &lt; b :==&gt;  b - a &gt; 0
</pre></blockquote>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Moved to Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>

<p>Modify 24.2.5 [random.access.iterators]p7-9 as follows:</p>

<blockquote><pre>difference_type operator-(const X&amp; a, const X&amp; b);
</pre>
<ol start="7">
  <li><i>Precondition</i>: there exists a value <code>n</code> of
  <code>difference_type</code> such that <code>a == b + n</code>.</li>
  <li><del><i>Effects</i>: <code>b == a + (b - a)</code></del></li>
  <li><i>Returns</i>: <del><code>(a &lt; b) ? distance(a,b) :
  -distance(b,a)</code></del><ins><code>n</code></ins></li>
</ol>
</blockquote>





<hr>
<h3><a name="1089"></a>1089. Response to JP 76</h3>
<p><b>Section:</b> 30 [thread] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-03-22  <b>Last modified:</b> 2009-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread">issues</a> in [thread].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses JP 76</b></p>

<p>
A description for "Throws: Nothing." are not unified.
</p>

<p>
At the part without throw, "Throws: Nothing." should be described.
</p>

<p>
Add "Throws: Nothing." to the following.
</p>

<ul>
<li>
30.3.1.6 [thread.thread.static] p1
</li>
<li>
30.4.3.1 [thread.lock.guard] p4
</li>
<li>
30.4.3.2.1 [thread.lock.unique.cons] p6
</li>
<li>
30.5.1 [thread.condition.condvar] p7 and p8
</li>
<li>
30.5.2 [thread.condition.condvarany] p6, p7, p19, p21 and p25
</li>
</ul>

<p><i>[
Summit:
]</i></p>

<blockquote>
Pass on to editor.
</blockquote>

<p><i>[
Post Summit:  Editor declares this non-editorial.
]</i></p>


<p><i>[
2009-08-01 Howard provided wording:
]</i></p>


<blockquote>

<p>
The definition of "<i>Throws:</i> Nothing." that I added is probably going to
be controversial, but I beg you to consider it seriously.
</p>

<blockquote>
<p>
In C++ there are three "flow control" options for a function:
</p>

<ol>
<li>
It can return, either with a value, or with <tt>void</tt>.
</li>
<li>
It can call a function which never returns, such as <tt>std::exit</tt> or
<tt>std::terminate</tt>.
</li>
<li>
It can throw an exception.
</li>
</ol>

The above list can be abbreviated with:

<ol>
<li><b>R</b>eturns.</li>
<li><b>E</b>nds program.</li>
<li><b>T</b>hrows exception.</li>
</ol>

<p>
In general a function can have the behavior of any of these 3, or any combination
of any of these three, depending upon run time data.
</p>

<ol>
<li><b>R</b></li>
<li><b>E</b></li>
<li><b>T</b></li>
<li><b>RE</b></li>
<li><b>RT</b></li>
<li><b>ET</b></li>
<li><b>RET</b></li>
</ol>

<p>
A function with no throw spec, and no documentation, is in general a <b>RET</b>
function.  It may return, it may end the program, or it may throw.  When we
specify a function with an empty throw spec:
</p>

<blockquote><pre>void f() throw();
</pre></blockquote>

<p>
We are saying that <tt>f()</tt> is an <b>RE</b> function:  It may return or end
the program, but it will not throw.
</p>

<p>
I posit that there are very few places in the library half of the standard
where we intend for functions to be able to end the program (call <tt>terminate</tt>).
And none of those places where we do say <tt>terminate</tt> could be called,
do we currently say "<i>Throws:</i> Nothing.".
</p>

<p>
I believe that if we define "<i>Throws:</i> Nothing." to mean <b>R</b>,
we will both clarify many, many places in the standard, <em>and</em> give us a
good rationale for choosing between "<i>Throws:</i> Nothing." (<b>R</b>)
and <tt>throw()</tt> (<b>RE</b>) in the future.  Indeed, this may give us motivation
to change several <tt>throw()</tt>s to "<i>Throws:</i> Nothing.".
</p>
</blockquote>

<p>
I did not add the following changes as JP 76 requested as I believe we want to
allow these functions to throw:
</p>

<blockquote>
<p>
Add a paragraph under 30.4.3.1 [thread.lock.guard] p4:
</p>

<blockquote><pre>explicit lock_guard(mutex_type&amp; m);
</pre>

<p><ins>
<i>Throws:</i> Nothing.
</ins></p>
</blockquote>

<p>
Add a paragraph under 30.4.3.2.1 [thread.lock.unique.cons] p6:
</p>

<blockquote><pre>explicit unique_lock(mutex_type&amp; m);
</pre>

<p><ins>
<i>Throws:</i> Nothing.
</ins></p>
</blockquote>

<p>
Add a paragraph under 30.5.2 [thread.condition.condvarany] p19, p21 and p25:
</p>

<blockquote><pre>template &lt;class Lock, class Rep, class Period&gt; 
  bool wait_for(Lock&amp; lock, const chrono::duration&lt;Rep, Period&gt;&amp; rel_time);
</pre>

<p><ins>
<i>Throws:</i> Nothing.
</ins></p>
</blockquote>

<blockquote><pre>template &lt;class Lock, class Duration, class Predicate&gt; 
  bool wait_until(Lock&amp; lock, const chrono::time_point&lt;Clock, Duration&gt;&amp; rel_time, Predicate pred);
</pre>

<p><ins>
<i>Throws:</i> Nothing.
</ins></p>
</blockquote>

<blockquote><pre>template &lt;class Lock, class Rep, class Period, class Predicate&gt; 
  bool wait_for(Lock&amp; lock, const chrono::duration&lt;Rep, Period&gt;&amp; rel_time, Predicate pred);
</pre>

<p><ins>
<i>Throws:</i> Nothing.
</ins></p>
</blockquote>

</blockquote>

</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Defer pending further developments with exception restriction annotations.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add a paragraph after 17.5.1.4 [structure.specifications] p4:
</p>

<blockquote>
<p>
-3- Descriptions of function semantics contain the following elements
(as appropriate):<sup>158</sup>
</p>
<ul>
<li>...</li>
<li>
<i>Throws:</i> any exceptions thrown by the function, and the conditions
that would cause the exception
</li>
<li>...</li>
</ul>

<p>
-4- For non-reserved replacement and handler functions, ...
</p>

<p><ins>
A "<i>Throws:</i> Nothing." element indicates that the function shall
return ordinarily, and not exit via an exception.  This element also
indicates that the function <em>shall</em> return. [<i>Note:</i> This
differs from an empty throw specification which may cause a function to
call <tt>unexpected</tt> and subsequently <tt>terminate</tt>. &#8212;
<i>end note</i>]
</ins></p>
</blockquote>

<p>
Add a paragraph under 30.3.1.6 [thread.thread.static] p1:
</p>

<blockquote><pre>unsigned hardware_concurrency();
</pre>

<p>
-1- <i>Returns:</i> ...
</p>

<p><ins>
<i>Throws:</i> Nothing.
</ins></p>
</blockquote>

<p>
Add a paragraph under 30.5.1 [thread.condition.condvar] p7 and p8:
</p>

<blockquote>
<p>
<i>[Informational, not to be incluced in the WP: The POSIX spec allows only:</i>
</p>
<dl>
<dt><i>[EINVAL]</i></dt>
<dd><i>The value <tt>cond</tt> does not refer to an initialized condition variable. &#8212; end informational]</i></dd>
</dl>

<pre>void notify_one();
</pre>

<p>
-7- <i>Effects:</i> ...
</p>

<p><ins>
<i>Throws:</i> Nothing.
</ins></p>
</blockquote>

<blockquote><pre>void notify_all();
</pre>

<p>
-8- <i>Effects:</i> ...
</p>

<p><ins>
<i>Throws:</i> Nothing.
</ins></p>
</blockquote>


<p>
Add a paragraph under 30.5.2 [thread.condition.condvarany] p6 and p7:
</p>

<blockquote>
<pre>void notify_one();
</pre>

<p>
-6- <i>Effects:</i> ...
</p>

<p><ins>
<i>Throws:</i> Nothing.
</ins></p>
</blockquote>

<blockquote><pre>void notify_all();
</pre>

<p>
-7- <i>Effects:</i> ...
</p>

<p><ins>
<i>Throws:</i> Nothing.
</ins></p>
</blockquote>







<hr>
<h3><a name="1090"></a>1090. Missing description of <tt>packaged_task</tt> member <tt>swap</tt>,  missing non-member <tt>swap</tt></h3>
<p><b>Section:</b> 30.6.10 [futures.task] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2009-03-22  <b>Last modified:</b> 2009-10-26</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Class template <tt>packaged_task</tt> in 30.6.10 [futures.task] shows a member <tt>swap</tt>
declaration, but misses to
document it's effects (No prototype provided). Further on this class
misses to provide a non-member
swap.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Alisdair notes that paragraph 2 of the proposed resolution has already been
applied in the current Working Draft.
</p>
<p>
We note a pending <tt>future</tt>-related paper by Detlef;
we would like to wait for this paper before proceeding.
</p>
<p>
Move to Open.
</p>
</blockquote>

<p><i>[
2009-05-24 Daniel removed part 2 of the proposed resolution.
]</i></p>


<p><i>[
2009-10 post-Santa Cruz:
]</i></p>


<blockquote>
Move to Tentatively Ready, removing bullet 3 from the proposed
resolution but keeping the other two bullets.
</blockquote>



<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>
In 30.6.10 [futures.task], immediately after the definition of class
template packaged_task add:
</p>
<blockquote><pre><ins>
template&lt;class R, class... Argtypes&gt;
void swap(packaged_task&lt;R(ArgTypes...)&gt;&amp;, packaged_task&lt;R(ArgTypes...)&gt;&amp;);
</ins>
</pre></blockquote>
</li>
</ol>

<ol start="4">

<li>
<p>
At the end of 30.6.10 [futures.task] (after p. 20), add add the following
prototype description:
</p>

<blockquote><pre><ins>
template&lt;class R, class... Argtypes&gt;
void swap(packaged_task&lt;R(ArgTypes...)&gt;&amp; x, packaged_task&lt;R(ArgTypes...)&gt;&amp; y);
</ins></pre>
<blockquote>
<p><ins>
<i>Effects:</i> <tt>x.swap(y)</tt>
</ins></p>
<p><ins>
<i>Throws:</i> Nothing.
</ins></p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="1093"></a>1093. Multiple definitions for random_shuffle algorithm</h3>
<p><b>Section:</b> 25.3.12 [alg.random.shuffle] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-22  <b>Last modified:</b> 2009-10-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.random.shuffle">issues</a> in [alg.random.shuffle].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
There are a couple of issues with the declaration of the <tt>random_shuffle</tt>
algorithm accepting a random number engine.
</p>

<ol type="i">
<li>
The Iterators must be shuffle iterators, yet this requirement is missing.
</li>
<li>
The <tt>RandomNumberEngine</tt> concept is now provided by the random number
library
(<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2836.pdf">n2836</a>)
and the placeholder should be removed.
</li>
</ol>

<p><i>[
2009-05-02 Daniel adds:
]</i></p>


<blockquote>
<p>
this issue completes adding necessary requirement to the
third new <tt>random_shuffle</tt> overload. The current suggestion is:
</p>

<blockquote><pre>template&lt;RandomAccessIterator Iter, UniformRandomNumberGenerator Rand&gt;
requires ShuffleIterator&lt;Iter&gt;
void random_shuffle(Iter first, Iter last, Rand&amp;&amp; g);
</pre></blockquote>

<p>
IMO this is still insufficient and I suggest to add the requirement
</p>
<blockquote><pre>Convertible&lt;Rand::result_type, Iter::difference_type&gt;
</pre></blockquote>
<p>
to the list (as the two other overloads already have).
</p>

<p>
Rationale:
</p>

<blockquote>
<p>
Its true that this third overload is somewhat different from the remaining
two. Nevertheless we know from <tt>UniformRandomNumberGenerator</tt>, that
it's <tt>result_type</tt> is an integral type and that it satisfies
<tt>UnsignedIntegralLike&lt;result_type&gt;</tt>.
</p>
<p>
To realize it's designated task, the algorithm has to invoke the
<tt>Callable</tt> aspect of <tt>g</tt> and needs to perform some algebra involving
it's <tt>min()/max()</tt> limits to compute another index value that
at this point is converted into <tt>Iter::difference_type</tt>. This is so,
because 24.2.5 [random.access.iterators] uses this type as argument
of it's algebraic operators. Alternatively consider the equivalent
iterator algorithms in 24.4.4 [iterator.operations] with the same result.
</p>
<p>
This argument leads us to the conclusion that we also need
<tt>Convertible&lt;Rand::result_type, Iter::difference_type&gt;</tt> here.
</p>
</blockquote>

</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Alisdair notes that point (ii) has already been addressed.
</p>
<p>
We agree with the proposed resolution to point (i)
with Daniel's added requirement.
</p>
<p>
Move to Review.
</p>
</blockquote>

<p><i>[
2009-06-05 Daniel updated proposed wording as recommended in Batavia.
]</i></p>


<p><i>[
2009-07-28 Alisdair adds:
]</i></p>


<blockquote>
Revert to Open, with a note there is consensus on direction but the
wording needs updating to reflect removal of concepts.
</blockquote>

<p><i>[
2009-10 post-Santa Cruz:
]</i></p>


<blockquote>
Leave Open, Walter to work on it.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change in  [algorithms.syn] and 25.3.12 [alg.random.shuffle]:
</p>

<blockquote><pre><del>concept UniformRandomNumberGenerator&lt;typename Rand&gt; { }</del>
template&lt;RandomAccessIterator Iter, UniformRandomNumberGenerator Rand&gt;
  <ins>requires ShuffleIterator&lt;Iter&gt; &amp;&amp;
  Convertible&lt;Rand::result_type, Iter::difference_type&gt;</ins>
  void random_shuffle(Iter first, Iter last, Rand&amp;&amp; g);
</pre></blockquote>






<hr>
<h3><a name="1094"></a>1094. Response to JP 65 and JP 66</h3>
<p><b>Section:</b> 27.5.4.3 [iostate.flags] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> P.J. Plauger <b>Opened:</b> 2009-03-24  <b>Last modified:</b> 2009-10-20</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#iostate.flags">issues</a> in [iostate.flags].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses JP 65 and JP 66</b></p>

<p>
Switch from "unspecified-bool-type" to "explicit operator bool() const". 
</p>

<p>
Replace <tt>operator unspecified-bool-type() const;</tt>" with <tt>explicit operator bool() const;</tt>
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution.
Move to Review.
</blockquote>

<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote>
Moved to Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change the synopis in 27.5.4 [ios]:
</p>

<blockquote><pre><ins>explicit</ins> operator <del><i>unspecified-bool-type</i></del> <ins>bool</ins>() const;
</pre></blockquote>

<p>
Change 27.5.4.3 [iostate.flags]:
</p>

<blockquote><pre><ins>explicit</ins> operator <del><i>unspecified-bool-type</i></del> <ins>bool</ins>() const;
</pre>

<blockquote>
<p>
-1- <i>Returns:</i> <ins><tt>!fail()</tt></ins> <del>If <tt>fail()</tt> then a value that will evaluate
false in a boolean context; otherwise a value that will evaluate true in
a boolean context. The value type returned shall not be convertible to
int.</del>
</p>
<p>
<del>[<i>Note:</i> This conversion can be used in contexts where a bool is expected
(e.g., an <tt>if</tt> condition); however, implicit conversions (e.g.,
to <tt>int</tt>) that can occur with <tt>bool</tt> are not allowed,
eliminating some sources of user error. One possible implementation
choice for this type is pointer-to-member. <i>-- end note</i>]</del>
</p>
</blockquote>
</blockquote>







<hr>
<h3><a name="1095"></a>1095. <i>Shared objects and the library</i> wording unclear</h3>
<p><b>Section:</b> 17.6.3.10 [res.on.objects] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Beman Dawes <b>Opened:</b> 2009-03-27  <b>Last modified:</b> 2009-10-21</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2775.htm">N2775</a>,
<i>Small library thread-safety revisions</i>, among other changes, removed a note from
17.6.3.10 [res.on.objects] that read:
</p>

<blockquote>
[<i>Note:</i> This prohibition against concurrent non-const access means that
modifying an object of a standard library type shared between threads
without using a locking mechanism may result in a data race. <i>--end note</i>.]
</blockquote>

<p>
That resulted in wording which is technically correct but can only be
understood by reading the lengthy and complex 17.6.4.8 [res.on.data.races]
Data race avoidance. This has the effect of making
17.6.3.10 [res.on.objects] unclear, and has already resulted in a query
to the LWG reflector. See c++std-lib-23194.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
The proposed wording seems to need a bit of tweaking
("really bad idea" isn't quite up to standardese).
We would like feedback
as to whether the original Note's removal was intentional.
</p>
<p>
Change the phrase "is a really bad idea"
to "risks undefined behavior" and
move to Review status.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Note: Change to read: "Modifying...", Delete 'thus', move to Ready
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 17.6.3.10 [res.on.objects] as indicated:
</p>

<blockquote>
<p>
The behavior of a program is undefined if calls to standard library
functions from different threads may introduce a data race. The
conditions under which this may occur are specified in 17.6.4.7.
</p>
<p><ins>
[<i>Note:</i> Modifying an object of a standard library type shared between
threads risks undefined behavior unless objects of the type are explicitly
specified as being sharable without data races or the user supplies a
locking mechanism. <i>--end note</i>]
</ins></p>
</blockquote>





<hr>
<h3><a name="1097"></a>1097. #define __STDCPP_THREADS</h3>
<p><b>Section:</b> 18.2 [support.types] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Jens Maurer <b>Opened:</b> 2009-04-03  <b>Last modified:</b> 2009-10-21</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#support.types">issues</a> in [support.types].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses DE 18</b></p>

<p>
Freestanding implementations do not (necessarily) have
  support for multiple threads (see 1.10 [intro.multithread]).
  Applications and libraries may want to optimize for the
  absence of threads.  I therefore propose a preprocessor
  macro to indicate whether multiple threads can occur.
</p>

<p>
There is ample prior implementation experience for this
  feature with various spellings of the macro name.  For
  example, gcc implicitly defines <tt>_REENTRANT</tt>
  if multi-threading support is selected on the compiler
  command-line.
</p>

<p>
While this is submitted as a library issue, it may be more
  appropriate to add the macro in 16.8 cpp.predefined in the
  core language.
</p>

<p>
See also
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2693.html">N2693</a>.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We agree with the issue, and believe it is properly a library issue.
</p>
<p>
We prefer that the macro be conditionally defined
as part of the <tt>&lt;thread&gt;</tt> header.
</p>
<p>
Move to Review.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Move to Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Insert a new subsection before 18.2 [support.types], entitled
"Feature Macros" (support.macros):
</p>
<blockquote>
<p>
The standard library defines the following macros; no explicit
prior inclusion of any header file is necessary.
</p>
<blockquote>
<dl>
<dt><tt>__STDCPP_THREADS</tt></dt>
<dd>
The macro <tt>__STDCPP_THREADS</tt> shall be defined if and only if a
    program can have more than one thread of execution (1.10 [intro.multithread]).
If the macro is defined, it shall have the same
    value as the predefined macro <tt>__cplusplus</tt> (16.8 [cpp.predefined]).
</dd>
</dl>
</blockquote>
</blockquote>






<hr>
<h3><a name="1098"></a>1098. definition of get_pointer_safety()</h3>
<p><b>Section:</b> 20.8.15.6 [util.dynamic.safety] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Jens Maurer <b>Opened:</b> 2009-04-03  <b>Last modified:</b> 2009-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#util.dynamic.safety">issues</a> in [util.dynamic.safety].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses DE 18</b></p>

<p>
 In 20.8.15.6 [util.dynamic.safety], <tt>get_pointer_safety()</tt> purports
to define behavior for
 non-safely derived pointers (3.7.4.3 [basic.stc.dynamic.safety]).  However,
 the cited core-language section in paragraph 4 specifies undefined behavior
 for the use of such pointer values.  This seems an unfortunate near-contradiction.
 I suggest to specify the term <i>relaxed pointer safety</i> in
 the core language section and refer to it from the library description.
 This issue deals with the library part, the corresponding core issue (c++std-core-13940)
 deals with the core modifications.
</p>

<p>
See also
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2693.html">N2693</a>.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We recommend if this issue is to be moved,
the issue be moved concurrently with the cited Core issue.
</p>
<p>
We agree with the intent of the proposed resolution.
We would like input from garbage collection specialists.
</p>
<p>
Move to Open.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
The core issue is 853 and is in Ready status.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
In 20.8.15.6 [util.dynamic.safety] p16, replace the description of
<tt>get_pointer_safety()</tt> with:
</p>

<blockquote>
<p>
<tt>pointer_safety get_pointer_safety();</tt>
</p>
<blockquote>
<p>
<del><i>Returns:</i> an enumeration value indicating the implementation's treatment
of pointers that are not safely derived (3.7.4.3). Returns
<tt>pointer_safety::relaxed</tt> if pointers that are not safely derived will be
treated the same as pointers that are safely derived for the duration of
the program. Returns <tt>pointer_safety::preferred</tt> if pointers that are not
safely derived will be treated the same as pointers that are safely
derived for the duration of the program but allows the implementation to
hint that it could be desirable to avoid dereferencing pointers that are
not safely derived as described. [<i>Example:</i> <tt>pointer_safety::preferred</tt>
might be returned to detect if a leak detector is running to avoid
spurious leak reports. -- <i>end note</i>] Returns <tt>pointer_safety::strict</tt> if
pointers that are not safely derived might be treated differently than
pointers that are safely derived.</del>
</p>
<p><ins>
<i>Returns:</i> Returns <tt>pointer_safety::strict</tt> if the implementation has
   strict pointer safety (3.7.4.3 [basic.stc.dynamic.safety]). It is
   implementation-defined whether <tt>get_pointer_safety</tt> returns
   <tt>pointer_safety::relaxed</tt> or <tt>pointer_safety::preferred</tt> if the
   implementation has relaxed pointer safety
   (3.7.4.3 [basic.stc.dynamic.safety]).<sup>Footnote</sup>
</ins></p>

<p><ins>
<i>Throws:</i> nothing
</ins></p>

<p><ins>
Footnote) <tt>pointer_safety::preferred</tt> might be returned to indicate to the
   program that a leak detector is running so that the program can avoid
   spurious leak reports.
</ins>
</p>

</blockquote>
</blockquote>





<hr>
<h3><a name="1099"></a>1099. Various issues</h3>
<p><b>Section:</b> 17 [library] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> David Abrahams <b>Opened:</b> 2009-03-21  <b>Last modified:</b> 2009-10-26</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Notes
</p>
<blockquote>
<p>
[2009-03-21 Sat] p. 535 at the top we need MoveConstructible V1,
MoveConstructible V2 (where V1,V2 are defined on 539).  Also make_tuple
on 550
</p>

<blockquote>
<p>
CD-1 reads:
</p>

<blockquote><pre>template &lt;MoveConstructible T1, MoveConstructible T2&gt; 
pair&lt;V1, V2&gt; make_pair(T1&amp;&amp;, T2&amp;&amp;); 
</pre></blockquote>

<p>
Actually I'm guessing we need something like <tt>MoveConstructible&lt;V1,T1&gt;</tt>,
i.e. "<tt>V1</tt> can be constructed from an rvalue of type <tt>T1</tt>."
</p>

<p>
Ditto for <tt>make_tuple</tt>
</p>
</blockquote>

<p>
[2009-03-21 Sat] p1183 thread ctor, and in general, we need a way to
talk about "copiable from generalized rvalue ref argument" for cases
where we're going to forward and copy.  
</p>
<blockquote>
<p>
   This issue may well be quite large.  Language in para 4 about "if
   an lvalue" is wrong because types aren't expressions.
</p>

<blockquote>
<p>
Maybe we should define the term "move" so we can just say in the
effects, "<tt>f</tt> is moved into the newly-created thread" or something, and
agree (and ideally document) that saying "<tt>f</tt> is moved" implies 
</p>

<blockquote><pre>F x(move(f))
</pre></blockquote>

<p>
is required to work.  That would cover both ctors at once.
</p>
</blockquote>

<p>
   p1199, call_once has all the same issues.
</p>
</blockquote>
<p>
[2009-03-21 Sat] p869 InputIterator pointer type should not be required
to be convertible to const value_type*, rather it needs to have a
operator-&gt; of its own that can be used for the value type.
</p>

<blockquote>
This one is serious and unrelated to the move issue.
</blockquote>

<p>
[2009-03-21 Sat] p818 stack has the same problem with default ctor.
</p>
<p>
[2009-03-21 Sat] p816 priority_queue has the same sorts of problems as queue, only more so
</p>
<blockquote><pre>   requires MoveConstructible&lt;Cont&gt; 
     explicit priority_queue(const Compare&amp; x = Compare(), Cont&amp;&amp; = Cont()); 
</pre>
<p>
   Don't require MoveConstructible when default constructing Cont.
   Also missing semantics for move ctor.
</p>
</blockquote>
<p>
 [2009-03-21 Sat] Why are Allocators required to be CopyConstructible as
 opposed to MoveConstructible?
</p>
<p>
 [2009-03-21 Sat] p813 queue needs a separate default ctor (Cont needn't
 be MoveConstructible).  No documented semantics for move c'tor.  Or
 *any* of its 7 ctors!
</p>
<p>
 [2009-03-21 Sat] std::array should have constructors for C++0x,
 consequently must consider move construction.
</p>

<p><i>[
2009-05-01 Daniel adds:
]</i></p>


<blockquote>
This could be done as part of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1035">1035</a>, which already handles
deviation of <tt>std::array</tt> from container tables.
</blockquote>

<p>
 [2009-03-21 Sat] p622 all messed up.
</p>
<blockquote>
<p>
   para 8 "implementation-defined" is the wrong term; should be "see
   below" or something.  
</p>
<p>
   para 12 "will be selected" doesn't make any sense because we're not
   talking about actual arg types.
</p>
<p>
   paras 9-13 need to be totally rewritten for concepts.
</p>
</blockquote>

<p>
 [2009-03-21 Sat] Null pointer comparisons (p587) have all become
 unconstrained.  Need to fix that
</p>
<p>
 [2009-03-21 Sat] mem_fun_t etc. definition doesn't match declaration.
  We think CopyConstructible is the right reqt.
</p>
<p>
 make_pair needs Constructible&lt;V1, T1&amp;&amp;&gt; requirements!
</p>
<p>
 make_tuple needs something similar
</p>
<p>
 tuple bug in synopsis:
</p>
<blockquote><pre>   template &lt;class... UTypes&gt;
   requires Constructible&lt;Types, const UTypes&amp;&gt;...
   template &lt;class... UTypes&gt;
   requires Constructible&lt;Types, RvalueOf&lt;UTypes&gt;::type&gt;...
</pre>
<p>
   Note: removal of MoveConstructible requirements in std::function makes
   these routines unconstrained!
</p>
</blockquote>

<p><i>[
2009-05-02 Daniel adds:
]</i></p>


<blockquote>
This part of the issue is already covered by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1077">1077</a>.
</blockquote>

<p>
 these unique_ptr constructors are broken [ I think this is covered in "p622 all messed up" ]
</p>
<blockquote><pre> unique_ptr(pointer p, implementation-defined d);
 unique_ptr(pointer p, implementation-defined d);
</pre></blockquote>
<p>
 multimap range constructor should not have MoveConstructible&lt;value_type&gt; requirement.
</p>
<blockquote>
   same with insert(..., P&amp;&amp;); multiset has the same issue, as do
   unordered_multiset and unordered_multimap. Review these!
</blockquote>

</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Move to Open, pending proposed wording from Dave for further review.
</blockquote>

<p><i>[
2009-10 post-Santa Cruz:
]</i></p>


<blockquote>
Tentatively NAD.  We are not sure what has been addressed and what hasn't.
Recommend closing unless someone sorts this out into something more readable.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="1100"></a>1100. <tt>auto_ptr</tt> to <tt>unique_ptr</tt> conversion</h3>
<p><b>Section:</b> 20.8.14.2.1 [unique.ptr.single.ctor] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-04-25  <b>Last modified:</b> 2009-10-21</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#unique.ptr.single.ctor">active issues</a> in [unique.ptr.single.ctor].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#unique.ptr.single.ctor">issues</a> in [unique.ptr.single.ctor].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Message c++std-lib-23182 led to a discussion in which several people
expressed interest in being able to convert an <tt>auto_ptr</tt> to a
<tt>unique_ptr</tt> without the need to call <tt>release</tt>.  Below is
wording to accomplish this.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Pete believes it not a good idea to separate parts of a class's definition.
Therefore, if we do this,
it should be part of <tt>unique-ptr</tt>'s specification.
</p>
<p>
Alisdair believes the lvalue overload may be not necessary.
</p>
<p>
Marc believes it is more than just sugar,
as it does ease the transition to <tt>unique-ptr</tt>.
</p>
<p>
We agree with the resolution as presented.
Move to Tentatively Ready.
</p>
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
Moved from Tentatively Ready to Open only because the wording needs to be
tweaked for concepts removal.
</blockquote>

<p><i>[
2009-08-01 Howard deconceptifies wording:
]</i></p>


<blockquote>
I also moved the change from D.10 [depr.auto.ptr]
to 20.8.14.2 [unique.ptr.single] per the Editor's request
in Batavia (as long as I was making changes anyway).  Set back
to Review.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Move to Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add to 20.8.14.2 [unique.ptr.single]:
</p>

<blockquote><pre>template &lt;class T, class D&gt;
class unique_ptr
{
public:
<ins>    template &lt;class U&gt;
      unique_ptr(auto_ptr&lt;U&gt;&amp; u);
    template &lt;class U&gt;
      unique_ptr(auto_ptr&lt;U&gt;&amp;&amp; u);</ins>
};
</pre></blockquote>

<p>
Add to 20.8.14.2.1 [unique.ptr.single.ctor]:
</p>

<blockquote><pre>template &lt;class U&gt;
  unique_ptr(auto_ptr&lt;U&gt;&amp; u);
template &lt;class U&gt;
  unique_ptr(auto_ptr&lt;U&gt;&amp;&amp; u);
</pre>
<blockquote>
<p>
<i>Effects:</i> Constructs a <tt>unique_ptr</tt> with <tt>u.release()</tt>.
</p>

<p>
<i>Postconditions:</i> <tt>get() == </tt> the value <tt>u.get()</tt> had before
the construciton, modulo any required offset adjustments resulting from the cast from
<tt>U*</tt> to <tt>T*</tt>.  <tt>u.get() == nullptr</tt>.
</p>

<p>
<i>Throws:</i> nothing.
</p>

<p>
<i>Remarks:</i> <tt>U*</tt> shall be implicitly convertible to <tt>T*</tt> and
<tt>D</tt> shall be the same type as <tt>default_delete&lt;T&gt;</tt>, else these
constructors shall not participate in overload resolution.
</p>
</blockquote>
</blockquote>






<hr>
<h3><a name="1104"></a>1104. <tt>basic_ios::move</tt> should accept lvalues</h3>
<p><b>Section:</b> 27.5.4.2 [basic.ios.members] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-04-25  <b>Last modified:</b> 2009-10-20</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#basic.ios.members">active issues</a> in [basic.ios.members].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#basic.ios.members">issues</a> in [basic.ios.members].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
With the rvalue reference changes in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2844.html">N2844</a>
<tt>basic_ios::move</tt> no longer has the most convenient signature:
</p>

<blockquote><pre>void move(basic_ios&amp;&amp; rhs);
</pre></blockquote>

<p>
This signature should be changed to accept lvalues.  It does not need to be
overloaded to accept rvalues.  This is a special case that only derived clients
will see.  The generic <tt>move</tt> still needs to accept rvalues.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Tom prefers, on general principles, to provide both overloads.
Alisdair agrees.
</p>
<p>
Howard points out that there is no backward compatibility issue
as this is new to C++0X.
</p>
<p>
We agree that both overloads should be provided,
and Howard will provide the additional wording.
Move to Open.
</p>
</blockquote>

<p><i>[
2009-05-23 Howard adds:
]</i></p>


<blockquote>
Added overload, moved to Review.
</blockquote>

<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote>
Move to Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add a signature to the existing prototype in the synopsis of 27.5.4 [ios]
and in 27.5.4.2 [basic.ios.members]:
</p>

<blockquote><pre><ins>void move(basic_ios&amp; rhs);</ins>
void move(basic_ios&amp;&amp; rhs);
</pre></blockquote>





<hr>
<h3><a name="1106"></a>1106. Multiple exceptions from connected <tt>shared_future::get()</tt>?</h3>
<p><b>Section:</b> 30.6.7 [future.shared_future] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Thomas J. Gritzan <b>Opened:</b> 2009-04-03  <b>Last modified:</b> 2009-05-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#future.shared_future">issues</a> in [future.shared_future].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It is not clear, if multiple threads are waiting in a 
<tt>shared_future::get()</tt> call, if each will rethrow the stored exception.
</p>
<p>
Paragraph 9 reads: 
</p>
<blockquote>
<i>Throws:</i> the stored exception, if an exception was stored and not 
retrieved before.
</blockquote>
<p>
The "not retrieved before" suggests that only one exception is thrown, 
but one exception for each call to <tt>get()</tt> is needed, and multiple calls 
to <tt>get()</tt> even on the same <tt>shared_future</tt> object seem to be allowed. 
</p>
<p>
I suggest removing "and not retrieved before" from the Throws paragraph. 
I recommend adding a note that explains that multiple calls on <tt>get()</tt> are 
allowed, and each call would result in an exception if an exception was 
stored. 
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We note there is a pending paper by Detlef
on such <tt>future</tt>-related issues;
we would like to wait for his paper before proceeding.
</p>
<p>
Alisdair suggests we may want language to clarify that this
<tt>get()</tt> function can be called from several threads
with no need for explicit locking.
</p>
<p>
Move to Open.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 30.6.7 [future.shared_future]:
</p>

<blockquote><pre>const R&amp; shared_future::get() const; 
R&amp; shared_future&lt;R&amp;&gt;::get() const; 
void shared_future&lt;void&gt;::get() const;
</pre>
<blockquote>
<p>...</p>
<p>
-9- <i>Throws:</i> the stored exception, if an exception was stored<del> and not retrieved before</del>.
<ins>
[<i>Note:</i> Multiple calls on <tt>get()</tt> are 
allowed, and each call would result in an exception if an exception was 
stored. &#8212; <i>end note</i>]
</ins>
</p>
</blockquote>
</blockquote>






<hr>
<h3><a name="1108"></a>1108. thread.req.exception overly constrains implementations</h3>
<p><b>Section:</b> 30.2.2 [thread.req.exception] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Christopher Kohlhoff <b>Opened:</b> 2009-04-25  <b>Last modified:</b> 2009-10-26</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The current formulation of 30.2.2 [thread.req.exception]/2 reads:
</p>
<blockquote>
The error_category of the <tt>error_code</tt> reported by such an
exception's <tt>code()</tt> member function is as specified in the error
condition Clause.
</blockquote>
<p>
This constraint on the code's associated <tt>error_categor</tt> means an
implementation must perform a mapping from the system-generated
error to a <tt>generic_category()</tt> error code. The problems with this
include:
</p>

<ul>
<li>
The mapping is always performed, even if the resultant value is
 never used.
</li>
<li>
<p>
The original error produced by the operating system is lost.
</p>
</li>
</ul>
<p>
The latter was one of Peter Dimov's main objections (in a private
email discussion) to the original <tt>error_code</tt>-only design, and led to
the creation of <tt>error_condition</tt> in the first place. Specifically,
<tt>error_code</tt> and <tt>error_condition</tt> are intended to perform the following
roles:
</p>
<ul>
<li>
<tt>error_code</tt> holds the original error produced by the operating
 system.
</li>
<li>
<tt>error_condition</tt> and the generic category provide a set of well
 known error constants that error codes may be tested against.
</li>
</ul>
<p>
Any mapping determining correspondence of the returned error code to
the conditions listed in the error condition clause falls under the
"latitude" granted to implementors in 19.5.1.5 [syserr.errcat.objects].
(Although obviously their latitude is restricted a little by the
need to match the right error condition when returning an error code
from a library function.)
</p>
<p>
It is important that this <tt>error_code/error_condition</tt> usage is done
correctly for the thread library since it is likely to set the
pattern for future TR libraries that interact with the operating
system.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Move to Open, and recommend the issue be deferred until after the next
Committee Draft is issued.
</blockquote>

<p><i>[
2009-10 post-Santa Cruz:
]</i></p>


<blockquote>
Move to Tentatively Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 30.2.2 [thread.req.exception]/2:
</p>

<blockquote>
<p>
-2- <del>The <tt>error_category</tt> (19.5.1.1) of the <tt>error_code</tt> reported by
such an exception's <tt>code()</tt> member function 
is as specified in the error condition Clause.</del>
<ins>
The <tt>error_code</tt> reported by such an exception's <tt>code()</tt> member
function shall compare equal to one of the conditions specified in
the function's error condition Clause. [<i>Example:</i> When the thread
constructor fails:
</ins>
</p>
<blockquote><pre><ins>
ec.category() == implementation-defined // probably system_category
ec == errc::resource_unavailable_try_again // holds true
</ins></pre></blockquote>

<p><ins>
&#8212; <i>end example</i>]
</ins></p>

</blockquote>






<hr>
<h3><a name="1110"></a>1110. Is <tt>for_each</tt> overconstrained?</h3>
<p><b>Section:</b> 25.2.4 [alg.foreach] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-04-29  <b>Last modified:</b> 2009-10-27</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.foreach">issues</a> in [alg.foreach].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Quoting working paper for reference (25.2.4 [alg.foreach]):
</p>

<blockquote>
<pre>template&lt;InputIterator Iter, Callable&lt;auto, Iter::reference&gt; Function&gt;
  requires CopyConstructible&lt;Function&gt;
  Function for_each(Iter first, Iter last, Function f);
</pre>
<blockquote>
<p>
1 Effects: Applies f to the result of dereferencing every iterator in the
 range [first,last), starting from first and proceeding to last - 1.
</p>
<p>
2 Returns: f.
</p>
<p>
3 Complexity: Applies f exactly last - first times.
</p>
</blockquote>
</blockquote>

<p>
P2 implies the passed object <tt>f</tt> should be invoked at each stage, rather than
some copy of <tt>f</tt>.  This is important if the return value is to usefully
accumulate changes.  So the requirements are an object of type <tt>Function</tt> can
be passed-by-value, invoked multiple times, and then return by value.  In
this case, <tt>MoveConstructible</tt> is sufficient. This would open support for
move-only functors, which might become important in concurrent code as you
can assume there are no other references (copies) of a move-only type and so
freely use them concurrently without additional locks.
</p>

<p><i>[
See further discussion starting with c++std-lib-23686.
]</i></p>


<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Pete suggests we may want to look at this in a broader context
involving other algorithms.
We should also consider the implications of parallelism.
</p>
<p>
Move to Open, and recommend the issue be deferred until after the next
Committee Draft is issued.
</p>
</blockquote>

<p><i>[
2009-10-14 Daniel de-conceptified the proposed resolution.
]</i></p>


<blockquote>
<p>
The note in 25.1 [algorithms.general]/9 already says the right thing:
</p>
<blockquote>
Unless otherwise specified, algorithms that take function objects
as arguments are permitted to copy those function objects freely.
</blockquote>
<p>
So we only need to ensure that the wording for <tt>for_each</tt> is sufficiently
clear, which is the intend of the following rewording.
</p>
</blockquote>

<p><i>[
2009-10-15 Daniel proposes:
]</i></p>


<blockquote>
<ul>
<li>
<p>
Add a new Requires clause just after the prototype declaration (25.2.4 [alg.foreach]):
</p>
<blockquote>
<p>
<ins><i>Requires:</i> <tt>Function</tt> shall be <tt>MoveConstructible</tt>
( [moveconstructible]), <tt>CopyConstructible</tt> is not required.</ins>
</p>
</blockquote>
</li>
<li>
<p>
Change 25.2.4 [alg.foreach]/2 as indicated:
</p>

<blockquote>
<i>Returns:</i> <ins>std::move(</ins>f<ins>)</ins>.
</blockquote>
</li>
</ul>
</blockquote>

<p><i>[
2009-10 post-Santa Cruz:
]</i></p>


<blockquote>
Move to Tentatively Ready, using Daniel's wording without the portion
saying "CopyConstructible is not required".
</blockquote>

<p><i>[
2009-10-27 Daniel adds:
]</i></p>


<blockquote>
<p>
I see that during the Santa Cruz meeting the originally proposed addition
</p>

<blockquote>
, <tt>CopyConstructible</tt> is not required.
</blockquote>

<p>
was removed. I don't think that this removal was a good idea. The combination
of 25.1 [algorithms.general]/9
</p>

<blockquote>
[<i>Note:</i> Unless otherwise specified, algorithms that take function objects
as arguments are permitted to copy those function objects freely.[..]
</blockquote>

<p>
with the fact that <tt>CopyConstructible</tt> is a refinement <tt>MoveConstructible</tt>
makes it necessary that such an explicit statement is given. Even the
existence of the usage of <tt>std::move</tt> in the <i>Returns</i> clause doesn't
help much, because this would still be well-formed for a <tt>CopyConstructible</tt>
without move constructor. Let me add that the originally proposed
addition reflects current practice in the standard, e.g. 25.3.9 [alg.unique]/5
usages a similar terminology.
</p>

<p>
For similar wording need in case for auto_ptr see <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#973">973</a>.
</p>

<p><i>[
Howard: Moved from Tentatively Ready to Open.
]</i></p>

</blockquote>



<p><b>Proposed resolution:</b></p>
<ul>
<li>
<p>
Add a new Requires clause just after the prototype declaration (25.2.4 [alg.foreach]):
</p>
<blockquote>
<p>
<ins><i>Requires:</i> <tt>Function</tt> shall be <tt>MoveConstructible</tt>
( [moveconstructible]).</ins>
</p>
</blockquote>
</li>
<li>
<p>
Change 25.2.4 [alg.foreach]/2 as indicated:
</p>

<blockquote>
<i>Returns:</i> <ins>std::move(</ins>f<ins>)</ins>.
</blockquote>
</li>
</ul>








<hr>
<h3><a name="1112"></a>1112. bitsets and new style for loop</h3>
<p><b>Section:</b> 20.3.7 [template.bitset] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Future">Tentatively NAD Future</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-05-06  <b>Last modified:</b> 2009-10-26</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#template.bitset">active issues</a> in [template.bitset].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#template.bitset">issues</a> in [template.bitset].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20NAD%20Future">Tentatively NAD Future</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>Std::bitset</tt> is a homogeneous container-like sequence of bits, yet it does
not model the Range concept so cannot be used with the new for-loop syntax.
It is the only such type in the library that does NOT support the new for
loop.
</p>
<p>
The obvious reason is that bitset does not support iterators.
</p>
<p>
At least two reasonable solutions are available:
</p>
<ol type="i">
<li>
Add an iterator interface to <tt>bitset</tt>, bringing its interface close to that
of <tt>std::array</tt>
</li>
<li>
Provide an unspecified concept_map for <tt>Range&lt;bitset&gt;</tt>.
</li>
</ol>
<p>
The latter will still need some kind of iterator-like adapter for <tt>bitset</tt>,
but gives implementers greater freedom on the details. E.g. begin/end return
some type that simply invokes <tt>operator[]</tt> on the object it wraps, and
increments its index on <tt>operator++</tt>.  A vendor can settle for <tt>InputIterator</tt>
support, rather than wrapping up a full <tt>RandomAccessIterator</tt>.
</p>
<p>
I have a mild preference for option (ii) as I think it is less work to
specify at this stage of the process, although (i) is probably more useful
in the long run.
</p>
<p>
Hmm, my wording looks a little woolly, as it does not say what the element
type of the range is.  Do I get a range of <tt>bool</tt>, <tt>bitset&lt;N&gt;::reference</tt>, or
something else entirely?
</p>
<p>
I guess most users will assume the behaviour of reference, but expect to
work with <tt>bool</tt>.  <tt>Bool</tt> is OK for read-only traversal, but you really need to
take a reference to a <tt>bitset::reference</tt> if you want to write back.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Move to Open.
We further recommend this be deferred until after the next Committee Draft.
</blockquote>

<p><i>[
2009-05-25 Alisdair adds:
]</i></p>


<blockquote>
<p>
I just stumbled over the <tt>Range concept_map</tt> for <tt>valarray</tt> and this should
probably set the precedent on how to write the wording.
</p>

<p><i>[
Howard: I've replaced the proposed wording with Alisdair's suggestion.
]</i></p>


</blockquote>

<p><i>[
2009-07-24 Daniel modifies the proposed wording for non-concepts.
]</i></p>


<p><i>[
2009-10 post-Santa Cruz:
]</i></p>


<blockquote>
Mark as Tentatively NAD Future due to the loss of concepts.
</blockquote>



<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>
Modify the section 20.3.7 [template.bitset] <tt>&lt;bitset&gt;</tt> synopsis by adding
the following at the end of the synopsis:
</p>
<blockquote><pre><ins>
// XX.X.X bitset range access [bitset.range]
template&lt;size_t N&gt; <i>unspecified-1</i> begin(bitset&lt;N&gt;&amp;);
template&lt;size_t N&gt; <i>unspecified-2</i> begin(const bitset&lt;N&gt;&amp;);
template&lt;size_t N&gt; <i>unspecified-1</i> end(bitset&lt;N&gt;&amp;);
template&lt;size_t N&gt; <i>unspecified-2</i> end(const bitset&lt;N&gt;&amp;);
</ins>
</pre></blockquote>
</li>
<li>
<p>
Add a new section <ins>"bitset range access" [bitset.range]</ins>
after the current section 20.3.7.3 [bitset.operators] with the following series of
paragraphs:
</p>
<blockquote>
<p>
<ins>
1.  In the <tt>begin</tt> and <tt>end</tt> function templates that follow, <i>unspecified-1</i>
is a type that meets the requirements of a mutable random access
iterator (24.2.5 [random.access.iterators]) whose <tt>value_type</tt> is <tt>bool</tt> and
whose reference type is <tt>bitset&lt;N&gt;::reference</tt>.
<i>unspecified-2</i> is a type that meets the requirements of a constant
random access iterator (24.2.5 [random.access.iterators]) whose <tt>value_type</tt>
is <tt>bool</tt> and whose reference type is <tt>bool</tt>.
</ins>
</p>
<pre><ins>
template&lt;size_t N&gt; <i>unspecified-1</i> begin(bitset&lt;N&gt;&amp;);
template&lt;size_t N&gt; <i>unspecified-2</i> begin(const bitset&lt;N&gt;&amp;);
</ins>
</pre>
<blockquote>
<ins>2.  Returns: an iterator referencing the first bit in the bitset.</ins>
</blockquote>

<pre><ins>
template&lt;size_t N&gt; <i>unspecified-1</i> end(bitset&lt;N&gt;&amp;);
template&lt;size_t N&gt; <i>unspecified-2</i> end(const bitset&lt;N&gt;&amp;);
</ins></pre>

<blockquote>
<ins>3.  Returns: an iterator referencing one past the last bit in the
bitset.</ins>
</blockquote>
</blockquote>
</li>
</ol>












<hr>
<h3><a name="1113"></a>1113. <tt>bitset::to_string</tt> could be simplified</h3>
<p><b>Section:</b> 20.3.7 [template.bitset] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-05-09  <b>Last modified:</b> 2009-10-26</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#template.bitset">active issues</a> in [template.bitset].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#template.bitset">issues</a> in [template.bitset].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#853">853</a> our resolution is changing the signature by adding two
defaulting arguments to 3 calls.  In principle, this means that ABI breakage
is not an issue, while API is preserved.
</p>
<p>
With that observation, it would be very nice to use the new ability to
supply default template parameters to function templates to collapse all 3
signatures into 1.  In that spirit, this issue offers an alternative resolution
than that of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#853">853</a>.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Move to Open,
and look at the issue again after <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#853">853</a> has been accepted.
We further recommend this be deferred until after the next Committee Draft.
</blockquote>

<p><i>[
2009-10 post-Santa Cruz:
]</i></p>


<blockquote>
Move to Tentatively Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>

<ol type="A">
<li>
<p>
In 20.3.7 [template.bitset]/1 (class bitset) ammend:
</p>
<blockquote><pre>template &lt;class charT <ins>= char</ins>,
            class traits <ins>= char_traits&lt;charT&gt;</ins>,
            class Allocator <ins>= allocator&lt;charT&gt;</ins>&gt; 
  basic_string&lt;charT, traits, Allocator&gt;
  to_string(charT zero = charT('0'), charT one = charT('1')) const;
<del>template &lt;class charT, class traits&gt; 
  basic_string&lt;charT, traits, allocator&lt;charT&gt; &gt; to_string() const; 
template &lt;class charT&gt; 
  basic_string&lt;charT, char_traits&lt;charT&gt;, allocator&lt;charT&gt; &gt; to_string() const; 
basic_string&lt;char, char_traits&lt;char&gt;, allocator&lt;char&gt; &gt; to_string() const;</del>
</pre></blockquote>
</li>
<li>
<p>
In 20.3.7.2 [bitset.members] prior to p35 ammend:
</p>
<blockquote><pre>template &lt;class charT <ins>= char</ins>,
            class traits <ins>= char_traits&lt;charT&gt;</ins>,
            class Allocator <ins>= allocator&lt;charT&gt;</ins>&gt; 
  basic_string&lt;charT, traits, Allocator&gt;
  to_string(charT zero = charT('0'), charT one = charT('1')) const;
</pre></blockquote>
</li>
<li>
Strike 20.3.7.2 [bitset.members] paragraphs 37 -&gt; 39 (including signature
above 37)
</li>
</ol>






<hr>
<h3><a name="1114"></a>1114. Type traits underspecified</h3>
<p><b>Section:</b> 20.6 [meta] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2009-05-12  <b>Last modified:</b> 2009-10-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#meta">issues</a> in [meta].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Related to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#975">975</a> and <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1023">1023</a>.
</p>

<p>
The current wording in 20.6.1 [meta.rqmts] is still unclear concerning
it's requirements on the type traits classes regarding ambiguities.
Specifically it's unclear
</p>

<ul>
<li>
if a predicate trait (20.6.4 [meta.unary], 20.6.5 [meta.rel]) could derive from both
<tt>true_type</tt>/<tt>false_type</tt>.
</li>
<li>
if any of the type traits (20.6.1 [meta.rqmts], 20.6.4 [meta.unary], 20.6.5 [meta.rel]) could ambiguously derive
from the same specified result type.
</li>
<li>
if any of the type traits (20.6.1 [meta.rqmts], 20.6.4 [meta.unary], 20.6.5 [meta.rel]) could derive from other
<tt>integral_constant</tt> types making the contained names ambiguous
</li>
<li>
if any of the type traits (20.6.1 [meta.rqmts], 20.6.4 [meta.unary], 20.6.5 [meta.rel]) could have other base
classes that contain members hiding the name of the result type members
or make the contained member names ambiguous.
</li>
</ul>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Alisdair would prefer to factor some of the repeated text,
but modulo a corner case or two,
he believes the proposed wording is otherwise substantially correct.
</p>
<p>
Move to Open.
</p>
</blockquote>

<p><i>[
2009-10 post-Santa Cruz:
]</i></p>


<blockquote>
Move to Tentatively Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p><i>[
The usage of the notion of a <i>BaseCharacteristic</i> below
might be
useful in other places - e.g. to define the base class relation in
20.7.5 [refwrap], 20.7.14 [func.memfn], or 20.7.15.2 [func.wrap.func].
In this case it's definition should probably
be moved to Clause 17
]</i></p>


<ol>
<li>
<p>
Change 20.6.1 [meta.rqmts]/1 as indicated:
</p>
<blockquote>
[..] It shall be <tt>DefaultConstructible</tt>, <tt>CopyConstructible</tt>, and publicly
<ins>and unambiguously</ins> derived, directly or indirectly, from
<ins>its <i>BaseCharacteristic</i>, which is</ins> a specialization of the
template <tt>integral_constant</tt> (20.6.3), with the arguments to the template
<tt>integral_constant</tt> determined by the requirements for the particular
property being described. <ins>The member names of the
<i>BaseCharacteristic</i> shall be unhidden and unambiguously
available in the <i>UnaryTypeTrait</i>.</ins>
</blockquote>
</li>
<li>
<p>
Change 20.6.1 [meta.rqmts]/2 as indicated:
</p>
<blockquote>
[..] It shall be <tt>DefaultConstructible</tt>, <tt>CopyConstructible</tt>, and publicly
<ins>and unambiguously</ins> derived, directly or indirectly, from
<del>an instance</del> <ins>its <i>BaseCharacteristic</i>, which is a
specialization</ins> of the template <tt>integral_constant</tt> (20.6.3), with
the arguments to the template <tt>integral_constant</tt> determined by the
requirements for the particular relationship being described. <ins>The
member names of the <i>BaseCharacteristic</i> shall be unhidden
and unambiguously available in the <i>BinaryTypeTrait</i>.</ins>
</blockquote>
</li>
<li>
<p>
Change 20.6.4 [meta.unary]/2 as indicated:
</p>
<blockquote>
Each of these templates shall be a <i>UnaryTypeTrait</i> (20.6.1),
<del>publicly derived directly or indirectly from <tt>true_type</tt> if the
corresponding condition is true, otherwise from <tt>false_type</tt></del>
<ins>where its <i>BaseCharacteristic</i> shall be <tt>true_type</tt> if the
corresponding condition is true, otherwise <tt>false_type</tt></ins>.
</blockquote>
</li>
<li>
<p>
Change 20.6.5 [meta.rel]/2 as indicated:
</p>

<blockquote>
Each of these templates shall be a <i>BinaryTypeTrait</i> (20.6.1),
<del>publicly derived directly or indirectly from <tt>true_type</tt> if the
corresponding condition is true, otherwise from <tt>false_type</tt></del>
<ins>where its <i>BaseCharacteristic</i> shall be <tt>true_type</tt> if the
corresponding condition is true, otherwise <tt>false_type</tt></ins>.
</blockquote>
</li>
</ol>






<hr>
<h3><a name="1115"></a>1115. <tt>va_copy</tt> missing from Standard macros table</h3>
<p><b>Section:</b> C.2 [diff.library] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">Tentatively NAD Editorial</a>
 <b>Submitter:</b> Miles Zhao <b>Opened:</b> 2009-05-23  <b>Last modified:</b> 2009-10-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#diff.library">issues</a> in [diff.library].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20NAD%20Editorial">Tentatively NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In "Table 122 -- Standard macros" of C.2 [diff.library], which lists the 56 macros
inherited from C library, <tt>va_copy</tt> seems to be missing. But in
"Table 21 -- Header <tt>&lt;cstdarg&gt;</tt> synopsis" (18.10 [support.runtime]), there is.
</p>

<p><i>[
2009-10 post-Santa Cruz:
]</i></p>


<blockquote>
Mark as Tentatively NAD Editorial, if Pete disagrees, Howard
will move to Tentatively Ready
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add <tt>va_copy</tt> to Table 122 -- Standard macros in C.2 [diff.library].
</p>





<hr>
<h3><a name="1118"></a>1118. tuple query APIs do not support cv-qualification</h3>
<p><b>Section:</b> 20.5.2.5 [tuple.helper] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-05-23  <b>Last modified:</b> 2009-10-26</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#tuple.helper">active issues</a> in [tuple.helper].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#tuple.helper">issues</a> in [tuple.helper].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The APIs <tt>tuple_size</tt> and <tt>tuple_element</tt> do not support
cv-qualified <tt>tuple</tt>s, <tt>pair</tt>s or <tt>array</tt>s.
</p>
<p>
The most generic solution would be to supply partial specializations once
for each cv-type in the <tt>tuple</tt> header.  However, requiring this header for
cv-qualified <tt>pair</tt>s/<tt>array</tt>s seems unhelpful.  The BSI editorial
suggestion (UK-198/US-69,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2533.html">N2533</a>)
to merge <tt>tuple</tt> into <tt>&lt;utility&gt;</tt> would help with <tt>pair</tt>,
but not <tt>array</tt>.  That might be resolved by making a dependency between the
<tt>&lt;array&gt;</tt> header and <tt>&lt;utility&gt;</tt>, or simply recognising
the dependency be fulfilled in a Remark.
</p>

<p><i>[
2009-05-24 Daniel adds:
]</i></p>


<blockquote>
<p>
All <tt>tuple_size</tt> templates with a base class need to derive publicly, e.g.
</p>

<blockquote><pre>template &lt;IdentityOf T&gt; class tuple_size&lt; const T &gt; :
   <ins>public</ins> tuple_size&lt;T&gt; {};
</pre></blockquote>

<p>
The same applies to the tuple_element class hierarchies.
</p>
<p>
What is actually meant with the comment
</p>
<blockquote>
this solution relies on 'metafunction forwarding' to inherit the
nested typename type
</blockquote>
<p>
?
</p>
<p>
I ask, because all base classes are currently unconstrained and their
instantiation is invalid in the constrained context of the <tt>tuple_element</tt> partial
template specializations.
</p>
</blockquote>

<p><i>[
2009-05-24 Alisdair adds:
]</i></p>


<blockquote>
<p>
I think a better solution might be to ask Pete editorially to change all
declarations of tupling APIs to use the struct specifier instead of class.
</p>
<p>
"metafunction forwarding" refers to the MPL metafunction protocol, where a
metafunction result is declared as a nested typedef with the name "type",
allowing metafunctions to be chained by means of inheritance.  It is a
neater syntax than repeatedly declaring a typedef, and inheritance syntax is
slightly nicer when it comes to additional typename keywords.
</p>
<p>
The constrained template with an unconstrained base is a good observation
though.
</p>
</blockquote>

<p><i>[
2009-10 post-Santa Cruz:
]</i></p>


<blockquote>
Move to Open, Alisdair to provide wording. Once wording is
provided, Howard will move to Review.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add to 20.5.1 [tuple.general] p2 (Header <tt>&lt;tuple&gt;</tt> synopsis)
</p>

<blockquote><pre>// 20.5.2.3, tuple helper classes:
template &lt;IdentityOf T&gt; class tuple_size; // undefined
<ins>template &lt;IdentityOf T&gt; class tuple_size&lt; const T &gt; : tuple_size&lt;T&gt; {};</ins>
<ins>template &lt;IdentityOf T&gt; class tuple_size&lt; volatile T &gt; : tuple_size&lt;T&gt; {};</ins>
<ins>template &lt;IdentityOf T&gt; class tuple_size&lt; const volatile T &gt; : tuple_size&lt;T&gt; {};</ins>

template &lt;VariableType... Types&gt; class tuple_size&lt;tuple&lt;Types...&gt; &gt;;

template &lt;size_t I, IdentityOf T&gt; class tuple_element; // undefined
<ins>template &lt;size_t I, IdentityOf T&gt; class tuple_element&lt;I, const T&gt;;</ins>
<ins>template &lt;size_t I, IdentityOf T&gt; class tuple_element&lt;I, volatile T&gt;;</ins>
<ins>template &lt;size_t I, IdentityOf T&gt; class tuple_element&lt;I, const volatile T&gt;;</ins>

template &lt;size_t I, VariableType... Types&gt;
  requires True&lt;(I &lt; sizeof...(Types))&gt; class tuple_element&lt;I, tuple&lt;Types...&gt; &gt;;
</pre></blockquote>

<p>
Add to 20.5.2.5 [tuple.helper]
</p>
<p><i>[
(note that this solution relies on 'metafunction forwarding' to inherit the
nested typename type)
]</i></p>


<blockquote><pre>template &lt;class... Types&gt;
class tuple_size&lt;tuple&lt;Types...&gt; &gt;
  : public integral_constant&lt;size_t, sizeof...(Types)&gt; { };

template &lt;size_t I, class... Types&gt;
requires True&lt;(I &lt; sizeof...(Types))&gt;
class tuple_element&lt;I, tuple&lt;Types...&gt; &gt; {
public:
  typedef TI type;
};

<ins>template &lt;size_t I, IdentityOf T&gt;
  class tuple_element&lt;I, const T&gt; : add_const&lt;tuple_element&lt;I,T&gt;&gt; {};</ins>

<ins>template &lt;size_t I, IdentityOf T&gt;
  class tuple_element&lt;I, volatile T&gt; : add_volatile&lt;tuple_element&lt;I,T&gt;&gt; {};</ins>

<ins>template &lt;size_t I, IdentityOf T&gt;
  class tuple_element&lt;I, const volatile T&gt; : add_cv&lt;tuple_element&lt;I,T&gt;&gt; {};</ins>
</pre></blockquote>





<hr>
<h3><a name="1119"></a>1119. tuple query APIs do not support references</h3>
<p><b>Section:</b> 20.5.2.5 [tuple.helper] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-05-23  <b>Last modified:</b> 2009-10-26</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#tuple.helper">active issues</a> in [tuple.helper].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#tuple.helper">issues</a> in [tuple.helper].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <tt>tuple</tt> query APIs <tt>tuple_size</tt> and
<tt>tuple_element</tt> do not support references-to-tuples.  This can be
annoying when a template deduced a parameter type to be a reference,
which must be explicitly stripped with <tt>remove_reference</tt> before calling
these APIs.
</p>
<p>
I am not proposing a resolution at this point, as there is a
combinatorial explosion with lvalue/rvalue references and
cv-qualification (see previous issue) that suggests some higher
refactoring is in order.  This might be something to kick back over to
Core/Evolution.
</p>
<p>
Note that we have the same problem in numeric_limits.
</p>

<p><i>[
2009-10 post-Santa Cruz:
]</i></p>


<blockquote>
Move to Open. Alisdair to provide wording.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1121"></a>1121. Support for multiple arguments</h3>
<p><b>Section:</b> 20.4.2 [ratio.arithmetic] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Future">Tentatively NAD Future</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-05-25  <b>Last modified:</b> 2009-11-02</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#ratio.arithmetic">issues</a> in [ratio.arithmetic].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20NAD%20Future">Tentatively NAD Future</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Both add and multiply could sensibly be called with more than two arguments.
The variadic template facility makes such declarations simple, and is likely
to be frequently wrapped by end users if we do not supply the variant
ourselves.
</p>
<p>
We deliberately ignore divide at this point as it is not transitive.
Likewise, subtract places special meaning on the first argument so I do not
suggest extending that immediately.  Both could be supported with analogous
wording to that for add/multiply below.
</p>
<p>
Note that the proposed resolution is potentially incompatible with that
proposed for <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#921">921</a>, although the addition of the typedef to ratio would be
equally useful.
</p>

<p><i>[
2009-10-30 Alisdair adds:
]</i></p>


<blockquote>
<p>
The consensus of the group when we reviewed this in Santa Cruz was that
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#921">921</a> would proceed to Ready as planned, and the
multi-paramater add/multiply templates should be renamed as
<tt>ratio_sum</tt> and <tt>ratio_product</tt> to avoid the problem
mixing template aliases with partial specializations.
</p>

<p>
It was also suggested to close this issue as NAD Future as it does not
correspond directly to any NB comment.  NBs are free to submit a
specific comment (and re-open) in CD2 though.
</p>

<p>
Walter Brown also had concerns on better directing the order of
evaluation to avoid overflows if we do proceed for 0x rather than TR1,
so wording may not be complete yet.
</p>

<p><i>[
Alisdair updates wording.
]</i></p>


</blockquote>

<p><i>[
2009-10-30 Howard:
]</i></p>


<blockquote>
Moved to Tentatively NAD Future after 5 positive votes on c++std-lib.
</blockquote>



<p><b>Proposed resolution:</b></p>

<p>
Add the following type traits to p3 20.4 [ratio]
</p>

<blockquote><pre>// ratio arithmetic
template &lt;class R1, class R2&gt; struct ratio_add;
template &lt;class R1, class R2&gt; struct ratio_subtract;
template &lt;class R1, class R2&gt; struct ratio_multiply;
template &lt;class R1, class R2&gt; struct ratio_divide;
<ins>template &lt;class R1, class ... RList&gt; struct ratio_sum;</ins>
<ins>template &lt;class R1, class ... RList&gt; struct ratio_product;</ins>
</pre></blockquote>

<p>
after 20.4.2 [ratio.arithmetic] p1: add
</p>

<blockquote><pre>template &lt;class R1, class ... RList&gt; struct ratio_sum; // declared, never defined

template &lt;class R1&gt; struct ratio_sum&lt;R1&gt; : R1 {};
</pre>

<blockquote>
<i>Requires:</i> <tt>R1</tt> is a specialization of class template <tt>ratio</tt>
</blockquote>

<pre>template &lt;class R1, class R2, class ... RList&gt; 
 struct ratio_sum&lt;R1, R2, RList...&gt;
   : ratio_add&lt; R1, ratio_sum&lt;R2, RList...&gt;&gt; {
};
</pre>

<blockquote>
<i>Requires:</i> <tt>R1</tt> and each element in parmater pack
<tt>RList</tt> is a specialization of class template <tt>ratio</tt>
</blockquote>
</blockquote>

<p>
after 20.4.2 [ratio.arithmetic] p3: add
</p>

<blockquote><pre>template &lt;class R1, class ... RList&gt; struct ratio_product; // declared, never defined

template &lt;class R1&gt; struct ratio_product&lt;R1&gt; : R1 {};
</pre>

<blockquote>
<i>Requires:</i> <tt>R1</tt> is a specialization of class template <tt>ratio</tt>
</blockquote>

<pre>template &lt;class R1, class R2, class ... RList&gt; 
 struct ratio_sum&lt;R1, R2, RList...&gt;
   : ratio_add&lt; R1, ratio_product&lt;R2, RList...&gt;&gt; {
};
</pre>

<blockquote>
<i>Requires:</i> <tt>R1</tt> and each element in parmater pack
<tt>RList</tt> is a specialization of class template <tt>ratio</tt>
</blockquote>
</blockquote>








<hr>
<h3><a name="1123"></a>1123. no requirement that standard streams be flushed</h3>
<p><b>Section:</b> 27.5.2.1.6 [ios::Init] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> James Kanze <b>Opened:</b> 2009-05-14  <b>Last modified:</b> 2009-10-20</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#ios::Init">issues</a> in [ios::Init].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
As currently formulated, the standard doesn't require that there 
is ever a flush of <tt>cout</tt>, etc.  (This implies, for example, that 
the classical hello, world program may have no output.)  In the 
current draft
(<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2798.pdf">N2798</a>),
there is a requirement that the objects 
be constructed before <tt>main</tt>, and before the dynamic 
initialization of any non-local objects defined after the 
inclusion of <tt>&lt;iostream&gt;</tt> in the same translation unit.  The only 
requirement that I can find concerning flushing, however, is in 
27.5.2.1.6 [ios::Init], where the destructor of the last 
<tt>std::ios_base::Init</tt> object flushes.  But there is, as far as I 
can see, no guarantee that such an object ever exists. 
</p>
<p>
Also, the wording in  [iostreams.objects] says that:
</p>
<blockquote>
The objects 
are constructed and the associations are established at some 
time prior to or during the first time an object of class 
<tt>ios_base::Init</tt> is constructed, and in any case before the body 
of main begins execution.
</blockquote>
<p>
In 27.5.2.1.6 [ios::Init], however, as an 
effect of the constructor, it says that
</p>
<blockquote>
If <tt>init_cnt</tt> is zero, 
the function stores the value one in <tt>init_cnt</tt>, then constructs 
and initializes the objects <tt>cin</tt>, <tt>cout</tt>, <tt>cerr</tt>, <tt>clog</tt> 
<tt>wcin</tt>, <tt>wcout</tt>, <tt>wcerr</tt>, and <tt>wclog</tt>"
</blockquote>

<p>
which seems to forbid earlier 
construction. 
</p>

<p>
(Note that with these changes, the exposition only "<tt>static 
int init_cnt</tt>" in <tt>ios_base::Init</tt> can be dropped.) 
</p>
<p>
Of course, a determined programmer can still inhibit the 
flush with things like: 
</p>
<blockquote><pre>new std::ios_base::Init ;       //  never deleted 
</pre></blockquote>
<p>
or (in a function): 
</p>
<blockquote><pre>std::ios_base::Init ensureConstruction ; 
//  ... 
exit( EXIT_SUCCESS ) ; 
</pre></blockquote>
<p>
Perhaps some words somewhere to the effect that all 
<tt>std::ios_base::Init</tt> objects should have static lifetime 
would be in order. 
</p>

<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote>
Moved to Ready.  Some editorial changes are expected (in addition to the
proposed wording) to remove <tt>init_cnt</tt> from <tt>Init</tt>.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 27.4 [iostream.objects]/2:
</p>

<blockquote>
-2- The objects are constructed and the associations are established at
some time prior to or during the first time an object of class
<tt>ios_base::Init</tt> is constructed, and in any case before the body
of main begins execution.<sup>292</sup> The objects are not destroyed
during program execution.<sup>293</sup>
<del>If a translation unit includes
<tt>&lt;iostream&gt;</tt> or explicitly constructs an
<tt>ios_base::Init</tt> object, these stream objects shall be
constructed before dynamic initialization of non-local objects defined
later in that translation unit.</del>
<ins>The results of including <tt>&lt;iostream&gt;</tt> in a translation
unit shall be as if <tt>&lt;iostream&gt;</tt> defined an instance of
<tt>ios_base::Init</tt> with static lifetime. Similarly, the entire
program shall behave as if there were at least one instance of
<tt>ios_base::Init</tt> with static lifetime.</ins>
</blockquote>

<p>
Change 27.5.2.1.6 [ios::Init]/3:
</p>

<blockquote>
<pre>Init();
</pre>
<blockquote>
-3- <i>Effects:</i> Constructs an object of class <tt>Init</tt>. 
<del>If <tt>init_cnt</tt> is zero, the function stores the value one in
<tt>init_cnt</tt>, then constructs and initializes the objects
<tt>cin</tt>, <tt>cout</tt>, <tt>cerr</tt>, <tt>clog</tt> (27.4.1),
<tt>wcin</tt>, <tt>wcout</tt>, <tt>wcerr</tt>, and <tt>wclog</tt>
(27.4.2). In any case, the function then adds one to the value stored in
<tt>init_cnt</tt>.</del>
<ins>Constructs and initializes the objects <tt>cin</tt>, <tt>cout</tt>,
<tt>cerr</tt>, <tt>clog</tt>, <tt>wcin</tt>, <tt>wcout</tt>,
<tt>wcerr</tt> and <tt>wclog</tt> if they have not already been
constructed and initialized.</ins>
</blockquote>
</blockquote>

<p>
Change 27.5.2.1.6 [ios::Init]/4:
</p>

<blockquote>
<pre>~Init();
</pre>
<blockquote>
-4- <i>Effects:</i> Destroys an object of class <tt>Init</tt>.
<del>The function subtracts one from the value stored in <tt>init_cnt</tt> and,
if the resulting stored value is one,</del>
<ins>If there are no other instances of the class still in
existance,</ins>
calls <tt>cout.flush()</tt>,
<tt>cerr.flush()</tt>, <tt>clog.flush()</tt>, <tt>wcout.flush()</tt>,
<tt>wcerr.flush()</tt>, <tt>wclog.flush()</tt>.
</blockquote>
</blockquote>






<hr>
<h3><a name="1125"></a>1125. ostream_iterator does not work with movable types</h3>
<p><b>Section:</b> 24.6.2.2 [ostream.iterator.ops] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-05-28  <b>Last modified:</b> 2009-05-30</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>ostream_iterator</tt> has not been updated to support moveable types, in a
similar manner to the insert iterators.
Note that this is not a problem for <tt>ostreambuf_iterator</tt>, as the types it is
restricted to dealing with do not support extra-efficient moving.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add second <tt>operator=</tt> overload to class <tt>template ostream_iterator</tt>
in 24.6.2 [ostream.iterator], para 2:
</p>

<blockquote><pre>ostream_iterator&lt;T,charT,traits&gt;&amp; operator=(const T&amp; value);
<ins>ostream_iterator&lt;T,charT,traits&gt;&amp; operator=(T&amp;&amp; value);</ins>
</pre></blockquote>

<p>
Add a new paragraph: in 24.6.2.2 [ostream.iterator.ops]:
</p>

<blockquote>
<pre>ostream_iterator&amp; operator=(T&amp;&amp; value);
</pre>
<blockquote>
<p>
-2- <i>Effects:</i>
</p>
<blockquote><pre>*out_stream &lt;&lt; std::move(value);
if(delim != 0)
  *out_stream &lt;&lt; delim;
return (*this);
</pre></blockquote>
</blockquote>
</blockquote>






<hr>
<h3><a name="1126"></a>1126. <tt>istreambuff_iterator::equal</tt> needs a const &amp; parameter</h3>
<p><b>Section:</b> 24.6.3.5 [istreambuf.iterator::equal] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-05-28  <b>Last modified:</b> 2009-11-02</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#istreambuf.iterator::equal">issues</a> in [istreambuf.iterator::equal].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <tt>equal</tt> member function of <tt>istreambuf_iterator</tt> is
declared <tt>const</tt>, but takes its argument by non-const reference.
</p>
<p>
This is not compatible with the <tt>operator==</tt> free function overload, which is
defined in terms of calling <tt>equal</tt> yet takes both arguments by reference to
const.
</p>

<p><i>[
The proposed wording is consistent with <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#110">110</a> with status TC1.
]</i></p>


<p><i>[
2009-11-02 Howard adds:
]</i></p>


<blockquote>
Set to Tentatively Ready after 5 positive votes on c++std-lib.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Ammend in both:<br>
24.6.3 [istreambuf.iterator]<br>
24.6.3.5 [istreambuf.iterator::equal]<br>
</p>

<blockquote><pre>bool equal(<ins>const </ins>istreambuf_iterator&amp; b) const;
</pre></blockquote>






<hr>
<h3><a name="1130"></a>1130. <tt>copy_exception</tt> name misleading</h3>
<p><b>Section:</b> 18.8.5 [propagation] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Review">Review</a>
 <b>Submitter:</b> Peter Dimov <b>Opened:</b> 2009-05-13  <b>Last modified:</b> 2009-10-20</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#propagation">active issues</a> in [propagation].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#propagation">issues</a> in [propagation].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Review">Review</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The naming of <tt>std::copy_exception</tt> misleads almost everyone
(experts included!) to think that it is the function that copies an
<tt>exception_ptr</tt>:
</p>

<blockquote><pre>exception_ptr p1 = current_exception();
exception_ptr p2 = copy_exception( p1 );
</pre></blockquote>

<p>
But this is not at all what it does. The above actually creates an
<tt>exception_ptr p2</tt> that contains a copy of <tt>p1</tt>, not of
the exception to which <tt>p1</tt> refers!
</p>
<p>
This is, of course, all my fault; in my defence, I used <tt>copy_exception</tt>
because I was unable to think of a better name.
</p>
<p>
But I believe that, based on what we've seen so far, <em>any</em> other name would be better.
</p>
<p>
Therefore, I propose <tt>copy_exception</tt> to be renamed to
<tt>create_exception</tt>:
</p>

<blockquote><pre>template&lt;class E&gt; exception_ptr create_exception(E e);
</pre></blockquote>

<p>
with the following explanatory paragraph after it:
</p>

<blockquote>
Creates an <tt>exception_ptr</tt> that refers to a copy of <tt>e</tt>.
</blockquote>

<p><i>[
2009-05-13 Daniel adds:
]</i></p>


<blockquote>
<p>
What about
</p>
<blockquote><pre>make_exception_ptr
</pre></blockquote>
<p>
in similarity to <tt>make_pair</tt> and <tt>make_tuple</tt>, <tt>make_error_code</tt> and
<tt>make_error_condition</tt>, or <tt>make_shared</tt>? Or, if a stronger symmetry to
<tt>current_exception</tt> is preferred:
</p>

<blockquote><pre>make_exception
</pre></blockquote>
<p>
We have not a single <tt>create_*</tt> function in the library, it was always
<tt>make_*</tt> used.
</p>
</blockquote>

<p><i>[
2009-05-13 Peter adds:
]</i></p>


<blockquote>
<tt>make_exception_ptr</tt> works for me.
</blockquote>

<p><i>[
2009-06-02 Thomas J. Gritzan adds:
]</i></p>


<blockquote>
<p>
To avoid surprises and unwanted recursion, how about making a call to
<tt>std::make_exception_ptr</tt> with an <tt>exception_ptr</tt> illegal?
</p>
<p>
It might work like this:
</p>
<blockquote><pre>template&lt;class E&gt;
exception_ptr make_exception_ptr(E e);
template&lt;&gt;
exception_ptr make_exception_ptr&lt;exception_ptr&gt;(exception_ptr e) = delete;
</pre></blockquote>
</blockquote>

<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote>
Move to Review for the time being. The subgroup thinks this is a good
idea, but doesn't want to break compatibility unnecessarily if someone
is already shipping this. Let's talk to Benjamin and PJP tomorrow to
make sure neither objects.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 18.8.5 [propagation]:
</p>

<blockquote>
<pre>template&lt;class E&gt; exception_ptr <del>copy_exception</del><ins>make_exception_ptr</ins>(E e);
</pre>

<blockquote>
<p>
-11- <i>Effects:</i> <ins>Creates an <tt>exception_ptr</tt> that refers
to a copy of <tt>e</tt>,</ins> as if
</p>

<blockquote><pre>try {
  throw e;
} catch(...) {
  return current_exception();
}
</pre></blockquote>

<p>...</p>
</blockquote>

</blockquote>






<hr>
<h3><a name="1131"></a>1131. C++0x does not need <tt>alignment_of</tt></h3>
<p><b>Section:</b> 20.6.4.3 [meta.unary.prop] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Niels Dekker <b>Opened:</b> 2009-06-01  <b>Last modified:</b> 2009-06-02</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#meta.unary.prop">active issues</a> in [meta.unary.prop].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#meta.unary.prop">issues</a> in [meta.unary.prop].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <tt>alignment_of</tt> template is no longer necessary, now that the
core language will provide <tt>alignof</tt>. Scott Meyers raised this
issue at comp.std.c++,
<a href="http://groups.google.com/group/comp.std.c++/browse_thread/thread/9b020306e803f08a">C++0x: alignof vs. alignment_of</a>,
May 21, 2009.  In a reply, Daniel Krgler pointed out that
<tt>alignof</tt> was added to the working paper <i>after</i>
<tt>alignment_of</tt>. So it appears that <tt>alignment_of</tt> is only
part of the current Working Draft 
(<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2857.pdf">N2857</a>)
because it is in TR1.
</p>
<p>
Having both <tt>alignof</tt> and <tt>alignment_of</tt> would cause
unwanted confusion. In general, I think TR1 functionality should not be
brought into C++0x if it is entirely redundant with other C++0x language
or library features.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Remove from Header &lt;type_traits&gt; synopsis 20.6.2 [meta.type.synop]:
</p>
<blockquote><pre><del>template &lt;class T&gt; struct alignment_of;</del>
</pre></blockquote>

<p>
Remove the first row of Table 34 ("Type property queries"), from
Type properties 20.6.4.3 [meta.unary.prop]:
</p>
<blockquote>
<table border="1">
<caption>Table 34 -- Type property queries</caption>
<tbody><tr>
<td><del><tt>template &lt;class T&gt; struct alignment_of;</tt></del></td>
<td><del><tt>alignof(T)</tt>.</del><br>
<del><i>Precondition:</i> <tt>T</tt> shall be a complete type, a reference
type, or an array of unknown bound, but shall not be a function type or
(possibly cv-qualified) <tt>void</tt>.</del>
</td>
</tr>
</tbody></table>
</blockquote>

<p>
Change text in Table 41 ("Other transformations"), from Other
transformations 20.6.7 [meta.trans.other], as follows:
</p>
<blockquote>
<table border="1">
<caption>Table 41 -- Other transformations</caption>
<tbody><tr><td>...</td>
<td>
 Align shall be equal to <tt>
 <del>alignment_of&lt;T&gt;::value</del>
 <ins>alignof(T)</ins>
 </tt> for some type <tt>T</tt> or to <i>default-alignment</i>.
</td>
<td>...</td>
</tr></tbody></table>
</blockquote>





<hr>
<h3><a name="1133"></a>1133. Does N2844 break current specification of list::splice?</h3>
<p><b>Section:</b> 23.3.3.5 [forwardlist.ops], 23.3.4.4 [list.ops] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-05-09  <b>Last modified:</b> 2009-10-27</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#forwardlist.ops">issues</a> in [forwardlist.ops].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
IIUC,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2844.html">N2844</a>
means that lvalues will no longer bind to rvalue references.
Therefore, the current specification of <tt>list::splice</tt> (list
operations 23.3.4.4 [list.ops]) will be a breaking change of behaviour for existing
programs.  That is because we changed the signature to swallow via an rvalue
reference rather than the lvalue reference used in 03.
</p>
<p>
Retaining this form would be safer, requiring an explicit move when splicing
from lvalues.  However, this will break existing programs.
We have the same problem with <tt>forward_list</tt>, although without the risk of
breaking programs so here it might be viewed as a positive feature.
</p>
<p>
The problem signatures:
</p>
<blockquote><pre>void splice_after(const_iterator position, forward_list&lt;T,Alloc&gt;&amp;&amp; x);
void splice_after(const_iterator position, forward_list&lt;T,Alloc&gt;&amp;&amp; x,
                  const_iterator i);
void splice_after(const_iterator position, forward_list&lt;T,Alloc&gt;&amp;&amp; x,
                  const_iterator first, const_iterator last);

void splice(const_iterator position, list&lt;T,Alloc&gt;&amp;&amp; x);
void splice(const_iterator position, list&lt;T,Alloc&gt;&amp;&amp; x,
            const_iterator i);
void splice(const_iterator position, list&lt;T,Alloc&gt;&amp;&amp; x,
            const_iterator first, const_iterator last);
</pre></blockquote>

<b>Possible resolutions:</b>

<p>
Option A.   Add an additional (non-const) lvalue-reference
overload in each case
</p>
<p>
Option B.   Change rvalue reference back to (non-const)
lvalue-reference overload in each case
</p>
<p>
Option C.   Add an additional (non-const) lvalue-reference
overload in just the <tt>std::list</tt> cases
</p>
<p>
I think (B) would be very unfortunate, I really like the <tt>forward_list</tt>
behaviour in (C) but feel (A) is needed for consistency.
</p>
<p>
My actual preference would be NAD, ship with this as a breaking change as it
is a more explicit interface.  I don't think that will fly though!
</p>

<p>
See the thread starting with c++std-lib-23725 for more discussion.
</p>

<p><i>[
2009-10-27 Christopher Jefferson provides proposed wording for Option C.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
In 23.3.4 [list]
</p>

<p>
Add lvalue overloads before rvalue ones:
</p>

<blockquote><pre><ins>void splice(const_iterator position, list&lt;T,Allocator&gt;&amp; x);</ins>
void splice(const_iterator position, list&lt;T,Allocator&gt;&amp;&amp; x);
<ins>void splice(const_iterator position, list&lt;T,Allocator&gt;&amp; x, const_iterator i);</ins>
void splice(const_iterator position, list&lt;T,Allocator&gt;&amp;&amp; x, const_iterator i);
<ins>void splice(const_iterator position, list&lt;T,Allocator&gt;&amp; x,
            const_iterator first, const_iterator last);</ins>
void splice(const_iterator position, list&lt;T,Allocator&gt;&amp;&amp; x,
            const_iterator first, const_iterator last);
</pre></blockquote>

<p>
In 23.3.4.4 [list.ops], similarly add lvalue overload before each rvalue one:
</p>
<p>
(After paragraph 2)
</p>

<blockquote><pre><ins>void splice(const_iterator position, list&lt;T,Allocator&gt;&amp; x);</ins>
void splice(const_iterator position, list&lt;T,Allocator&gt;&amp;&amp; x);
</pre></blockquote>

<p>
(After paragraph 6)
</p>

<blockquote><pre><ins>void splice(const_iterator position, list&lt;T,Allocator&gt;&amp; x, const_iterator i);</ins>
void splice(const_iterator position, list&lt;T,Allocator&gt;&amp;&amp; x, const_iterator i);
</pre></blockquote>

<p>
(After paragraph 10)
</p>

<blockquote><pre><ins>void splice(const_iterator position, list&lt;T,Allocator&gt;&amp; x,
            const_iterator first, const_iterator last);</ins>
void splice(const_iterator position, list&lt;T,Allocator&gt;&amp;&amp; x,
            const_iterator first, const_iterator last);
</pre></blockquote>






<hr>
<h3><a name="1134"></a>1134. Redundant specification of stdint.h, fenv.h, tgmath.h, and maybe complex.h</h3>
<p><b>Section:</b> 18.4.2 [stdinth], 26.3.2 [fenv], 26.8 [c.math], 26.4.11 [cmplxh] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Robert Klarer <b>Opened:</b> 2009-05-26  <b>Last modified:</b> 2009-10-20</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
This is probably editorial.
</p>
<p>
The following items should be removed from the draft, because they're
redundant with Annex D, and they arguably make some *.h headers
non-deprecated:
</p>
<p>
18.4.2 [stdinth] (regarding <tt>&lt;stdint.h&gt;</tt>) 
</p>
<p>
26.3.2 [fenv] (regarding <tt>&lt;fenv.h&gt;</tt>
</p>
<p>
Line 3 of 26.8 [c.math] (regarding <tt>&lt;tgmath.h&gt;</tt>) 
</p>
<p>
26.4.11 [cmplxh] (regarding <tt>&lt;complex.h&gt;</tt>, though the note in this subclause is not redundant) 
</p>

<p><i>[
2009-06-10 Ganesh adds:
]</i></p>


<blockquote>
While searching for <tt>stdint</tt> in the CD, I found that <tt>&lt;stdint.h&gt;</tt> is also
mentioned in 3.9.1 [basic.fundamental] /5. It guess it should refer to
<tt>&lt;cstdint&gt;</tt> instead.
</blockquote>

<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote>
Real issue. Maybe just editorial, maybe not. Move to Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Remove the section 18.4.2 [stdinth].
</p>
<p>
Remove the section 26.3.2 [fenv].
</p>
<p>
Remove 26.8 [c.math], p3:
</p>

<blockquote>
<del>-3- The header <tt>&lt;tgmath.h&gt;</tt> effectively includes the headers <tt>&lt;complex.h&gt;</tt>
and <tt>&lt;math.h&gt;</tt>.</del>
</blockquote>
<p>
Remove the section 26.4.11 [cmplxh].
</p>





<hr>
<h3><a name="1135"></a>1135. <tt>exception_ptr</tt> should support contextual conversion to <tt>bool</tt></h3>
<p><b>Section:</b> 18.8.5 [propagation] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2007-06-06  <b>Last modified:</b> 2009-10-20</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#propagation">active issues</a> in [propagation].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#propagation">issues</a> in [propagation].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
As of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2857.pdf">N2857</a>
18.8.5 [propagation]/5, the implementation-defined type
<tt>exception_ptr</tt> does provide the following ways to check whether
it is a null value:
</p>
<blockquote><pre>void f(std::exception_ptr p) {
  p == nullptr;
  p == 0;
  p == exception_ptr();
}
</pre></blockquote>
<p>
This is rather cumbersome way of checking for the null value
and I suggest to require support for evaluation in a boolean
context like so:
</p>

<blockquote><pre>void g(std::exception_ptr p) {
  if (p) {}
  !p;
}
</pre></blockquote>

<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote>
Move to Ready. Note to editor: considering putting in a cross-reference
to 4 [conv], paragraph 3, which defines the phrase
"contextually converted to <tt>bool</tt>".
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
In section 18.8.5 [propagation] insert a new paragraph between p.5 and p.6:
</p>

<blockquote>
<ins>
An object <tt>e</tt> of type <tt>exception_ptr</tt> can be contextually converted to <tt>bool</tt>.
The effect shall be as if <tt>e != exception_ptr()</tt> had been evaluated in place
of <tt>e</tt>. There shall be no implicit conversion to arithmetic type, to
enumeration type or to pointer type.
</ins>
</blockquote>





<hr>
<h3><a name="1136"></a>1136. Incomplete specification of <tt>nested_exception::rethrow_nested()</tt></h3>
<p><b>Section:</b> 18.8.6 [except.nested] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2007-06-06  <b>Last modified:</b> 2009-10-20</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#except.nested">active issues</a> in [except.nested].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#except.nested">issues</a> in [except.nested].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It was recently mentioned in a newsgroup article
<a href="http://groups.google.de/group/comp.std.c++/msg/f82022aff68edf3d">http://groups.google.de/group/comp.std.c++/msg/f82022aff68edf3d</a>
that the specification of the member function <tt>rethrow_nested()</tt> of the
class <tt>nested_exception</tt> is incomplete, specifically it remains unclear
what happens, if member <tt>nested_ptr()</tt> returns a null value. In
18.8.6 [except.nested] we find only the following paragraph related to that:
</p>
<blockquote><pre>void rethrow_nested() const; // [[noreturn]]
</pre>
<blockquote>
-4- <i>Throws:</i> the stored exception captured by this <tt>nested_exception</tt> object.
</blockquote>
</blockquote>
<p>
This is a problem, because it is possible to create an object of
<tt>nested_exception</tt> with exactly such a state, e.g.
</p>
<blockquote><pre>#include &lt;exception&gt;
#include &lt;iostream&gt;

int main() try {
  std::nested_exception e; // OK, calls current_exception() and stores it's null value
  e.rethrow_nested(); // ?
  std::cout &lt;&lt; "A" &lt;&lt; std::endl;
}
catch(...) {
  std::cout &lt;&lt; "B" &lt;&lt; std::endl;
}
</pre></blockquote>
<p>
I suggest to follow the proposal of the reporter, namely to invoke
<tt>terminate()</tt> if <tt>nested_ptr()</tt> return a null value of <tt>exception_ptr</tt> instead
of relying on the fallback position of undefined behavior. This would
be consistent to the behavior of a <tt>throw;</tt> statement when no
exception is being handled.
</p>

<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote>
Move to Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change around 18.8.6 [except.nested]/4 as indicated:
</p>
<blockquote>
<p>
-4- <i>Throws:</i> the stored exception captured by this <tt>nested_exception</tt>
object<ins>, if <tt>nested_ptr() != nullptr</tt></ins>
</p>
<p>
<ins>- <i>Remarks:</i> If <tt>nested_ptr() == nullptr</tt>, <tt>terminate()</tt>
shall be called.</ins>
</p>
</blockquote>





<hr>
<h3><a name="1137"></a>1137. Return type of <tt>conj</tt> and <tt>proj</tt></h3>
<p><b>Section:</b> 26.4.9 [cmplx.over] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Marc Steinbach <b>Opened:</b> 2009-06-11  <b>Last modified:</b> 2009-06-27</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#cmplx.over">issues</a> in [cmplx.over].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In clause 1, the Working Draft 
(<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2857.pdf">N2857</a>)
specifies overloads of the
functions
</p>
<blockquote><pre>arg, conj, imag, norm, proj, real
</pre></blockquote>
<p>
for non-complex arithmetic types (<tt>float</tt>, <tt>double</tt>,
<tt>long double</tt>, and integers).
The only requirement (clause 2) specifies effective type promotion of arguments.
</p>
<p>
I strongly suggest to add the following requirement on the return types:
</p>
<blockquote>
All the specified overloads must return real (i.e., non-complex) values,
specifically, the nested <tt>value_type</tt> of effectively promoted arguments.
</blockquote>

<p>
(This has no effect on <tt>arg</tt>, <tt>imag</tt>, <tt>norm</tt>, <tt>real</tt>:
they are real-valued anyway.)
</p>
<p><b>Rationale:</b></p>
<p>
Mathematically, <tt>conj()</tt> and <tt>proj()</tt>, like the transcendental functions, are
complex-valued in general but map the (extended) real line to itself.
In fact, both functions act as identity on the reals.
A typical user will expect <tt>conj()</tt> and <tt>proj()</tt> to preserve this essential
mathematical property in the same way as <tt>exp()</tt>, <tt>sin()</tt>, etc.
A typical use of <tt>conj()</tt>, e.g., is the generic scalar product of n-vectors:
</p>

<blockquote><pre>template&lt;typename T&gt;
inline T
scalar_product(size_t n, T const* x, T const* y) {
  T result = 0;
  for (size_t i = 0; i &lt; n; ++i)
    result += x[i] * std::conj(y[i]);
  return result;
}
</pre></blockquote>
<p>
This will work equally well for real and complex floating-point types <tt>T</tt> if
<tt>conj()</tt> returns <tt>T</tt>. It will not work with real types if <tt>conj()</tt>
returns complex values.
</p>
<p>
Instead, the implementation of <tt>scalar_product</tt> becomes either less efficient
and less useful (if a complex result is always returned), or unnecessarily
complicated (if overloaded versions with proper return types are defined).
In the second case, the real-argument overload of <tt>conj()</tt> cannot be used.
In fact, it must be avoided.
</p>
<p>
Overloaded <tt>conj()</tt> and <tt>proj()</tt> are principally needed in generic programming.
All such use cases will benefit from the proposed return type requirement,
in a similar way as the <tt>scalar_product</tt> example.
The requirement will not harm use cases where a complex return value
is expected, because of implicit conversion to complex.
Without the proposed return type guarantee, I find overloaded versions
of <tt>conj()</tt> and <tt>proj()</tt> not only useless but actually troublesome.
</p>



<p><b>Proposed resolution:</b></p>
<p>
Insert a new paragraph after 26.4.9 [cmplx.over]/2:
</p>

<blockquote>
<ins>
All of the specified overloads shall have a return type which is the nested <tt>value_type</tt> of
the effectively promoted arguments.
</ins>
</blockquote>





<hr>
<h3><a name="1138"></a>1138. unusual return value for operator+</h3>
<p><b>Section:</b> 21.4.8.1 [string::op+] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-06-12  <b>Last modified:</b> 2009-11-05</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Many of the <tt>basic_string operator+</tt> overloads return an rvalue-reference.  Is
that really intended?
</p>
<p>
I'm considering it might be a mild performance tweak to avoid making
un-necessary copies of a cheaply movable type, but it opens risk to dangling
references in code like:
</p>

<blockquote><pre>auto &amp;&amp; s = string{"x"} + string{y};
</pre></blockquote>

<p>
and I'm not sure about:
</p>

<blockquote><pre>auto s = string{"x"} + string{y};
</pre></blockquote>

<p><i>[
2009-10-11 Howard updated <i>Returns:</i> clause for each of these.
]</i></p>


<p><i>[
2009-11-05 Howard adds:
]</i></p>


<blockquote>
Moved to Tentatively Ready after 5 positive votes on c++std-lib.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Strike the <tt>&amp;&amp;</tt> from the return type in the following function
signatures:
</p>

<blockquote>
<p>
21.3 [string.classes] p2 Header Synopsis
</p>

<blockquote><pre>template&lt;class charT, class traits, class Allocator&gt;
  basic_string&lt;charT,traits,Allocator&gt;<del>&amp;&amp;</del>
    operator+(basic_string&lt;charT,traits,Allocator&gt;&amp;&amp; lhs,
              const basic_string&lt;charT,traits,Allocator&gt;&amp; rhs);

template&lt;class charT, class traits, class Allocator&gt;
  basic_string&lt;charT,traits,Allocator&gt;<del>&amp;&amp;</del>
    operator+(const basic_string&lt;charT,traits,Allocator&gt;&amp; lhs,
              basic_string&lt;charT,traits,Allocator&gt;&amp;&amp; rhs);

template&lt;class charT, class traits, class Allocator&gt;
  basic_string&lt;charT,traits,Allocator&gt;<del>&amp;&amp;</del>
    operator+(basic_string&lt;charT,traits,Allocator&gt;&amp;&amp; lhs,
              basic_string&lt;charT,traits,Allocator&gt;&amp;&amp; rhs);


template&lt;class charT, class traits, class Allocator&gt;
  basic_string&lt;charT,traits,Allocator&gt;<del>&amp;&amp;</del>
    operator+(const charT* lhs,
              basic_string&lt;charT,traits,Allocator&gt;&amp;&amp; rhs);

template&lt;class charT, class traits, class Allocator&gt;
  basic_string&lt;charT,traits,Allocator&gt;<del>&amp;&amp;</del>
    operator+(charT lhs, basic_string&lt;charT,traits,Allocator&gt;&amp;&amp; rhs);

template&lt;class charT, class traits, class Allocator&gt;
  basic_string&lt;charT,traits,Allocator&gt;<del>&amp;&amp;</del>
    operator+(basic_string&lt;charT,traits,Allocator&gt;&amp;&amp; lhs,
              const charT* rhs);

template&lt;class charT, class traits, class Allocator&gt;
  basic_string&lt;charT,traits,Allocator&gt;<del>&amp;&amp;</del>
    operator+(basic_string&lt;charT,traits,Allocator&gt;&amp;&amp; lhs, charT rhs);
</pre></blockquote>

<p>
21.4.8.1 [string::op+]
</p>

<blockquote><pre>template&lt;class charT, class traits, class Allocator&gt;
  basic_string&lt;charT,traits,Allocator&gt;<del>&amp;&amp;</del>
    operator+(basic_string&lt;charT,traits,Allocator&gt;&amp;&amp; lhs,
              const basic_string&lt;charT,traits,Allocator&gt;&amp; rhs);
</pre>
<blockquote>
<i>Returns:</i> <tt><ins>std::move(</ins>lhs.append(rhs)<ins>)</ins></tt>
</blockquote>
<pre>template&lt;class charT, class traits, class Allocator&gt;
  basic_string&lt;charT,traits,Allocator&gt;<del>&amp;&amp;</del>
    operator+(const basic_string&lt;charT,traits,Allocator&gt;&amp; lhs,
              basic_string&lt;charT,traits,Allocator&gt;&amp;&amp; rhs);
</pre>
<blockquote>
<i>Returns:</i> <tt><ins>std::move(</ins>rhs.insert(0, lhs)<ins>)</ins></tt>
</blockquote>
<pre>template&lt;class charT, class traits, class Allocator&gt;
  basic_string&lt;charT,traits,Allocator&gt;<del>&amp;&amp;</del>
    operator+(basic_string&lt;charT,traits,Allocator&gt;&amp;&amp; lhs,
              basic_string&lt;charT,traits,Allocator&gt;&amp;&amp; rhs);
</pre>
<blockquote>
<i>Returns:</i> <tt><ins>std::move(</ins>lhs.append(rhs)<ins>)</ins></tt> [<i>Note:</i> Or equivalently
<tt><ins>std::move(</ins>rhs.insert(0, lhs)<ins>)</ins></tt> &#8212; <i>end note</i>]
</blockquote>
<pre>template&lt;class charT, class traits, class Allocator&gt;
  basic_string&lt;charT,traits,Allocator&gt;<del>&amp;&amp;</del>
    operator+(const charT* lhs,
              basic_string&lt;charT,traits,Allocator&gt;&amp;&amp; rhs);
</pre>
<blockquote>
<i>Returns:</i> <tt><ins>std::move(</ins>rhs.insert(0, lhs)<ins>)</ins></tt>.
</blockquote>
<pre>template&lt;class charT, class traits, class Allocator&gt;
  basic_string&lt;charT,traits,Allocator&gt;<del>&amp;&amp;</del>
    operator+(charT lhs, basic_string&lt;charT,traits,Allocator&gt;&amp;&amp; rhs);
</pre>
<blockquote>
<i>Returns:</i> <tt><ins>std::move(</ins>rhs.insert(0, 1, lhs)<ins>)</ins></tt>.
</blockquote>
<pre>template&lt;class charT, class traits, class Allocator&gt;
  basic_string&lt;charT,traits,Allocator&gt;<del>&amp;&amp;</del>
    operator+(basic_string&lt;charT,traits,Allocator&gt;&amp;&amp; lhs,
              const charT* rhs);
</pre>
<blockquote>
<i>Returns:</i> <tt><ins>std::move(</ins>lhs.append(rhs)<ins>)</ins></tt>.
</blockquote>
<pre>template&lt;class charT, class traits, class Allocator&gt;
  basic_string&lt;charT,traits,Allocator&gt;<del>&amp;&amp;</del>
    operator+(basic_string&lt;charT,traits,Allocator&gt;&amp;&amp; lhs, charT rhs);
</pre>
<blockquote>
<i>Returns:</i> <tt><ins>std::move(</ins>lhs.append(1, rhs)<ins>)</ins></tt>.
</blockquote>
</blockquote>

</blockquote>






<hr>
<h3><a name="1144"></a>1144. "thread safe" is undefined</h3>
<p><b>Section:</b> 18.5 [support.start.term] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> LWG <b>Opened:</b> 2009-06-16  <b>Last modified:</b> 2009-10-20</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#support.start.term">issues</a> in [support.start.term].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 187</b></p>

<p>
The term "thread safe" is not defined nor used in this context
anywhere else in the standard.
</p>

<p><b>Suggested action:</b></p>
<p>
Clarify the meaning of "thread safe".
</p>

<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote>
<p>
The "thread safe" language has already been change in the WP. It was
changed to "happen before", but the current WP text is still a little
incomplete: "happen before" is binary, but the current WP text only
mentions one thing.
</p>
<p>
Move to Ready.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
For the following functions in 18.5 [support.start.term].
</p>
<blockquote><pre><code>
extern "C" int at_quick_exit(void (*f)(void));
extern "C++" int at_quick_exit(void (*f)(void));
</code></pre></blockquote>

<p>
Edit paragraph 10 as follows.
The intent is
to provide the other half of the happens before relation;
to note indeterminate ordering;
and to clean up some formatting.
</p>
<blockquote><p>
<i>Effects:</i>
The <code>at_quick_exit()</code> functions
register the function pointed to by <code>f</code>
to be called without arguments when <code>quick_exit</code> is called.
It is unspecified whether a call to <code>at_quick_exit()</code>
that does not <del>happen-before</del> <ins>happen before</ins> (1.10)
<ins>all calls to <code>quick_exit</code></ins>
will succeed.
[<i>Note:</i>
the <code>at_quick_exit()</code> functions
shall not introduce a data race (17.6.4.7).
<del>exitnote</del>
<ins>&#8212;<i>end note</i>]</ins>
<ins>
[<i>Note:</i>
The order of registration may be indeterminate
if <code>at_quick_exit</code> was called from more than one thread.
&#8212;<i>end note</i>]
</ins>
[<i>Note:</i> The <code>at_quick_exit</code> registrations
are distinct from the <code>atexit</code> registrations,
and applications may need to call both registration functions
with the same argument.
&#8212;<i>end note</i>]
</p></blockquote>

<p>
For the following function.
</p>
<blockquote><pre><code>
void quick_exit [[noreturn]] (int status)
</code></pre></blockquote>

<p>
Edit paragraph 13 as follows.
The intent is to note that thread-local variables may be different.
</p>
<blockquote><p>
<i>Effects:</i>
Functions registered by calls to <code>at_quick_exit</code>
are called in the reverse order of their registration,
except that a function shall be called
after any previously registered functions
that had already been called at the time it was registered.
Objects shall not be destroyed as a result of calling <code>quick_exit</code>.
If control leaves a registered function called by <code>quick_exit</code>
because the function does not provide a handler for a thrown exception,
<code>terminate()</code> shall be called.
<ins>
[<i>Note:</i>
Functions registered by one thread may be called by any thread,
and hence should not rely on the identity of thread-storage-duration objects.
&#8212;<i>end note</i>]
</ins>
After calling registered functions,
<code>quick_exit</code> shall call <code>_Exit(status)</code>.
[<i>Note:</i>
The standard file buffers are not flushed.
See: ISO C 7.20.4.4.
&#8212;<i>end note</i>]
</p></blockquote>





<hr>
<h3><a name="1151"></a>1151. Behavior of the library in the presence of threads is incompletely specified</h3>
<p><b>Section:</b> 17 [library] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> LWG <b>Opened:</b> 2009-06-28  <b>Last modified:</b> 2009-10-20</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US 63</b></p>

   <p><b>Description</b></p>
        <p>The behavior of the library in the presence of threads
        is incompletely specified.</p>
        <p>For example, if thread 1 assigns to <tt>X</tt>, then writes data
        to file <tt>f</tt>, which is read by thread 2, and then accesses
        variable <tt>X</tt>, is thread 2 guaranteed to be able to see the
        value assigned to <tt>X</tt> by thread 1? In other words, does the
        write of the data "happen before" the read?</p>
        <p>Another example: does simultaneous access using <tt>operator
        at()</tt> to different characters in the same non-const string
        really introduce a data race?</p>
<p><b>Suggestion</b></p>
<p><b>Notes</b></p><p>17 SG: should go to threads group; misclassified in document
</p>

    <p>Concurrency SG: Create an issue. Hans will look into it.</p>

<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote>
Move to "Open". Hans and the rest of the concurrency working group will
study this. We can't make progress without a thorough review and a
paper.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1152"></a>1152. expressions parsed differently than intended</h3>
<p><b>Section:</b> 22.4.2.2.2 [facet.num.put.virtuals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Seungbeom Kim <b>Opened:</b> 2009-06-27  <b>Last modified:</b> 2009-10-28</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#facet.num.put.virtuals">active issues</a> in [facet.num.put.virtuals].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#facet.num.put.virtuals">issues</a> in [facet.num.put.virtuals].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In Table 73 -- Floating-point conversions, 22.4.2.2.2 [facet.num.put.virtuals], 
in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2914.pdf">N2914</a>,
we have the following entries: 
</p>
<table border="1">
<caption>Table 73 &#8212; Floating-point conversions</caption>
<tbody><tr>
<th>State</th> <th><tt>stdio</tt> equivalent</th>
</tr>
<tr>
<td><tt>floatfield == ios_base::fixed | ios_base::scientific &amp;&amp; !uppercase</tt></td>
<td align="center"><tt>%a</tt></td>
</tr>

<tr>
<td><tt>floatfield == ios_base::fixed | ios_base::scientific</tt></td>
<td align="center"><tt>%A</tt></td>
</tr>
</tbody></table>

<p>
These expressions are supposed to mean: 
</p>

<blockquote><pre>floatfield == (ios_base::fixed | ios_base::scientific) &amp;&amp; !uppercase 
floatfield == (ios_base::fixed | ios_base::scientific) 
</pre></blockquote>
<p>
but technically parsed as: 
</p>
<blockquote><pre>((floatfield == ios_base::fixed) | ios_base::scientific) &amp;&amp; (!uppercase) 
((floatfield == ios_base::fixed) | ios_base::scientific) 
</pre></blockquote>
<p>
and should be corrected with additional parentheses, as shown above. 
</p>

<p><i>[
2009-10-28 Howard:
]</i></p>


<blockquote>
Moved to Tentatively Ready after 5 positive votes on c++std-lib.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change Table 83 &#8212; Floating-point conversions in  22.4.2.2.2 [facet.num.put.virtuals]:
</p>

<table border="1">
<caption>Table 83 &#8212; Floating-point conversions</caption>
<tbody><tr>
<th>State</th> <th><tt>stdio</tt> equivalent</th>
</tr>
<tr>
<td><tt>floatfield == <ins>(</ins>ios_base::fixed | ios_base::scientific<ins>)</ins> &amp;&amp; !uppercase</tt></td>
<td align="center"><tt>%a</tt></td>
</tr>

<tr>
<td><tt>floatfield == <ins>(</ins>ios_base::fixed | ios_base::scientific<ins>)</ins></tt></td>
<td align="center"><tt>%A</tt></td>
</tr>
</tbody></table>





<hr>
<h3><a name="1153"></a>1153. Standard library needs review for constructors to be
explicit to avoid treatment as initializer-list constructor</h3>
<p><b>Section:</b> 17 [library], 30 [thread], D [depr] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> LWG <b>Opened:</b> 2009-06-28  <b>Last modified:</b> 2009-10-20</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses DE 2</b></p>

<p><b>Description</b></p>
        <p>Marking a constructor with <tt>explicit</tt> has semantics
        even for a constructor with zero or several parameters:
        Such a constructor cannot be used with list-initialization
        in a copy-initialization context, see 13.3.1.7 [over.match.list]. The
        standard library apparently has not been reviewed for
        marking non-single-parameter constructors as <tt>explicit</tt>.</p>
<p><b>Suggestion</b></p>
        <p>Consider marking zero-parameter and multi-parameter
        constructors <tt>explicit</tt> in classes that have at least one
        constructor marked <tt>explicit</tt> and that do not have an
        initializer-list constructor.</p>

<p><b>Notes</b></p>
        <p>Robert Klarer to address this one.</p>

<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote>
Move to "Open". Robert Klarer has promised to provide wording.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1154"></a>1154. <tt>complex</tt> should accept integral types</h3>
<p><b>Section:</b> 26.4 [complex.numbers] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> LWG <b>Opened:</b> 2009-06-28  <b>Last modified:</b> 2009-10-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#complex.numbers">issues</a> in [complex.numbers].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses FR 35</b></p>

<p><b>Description</b></p>
        <p>Instantiations of the class
        template <tt>complex&lt;&gt;</tt> have to be allowed for integral
        types, to reflect existing practice and ISO standards
        (LIA-III).</p>
        
<p><b>Suggestion</b></p>

<p><i>[
2009-10-26 Proposed wording in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n3002.pdf">N3002</a>.
]</i></p>




<p><b>Proposed resolution:</b></p>
Adopt
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n3002.pdf">N3002</a>.





<hr>
<h3><a name="1156"></a>1156. Constraints on bitmask and enumeration types to be tightened</h3>
<p><b>Section:</b> 17.5.2.1.2 [enumerated.types], 17.5.2.1.3 [bitmask.types] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> LWG <b>Opened:</b> 2009-06-28  <b>Last modified:</b> 2009-10-27</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 165</b></p>

<p><b>Description</b></p>
        <p>Constraints on
        bitmask and enumeration types were supposed to be tightened
        up as part of the motivation for the <tt>constexpr</tt> feature -
        see paper
        <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2235.pdf">N2235</a>
        for details</p>
<p><b>Suggestion</b></p>
        <p>Adopt wording in line with the motivation
        described in
        <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2235.pdf">N2235</a></p>
<p><b>Notes</b></p>
        <p>Robert Klarer to review</p>

<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote>
Move to Open. Ping Robert Klarer to provide wording, using N2235 as
guidance.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1157"></a>1157. Local types can now instantiate templates</h3>
<p><b>Section:</b> 17.6.3.2.1 [namespace.std] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> LWG <b>Opened:</b> 2009-06-28  <b>Last modified:</b> 2009-10-21</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 175</b></p>

<p><b>Description</b></p>
        <p>Local types can
        now be used to instantiate templates, but don't have
        external linkage.</p>
<p><b>Suggestion</b></p>
        <p>Remove the reference to external linkage.</p>

<p><b>Notes</b></p>
<p>We accept the proposed solution. Martin will draft an issue.</p>

<p><i>[
2009-07-28 Alisdair provided wording.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Moved to Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
17.6.3.2.1 [namespace.std]
</p>
<p>
Strike "of external linkage" in p1 and p2:
</p>

<blockquote>
<p>
-1- The behavior of a C++ program is undefined if it adds declarations or
definitions to namespace <tt>std</tt> or to a namespace within namespace <tt>std</tt>
unless otherwise specified. A program may add a concept map for any
standard library concept or a template specialization for any standard
library template to namespace <tt>std</tt> only if the declaration depends on a
user-defined type <del>of external linkage</del> and the specialization meets the
standard library requirements for the original template and is not
explicitly prohibited.<sup>179</sup>
</p>

<p>
-2- The behavior of a C++ program is undefined if it declares
</p>
<ul>
<li>
an explicit specialization of any member function of a standard library
class template, or
</li>
<li>
an explicit specialization of any member function template of a standard
library class or class template, or
</li>
<li>
an explicit or partial specialization of any member class template of a
standard library class or class template.
</li>
</ul>
<p>
A program may explicitly instantiate a template defined in the standard
library only if the declaration depends on the name of a user-defined
type <del>of external linkage</del> and the instantiation meets the standard
library requirements for the original template.
</p>
</blockquote>






<hr>
<h3><a name="1158"></a>1158. Encouragement to use monotonic clock</h3>
<p><b>Section:</b> 30.2.4 [thread.req.timing] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> LWG <b>Opened:</b> 2009-06-28  <b>Last modified:</b> 2009-10-31</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 322, US 96</b></p>

<p><b>Description</b></p>
        <p>Not all systems
        can provide a monotonic clock. How are they expected to
        treat a _for function?</p>
<p><b>Suggestion</b></p>
        <p>Add at least a note explaining the intent
        for systems that do not support a monotonic clock.</p>

<p><b>Notes</b></p>
<p>Create an issue, together with UK 96. Note that the specification as is 
    already allows a non-monotonic clock due to the word &#8220;should&#8221; rather than 
    &#8220;shall&#8221;. If this wording is kept, a footnote should be added to make the 
    meaning clear.</p>

<p><i>[ 2009-06-29 Beman provided a proposed resolution. ] </i></p>

<p><i>[
2009-10-31 Howard adds:
]</i></p>


<blockquote>
Set to Tentatively Ready after 5 positive votes on c++std-lib.
</blockquote>



<p><b>Proposed resolution:</b></p>

<p><i>Change Timing specifications 30.2.4 [thread.req.timing] as indicated:</i></p>

<p>The member functions whose names end in <tt>_for</tt> take an argument that
specifies a relative time. Implementations
<del>should</del> <ins>are encouraged but not required to</ins> use a
monotonic clock to measure time for these functions.</p>






<hr>
<h3><a name="1159"></a>1159. Unclear spec for <tt>resource_deadlock_would_occur</tt></h3>
<p><b>Section:</b> 30.4.3.2.2 [thread.lock.unique.locking] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> LWG <b>Opened:</b> 2009-06-28  <b>Last modified:</b> 2009-07-04</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#thread.lock.unique.locking">active issues</a> in [thread.lock.unique.locking].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.lock.unique.locking">issues</a> in [thread.lock.unique.locking].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 327, UK 328</b></p>

<p><b>UK 327 Description</b></p>
        <p>Not clear what
        the specification for error condition
        <tt>resource_deadlock_would_occur</tt> means. It is perfectly
        possible for this thread to own the mutex without setting
        owns to true on this specific lock object. It is also
        possible for lock operations to succeed even if the thread
        does own the mutex, if the mutex is recursive. Likewise, if
        the mutex is not recursive and the mutex has been locked
        externally, it is not always possible to know that this
        error condition should be raised, depending on the host
        operating system facilities. It is possible that 'i.e.' was
        supposed to be 'e.g.' and that suggests that recursive
        locks are not allowed. That makes sense, as the
        exposition-only member owns is boolean and not a integer to
        count recursive locks.</p>
        
<p><b>UK 327 Suggestion</b></p>
        <p>Add a precondition <tt>!owns</tt>. Change the 'i.e.'
        in the error condition to be 'e.g.' to allow for this
        condition to propogate deadlock detection by the host OS.</p>
<p><b>UK 327 Notes</b></p>
<p>Create an issue. Assigned to Lawrence Crowl. Note: not sure what try_lock 
    means for recursive locks when you are the owner. POSIX has language on 
    this, which should ideally be followed. Proposed fix is not quite right, for 
    example, try_lock should have different wording from lock.</p>

<p><b>UK 328 Description</b></p>

        <p>There is a missing precondition that <tt>owns</tt>
        is true, or an <tt>if(owns)</tt> test is missing from the effect
        clause</p>
<p><b>UK 328 Suggestion</b></p>
        <p>Add a
        precondition that <tt>owns == true</tt>. Add an error condition to
        detect a violation, rather than yield undefined behaviour.</p>
<p><b>UK 328 Notes</b></p>
<p>Handle in same issue as UK 327. Also uncertain that the proposed resolution 
    is the correct one.</p>

    


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1169"></a>1169. <tt>num_get</tt> not fully compatible with <tt>strto*</tt></h3>
<p><b>Section:</b> 22.4.2.1.2 [facet.num.get.virtuals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Cosmin Truta <b>Opened:</b> 2009-07-04  <b>Last modified:</b> 2009-07-07</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#facet.num.get.virtuals">active issues</a> in [facet.num.get.virtuals].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#facet.num.get.virtuals">issues</a> in [facet.num.get.virtuals].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
As specified in the latest draft,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2914.pdf">N2914</a>,
<code>num_get</code> is still not fully compatible with the following C
functions: <code>strtoul</code>, <code>strtoull</code>, 
<code>strtof</code> and
<code>strtod</code>.
</p>
<p>
In C, when conversion of a string to an unsigned integer type falls 
outside the
representable range, <code>strtoul</code> and <code>strtoull</code> return
<code>ULONG_MAX</code> and <code>ULLONG_MAX</code>, respectively, 
regardless
whether the input field represents a positive or a negative value.
On the other hand, the result of <code>num_get</code> conversion of 
negative
values to unsigned integer types is zero. This raises a compatibility 
issue.
</p>
<p>
Moreover, in C, when conversion of a string to a floating-point type falls
outside the representable range, <code>strtof</code>, <code>strtod</code> 
and
<code>strtold</code> return <code>HUGE_VALF</code>,
<code>HUGE_VAL</code> and <code>HUGE_VALL</code>, respectively.
On the other hand, the result of <code>num_get</code> conversion of such
out-of-range floating-point values results in the most positive/negative
representable value.
Although many C library implementations do implement <code>HUGE_VAL</code>
(etc.) as the highest representable (which is, usually, the infinity), 
this
isn't required by the C standard. The C library specification makes no
statement regarding the value of <code>HUGE_VAL</code> and friends, which
potentially raises the same compatibility issue as in the above case of
unsigned integers.
In addition, neither C nor C++ define symbolic constants for the maximum
representable floating-point values (they only do so only for the maximum
representable <i>finite</i> floating-point values), which raises a 
usability
issue (it would be hard for the programmer to check the result of
<code>num_get</code> against overflow).
</p>
<p>
As such, we propose to adjust the specification of <code>num_get</code> to
closely follow the behavior of all of its underlying C functions.
</p>


<p><b>Proposed resolution:</b></p>

<p>
Change 22.4.2.1.2 [facet.num.get.virtuals] as follows:
</p>
<blockquote>
<p>
<b>Stage 3:</b>
The sequence of <code>char</code>s accumulated in stage 2 (the field) is
converted to a numeric value by the rules of one of the functions declared in
the header <code>&lt;cstdlib&gt;</code>:
</p>
<ul>
<li>For a signed integer value, the function <code>strtoll</code>.</li>
<li>For an unsigned integer value, the function <code>strtoull</code>.</li>
<li><ins>For a <code>float</code> value, the function
    <code>strtof</code>.</ins></li>
<li><ins>For a <code>double</code> value, the function
    <code>strtod</code>.</ins></li>
<li>For a <del>floating-point</del> <ins><code>long double</code></ins>
    value, the function <code>strtold</code>.</li>
</ul>
<p>
The numeric value to be stored can be one of:
</p>
<ul>
<li>zero, if the conversion function fails to convert the entire field.
    <del><code>ios_base::failbit</code> is assigned to <code>err</code>.</del></li>
<li>the most positive <ins>(or negative)</ins> representable value, if
    the field <ins>to be converted to a signed integer type</ins> represents a
    value too large positive <ins>(or negative)</ins> to be represented in
    <code>val</code>.
    <del><code>ios_base::failbit</code> is assigned to <code>err</code>.</del></li>
<li><del>the most negative representable value or zero for an unsigned integer
    type, if the field represents a value too large negative to be represented
    in <code>val</code>.
    <code>ios_base::failbit</code> is assigned to <code>err</code>.</del></li>
<li><ins>the most positive representable value, if the field to be converted to
    an unsigned integer type represents a value that cannot be represented in
    <code>val</code>.</ins></li>
<li>the converted value, otherwise.</li>
</ul>
<p>
The resultant numeric value is stored in <code>val</code>.
<ins>If the conversion function fails to convert the entire field, or if the
field represents a value outside the range of representable values,
<code>ios_base::failbit</code> is assigned to <code>err</code>.</ins>
</p>
</blockquote>






<hr>
<h3><a name="1170"></a>1170. String <i>char-like types</i> no longer PODs</h3>
<p><b>Section:</b> 21.1 [strings.general] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Beman Dawes <b>Opened:</b> 2009-06-22  <b>Last modified:</b> 2009-11-04</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 218</b></p>

<p>Prior to the introduction of constant expressions into the library, 
<tt>basic_string</tt> elements had to be POD types, and thus had to be both trivially 
copyable and standard-layout. This ensured that they could be memcpy'ed and 
would be compatible with other libraries and languages, particularly the C 
language and its library.</p>
<p>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2349.pdf">N2349</a>,
Constant Expressions in the Standard Library Revision 2, changed the 
requirement in 21/1 from "POD type" to "literal type". That change had the 
effect of removing the trivially copyable and standard-layout requirements from 
<tt>basic_string</tt> elements.</p>
<p>This means that <tt>basic_string</tt> elements no longer are guaranteed to be 
memcpy'able, and are no longer guaranteed to be standard-layout types:</p>
<blockquote>
  <p>3.9/p2 and 3.9/p3 both make it clear that a "trivially copyable type" is 
  required for memcpy to be guaranteed to work.</p>
  <p>Literal types (3.9p12) may have a non-trivial copy assignment operator, and 
  that violates the trivially copyable requirements given in 9/p 6, bullet item 
  2. </p>
  <p>Literal types (3.9p12) have no standard-layout requirement, either.</p>
</blockquote>
<p>This situation probably arose because the wording for "Constant Expressions 
in the Standard Library" was in process at the same time the C++ POD 
deconstruction wording was in process. </p>
<p>Since trivially copyable types meet the C++0x requirements for literal types, 
and thus work with constant expressions, it seems an easy fix to revert the 
<tt>basic_string</tt> element wording to its original state.</p>

 <p><i>[
 2009-07-28 Alisdair adds:
 ]</i></p>

 
<blockquote>
When looking for any resolution for this issue, consider the definition of
"character container type" in 17.3.4 [defns.character.container].  This
does require the character type to be a POD, and this term is used in a
number of places through clause 21 and 28. This suggests the PODness
constraint remains, but is much more subtle than before.  Meanwhile, I
suspect the change from POD type to literal type was intentional with
the assumption that trivially copyable types with
non-trivial-but-constexpr constructors should serve as well.  I don't
believe the current wording offers the right guarantees for either of
the above designs.
</blockquote>

<p><i>[
2009-11-04 Howard modifies proposed wording to disallow array types as
char-like types.
]</i></p>




<p><b>Proposed resolution:</b></p>

<p><i>Change General 21.1 [strings.general] as indicated:</i></p>
<blockquote>
<p>This Clause describes components for manipulating sequences of any
<del>literal</del> <ins>non-array POD</ins> (3.9) type. In this Clause
such types are called <i>char-like types</i>, and objects of char-like
types are called <i>char-like objects</i> or simply
<i>characters</i>.</p>
</blockquote>






<hr>
<h3><a name="1171"></a>1171. duration types should be literal</h3>
<p><b>Section:</b> 20.9.3 [time.duration] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-07-06  <b>Last modified:</b> 2009-10-31</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#time.duration">active issues</a> in [time.duration].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#time.duration">issues</a> in [time.duration].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <tt>duration</tt> types in 20.9.3 [time.duration] are exactly the sort of type
that should be "literal types" in the new standard.  Likewise,
arithmetic operations on <tt>duration</tt>s should be declared <tt>constexpr</tt>.
</p>

<p><i>[
2009-09-21 Daniel adds:
]</i></p>


<blockquote>
An alternative (and possibly preferable solution for potentially
heap-allocating big_int representation types) would be to ask the core
language to allow references to <tt>const</tt> literal types as feasible
arguments for <tt>constexpr</tt> functions.
</blockquote>

<p><i>[
2009-10-30 Alisdair adds:
]</i></p>


<blockquote>
<p>
I suggest this issue moves from New to Open.
</p>

<p>
Half of this issue was dealt with in paper
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2994.html">n2994</a>
on constexpr constructors.
</p>

<p>
The other half (duration arithmetic) is on hold pending Core support for
<tt>const &amp;</tt> in <tt>constexpr</tt> functions.
</p>

</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add <tt>constexpr</tt> to declaration of following functions and constructors:
</p>
<p>
p1 20.9 [time]
</p>

<blockquote>
<p>
<b>Header <tt>&lt;chrono&gt;</tt> synopsis</b>
</p>

<p><i>[Draughting note - observe switch to pass-by-value to support constexpr]</i></p>


<pre><i>// duration arithmetic</i>
template &lt;class Rep1, class Period1, class Rep2, class Period2&gt;
   typename common_type&lt;duration&lt;Rep1, Period1&gt;, duration&lt;Rep2, Period2&gt;&gt;::type
   <ins>constexpr</ins> operator+(<del>const</del> duration&lt;Rep1, Period1&gt;<del>&amp;</del> lhs, <del>const</del> duration&lt;Rep2, Period2&gt;<del>&amp;</del> rhs);
template &lt;class Rep1, class Period1, class Rep2, class Period2&gt;
   typename common_type&lt;duration&lt;Rep1, Period1&gt;, duration&lt;Rep2, Period2&gt;&gt;::type
   <ins>constexpr</ins> operator-(<del>const</del> duration&lt;Rep1, Period1&gt;<del>&amp;</del> lhs, <del>const</del> duration&lt;Rep2, Period2&gt;<del>&amp;</del> rhs);
template &lt;class Rep1, class Period, class Rep2&gt;
   duration&lt;typename common_type&lt;Rep1, Rep2&gt;::type, Period&gt;
   <ins>constexpr</ins> operator*(<del>const</del> duration&lt;Rep1, Period&gt;<del>&amp;</del> d, <del>const</del> Rep2<del>&amp;</del> s);
template &lt;class Rep1, class Period, class Rep2&gt;
   duration&lt;typename common_type&lt;Rep1, Rep2&gt;::type, Period&gt;
   <ins>constexpr</ins> operator*(<del>const</del> Rep1<del>&amp;</del> s, <del>const</del> duration&lt;Rep2, Period&gt;<del>&amp;</del> d);
template &lt;class Rep1, class Period, class Rep2&gt;
   duration&lt;typename common_type&lt;Rep1, Rep2&gt;::type, Period&gt;
   <ins>constexpr</ins> operator/(<del>const</del> duration&lt;Rep1, Period&gt;<del>&amp;</del> d, <del>const</del> Rep2<del>&amp;</del> s);
template &lt;class Rep1, class Period1, class Rep2, class Period2&gt;
   typename common_type&lt;Rep1, Rep2&gt;::type
   <ins>constexpr</ins> operator/(<del>const</del> duration&lt;Rep1, Period1&gt;<del>&amp;</del> lhs, <del>const</del> duration&lt;Rep2, Period2&gt;<del>&amp;</del> rhs);

<i>// duration comparisons</i>
template &lt;class Rep1, class Period1, class Rep2, class Period2&gt;
   <ins>constexpr</ins> bool operator==(<del>const</del> duration&lt;Rep1, Period1&gt;<del>&amp;</del> lhs, <del>const</del> duration&lt;Rep2, Period2&gt;<del>&amp;</del> rhs);
template &lt;class Rep1, class Period1, class Rep2, class Period2&gt;
   <ins>constexpr</ins> bool operator!=(<del>const</del> duration&lt;Rep1, Period1&gt;<del>&amp;</del> lhs, <del>const</del> duration&lt;Rep2, Period2&gt;<del>&amp;</del> rhs);
template &lt;class Rep1, class Period1, class Rep2, class Period2&gt;
   <ins>constexpr</ins> bool operator&lt; (<del>const</del> duration&lt;Rep1, Period1&gt;<del>&amp;</del> lhs, <del>const</del> duration&lt;Rep2, Period2&gt;<del>&amp;</del> rhs);
template &lt;class Rep1, class Period1, class Rep2, class Period2&gt;
   <ins>constexpr</ins> bool operator&lt;=(<del>const</del> duration&lt;Rep1, Period1&gt;<del>&amp;</del> lhs, <del>const</del> duration&lt;Rep2, Period2&gt;<del>&amp;</del> rhs);
template &lt;class Rep1, class Period1, class Rep2, class Period2&gt;
   <ins>constexpr</ins> bool operator&gt; (<del>const</del> duration&lt;Rep1, Period1&gt;<del>&amp;</del> lhs, <del>const</del> duration&lt;Rep2, Period2&gt;<del>&amp;</del> rhs);
template &lt;class Rep1, class Period1, class Rep2, class Period2&gt;
   <ins>constexpr</ins> bool operator&gt;=(<del>const</del>  duration&lt;Rep1, Period1&gt;<del>&amp;</del> lhs, <del>const</del> duration&lt;Rep2, Period2&gt;<del>&amp;</del> rhs);

<i>// duration_cast</i>
template &lt;class ToDuration, class Rep, class Period&gt;
   <ins>constexpr</ins> ToDuration duration_cast(<del>const</del> duration&lt;Rep, Period&gt;<del>&amp;</del> d);
</pre>

<p>
<b>20.9.3 [time.duration]</b>
</p>

<pre>template &lt;class Rep, class Period = ratio&lt;1&gt;&gt;
class duration {
  ....
public:
  <i>// 20.9.3.1, construct/copy/destroy:</i>
 <ins>constexpr</ins> duration() = default;

 template &lt;class Rep2&gt;
   <ins>constexpr</ins> explicit duration(const Rep2&amp; r);
 template &lt;class Rep2, class Period2&gt;
   <ins>constexpr</ins> duration(const duration&lt;Rep2, Period2&gt;&amp; d);

  <ins>constexpr</ins> duration(const duration&amp;) = default;

  <i>// 20.9.3.2, observer:</i>
  <ins>constexpr</ins> rep count() const;

  <i>// 20.9.3.3, arithmetic:</i>
  <ins>constexpr</ins> duration operator+() const;
  <ins>constexpr</ins> duration operator-() const;
  ...

};
</pre>
</blockquote>
<p><i>[
Note - this edit already seems assumed by definition of the duration static members <tt>zero/min/max</tt>.
They cannot meaningfully be <tt>constexpr</tt> without this change.
]</i></p>






<hr>
<h3><a name="1173"></a>1173. "Equivalence" wishy-washiness</h3>
<p><b>Section:</b> 17 [library] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> David Abrahams <b>Opened:</b> 2009-07-14  <b>Last modified:</b> 2009-10-20</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Issue: The <tt>CopyConstructible</tt> requirements are wishy-washy.  It requires
that the copy is "equivalent" to the original, but "equivalent" is never
defined.
</p>
<p>
I believe this to be an example of a more general lack of rigor around
copy and assignment, although I haven't done the research to dig up all
the instances.
</p>
<p>
It's a problem because if you don't know what <tt>CopyConstructible</tt> means,
you also don't know what it means to copy a pair of <tt>CopyConstructible</tt>
types.  It doesn't prevent us from writing code, but it is a hole in our
ability to understand the meaning of copy.
</p>
<p>
Furthermore, I'm pretty sure that vector's copy constructor doesn't
require the elements to be <tt>EqualityComparable</tt>, so that table is actually
referring to some ill-defined notion of equivalence when it uses ==.
</p>

<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote>
Move to "Open". Dave is right that this is a big issue. Paper D2987
("Defining Move Special Member Functions", Bjarne Stroustrup and
Lawrence Crowl) touches on this but does not solve it. This issue is
discussed in Elements of Programming.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1175"></a>1175. <tt>unordered</tt> complexity</h3>
<p><b>Section:</b> 23.2.5 [unord.req] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Pablo Halpern <b>Opened:</b> 2009-07-17  <b>Last modified:</b> 2009-07-19</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#unord.req">active issues</a> in [unord.req].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#unord.req">issues</a> in [unord.req].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
When I look at the <tt>unordered_*</tt> constructors, I think the complexity is poorly
described and does not follow the style of the rest of the standard.
</p>

<p>
The complexity for the default constructor is specified as constant.
 Actually, it is proportional to <tt>n</tt>, but there are no invocations of
<tt>value_type</tt> constructors or other <tt>value_type</tt> operations.
</p>

<p>
For the iterator-based constructor the complexity should be:
</p>

<blockquote>
<i>Complexity:</i> exactly <tt>n</tt> calls to construct <tt>value_type</tt>
from <tt>InputIterator::value_type</tt> (where <tt>n = distance(f,l)</tt>).
The number of calls to <tt>key_equal::operator()</tt> is proportional to
<tt>n</tt> in the average case and <tt>n*n</tt> in the worst case.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="1176"></a>1176. Make <tt>thread</tt> constructor non-variadic</h3>
<p><b>Section:</b> 30.3.1.2 [thread.thread.constr] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-07-18  <b>Last modified:</b> 2009-07-18</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#thread.thread.constr">active issues</a> in [thread.thread.constr].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.thread.constr">issues</a> in [thread.thread.constr].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The variadic <tt>thread</tt> constructor is causing controversy, e.g.
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2901.pdf">N2901</a>.
This issue has been created as a placeholder for this course of action.
</p>

<blockquote><pre>template &lt;class F<del>, class ...Args</del>&gt; thread(F&amp;&amp; f<del>, Args&amp;&amp;... args</del>);
</pre></blockquote>

<p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#929">929</a> for wording which specifies an rvalue-ref signature but
with "decay behavior", but using variadics.
</p>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="1177"></a>1177. Improve "diagnostic required" wording</h3>
<p><b>Section:</b> 20.9.3 [time.duration] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-07-18  <b>Last modified:</b> 2009-10-26</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#time.duration">active issues</a> in [time.duration].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#time.duration">issues</a> in [time.duration].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
"diagnostic required" has been used (by me) for code words meaning "use
<tt>enable_if</tt> to constrain templated functions.  This needs to be
improved by referring to the function signature as not participating in
the overload set, and moving this wording to a <i>Remarks</i> paragraph.
</p>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Moved to Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p><i>[
This proposed resolution addresses <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#947">947</a> and <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#974">974</a>. 
]</i></p>


<ol>
<li>
<p>
Change 20.9.3.1 [time.duration.cons]:
</p>

<blockquote>
<pre>template &lt;class Rep2&gt; 
  explicit duration(const Rep2&amp; r);
</pre>
<blockquote>
<p>
<i><del>Requires:</del> <ins>Remarks:</ins></i>
<tt>Rep2</tt> shall be implicitly convertible to <tt>rep</tt> and
</p>
<ul>
<li>
<tt>treat_as_floating_point&lt;rep&gt;::value</tt> shall be <tt>true</tt> or
</li>
<li>
<tt>treat_as_floating_point&lt;Rep2&gt;::value</tt> shall be <tt>false</tt>.
</li>
</ul>
<p>
<del>Diagnostic required</del> <ins>If these constraints are not met, this
constructor shall not participate in overload resolution</ins>. [<i>Example:</i>
</p>
<blockquote><pre>duration&lt;int, milli&gt; d(3); // OK 
duration&lt;int, milli&gt; d(3.5); // error 
</pre></blockquote>

<p>
&#8212; <i>end example</i>]
</p>

<p>
<i>Effects:</i> Constructs an object of type <tt>duration</tt>.
</p>

<p>
<i>Postcondition:</i> <tt>count() == static_cast&lt;rep&gt;(r)</tt>.
</p>

</blockquote>

<pre>template &lt;class Rep2, class Period2&gt;
  duration(const duration&lt;Rep2, Period2&gt;&amp; d);
</pre>
<blockquote>
<p>
<i><del>Requires:</del> <ins>Remarks:</ins></i> <tt>treat_as_floating_point&lt;rep&gt;::value</tt> shall be <tt>true</tt> or
<tt>ratio_divide&lt;Period2, period&gt;::type::den</tt> shall be 1<del>. Diagnostic
required</del><ins>, else this constructor shall not participate in overload
resolution</ins>. [<i>Note:</i> This requirement prevents implicit truncation error
when converting between integral-based duration types. Such a
construction could easily lead to confusion about the value of the
duration. &#8212; <i>end note</i>] [<i>Example:</i>
</p>

<blockquote><pre>duration&lt;int, milli&gt; ms(3); 
duration&lt;int, micro&gt; us = ms; // OK 
duration&lt;int, milli&gt; ms2 = us; // error 
</pre></blockquote>

<p>
&#8212; <i>end example</i>]
</p>

<p>
<i>Effects:</i> Constructs an object of type <tt>duration</tt>, constructing
<tt>rep_</tt> from
<tt>duration_cast&lt;duration&gt;(d).count()</tt>.
</p>

</blockquote>


</blockquote>
</li>

<li>
<p>
Change the following paragraphs in 20.9.3.5 [time.duration.nonmember]:
</p>

<blockquote>
<pre>template &lt;class Rep1, class Period, class Rep2&gt; 
  duration&lt;typename common_type&lt;Rep1, Rep2&gt;::type, Period&gt; 
  operator*(const duration&lt;Rep1, Period&gt;&amp; d, const Rep2&amp; s);
</pre>
<blockquote>
<i><del>Requires</del> <ins>Remarks</ins>:</i> <tt>Rep2</tt> shall be implicitly convertible to
<tt>CR(Rep1, Rep2)</tt><ins>, else this signature shall not participate in
overload resolution</ins>. <del>Diagnostic required.</del>
</blockquote>

<pre>template &lt;class Rep1, class Period, class Rep2&gt; 
  duration&lt;typename common_type&lt;Rep1, Rep2&gt;::type, Period&gt; 
  operator*(const Rep1&amp; s, const duration&lt;Rep2, Period&gt;&amp; d);
</pre>
<blockquote>
<i><del>Requires</del> <ins>Remarks</ins>:</i> <tt>Rep1</tt> shall be implicitly convertible to
<tt>CR(Rep1, Rep2)</tt><ins>, else this signature shall not participate in
overload resolution</ins>. <del>Diagnostic required.</del>
</blockquote>

<pre>template &lt;class Rep1, class Period, class Rep2&gt; 
  duration&lt;typename common_type&lt;Rep1, Rep2&gt;::type, Period&gt; 
  operator/(const duration&lt;Rep1, Period&gt;&amp; d, const Rep2&amp; s);
</pre>
<blockquote>
<i><del>Requires</del> <ins>Remarks</ins>:</i> <tt>Rep2</tt> shall be implicitly convertible to
<tt>CR(Rep1, Rep2)</tt> and <tt>Rep2</tt> shall not be an instantiation of
<tt>duration</tt><ins>, else this signature shall not participate in
overload resolution</ins>. <del>Diagnostic required.</del>
</blockquote>

<pre>template &lt;class Rep1, class Period, class Rep2&gt; 
  duration&lt;typename common_type&lt;Rep1, Rep2&gt;::type, Period&gt; 
  operator%(const duration&lt;Rep1, Period&gt;&amp; d, const Rep2&amp; s);
</pre>
<blockquote>
<i><del>Requires</del> <ins>Remarks</ins>:</i> <tt>Rep2</tt> shall be implicitly convertible to
<tt>CR(Rep1, Rep2)</tt> and <tt>Rep2</tt> shall not be an instantiation of
<tt>duration</tt><ins>, else this signature shall not participate in
overload resolution</ins>. <del>Diagnostic required.</del>
</blockquote>

</blockquote>
</li>

<li>
<p>
Change the following paragraphs in 20.9.3.7 [time.duration.cast]:
</p>

<blockquote><pre>template &lt;class ToDuration, class Rep, class Period&gt; 
  ToDuration duration_cast(const duration&lt;Rep, Period&gt;&amp; d);
</pre>

<blockquote>
<i><del>Requires</del> <ins>Remarks</ins>:</i> <tt>ToDuration</tt> shall be an instantiation of
<tt>duration</tt><ins>, else this signature shall not participate in
overload resolution</ins>. <del>Diagnostic required.</del>
</blockquote>
</blockquote>
</li>

<li>
<p>
Change the following paragraphs in 20.9.4.7 [time.point.cast]:
</p>

<blockquote><pre>template &lt;class ToDuration, class Clock, class Duration&gt; 
  time_point&lt;Clock, ToDuration&gt; time_point_cast(const time_point&lt;Clock, Duration&gt;&amp; t);
</pre>

<blockquote>
<i><del>Requires</del> <ins>Remarks</ins>:</i> <tt>ToDuration</tt> shall be an instantiation of
<tt>duration</tt><ins>, else this signature shall not participate in
overload resolution</ins>. <del>Diagnostic required.</del>
</blockquote>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="1180"></a>1180. Missing string_type member typedef in class <tt>sub_match</tt></h3>
<p><b>Section:</b> 28.9.1 [re.submatch.members] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2009-07-25  <b>Last modified:</b> 2009-07-26</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The definition of class template <tt>sub_match</tt> is strongly dependent
on the type <tt>basic_string&lt;value_type&gt;</tt>, both in interface and effects,
but does not provide a corresponding typedef <tt>string_type</tt>, as e.g.
class <tt>match_results</tt> does, which looks like an oversight to me that
should be fixed.
</p>


<p><b>Proposed resolution:</b></p>

<ol>
<li>
<p>
In the class template <tt>sub_match</tt> synopsis 28.9 [re.submatch]/1
change as indicated:
</p>

<blockquote><pre>template &lt;class BidirectionalIterator&gt;
class sub_match : public std::pair&lt;BidirectionalIterator, BidirectionalIterator&gt; {
public:
  typedef typename iterator_traits&lt;BidirectionalIterator&gt;::value_type value_type;
  typedef typename iterator_traits&lt;BidirectionalIterator&gt;::difference_type difference_type;
  typedef BidirectionalIterator iterator;
  <ins>typedef basic_string&lt;value_type&gt; string_type;</ins>

  bool matched;

  difference_type length() const;
  operator <del>basic_string&lt;value_type&gt;</del><ins>string_type</ins>() const;
  <del>basic_string&lt;value_type&gt;</del><ins>string_type</ins> str() const;
  int compare(const sub_match&amp; s) const;
  int compare(const <del>basic_string&lt;value_type&gt;</del><ins>string_type</ins>&amp; s) const;
  int compare(const value_type* s) const;
};
</pre></blockquote>
</li>

<li>
<p>
In 28.9.1 [re.submatch.members]/2 change as indicated:
</p>

<blockquote><pre>operator <del>basic_string&lt;value_type&gt;</del><ins>string_type</ins>() const;
</pre>

<blockquote>
<i>Returns:</i> <tt>matched ? <del>basic_string&lt;value_type&gt;</del>
<ins>string_type</ins>(first, second) : <del>basic_string&lt;value_type&gt;</del>
<ins>string_type</ins>()</tt>.
</blockquote>
</blockquote>
</li>

<li>
<p>
In 28.9.1 [re.submatch.members]/3 change as indicated:
</p>

<blockquote><pre><del>basic_string&lt;value_type&gt;</del><ins>string_type</ins> str() const;
</pre>

<blockquote>
<i>Returns:</i> <tt>matched ? <del>basic_string&lt;value_type&gt;</del>
<ins>string_type</ins>(first, second) : <del>basic_string&lt;value_type&gt;</del>
<ins>string_type</ins>()</tt>.
</blockquote>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="1181"></a>1181. Invalid <tt>sub_match</tt> comparison operators</h3>
<p><b>Section:</b> 28.9.2 [re.submatch.op] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2009-07-25  <b>Last modified:</b> 2009-07-28</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#re.submatch.op">issues</a> in [re.submatch.op].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Several heterogeneous comparison operators of class template
<tt>sub_match</tt> are specified by return clauses that are not valid
in general. E.g. 28.9.2 [re.submatch.op]/7:
</p>

<blockquote><pre>template &lt;class BiIter, class ST, class SA&gt;
bool operator==(
  const basic_string&lt;
    typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; lhs,
  const sub_match&lt;BiIter&gt;&amp; rhs);
</pre>
<blockquote>
<i>Returns:</i> <tt>lhs == rhs.str()</tt>.
</blockquote>
</blockquote>

<p>
The returns clause would be ill-formed for all cases where
<tt>ST != std::char_traits&lt;iterator_traits&lt;BiIter&gt;::value_type&gt;</tt>
or <tt>SA != std::allocator&lt;iterator_traits&lt;BiIter&gt;::value_type&gt;</tt>.
</p>
<p>
The generic character of the comparison was intended, so
there are basically two approaches to fix the problem: The
first one would define the semantics of the comparison
using the traits class <tt>ST</tt> (The semantic of <tt>basic_string::compare</tt>
is defined in terms of the compare function of the corresponding
traits class), the second one would define the semantics of the
comparison using the traits class
</p>

<blockquote><pre>std::char_traits&lt;iterator_traits&lt;BiIter&gt;::value_type&gt;
</pre></blockquote>

<p>
which is essentially identical to
</p>

<blockquote><pre>std::char_traits&lt;sub_match&lt;BiIter&gt;::value_type&gt;
</pre></blockquote>

<p>
I suggest to follow the second approach, because
this emphasizes the central role of the <tt>sub_match</tt>
object as part of the comparison and would also
make sure that a <tt>sub_match</tt> comparison using some
<tt>basic_string&lt;char_t, ..&gt;</tt> always is equivalent to
a corresponding comparison with a string literal
because of the existence of further overloads (beginning
from 28.9.2 [re.submatch.op]/19). If users really want to
take advantage of their own <tt>traits::compare</tt>, they can
simply write a corresponding compare function that
does so.
</p>


<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>
In 28.9.2 [re.submatch.op] change as indicated:
</p>

<ol type="a">
<li>

<p>
If <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1180">1180</a> is accepted:
</p>

<blockquote>
<pre>template &lt;class BiIter, class ST, class SA&gt;
  bool operator==(
    const basic_string&lt;
      typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; lhs,
    const sub_match&lt;BiIter&gt;&amp; rhs);
</pre>
<blockquote>
7 <i>Returns:</i> <tt><del>lhs</del><ins>typename
sub_match&lt;BiIter&gt;::string_type(lhs.begin(), lhs.end())</ins> ==
rhs.str()</tt>.
</blockquote>

<pre>template &lt;class BiIter, class ST, class SA&gt;
  bool operator!=(
    const basic_string&lt;
      typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; lhs,
    const sub_match&lt;BiIter&gt;&amp; rhs);
</pre>

<blockquote>
8 <i>Returns:</i> <tt><del>lhs</del><ins>typename
sub_match&lt;BiIter&gt;::string_type(lhs.begin(), lhs.end())</ins> !=
rhs.str()</tt>.
</blockquote>

<pre>template &lt;class BiIter, class ST, class SA&gt;
  bool operator&lt;(
    const basic_string&lt;
      typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; lhs,
    const sub_match&lt;BiIter&gt;&amp; rhs);
</pre>

<blockquote>
9 <i>Returns:</i> <tt><del>lhs</del><ins>typename
sub_match&lt;BiIter&gt;::string_type(lhs.begin(), lhs.end())</ins> &lt;
rhs.str()</tt>.
</blockquote>

<pre>template &lt;class BiIter, class ST, class SA&gt;
  bool operator&gt;(
    const basic_string&lt;
      typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; lhs,
    const sub_match&lt;BiIter&gt;&amp; rhs);
</pre>

<blockquote>
10 <i>Returns:</i> <tt><del>lhs</del><ins>typename
sub_match&lt;BiIter&gt;::string_type(lhs.begin(), lhs.end())</ins> &gt;
rhs.str()</tt>.
</blockquote>

<pre>template &lt;class BiIter, class ST, class SA&gt;
  bool operator&gt;=(
    const basic_string&lt;
      typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; lhs,
    const sub_match&lt;BiIter&gt;&amp; rhs);
</pre>

<blockquote>
11 <i>Returns:</i> <tt><del>lhs</del><ins>typename
sub_match&lt;BiIter&gt;::string_type(lhs.begin(), lhs.end())</ins> &gt;=
rhs.str()</tt>.
</blockquote>

<pre>template &lt;class BiIter, class ST, class SA&gt;
  bool operator&lt;=(
    const basic_string&lt;
      typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; lhs,
    const sub_match&lt;BiIter&gt;&amp; rhs);
</pre>

<blockquote>
12 <i>Returns:</i> <tt><del>lhs</del><ins>typename
sub_match&lt;BiIter&gt;::string_type(lhs.begin(), lhs.end())</ins> &lt;=
rhs.str()</tt>.
</blockquote>

<pre>template &lt;class BiIter, class ST, class SA&gt;
  bool operator==(const sub_match&lt;BiIter&gt;&amp; lhs,
    const basic_string&lt;
      typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; rhs);
</pre>

<blockquote>
13 <i>Returns:</i> <tt>lhs.str() == <del>rhs</del><ins>typename
sub_match&lt;BiIter&gt;::string_type(rhs.begin(), rhs.end())</ins></tt>.
</blockquote>

<pre>template &lt;class BiIter, class ST, class SA&gt;
  bool operator!=(const sub_match&lt;BiIter&gt;&amp; lhs,
    const basic_string&lt;
      typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; rhs);
</pre>

<blockquote>
14 <i>Returns:</i> <tt>lhs.str() != <del>rhs</del><ins>typename
sub_match&lt;BiIter&gt;::string_type(rhs.begin(), rhs.end())</ins></tt>.
</blockquote>

<pre>template &lt;class BiIter, class ST, class SA&gt;
  bool operator&lt;(const sub_match&lt;BiIter&gt;&amp; lhs,
    const basic_string&lt;
      typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; rhs);
</pre>

<blockquote>
15 <i>Returns:</i> <tt>lhs.str() &lt; <del>rhs</del><ins>typename
sub_match&lt;BiIter&gt;::string_type(rhs.begin(), rhs.end())</ins></tt>.
</blockquote>

<pre>template &lt;class BiIter, class ST, class SA&gt;
  bool operator&gt;(const sub_match&lt;BiIter&gt;&amp; lhs,
    const basic_string&lt;
      typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; rhs);
</pre>

<blockquote>
16 <i>Returns:</i> <tt>lhs.str() &gt; <del>rhs</del><ins>typename
sub_match&lt;BiIter&gt;::string_type(rhs.begin(), rhs.end())</ins></tt>.
</blockquote>

<pre>template &lt;class BiIter, class ST, class SA&gt;
  bool operator&gt;=(const sub_match&lt;BiIter&gt;&amp; lhs,
    const basic_string&lt;
      typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; rhs);
</pre>

<blockquote>
17 <i>Returns:</i> <tt>lhs.str() &gt;= <del>rhs</del><ins>typename
sub_match&lt;BiIter&gt;::string_type(rhs.begin(), rhs.end())</ins></tt>.
</blockquote>

<pre>template &lt;class BiIter, class ST, class SA&gt;
  bool operator&lt;=(const sub_match&lt;BiIter&gt;&amp; lhs,
    const basic_string&lt;
      typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; rhs);
</pre>

<blockquote>
18 <i>Returns:</i> <tt>lhs.str() &lt;= <del>rhs</del><ins>typename
sub_match&lt;BiIter&gt;::string_type(rhs.begin(), rhs.end())</ins></tt>.
</blockquote>
</blockquote>

</li>

<li>

<p>
If <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1180">1180</a> is <em>not</em> accepted:
</p>

<blockquote>
<pre>template &lt;class BiIter, class ST, class SA&gt;
  bool operator==(
    const basic_string&lt;
      typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; lhs,
    const sub_match&lt;BiIter&gt;&amp; rhs);
</pre>
<blockquote>
7 <i>Returns:</i> <tt><del>lhs</del><ins>basic_string&lt;typename
sub_match&lt;BiIter&gt;::value_type&gt;(lhs.begin(), lhs.end())</ins> ==
rhs.str()</tt>.
</blockquote>

<pre>template &lt;class BiIter, class ST, class SA&gt;
  bool operator!=(
    const basic_string&lt;
      typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; lhs,
    const sub_match&lt;BiIter&gt;&amp; rhs);
</pre>

<blockquote>
8 <i>Returns:</i> <tt><del>lhs</del><ins>basic_string&lt;typename
sub_match&lt;BiIter&gt;::value_type&gt;(lhs.begin(), lhs.end())</ins> !=
rhs.str()</tt>.
</blockquote>

<pre>template &lt;class BiIter, class ST, class SA&gt;
  bool operator&lt;(
    const basic_string&lt;
      typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; lhs,
    const sub_match&lt;BiIter&gt;&amp; rhs);
</pre>

<blockquote>
9 <i>Returns:</i> <tt><del>lhs</del><ins>basic_string&lt;typename
sub_match&lt;BiIter&gt;::value_type&gt;(lhs.begin(), lhs.end())</ins> &lt;
rhs.str()</tt>.
</blockquote>

<pre>template &lt;class BiIter, class ST, class SA&gt;
  bool operator&gt;(
    const basic_string&lt;
      typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; lhs,
    const sub_match&lt;BiIter&gt;&amp; rhs);
</pre>

<blockquote>
10 <i>Returns:</i> <tt><del>lhs</del><ins>basic_string&lt;typename
sub_match&lt;BiIter&gt;::value_type&gt;(lhs.begin(), lhs.end())</ins> &gt;
rhs.str()</tt>.
</blockquote>

<pre>template &lt;class BiIter, class ST, class SA&gt;
  bool operator&gt;=(
    const basic_string&lt;
      typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; lhs,
    const sub_match&lt;BiIter&gt;&amp; rhs);
</pre>

<blockquote>
11 <i>Returns:</i> <tt><del>lhs</del><ins>basic_string&lt;typename
sub_match&lt;BiIter&gt;::value_type&gt;(lhs.begin(), lhs.end())</ins> &gt;=
rhs.str()</tt>.
</blockquote>

<pre>template &lt;class BiIter, class ST, class SA&gt;
  bool operator&lt;=(
    const basic_string&lt;
      typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; lhs,
    const sub_match&lt;BiIter&gt;&amp; rhs);
</pre>

<blockquote>
12 <i>Returns:</i> <tt><del>lhs</del><ins>basic_string&lt;typename
sub_match&lt;BiIter&gt;::value_type&gt;(lhs.begin(), lhs.end())</ins> &lt;=
rhs.str()</tt>.
</blockquote>

<pre>template &lt;class BiIter, class ST, class SA&gt;
  bool operator==(const sub_match&lt;BiIter&gt;&amp; lhs,
    const basic_string&lt;
      typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; rhs);
</pre>

<blockquote>
13 <i>Returns:</i> <tt>lhs.str() == <del>rhs</del><ins>basic_string&lt;typename
sub_match&lt;BiIter&gt;::value_type&gt;(rhs.begin(), rhs.end())</ins></tt>.
</blockquote>

<pre>template &lt;class BiIter, class ST, class SA&gt;
  bool operator!=(const sub_match&lt;BiIter&gt;&amp; lhs,
    const basic_string&lt;
      typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; rhs);
</pre>

<blockquote>
14 <i>Returns:</i> <tt>lhs.str() != <del>rhs</del><ins>basic_string&lt;typename
sub_match&lt;BiIter&gt;::value_type&gt;(rhs.begin(), rhs.end())</ins></tt>.
</blockquote>

<pre>template &lt;class BiIter, class ST, class SA&gt;
  bool operator&lt;(const sub_match&lt;BiIter&gt;&amp; lhs,
    const basic_string&lt;
      typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; rhs);
</pre>

<blockquote>
15 <i>Returns:</i> <tt>lhs.str() &lt; <del>rhs</del><ins>basic_string&lt;typename
sub_match&lt;BiIter&gt;::value_type&gt;(rhs.begin(), rhs.end())</ins></tt>.
</blockquote>

<pre>template &lt;class BiIter, class ST, class SA&gt;
  bool operator&gt;(const sub_match&lt;BiIter&gt;&amp; lhs,
    const basic_string&lt;
      typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; rhs);
</pre>

<blockquote>
16 <i>Returns:</i> <tt>lhs.str() &gt; <del>rhs</del><ins>basic_string&lt;typename
sub_match&lt;BiIter&gt;::value_type&gt;(rhs.begin(), rhs.end())</ins></tt>.
</blockquote>

<pre>template &lt;class BiIter, class ST, class SA&gt;
  bool operator&gt;=(const sub_match&lt;BiIter&gt;&amp; lhs,
    const basic_string&lt;
      typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; rhs);
</pre>

<blockquote>
17 <i>Returns:</i> <tt>lhs.str() &gt;= <del>rhs</del><ins>basic_string&lt;typename
sub_match&lt;BiIter&gt;::value_type&gt;(rhs.begin(), rhs.end())</ins></tt>.
</blockquote>

<pre>template &lt;class BiIter, class ST, class SA&gt;
  bool operator&lt;=(const sub_match&lt;BiIter&gt;&amp; lhs,
    const basic_string&lt;
      typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; rhs);
</pre>

<blockquote>
18 <i>Returns:</i> <tt>lhs.str() &lt;= <del>rhs</del><ins>basic_string&lt;typename
sub_match&lt;BiIter&gt;::value_type&gt;(rhs.begin(), rhs.end())</ins></tt>.
</blockquote>
</blockquote>

</li>

</ol>

</li>
</ol>





<hr>
<h3><a name="1182"></a>1182. Unfortunate hash dependencies</h3>
<p><b>Section:</b> 20.7.16 [unord.hash] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-07-28  <b>Last modified:</b> 2009-09-21</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#unord.hash">active issues</a> in [unord.hash].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#unord.hash">issues</a> in [unord.hash].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The implied library dependencies created by spelling out all the <tt>hash</tt>
template specializations in the <tt>&lt;functional&gt;</tt> synopsis are unfortunate. 
The potential coupling is greatly reduced if the <tt>hash</tt> specialization is
declared in the appropriate header for each library type, as it is much
simpler to forward declare the primary template and provide a single
specialization than it is to implement a <tt>hash</tt> function for a <tt>string</tt> or
<tt>vector</tt> without providing a definition for the whole <tt>string/vector</tt>
template in order to access the necessary bits.
</p>

<p>
Note that the proposed resolution purely involves moving the
declarations of a few specializations, it specifically does not make any
changes to 20.7.16 [unord.hash].
</p>

<p><i>[
2009-09-15 Daniel adds:
]</i></p>


<blockquote>
</blockquote>
<p>
I suggest to add to the current existing
proposed resolution the following items.
</p>

<ul>
<li>
<p>
Add to the very first strike-list of the currently suggested resolution
the following lines:
</p>

<blockquote><pre><del>template &lt;&gt; struct hash&lt;std::error_code&gt;;</del>
<del>template &lt;&gt; struct hash&lt;std::thread::id&gt;;</del>
</pre></blockquote>
</li>

<li>
<p>
Add the following declarations to 19.5 [syserr], header
<tt>&lt;system_error&gt;</tt> synopsis after // 19.5.4:
</p>

<blockquote><pre><ins>
// 19.5.x hash support
template &lt;class T&gt; struct hash;
template &lt;&gt; struct hash&lt;error_code&gt;;
</ins>
</pre></blockquote>
</li>

<li>
<p>
Add a new clause 19.5.X (probably after 19.5.4):
</p>

<blockquote>
<p><ins>
19.5.X Hash support [syserr.hash]
</ins></p>

<pre><ins>
template &lt;&gt; struct hash&lt;error_code&gt;;
</ins></pre>

<blockquote><ins>
An explicit specialization of the class template hash (20.7.16 [unord.hash])
shall be provided
for the type <tt>error_code</tt> suitable for using this type as key in
unordered associative
containers (23.5 [unord]).
</ins></blockquote>
</blockquote>
</li>

<li>
<p>
Add the following declarations to 30.3.1.1 [thread.thread.id] just after the
declaration of
the comparison operators:
</p>

<blockquote><pre><ins>
template &lt;class T&gt; struct hash;
template &lt;&gt; struct hash&lt;thread::id&gt;;
</ins></pre></blockquote>
</li>

<li>
<p>
Add a new paragraph at the end of 30.3.1.1 [thread.thread.id]:
</p>

<blockquote>
<pre><ins>
template &lt;&gt; struct hash&lt;thread::id&gt;;
</ins></pre>

<blockquote><ins>
An explicit specialization of the class template hash (20.7.16 [unord.hash])
shall be provided
for the type <tt>thread::id</tt> suitable for using this type as key in
unordered associative
containers (23.5 [unord]).
</ins></blockquote>
</blockquote>
</li>

<li>
Issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#889">889</a> independently suggests moving the specialization
<tt>std::hash&lt;std::thread::id&gt;</tt> to header <tt>&lt;thread&gt;</tt>.
</li>
</ul>



<p><b>Proposed resolution:</b></p>
<p>
Strike the following specializations declared in the <tt>&lt;functional&gt;</tt>
synopsis p2 20.7 [function.objects]
</p>

<blockquote><pre><del>template &lt;&gt; struct hash&lt;std::string&gt;;</del>
<del>template &lt;&gt; struct hash&lt;std::u16string&gt;;</del>
<del>template &lt;&gt; struct hash&lt;std::u32string&gt;;</del>
<del>template &lt;&gt; struct hash&lt;std::wstring&gt;;</del>

<del>template &lt;class Allocator&gt; struct hash&lt;std::vector&lt;bool, Allocator&gt; &gt;;</del>
<del>template &lt;std::size_t N&gt; struct hash&lt;std::bitset&lt;N&gt; &gt;;</del>
</pre></blockquote>

<p>
Add the following declarations to the synopsis of <tt>&lt;string&gt;</tt> in
21.3 [string.classes]
</p>

<blockquote><pre><ins>// 21.4.x hash support
template &lt;class T&gt; struct hash;
template &lt;&gt; struct hash&lt;string&gt;;
template &lt;&gt; struct hash&lt;u16string&gt;;
template &lt;&gt; struct hash&lt;u32string&gt;;
template &lt;&gt; struct hash&lt;wstring&gt;;</ins>
</pre></blockquote>

<p>
Add a new clause 21.4.X
</p>

<blockquote>
<p>
21.4.X Hash support [basic.string.hash]
</p>

<pre>template &lt;&gt; struct hash&lt;string&gt;;
template &lt;&gt; struct hash&lt;u16string&gt;;
template &lt;&gt; struct hash&lt;u32string&gt;;
template &lt;&gt; struct hash&lt;wstring&gt;;
</pre>

<blockquote>
Explicit specializations of the class template hash (20.7.16 [unord.hash])
shall be provided for the types <tt>string</tt>, <tt>u16string</tt>,
<tt>u32string</tt> and <tt>wstring</tt> suitable for using these types as keys in
unordered associative containers (23.5 [unord]).
</blockquote>
</blockquote>

<p>
Add the following declarations to the synopsis of <tt>&lt;vector&gt;</tt> in 
23.3 [sequences]
</p>

<blockquote><pre><ins>
// 21.4.x hash support
template &lt;class T&gt; struct hash;
template &lt;class Allocator&gt; struct hash&lt;vector&lt;bool, Allocator&gt;&gt;;
</ins></pre></blockquote>

<p>
Add a new paragraph to the end of 23.3.7 [vector.bool]
</p>

<blockquote><pre>template &lt;class Allocator&gt; struct hash&lt;vector&lt;bool, Allocator&gt;&gt;;
</pre>
<blockquote>
A partial specialization of the class template hash (20.7.16 [unord.hash])
shall be provided for vectors of boolean values suitable for use as a key
in unordered associative containers (23.5 [unord]).
</blockquote>
</blockquote>

<p>
Add the following declarations to the synopsis of <tt>&lt;bitset&gt;</tt>
in 20.3.7 [template.bitset]
</p>

<blockquote><pre><ins>
// 20.3.6.X hash support
template &lt;class T&gt; struct hash;
template &lt;size_t N&gt; struct hash&lt;bitset&lt;N&gt; &gt;;
</ins></pre></blockquote>

<p>
Add a new subclause 20.3.6.X [bitset.hash]
</p>

<blockquote>
<p>
20.3.6.X bitset hash support [bitset.hash]
</p>

<pre>template &lt;size_t N&gt; struct hash&lt;bitset&lt;N&gt; &gt;;
</pre>

<blockquote>
A partial specialization of the class template hash
(20.7.16 [unord.hash]) shall be provided for bitsets suitable for use as a key in
unordered associative containers (23.5 [unord]).
</blockquote>
</blockquote>






<hr>
<h3><a name="1183"></a>1183. <tt>basic_ios::set_rdbuf</tt> may break class invariants</h3>
<p><b>Section:</b> 27.5.4.2 [basic.ios.members] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2009-07-28  <b>Last modified:</b> 2009-10-22</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#basic.ios.members">active issues</a> in [basic.ios.members].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#basic.ios.members">issues</a> in [basic.ios.members].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The protected member function <tt>set_rdbuf</tt> had been added during the
process of adding move and swap semantics to IO classes. A relevant
property of this function is described by it's effects in
27.5.4.2 [basic.ios.members]/19:
</p>

<blockquote>
<i>Effects:</i> Associates the <tt>basic_streambuf</tt> object pointed to by sb with
this stream without calling <tt>clear()</tt>.
</blockquote>

<p>
This means that implementors of or those who derive from existing IO classes
could cause an internal state where the stream buffer could be 0, but the
IO class has the state <tt>good()</tt>. This would break several currently existing
implementations which rely on the fact that setting a stream buffer via the
currently only ways, i.e. either by calling
</p>

<blockquote><pre>void init(basic_streambuf&lt;charT,traits&gt;* sb);
</pre></blockquote>

<p>
or by calling
</p>

<blockquote><pre>basic_streambuf&lt;charT,traits&gt;* rdbuf(basic_streambuf&lt;charT,traits&gt;* sb);
</pre></blockquote>

<p>
to set <tt>rdstate()</tt> to <tt>badbit</tt>, if the buffer is 0. This has the effect that many
internal functions can simply check <tt>rdstate()</tt> instead of <tt>rdbuf()</tt> for being 0.
</p>

<p>
I therefore suggest that a requirement is added for callers of <tt>set_rdbuf</tt> to
set a non-0 value.
</p>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Moved to Open.  Martin volunteers to provide new wording, where
<tt>set_rdbuf()</tt> sets the <tt>badbit</tt> but does not cause an
exception to be thrown like a call to <tt>clear()</tt> would.
</blockquote>

<p><i>[
2009-10-20 Martin provides wording:
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
Change 27.5.4.2 [basic.ios.members] around p. 19 as indicated:
</p>

<blockquote><pre>void set_rdbuf(basic_streambuf&lt;charT, traits&gt;* sb);
</pre>

<blockquote>
<p><del>
<i>Effects:</i> Associates the <tt>basic_streambuf</tt> object pointed
to by <tt>sb</tt> with this stream without calling <tt>clear()</tt>.
<i>Postconditions:</i> <tt>rdbuf() == sb</tt>.
</del></p>

<p><ins>
<i>Effects:</i> As if:
</ins></p>

<blockquote><pre><ins>
iostate state = rdstate();
try { rdbuf(sb); }
catch(ios_base::failure) {
   if (0 == (state &amp; ios_base::badbit))
       unsetf(badbit);
}
</ins></pre></blockquote>

<p>
<i>Throws:</i> Nothing.
</p>

</blockquote>
</blockquote>


<p><b>Rationale:</b></p>
We need to be able to call <tt>set_rdbuf()</tt> on stream objects
for which (<tt>rdbuf() == 0</tt>) holds without causing <tt>ios_base::failure</tt> to
be thrown. We also don't want <tt>badbit</tt> to be set as a result of
setting <tt>rdbuf()</tt> to 0 if it wasn't set before the call. This changed
Effects clause maintains the current behavior (as of N2914) without
requiring that <tt>sb</tt> be non-null.





<hr>
<h3><a name="1185"></a>1185. iterator categories and output iterators</h3>
<p><b>Section:</b> 24.2 [iterator.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-07-31  <b>Last modified:</b> 2009-07-31</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#iterator.requirements">active issues</a> in [iterator.requirements].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#iterator.requirements">issues</a> in [iterator.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
(wording relative to
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2723.pdf">N2723</a>
pending new working paper)
</p>

<p>
According to p3 24.2 [iterator.requirements], Forward iterators,
Bidirectional iterators and Random Access iterators all satisfy the
requirements for an Output iterator:
</p>

<blockquote>
XXX iterators satisfy all the requirements of the input and output iterators
and can be used whenever either kind is specified ...
</blockquote>

<p>
Meanwhile, p4 goes on to contradict this:
</p>

<blockquote>
Besides its category, a forward, bidirectional, or random access
iterator can also be mutable or constant...
</blockquote>

<blockquote>
... Constant iterators do not satisfy the requirements for output iterators
</blockquote>

<p>
The latter seems to be the overriding concern, as the iterator tag
hierarchy does not define <tt>forward_iterator_tag</tt> as multiply derived from
both <tt>input_iterator_tag</tt> and <tt>output_iterator_tag</tt>.
</p>

<p>
The work on concepts for iterators showed us that output iterator really
is fundamentally a second dimension to the iterator categories, rather
than part of the linear input -&gt; forward -&gt; bidirectional -&gt;
random-access sequence.  It would be good to clear up these words to
reflect that, and separately list output iterator requirements in the
requires clauses for the appropriate algorithms and operations.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1186"></a>1186. Forward list could model a stack</h3>
<p><b>Section:</b> 23.3.5.3 [stack] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Concepts">Tentatively NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-07-31  <b>Last modified:</b> 2009-11-02</p>
<p><b>Discussion:</b></p>
<p>
The library template <tt>forward_list</tt> could easily model the idea of a
<tt>stack</tt>, where the operations work on the front of the list rather than
the back.  However, the standard library <tt>stack</tt> adaptor cannot support
this.
</p>

<p>
It would be relatively easy to write a partial specialization for <tt>stack</tt>
to support <tt>forward_list</tt>, but that opens the question of which header to
place it in.  A much better solution would be to add a <tt>concept_map</tt> for
the <tt>StackLikeContainer</tt> concept to the <tt>&lt;forward_list&gt;</tt> header and then
everything just works, including a user's own further uses in a
stack-like context.
</p>

<p>
Therefore while I am submitting the issue now so that it is on record, I
<em>strongly recommend</em> we resolve as "NAD Concepts" as any non-concepts
based solution will be inferior to the final goal, and the feature is
not so compelling it must be supported ahead of the concepts-based
library.
</p>

<p><i>[
2009-11-02 Howard adds:
]</i></p>


<blockquote>
Moved to Tentatively NAD Concepts after 5 positive votes on c++std-lib.
</blockquote>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1187"></a>1187. std::decay</h3>
<p><b>Section:</b> 20.6.7 [meta.trans.other] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Jason Merrill <b>Opened:</b> 2009-08-07  <b>Last modified:</b> 2009-08-22</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#meta.trans.other">issues</a> in [meta.trans.other].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I notice that <tt>std::decay</tt> is specified to strip the cv-quals from
anything but an array or pointer.  This seems incorrect for values of
class type, since class rvalues can have cv-qualified type (3.10 [basic.lval]/9).
</p>

<p><i>[
2009-08-09 Howard adds:
]</i></p>


<blockquote>
See the thread starting with c++std-lib-24568 for further discussion.  And
here is a convenience link to the
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2069.html">original proposal</a>.
Also see the closely related issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#705">705</a>.
</blockquote>


<p><b>Proposed resolution:</b></p>

<p>
Add a note to <tt>decay</tt> in 20.6.7 [meta.trans.other]:
</p>

<blockquote>
[<i>Note:</i> This behavior is similar to the lvalue-to-rvalue (4.1),
array-to-pointer (4.2), and function-to-pointer (4.3) conversions
applied when an lvalue expression is used as an rvalue, but also strips
cv-qualifiers from class types in order to more closely model by-value
argument passing. &#8212; <i>end note</i>]
</blockquote>








<hr>
<h3><a name="1188"></a>1188. Unordered containers should have a minimum load factor as well as a maximum</h3>
<p><b>Section:</b> 23.2.5 [unord.req], 23.5 [unord] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2009-08-10  <b>Last modified:</b> 2009-08-11</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#unord.req">active issues</a> in [unord.req].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#unord.req">issues</a> in [unord.req].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Unordered associative containers have a notion of a maximum load factor:
when the number of elements grows large enough, the containers
automatically perform a rehash so that the number of elements per bucket
stays below a user-specified bound. This ensures that the hash table's
performance characteristics don't change dramatically as the size
increases.
</p>

<p>
For similar reasons, Google has found it useful to specify a minimum
load factor: when the number of elements shrinks by a large enough, the
containers automatically perform a rehash so that the number of elements
per bucket stays above a user-specified bound. This is useful for two
reasons. First, it prevents wasting a lot of memory when an unordered
associative container grows temporarily. Second, it prevents amortized
iteration time from being arbitrarily large; consider the case of a hash
table with a billion buckets and only one element. (This was discussed
even before TR1 was published; it was TR issue 6.13, which the LWG
closed as NAD on the grounds that it was a known design feature.
However, the LWG did not consider the approach of a minimum load
factor.)
</p>

<p>
The only interesting question is when shrinking is allowed. In principle
the cleanest solution would be shrinking on erase, just as we grow on
insert. However, that would be a usability problem; it would break a
number of common idioms involving erase. Instead, Google's hash tables
only shrink on insert and rehash.
</p>

<p>
The proposed resolution allows, but does not require, shrinking in
rehash, mostly because a postcondition for rehash that involves the
minimum load factor would be fairly complicated. (It would probably have
to involve a number of special cases and it would probably have to
mention yet another parameter, a minimum bucket count.)
</p>

<p>
The current behavior is equivalent to a minimum load factor of 0. If we
specify that 0 is the default, this change will have no impact on
backward compatibility.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add two new rows, and change rehash's postcondition in the unordered
associative container requirements table in 23.2.5 [unord.req]:
</p>

<blockquote>
<table border="1">
<caption>Table 87 &#8212; Unordered associative container requirements
(in addition to container)</caption>

<tbody><tr>
<th>Expression</th><th>Return type</th><th>Assertion/note pre-/post-condition</th>
<th>Complexity</th>
</tr>
<tr>
<td><ins>
<tt>a.min_load_factor()</tt>
</ins></td>
<td><ins>
<tt>float</tt>
</ins></td>
<td><ins>
Returns a non-negative number that the container attempts to keep the
load factor greater than or equal to. The container automatically
decreases the number of buckets as necessary to keep the load factor
above this number.
</ins></td>
<td><ins>
constant
</ins></td>
</tr>

<tr>
<td><ins><tt>a.min_load_factor(z)</tt></ins></td>
<td><ins><tt>void</tt></ins></td>
<td><ins>Pre: <tt>z</tt> shall be non-negative. Changes the container's minimum
load factor, using <tt>z</tt> as a hint. [<i>Footnote:</i> the minimum
load factor should be significantly smaller than the maximum. 
If <tt>z</tt> is too large, the implementation may reduce it to a more sensible value.]
</ins></td>
<td><ins>
constant
</ins></td>
</tr>
<tr>
<td><tt>a.rehash(n)</tt></td>
<td><tt>void</tt></td>
<td>
Post: <ins><tt>a.bucket_count() &gt;= n</tt>, and <tt>a.size() &lt;= a.bucket_count()
* a.max_load_factor()</tt>. [<i>Footnote:</i> It is intentional that the
postcondition does not mention the minimum load factor.
This member function is primarily intended for cases where the user knows
that the container's size will increase soon, in which case the container's
load factor will temporarily fall below <tt>a.min_load_factor()</tt>.]</ins>
<del>
<tt>a.bucket_cout &gt; a.size() / a.max_load_factor()</tt> and <tt>a.bucket_count()
&gt;= n</tt>.
</del>
</td>
<td>
Average case linear in <tt>a.size()</tt>, worst case quadratic.
</td>
</tr>
</tbody></table>
</blockquote>

<p>
Add a footnote to 23.2.5 [unord.req] p12:
</p>

<blockquote>
<p>
The insert members shall not affect the validity of references to
container elements, but may invalidate all iterators to the container.
The erase members shall invalidate only iterators and references to the
erased elements.
</p>

<blockquote><ins>
[A consequence of these requirements is that while insert may change the
number of buckets, erase may not. The number of buckets may be reduced
on calls to insert or rehash.]
</ins></blockquote>
</blockquote>

<p>
Change paragraph 13:
</p>

<blockquote>
The insert members shall not affect the validity of iterators if
<del><tt>(N+n) &lt; z * B</tt></del> <ins><tt>zmin * B &lt;= (N+n) &lt;= zmax * B</tt></ins>,
where <tt>N</tt> is the number of elements in
the container prior to the insert operation, <tt>n</tt> is the number of
elements inserted, <tt>B</tt> is the container's bucket count,
<ins><tt>zmin</tt> is the container's minimum load factor,</ins>
and <tt>z<ins>max</ins></tt> is the container's maximum load factor.
</blockquote>

<p>
Add to the <tt>unordered_map</tt> class synopsis in section 23.5.1 [unord.map],
the <tt>unordered_multimap</tt> class synopsis
in 23.5.2 [unord.multimap], the <tt>unordered_set</tt> class synopsis in
23.5.3 [unord.set], and the <tt>unordered_multiset</tt> class synopsis
in 23.5.4 [unord.multiset]:
</p>

<blockquote><pre><ins>
float min_load_factor() const;
void min_load_factor(float z);
</ins></pre></blockquote>

<p>
In 23.5.1.1 [unord.map.cnstr], 23.5.2.1 [unord.multimap.cnstr], 23.5.3.1 [unord.set.cnstr], and
23.5.4.1 [unord.multiset.cnstr], change:
</p>

<blockquote>
... <tt>max_load_factor()</tt> returns 1.0 <ins>and
<tt>min_load_factor()</tt> returns 0</ins>.
</blockquote>





<hr>
<h3><a name="1189"></a>1189. Awkward interface for changing the number of buckets in an unordered associative container</h3>
<p><b>Section:</b> 23.2.5 [unord.req], 23.5 [unord] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2009-08-10  <b>Last modified:</b> 2009-10-28</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#unord.req">active issues</a> in [unord.req].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#unord.req">issues</a> in [unord.req].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Consider a typical use case: I create an <tt>unordered_map</tt> and then start
adding elements to it one at a time. I know that it will eventually need
to store a few million elements, so, for performance reasons, I would
like to reserve enough capacity that none of the calls to <tt>insert</tt> will
trigger a rehash.
</p>

<p>
Unfortunately, the existing interface makes this awkward. The user
naturally sees the problem in terms of the number of elements, but the
interface presents it as buckets. If <tt>m</tt> is the map and <tt>n</tt> is the expected
number of elements, this operation is written <tt>m.rehash(n /
m.max_load_factor())</tt> &#8212; not very novice friendly.
</p>

<p><i>[
2009-09-30 Daniel adds:
]</i></p>


<blockquote>
I recommend to replace "<tt>resize</tt>" by a different name like
"<tt>reserve</tt>", because that would better match the intended
use-case. Rational: Any existing resize function has the on-success
post-condition that the provided size is equal to <tt>size()</tt>, which
is not satisfied for the proposal. Reserve seems to fit the purpose of
the actual renaming suggestion.
</blockquote>

<p><i>[
2009-10-28 Ganesh summarizes alternative resolutions and expresses a
strong preference for the second (and opposition to the first):
]</i></p>


<blockquote>
<ol>
<li>
<p>
In the unordered associative container requirements (23.2.5 [unord.req]),
remove the row for
rehash and replace it with:
</p>

<blockquote>
<table border="1">
<caption>Table 87 &#8212; Unordered associative container requirements
(in addition to container)</caption>

<tbody><tr>
<th>Expression</th><th>Return type</th><th>Assertion/note pre-/post-condition</th>
<th>Complexity</th>
</tr>
<tr>
<td><tt>a.<del>rehash</del><ins>reserve</ins>(n)</tt></td>
<td><tt>void</tt></td>
<td>
Post: <tt>a.bucket_count &gt; <ins>max(</ins>a.size()<ins>, n)</ins>
/ a.max_load_factor()</tt><del> and <tt>a.bucket_count()
&gt;= n</tt></del>.
</td>
<td>
Average case linear in <tt>a.size()</tt>, worst case quadratic.
</td>
</tr>
</tbody></table>
</blockquote>

<p>
Make the corresponding change in the class synopses in 23.5.1
[unord.map], 23.5.2 [unord.multimap], 23.5.3 [unord.set], and 23.5.4
[unord.multiset].
</p>
</li>
<li>

<p>
In 23.2.5 [unord.req]/9, table 98, append a new row after the last one:
</p>

<blockquote>
<table border="1">
<caption>Table 87 &#8212; Unordered associative container requirements
(in addition to container)</caption>

<tbody><tr>
<th>Expression</th><th>Return type</th><th>Assertion/note pre-/post-condition</th>
<th>Complexity</th>
</tr>
<tr>
<td><tt>a.rehash(n)</tt></td>
<td><tt>void</tt></td>
<td>
Post: <tt>a.bucket_count &gt; a.size()
/ a.max_load_factor()</tt> and <tt>a.bucket_count()
&gt;= n</tt>.
</td>
<td>
Average case linear in <tt>a.size()</tt>, worst case quadratic.
</td>
</tr>
<tr>
<td><ins>
<tt>a.reserve(n)</tt>
</ins></td>
<td><ins>
<tt>void</tt>
</ins></td>
<td><ins>
Same as <tt>a.rehash(ceil(n / a.max_load_factor()))</tt>
</ins></td>
<td><ins>
Average case linear in <tt>a.size()</tt>, worst case quadratic.
</ins></td>
</tr>
</tbody></table>
</blockquote>

<p>
In 23.5.1 [unord.map]/3 in the definition of class template <tt>unordered_map</tt>, in
23.5.2 [unord.multimap]/3 in the definition of class template <tt>unordered_multimap</tt>, in
23.5.3 [unord.set]/3 in the definition of class template <tt>unordered_set</tt> and in
23.5.4 [unord.multiset]/3 in the definition of class template <tt>unordered_multiset</tt>, add the
following line after member function <tt>rehash()</tt>:
</p>

<blockquote><pre>void reserve(size_type n);
</pre></blockquote>

</li>
</ol>
</blockquote>

<p><i>[
2009-10-28 Howard:
]</i></p>


<blockquote>
<p>
Moved to Tentatively Ready after 5 votes in favor of Ganesh's option 2 above.
The original proposed wording now appears here:
</p>

<blockquote>
<p>
Informally: instead of providing <tt>rehash(n)</tt> provide <tt>resize(n)</tt>, with the
semantics "make the container a good size for <tt>n</tt> elements".
</p>

<p>
In the unordered associative container requirements (23.2.5 [unord.req]),
remove the row for
rehash and replace it with:
</p>

<blockquote>
<table border="1">
<caption>Table 87 &#8212; Unordered associative container requirements
(in addition to container)</caption>

<tbody><tr>
<th>Expression</th><th>Return type</th><th>Assertion/note pre-/post-condition</th>
<th>Complexity</th>
</tr>
<tr>
<td><tt>a.<del>rehash</del><ins>resize</ins>(n)</tt></td>
<td><tt>void</tt></td>
<td>
Post: <tt>a.bucket_count &gt; <ins>max(</ins>a.size()<ins>, n)</ins>
/ a.max_load_factor()</tt><del> and <tt>a.bucket_count()
&gt;= n</tt></del>.
</td>
<td>
Average case linear in <tt>a.size()</tt>, worst case quadratic.
</td>
</tr>
</tbody></table>
</blockquote>

<p>Make the corresponding change in the class synopses in 23.5.1
[unord.map], 23.5.2 [unord.multimap], 23.5.3 [unord.set], and 23.5.4
[unord.multiset].
</p>

</blockquote>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
In 23.2.5 [unord.req]/9, table 98, append a new row after the last one:
</p>

<blockquote>
<table border="1">
<caption>Table 87 &#8212; Unordered associative container requirements
(in addition to container)</caption>

<tbody><tr>
<th>Expression</th><th>Return type</th><th>Assertion/note pre-/post-condition</th>
<th>Complexity</th>
</tr>
<tr>
<td><tt>a.rehash(n)</tt></td>
<td><tt>void</tt></td>
<td>
Post: <tt>a.bucket_count &gt; a.size()
/ a.max_load_factor()</tt> and <tt>a.bucket_count()
&gt;= n</tt>.
</td>
<td>
Average case linear in <tt>a.size()</tt>, worst case quadratic.
</td>
</tr>
<tr>
<td><ins>
<tt>a.reserve(n)</tt>
</ins></td>
<td><ins>
<tt>void</tt>
</ins></td>
<td><ins>
Same as <tt>a.rehash(ceil(n / a.max_load_factor()))</tt>
</ins></td>
<td><ins>
Average case linear in <tt>a.size()</tt>, worst case quadratic.
</ins></td>
</tr>
</tbody></table>
</blockquote>

<p>
In 23.5.1 [unord.map]/3 in the definition of class template <tt>unordered_map</tt>, in
23.5.2 [unord.multimap]/3 in the definition of class template <tt>unordered_multimap</tt>, in
23.5.3 [unord.set]/3 in the definition of class template <tt>unordered_set</tt> and in
23.5.4 [unord.multiset]/3 in the definition of class template <tt>unordered_multiset</tt>, add the
following line after member function <tt>rehash()</tt>:
</p>

<blockquote><pre>void reserve(size_type n);
</pre></blockquote>





<hr>
<h3><a name="1190"></a>1190. Setting the maximum load factor should return the previous value</h3>
<p><b>Section:</b> 23.2.5 [unord.req], 23.5 [unord] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2009-08-10  <b>Last modified:</b> 2009-08-11</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#unord.req">active issues</a> in [unord.req].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#unord.req">issues</a> in [unord.req].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The unordered associative container requirements table specifies that
<tt>a.set_max_load_factor(z)</tt> has return type <tt>void</tt>. However, there is a
useful piece of information to return: the previous value. Users who
don't need it can always ignore it.
</p>


<p><b>Proposed resolution:</b></p>
<p>
In the unordered associative container requirements table, change:
</p>

<blockquote>
<table border="1">
<caption>Table 87 &#8212; Unordered associative container requirements
(in addition to container)</caption>

<tbody><tr>
<th>Expression</th><th>Return type</th><th>Assertion/note pre-/post-condition</th>
<th>Complexity</th>
</tr>

<tr>
<td><tt>a.max_load_factor(z)</tt></td>
<td><tt><del>void</del> <ins>float</ins></tt></td>
<td>Pre: <tt>z</tt> shall be positive. Changes the container's maximum
<del>load</del> load factor, using <tt>z</tt> as a hint.
<ins>Returns: the previous value of
<tt>a.max_load_factor()</tt>.</ins>
</td>
<td>
constant
</td>
</tr>
<tr></tr>
</tbody></table>
</blockquote>

<p>
Change the return type of <tt>set_max_load_factor</tt>
in the class synopses in 23.5.1 [unord.map], 23.5.2 [unord.multimap],  23.5.3 [unord.set],
and 23.5.4 [unord.multiset].
</p>

<p>
If issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1188">1188</a> is also accepted, make the same changes for
<tt>min_load_factor</tt>.
</p>





<hr>
<h3><a name="1191"></a>1191. <tt>tuple get</tt> API should respect rvalues</h3>
<p><b>Section:</b> 20.5.2.6 [tuple.elem] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-08-18  <b>Last modified:</b> 2009-10-31</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <tt>tuple get</tt> API should respect rvalues.  This would allow for moving a
single element out of a <tt>tuple</tt>-like type.
</p>

<p><i>[
2009-10-30 Alisdair adds:
]</i></p>


<blockquote>
<p>
The issue of rvalue overloads of get for tuple-like types was briefly
discussed in Santa Cruz.
</p>

<p>
The feedback was this would be welcome, but we need full wording for the
other types (<tt>pair</tt> and <tt>array</tt>) before advancing.
</p>

<p>
I suggest the issue moves to Open from New as it has been considered,
feedback given, and it has not (yet) been rejected as NAD.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add the following signature to p2 20.5.1 [tuple.general]
</p>

<blockquote><pre><ins>
template &lt;size_t I, class ... Types&gt;
typename tuple_element&lt;I, tuple&lt;Types...&gt; &gt;::type&amp;&amp; get(tuple&lt;Types...&gt; &amp;&amp;);
</ins></pre></blockquote>

<p>
And again to 20.5.2.6 [tuple.elem].
</p>

<blockquote><pre><ins>
template &lt;size_t I, class ... Types&gt;
typename tuple_element&lt;I, tuple&lt;Types...&gt; &gt;::type&amp;&amp; get(tuple&lt;Types...&gt;&amp;&amp; t);
</ins></pre>

<blockquote>
<p><ins>
<i>Effects:</i> Equivalent to <tt>return std::forward&lt;typename tuple_element&lt;I, tuple&lt;Types...&gt; &gt;::type&amp;&amp;&gt;(get&lt;I&gt;(t));</tt>
</ins></p>


<p><ins>
[<i>Note:</i> If a <tt>T</tt> in <tt>Types</tt> is some reference type <tt>X&amp;</tt>,
the return type is <tt>X&amp;</tt>, not <tt>X&amp;&amp;</tt>.
However, if the element type is non-reference type <tt>T</tt>,
the return type is <tt>T&amp;&amp;</tt>. &#8212; <i>end note</i>]
</ins></p>

</blockquote>
</blockquote>

<p>
Add the following signature to p1 20.3 [utility]
</p>

<blockquote><pre><ins>
template &lt;size_t I, class T1, class T2&gt;
typename tuple_element&lt;I, pair&lt;T1,T2&gt; &gt;::type&amp;&amp; get(pair&lt;T1, T2&gt;&amp;&amp;);
</ins></pre></blockquote>

<p>
And to p5 20.3.5 [pair.astuple]
</p>

<blockquote><pre><ins>
template &lt;size_t I, class T1, class T2&gt;
typename tuple_element&lt;I, pair&lt;T1,T2&gt; &gt;::type&amp;&amp; get(pair&lt;T1, T2&gt;&amp;&amp; p);
</ins></pre>

<blockquote>
<p><ins>
<i>Returns:</i> If <tt>I == 0</tt> returns <tt>std::forward&lt;T1&amp;&amp;&gt;(p.first)</tt>;
if <tt>I == 1</tt>
returns <tt>std::forward&lt;T2&amp;&amp;&gt;(p.second)</tt>; otherwise the program is ill-formed.
</ins></p>

<p><ins>
<i>Throws:</i> Nothing.
</ins></p>

</blockquote>

</blockquote>

<p>
Add the following signature to 23.3 [sequences] <tt>&lt;array&gt;</tt> synopsis
</p>

<blockquote><pre><ins>template &lt;size_t I, class T, size_t N&gt;
T&amp;&amp; get(array&lt;T,N&gt; &amp;&amp;);
</ins></pre></blockquote>

<p>
And after p8 23.3.1.7 [array.tuple]
</p>

<blockquote><pre><ins>template &lt;size_t I, class T, size_t N&gt;
T&amp;&amp; get(array&lt;T,N&gt; &amp;&amp; a);
</ins></pre>

<blockquote><ins>
<i>Effects:</i> Equivalent to <tt>return std::move(get&lt;I&gt;(a));</tt>
</ins></blockquote>
</blockquote>






<hr>
<h3><a name="1192"></a>1192. <tt>basic_string</tt> missing definitions for <tt>cbegin</tt> / <tt>cend</tt> / <tt>crbegin</tt> / <tt>crend</tt></h3>
<p><b>Section:</b> 21.4.3 [string.iterators] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2009-08-14  <b>Last modified:</b> 2009-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Unlike the containers in clause 23, <tt>basic_string</tt> has definitions for
<tt>begin()</tt> and <tt>end()</tt>, but these have not been updated to include <tt>cbegin</tt>,
<tt>cend</tt>, <tt>crbegin</tt> and <tt>crend</tt>.
</p>

<p><i>[
2009-10-28 Howard:
]</i></p>


<blockquote>
Moved to Tentatively NAD after 5 positive votes on c++std-lib.  Added
rationale.
</blockquote>

<p><i>[
2009-10-28 Alisdair disagrees:
]</i></p>


<blockquote>
<p>
I'm going to have to speak up as the dissenting voice.
</p>

<p>
I agree the issue could be handled editorially, and that would be my
preference if Pete feels this is appropriate. Failing that, I really
think this issue should be accepted and moved to ready.  The other
begin/end functions all have a semantic definition for this template,
and it is confusing if a small few are missing.
</p>

<p>
I agree that an alternative would be to strike <em>all</em> the definitions for
<tt>begin/end/rbegin/rend</tt> and defer completely to the requirements tables in
clause 23.  I think that might be confusing without a forward reference
though, as those tables are defined in a *later* clause than the
basic_string template itself.  If someone wants to pursue this I would
support it, but recommend it as a separate issue.
</p>

<p>
So my preference is strongly to move Ready over NAD, and a stronger
preference for NAD Editorial if Pete is happy to make these changes.
</p>

</blockquote>

<p><i>[
2009-10-29 Howard:
]</i></p>


<blockquote>
Moved to Tentatively Ready after 5 positive votes on c++std-lib.  Removed
rationale to mark it NAD.  :-)
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add to 21.4.3 [string.iterators]
</p>

<blockquote><pre>iterator       begin();
const_iterator begin() const;
<ins>const_iterator cbegin() const;</ins>
</pre>

<p>...</p>

<pre>iterator       end();
const_iterator end() const;
<ins>const_iterator cend() const;</ins>
</pre>

<p>...</p>

<pre>reverse_iterator       rbegin();
const_reverse_iterator rbegin() const;
<ins>const_reverse_iterator crbegin() const;</ins>
</pre>

<p>...</p>

<pre>reverse_iterator       rend();
const_reverse_iterator rend() const;
<ins>const_reverse_iterator crend() const;</ins>
</pre>

</blockquote>





<hr>
<h3><a name="1193"></a>1193. <tt>default_delete</tt> cannot be instantiated with  incomplete types</h3>
<p><b>Section:</b> 20.8.14.1 [unique.ptr.dltr] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2009-08-18  <b>Last modified:</b> 2009-08-22</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
According to the general rules of 17.6.3.8 [res.on.functions]/2 b 5 the effects
are undefined, if an incomplete type is used to instantiate a library template. But neither in
20.8.14.1 [unique.ptr.dltr] nor
in any other place of the standard such explicit allowance is given.
Since this template is intended to be instantiated with incomplete
types, this must
be fixed.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add two new paragraphs directly to 20.8.14.1 [unique.ptr.dltr] (before
20.8.14.1.1 [unique.ptr.dltr.dflt]) with the following
content:
</p>

<blockquote>
<p><ins>
The class template <tt>default_delete</tt> serves as the default deleter (destruction policy) for
the class template <tt>unique_ptr</tt>.
</ins></p>

<p><ins>
The template parameter <tt>T</tt> of <tt>default_delete</tt> may be an incomplete type.
</ins></p>
</blockquote>





<hr>
<h3><a name="1194"></a>1194. Unintended <tt>queue</tt> constructor</h3>
<p><b>Section:</b> 23.3.5 [container.adaptors] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-08-20  <b>Last modified:</b> 2009-10-20</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#container.adaptors">active issues</a> in [container.adaptors].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#container.adaptors">issues</a> in [container.adaptors].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
23.3.5.1.1 [queue.defn] has the following <tt>queue</tt> constructor:
</p>

<blockquote><pre>template &lt;class Alloc&gt; explicit queue(const Alloc&amp;);
</pre></blockquote>

<p>
This will be implemented like so:
</p>

<blockquote><pre>template &lt;class Alloc&gt; explicit queue(const Alloc&amp; a) : c(a) {}
</pre></blockquote>

<p>
The issue is that <tt>Alloc</tt> can be anything that a container will construct
from, for example an <tt>int</tt>.  Is this intended to compile?
</p>

<blockquote><pre>queue&lt;int&gt; q(5);
</pre></blockquote>

<p>
Before the addition of this constructor, <tt>queue&lt;int&gt;(5)</tt> would not compile.
I ask, not because this crashes, but because it is new and appears to be
unintended.  We do not want to be in a position of accidently introducing this
"feature" in C++0X and later attempting to remove it.
</p>

<p>
I've picked on <tt>queue</tt>.  <tt>priority_queue</tt> and <tt>stack</tt> have
the same issue.  Is it useful to create a <tt>priority_queue</tt> of 5
identical elements?
</p>

<p><i>[
Daniel, Howard and Pablo collaborated on the proposed wording.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Move to Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>

<p><i>[
This resolution includes a semi-editorial clean up, giving definitions to members
which in some cases weren't defined since C++98.
This resolution also offers editorially different wording for <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#976">976</a>,
and it also provides wording for <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1196">1196</a>.
]</i></p>


<p>
Change  container.adaptors, p1:
</p>

<blockquote>
The container adaptors each take a <tt>Container</tt> template parameter, and
each constructor takes a <tt>Container</tt> reference argument. This container is
copied into the <tt>Container</tt> member of each adaptor. If the container takes
an allocator, then a compatible allocator may be passed in to the
adaptor's constructor. Otherwise, normal copy or move construction is
used for the container argument. <del>[<i>Note:</i> it is not necessary for an
implementation to distinguish between the one-argument constructor that
takes a <tt>Container</tt> and the one- argument constructor that takes an
allocator_type. Both forms use their argument to construct an instance
of the container. &#8212; <i>end note</i>]</del>
</blockquote>

<p>
Change  queue.defn, p1:
</p>

<blockquote><pre>template &lt;class T, class Container = deque&lt;T&gt; &gt;
class queue {
public:
  typedef typename Container::value_type      value_type;
  typedef typename Container::reference       reference;
  typedef typename Container::const_reference const_reference;
  typedef typename Container::size_type       size_type;
  typedef Container                           container_type;
protected:
  Container c;

public:
  explicit queue(const Container&amp;);
  explicit queue(Container&amp;&amp; = Container());
  queue(queue&amp;&amp; q)<ins>;</ins><del> : c(std::move(q.c)) {}</del>
  template &lt;class Alloc&gt; explicit queue(const Alloc&amp;);
  template &lt;class Alloc&gt; queue(const Container&amp;, const Alloc&amp;);
  template &lt;class Alloc&gt; queue(Container&amp;&amp;, const Alloc&amp;);
  template &lt;class Alloc&gt; queue(queue&amp;&amp;, const Alloc&amp;);
  queue&amp; operator=(queue&amp;&amp; q)<ins>;</ins><del> { c = std::move(q.c); return *this; }</del>

  bool empty() const          { return c.empty(); }
  ...
};
</pre></blockquote>

<p>
Add a new section after 23.3.5.1.1 [queue.defn], [queue.cons]:
</p>

<blockquote>
<p><b><tt>queue</tt> constructors [queue.cons]</b></p>

<pre>explicit queue(const Container&amp; cont);
</pre>

<blockquote>

<p>
<i>Effects:</i> Initializes <tt>c</tt> with <tt>cont</tt>.
</p>

</blockquote>

<pre>explicit queue(Container&amp;&amp; cont = Container());
</pre>

<blockquote>

<p>
<i>Effects:</i> Initializes <tt>c</tt> with <tt>std::move(cont)</tt>.
</p>

</blockquote>

<pre>queue(queue&amp;&amp; q)
</pre>

<blockquote>

<p>
<i>Effects:</i> Initializes <tt>c</tt> with <tt>std::move(q.c)</tt>.
</p>

</blockquote>

<p>
For each of the following constructors,
if <tt>uses_allocator&lt;container_type, Alloc&gt;::value</tt> is <tt>false</tt>,
then the constructor shall not participate in overload resolution.
</p>

<pre>template &lt;class Alloc&gt; 
  explicit queue(const Alloc&amp; a);
</pre>

<blockquote>

<p>
<i>Effects:</i> Initializes <tt>c</tt> with <tt>a</tt>.
</p>

</blockquote>

<pre>template &lt;class Alloc&gt; 
  queue(const container_type&amp; cont, const Alloc&amp; a);
</pre>

<blockquote>

<p>
<i>Effects:</i> Initializes <tt>c</tt> with <tt>cont</tt> as the first
argument and <tt>a</tt> as the second argument.
</p>

</blockquote>

<pre>template &lt;class Alloc&gt; 
  queue(container_type&amp;&amp; cont, const Alloc&amp; a);
</pre>

<blockquote>

<p>
<i>Effects:</i> Initializes <tt>c</tt> with <tt>std::move(cont)</tt> as the
first argument and <tt>a</tt> as the second argument.
</p>

</blockquote>

<pre>template &lt;class Alloc&gt; 
  queue(queue&amp;&amp; q, const Alloc&amp; a);
</pre>

<blockquote>

<p>
<i>Effects:</i> Initializes <tt>c</tt> with <tt>std::move(q.c)</tt> as the
first argument and <tt>a</tt> as the second argument.
</p>

</blockquote>

<pre>queue&amp; operator=(queue&amp;&amp; q);
</pre>

<blockquote>

<p>
<i>Effects:</i> Assigns <tt>c</tt> with <tt>std::move(q.c)</tt>.
</p>

<p>
<i>Returns:</i> <tt>*this</tt>.
</p>

</blockquote>



</blockquote>

<p>
Add to 23.3.5.2.1 [priqueue.cons]:
</p>

<blockquote>

<pre>priority_queue(priority_queue&amp;&amp; q);
</pre>

<blockquote>

<p>
<i>Effects:</i> Initializes <tt>c</tt> with <tt>std::move(q.c)</tt> and
initializes <tt>comp</tt> with <tt>std::move(q.comp)</tt>.
</p>

</blockquote>

<p>
For each of the following constructors,
if <tt>uses_allocator&lt;container_type, Alloc&gt;::value</tt> is <tt>false</tt>,
then the constructor shall not participate in overload resolution.
</p>

<pre>template &lt;class Alloc&gt;
  explicit priority_queue(const Alloc&amp; a);
</pre>

<blockquote>

<p>
<i>Effects:</i> Initializes <tt>c</tt> with <tt>a</tt> and value-initializes <tt>comp</tt>.
</p>

</blockquote>

<pre>template &lt;class Alloc&gt;
  priority_queue(const Compare&amp; compare, const Alloc&amp; a);
</pre>

<blockquote>

<p>
<i>Effects:</i> Initializes <tt>c</tt> with <tt>a</tt> and initializes <tt>comp</tt>
with <tt>compare</tt>.
</p>

</blockquote>

<pre>template &lt;class Alloc&gt;
  priority_queue(const Compare&amp; compare, const Container&amp; cont, const Alloc&amp; a);
</pre>

<blockquote>

<p>
<i>Effects:</i> Initializes <tt>c</tt> with <tt>cont</tt> as the first argument
and <tt>a</tt> as the second argument,
and initializes <tt>comp</tt> with <tt>compare</tt>.
</p>

</blockquote>

<pre>template &lt;class Alloc&gt;
  priority_queue(const Compare&amp; compare, Container&amp;&amp; cont, const Alloc&amp; a);
</pre>

<blockquote>

<p>
<i>Effects:</i> Initializes <tt>c</tt> with <tt>std::move(cont)</tt> as 
the first argument and <tt>a</tt> as the second argument,
and initializes <tt>comp</tt> with <tt>compare</tt>.
</p>

</blockquote>

<pre>template &lt;class Alloc&gt;
  priority_queue(priority_queue&amp;&amp; q, const Alloc&amp; a);
</pre>

<blockquote>

<p>
<i>Effects:</i> Initializes <tt>c</tt> with <tt>std::move(q.c)</tt> as the
first argument and <tt>a</tt> as the second argument, 
and initializes <tt>comp</tt> with <tt>std::move(q.comp)</tt>.
</p>

</blockquote>

<pre>priority_queue&amp; operator=(priority_queue&amp;&amp; q);
</pre>

<blockquote>

<p>
<i>Effects:</i> Assigns <tt>c</tt> with <tt>std::move(q.c)</tt> and
assigns <tt>comp</tt> with <tt>std::move(q.comp)</tt>.
</p>

<p>
<i>Returns:</i> <tt>*this</tt>.
</p>

</blockquote>

</blockquote>




<p>
Change 23.3.5.3.1 [stack.defn]:
</p>

<blockquote><pre>template &lt;class T, class Container = deque&lt;T&gt; &gt;
class stack {
public:
  typedef typename Container::value_type      value_type;
  typedef typename Container::reference       reference;
  typedef typename Container::const_reference const_reference;
  typedef typename Container::size_type       size_type;
  typedef Container                           container_type;
protected:
  Container c;

public:
  explicit stack(const Container&amp;);
  explicit stack(Container&amp;&amp; = Container());
  <ins>stack(stack&amp;&amp; s);</ins>
  template &lt;class Alloc&gt; explicit stack(const Alloc&amp;);
  template &lt;class Alloc&gt; stack(const Container&amp;, const Alloc&amp;);
  template &lt;class Alloc&gt; stack(Container&amp;&amp;, const Alloc&amp;);
  template &lt;class Alloc&gt; stack(stack&amp;&amp;, const Alloc&amp;);
  <ins>stack&amp; operator=(stack&amp;&amp; s);</ins>

  bool empty() const          { return c.empty(); }
  ...
};
</pre></blockquote>

<p>
Add a new section after 23.3.5.3.1 [stack.defn], [stack.cons]:
</p>

<blockquote>
<p><b><tt>stack</tt> constructors [stack.cons]</b></p>

<pre>stack(stack&amp;&amp; s);
</pre>

<blockquote>

<p>
<i>Effects:</i> Initializes <tt>c</tt> with <tt>std::move(s.c)</tt>.
</p>

</blockquote>

<p>
For each of the following constructors,
if <tt>uses_allocator&lt;container_type, Alloc&gt;::value</tt> is <tt>false</tt>,
then the constructor shall not participate in overload resolution.
</p>

<pre>template &lt;class Alloc&gt; 
  explicit stack(const Alloc&amp; a);
</pre>

<blockquote>

<p>
<i>Effects:</i> Initializes <tt>c</tt> with <tt>a</tt>.
</p>

</blockquote>

<pre>template &lt;class Alloc&gt; 
  stack(const container_type&amp; cont, const Alloc&amp; a);
</pre>

<blockquote>

<p>
<i>Effects:</i> Initializes <tt>c</tt> with <tt>cont</tt> as the
first argument and <tt>a</tt> as the second argument.
</p>

</blockquote>

<pre>template &lt;class Alloc&gt; 
  stack(container_type&amp;&amp; cont, const Alloc&amp; a);
</pre>

<blockquote>

<p>
<i>Effects:</i> Initializes <tt>c</tt> with <tt>std::move(cont)</tt> as the
first argument and <tt>a</tt> as the second argument.
</p>

</blockquote>

<pre>template &lt;class Alloc&gt; 
  stack(stack&amp;&amp; s, const Alloc&amp; a);
</pre>

<blockquote>

<p>
<i>Effects:</i> Initializes <tt>c</tt> with <tt>std::move(s.c)</tt> as the
first argument and <tt>a</tt> as the second argument.
</p>

</blockquote>

<pre>stack&amp; operator=(stack&amp;&amp; s);
</pre>

<blockquote>

<p>
<i>Effects:</i> Assigns <tt>c</tt> with <tt>std::move(s.c)</tt>.
</p>

<p>
<i>Returns:</i> <tt>*this</tt>.
</p>

</blockquote>

</blockquote>






<hr>
<h3><a name="1197"></a>1197. Can unordered containers have <tt>bucket_count() == 0</tt>?</h3>
<p><b>Section:</b> 23.2.5 [unord.req] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-08-24  <b>Last modified:</b> 2009-09-03</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#unord.req">active issues</a> in [unord.req].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#unord.req">issues</a> in [unord.req].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Table 97 "Unordered associative container requirements" in
23.2.5 [unord.req] says:
</p>

<blockquote>
<table border="1">
<caption>Table 97 &#8212; Unordered associative container requirements
(in addition to container)</caption>

<tbody><tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion/note pre-/post-condition</th>
<th>Complexity</th>
</tr>

<tr>
<td><tt>b.bucket(k)</tt></td>
<td><tt>size_type</tt></td>
<td>Returns the index of the bucket in which elements with keys 
equivalent to <tt>k</tt> would be found, 
if any such element existed. 
Post: the return value shall be 
in the range <tt>[0, 
b.bucket_count())</tt>.</td>
<td>Constant</td>
</tr>

</tbody></table>
</blockquote>

<p>
What should <tt>b.bucket(k)</tt> return if <tt>b.bucket_count() == 0</tt>?
</p>

<p>
I believe allowing <tt>b.bucket_count() == 0</tt> is important.  It is a
very reasonable post-condition of the default constructor, or of a moved-from
container.
</p>

<p>
I can think of several reasonable results from <tt>b.bucket(k)</tt> when
<tt>b.bucket_count() == 0</tt>:
</p>

<ol>
<li>
Return 0.
</li>
<li>
Return <tt>numeric_limits&lt;size_type&gt;::max()</tt>.
</li>
<li>
Throw a <tt>domain_error</tt>.
</li>
<li>
Precondition: <tt>b.bucket_count() != 0</tt>.
</li>
</ol>

<p><i>[
2009-08-26 Daniel adds:
]</i></p>


<blockquote>
<p>
A forth choice would be to add the pre-condition "<tt>b.bucket_count() != 0</tt>"
and thus imply undefined behavior if this is violated.
</p>

<p><i>[
Howard:  I like this option too, added to the list.
]</i></p>


<p>
Further on here my own favorite solution (rationale see below):
</p>

<p><b>Suggested resolution:</b></p>

<p>
[Rationale: I suggest to follow choice (1). The main reason is
that all associative container functions which take a key argument,
are basically free of pre-conditions and non-disrupting, therefore
excluding choices (3) and (4). Option (2) seems a bit unexpected
to me. It would be more natural, if several similar functions
would exist which would also justify the existence of a symbolic
constant like npos for this situation. The value 0 is both simple
and consistent, it has exactly the same role as a past-the-end
iterator value. A typical use-case is:
</p>

<blockquote><pre>size_type pos = m.bucket(key);
if (pos != m.bucket_count()) {
 ...
} else {
 ...
}
</pre></blockquote>

<p>&#8212; end Rationale]</p>

<p>
- Change Table 97 in 23.2.5 [unord.req] as follows (Row b.bucket(k), Column "Assertion/..."):
</p>

<blockquote>
<table border="1">
<caption>Table 97 &#8212; Unordered associative container requirements
(in addition to container)</caption>

<tbody><tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion/note pre-/post-condition</th>
<th>Complexity</th>
</tr>

<tr>
<td><tt>b.bucket(k)</tt></td>
<td><tt>size_type</tt></td>
<td>Returns the index of the bucket in which elements with keys 
equivalent to <tt>k</tt> would be found, 
if any such element existed. 
Post: <ins>if b.bucket_count() != 0, </ins>the return value shall be 
in the range <tt>[0, 
b.bucket_count())</tt><ins>, otherwise 0</ins>.</td>
<td>Constant</td>
</tr>

</tbody></table>
</blockquote>

</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="1198"></a>1198. Container adaptor swap: member or non-member?</h3>
<p><b>Section:</b> 23.3.5 [container.adaptors] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Pablo Halpern <b>Opened:</b> 2009-08-26  <b>Last modified:</b> 2009-09-30</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#container.adaptors">active issues</a> in [container.adaptors].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#container.adaptors">issues</a> in [container.adaptors].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Under 23.3.5 [container.adaptors] of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2914.pdf">N2914</a>
the member function of <tt>swap</tt> of <tt>queue</tt> and <tt>stack</tt> call:
</p>

<blockquote><pre>swap(c, q.c);
</pre></blockquote>

<p>
But under 23.3.5 [container.adaptors] of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2723.pdf">N2723</a>
these members are specified to call:
</p>

<blockquote><pre>c.swap(q.c);
</pre></blockquote>

<p>
Neither draft specifies the semantics of member <tt>swap</tt> for
<tt>priority_queue</tt> though it is declared.
</p>

<p>
Although the distinction between member <tt>swap</tt> and non-member
<tt>swap</tt> is not important when these adaptors are adapting standard
containers, it may be important for user-defined containers.
</p>
<p>
We (Pablo and Howard) feel that
it is more likely for a user-defined container to support a namespace scope
<tt>swap</tt> than a member <tt>swap</tt>, and therefore these adaptors
should use the container's namespace scope <tt>swap</tt>.
</p>

<p><i>[
2009-09-30 Daniel adds:
]</i></p>


<blockquote>
The outcome of this issue should be considered with the outcome of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#774">774</a> both in style and in content (e.g. <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#774">774</a> bullet 9
suggests to define the semantic of <tt>void
priority_queue::swap(priority_queue&amp;)</tt> in terms of the member
<tt>swap</tt> of the container).
</blockquote>



<p><b>Proposed resolution:</b></p>
<p><i>[
Changes written with respect to
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2723.pdf">N2723</a>.
]</i></p>


<p>
Change 23.3.5.1.1 [queue.defn]:
</p>

<blockquote><pre>template &lt;class T, class Container = deque&lt;T&gt; &gt; 
class queue {
   ...
   void swap(queue&amp;<del>&amp;</del> q) { <ins>using std::swap;</ins>
                          <del>c.</del>swap(<ins>c, </ins>q.c); }
   ...
};
</pre></blockquote>

<p>
Change 23.3.5.2 [priority.queue]:
</p>

<blockquote><pre>template &lt;class T, class Container = vector&lt;T&gt;, 
          class Compare = less&lt;typename Container::value_type&gt; &gt; 
class priority_queue { 
    ...
    void swap(priority_queue&amp;<del>&amp;</del> <ins>q</ins>)<del>;</del> <ins>{ using std::swap;</ins>
                                     <ins>swap(c, q.c);</ins>
                                     <ins>swap(comp, q.comp); }</ins>
    ...
};
</pre></blockquote>

<p>
Change 23.3.5.3.1 [stack.defn]:
</p>

<blockquote><pre>template &lt;class T, class Container = deque&lt;T&gt; &gt; 
class stack {
   ...
   void swap(stack&amp;<del>&amp;</del> s) { <ins>using std::swap;</ins>
                          <del>c.</del>swap(<ins>c, </ins>s.c); }
   ...
};
</pre></blockquote>






<hr>
<h3><a name="1199"></a>1199. Missing extended copy constructor in container adaptors</h3>
<p><b>Section:</b> 23.3.5 [container.adaptors] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Pablo Halpern <b>Opened:</b> 2009-08-26  <b>Last modified:</b> 2009-08-31</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#container.adaptors">active issues</a> in [container.adaptors].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#container.adaptors">issues</a> in [container.adaptors].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>queue</tt> has a constructor:
</p>

<blockquote><pre>template &lt;class Alloc&gt;
  queue(queue&amp;&amp;, const Alloc&amp;);
</pre></blockquote>

<p>
but it is missing a corresponding constructor:
</p>

<blockquote><pre>template &lt;class Alloc&gt;
  queue(const queue&amp;, const Alloc&amp;);
</pre></blockquote>

<p>
The same is true of <tt>priority_queue</tt>, and <tt>stack</tt>.  This
"extended copy constructor" is needed for consistency and to ensure that the
user of a container adaptor can always specify the allocator for his adaptor.
</p>



<p><b>Proposed resolution:</b></p>
<p><i>[
This resolution has been harmonized with the proposed resolution to issue
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1194">1194</a>
]</i></p>


<p>Change 23.3.5.1.1 [queue.defn], p1:</p>

<blockquote><pre>template &lt;class T, class Container = deque&lt;T&gt; &gt;
class queue {
public:
  typedef typename Container::value_type      value_type;
  typedef typename Container::reference       reference;
  typedef typename Container::const_reference const_reference;
  typedef typename Container::size_type       size_type;
  typedef Container                           container_type;
protected:
  Container c;

public:
  explicit queue(const Container&amp;);
  explicit queue(Container&amp;&amp; = Container());
  queue(queue&amp;&amp; q);

  template &lt;class Alloc&gt; explicit queue(const Alloc&amp;);
  template &lt;class Alloc&gt; queue(const Container&amp;, const Alloc&amp;);
  template &lt;class Alloc&gt; queue(Container&amp;&amp;, const Alloc&amp;);
  <ins>template &lt;class Alloc&gt; queue(const queue&amp;, const Alloc&amp;);</ins>
  template &lt;class Alloc&gt; queue(queue&amp;&amp;, const Alloc&amp;);
  queue&amp; operator=(queue&amp;&amp; q);

  bool empty() const          { return c.empty(); }
  ...
};
</pre></blockquote>

<p>
To the new section  [queue.cons], introduced
in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1194">1194</a>, add:
</p>

<blockquote>

<pre>template &lt;class Alloc&gt; 
  queue(const queue&amp; q, const Alloc&amp; a);
</pre>

<blockquote><p>
<i>Effects:</i> Initializes <tt>c</tt> with <tt>q.c</tt> as the
first argument and <tt>a</tt> as the second argument.
</p></blockquote>

</blockquote>

<p>Change 23.3.5.2 [priority.queue] as follows (I've an included an editorial change to
  move the poorly-placed move-assignment operator):</p>

<blockquote><pre>template &lt;class T, class Container = vector&lt;T&gt;,
          class Compare = less&lt;typename Container::value_type&gt; &gt;
class priority_queue {
public:
  typedef typename Container::value_type      value_type;
  typedef typename Container::reference       reference;
  typedef typename Container::const_reference const_reference;
  typedef typename Container::size_type       size_type;
  typedef          Container                  container_type;
protected:
  Container c;
  Compare comp;

public:
  priority_queue(const Compare&amp; x, const Container&amp;);
  explicit priority_queue(const Compare&amp; x = Compare(), Container&amp;&amp; = Container());
  template &lt;class InputIterator&gt;
    priority_queue(InputIterator first, InputIterator last,
                   const Compare&amp; x, const Container&amp;);
  template &lt;class InputIterator&gt;
    priority_queue(InputIterator first, InputIterator last,
                   const Compare&amp; x = Compare(), Container&amp;&amp; = Container());
  priority_queue(priority_queue&amp;&amp;);
  <del>priority_queue&amp; operator=(priority_queue&amp;&amp;);</del>
  template &lt;class Alloc&gt; explicit priority_queue(const Alloc&amp;);
  template &lt;class Alloc&gt; priority_queue(const Compare&amp;, const Alloc&amp;);
  template &lt;class Alloc&gt; priority_queue(const Compare&amp;,
                                        const Container&amp;, const Alloc&amp;);
  template &lt;class Alloc&gt; priority_queue(const Compare&amp;,
                                        Container&amp;&amp;, const Alloc&amp;);
  <ins>template &lt;class Alloc&gt; priority_queue(const priority_queue&amp;, const Alloc&amp;);</ins>
  template &lt;class Alloc&gt; priority_queue(priority_queue&amp;&amp;, const Alloc&amp;);

  <ins>priority_queue&amp; operator=(priority_queue&amp;&amp;);</ins>
  ...
};
</pre></blockquote>

<p>
Add to 23.3.5.2.1 [priqueue.cons]:
</p>

<blockquote>

<pre>template &lt;class Alloc&gt;
  explicit priority_queue(const priority_queue&amp; q, const Alloc&amp; a);
</pre>

<blockquote><p>
<i>Effects:</i> Initializes <tt>c</tt> with <tt>q.c</tt> as the
first argument and <tt>a</tt> as the second argument, 
and initializes <tt>comp</tt> with <tt>q.comp</tt>.
</p></blockquote>

</blockquote>

<p>
Change 23.3.5.3.1 [stack.defn]:
</p>

<blockquote><pre>template &lt;class T, class Container = deque&lt;T&gt; &gt;
class stack {
public:
  typedef typename Container::value_type      value_type;
  typedef typename Container::reference       reference;
  typedef typename Container::const_reference const_reference;
  typedef typename Container::size_type       size_type;
  typedef Container                           container_type;
protected:
  Container c;

public:
  explicit stack(const Container&amp;);
  explicit stack(Container&amp;&amp; = Container());
  stack(stack&amp;&amp; s);

  template &lt;class Alloc&gt; explicit stack(const Alloc&amp;);
  template &lt;class Alloc&gt; stack(const Container&amp;, const Alloc&amp;);
  template &lt;class Alloc&gt; stack(Container&amp;&amp;, const Alloc&amp;);
  <ins>template &lt;class Alloc&gt; stack(const stack&amp;, const Alloc&amp;);</ins>
  template &lt;class Alloc&gt; stack(stack&amp;&amp;, const Alloc&amp;);
  stack&amp; operator=(stack&amp;&amp; s);

  bool empty() const          { return c.empty(); }
  ...
};
</pre></blockquote>

<p>
To the new section  [stack.cons], introduced
in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1194">1194</a>, add:
</p>

<blockquote>

<pre>template &lt;class Alloc&gt; 
  stack(const stack&amp; s, const Alloc&amp; a);
</pre>

<blockquote><p>
<i>Effects:</i> Initializes <tt>c</tt> with <tt>s.c</tt> as the
first argument and <tt>a</tt> as the second argument.
</p></blockquote>
</blockquote>






<hr>
<h3><a name="1200"></a>1200. "surprising" <tt>char_traits&lt;T&gt;::int_type</tt> requirements</h3>
<p><b>Section:</b> 21.2.2 [char.traits.typedefs] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Sean Hunt <b>Opened:</b> 2009-09-03  <b>Last modified:</b> 2009-10-28</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#char.traits.typedefs">issues</a> in [char.traits.typedefs].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The footnote for <tt>int_type</tt> in 21.2.2 [char.traits.typedefs] says that
</p>

<blockquote>
If <tt>eof()</tt>
can be held in <tt>char_type</tt> then some iostreams implementations may give
surprising results.
</blockquote>

<p>
This implies that <tt>int_type</tt> should be a superset of
<tt>char_type</tt>. However, the requirements for <tt>char16_t</tt> and <tt>char32_t</tt> define
<tt>int_type</tt> to be equal to <tt>int_least16_t</tt> and <tt>int_least32_t</tt> respectively.
<tt>int_least16_t</tt> is likely to be the same size as <tt>char_16_t</tt>, which may lead
to surprising behavior, even if <tt>eof()</tt> is not a valid UTF-16 code unit.
The standard should not prescribe surprising behavior, especially
without saying what it is (it's apparently not undefined, just
surprising). The same applies for 32-bit types.
</p>

<p>
I personally recommend that behavior be undefined if <tt>eof()</tt> is a member
of <tt>char_type</tt>, and another type be chosen for <tt>int_type</tt> (my personal
favorite has always been a <tt>struct {bool eof; char_type c;}</tt>).
Alternatively, the exact results of such a situation should be defined,
at least so far that I/O could be conducted on these types as long as
the code units remain valid. Note that the argument that no one streams
<tt>char16_t</tt> or <tt>char32_t</tt> is not really valid as it would be perfectly
reasonable to use a <tt>basic_stringstream</tt> in conjunction with UTF character
types.
</p>

<p><i>[
2009-10-28 Ganesh provides two possible resolutions and expresses a preference
for the second:
]</i></p>


<blockquote>
<ol>
<li>
<p>
Replace 21.2.3.2 [char.traits.specializations.char16_t] para 3 with:
</p>

<blockquote>
The member <tt>eof()</tt> shall return <del>an implementation-defined
constant that cannot appear as a valid UTF-16 code unit</del>
<ins><tt>UINT_LEAST16_MAX</tt> [<i>Note:</i> this value is guaranteed to
be a permanently reserved UCS-2 code position if <tt>UINT_LEAST16_MAX ==
0xFFFF</tt> and it's not a UCS-2 code position otherwise &#8212; <i>end
note</i>]</ins>.
</blockquote>

<p>
Replace 21.2.3.3 [char.traits.specializations.char32_t] para 3 with:
</p>

<blockquote>
The member <tt>eof()</tt> shall return <del>an implementation-defined constant that
cannot appear as a Unicode code point</del>
<ins>
<tt>UINT_LEAST32_MAX</tt> [<i>Note:</i> this value is guaranteed to be a
permanently reserved UCS-4 code position if <tt>UINT_LEAST32_MAX ==
0xFFFFFFFF</tt> and it's not a UCS-4 code position otherwise &#8212; <i>end
note</i>]</ins>.
</blockquote>
</li>
<li>
<p>
In 21.2.3.2 [char.traits.specializations.char16_t], in the
definition of <tt>char_traits&lt;char16_t&gt;</tt> replace the definition of nested
typedef <tt>int_type</tt> with:
</p>

<blockquote><pre>namespace std {
  template&lt;&gt; struct char_traits&lt;char16_t&gt; {
    typedef char16_t         char_type;
    typedef <del>uint_least16_t</del> <ins>uint_fast16_t</ins> int_type;
     ...
</pre></blockquote>

<p>
Replace 21.2.3.2 [char.traits.specializations.char16_t] para 3 with:
</p>

<blockquote>
The member <tt>eof()</tt> shall return <del>an implementation-defined
constant that cannot appear as a valid UTF-16 code unit</del>
<ins><tt>UINT_FAST16_MAX</tt> [<i>Note:</i> this value is guaranteed to
be a permanently reserved UCS-2 code position if <tt>UINT_FAST16_MAX ==
0xFFFF</tt> and it's not a UCS-2 code position otherwise &#8212; <i>end
note</i>]</ins>.
</blockquote>

<p>
In 21.2.3.3 [char.traits.specializations.char32_t], in the
definition of <tt>char_traits&lt;char32_t&gt;</tt> replace the definition of nested
typedef <tt>int_type</tt> with:
</p>

<blockquote><pre>namespace std {
  template&lt;&gt; struct char_traits&lt;char32_t&gt; {
    typedef char32_t         char_type;
    typedef <del>uint_least32_t</del> <ins>uint_fast32_t</ins> int_type;
     ...
</pre></blockquote>

<p>
Replace 21.2.3.3 [char.traits.specializations.char32_t] para 3 with:
</p>

<blockquote>
The member <tt>eof()</tt> shall return <del>an implementation-defined constant that
cannot appear as a Unicode code point</del>
<ins>
<tt>UINT_FAST32_MAX</tt> [<i>Note:</i> this value is guaranteed to be a
permanently reserved UCS-4 code position if <tt>UINT_FAST32_MAX ==
0xFFFFFFFF</tt> and it's not a UCS-4 code position otherwise &#8212; <i>end
note</i>]</ins>.
</blockquote>
</li>
</ol>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="1201"></a>1201. Do we always want to unwrap <tt>ref</tt>-wrappers in <tt>make_tuple</tt></h3>
<p><b>Section:</b> 20.5.2.4 [tuple.creation], 20.3.4 [pairs] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Future">Tentatively NAD Future</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-09-05  <b>Last modified:</b> 2009-10-26</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20NAD%20Future">Tentatively NAD Future</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Spotting a recent thread on the boost lists regarding collapsing
optional representations in <tt>optional&lt;optional&lt;T&gt;&gt;</tt> instances, I wonder if
we have some of the same issues with <tt>make_tuple</tt>, and now <tt>make_pair</tt>?
</p>

<p>
Essentially, if my generic code in my own library is handed a
<tt>reference_wrapper</tt> by a user, and my library in turn delegates some logic
to <tt>make_pair</tt> or <tt>make_tuple</tt>, then I am going to end up with a <tt>pair</tt>/<tt>tuple</tt>
holding a real reference rather than the intended reference wrapper.
</p>

<p>
There are two things as a library author I can do at this point:
</p>

<ol type="i">
<li>
document my library also has the same reference-wrapper behaviour as
<tt>std::make_tuple</tt>
</li>
<li>
roll my own <tt>make_tuple</tt> that does not unwrap rereferences, a lost
opportunity to re-use the standard library.
</li>
</ol>

<p>
(There may be some metaprogramming approaches my library can use to wrap
the <tt>make_tuple</tt> call, but all will be significantly more complex than
simply implementing a simplified <tt>make_tuple</tt>.)
</p>

<p>
Now I don't propose we lose this library facility, I think unwrapping
references will be the common behaviour.  However, we might want to
consider adding another overload that does nothing special with
<tt>ref</tt>-wrappers.  Note that we already have a second overload of <tt>make_tuple</tt>
in the library, called <tt>tie</tt>.
</p>

<p><i>[
2009-09-30 Daniel adds:
]</i></p>


<blockquote>
<p>
I suggest to change the currently proposed paragraph for
<tt>make_simple_pair</tt>
</p>

<blockquote><pre>template&lt;typename... Types&gt;
  pair&lt;typename decay&lt;Types&gt;::type...&gt; make_simple_pair(Types&amp;&amp;... t);
</pre>
<blockquote>
<p>
<del><i>Type requirements:</i> <tt>sizeof...(Types) == 2</tt>.</del>
<ins><i>Remarks:</i> The program shall be ill-formed, if
<tt>sizeof...(Types) != 2</tt>.</ins>
</p>
<p>
...
</p>
</blockquote>
</blockquote>

<p>
or alternatively (but with a slightly different semantic):
</p>

<blockquote>
<blockquote>
<i>Remarks:</i> If <tt>sizeof...(Types) != 2</tt>, this function shall not
participate in overload resolution.
</blockquote>
</blockquote>

<p>
to follow a currently introduced style and because the library does
not have yet a specific "<i>Type requirements</i>" element. If such thing
would be considered as useful this should be done as a separate
issue. Given the increasing complexity of either of these wordings
it might be preferable to use the normal two-argument-declaration
style again in either of the following ways:
</p>

<ol type="A">
<li>
<pre>template&lt;class T1, class T2&gt;
pair&lt;typename decay&lt;T1&gt;::type, typename decay&lt;T2&gt;::type&gt;
make_simple_pair(T1&amp;&amp; t1, T2&amp;&amp; t2);
</pre>
</li>
<li>
<pre>template&lt;class T1, class T2&gt;
pair&lt;V1, V2&gt; make_simple_pair(T1&amp;&amp; t1, T2&amp;&amp; t2);
</pre>
<blockquote>
Let <tt>V1</tt> be <tt>typename decay&lt;T1&gt;::type</tt> and <tt>V2</tt> be
<tt>typename decay&lt;T2&gt;::type</tt>.
</blockquote>
</li>
</ol>

</blockquote>

<p><i>[
2009-10 post-Santa Cruz:
]</i></p>


<blockquote>
Mark as Tentatively NAD Future.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add the following function to 20.3.4 [pairs] and signature in
appropriate synopses:
</p>

<blockquote><pre>template&lt;typename... Types&gt;
  pair&lt;typename decay&lt;Types&gt;::type...&gt; make_simple_pair(Types&amp;&amp;... t);
</pre>
<blockquote>
<p>
<i>Type requirements:</i> <tt>sizeof...(Types) == 2</tt>.
</p>
<p>
<i>Returns:</i> <tt>pair&lt;typename decay&lt;Types&gt;::type...&gt;(std::forward&lt;Types&gt;(t)...)</tt>.
</p>
</blockquote>
</blockquote>

<p><i>[
Draughting note: I chose a variadic representation similar to <tt>make_tuple</tt>
rather than naming both types as it is easier to read through the
clutter of metaprogramming this way.  Given there are exactly two
elements, the committee may prefer to draught with two explicit template
type parameters instead
]</i></p>


<p>
Add the following function to 20.5.2.4 [tuple.creation] and
signature in appropriate synopses:
</p>

<blockquote><pre>template&lt;typename... Types&gt;
  tuple&lt;typename decay&lt;Types&gt;::type...&gt; make_simple_tuple(Types&amp;&amp;... t);
</pre>
<blockquote>
<p>
<i>Returns:</i> <tt>tuple&lt;typename decay&lt;Types&gt;::type...&gt;(std::forward&lt;Types&gt;(t)...)</tt>.
</p>
</blockquote>
</blockquote>





<hr>
<h3><a name="1202"></a>1202. <tt>integral_constant</tt> needs a spring clean</h3>
<p><b>Section:</b> 20.6.3 [meta.help] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-09-05  <b>Last modified:</b> 2009-09-06</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#meta.help">issues</a> in [meta.help].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The specification of <tt>integral_constant</tt> has been inherited
essentially unchanged from TR1:
</p>

<blockquote><pre>template &lt;class T, T v&gt;
struct integral_constant {
  static const T value = v;
  typedef T value_type;
  typedef integral_constant&lt;T,v&gt; type;
};
</pre></blockquote>

<p>
In light of 0x language changes there are several things we might
consider changing, notably the form of specification for value.
</p>

<p>
The current form requires a static data member have storage allocated
for it, where we could now implement without this using the new enum
syntax:
</p>

<blockquote><pre>template &lt;class T, T v&gt;
struct integral_constant {
  <b>enum : T { value = v };</b>
  typedef T value_type;
  typedef integral_constant type;
};
</pre></blockquote>

<p>
The effective difference between these two implementation is:
</p>

<ol type="i">
<li>
No requirement to allocate storage for data member (which we hope but do
not guarantee compilers strip today)
</li>

<li>
You can no longer take the address of the constant as
<tt>&amp;integral_constant&lt;T,v&gt;::value;</tt>
</li>
</ol>

<p>
Also note the editorial change to drop the explicit qualification of
<tt>integral_constant</tt> in the <tt>typedef type</tt>.  This makes it quite clear we
mean the current instantiation, and cannot be mistaken for a recursive
metaprogram.
</p>

<p>
Even if we don't mandate this implementation, it would be nice to give
vendors freedom under QoI to choose their preferred representation.
</p>

<p>
The other side of this issue is if we choose to retain the static
constant form.  In that case we should go further and insist on
<tt>constexpr</tt>, much like we did throughout <tt>numeric_limits</tt>:
</p>

<blockquote><pre>template &lt;class T, T v&gt;
struct integral_constant {
  static <b>constexpr</b> T value = v;
  typedef T value_type;
  typedef integral_constant type;
};
</pre></blockquote>

<p>
[Footnote] It turns out <tt>constexpr</tt> is part of the Tentatively Ready
resolution for <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1019">1019</a>.  I don't want to interfere with that issue, but
would like a new issue to consider if the fixed-base enum implementation
should be allowed.
</p>

<p><i>[
2009-09-05 Daniel adds:
]</i></p>


<blockquote>
<p>
I think that the suggested resolution is incomplete and
may have some possible unwanted side-effects. To understand
why, note that <tt>integral_constant</tt> is <em>completely</em> specified
by code in 20.6.3 [meta.help]. While this is usually considered
as a good thing, let me give a possible user-defined
specialization that would break given the suggested changes:
</p>

<blockquote><pre>enum NodeColor { Red, Black };

std::integral_constant&lt;NodeColor, Red&gt; red;
</pre></blockquote>

<p>
The reason why that breaks is due to the fact that
current core language rules does only allow integral
types as enum-bases, see 7.2 [dcl.enum]/2.
</p>

<p>
So, I think that we cannot leave the implementation the
freedom to decide which way they would like to provide
the implementation, because that is easily user-visible
(I don't speak of addresses, but of instantiation errors),
therefore if applied, this should be either specified or
wording must be added that gives a note about this
freedom of implementation.
</p>

<p>
Another possible disadvantage seems to me that user-expectations
are easy to disappoint if they see a failure
of the test
</p>

<blockquote><pre>assert(typeid(std::integral_constant&lt;int, 0&gt;::value) == typeid(int));
</pre></blockquote>

<p>
or of
</p>

<blockquote><pre>static_assert(std::is_same&lt;decltype(std::integral_constant&lt;int, 0&gt;::value), const int&gt;::value, "Bad library");
</pre></blockquote>

</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1204"></a>1204. Global permission to move</h3>
<p><b>Section:</b> 17.6.3.9 [res.on.arguments] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-09-12  <b>Last modified:</b> 2009-10-20</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
When a library function binds an rvalue reference parameter to an argument, the
library must be able to assume that the bound argument is a temporary, and not
a moved-from lvalue.  The reason for this is that the library function must be
able to modify that argument without concern that such modifications will corrupt
the logic of the calling code.  For example:
</p>

<blockquote><pre>template &lt;class T, class A&gt;
void
vector&lt;T, A&gt;::push_back(value_type&amp;&amp; v)
{
    <font color="#c80000">// This function should move from v, potentially modifying</font>
    <font color="#c80000">//   the object v is bound to.</font>
}
</pre></blockquote>

<p>
If <tt>v</tt> is truly bound to a temporary, then <tt>push_back</tt> has the
<em>only</em> reference to this temporary in the entire program.  Thus any
modifications will be invisible to the rest of the program.
</p>

<p>
If the client supplies <tt>std::move(x)</tt> to <tt>push_back</tt>, the onus is
on the client to ensure that the value of <tt>x</tt> is no longer important to
the logic of his program after this statement.  I.e. the client is making a statement
that <tt>push_back</tt> may treat <tt>x</tt> as a temporary.
</p>

<blockquote><em>
The above statement is the very foundation upon which move semantics is based.
</em></blockquote>

<p>
The standard is currently lacking a global statement to this effect.  I propose
the following addition to 17.6.3.9 [res.on.arguments]:
</p>

<blockquote>
<p>
Each of the following statements applies to all arguments to functions
defined in the C++ standard library, unless explicitly stated otherwise.
</p>
<ul>
<li>
If an argument to a function has an invalid value (such as a value
outside the domain of the function, or a pointer invalid for its
intended use), the behavior is undefined.
</li>
<li>
If a function argument is described as being an array, the pointer
actually passed to the function shall have a value such that all address
computations and accesses to objects (that would be valid if the pointer
did point to the first element of such an array) are in fact valid.
</li>
<li><ins>
If a function argument binds to an rvalue reference parameter, the C++
standard library may assume that this parameter is a unique reference
to this argument.  If the parameter is a generic parameter of the
form <tt>T&amp;&amp;</tt>, and an lvalue of type <tt>A</tt> is bound,
then the binding is considered to be to an lvalue reference
(14.9.2.1 [temp.deduct.call]) and thus not covered by this clause.
[<i>Note:</i>
If a program casts an lvalue to an rvalue while passing that lvalue to
a library function (e.g. <tt>move(x)</tt>), then the program is effectively
asking the library to treat that lvalue as a temporary.  The library is at
liberty to optimize away aliasing checks which might be needed if the argument
were an lvalue.
&#8212; <i>end note</i>]
</ins></li>
</ul>

</blockquote>

<p>
Such a global statement will eliminate the need for piecemeal statements such as
23.2.1 [container.requirements.general]/13:
</p>

<blockquote>
An object bound to an rvalue reference parameter of a member function of
a container shall not be an element of that container; no diagnostic
required.
</blockquote>

<p>
Additionally this clarifies that move assignment operators need not perform the
traditional <tt>if (this != &amp;rhs)</tt> test commonly found (and needed) in
copy assignment operators.
</p>

<p><i>[
2009-09-13 Niels adds:
]</i></p>


<blockquote>
Note: This resolution supports the change of 27.9.1.3 [filebuf.assign]/1,
proposed by LWG <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#900">900</a>.
</blockquote>

<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote>
Move to Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add a bullet to 17.6.3.9 [res.on.arguments]:
</p>

<blockquote>
<p>
Each of the following statements applies to all arguments to functions
defined in the C++ standard library, unless explicitly stated otherwise.
</p>
<ul>
<li>
If an argument to a function has an invalid value (such as a value
outside the domain of the function, or a pointer invalid for its
intended use), the behavior is undefined.
</li>
<li>
If a function argument is described as being an array, the pointer
actually passed to the function shall have a value such that all address
computations and accesses to objects (that would be valid if the pointer
did point to the first element of such an array) are in fact valid.
</li>
<li><ins>
If a function argument binds to an rvalue reference parameter, the C++
standard library may assume that this parameter is a unique reference
to this argument.  If the parameter is a generic parameter of the
form <tt>T&amp;&amp;</tt>, and an lvalue of type <tt>A</tt> is bound,
then the binding is considered to be to an lvalue reference
(14.9.2.1 [temp.deduct.call]) and thus not covered by this clause.
[<i>Note:</i>
If a program casts an lvalue to an rvalue while passing that lvalue to
a library function (e.g. <tt>move(x)</tt>), then the program is effectively
asking the library to treat that lvalue as a temporary.  The library is at
liberty to optimize away aliasing checks which might be needed if the argument
were an lvalue.
&#8212; <i>end note</i>]
</ins></li>
</ul>
</blockquote>

<p>
Delete 23.2.1 [container.requirements.general]/13:
</p>

<blockquote><del>
An object bound to an rvalue reference parameter of a member function of
a container shall not be an element of that container; no diagnostic
required.
</del></blockquote>






<hr>
<h3><a name="1205"></a>1205. Some algorithms could more clearly document their handling of empty ranges</h3>
<p><b>Section:</b> 25 [algorithms] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-09-13  <b>Last modified:</b> 2009-09-13</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#algorithms">active issues</a> in [algorithms].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#algorithms">issues</a> in [algorithms].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There are a number of algorithms whose result might depend on the
handling of an empty range.  In some cases the result is not clear,
while in others it would help readers to clearly mention the result
rather than require some subtle intuition of the supplied wording.
</p>

<p>
25.2.1 [alg.all_of]
</p>

<blockquote>
<i>Returns:</i> <tt>true</tt> if <tt>pred(*i)</tt> is <tt>true</tt> for every
iterator <tt>i</tt> in the range <tt>[first,last)</tt>, ...
</blockquote>

<p>
What does this mean if the range is empty?
</p>

<p>
I believe that we intend this to be <tt>true</tt> and suggest a
non-normative note to clarify:
</p>

<p>
Add to p1 25.2.1 [alg.all_of]:
</p>

<blockquote>
[<i>Note:</i> Returns <tt>true</tt> if <tt>[first,last)</tt> is empty. 
&#8212; <i>end note</i>]
</blockquote>

<p>
25.2.3 [alg.none_of]
</p>

<blockquote>
<i>Returns:</i> <tt>true</tt> if <tt>pred(*i)</tt> is <tt>false</tt> for every
iterator <tt>i</tt> in the range <tt>[first,last)</tt>, ...
</blockquote>

<p>
What does this mean if the range empty?
</p>

<p>
I believe that we intend this to be <tt>true</tt> and suggest a
non-normative note to clarify:
</p>

<p>
Add to p1 25.2.3 [alg.none_of]:
</p>

<blockquote>
[<i>Note:</i> Returns <tt>true</tt> if <tt>[first,last)</tt> is empty. 
&#8212; <i>end note</i>]
</blockquote>

<p>
25.2.2 [alg.any_of]
</p>

<p>
The specification for an empty range is actually fairly clear in this
case, but a note wouldn't hurt and would be consistent with proposals
for <tt>all_of</tt>/<tt>none_of</tt> algorithms.
</p>

<p>
Add to p1 25.2.2 [alg.any_of]:
</p>

<blockquote>
[<i>Note:</i> Returns <tt>false</tt> if <tt>[first,last)</tt> is empty. 
&#8212; <i>end note</i>]
</blockquote>

<p>
25.2.6 [alg.find.end]
</p>

<p>
what does this mean if <tt>[first2,last2)</tt> is empty?
</p>

<p>
I believe the wording suggests the algorithm should return
<tt>last1</tt> in this case, but am not 100% sure. Is this in fact the
correct result anyway? Surely an empty range should always match and the
naive expected result would be <tt>first1</tt>?
</p>

<p>
My proposed wording is a note to clarify the current semantic:
</p>

<p>
Add to p2 25.2.6 [alg.find.end]:
</p>

<blockquote>
[<i>Note:</i> Returns <tt>last1</tt> if <tt>[first2,last2)</tt> is
empty. &#8212; <i>end note</i>]
</blockquote>

<p>
I would prefer a normative wording treating empty ranges specially, but
do not believe we can change semantics at this point in the process,
unless existing implementations actually yield this result:
</p>

<p>
Alternative wording: (NOT a note)
</p>
<p>
Add to p2 25.2.6 [alg.find.end]:
</p>
<blockquote>
Returns <tt>first1</tt> if <tt>[first2,last2)</tt> is empty.
</blockquote>

<p>
25.2.7 [alg.find.first.of]
</p>

<p>
The phrasing seems precise when <tt>[first2, last2)</tt> is empty, but a small
note to confirm the reader's understanding might still help.
</p>

<p>
Add to p2 25.2.7 [alg.find.first.of]
</p>
<blockquote>
[<i>Note:</i> Returns <tt>last1</tt> if <tt>[first2,last2)</tt> is
empty. &#8212; <i>end note</i>]
</blockquote>

<p>
25.2.12 [alg.search]
</p>

<p>
What is the expected result if <tt>[first2, last2)</tt> is empty?
</p>

<p>
I believe the wording suggests the algorithm should return <tt>last1</tt> in this
case, but am not 100% sure. Is this in fact the correct result anyway? 
Surely an empty range should always match and the naive expected result
would be <tt>first1</tt>?
</p>

<p>
My proposed wording is a note to clarify the current semantic:
</p>

<p>
Add to p2 25.2.12 [alg.search]:
</p>

<blockquote>
[<i>Note:</i> Returns <tt>last1</tt> if <tt>[first2,last2)</tt> is
empty. &#8212; <i>end note</i>]
</blockquote>

<p>
Again, I would prefer a normative wording treating empty ranges
specially, but do not believe we can change semantics at this point in
the process, unless existing implementations actually yield this result:
</p>

<p>
Alternative wording: (NOT a note)
</p>
<p>
Add to p2 25.2.12 [alg.search]:
</p>

<blockquote>
Returns <tt>first1</tt> if <tt>[first2,last2)</tt> is empty.
</blockquote>

<p>
25.3.13 [alg.partitions]
</p>

<p>
Is an empty range partitioned or not?
</p>

<p>
Proposed wording:
</p>

<p>
Add to p1 25.3.13 [alg.partitions]:
</p>

<blockquote>
[<i>Note:</i> Returns <tt>true</tt> if <tt>[first,last)</tt> is empty. 
&#8212; <i>end note</i>]
</blockquote>

<p>
25.4.5.1 [includes]
</p>

<blockquote>
<i>Returns:</i> <tt>true</tt> if every element in the range
<tt>[first2,last2)</tt> is contained in the range
<tt>[first1,last1)</tt>. ...
</blockquote>

<p>
I really don't know what this means if <tt>[first2,last2)</tt> is empty.
I could loosely guess that this implies empty ranges always match, and
my proposed wording is to clarify exactly that:
</p>

<p>
Add to p1 25.4.5.1 [includes]:
</p>

<blockquote>
[<i>Note:</i> Returns <tt>true</tt> if <tt>[first2,last2)</tt> is empty.
&#8212; <i>end note</i>]
</blockquote>

<p>
25.4.6.2 [pop.heap]
</p>

<p>
The effects clause is invalid if the range <tt>[first,last)</tt> is empty, unlike
all the other heap alogorithms.  The should be called out in the
requirements.
</p>

<p>
Proposed wording:
</p>
<p>
Revise p2 25.4.6.2 [pop.heap]
</p>

<blockquote>
<i>Requires:</i> The range <tt>[first,last)</tt> shall be a valid
<ins>non-empty</ins> heap.
</blockquote>

<p>
[Editorial] Reverse order of 25.4.6.2 [pop.heap] p1 and p2.
</p>

<p>
25.4.7 [alg.min.max]
</p>

<p>
<tt>minmax_element</tt> does not clearly specify behaviour for an empty
range in the same way that <tt>min_element</tt> and <tt>max_element</tt> do.
</p>

<p>
Add to p31 25.4.7 [alg.min.max]:
</p>

<blockquote>
Returns <tt>make_pair(first, first)</tt> if <tt>first == last</tt>.
</blockquote>

<p>
25.4.8 [alg.lex.comparison]
</p>

<p>
The wording here seems quite clear, especially with the sample algorithm
implementation.  A note is recommended purely for consistency with the
rest of these issue resolutions:
</p>

<p>
Add to p1 25.4.8 [alg.lex.comparison]:
</p>

<blockquote>
[<i>Note:</i> An empty sequence is lexicographically less than any other
non-empty sequence, but not to another empty sequence. &#8212; <i>end note</i>]
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Add to p1 25.2.1 [alg.all_of]:
</p>
<blockquote>
[<i>Note:</i> Returns <tt>true</tt> if <tt>[first,last)</tt> is empty. 
&#8212; <i>end note</i>]
</blockquote>

<p>
Add to p1 25.2.2 [alg.any_of]:
</p>
<blockquote>
[<i>Note:</i> Returns <tt>false</tt> if <tt>[first,last)</tt> is empty. 
&#8212; <i>end note</i>]
</blockquote>

<p>
Add to p1 25.2.3 [alg.none_of]:
</p>
<blockquote>
[<i>Note:</i> Returns <tt>true</tt> if <tt>[first,last)</tt> is empty. 
&#8212; <i>end note</i>]
</blockquote>

<p>
Add to p2 25.2.6 [alg.find.end]:
</p>
<blockquote>
[<i>Note:</i> Returns <tt>last1</tt> if <tt>[first2,last2)</tt> is
empty.  &#8212; <i>end note</i>]
</blockquote>

<p>
Add to p2 25.2.7 [alg.find.first.of]
</p>
<blockquote>
[<i>Note:</i> Returns <tt>last1</tt> if <tt>[first2,last2)</tt> is
empty.  &#8212; <i>end note</i>]
</blockquote>

<p>
Add to p2 25.2.12 [alg.search]:
</p>
<blockquote>
[<i>Note:</i> Returns <tt>last1</tt> if <tt>[first2,last2)</tt> is
empty.  &#8212; <i>end note</i>]
</blockquote>

<p>
Add to p1 25.3.13 [alg.partitions]:
</p>
<blockquote>
[<i>Note:</i> Returns <tt>true</tt> if <tt>[first,last)</tt> is empty. 
&#8212; <i>end note</i>]
</blockquote>

<p>
Add to p1 25.4.5.1 [includes]:
</p>
<blockquote>
[<i>Note:</i> Returns <tt>true</tt> if <tt>[first2,last2)</tt> is empty. 
&#8212; <i>end note</i>]
</blockquote>

<p>
Revise p2 25.4.6.2 [pop.heap]
</p>
<blockquote>
Requires: The range <tt>[first,last)</tt> shall be a valid
<ins>non-empty</ins> heap.
</blockquote>

<p>
[Editorial] 
</p>
<blockquote>
Reverse order of 25.4.6.2 [pop.heap] p1 and p2.
</blockquote>

<p>
Add to p31 25.4.7 [alg.min.max]:
</p>
<blockquote>
Returns <tt>make_pair(first, first)</tt> if <tt>first == last</tt>.
</blockquote>

<p>
Add to p1 25.4.8 [alg.lex.comparison]:
</p>
<blockquote>
[<i>Note:</i> An empty sequence is lexicographically less than any other
non-empty sequence, but not less than another empty sequence. &#8212;
<i>end note</i>]
</blockquote>






<hr>
<h3><a name="1206"></a>1206. Incorrect requires for <tt>move_backward</tt> and <tt>copy_backward</tt></h3>
<p><b>Section:</b> 25.3.2 [alg.move] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-09-13  <b>Last modified:</b> 2009-09-13</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
25.3.2 [alg.move], p6 says:
</p>

<blockquote>
<pre>template&lt;class BidirectionalIterator1, class BidirectionalIterator2&gt;
  BidirectionalIterator2
    move_backward(BidirectionalIterator1 first,
                  BidirectionalIterator1 last,
                  BidirectionalIterator2 result);
</pre>
<blockquote>
<p>...</p>
<p>
<i>Requires:</i> <tt>result</tt> shall not be in the range
<tt>[first,last)</tt>.
</p>
</blockquote>
</blockquote>

<p>
This is essentially an "off-by-one" error.
</p>

<p>
When <tt>result == last</tt>, which
<em>is</em> allowed by this specification, then the range <tt>[first, last)</tt>
is being move assigned into the range <tt>[first, last)</tt>.  The <tt>move</tt>
(forward) algorithm doesn't allow self move assignment, and neither should
<tt>move_backward</tt>.  So <tt>last</tt> should be included in the range which
<tt>result</tt> can not be in.
</p>

<p>
Conversely, when <tt>result == first</tt>, which <em>is not</em> allowed by this
specification, then the range <tt>[first, last)</tt>
is being move assigned into the range <tt>[first - (last-first), first)</tt>.
I.e. into a <em>non-overlapping</em> range.  Therefore <tt>first</tt> should
not be included in the range which <tt>result</tt> can not be in.
</p>

<p>
The same argument applies to <tt>copy_backward</tt> though copy assigning elements
to themselves (<tt>result == last</tt>) should be harmless (though is disallowed
by <tt>copy</tt>).
</p>



<p><b>Proposed resolution:</b></p>
<p>
Change 25.3.2 [alg.move], p6:
</p>

<blockquote>
<pre>template&lt;class BidirectionalIterator1, class BidirectionalIterator2&gt;
  BidirectionalIterator2
    move_backward(BidirectionalIterator1 first,
                  BidirectionalIterator1 last,
                  BidirectionalIterator2 result);
</pre>
<blockquote>
<p>...</p>
<p>
<i>Requires:</i> <tt>result</tt> shall not be in the range
<tt><del>[</del><ins>(</ins>first,last<ins>]</ins><del>)</del></tt>.
</p>
</blockquote>
</blockquote>

<p>
Change 25.3.1 [alg.copy], p13:
</p>

<blockquote>
<pre>template&lt;class BidirectionalIterator1, class BidirectionalIterator2&gt;
  BidirectionalIterator2
    copy_backward(BidirectionalIterator1 first,
                  BidirectionalIterator1 last,
                  BidirectionalIterator2 result);
</pre>
<blockquote>
<p>...</p>
<p>
<i>Requires:</i> <tt>result</tt> shall not be in the range
<tt><del>[</del><ins>(</ins>first,last<ins>]</ins><del>)</del></tt>.
</p>
</blockquote>
</blockquote>





<hr>
<h3><a name="1207"></a>1207. Underspecified std::list operations?</h3>
<p><b>Section:</b> 23.3.4.4 [list.ops] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Loc Joly <b>Opened:</b> 2009-09-13  <b>Last modified:</b> 2009-09-19</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#list.ops">active issues</a> in [list.ops].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#list.ops">issues</a> in [list.ops].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It looks to me like some operations of <tt>std::list</tt>
(<tt>sort</tt>, <tt>reverse</tt>, <tt>remove</tt>, <tt>unique</tt> &amp;
<tt>merge</tt>) do not specify the validity of iterators, pointers &amp;
references to elements of the list after those operations. Is it implied
by some other text in the standard?
</p>

<p>
I believe <tt>sort</tt> &amp; <tt>reverse</tt> do not invalidating
anything, <tt>remove</tt> &amp; <tt>unique</tt> only invalidates what
refers to erased elements, <tt>merge</tt> does not invalidate anything
(with the same precision as <tt>splice</tt> for elements who changed of
container). Are those assumptions correct ?
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1208"></a>1208. valarray initializer_list constructor has incorrect effects</h3>
<p><b>Section:</b> 26.6.2.1 [valarray.cons] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-09-23  <b>Last modified:</b> 2009-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#valarray.cons">issues</a> in [valarray.cons].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
26.6.2.1 [valarray.cons] says:
</p>

<blockquote>
<pre>valarray(initializer_list&lt;T&gt; il);
</pre>
<blockquote>
<i>Effects:</i> Same as <tt>valarray(il.begin(), il.end())</tt>.
</blockquote>
</blockquote>

<p>
But there is no <tt>valarray</tt> constructor taking two <tt>const T*</tt>.
</p>

<p><i>[
2009-10-29 Howard:
]</i></p>


<blockquote>
Moved to Tentatively Ready after 6 positive votes on c++std-lib.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 26.6.2.1 [valarray.cons]:
</p>

<blockquote>
<pre>valarray(initializer_list&lt;T&gt; il);
</pre>
<blockquote>
<i>Effects:</i> Same as <tt>valarray(il.begin(), il.<del>end</del><ins>size</ins>())</tt>.
</blockquote>
</blockquote>





<hr>
<h3><a name="1209"></a>1209. match_results should be moveable</h3>
<p><b>Section:</b> 28.10.1 [re.results.const] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2009-09-15  <b>Last modified:</b> 2009-09-21</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In Working Draft
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2914.pdf">N2914</a>,
<tt>match_results</tt> lacks a move constructor and move
assignment operator. Because it owns dynamically allocated memory, it
should be moveable.
</p>

<p>
As far as I can tell, this isn't tracked by an active issue yet; Library
Issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#723">723</a> doesn't talk about <tt>match_results</tt>.
</p>

<p><i>[
2009-09-21 Daniel provided wording.
]</i></p>



<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>
Add the following member declarations to 28.10 [re.results]/3:
</p>

<blockquote><pre>// 28.10.1, construct/copy/destroy:
explicit match_results(const Allocator&amp; a = Allocator());
match_results(const match_results&amp; m);
<ins>match_results(match_results&amp;&amp; m);</ins>
match_results&amp; operator=(const match_results&amp; m);
<ins>match_results&amp; operator=(match_results&amp;&amp; m);</ins>
~match_results();
</pre></blockquote>
</li>

<li>
<p>
Add the following new prototype descriptions to 28.10.1 [re.results.const]
using the table numbering of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2723.pdf">N2723</a>:
</p>

<blockquote>
<pre>match_results(const match_results&amp; m);
</pre>

<blockquote>
4 <i>Effects:</i> Constructs an object of class <tt>match_results</tt>, as a
copy of <tt>m</tt>.
</blockquote>

<pre><ins>match_results(match_results&amp;&amp; m);</ins>
</pre>

<blockquote>
<p>
<ins>5 <i>Effects:</i> Move-constructs an object of class <tt>match_results</tt>
from <tt>m</tt> satisfying the same postconditions as Table 132. Additionally
the stored <tt>Allocator</tt> value is move constructed from <tt>m.get_allocator()</tt>.
After the initialization of <tt>*this</tt> sets <tt>m</tt> to an unspecified but valid
state.</ins>
</p>

<p>
<ins>6 <i>Throws:</i> Nothing if the allocator's move constructor throws nothing.</ins>
</p>
</blockquote>

<pre>match_results&amp; operator=(const match_results&amp; m);
</pre>

<blockquote>
7 <i>Effects:</i> Assigns <tt>m</tt> to <tt>*this</tt>. The postconditions of this function are
indicated in Table 132.
</blockquote>

<pre><ins>match_results&amp; operator=(match_results&amp;&amp; m);</ins>
</pre>

<blockquote>
<p>
<ins>8 <i>Effects:</i> Move-assigns <tt>m</tt> to <tt>*this</tt>. The postconditions of this
function are indicated in Table 132. After the assignment, <tt>m</tt> is in
a valid but unspecified state.</ins>
</p>

<p>
<ins>9 <i>Throws:</i> Nothing.</ins>
</p>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="1210"></a>1210. iterator reachability should not require a container</h3>
<p><b>Section:</b> 24.2 [iterator.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-09-18  <b>Last modified:</b> 2009-09-19</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#iterator.requirements">active issues</a> in [iterator.requirements].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#iterator.requirements">issues</a> in [iterator.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
p6 Iterator requirements 24.2 [iterator.requirements]
</p>

<blockquote>
An iterator <tt>j</tt> is called reachable from an iterator <tt>i</tt> if and only if
there is a finite sequence of applications of the expression <tt>++i</tt> that
makes <tt>i == j</tt>. If <tt>j</tt> is reachable from <tt>i</tt>, they refer to the same
container.
</blockquote>

<p>
A good example would be stream iterators, which do not refer to a
container.  Typically, the end iterator from a range of stream iterators
will compare equal for many such ranges.  I suggest striking the second
sentence.
</p>

<p>
An alternative wording might be:
</p>

<blockquote>
If <tt>j</tt> is reachable from <tt>i</tt>, and both <tt>i</tt> and
<tt>j</tt> are dereferencable iterators, then they refer to the same
range.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 24.2 [iterator.requirements], p6:
</p>

<blockquote>
An iterator <tt>j</tt> is called <i>reachable</i> from an iterator
<tt>i</tt> if and only if there is a finite sequence of applications of
the expression <tt>++i</tt> that makes <tt>i == j</tt>. <del>If
<tt>j</tt> is reachable from <tt>i</tt>, they refer to the same
container.</del>
</blockquote>





<hr>
<h3><a name="1211"></a>1211. move iterators should be restricted as input iterators</h3>
<p><b>Section:</b> 24.5.3.1 [move.iterator] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-09-18  <b>Last modified:</b> 2009-10-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#move.iterator">issues</a> in [move.iterator].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I contend that while we can support both bidirectional and random access
traversal, the category of a move iterator should never be better than
<tt>input_iterator_tag</tt>.
</p>

<p>
The contentious point is that you cannot truly have a multipass property
when values are moved from a range.  This is contentious if you view a
moved-from object as still holding a valid value within the range.  
</p>

<p>
The second reason comes from the Forward Iterator requirements table:
</p>

<blockquote>
<p>
Forward iterators 24.2.3 [forward.iterators]
</p>

<p>
Table 102 -- Forward iterator requirements
</p>

<blockquote>
For expression <tt>*a</tt> the return type is:
"<tt>T&amp;</tt> if <tt>X</tt> is mutable, otherwise <tt>const T&amp;</tt>"
</blockquote>
</blockquote>

<p>
There is a similar constraint on <tt>a-&gt;m</tt>.
</p>

<p>
There is no support for rvalue references, nor do I believe their should
be.  Again, opinions may vary but either this table or the definition of
<tt>move_iterator</tt> need updating.
</p>

<p>
Note: this requirement probably need updating anyway if we wish to
support proxy iterators but I am waiting to see a new working paper
before filing that issue.
</p>

<p><i>[
2009-10 post-Santa Cruz:
]</i></p>


<blockquote>
Move to Open. Howard to put his rationale mentioned above into the issue
as a note.
</blockquote>

<p><i>[
2009-10-26 Howard adds:
]</i></p>


<blockquote>
<p>
<tt>vector::insert(pos, iter, iter)</tt> is significantly more effcient when
<tt>iter</tt> is a random access iterator, as compared to when it is an
input iterator.
</p>

<p>
When <tt>iter</tt> is an input iterator, the best algorithm
is to append the inserted range to the end of the <tt>vector</tt> using
<tt>push_back</tt>.  This may involve several reallocations before the input
range is exhausted.  After the append, then one can use <tt>std::rotate</tt>
to place the inserted range into the correct position in the vector.
</p>

<p>
But when <tt>iter</tt> is a random access iterator, the best algorithm
is to first compute the size of the range to be inserted (<tt>last - first</tt>),
do a buffer reallocation if necessary, scoot existing elements in the <tt>vector</tt>
down to make the "hole", and then insert the new elements directly to their correct
place.
</p>

<blockquote><b>
The insert-with-random-access-iterators algorithm is considerably more efficient
than the insert-with-input-iterators algorithm
</b></blockquote>

<p>
Now consider:
</p>

<blockquote><pre>vector&lt;A&gt; v;
<font color="#c80000">//  ... build up a large vector of A ...</font>
vector&lt;A&gt; temp;
<font color="#c80000">//  ... build up a large temporary vector of A to later be inserted ...</font>
typedef move_iterator&lt;vector&lt;A&gt;::iterator&gt; MI;
<font color="#c80000">//  Now insert the temporary elements:</font>
v.insert(v.begin() + N, MI(temp.begin()), MI(temp.end()));
</pre></blockquote>

<p>
A major motivation for using <tt>move_iterator</tt> in the above example is the
expectation that <tt>A</tt> is cheap to move but expensive to copy.  I.e. the
customer is looking for <em>high performance</em>.  If we allow <tt>vector::insert</tt>
to subtract two <tt>MI</tt>'s to get the distance between them, the customer enjoys
substantially better performance, compared to if we say that <tt>vector::insert</tt>
can not subtract two <tt>MI</tt>'s.
</p>

<p>
I can find no rationale for not giving this performance boost to our customers.
Therefore I am strongly against restricting <tt>move_iterator</tt> to the
<tt>input_iterator_tag</tt> category.
</p>

<p>
I believe that the requirement that forward
iterators have a dereference that returns an lvalue reference to cause unacceptable
pessimization.  For example <tt>vector&lt;bool&gt;::iterator</tt> also does not return
a <tt>bool&amp;</tt> on dereference.  Yet I am not aware of a single vendor that
is willing to ship <tt>vector&lt;bool&gt;::iterator</tt> as an input iterator.
Everyone classifies it as a random access iterator.  Not only does this not
cause any problems, it prevents significant performance problems.
</p>

</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Class template move_iterator 24.5.3.1 [move.iterator]
</p>

<blockquote><pre>namespace std {
template &lt;class Iterator&gt;
class move_iterator {
public:
 ...
 typedef <del>typename iterator_traits&lt;Iterator&gt;::iterator_category</del> <ins>input_iterator_tag</ins> iterator_category;
</pre></blockquote>





<hr>
<h3><a name="1212"></a>1212. result of post-increment/decrement operator</h3>
<p><b>Section:</b> 24.2 [iterator.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-09-18  <b>Last modified:</b> 2009-09-19</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#iterator.requirements">active issues</a> in [iterator.requirements].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#iterator.requirements">issues</a> in [iterator.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>Forward iterator and bidirectional iterator place different
requirements on the result of post-increment/decrement operator. The
same form should be used in each case.
</p>

<p>
Merging row from:
</p>

<blockquote><pre>Table 102 -- Forward iterator requirements
Table 103 -- Bidirectional iterator requirements

    r++ : convertible to const X&amp;
    r-- : convertible to const X&amp;
    
    *r++ : T&amp; if X is mutable, otherwise const T&amp;
    *r-- : convertible to T
</pre></blockquote>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1213"></a>1213. Meaning of valid and singular iterator underspecified</h3>
<p><b>Section:</b> 24.2 [iterator.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2009-09-19  <b>Last modified:</b> 2009-09-19</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#iterator.requirements">active issues</a> in [iterator.requirements].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#iterator.requirements">issues</a> in [iterator.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The terms <em>valid</em> iterator and <em>singular</em> aren't
properly defined. The fuzziness of those terms became even worse
after the resolution of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#208">208</a> (including further updates by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#278">278</a>). In
24.2 [iterator.requirements] as of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2723.pdf">N2723</a>
the standard says now:
</p>

<blockquote>
<p>
5 - These values are called past-the-end values. Values of an iterator <tt>i</tt> for
which the expression <tt>*i</tt> is defined are called dereferenceable. The library
never assumes that past-the-end values are dereferenceable. Iterators
can also have singular values that are not associated with any
container. [...] Results of most expressions are undefined for singular
values; the only exceptions are destroying an iterator that holds a
singular value and the assignment of a non-singular value to an iterator
that holds a singular value. [...] Dereferenceable values are always
non-singular.
</p>

<p>
10 - An invalid iterator is an iterator that may be singular.
</p>
</blockquote>

<p>
First, issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#208">208</a> intentionally removed the earlier constraint that past-the-end
values are always non-singular. The reason for this was to support null
pointers as past-the-end iterators of e.g. empty sequences. But there
seem to exist different views on what a singular (iterator) value is. E.g.
according to the <a href="http://www.sgi.com/tech/stl/trivial.html">SGI definition</a>
a null pointer is <em>not</em> a singular value:
</p>

<blockquote>
Dereferenceable iterators are always nonsingular, but the converse is
not true.
For example, a null pointer is nonsingular (there are well defined operations
involving null pointers) even thought it is not dereferenceable.
</blockquote>

<p>
and <a href="http://www.sgi.com/tech/stl/InputIterator.html">proceeds</a>:
</p>

<blockquote>
An iterator is valid if it is dereferenceable or past-the-end.
</blockquote>

<p>
Even if the standard prefers a different meaning of singular here, the
change was
incomplete, because by restricting feasible expressions of singular
iterators to
destruction and assignment isn't sufficient for a past-the-end
iterator: Of-course
it must still be equality-comparable and in general be a readable value.
</p>

<p>
Second, the standard doesn't clearly say whether a past-the-end value is
a valid iterator or not. E.g. 20.8.13 [specialized.algorithms]/1 says:
</p>

<blockquote>
In all of the following algorithms, the formal template parameter
<tt>ForwardIterator</tt>
is required to satisfy the requirements of a forward iterator (24.1.3)
[..], and is
required to have the property that no exceptions are thrown from [..], or
dereference of valid iterators.
</blockquote>

<p>
The standard should make better clear what "singular pointer" and "valid
iterator" means. The fact that the meaning of a valid <em>value</em>
has a core language meaning doesn't imply that for an iterator concept
the term "valid iterator" has the same meaning.
</p>

<p>
Let me add a final example: In X [allocator.concepts.members] of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2914.pdf">N2914</a>
we find:
</p>

<blockquote><pre>pointer X::allocate(size_type n);
</pre>

<blockquote>
11 <i>Returns:</i> a pointer to the allocated memory. [<i>Note:</i> if <tt>n == 0</tt>, the return
value is unspecified. &#8212;<i>end note</i>]
</blockquote>

<p>
[..]
</p>

<pre>void X::deallocate(pointer p, size_type n);
</pre>

<blockquote>
<i>Preconditions:</i> <tt>p</tt> shall be a non-singular pointer value obtained from a call
to <tt>allocate()</tt> on this allocator or one that compares equal to it.
</blockquote>
</blockquote>

<p>
If singular pointer value would include null pointers this make the
preconditions
unclear if the pointer value is a result of <tt>allocate(0)</tt>: Since the return value
is unspecified, it could be a null pointer. Does that mean that programmers
need to check the pointer value for a null value before calling deallocate?
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1214"></a>1214. Insufficient/inconsistent key immutability requirements for  associative containers</h3>
<p><b>Section:</b> 23.2.4 [associative.reqmts] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2009-09-20  <b>Last modified:</b> 2009-09-20</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#associative.reqmts">active issues</a> in [associative.reqmts].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#associative.reqmts">issues</a> in [associative.reqmts].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Scott Meyers' mentions on a recent posting on <a href="http://groups.google.de/group/comp.std.c++/msg/6f9160fc428bcbea">c.s.c++</a>
some arguments that point to an incomplete resolution
of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#103">103</a> and to an inconsistency of requirements on keys in ordered and
unordered associative
containers:
</p>

<blockquote>
<p>
1) <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#103">103</a> introduced the term immutable without defining it in a unique manner in
23.2.4 [associative.reqmts]/5:
</p>

<blockquote>
[..] Keys in an associative container are immutable.
</blockquote>

<p>
According to conventional dictionaries immutable is an unconditional way of
saying that something cannot be changed. So without any further explicit
allowance a user <em>always</em> runs into undefined behavior if (s)he attempts
to modify such a key. IMO this was not the intend of the committee to resolve
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#103">103</a> in that way because the comments suggest an interpretation that
should give any user the freedom to modify the key in an <em>explicit</em> way
<em>provided</em> it would not affect the sort order in that container.
</p>

<p>
2) Another observation was that surprisingly no similar 'safety guards'
exists against unintentional key changes for the unordered associative
containers, specifically there is no such requirement as in
23.2.4 [associative.reqmts]/6 that "both <tt>iterator</tt> and <tt>const_iterator</tt> are constant
iterators". But the need for such protection against unintentional
changes as well as the constraints in which manner any explicit
changes may be performed are both missing and necessary, because
such changes could potentially change the <em>equivalence</em> of keys that
is measured by the <tt>hasher</tt> and <tt>key_equal</tt>.
</p>

<p>
I suggest to fix the unconditional wording involved with "immutable keys"
by at least adding a hint for the reader that users <em>may</em> perform such
changes in an explicit manner <em>and</em> to perform similar wording changes
as <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#103">103</a> did for the ordered associative containers also for the unordered
containers.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1215"></a>1215. <tt>list::merge</tt> with unequal allocators</h3>
<p><b>Section:</b> 23.3.4.4 [list.ops] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Pablo Halpern <b>Opened:</b> 2009-09-24  <b>Last modified:</b> 2009-09-24</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#list.ops">active issues</a> in [list.ops].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#list.ops">issues</a> in [list.ops].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In Bellevue (I think), we passed
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2525.pdf">N2525</a>,
which, among other things, specifies that the behavior of
<tt>list::splice</tt> is undefined if the allocators of the two lists
being spliced do not compare equal. The same rationale should apply to
<tt>list::merge</tt>. The intent of <tt>list::merge</tt> (AFAIK) is to
move nodes from one sorted <tt>list</tt> into another sorted
<tt>list</tt> without copying the elements. This is possible only if the
allocators compare equal.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Relative to the August 2009 WP,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2857.pdf">N2857</a>,
change 23.3.4.4 [list.ops],
paragraphs 22-25 as follows:
</p>

<blockquote>
<pre>void merge(list&amp;&amp; x);
template &lt;class Compare&gt; void merge(list&amp;&amp; x, Compare comp);
</pre>
<blockquote>
<p>
<i>Requires</i>: both the list and the argument list shall be sorted
according to operator&lt; or comp.
</p>
<p>
<i>Effects</i>: If <tt>(&amp;x == this)</tt> does nothing; otherwise, merges the
two sorted ranges <tt>[begin(), end())</tt> and <tt>[x.begin(),
x.end())</tt>. The result is a range in which the elements will be
sorted in non-decreasing order according to the ordering defined by
<tt>comp</tt>; that is, for every iterator <tt>i</tt>, in the range other than the
<tt>first</tt>, the condition <tt>comp(*i, *(i - 1)<ins>)</ins></tt> will be
<tt>false</tt>.
</p>
<p>
<i>Remarks</i>: Stable. If <tt>(&amp;x != this)</tt> the range <tt>[x.begin(), x.end())</tt> is
empty after the merge. <ins>No elements are copied by this operation.
The behavior is undefined if <tt>this-&gt;get_allocator() !=
x.get_allocator()</tt>.</ins>
</p>
<p>
<i>Complexity</i>: At most <tt>size() + x.size() - 1</tt> applications of <tt>comp</tt>
if <tt>(&amp;x != this)</tt>; otherwise, no applications of <tt>comp</tt> are performed. If an
exception is thrown other than by a comparison there are no effects.
</p>
</blockquote>
</blockquote>





<hr>
<h3><a name="1216"></a>1216. LWG 1066 Incomplete?</h3>
<p><b>Section:</b> 18.8.6 [except.nested] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2009-09-25  <b>Last modified:</b> 2009-10-20</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#except.nested">active issues</a> in [except.nested].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#except.nested">issues</a> in [except.nested].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
LWG <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1066">1066</a> adds <tt>[[noreturn]]</tt> to a bunch of things.
It doesn't add it to <tt>rethrow_nested()</tt>, which seems like an obvious
candidate. I've made the changes indicated in the issue, and haven't
changed <tt>rethrow_nested()</tt>.
</p>

<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote>
Move to Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add <tt>[[noreturn]]</tt> to <tt>rethrow_nested()</tt> in 18.8.6 [except.nested].
</p>





<hr>
<h3><a name="1218"></a>1218. mutex destructor synchronization</h3>
<p><b>Section:</b> 30.4.1 [thread.mutex.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Jeffrey Yasskin <b>Opened:</b> 2009-09-30  <b>Last modified:</b> 2009-09-30</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#thread.mutex.requirements">active issues</a> in [thread.mutex.requirements].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.mutex.requirements">issues</a> in [thread.mutex.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
If an object <tt>*o</tt> contains a mutex <tt>mu</tt> and a
correctly-maintained reference count <tt>c</tt>, is the following code
safe?
</p>

<blockquote><pre>o-&gt;mu.lock();
bool del = (--(o-&gt;c) == 0);
o-&gt;mu.unlock();
if (del) { delete o; }
</pre></blockquote>

<p>
If the implementation of <tt>mutex::unlock()</tt> can touch the mutex's
memory after the moment it becomes free, this wouldn't be safe, and
"Construction and destruction of an object of a Mutex type need not be
thread-safe" 30.4.1 [thread.mutex.requirements] may imply that
it's not safe. Still, it's useful to allow mutexes to guard reference
counts, and if it's not allowed, users are likely to write bugs.
</p>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="1219"></a>1219. unique_lock::lock and resource_deadlock_would_occur</h3>
<p><b>Section:</b> 30.4.3.2.2 [thread.lock.unique.locking] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Jeffrey Yasskin <b>Opened:</b> 2009-09-30  <b>Last modified:</b> 2009-09-30</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#thread.lock.unique.locking">active issues</a> in [thread.lock.unique.locking].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.lock.unique.locking">issues</a> in [thread.lock.unique.locking].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>unique_lock::lock</tt> and friends raise
"<tt>resource_deadlock_would_occur</tt> -- if the current thread already
owns the mutex (i.e., on entry, <tt>owns</tt> is <tt>true</tt>)."  1)
The current thread owning a mutex is not the same as any particular
<tt>unique_lock::owns</tt> being <tt>true</tt>. 2) There's no need to
raise this exception for a <tt>recursive_mutex</tt> if <tt>owns</tt> is
<tt>false</tt>. 3) If <tt>owns</tt> is true, we need to raise some
exception or the unique_lock will lose track of whether to unlock itself
on destruction, but "deadlock" isn't it. For (3), s/bool owns/int
ownership_level/ would fix it.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1220"></a>1220. What does condition_variable wait on?</h3>
<p><b>Section:</b> 30.5 [thread.condition] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jeffrey Yasskin <b>Opened:</b> 2009-09-30  <b>Last modified:</b> 2009-11-06</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#thread.condition">active issues</a> in [thread.condition].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.condition">issues</a> in [thread.condition].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
"Class <tt>condition_variable</tt> provides a condition variable that can only
wait on an object of type <tt>unique_lock</tt>" should say "...object of type
<tt>unique_lock&lt;mutex&gt;</tt>"
</p>

<p><i>[
2009-11-06 Howard adds:
]</i></p>


<blockquote>
Moved to Tentatively Ready after 5 positive votes on c++std-lib.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 30.5 [thread.condition], p1:
</p>

<blockquote>
Condition variables provide synchronization primitives used to block a
thread until notified by some other thread that some condition is met or
until a system time is reached. Class <tt>condition_variable</tt>
provides a condition variable that can only wait on an object of type
<tt>unique_lock<ins>&lt;mutex&gt;</ins></tt>, allowing maximum
efficiency on some platforms. Class <tt>condition_variable_any</tt>
provides a general condition variable that can wait on objects of
user-supplied lock types.
</blockquote>





<hr>
<h3><a name="1221"></a>1221. condition_variable wording</h3>
<p><b>Section:</b> 30.5.1 [thread.condition.condvar] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Jeffrey Yasskin <b>Opened:</b> 2009-09-30  <b>Last modified:</b> 2009-09-30</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#thread.condition.condvar">active issues</a> in [thread.condition.condvar].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.condition.condvar">issues</a> in [thread.condition.condvar].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
30.5.1 [thread.condition.condvar] says:
</p>

<blockquote>
<pre>~condition_variable();
</pre>
<blockquote>
<i>Precondition:</i> There shall be no thread blocked on <tt>*this</tt>.
[<i>Note:</i> That is, all threads shall have been notified; they may
subsequently block on the lock specified in the wait. Beware that
destroying a <tt>condition_variable</tt> object while the corresponding
predicate is <tt>false</tt> is likely to lead to undefined behavior.
&#8212; <i>end note</i>]
</blockquote>
</blockquote>

<p>
The text hasn't introduced the notion of a "corresponding predicate"
yet.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1222"></a>1222. condition_variable incorrect effects for exception safety</h3>
<p><b>Section:</b> 30.5 [thread.condition] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Jeffrey Yasskin <b>Opened:</b> 2009-09-30  <b>Last modified:</b> 2009-09-30</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#thread.condition">active issues</a> in [thread.condition].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.condition">issues</a> in [thread.condition].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
30.5.1 [thread.condition.condvar] says:
</p>

<blockquote>
<pre>void wait(unique_lock&lt;mutex&gt;&amp; lock);
</pre>
<blockquote>
<p>...</p>
<p>
<i>Effects:</i>
</p>
<ul>
<li>...</li>
<li>
If the function exits via an exception, <tt>lock.unlock()</tt> shall be
called prior to exiting the function scope.
</li>
</ul>
</blockquote>
</blockquote>

<p>
Should that be <tt>lock.lock()</tt>?
</p>


<p><b>Proposed resolution:</b></p>

<p>
Change 30.5.1 [thread.condition.condvar] p10:
</p>

<blockquote>
<pre>void wait(unique_lock&lt;mutex&gt;&amp; lock);
</pre>
<blockquote>
<p>...</p>
<p>
<i>Effects:</i>
</p>
<ul>
<li>...</li>
<li>
If the function exits via an exception, <tt>lock.<del>un</del>lock()</tt> shall be
called prior to exiting the function scope.
</li>
</ul>
</blockquote>
</blockquote>

<p>
And make a similar change in p16, and in 30.5.2 [thread.condition.condvarany],
p8 and p13.
</p>






<hr>
<h3><a name="1223"></a>1223. condition_variable_any lock matching?</h3>
<p><b>Section:</b> 30.5.2 [thread.condition.condvarany] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Jeffrey Yasskin <b>Opened:</b> 2009-09-30  <b>Last modified:</b> 2009-09-30</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#thread.condition.condvarany">active issues</a> in [thread.condition.condvarany].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.condition.condvarany">issues</a> in [thread.condition.condvarany].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
For <tt>condition_variable_any</tt>, must all lock arguments to concurrent wait calls
"match" in some way, similar to the requirement in
30.5.1 [thread.condition.condvar] that <tt>lock.mutex()</tt> returns the same
value for each of the lock arguments supplied by all concurrently
waiting threads (via <tt>wait</tt> or <tt>timed_wait</tt>)?
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1224"></a>1224. condition_variable_any support for recursive mutexes?</h3>
<p><b>Section:</b> 30.5.2 [thread.condition.condvarany] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Jeffrey Yasskin <b>Opened:</b> 2009-09-30  <b>Last modified:</b> 2009-09-30</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#thread.condition.condvarany">active issues</a> in [thread.condition.condvarany].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.condition.condvarany">issues</a> in [thread.condition.condvarany].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
For <tt>condition_variable_any</tt>, are recursive mutexes allowed? (I think "no")
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1225"></a>1225. C++0x result_of issue </h3>
<p><b>Section:</b> 20.7.4 [func.ret] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Sebastian Gesemann <b>Opened:</b> 2009-10-05  <b>Last modified:</b> 2009-10-17</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#func.ret">issues</a> in [func.ret].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I think the text about <tt>std::result_of</tt> could be a little more precise.
Quoting from
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2960.pdf">N2960</a>...
</p>

<blockquote>
<p>
20.7.4 [func.ret] Function object return types
</p>

<pre>template&lt;class&gt; class result_of;

template&lt;class Fn, class... ArgTypes&gt;
class result_of&lt;Fn(ArgTypes...)&gt; {
public:
  typedef <i>see below</i> type;
};
</pre>

<p>
Given an rvalue <tt>fn</tt> of type <tt>Fn</tt> and values <tt>t1, t2,
..., tN</tt> of types <tt>T1, T2, ... TN</tt> in <tt>ArgTypes</tt>
respectivly, the <tt>type</tt> member is the result type of the
expression <tt>fn(t1,t2,...,tN)</tt>. the values <tt>ti</tt> are lvalues
when the corresponding type <tt>Ti</tt> is an lvalue-reference type, and
rvalues otherwise.
</p>
</blockquote>

<p>
This text doesn't seem to consider lvalue reference types for <tt>Fn</tt>.
Also, it's not clear whether this class template can be used for
"SFINAE" like <tt>std::enable_if</tt>. Example:
</p>

<blockquote><pre>template&lt;typename Fn, typename... Args&gt;
typename std::result_of&lt;Fn(Args...)&gt;::type
apply(Fn &amp;&amp; fn, Args &amp;&amp; ...args)
{
  // Fn may be an lvalue reference, too
  return std::forward&lt;Fn&gt;(fn)(std::forward&lt;Args&gt;(args)...);
}
</pre></blockquote>

<p>
Either <tt>std::result_of&lt;...&gt;</tt> can be instantiated and simply may not have
a typedef "<tt>type</tt>" (--&gt;SFINAE) or instantiating the class template for
some type combinations will be a "hard" compile-time error.
</p>


<p><b>Proposed resolution:</b></p>

<p><i>[
These changes will require compiler support
]</i></p>


<p>
Change 20.7.4 [func.ret]:
</p>

<blockquote><pre>template&lt;class&gt; class result_of; // <i>undefined</i>

template&lt;class Fn, class... ArgTypes&gt;
class result_of&lt;Fn(ArgTypes...)&gt; {
public:
  <del>typedef</del> <i>see below</i> <del>type;</del>
};
</pre>

<p><del>
Given an rvalue <tt>fn</tt> of type <tt>Fn</tt> and values <tt>t1, t2,
..., tN</tt> of types <tt>T1, T2, ... TN</tt> in <tt>ArgTypes</tt>
respectivly, the <tt>type</tt> member is the result type of the
expression <tt>fn(t1,t2,...,tN)</tt>. the values <tt>ti</tt> are lvalues
when the corresponding type <tt>Ti</tt> is an lvalue-reference type, and
rvalues otherwise.
</del></p>

<p>
<ins>The class template <tt>result_of</tt> shall meet the requirements of a
<i>TransformationTrait</i>: Given the types <tt>Fn</tt>, <tt>T1</tt>, <tt>T2</tt>, ..., <tt>TN</tt> every
template specialization <tt>result_of&lt;Fn(T1,T2,...,TN)&gt;</tt> shall define the
member typedef type equivalent to <tt>decltype(<i>RE</i>)</tt> if and only if
the expression <tt><i>RE</i></tt>
</ins></p>

<blockquote><pre><ins>
value&lt;Fn&gt;() ( value&lt;T1&gt;(), value&lt;T2&gt;(), ... value&lt;TN&gt;()  )
</ins></pre></blockquote>

<p><ins>
would be well-formed. Otherwise, there shall be no member typedef
<tt>type</tt> defined.
</ins></p>

</blockquote>
 
<p><i>[
The <tt>value&lt;&gt;</tt> helper function is a utility Daniel Krgler
proposed in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2958.html">N2958</a>.
]</i></p>






<hr>
<h3><a name="1226"></a>1226. Incomplete changes of #890</h3>
<p><b>Section:</b> 30.6.2 [futures.errors] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2009-10-05  <b>Last modified:</b> 2009-10-27</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Defect issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#890">890</a> overlooked to adapt the <tt>future_category</tt> from
30.6.1 [futures.overview] and 30.6.2 [futures.errors]:
</p>

<blockquote><pre>extern const error_category* const future_category;
</pre></blockquote>

<p>
which should be similarly transformed into function form.
</p>

<p><i>[
2009-10-27 Howard:
]</i></p>


<blockquote>
Moved to Tentatively Ready after 5 positive votes on c++std-lib.
</blockquote>



<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>
Change in 30.6.1 [futures.overview], header <tt>&lt;future&gt;</tt> synopsis:
</p>

<blockquote><pre><del>extern</del> const error_category<ins>&amp;</ins><del>* const</del> future_category<ins>()</ins>;
</pre></blockquote>
</li>

<li>
<p>
Change in 30.6.2 [futures.errors]:
</p>

<blockquote><pre><del>extern</del> const error_category<ins>&amp;</ins><del>* const</del> future_category<ins>()</ins>;
</pre>

<blockquote>
<p>
<del>1- <tt>future_category</tt> shall point to a statically initialized object
of a type derived from class <tt>error_category</tt>.</del>
</p>
<p>
<ins>1- <i>Returns:</i> A reference to an object of a type
derived from class <tt>error_category</tt>.</ins>
</p>
</blockquote>

<pre>constexpr error_code make_error_code(future_errc e);
</pre>

<blockquote>
3 <i>Returns:</i> <tt>error_code(static_cast&lt;int&gt;(e),
<del>*</del>future_category<ins>()</ins>)</tt>.
</blockquote>

<pre>constexpr error_code make_error_condition(future_errc e);
</pre>

<blockquote>
4 <i>Returns:</i> <tt>error_condition(static_cast&lt;int&gt;(e),
<del>*</del>future_category<ins>()</ins>)</tt>.
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="1227"></a>1227. <tt>&lt;bitset&gt;</tt> synopsis overspecified</h3>
<p><b>Section:</b> 20.3.7 [template.bitset] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Bo Persson <b>Opened:</b> 2009-10-05  <b>Last modified:</b> 2009-10-26</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#template.bitset">active issues</a> in [template.bitset].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#template.bitset">issues</a> in [template.bitset].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The resolutions to some library defect reports, like <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1178">1178</a>
requires that <tt>#includes</tt> in each synopsis should be taken
literally. This means that the <tt>&lt;bitset&gt;</tt> header now
<em>must</em> include <tt>&lt;stdexcept&gt;</tt>, even though none of the
exceptions are mentioned in the <tt>&lt;bitset&gt;</tt> header.
</p>
<p>
Many other classes are required to throw exceptions like
<tt>invalid_argument</tt> and <tt>out_of_range</tt>, without explicitly
including <tt>&lt;stdexcept&gt;</tt> in their synopsis. It is totally
possible for implementations to throw the needed exceptions from utility
functions, whose implementations are not visible in the headers.
</p>
<p>
I propose that <tt>&lt;stdexcept&gt;</tt> is removed from the
<tt>&lt;bitset&gt;</tt> header.
</p>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Moved to Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 20.3.7 [template.bitset]:
</p>

<blockquote><pre>#include &lt;cstddef&gt;        // for size_t
#include &lt;string&gt;
<del>#include &lt;stdexcept&gt;      // for invalid_argument,</del>
                          <del>// out_of_range, overflow_error</del>
#include &lt;iosfwd&gt;         // for istream, ostream
namespace std {
...
</pre></blockquote>





<hr>
<h3><a name="1228"></a>1228. User-specialized nothrow type traits</h3>
<p><b>Section:</b> 20.6.4.3 [meta.unary.prop] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-10-07  <b>Last modified:</b> 2009-10-26</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#meta.unary.prop">active issues</a> in [meta.unary.prop].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#meta.unary.prop">issues</a> in [meta.unary.prop].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
According to p1 20.6.2 [meta.type.synop]:
</p>

<blockquote>
The behavior of a program that adds specializations for any of the class
templates defined in this subclause is undefined unless otherwise
specified.
</blockquote>

<p>
I believe we should 'otherwise specify' for the nothrow traits, are
these are exactly the use cases where the end user actually has more
information than the compiler.
</p>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Moved to Open.  Definitely need to give the users the ability to ensure
that the traits give the right answers. Unsure we want to give them the
ability to say this in more than one way. Believes the noexcept proposal
already gives this.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add the following comment:
</p>

<blockquote>
user specialization permitted to derive from <tt>std::true_type</tt> when the
operation is known not to throw.
</blockquote>

<p>
to the following traits in 20.6.4.3 [meta.unary.prop] Table 43 Type
property predicates.
</p>

<p><i>[
This may require a new Comments column
]</i></p>


<blockquote><pre>has_nothrow_default_constructor
has_nothrow_copy_constructor
has_nothrow_assign
</pre></blockquote>





<hr>
<h3><a name="1231"></a>1231. <tt>weak_ptr</tt> comparisons incompletely resolved</h3>
<p><b>Section:</b> 20.8.15.3.5 [util.smartptr.weak.obs] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2009-10-10  <b>Last modified:</b> 2009-11-06</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2637.pdf">n2637</a>
paper suggested several updates of the ordering semantics of
<tt>shared_ptr</tt>
and <tt>weak_ptr</tt>, among those the explicit comparison operators of <tt>weak_ptr</tt> were
removed/deleted, instead a corresponding functor <tt>owner_less</tt> was added.
The problem
is that
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2637.pdf">n2637</a>
did not clearly enough specify, how the previous wording
parts describing
the comparison semantics of <tt>weak_ptr</tt> should be removed.
</p>

<p><i>[
2009-11-06 Howard adds:
]</i></p>


<blockquote>
Moved to Tentatively Ready after 5 positive votes on c++std-lib.
</blockquote>



<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>
Change 20.8.15.3 [util.smartptr.weak]/2 as described, the intention is to fix
the now no longer valid
requirement that <tt>weak_ptr</tt> is <tt>LessComparable</tt> [Note the deleted comma]:
</p>

<blockquote>
Specializations of <tt>weak_ptr</tt> shall be <tt>CopyConstructible</tt><del>,</del>
<ins>and</ins> <tt>CopyAssignable</tt>,
<del>and <tt>LessThanComparable</tt>,</del> allowing their use in standard containers.
</blockquote>
</li>

<li>
<p>
In 20.8.15.3.5 [util.smartptr.weak.obs] remove the paragraphs 9-11 including prototype:
</p>

<blockquote>
<del>template&lt;class T, class U&gt; bool operator&lt;(const weak_ptr&lt;T&gt;&amp; a, const weak_ptr&lt;U&gt;&amp; b);</del>

<p>
<del><i>Returns:</i> an unspecified value such that</del>
</p>
<ul>
<li>
<del><tt>operator&lt;</tt> is a strict weak ordering as described in 25.4;</del>
</li>
<li>
<del>under the equivalence relation defined by <tt>operator&lt;</tt>, <tt>!(a
&lt; b) &amp;&amp; !(b &lt; a)</tt>, two <tt>weak_ptr</tt> instances are
equivalent if and only if they share ownership or are both empty.</del>
</li>
</ul>

<p>
<del><i>Throws:</i> nothing.</del>
</p>

<p>
<del>[<i>Note:</i> Allows <tt>weak_ptr</tt> objects to be used as keys in associative
containers. &#8212; <i>end note</i>]</del>
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="1233"></a>1233. Missing <tt>unique_ptr</tt> signatures in synopsis</h3>
<p><b>Section:</b> 20.8 [memory] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">Tentatively NAD Editorial</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2009-10-11  <b>Last modified:</b> 2009-11-04</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#memory">issues</a> in [memory].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20NAD%20Editorial">Tentatively NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Related to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#296">296</a>.  Some <tt>unique_ptr</tt> signatures are missing
from the synopsis in 20.8 [memory].
</p>

<p><i>[
2009-11-04 Howard adds:
]</i></p>


<blockquote>
Moved to Tentatively NAD Editorial.  The editor has adopted the fix.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Add in 20.8 [memory], Header <tt>&lt;memory&gt;</tt> synopsis
missing declarations as shown below:
</p>

<blockquote><pre>// 20.8.11 Class unique_ptr:
template &lt;class X&gt; class default_delete;
<ins>template&lt;class T&gt; struct default_delete&lt;T[]&gt;;</ins>
template &lt;class X, class D = default_delete&lt;T&gt;&gt; class unique_ptr;
<ins>template&lt;class T, class D&gt; class unique_ptr&lt;T[], D&gt;;</ins>

<ins>template&lt;class T, class D&gt; void swap(unique_ptr&lt;T, D&gt;&amp; x, unique_ptr&lt;T, D&gt;&amp; y);</ins>

<ins>template&lt;class T1, class D1, class T2, class D2&gt;
bool operator==(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);</ins>
<ins>template&lt;class T1, class D1, class T2, class D2&gt;
bool operator!=(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);</ins>
<ins>template&lt;class T1, class D1, class T2, class D2&gt;
bool operator&lt;(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);</ins>
<ins>template&lt;class T1, class D1, class T2, class D2&gt;
bool operator&lt;=(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);</ins>
<ins>template&lt;class T1, class D1, class T2, class D2&gt;
bool operator&gt;(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);</ins>
<ins>template&lt;class T1, class D1, class T2, class D2&gt;
bool operator&gt;=(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);</ins>
</pre></blockquote>





<hr>
<h3><a name="1234"></a>1234. "Do the right thing" and NULL</h3>
<p><b>Section:</b> 23.2.3 [sequence.reqmts] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2009-10-09  <b>Last modified:</b> 2009-10-13</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#sequence.reqmts">active issues</a> in [sequence.reqmts].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#sequence.reqmts">issues</a> in [sequence.reqmts].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
On g++ 4.2.4 (x86_64-linux-gnu), the following file gives a compile
error:
</p>

<blockquote><pre>#include &lt;vector&gt;
void foo() { std::vector&lt;int*&gt; v(500l, NULL); }
</pre></blockquote>

<p>
Is this supposed to work? 
</p>

<p>
The issue: if <tt>NULL</tt> happens to be defined as <tt>0l</tt>, this is an invocation of
the constructor with two arguments of the same integral type.
23.2.3 [sequence.reqmts]/11 says that this will behave as if the the
overloaded constructor
</p>

<blockquote><pre>X(size_type, const value_type&amp; = value_type(),
  const allocator_type&amp; = allocator_type())
</pre></blockquote>

<p>
were called instead, with the arguments
<tt>static_cast&lt;size_type&gt;(first)</tt>, <tt>last</tt> and
<tt>alloc</tt>, respectively. However, it does not say whether this
actually means invoking that constructor with the exact textual form of
the arguments as supplied by the user, or whether the standard permits
an implementation to invoke that constructor with variables of the same
type and value as what the user passed in. In most cases this is a
distinction without a difference. In this particular case it does make a
difference, since one of those things is a null pointer constant and the
other is not.
</p>

<p>
Note that an implementation based on forwarding functions will use the
latter interpretation.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1237"></a>1237. Constrained error_code/error_condition members</h3>
<p><b>Section:</b> 19.5 [syserr] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2009-10-14  <b>Last modified:</b> 2009-10-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#syserr">issues</a> in [syserr].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I'm just reflecting on the now SFINAE-constrained constructors
and assignment operators of <tt>error_code</tt> and <tt>error_condition</tt>:
</p>
<p>
These are the <em>only</em> library components that are pro-actively
announcing that they are using <tt>std::enable_if</tt> as constraining tool,
which has IMO several disadvantages:
</p>

<ol>
<li>
<p>
With the availability of template default arguments and
decltype, using <tt>enable_if</tt> in C++0x standard library, seems
unnecessary restricting implementation freedom. E.g. there
should be not need for a useless specification of a dummy
default function argument, which only confuses the reader.
A more reasonable implementation could e.g. be
</p>

<blockquote><pre>template &lt;class ErrorCodeEnum
 class = typename enable_if&lt;is_error_code_enum&lt;ErrorCodeEnum&gt;::value&gt;::type&gt;
error_code(ErrorCodeEnum e);
</pre></blockquote>

<p>
As currently specified, the function signatures are so unreadable,
that errors quite easily happen, see e.g. <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1229">1229</a>.
</p>
</li>

<li>
<p>
We have a <em>lot</em> of constrained functions in other places, that
now have a standard phrase that is easily understandable:
</p>

<blockquote>
<i>Remarks:</i> This constructor/function shall participate in overload
resolution if and only if X.
</blockquote>

<p>
where X describes the condition. Why should these components deviate?
</p>
</li>

<li>
<p>
If <tt>enable_if</tt> would <em>not</em> be explicitly specified, the standard library
is much better prepared for the future. It would also be possible, that
libraries with partial support for not-yet-standard-concepts could provide
a much better diagnostic as is possible with <tt>enable_if</tt>. This again
would allow for experimental concept implementations in the wild,
which as a result would make concept standardization a much more
natural thing, similar to the way as templates were standardized
in C++.
</p>

<p>
In summary: I consider it as a library defect that <tt>error_code</tt> and
<tt>error_condition</tt> explicitly require a dependency to <tt>enable_if</tt> and
do limit implementation freedom and I volunteer to prepare a
corresponding resolution.
</p>
</li>
</ol>

<p><i>[
2009-10-18 Beman adds:
]</i></p>


<blockquote>
I support this proposed resolution, and thank Daniel for writing it up.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Moved to Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p><i>[
Should this resolution be accepted, I recommend to resolve <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1229">1229</a> as NAD
]</i></p>


<ol>
<li>
<p>
In 19.5.2.1 [syserr.errcode.overview]/1, class <tt>error_code</tt>,
change as indicated:
</p>

<blockquote><pre>// 19.5.2.2 constructors:
error_code();
error_code(int val, const error_category&amp; cat);
template &lt;class ErrorCodeEnum&gt;
  error_code(ErrorCodeEnum e<del>,
    typename enable_if&lt;is_error_code_enum&lt;ErrorCodeEnum&gt;::value&gt;::type * = 0</del>);

// 19.5.2.3 modifiers:
void assign(int val, const error_category&amp; cat);
template &lt;class ErrorCodeEnum&gt;
  <del>typename enable_if&lt;is_error_code_enum&lt;ErrorCodeEnum&gt;::value&gt;::type</del><ins>error_code</ins>&amp;
    operator=(ErrorCodeEnum e);
void clear();
</pre></blockquote>
</li>

<li>
<p>
Change 19.5.2.2 [syserr.errcode.constructors] around the prototype before p. 7:
</p>

<blockquote><pre>template &lt;class ErrorCodeEnum&gt;
error_code(ErrorCodeEnum e<del>,
  typename enable_if&lt;is_error_code_enum&lt;ErrorCodeEnum&gt;::value&gt;::type * = 0</del>);
</pre>
<blockquote>
<p>
<ins><i>Remarks:</i> This constructor shall not participate in overload
resolution, unless
<tt>is_error_code_enum&lt;ErrorCodeEnum&gt;::value == true</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>

<li>
<p>
Change 19.5.2.3 [syserr.errcode.modifiers] around the prototype before p. 3:
</p>

<blockquote><pre>template &lt;class ErrorCodeEnum&gt;
  <del>typename enable_if&lt;is_error_code_enum&lt;ErrorCodeEnum&gt;::value&gt;::type</del><ins>error_code</ins>&amp;
    operator=(ErrorCodeEnum e);
</pre>

<blockquote>
<ins><i>Remarks:</i> This operator shall not participate in overload resolution, unless
<tt>is_error_code_enum&lt;ErrorCodeEnum&gt;::value == true</tt>.</ins>
</blockquote>
</blockquote>
</li>

<li>
<p>
In 19.5.3.1 [syserr.errcondition.overview]/1, class <tt>error_condition</tt>, change
as indicated:
</p>

<blockquote><pre>// 19.5.3.2 constructors:
error_condition();
error_condition(int val, const error_category&amp; cat);
template &lt;class ErrorConditionEnum&gt;
  error_condition(ErrorConditionEnum e<del>,
    typename enable_if&lt;is_error_condition_enum&lt;ErrorConditionEnum&gt;::type* = 0</del>);

// 19.5.3.3 modifiers:
void assign(int val, const error_category&amp; cat);
template&lt;<del>typename</del><ins>class</ins> ErrorConditionEnum&gt;
  <del>typename enable_if&lt;is_error_condition_enum&lt;ErrorConditionEnum&gt;, error_code&gt;::type</del><ins>error_condition</ins> &amp;
    operator=( ErrorConditionEnum e );
void clear();
</pre></blockquote>
</li>

<li>
<p>
Change 19.5.3.2 [syserr.errcondition.constructors] around the
prototype before p. 7:
</p>

<blockquote><pre>template &lt;class ErrorConditionEnum&gt;
  error_condition(ErrorConditionEnum e<del>,
    typename enable_if&lt;is_error_condition_enum&lt;ErrorConditionEnum&gt;::value&gt;::type* = 0</del>);
</pre>
<blockquote>
<ins><i>Remarks:</i> This constructor shall not participate in overload
resolution, unless
<tt>is_error_condition_enum&lt;ErrorConditionEnum&gt;::value == true</tt>.</ins>
</blockquote>
</blockquote>
</li>

<li>
<p>
Change 19.5.3.3 [syserr.errcondition.modifiers] around the
prototype before p. 3:
</p>

<blockquote><pre>template &lt;class ErrorConditionEnum&gt;
  <del>typename enable_if&lt;is_error_condition_enum&lt;ErrorConditionEnum&gt;::value&gt;::type</del><ins>error_condition</ins>&amp;
    operator=(ErrorConditionEnum e);
</pre>

<blockquote>
<p>
<ins><i>Remarks:</i> This operator shall not participate in overload resolution, unless
<tt>is_error_condition_enum&lt;ErrorConditionEnum&gt;::value == true</tt>.</ins>
</p>

<p>
<i>Postcondition:</i> <tt>*this == make_error_condition(e)</tt>.
</p>

<p>
<ins><i>Returns:</i> <tt>*this</tt></ins>
</p>
</blockquote>
</blockquote>

</li>
</ol>






<hr>
<h3><a name="1238"></a>1238. defining algorithms taking iterator for range</h3>
<p><b>Section:</b> 25 [algorithms] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Future">Tentatively NAD Future</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-10-15  <b>Last modified:</b> 2009-11-03</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#algorithms">active issues</a> in [algorithms].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#algorithms">issues</a> in [algorithms].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20NAD%20Future">Tentatively NAD Future</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The library has many algorithms that take a source range represented by
a pair of iterators, and the start of some second sequence given by a
single iterator.  Internally, these algorithms will produce undefined
behaviour if the second 'range' is not as large as the input range, but
none of the algorithms spell this out in Requires clauses, and there is
no catch-all wording to cover this in clause 17 or the front matter of
25.
</p>

<p>
There was an attempt to provide such wording in paper
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2944.pdf">n2944</a>
but this
seems incidental to the focus of the paper, and getting the wording of
this issue right seems substantially more difficult than the simple
approach taken in that paper.  Such wording will be removed from an
updated paper, and hopefully tracked via the LWG issues list instead.
</p>

<p>
It seems there are several classes of problems here and finding wording
to solve all in one paragraph could be too much.  I suspect we need
several overlapping requirements that should cover the desired range of
behaviours.
</p>

<p>
Motivating examples:
</p>

<p>
A good initial example is the <tt>swap_ranges</tt> algorithm.  Here there is a
clear requirement that <tt>first2</tt> refers to the start of a valid range at
least as long as the range <tt>[first1, last1)</tt>.  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2944.pdf">n2944</a> tries to solve this
by positing a hypothetical <tt>last2</tt> iterator that is implied by the
signature, and requires <tt>distance(first2,last2) &lt; distance(first1,last1)</tt>.
 This mostly works, although I am uncomfortable assuming that <tt>last2</tt> is
clearly defined and well known without any description of how to obtain
it (and I have no idea how to write that).
</p>

<p>
A second motivating example might be the <tt>copy</tt> algorithm.  Specifically,
let us image a call like:
</p>

<blockquote><pre>copy(istream_iterator&lt;int&gt;(is),istream_iterator(),ostream_iterator&lt;int&gt;(os));
</pre></blockquote>

<p>
In this case, our input iterators are literally simple <tt>InputIterators</tt>,
and the destination is a simple <tt>OutputIterator</tt>.  In neither case am I
happy referring to <tt>std::distance</tt>, in fact it is not possible for the
<tt>ostream_iterator</tt> at all as it does not meet the requirements.  However,
any wording we provide must cover both cases.  Perhaps we might deduce
<tt>last2 == ostream_iterator&lt;int&gt;{}</tt>, but that might not always be valid for
user-defined iterator types.  I can well imagine an 'infinite range'
that writes to <tt>/dev/null</tt> and has no meaningful <tt>last2</tt>.
</p>

<p>
The motivating example in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2944.pdf">n2944</a> is <tt>std::equal</tt>, and that seems to fall somewhere between the
two.
</p>

<p>
Outlying examples might be <tt>partition_copy</tt> that takes two output
iterators, and the <tt>_n</tt> algorithms where a range is specified by a
specific number of iterations, rather than traditional iterator pair. 
We should also <em>not</em> accidentally apply inappropriate constraints to
<tt>std::rotate</tt> which takes a third iterator that is not intended to be a
separate range at all.
</p>

<p>
I suspect we want some wording similar to:
</p>

<blockquote>
For algorithms that operate on ranges where the end iterator of the
second range is not specified, the second range shall contain at least
as many elements as the first.
</blockquote>

<p>
I don't think this quite captures the intent yet though.  I am not sure
if 'range' is the right term here rather than sequence.  More awkwardly,
I am not convinced we can describe an Output sequence such as produce by
an <tt>ostream_iterator</tt> as "containing elements", at least not as a
precondition to the call before they have been written.
</p>

<p>
Another idea was to describe require that the trailing iterator support
at least distance(input range) applications of <tt>operator++</tt> and may be
written through the same number of times if a mutable/output iterator.
</p>

<p>
We might also consider handling the case of an output range vs. an input
range in separate paragraphs, if that simplifies how we describe some of
these constraints.
</p>

<p><i>[
2009-11-03 Howard adds:
]</i></p>


<blockquote>
Moved to Tentatively NAD Future after 5 positive votes on c++std-lib.
</blockquote>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1239"></a>1239. Defect report</h3>
<p><b>Section:</b> 20.6.4.3 [meta.unary.prop] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">Tentatively NAD Editorial</a>
 <b>Submitter:</b> David Abrahams <b>Opened:</b> 2009-10-16  <b>Last modified:</b> 2009-10-26</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#meta.unary.prop">active issues</a> in [meta.unary.prop].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#meta.unary.prop">issues</a> in [meta.unary.prop].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20NAD%20Editorial">Tentatively NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Table 43 defines a number of traits that yield true for arrays of class
types with the trait's property, but not arrays of other types with that
property.  For example, <tt>has_trivial_default_constructor</tt>:
</p>

<blockquote>
<tt>T</tt> is a trivial type (3.9) or a class type with a trivial default
constructor (12.1) or an array of such a class type.
</blockquote>

<p><i>[
2009-10 post-Santa Cruz:
]</i></p>


<blockquote>
<p>
An array of a trivial type is a trivial type.
</p>
<p>
Mark as Tentatively NAD Editorial. The wording is OK as is,
since an array of a trivial type is a trivial type, but the wording as
proposed might be clearer.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change all the traits in question following this pattern:
</p>

<blockquote>
<tt>T</tt> is a trivial type (3.9) or a class type with a trivial default
 constructor (12.1)<ins>,</ins> or an array of such a <del>class</del> type.
</blockquote>

<p>
i.e., add a comma and delete a "class."
</p>





<hr>
<h3><a name="1240"></a>1240. Deleted comparison functions of std::function not  needed</h3>
<p><b>Section:</b> 20.7.15.2 [func.wrap.func] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2009-10-18  <b>Last modified:</b> 2009-10-19</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#func.wrap.func">issues</a> in [func.wrap.func].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The class template <tt>std::function</tt> contains the following member
declarations:
</p>

<blockquote><pre>// deleted overloads close possible hole in the type system
template&lt;class R2, class... ArgTypes2&gt;
  bool operator==(const function&lt;R2(ArgTypes2...)&gt;&amp;) = delete;
template&lt;class R2, class... ArgTypes2&gt;
  bool operator!=(const function&lt;R2(ArgTypes2...)&gt;&amp;) = delete;
</pre></blockquote>

<p>
The leading comment here is part of the history of <tt>std::function</tt>, which
was introduced with <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1402.html#undefined_operators">N1402</a>.
During that time no explicit conversion functions existed, and the
"safe-bool" idiom (based on pointers-to-member) was a popular
technique. The only disadvantage of this idiom was that given two
objects <tt>f1</tt> and <tt>f2</tt> of type <tt>std::function</tt> the expression
</p>

<blockquote><pre>f1 == f2;
</pre></blockquote>

<p>
was well-formed, just because the built-in <tt>operator==</tt> for pointer to member
was considered after a single user-defined conversion. To fix this, an
overload set of <em>undefined</em> comparison functions was added,
such that overload resolution would prefer those ending up in a linkage error.
The new language facility of deleted functions provided a much better
diagnostic mechanism to fix this issue.
</p>

<p>
The central point of this issue is, that with the replacement of the
safe-bool idiom by explicit conversion to bool the original "hole in the
type system" does no longer exist and therefore the comment is wrong and
the superfluous function definitions should be removed as well. An
explicit conversion function is considered in direct-initialization
situations only, which indirectly contain the so-called "contextual
conversion to bool" (4 [conv]/3). These conversions are not considered for
<tt>==</tt> or <tt>!=</tt> as defined by the core language.
</p>


<p><b>Proposed resolution:</b></p>
<p>
In 20.7.15.2 [func.wrap.func]/1, class function change as indicated:
</p>

<blockquote><pre>// 20.7.15.2.3, function capacity:
explicit operator bool() const;

<del>// deleted overloads close possible hole in the type system</del>
<del>template&lt;class R2, class... ArgTypes2&gt;</del>
  <del>bool operator==(const function&lt;R2(ArgTypes2...)&gt;&amp;) = delete;</del>
<del>template&lt;class R2, class... ArgTypes2&gt;</del>
  <del>bool operator!=(const function&lt;R2(ArgTypes2...)&gt;&amp;) = delete;</del>
</pre></blockquote>





<hr>
<h3><a name="1241"></a>1241. unique_copy needs to require EquivalenceRelation</h3>
<p><b>Section:</b> 25.3.9 [alg.unique] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2009-10-17  <b>Last modified:</b> 2009-10-31</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.unique">issues</a> in [alg.unique].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
A lot of fixes were silently applied during concept-time and we should
not lose them again. The Requires clause of 25.3.9 [alg.unique]/5
doesn't mention that <tt>==</tt> and the predicate need to satisfy an
<tt>EquivalenceRelation</tt>, as it is correctly said for
<tt>unique</tt>. This was intentionally fixed during conceptification,
were we had:
</p>

<blockquote><pre>template&lt;InputIterator InIter, class OutIter&gt;
  requires OutputIterator&lt;OutIter, RvalueOf&lt;InIter::value_type&gt;::type&gt;
        &amp;&amp; EqualityComparable&lt;InIter::value_type&gt;
        &amp;&amp; HasAssign&lt;InIter::value_type, InIter::reference&gt;
        &amp;&amp; Constructible&lt;InIter::value_type, InIter::reference&gt;
  OutIter unique_copy(InIter first, InIter last, OutIter result);

template&lt;InputIterator InIter, class OutIter,
         EquivalenceRelation&lt;auto, InIter::value_type&gt; Pred&gt;
  requires OutputIterator&lt;OutIter, RvalueOf&lt;InIter::value_type&gt;::type&gt;
        &amp;&amp; HasAssign&lt;InIter::value_type, InIter::reference&gt;
        &amp;&amp; Constructible&lt;InIter::value_type, InIter::reference&gt;
        &amp;&amp; CopyConstructible&lt;Pred&gt;
  OutIter unique_copy(InIter first, InIter last, OutIter result, Pred pred);
</pre></blockquote>

<p>
Note that EqualityComparable implied an equivalence relation.
</p>

<p><i>[
N.B. <tt>adjacent_find</tt> was also specified to require
<tt>EquivalenceRelation</tt>, but that was considered as a defect in
concepts, see <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1000">1000</a>
]</i></p>


<p><i>[
2009-10-31 Howard adds:
]</i></p>


<blockquote>
Moved to Tentatively Ready after 5 positive votes on c++std-lib.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 25.3.9 [alg.unique]/5 as indicated:
</p>

<blockquote><pre>template&lt;class InputIterator, class OutputIterator&gt;
  OutputIterator
    unique_copy(InputIterator first, InputIterator last, OutputIterator result);

template&lt;class InputIterator, class OutputIterator, class BinaryPredicate&gt;
  OutputIterator
    unique_copy(InputIterator first, InputIterator last,
                OutputIterator result, BinaryPredicate pred);
</pre>
<blockquote>
<i>Requires:</i> <ins>The comparison function shall be an equivalence
relation.</ins> The ranges <tt>[first,last)</tt> and
<tt>[result,result+(last-first))</tt> shall not overlap. The expression
<tt>*result = *first</tt> shall be valid. If neither
<tt>InputIterator</tt> nor <tt>OutputIterator</tt> meets the
requirements of forward iterator then the value type of
<tt>InputIterator</tt> shall be <tt>CopyConstructible</tt> (34) and
<tt>CopyAssignable</tt> (table 36). Otherwise <tt>CopyConstructible</tt>
is not required.
</blockquote>
</blockquote>





<hr>
<h3><a name="1244"></a>1244. wait_*() in *future for synchronous functions</h3>
<p><b>Section:</b> 30.6 [futures] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Detlef Vollmann <b>Opened:</b> 2009-10-22  <b>Last modified:</b> 2009-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#futures">issues</a> in [futures].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
With the addition of <tt>async()</tt>, a <tt>future</tt> might be
associated with a function that is not running in a different thread but
is stored to by run synchronously on the <tt>get()</tt> call. It's not
clear what the <tt>wait()</tt> functions should do in this case.
</p>

<p>
Suggested resolution:
</p>

<p>
Throw an exception.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1245"></a>1245. <tt>std::hash&lt;string&gt;</tt> &amp; co</h3>
<p><b>Section:</b> 20.7.16 [unord.hash] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Paolo Carlini <b>Opened:</b> 2009-10-22  <b>Last modified:</b> 2009-10-25</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#unord.hash">active issues</a> in [unord.hash].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#unord.hash">issues</a> in [unord.hash].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 20.7.16 [unord.hash], <tt>operator()</tt> is specified as
taking the argument by value. Moreover, it is said that <tt>operator()</tt> shall
not throw exceptions.
</p>

<p>
However, for the specializations for class types, like <tt>string</tt>, <tt>wstring</tt>,
etc, the former requirement seems suboptimal from the performance point
of view (a specific PR has been filed about this in the GCC Bugzilla)
and, together with the latter requirement, hard if not impossible to
fulfill. It looks like pass by const reference should be allowed in such
cases.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add to 20.7.16 [unord.hash]/2:
</p>

<blockquote>
<pre>namespace std {
  template &lt;class T&gt;
  struct hash : public std::unary_function&lt;T, std::size_t&gt; {
    std::size_t operator()(T val) const;
  };
}
</pre>

<p>
The return value of <tt>operator()</tt> is unspecified, except that
equal arguments shall yield the same result. <tt>operator()</tt> shall
not throw exceptions. <ins>It is also unspecified whether
<tt>operator()</tt> of <tt>std::hash</tt> specializations for class
types takes its argument by value or const reference.</ins>
</p>
</blockquote>





<hr>
<h3><a name="1246"></a>1246. <tt>vector::resize()</tt> missing efficiency guarantee</h3>
<p><b>Section:</b> 23.3.6.2 [vector.capacity] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> David Abrahams <b>Opened:</b> 2009-10-24  <b>Last modified:</b> 2009-10-25</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#vector.capacity">issues</a> in [vector.capacity].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
If <tt>v</tt> is a <tt>vector</tt>, I think repeated calls to
<tt>v.resize( v.size() + 1 )</tt> should be amortized O(1), but it's not
clear that's true from the text of the standard:
</p>

<blockquote><pre>void resize(size_type sz);
</pre>
<blockquote>
<i>Effects:</i> If <tt>sz &lt; size()</tt>, equivalent to <tt>erase(begin() + sz, end());</tt>. If
<tt>size() &lt; sz</tt>, appends <tt>sz - size()</tt> default constructed elements to the
sequence.
</blockquote>
</blockquote>

<p>
Seems to me if we used <tt>push_back</tt> instead of appends, we might be giving
the guarantee I'd like.  Thoughts?
</p>


<p><b>Proposed resolution:</b></p>
<p>
In 23.3.6.2 [vector.capacity]/10, change
</p>

<blockquote><pre>void resize(size_type sz);
</pre>
<blockquote>
<i>Effects:</i> If <tt>sz &lt; size()</tt>, equivalent to <tt>erase(begin() + sz, end());</tt>. If
<tt>size() &lt; sz</tt>, <del>appends <tt>sz - size()</tt> default constructed elements to the
sequence</del>
<ins>equivalent to <tt>sz - size()</tt> consecutive evaluations of <tt>push_back(T())</tt></ins>.
</blockquote>
</blockquote>






<hr>
<h3><a name="1247"></a>1247. <tt>auto_ptr</tt> is overspecified</h3>
<p><b>Section:</b> D.10.1 [auto.ptr] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Review">Review</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-10-24  <b>Last modified:</b> 2009-11-06</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#auto.ptr">issues</a> in [auto.ptr].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Review">Review</a> status.</p>
<p><b>Discussion:</b></p>
<p>
This issue is extracted as the ongoing point-of-interest from earlier
issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#463">463</a>.
</p>

<p>
<tt>auto_ptr</tt> is overspecified as the <tt>auto_ptr_ref</tt>
implementation detail is formally specified, and the technique is
observable so workarounds for compiler defects can  cause a working
implementation of the primary <tt>auto_ptr</tt> template become
non-conforming.
</p>

<p>
<tt>auto_ptr_ref</tt> is a documentation aid to describe a possible
mechanism to implement the class.  It should be marked exposition only,
as per similar classes, e.g., <tt>istreambuf_iterator::proxy</tt>
</p>

<p><i>[
2009-10-25 Daniel adds:
]</i></p>


<blockquote>
<p>
I wonder, whether the revised wording shouldn't be as straight as
for <tt>istream_buf</tt> by adding one further sentence:
</p>

<blockquote>
An implementation is permitted to provide equivalent functionality without
providing a class with this name.
</blockquote>
</blockquote>

<p><i>[
2009-11-06 Alisdair adds Daniel's suggestion to the proposed wording.
]</i></p>


<p><i>[
2009-11-06 Howard moves issue to Review.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
Add the term "exposition only" in the following two places:
</p>

<p>
Ammend D.10.1 [auto.ptr]p2:
</p>

<blockquote>
<p>
<ins>The exposition only class </ins> <del>T</del><ins>t</ins>emplate <tt>auto_ptr_ref</tt>
holds a reference to an <tt>auto_ptr</tt>. It is used by the
<tt>auto_ptr</tt> conversions to allow <tt>auto_ptr</tt> objects to be
passed to and returned from functions.
<ins>An implementation is permitted to provide equivalent functionality
without providing a class with this name.</ins>
</p>

<blockquote><pre>namespace std {
 template &lt;class Y&gt; struct auto_ptr_ref { }; <ins>// exposition only</ins>
</pre></blockquote>
</blockquote>





<hr>
<h3><a name="1249"></a>1249. basic_ios default ctor</h3>
<p><b>Section:</b> 27.5.4.1 [basic.ios.cons] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2009-10-25  <b>Last modified:</b> 2009-10-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#basic.ios.cons">issues</a> in [basic.ios.cons].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The basic_ios default ctor is required to leave the objects members
uninitialized (see below). The paragraph says the object must be
initialized by calling basic_ios::init() before it's destroyed by
I can't find a requirement that it be initialized before calling
any of the class other member functions. Am I not looking in the
right place or that an issue?
</p>

<p><i>[
2009-10-25 Daniel adds:
]</i></p>


<blockquote>
<p>
I agree, that your wording makes that clearer, but suggest to write
</p>

<blockquote>
... calling <tt>basic_ios::init<del>()</del></tt> before ...
</blockquote>

<p>
Doing so, I recommend to adapt that of <tt>ios_base();</tt> as well, where
we have:
</p>

<blockquote>
<i>Effects:</i> Each <tt>ios_base</tt> member has an indeterminate value
after construction. These members shall be initialized by calling
<tt>basic_ios::init</tt>. If an <tt>ios_base</tt> object is destroyed
before these initializations have taken place, the behavior is
undefined.
</blockquote>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 27.5.2.7 [ios.base.cons] p1:
</p>

<blockquote><pre>ios_base();
</pre>
<blockquote>
<i>Effects:</i> Each <tt>ios_base</tt> member has an indeterminate value
after construction. <del>These</del> <ins>The object's</ins> members shall be initialized by calling
<tt>basic_ios::init</tt> <ins>before the object's first use or before
 it is destroyed, whichever comes first; otherwise the behavior
 is undefined.</ins>. <del>If an <tt>ios_base</tt> object is destroyed
before these initializations have taken place, the behavior is
undefined.</del>
</blockquote>
</blockquote>

<p>
Change 27.5.4.1 [basic.ios.cons] p2:
</p>

<blockquote><pre>basic_ios();
</pre>
<blockquote>
<i>Effects:</i> Constructs an object of class <tt>basic_ios</tt>
(27.5.2.7) leaving its member objects uninitialized. The object shall be
initialized by calling <del>its</del>
<tt><ins>basic_ios::</ins>init</tt> <ins>before its first
use or before it is destroyed, whichever comes first; otherwise the
behavior is undefined.</ins> <del>member function. If it is destroyed
before it has been initialized the behavior is undefined.</del>
</blockquote>
</blockquote>





<hr>
<h3><a name="1250"></a>1250. <tt>&lt;bitset&gt;</tt> still overspecified</h3>
<p><b>Section:</b> 20.3.7 [template.bitset] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2009-10-29  <b>Last modified:</b> 2009-10-29</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#template.bitset">active issues</a> in [template.bitset].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#template.bitset">issues</a> in [template.bitset].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1227">1227</a> &#8212; <tt>&lt;bitset&gt;</tt> synopsis overspecified makes the observation
that <tt>std::bitset</tt>, and in fact the whole library, may be implemented
without needing to <tt>#include &lt;stdexcept&gt;</tt> in any library header. The
proposed resolution removes the <tt>#include &lt;stdexcept&gt;</tt> directive from
the header.
</p>

<p>
I'd like to add that the <tt>&lt;bitset&gt;</tt> header (as well as the rest of
the library) has also been implemented without #including the
<tt>&lt;cstddef&gt;</tt> header in any library header. In the case of <tt>std::bitset</tt>,
the template is fully usable (i.e., it may be instantiated and all
its member functions may be used) without ever mentioning <tt>size_t</tt>.
In addition, just like no library header except for <tt>&lt;bitset&gt;</tt>
<tt>#includes &lt;stdexcept&gt;</tt> in its synopsis, no header but <tt>&lt;bitset&gt;</tt>
<tt>#includes &lt;cstddef&gt;</tt> either.
</p>

<p>
Thus I suggest that the <tt>#include &lt;cstddef&gt;</tt> directive be similarly
removed from the synopsis of <tt>&lt;bitset&gt;</tt>.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change 20.3.7 [template.bitset]:
</p>

<blockquote><pre><del>#include &lt;cstddef&gt;        // for size_t</del>
#include &lt;string&gt;
#include &lt;iosfwd&gt;         // for istream, ostream
namespace std {
...
</pre></blockquote>





<hr>
<h3><a name="1251"></a>1251. move constructing <tt>basic_stringbuf</tt></h3>
<p><b>Section:</b> 27.8.1.1 [stringbuf.cons] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2009-10-29  <b>Last modified:</b> 2009-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#stringbuf.cons">issues</a> in [stringbuf.cons].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I just came across issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1204">1204</a> -- Global permission to move, which
seems to address the concern raised by the example in c++std-lib-25030.
</p>
<p>
IIUC, the example violates the permission to assume that arguments
bound to rvalue references are unnamed temporaries granted to
implementations by the resolution of issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1204">1204</a> - Global permission
to move.
</p>

<p>
I.e., the <tt>ostringstream(ostringstream &amp;&amp;rhs)</tt> ctor can leave the <tt>rhs</tt>
pointers pointing to the newly constructed object's buffer just as
long as the dtor doesn't change or invalidate the buffer. The caller
may not make any assumptions about rhs after the move beyond it being
safe to destroy or reassign.
</p>

<p>
So unless I misunderstood something, I still think the <tt>basic_stringbuf</tt>
move ctor is overspecified. Specifically, I think the third sentence
in the Effects clause and the last 6 bullets in the Postconditions
clause can, and IMO should, be stricken.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Strike from 27.8.1.1 [stringbuf.cons]:
</p>

<blockquote><pre>basic_stringbuf(basic_stringbuf&amp;&amp; rhs);
</pre>
<blockquote>
<p>
<i>Effects:</i> Move constructs from the rvalue <tt>rhs</tt>. It is
implementation-defined whether the sequence pointers in <tt>*this</tt>
(<tt>eback()</tt>, <tt>gptr()</tt>, <tt>egptr()</tt>, <tt>pbase()</tt>,
<tt>pptr()</tt>, <tt>epptr()</tt>) obtain the values which <tt>rhs</tt>
had. <del>Whether they do or not, <tt>*this</tt> and <tt>rhs</tt> reference
separate buffers (if any at all) after the construction.</del> The openmode,
locale and any other state of <tt>rhs</tt> is also copied.
</p>

<p>
<i>Postconditions:</i> Let <tt>rhs_p</tt> refer to the state of
<tt>rhs</tt> just prior to this construction and let <tt>rhs_a</tt>
referto the state of <tt>rhs</tt> just after this construction.
</p>
<ul>
<li>
<tt>str() == rhs_p.str()</tt>
</li>
<li>
<tt>gptr() - eback() == rhs_p.gptr() - rhs_p.eback()</tt>
</li>
<li>
<tt>egptr() - eback() == rhs_p.egptr() - rhs_p.eback()</tt>
</li>
<li>
<tt>pptr() - pbase() == rhs_p.pptr() - rhs_p.pbase()</tt>
</li>
<li>
<tt>epptr() - pbase() == rhs_p.epptr() - rhs_p.pbase()</tt>
</li>
<li><del>
if <tt>(eback()) eback() != rhs_a.eback()</tt>
</del></li>
<li><del>
if <tt>(gptr()) gptr() != rhs_a.gptr()</tt>
</del></li>
<li><del>
if <tt>(egptr()) egptr() != rhs_a.egptr()</tt>
</del></li>
<li><del>
if <tt>(pbase()) pbase() != rhs_a.pbase()</tt>
</del></li>
<li><del>
if <tt>(pptr()) pptr() != rhs_a.pptr()</tt>
</del></li>
<li><del>
if <tt>(epptr()) epptr() != rhs_a.epptr()</tt>
</del></li>
</ul>
</blockquote>
</blockquote>






<hr>
<h3><a name="1252"></a>1252. <tt>wbuffer_convert::state_type</tt> inconsistency</h3>
<p><b>Section:</b> 22.3.3.2.3 [conversions.buffer] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Bo Persson  <b>Opened:</b> 2009-10-21  <b>Last modified:</b> 2009-10-31</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The synopisis for <tt>wbuffer_convert</tt> 22.3.3.2.3 [conversions.buffer]/2 contains
</p>

<blockquote><pre>typedef typename Tr::state_type   state_type; 
</pre></blockquote>

<p>
making <tt>state_type</tt> a synonym for (possibly) some
<tt>char_traits&lt;x&gt;::state_type</tt>. 
</p>

<p>
However, in paragraph 9 of the same section, we have 
</p>

<blockquote><pre>typedef typename Codecvt::state_type state_type;
</pre>

<blockquote>
The type shall be a synonym for <tt>Codecvt::state_type</tt>.
</blockquote>
</blockquote>

<p>
From what I can see, it might be hard to implement
<tt>wbuffer_convert</tt> if the types were not both
<tt>std::mbstate_t</tt>, but I cannot find a requirement that they must
be the same type.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1253"></a>1253. invalidation of iterators and <tt>emplace</tt> vs. <tt>insert</tt> inconsistence in assoc. containers</h3>
<p><b>Section:</b> 23.2.4 [associative.reqmts] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Boris Du&#353;ek <b>Opened:</b> 2009-10-24  <b>Last modified:</b> 2009-10-31</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#associative.reqmts">active issues</a> in [associative.reqmts].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#associative.reqmts">issues</a> in [associative.reqmts].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In the latest published draft
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2960.pdf">N2960</a>,
section 23.2.4 [associative.reqmts], paragraph 8, it is specifies
that that <tt>insert</tt> does not invalidate any iterators. As per
23.2.1 [container.requirements.general], paragraph 12, this holds
true not only for <tt>insert</tt>, but <tt>emplace</tt> as well. This
gives the <tt>insert</tt> member a special treatment w.r.t.
<tt>emplace</tt> member in 23.2.4 [associative.reqmts], par. 8,
since both modify the container. For the sake of consistency, in 23.2.4 [associative.reqmts], par. 8: either reference to
<tt>insert</tt> should be removed (i.e. count on 23.2.1 [container.requirements.general], par. 12), or reference to
<tt>emplace</tt> be added (i.e. mention all members of assoc. containers
that modify it).
</p>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="1254"></a>1254. Misleading sentence in <tt>vector&lt;bool&gt;::flip</tt></h3>
<p><b>Section:</b> 23.3.7 [vector.bool] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Christopher Jefferson <b>Opened:</b> 2009-11-01  <b>Last modified:</b> 2009-11-01</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#vector.bool">issues</a> in [vector.bool].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The effects of <tt>vector&lt;bool&gt;::flip</tt> has the line:
</p>

<blockquote>
It is unspecified whether the function has any effect on allocated but
unused bits.
</blockquote>

<p>
While this is technically true, it is misleading, as any member function
in any standard container may change unused but allocated memory. Users
can never observe such changes as it would also be undefined behaviour
to read such memory.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Strike second sentence from the definition of <tt>vector&lt;bool&gt;::flip()</tt>,
23.3.7 [vector.bool], paragraph 5.
</p>

<blockquote>
<i>Effects:</i> Replaces each element in the container with its complement.
<del>It is unspecified whether the function has any effect on allocated
but unused bits.</del>
</blockquote>





<hr>
<h3><a name="1255"></a>1255. <tt>declval</tt> should be added to the library</h3>
<p><b>Section:</b> 20.3 [utility] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2009-11-03  <b>Last modified:</b> 2009-11-04</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
During the Santa Cruz meeting it was decided to split off the provision
of the library utility <tt>value()</tt> proposed in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2979.html">N2979</a>
from the concrete request of the
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2939.html#uk300">UK 300</a>
comment.
The provision of a new library component that allows the production of
values in unevaluated expressions is considered as important
to realize constrained templates in C++0x where concepts are not
available.
</p>

<p>
The following proposed resolution is an improvement over that suggested in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2958.html">N2958</a>,
because the proposed component can now be defined without loss of
general usefulness and any <i>use</i> by user-code will make the program ill-formed.
A possible prototype implementation that satisfies the core language
requirements
can be written as:
</p>

<blockquote><pre>template&lt;class T&gt;
  struct declval_protector {
    static const bool stop = false;
    static typename std::add_rvalue_reference&lt;T&gt;::type delegate(); <font color="#c80000">// undefined</font>
  };

template&lt;class T&gt;
typename std::add_rvalue_reference&lt;T&gt;::type declval() {
  static_assert(declval_protector&lt;T&gt;::stop, "declval() must not be used!");
  return declval_protector&lt;T&gt;::delegate();
}
</pre></blockquote>

<p>
Further-on the earlier suggested name <tt>value()</tt> has been changed to <tt>declval()</tt>
after discussions with committee members.
</p>

<p>
Finally the suggestion shown below demonstrates that it can simplify
existing standard wording by directly using it in the library
specification, and that it also improves an overlooked corner case for
<tt>common_type</tt> by adding support for <tt>cv void</tt>.
</p>


<p><b>Proposed resolution:</b></p>
<p><i>[
The following edit assumes that the earlier component identity
has been removed as part of applying the solution of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#939">939</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2951.html">N2951</a>,
and
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2984.html">N2984</a>.
Note that the proposal does not depend on this application,
but it just simplifies the editorial representation
]</i></p>


<ol>
<li>
<p>
Change 20.3 [utility], header <tt>&lt;utility&gt;</tt> synopsis
as indicated:
</p>

<blockquote><pre>// 20.3.2, forward/move:
template &lt;class T, class U&gt; T&amp;&amp; forward(U&amp;&amp; u);;
template &lt;class T&gt; typename remove_reference&lt;T&gt;::type&amp;&amp; move(T&amp;&amp;);

<ins>// 20.3.3, declval:</ins>
<ins>template &lt;class T&gt; typename add_rvalue_reference&lt;T&gt;::type declval(); // for unused context</ins>
</pre></blockquote>
</li>

<li>
<p>
Immediately after the current section 20.3.3 [forward] insert a
new section:
</p>
<p>
<ins>20.3.3 Function template declval [declval]</ins>
</p>
<p>
<ins>The library provides the function template <tt>declval</tt> to simplify
the definition of expressions in
unevaluated and unused contexts (3.2 [basic.def.odr], 5 [expr]). The
template parameter <tt>T</tt> of <tt>declval</tt> may
be an incomplete type.</ins>
</p>

<pre><ins>template &lt;class T&gt; typename add_rvalue_reference&lt;T&gt;::type declval(); // for unused context</ins>
</pre>

<blockquote>
<p>
<ins><i>Remarks:</i> If this function is used according to 3.2 [basic.def.odr],
the program shall be ill-formed.</ins>
</p>

<p>
<ins>[<i>Example:</i></ins>
</p>

<blockquote><pre><ins>
template&lt;class To, class From&gt;
decltype(static_cast&lt;To&gt;(declval&lt;From&gt;())) convert(From&amp;&amp;);
</ins></pre></blockquote>

<p>
<ins>
declares a function template <tt>convert</tt>, which does only participate in
overloading, if the type <tt>From</tt> can be
explicitly casted to type <tt>To</tt> &#8212; <i>end example</i>]</ins>
</p>
</blockquote>

</li>

<li>
<p>
This bullet just makes clear that after applying <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2984.html">N2984</a>, the changes in 20.6.4.3 [meta.unary.prop], before
table Type property queries should <em>not</em> use <tt>declval</tt>,
because the well-formedness requirement of the specification of
<tt>is_constructible</tt> would become more complicated, because we
would need to make sure that the expression <i>CE</i> is checked in an
unevaluated context.
</p>
</li>

<li>
<p>
Also 20.6.5 [meta.rel]/4 is not modified similar to the previous bullet,
because with
the stricter requirements of not using <tt>declval()</tt> the well-formedness condition
would be harder to specify. The following changes are only editorial ones (e.g.
the removal of the duplicate declaration of <tt>create()</tt>):
</p>

<blockquote>
<p>
Given the following function prototype:
</p>

<blockquote><pre>template &lt;class T&gt;
  typename add_rvalue_reference&lt;T&gt;::type create();
</pre></blockquote>

<p>
the predicate condition for a template specialization
<tt>is_convertible&lt;From, To&gt;</tt> shall be satisfied if and only
if the return expression in the following code would be well-formed,
including any
im<del>m</del>plicit conversions to the return type of the function:
</p>

<blockquote><pre><del>template &lt;class T&gt;
typename add_rvalue_reference&lt;T&gt;::type create();</del>
To test() {
  return create&lt;From&gt;();
}
</pre></blockquote>
</blockquote>
</li>

<li>
<p>
Change the entry in column "Comments" for <tt>common_type</tt> in Table 51 &#8212;
Other transformations (20.6.7 [meta.trans.other]):
</p>

<p><i>[
NB: This wording change extends the type domain of <tt>common_type</tt> for <tt>cv
void =&gt; cv void</tt> transformations and thus makes <tt>common_type</tt> usable for
all binary type combinations that are supported by <tt>is_convertible</tt>
]</i></p>


<blockquote>
The member typedef <tt>type</tt> shall be defined as set out below. All
types in the parameter pack <tt>T</tt> shall be complete <ins>or
(possibly cv-qualified) <tt>void</tt></ins>. A program may specialize
this trait if at least one template parameter in the specialization is a
user-defined type. [<i>Note:</i> Such specializations are needed when
only explicit conversions are desired among the template arguments.
&#8212; <i>end note</i>]
</blockquote>
</li>

<li>
<p>
Change 20.6.7 [meta.trans.other]/3 as indicated:
</p>

<p><i>[
NB: This wording change is more than an editorial simplification of
the definition of <tt>common_type</tt>: It also extends its usefulness for <tt>cv
void</tt> types as outlined above
]</i></p>


<blockquote>
<p>
The nested typedef <tt>common_type::type</tt> shall be defined as follows:
</p>

<blockquote>
<p>
[..]
</p>
<pre>template &lt;class T, class U&gt;
struct common_type&lt;T, U&gt; {
<del>private:
  static T&amp;&amp; __t();
  static U&amp;&amp; __u();
public:</del>
  typedef decltype(true ? <del>__t</del><ins>declval&lt;T&gt;</ins>() : <del>__u</del><ins>declval&lt;U&gt;</ins>()) type;
};
</pre>
</blockquote>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="1256"></a>1256. <tt>weak_ptr</tt> comparison functions should be removed</h3>
<p><b>Section:</b> 20.8.15.3 [util.smartptr.weak] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2009-11-04  <b>Last modified:</b> 2009-11-04</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Additional to the necessary cleanup of the description of the the
<tt>weak_ptr</tt> component from 20.8.15.3 [util.smartptr.weak]
described in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1231">1231</a> it turns out that the currently deleted
comparison functions of <tt>weak_ptr</tt> are not needed at all: There
is no safe-bool conversion from <tt>weak_ptr</tt>, and it won't silently
chose a conversion to <tt>shared_ptr</tt>.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change 20.8.15.3 [util.smartptr.weak]/1 as indicated:
</p>

<blockquote><pre>namespace std {
template&lt;class T&gt; class weak_ptr {
public:
...
  <del>// comparisons</del>
  <del>template&lt;class Y&gt; bool operator&lt;(weak_ptr&lt;Y&gt; const&amp;) const = delete;</del>
  <del>template&lt;class Y&gt; bool operator&lt;=(weak_ptr&lt;Y&gt; const&amp;) const = delete;</del>
  <del>template&lt;class Y&gt; bool operator&gt;(weak_ptr&lt;Y&gt; const&amp;) const = delete;</del>
  <del>template&lt;class Y&gt; bool operator&gt;=(weak_ptr&lt;Y&gt; const&amp;) const = delete;</del>
};
...
</pre></blockquote>





<hr>
<h3><a name="1257"></a>1257. Header &lt;ios&gt; still contains a <code>concept_map</code></h3>
<p><b>Section:</b> 27.5 [iostreams.base] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Beman Dawes <b>Opened:</b> 2009-11-04  <b>Last modified:</b> 2009-11-04</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#iostreams.base">issues</a> in [iostreams.base].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The current WP still contains a <tt>concept_map</tt>.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change Iostreams base classes 27.5 [iostreams.base], Header &lt;ios&gt; synopsis, 
as indicated:
</p>

<blockquote><pre><del>concept_map ErrorCodeEnum&lt;io_errc&gt; { };</del>
<ins>template &lt;&gt; struct is_error_code_enum&lt;io_errc&gt; : true_type { }</ins>
error_code make_error_code(io_errc e);
error_condition make_error_condition(io_errc e);
const error_category&amp; iostream_category();
</pre></blockquote>






<hr>
<h3><a name="1258"></a>1258. std::function Effects clause impossible to satisfy</h3>
<p><b>Section:</b> 20.7.15.2.2 [func.wrap.func.mod] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2009-11-05  <b>Last modified:</b> 2009-11-05</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
As of 20.7.15.2.2 [func.wrap.func.mod]/2+ we have the following
prototype description:
</p>

<blockquote><pre>template&lt;class F, Allocator Alloc&gt;
  requires Callable&lt;F, ArgTypes...&gt;
    &amp;&amp; Convertible&lt;Callable&lt;F, ArgTypes...&gt;::result_type, R&gt;
  void assign(F, const Alloc&amp;);
</pre>
<blockquote>
<i>Effects:</i> <tt>function(f, a).swap(*this)</tt>
</blockquote>
</blockquote>

<p>
Two things: First the concept debris needs to be removed, second and
much more importantly, the effects clause is now impossible to satisfy,
because there is no constructor that would match the parameter sequence
(<tt>FunctionObject</tt>, <tt>Allocator</tt>) [plus the fact that no
<tt>f</tt> and no <tt>a</tt> is part of the signature]. The most
probable candidate is
</p>

<blockquote><pre>template&lt;class F, class A&gt; function(allocator_arg_t, const A&amp;, F);
</pre></blockquote>

<p>
and the effects clause needs to be adapted to use this signature.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change in 20.7.15.2.2 [func.wrap.func.mod] the complete prototype description as
indicated
</p>
<p><i>[
Question to
the editor: Shouldn't there a paragraph number in front of the Effects clause?
]</i></p>


<blockquote><pre><del>template&lt;class F, Allocator Alloc&gt;
  requires Callable&lt;F, ArgTypes...&gt;
    &amp;&amp; Convertible&lt;Callable&lt;F, ArgTypes...&gt;::result_type, R&gt;
  void assign(F, const Alloc&amp;);</del>
<ins>template&lt;class F, class A&gt; void assign(F f, const A&amp; a);</ins>
</pre>
<blockquote>
<ins>3</ins> <i>Effects:</i> <tt>function(<del>f, a</del><ins>allocator_arg, a,
f</ins>).swap(*this)</tt>
</blockquote>
</blockquote>





<hr>
<h3><a name="1259"></a>1259. Should initializer-list constructors move elements?</h3>
<p><b>Section:</b> 23.2.3 [sequence.reqmts] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Sean Hunt <b>Opened:</b> 2009-11-05  <b>Last modified:</b> 2009-11-06</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#sequence.reqmts">active issues</a> in [sequence.reqmts].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#sequence.reqmts">issues</a> in [sequence.reqmts].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
According to 23.2.3 [sequence.reqmts], <tt>X(il)</tt> is
equivalent to <tt>X(il.begin(), il.end())</tt>. Should it instead be
equivalent to <tt>X(move_iterator(il.begin()),
move_iterator(il.end()))</tt> so that needless copies are not made? This
doesn't seem ideal either - it may make more sense to provide two
overloads for the constructor, one for move and one for copy.
</p>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="1260"></a>1260. <tt>is_constructible&lt;int*,void*&gt;</tt> reports true</h3>
<p><b>Section:</b> 20.6.4.3 [meta.unary.prop] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Peter Dimov <b>Opened:</b> 2009-11-07  <b>Last modified:</b> 2009-11-08</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#meta.unary.prop">active issues</a> in [meta.unary.prop].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#meta.unary.prop">issues</a> in [meta.unary.prop].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The specification of <tt>is_constructible&lt;T,Args...&gt;</tt> in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n3000.pdf">N3000</a>
uses
</p>

<blockquote><pre>static_cast&lt;T&gt;(create&lt;Args&gt;()...)
</pre></blockquote>

<p>
for the one-argument case, but <tt>static_cast</tt> also permits
unwanted conversions such as <tt>void*</tt> to <tt>T*</tt> and
<tt>Base*</tt> to <tt>Derived*</tt>.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change 20.6.4.3 [meta.unary.prop], p6:
</p>

<blockquote>
<p>
the predicate condition for a template specialization
<tt>is_constructible&lt;T, Args&gt;</tt> shall be satisfied, if and only
if the following <del>expression <i>CE</i></del> <ins>variable
definition</ins> would be well-formed:
</p>

<ul>
<li>
<p>
if <tt>sizeof...(Args) == <ins>0</ins> <del>1</del></tt><del>, the expression</del>:
</p>
<blockquote><pre><del>static_cast&lt;T&gt;(create&lt;Args&gt;()...)</del>
<ins>T t;</ins>
</pre></blockquote>
</li>
<li>
<p>
otherwise <del>the expression</del>:
</p>
<blockquote><pre>T<ins> t</ins>(create&lt;Args&gt;()...);
</pre></blockquote>
</li>
</ul>
</blockquote>





</body></html>