<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head><title>C++ Standard Library Active Issues List</title>



<style type="text/css">
p {text-align:justify}
li {text-align:justify}
ins {background-color:#A0FFA0}
del {background-color:#FFA0A0}
</style></head><body>
<table>
<tbody><tr>
<td align="left">Doc. no.</td>
<td align="left">N2612=08-0122</td>
</tr>
<tr>
<td align="left">Date:</td>
<td align="left">2008-05-18</td>
</tr>
<tr>
<td align="left">Project:</td>
<td align="left">Programming Language C++</td>
</tr>
<tr>
<td align="left">Reply to:</td>
<td align="left">Howard Hinnant &lt;<a href="mailto:howard.hinnant@gmail.com">howard.hinnant@gmail.com</a>&gt;</td>
</tr>
</tbody></table>
<h1>C++ Standard Library Active Issues List (Revision R56)</h1>

  <p>Reference ISO/IEC IS 14882:1998(E)</p>
  <p>Also see:</p>
  <ul>
      <li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-toc.html">Table of Contents</a> for all library issues.</li>
      <li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html">Index by Section</a> for all library issues.</li>
      <li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html">Index by Status</a> for all library issues.</li>
      <li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html">Library Defect Reports List</a></li>
      <li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html">Library Closed Issues List</a></li>
  </ul>
  <p>The purpose of this document is to record the status of issues
  which have come before the Library Working Group (LWG) of the ANSI
  (J16) and ISO (WG21) C++ Standards Committee. Issues represent
  potential defects in the ISO/IEC IS 14882:1998(E) document.  Issues
  are not to be used to request new features. </p>

  <p>This document contains only library issues which are actively being
  considered by the Library Working Group. That is, issues which have a
  status of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>, 
  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>, and <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Review">Review</a>. See
  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html">Library Defect Reports List</a> for issues considered defects and 
  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html">Library Closed Issues List</a> for issues considered closed.</p>

  <p>The issues in these lists are not necessarily formal ISO Defect
  Reports (DR's). While some issues will eventually be elevated to
  official Defect Report status, other issues will be disposed of in
  other ways. See <a href="#Status">Issue Status</a>.</p>

  <p>This document is in an experimental format designed for both
  viewing via a world-wide web browser and hard-copy printing. It
  is available as an HTML file for browsing or PDF file for
  printing.</p>

  <p>Prior to Revision 14, library issues lists existed in two slightly
  different versions; a Committee Version and a Public
  Version. Beginning with Revision 14 the two versions were combined
  into a single version.</p>

  <p>This document includes <i>[bracketed italicized notes]</i> as a
  reminder to the LWG of current progress on issues. Such notes are
  strictly unofficial and should be read with caution as they may be
  incomplete or incorrect. Be aware that LWG support for a particular
  resolution can quickly change if new viewpoints or killer examples are
  presented in subsequent discussions.</p>

  <p>For the most current official version of this document see 
  <a href="http://www.open-std.org/jtc1/sc22/wg21/">http://www.open-std.org/jtc1/sc22/wg21/</a>.
  Requests for further information about this document should include
  the document number above, reference ISO/IEC 14882:1998(E), and be
  submitted to Information Technology Industry Council (ITI), 1250 Eye
  Street NW, Washington, DC 20005.</p>

  <p>Public information as to how to obtain a copy of the C++ Standard,
  join the standards committee, submit an issue, or comment on an issue
  can be found in the comp.std.c++ FAQ.
  Public discussion of C++ Standard related issues occurs on <a href="news:comp.std.c++">news:comp.std.c++</a>.
  </p>

 <p>For committee members, files available on the committee's private
  web site include the HTML version of the Standard itself. HTML
  hyperlinks from this issues list to those files will only work for
  committee members who have downloaded them into the same disk
  directory as the issues list files.  </p>

<h2>Revision History</h2>
<ul>
<li>R56: 
2008-05-16 pre-Sophia Antipolis mailing.
<ul>
<li><b>Summary:</b><ul>
<li>191 open issues, up by 24.</li>
<li>647 closed issues, up by 1.</li>
<li>838 issues total, up by 25.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#814">814</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#815">815</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#816">816</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#817">817</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#818">818</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#819">819</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#820">820</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#821">821</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#822">822</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#823">823</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#824">824</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#825">825</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#826">826</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#827">827</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#828">828</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#829">829</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#830">830</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#831">831</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#832">832</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#833">833</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#834">834</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#835">835</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#836">836</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#837">837</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#838">838</a>.</li>
<li>Changed the following issues from New to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#802">802</a>.</li>
</ul></li>
</ul>
</li>
<li>R55: 
2008-03-14 post-Bellevue mailing.
<ul>
<li><b>Summary:</b><ul>
<li>167 open issues, down by 39.</li>
<li>646 closed issues, up by 65.</li>
<li>813 issues total, up by 26.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following Dup issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#795">795</a>.</li>
<li>Added the following NAD issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#790">790</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#791">791</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#796">796</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#797">797</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#799">799</a>.</li>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#788">788</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#794">794</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#802">802</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#804">804</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#805">805</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#806">806</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#807">807</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#808">808</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#809">809</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#810">810</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#811">811</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#812">812</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#813">813</a>.</li>
<li>Added the following Open issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#793">793</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#800">800</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#801">801</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#803">803</a>.</li>
<li>Added the following Ready issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#789">789</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#792">792</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#798">798</a>.</li>
<li>Changed the following issues from NAD Future to Dup: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#116">116</a>.</li>
<li>Changed the following issues from NAD Future to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#188">188</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#323">323</a>.</li>
<li>Changed the following issues from New to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#729">729</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#730">730</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#731">731</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#733">733</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#735">735</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#736">736</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#737">737</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#739">739</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#741">741</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#745">745</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#748">748</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#763">763</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#764">764</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#773">773</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#784">784</a>.</li>
<li>Changed the following issues from Open to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#388">388</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#462">462</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#579">579</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#627">627</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#653">653</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#686">686</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#707">707</a>.</li>
<li>Changed the following issues from NAD Future to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#140">140</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#390">390</a>.</li>
<li>Changed the following issues from Open to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#529">529</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#626">626</a>.</li>
<li>Changed the following issues from Review to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#645">645</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#684">684</a>.</li>
<li>Changed the following issues from NAD Future to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#128">128</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#180">180</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#190">190</a>.</li>
<li>Changed the following issues from New to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#617">617</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#718">718</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#719">719</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#720">720</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#724">724</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#732">732</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#734">734</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#742">742</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#747">747</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#750">750</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#753">753</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#756">756</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#760">760</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#762">762</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#767">767</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#774">774</a>.</li>
<li>Changed the following issues from Ready to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#675">675</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#676">676</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#688">688</a>.</li>
<li>Changed the following issues from New to Pending NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#709">709</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#717">717</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#725">725</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#738">738</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#754">754</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#757">757</a>.</li>
<li>Changed the following issues from Open to Pending NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#424">424</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#557">557</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#625">625</a>.</li>
<li>Changed the following issues from New to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#710">710</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#715">715</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#722">722</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#740">740</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#743">743</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#744">744</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#746">746</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#749">749</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#755">755</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#758">758</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#759">759</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#761">761</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#766">766</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#768">768</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#770">770</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#775">775</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#777">777</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#778">778</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#781">781</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#782">782</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#783">783</a>.</li>
<li>Changed the following issues from Open to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#387">387</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#471">471</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#550">550</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#612">612</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#629">629</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#673">673</a>.</li>
<li>Changed the following issues from Review to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#518">518</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#574">574</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#596">596</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#618">618</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#638">638</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#672">672</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#685">685</a>.</li>
<li>Changed the following issues from New to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#711">711</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#728">728</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#771">771</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#776">776</a>.</li>
<li>Changed the following issues from Open to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#539">539</a>.</li>
<li>Changed the following issues from Ready to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#561">561</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#562">562</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#563">563</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#567">567</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#581">581</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#620">620</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#621">621</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#622">622</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#623">623</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#624">624</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#661">661</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#664">664</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#665">665</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#666">666</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#674">674</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#679">679</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#680">680</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#687">687</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#689">689</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#693">693</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#694">694</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#695">695</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#700">700</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#703">703</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#705">705</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#706">706</a>.</li>
<li>Changed the following issues from Tentatively Ready to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#527">527</a>.</li>
</ul></li>
</ul>
</li>
<li>R54: 
2008-02-01 pre-Bellevue mailing.
<ul>
<li><b>Summary:</b><ul>
<li>206 open issues, up by 23.</li>
<li>581 closed issues, up by 0.</li>
<li>787 issues total, up by 23.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#765">765</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#766">766</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#767">767</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#768">768</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#769">769</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#770">770</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#771">771</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#772">772</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#773">773</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#774">774</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#775">775</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#776">776</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#777">777</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#778">778</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#779">779</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#780">780</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#781">781</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#782">782</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#783">783</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#784">784</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#785">785</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#786">786</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#787">787</a>.</li>
<li>Changed the following issues from NAD Future to Dup: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#105">105</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#348">348</a>.</li>
<li>Changed the following issues from NAD Future to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#353">353</a>.</li>
<li>Changed the following issues from New to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#697">697</a>.</li>
<li>Changed the following issues from NAD Future to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#388">388</a>.</li>
<li>Changed the following issues from Open to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#527">527</a>.</li>
</ul></li>
</ul>
</li>
<li>R53: 
2007-12-09 mid-term mailing.
<ul>
<li><b>Summary:</b><ul>
<li>183 open issues, up by 11.</li>
<li>581 closed issues, down by 1.</li>
<li>764 issues total, up by 10.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#755">755</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#756">756</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#757">757</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#758">758</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#759">759</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#760">760</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#761">761</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#762">762</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#763">763</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#764">764</a>.</li>
<li>Changed the following issues from NAD to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#463">463</a>.</li>
<li>Changed the following issues from Pending WP to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#607">607</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#608">608</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#654">654</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#655">655</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#677">677</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#682">682</a>.</li>
</ul></li>
</ul>
</li>
<li>R52: 
2007-10-19 post-Kona mailing.
<ul>
<li><b>Summary:</b><ul>
<li>172 open issues, up by 4.</li>
<li>582 closed issues, up by 27.</li>
<li>754 issues total, up by 31.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#724">724</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#725">725</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#726">726</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#727">727</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#728">728</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#729">729</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#730">730</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#731">731</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#732">732</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#733">733</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#734">734</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#735">735</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#736">736</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#737">737</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#738">738</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#739">739</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#740">740</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#741">741</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#742">742</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#743">743</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#744">744</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#745">745</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#746">746</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#747">747</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#748">748</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#749">749</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#750">750</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#751">751</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#752">752</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#753">753</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#754">754</a>.</li>
<li>Changed the following issues from NAD Future to Dup: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#77">77</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#350">350</a>.</li>
<li>Changed the following issues from New to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#639">639</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#657">657</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#663">663</a>.</li>
<li>Changed the following issues from Open to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#548">548</a>.</li>
<li>Changed the following issues from New to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#546">546</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#550">550</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#564">564</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#565">565</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#573">573</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#585">585</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#588">588</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#627">627</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#629">629</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#630">630</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#632">632</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#635">635</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#653">653</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#659">659</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#667">667</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#668">668</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#669">669</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#670">670</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#671">671</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#673">673</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#686">686</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#704">704</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#707">707</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#708">708</a>.</li>
<li>Changed the following issues from New to Pending NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#393">393</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#592">592</a>.</li>
<li>Changed the following issues from New to Pending WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#607">607</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#608">608</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#654">654</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#655">655</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#677">677</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#682">682</a>.</li>
<li>Changed the following issues from New to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#561">561</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#562">562</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#563">563</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#567">567</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#581">581</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#595">595</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#620">620</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#621">621</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#622">622</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#623">623</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#624">624</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#661">661</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#664">664</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#665">665</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#666">666</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#674">674</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#675">675</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#676">676</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#679">679</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#687">687</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#688">688</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#689">689</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#693">693</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#694">694</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#695">695</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#700">700</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#703">703</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#705">705</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#706">706</a>.</li>
<li>Changed the following issues from Open to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#680">680</a>.</li>
<li>Changed the following issues from New to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#574">574</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#596">596</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#618">618</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#638">638</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#645">645</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#672">672</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#684">684</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#685">685</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#691">691</a>.</li>
<li>Changed the following issues from New to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#552">552</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#634">634</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#650">650</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#651">651</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#652">652</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#678">678</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#681">681</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#699">699</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#712">712</a>.</li>
<li>Changed the following issues from Open to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#258">258</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#401">401</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#524">524</a>.</li>
<li>Changed the following issues from Ready to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#488">488</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#577">577</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#660">660</a>.</li>
</ul></li>
</ul>
</li>
<li>R51: 
2007-09-09 pre-Kona mailing.
<ul>
<li><b>Summary:</b><ul>
<li>168 open issues, up by 15.</li>
<li>555 closed issues, up by 0.</li>
<li>723 issues total, up by 15.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#709">709</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#710">710</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#711">711</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#712">712</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#713">713</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#714">714</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#715">715</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#716">716</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#717">717</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#718">718</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#719">719</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#720">720</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#721">721</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#722">722</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#723">723</a>.</li>
</ul></li>
</ul>
</li>
<li>R50: 
2007-08-05 post-Toronto mailing.
<ul>
<li><b>Summary:</b><ul>
<li>153 open issues, down by 5.</li>
<li>555 closed issues, up by 17.</li>
<li>708 issues total, up by 12.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#697">697</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#698">698</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#699">699</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#700">700</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#701">701</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#702">702</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#703">703</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#704">704</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#705">705</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#706">706</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#707">707</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#708">708</a>.</li>
<li>Changed the following issues from New to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#583">583</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#584">584</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#662">662</a>.</li>
<li>Changed the following issues from Open to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#528">528</a>.</li>
<li>Changed the following issues from New to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#637">637</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#647">647</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#658">658</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#690">690</a>.</li>
<li>Changed the following issues from Open to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#525">525</a>.</li>
<li>Changed the following issues from Pending NAD Editorial to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#553">553</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#571">571</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#591">591</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#633">633</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#636">636</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#641">641</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#642">642</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#648">648</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#649">649</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#656">656</a>.</li>
<li>Changed the following issues from New to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#579">579</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#631">631</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#680">680</a>.</li>
<li>Changed the following issues from Pending WP to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#258">258</a>.</li>
<li>Changed the following issues from Ready to Pending WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#644">644</a>.</li>
<li>Changed the following issues from New to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#577">577</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#660">660</a>.</li>
<li>Changed the following issues from Open to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#488">488</a>.</li>
<li>Changed the following issues from Open to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#518">518</a>.</li>
<li>Changed the following issues from Ready to TRDec: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#604">604</a>.</li>
<li>Changed the following issues from DR to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#453">453</a>.</li>
<li>Changed the following issues from Ready to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#531">531</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#551">551</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#566">566</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#628">628</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#640">640</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#643">643</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#646">646</a>.</li>
</ul></li>
</ul>
</li>
<li>R49: 
2007-06-23 pre-Toronto mailing.
<ul>
<li><b>Summary:</b><ul>
<li>158 open issues, up by 13.</li>
<li>538 closed issues, up by 7.</li>
<li>696 issues total, up by 20.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#677">677</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#678">678</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#679">679</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#680">680</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#681">681</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#682">682</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#684">684</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#685">685</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#686">686</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#687">687</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#688">688</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#689">689</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#690">690</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#691">691</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#692">692</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#693">693</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#694">694</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#695">695</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#696">696</a>.</li>
<li>Added the following Pending NAD Editorial issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#683">683</a>.</li>
<li>Changed the following issues from New to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#587">587</a>.</li>
<li>Changed the following issues from Open to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#590">590</a>.</li>
<li>Changed the following issues from New to Pending NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#636">636</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#642">642</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#648">648</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#649">649</a>.</li>
</ul></li>
</ul>
</li>
<li>R48: 
2007-05-06 post-Oxford mailing.
<ul>
<li><b>Summary:</b><ul>
<li>145 open issues, down by 33.</li>
<li>531 closed issues, up by 53.</li>
<li>676 issues total, up by 20.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#657">657</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#658">658</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#659">659</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#660">660</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#661">661</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#662">662</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#663">663</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#664">664</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#665">665</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#666">666</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#667">667</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#668">668</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#669">669</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#670">670</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#671">671</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#672">672</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#673">673</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#674">674</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#675">675</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#676">676</a>.</li>
<li>Changed the following issues from Tentatively Ready to Dup: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#479">479</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#536">536</a>.</li>
<li>Changed the following issues from Tentatively Ready to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#385">385</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#463">463</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#466">466</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#470">470</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#515">515</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#526">526</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#547">547</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#560">560</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#572">572</a>.</li>
<li>Changed the following issues from NAD to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#351">351</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#357">357</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#368">368</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#499">499</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#504">504</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#512">512</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#513">513</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#514">514</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#516">516</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#544">544</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#549">549</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#555">555</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#558">558</a>.</li>
<li>Changed the following issues from Tentatively Ready to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#482">482</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#615">615</a>.</li>
<li>Changed the following issues from NAD_Future to NAD Future: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#77">77</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#105">105</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#111">111</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#116">116</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#128">128</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#138">138</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#140">140</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#149">149</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#180">180</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#188">188</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#190">190</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#219">219</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#323">323</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#348">348</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#350">350</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#353">353</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#388">388</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#390">390</a>.</li>
<li>Changed the following issues from Tentatively Ready to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#471">471</a>.</li>
<li>Changed the following issues from New to Pending NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#633">633</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#641">641</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#656">656</a>.</li>
<li>Changed the following issues from Tentatively Ready to Pending NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#532">532</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#553">553</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#571">571</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#591">591</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#594">594</a>.</li>
<li>Changed the following issues from Tentatively Ready to Pending WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#258">258</a>.</li>
<li>Changed the following issues from New to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#566">566</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#628">628</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#640">640</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#643">643</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#644">644</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#646">646</a>.</li>
<li>Changed the following issues from Review to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#531">531</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#551">551</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#604">604</a>.</li>
<li>Changed the following issues from Ready to TRDec: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#598">598</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#599">599</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#600">600</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#601">601</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#602">602</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#603">603</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#605">605</a>.</li>
<li>Changed the following issues from Ready to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#543">543</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#545">545</a>.</li>
<li>Changed the following issues from Tentatively Ready to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#201">201</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#206">206</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#233">233</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#254">254</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#416">416</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#422">422</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#456">456</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#534">534</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#542">542</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#559">559</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#575">575</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#576">576</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#578">578</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#586">586</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#589">589</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#593">593</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#609">609</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#610">610</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#611">611</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#613">613</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#616">616</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#619">619</a>.</li>
</ul></li>
</ul>
</li>
<li>R47: 
2007-03-09 pre-Oxford mailing.
<ul>
<li><b>Summary:</b><ul>
<li>178 open issues, up by 37.</li>
<li>478 closed issues, up by 0.</li>
<li>656 issues total, up by 37.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#620">620</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#621">621</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#622">622</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#623">623</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#624">624</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#627">627</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#628">628</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#629">629</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#630">630</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#631">631</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#632">632</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#633">633</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#634">634</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#635">635</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#636">636</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#637">637</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#638">638</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#639">639</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#640">640</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#641">641</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#642">642</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#643">643</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#644">644</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#645">645</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#646">646</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#647">647</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#648">648</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#649">649</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#650">650</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#651">651</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#652">652</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#653">653</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#654">654</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#655">655</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#656">656</a>.</li>
<li>Added the following Open issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#625">625</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#626">626</a>.</li>
<li>Changed the following issues from New to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#570">570</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#580">580</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#582">582</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#590">590</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#612">612</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#614">614</a>.</li>
<li>Changed the following issues from New to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#547">547</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#553">553</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#560">560</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#571">571</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#572">572</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#575">575</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#576">576</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#578">578</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#586">586</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#589">589</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#591">591</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#593">593</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#594">594</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#609">609</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#610">610</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#611">611</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#613">613</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#615">615</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#616">616</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#619">619</a>.</li>
<li>Changed the following issues from Open to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#201">201</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#206">206</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#233">233</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#254">254</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#258">258</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#385">385</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#416">416</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#422">422</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#456">456</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#463">463</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#466">466</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#470">470</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#471">471</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#479">479</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#482">482</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#515">515</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#526">526</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#532">532</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#536">536</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#542">542</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#559">559</a>.</li>
<li>Changed the following issues from Review to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#534">534</a>.</li>
</ul></li>
</ul>
</li>
<li>R46: 
2007-01-12 mid-term mailing.
<ul>
<li><b>Summary:</b><ul>
<li>141 open issues, up by 11.</li>
<li>478 closed issues, down by 1.</li>
<li>619 issues total, up by 10.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#610">610</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#619">619</a>.</li>
</ul></li>
</ul>
</li>
<li>R45: 
2006-11-03 post-Portland mailing.
<ul>
<li><b>Summary:</b><ul>
<li>130 open issues, up by 0.</li>
<li>479 closed issues, up by 17.</li>
<li>609 issues total, up by 17.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Moved issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#520">520</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#521">521</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#530">530</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#535">535</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#537">537</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#538">538</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#540">540</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#541">541</a> to WP.</li>
<li>Moved issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#504">504</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#512">512</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#516">516</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#544">544</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#549">549</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#554">554</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#555">555</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#558">558</a> to NAD.</li>
<li>Moved issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#569">569</a> to Dup.</li>
<li>Moved issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#518">518</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#523">523</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#524">524</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#542">542</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#556">556</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#557">557</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#559">559</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#597">597</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#606">606</a> to Open.</li>
<li>Moved issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#543">543</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#545">545</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#549">549</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#549">549</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#598">598</a> - <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#603">603</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#605">605</a> to Ready.</li>
<li>Moved issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#531">531</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#551">551</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#604">604</a> to Review.</li>
<li>Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#593">593</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#609">609</a>.</li>
</ul></li>
</ul>
</li>
<li>R44: 
2006-09-08 pre-Portland mailing.
<ul>
<li><b>Summary:</b><ul>
<li>130 open issues, up by 6.</li>
<li>462 closed issues, down by 1.</li>
<li>592 issues total, up by 5.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#583">583</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#592">592</a>.</li>
</ul></li>
</ul>
</li>
<li>R43: 
2006-06-23 mid-term mailing.
<ul>
<li><b>Summary:</b><ul>
<li>124 open issues, up by 14.</li>
<li>463 closed issues, down by 1.</li>
<li>587 issues total, up by 13.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#575">575</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#582">582</a>.</li>
<li>Reopened <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#255">255</a>.</li>
<li>Moved issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#520">520</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#541">541</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#544">544</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#569">569</a> to Tentatively Ready.</li>
</ul></li>
</ul>
</li>
<li>R42: 
2006-04-21 post-Berlin mailing.
<ul>
<li><b>Summary:</b><ul>
<li>110 open issues, down by 16.</li>
<li>464 closed issues, up by 24.</li>
<li>574 issues total, up by 8.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#567">567</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#572">572</a>.</li>
<li>Moved issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#499">499</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#501">501</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#506">506</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#509">509</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#511">511</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#513">513</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#514">514</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#517">517</a> to NAD.</li>
<li>Moved issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#502">502</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#503">503</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#515">515</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#516">516</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#522">522</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#525">525</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#529">529</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#532">532</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#536">536</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#539">539</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#548">548</a> to Open.</li>
<li>Moved issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#504">504</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#512">512</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#521">521</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#530">530</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#531">531</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#535">535</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#537">537</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#538">538</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#540">540</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#549">549</a> to Ready.</li>
<li>Moved issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#247">247</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#294">294</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#362">362</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#369">369</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#371">371</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#376">376</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#384">384</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#475">475</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#478">478</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#495">495</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#497">497</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#505">505</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#507">507</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#508">508</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#519">519</a> to WP.</li>
<li>Moved issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#534">534</a> to Review.</li>
</ul></li>
</ul>
</li>
<li>R41: 
2006-02-24 pre-Berlin mailing.
<ul>
<li><b>Summary:</b><ul>
<li>126 open issues, up by 31.</li>
<li>440 closed issues, up by 0.</li>
<li>566 issues total, up by 31.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#536">536</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#566">566</a>.</li>
<li>Moved <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#342">342</a> from Ready to Open.</li>
<li>Reopened <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#309">309</a>.</li>
</ul></li>
</ul>
</li>
<li>R40: 
2005-12-16 mid-term mailing.
<ul>
<li><b>Summary:</b><ul>
<li>95 open issues.</li>
<li>440 closed issues.</li>
<li>535 issues total.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#529">529</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#535">535</a>.</li>
</ul></li>
</ul>
</li>
<li>R39: 
2005-10-14 post-Mont Tremblant mailing.
Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#526">526</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#528">528</a>.
Moved issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#280">280</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#461">461</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#464">464</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#465">465</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#467">467</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#468">468</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#474">474</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#496">496</a> from Ready to WP as per the vote from Mont Tremblant.
Moved issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#247">247</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#294">294</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#342">342</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#362">362</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#369">369</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#371">371</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#376">376</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#384">384</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#475">475</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#478">478</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#495">495</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#497">497</a> from Review to Ready.
Moved issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#498">498</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#504">504</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#506">506</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#509">509</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#510">510</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#511">511</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#512">512</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#513">513</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#514">514</a> from New to Open.
Moved issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#505">505</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#507">507</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#508">508</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#519">519</a> from New to Ready.
Moved issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#500">500</a> from New to NAD.
Moved issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#518">518</a> from New to Review.
</li>
<li>R38: 
2005-07-03 pre-Mont Tremblant mailing.
Merged open TR1 issues in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#504">504</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#522">522</a>.
Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#523">523</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#523">523</a>
</li>
<li>R37: 
2005-06 mid-term mailing.
Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#498">498</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#503">503</a>.
</li>
<li>R36: 
2005-04 post-Lillehammer mailing. All issues in "ready" status except
for <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#454">454</a> were moved to "DR" status, and all issues
previously in "DR" status were moved to "WP".
</li>
<li>R35: 
2005-03 pre-Lillehammer mailing.
</li>
<li>R34: 
2005-01 mid-term mailing.  Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#488">488</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#494">494</a>.
</li>
<li>R33: 
2004-11 post-Redmond mailing. Reflects actions taken in Redmond.
</li>
<li>R32: 
2004-09 pre-Redmond mailing: reflects new proposed resolutions and
new issues received after the 2004-07 mailing.  Added
new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#479">479</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#481">481</a>.
</li>
<li>R31: 
2004-07 mid-term mailing: reflects new proposed resolutions and
new issues received after the post-Sydney mailing.  Added
new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#463">463</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#478">478</a>.
</li>
<li>R30: 
Post-Sydney mailing: reflects decisions made at the Sydney meeting.
Voted all "Ready" issues from R29 into the working paper.
Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#460">460</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#462">462</a>.
</li>
<li>R29: 
Pre-Sydney mailing.  Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#441">441</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#457">457</a>.
</li>
<li>R28: 
Post-Kona mailing: reflects decisions made at the Kona meeting.
Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#432">432</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#440">440</a>.
</li>
<li>R27: 
Pre-Kona mailing.  Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#404">404</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#431">431</a>.
</li>
<li>R26: 
Post-Oxford mailing: reflects decisions made at the Oxford meeting.
All issues in Ready status were voted into DR status.  All issues in
DR status were voted into WP status.
</li>
<li>R25: 
Pre-Oxford mailing.  Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#390">390</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#402">402</a>.
</li>
<li>R24: 
Post-Santa Cruz mailing: reflects decisions made at the Santa Cruz
meeting.  All Ready issues from R23 with the exception of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#253">253</a>, which has been given a new proposed resolution, were
moved to DR status.  Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#383">383</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#389">389</a>.  (Issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#387">387</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#389">389</a> were discussed
at the meeting.)  Made progress on issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#225">225</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#226">226</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#229">229</a>: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#225">225</a> and <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#229">229</a> have been moved to Ready status, and the only remaining
concerns with <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#226">226</a> involve wording.
</li>
<li>R23: 
Pre-Santa Cruz mailing.  Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#367">367</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#382">382</a>.
Moved issues in the TC to TC status.
</li>
<li>R22: 
Post-Curaao mailing.  Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#362">362</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#366">366</a>.
</li>
<li>R21: 
Pre-Curaao mailing.  Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#351">351</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#361">361</a>.
</li>
<li>R20: 
Post-Redmond mailing; reflects actions taken in Redmond.  Added
new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#336">336</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#350">350</a>, of which issues 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#347">347</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#350">350</a> were added since Redmond, hence
not discussed at the meeting.  

All Ready issues were moved to DR status, with the exception of issues
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#284">284</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#241">241</a>, and <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#267">267</a>.

Noteworthy issues discussed at Redmond include 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#120">120</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#202">202</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#226">226</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#233">233</a>, 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#270">270</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#253">253</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#254">254</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#323">323</a>.
</li>
<li>R19: 
Pre-Redmond mailing.  Added new issues 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#323">323</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#335">335</a>.
</li>
<li>R18: 
Post-Copenhagen mailing; reflects actions taken in Copenhagen.
Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#312">312</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#317">317</a>, and discussed
new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#271">271</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#314">314</a>.

Changed status of issues
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#103">103</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#118">118</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#136">136</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#153">153</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#165">165</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#171">171</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#183">183</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#184">184</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#185">185</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#186">186</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#214">214</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#221">221</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#234">234</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#237">237</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#243">243</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#248">248</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#251">251</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#252">252</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#256">256</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#260">260</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#261">261</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#262">262</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#263">263</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#265">265</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#268">268</a>
to DR.

Changed status of issues
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#49">49</a>  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#109">109</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#117">117</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#182">182</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#228">228</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#230">230</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#232">232</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#235">235</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#238">238</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#241">241</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#242">242</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#250">250</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#259">259</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#264">264</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#266">266</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#267">267</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#271">271</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#272">272</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#273">273</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#275">275</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#281">281</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#284">284</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#285">285</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#286">286</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#288">288</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#292">292</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#295">295</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#297">297</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#298">298</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#301">301</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#303">303</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#306">306</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#307">307</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#308">308</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#312">312</a>
to Ready.

Closed issues 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#111">111</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#277">277</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#279">279</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#287">287</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#289">289</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#293">293</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#302">302</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#313">313</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#314">314</a>
as NAD.

</li>
<li>R17: 
Pre-Copenhagen mailing.  Converted issues list to XML.  Added proposed
resolutions for issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#49">49</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#76">76</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#91">91</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#235">235</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#250">250</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#267">267</a>.
Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#278">278</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#311">311</a>.
</li>
<li>R16:  
post-Toronto mailing; reflects actions taken in Toronto. Added new
issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#265">265</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#277">277</a>.  Changed status of issues
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#3">3</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#8">8</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#9">9</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#19">19</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#26">26</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#31">31</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#61">61</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#63">63</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#86">86</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#108">108</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#112">112</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#114">114</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#115">115</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#122">122</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#127">127</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#129">129</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#134">134</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#137">137</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#142">142</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#144">144</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#146">146</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#147">147</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#159">159</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#164">164</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#170">170</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#181">181</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#199">199</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#208">208</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#209">209</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#210">210</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#211">211</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#212">212</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#217">217</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#220">220</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#222">222</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#223">223</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#224">224</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#227">227</a> to "DR".  Reopened issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#23">23</a>. Reopened
issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#187">187</a>. Changed issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#2">2</a> and
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#4">4</a> to NAD. Fixed a typo in issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#17">17</a>. Fixed
issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#70">70</a>: signature should be changed both places it
appears. Fixed issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#160">160</a>: previous version didn't fix
the bug in enough places.
</li>
<li>R15: 
pre-Toronto mailing. Added issues
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#233">233</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#264">264</a>. Some small HTML formatting
changes so that we pass Weblint tests.
</li>
<li>R14: 
post-Tokyo II mailing; reflects committee actions taken in
Tokyo. Added issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#228">228</a> to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#232">232</a>. (00-0019R1/N1242)
</li>
<li>R13: 
pre-Tokyo II updated: Added issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#212">212</a> to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#227">227</a>.
</li>
<li>R12: 
pre-Tokyo II mailing: Added issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#199">199</a> to
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#211">211</a>. Added "and paragraph 5" to the proposed resolution
of issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#29">29</a>.  Add further rationale to issue
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#178">178</a>.
</li>
<li>R11: 
post-Kona mailing: Updated to reflect LWG and full committee actions
in Kona (99-0048/N1224). Note changed resolution of issues
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#4">4</a> and <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#38">38</a>. Added issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#196">196</a>
to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#198">198</a>. Closed issues list split into "defects" and
"closed" documents.  Changed the proposed resolution of issue
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#4">4</a> to NAD, and changed the wording of proposed resolution
of issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#38">38</a>.
</li>
<li>R10: 
pre-Kona updated.  Added proposed resolutions <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#83">83</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#86">86</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#91">91</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#92">92</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#109">109</a>. Added issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#190">190</a> to
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#195">195</a>. (99-0033/D1209, 14 Oct 99)
</li>
<li>R9: 
pre-Kona mailing.  Added issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#140">140</a> to
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#189">189</a>. Issues list split into separate "active" and
"closed" documents. (99-0030/N1206, 25 Aug 99)
</li>
<li>R8: 
post-Dublin mailing. Updated to reflect LWG and full committee actions
in Dublin. (99-0016/N1193, 21 Apr 99)
</li>
<li>R7: 
pre-Dublin updated: Added issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#130">130</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#131">131</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#132">132</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#133">133</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#134">134</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#135">135</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#136">136</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#137">137</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#138">138</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#139">139</a> (31 Mar 99)
</li>
<li>R6: 
pre-Dublin mailing. Added issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#127">127</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#128">128</a>,
and <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#129">129</a>.  (99-0007/N1194, 22 Feb 99)
</li>
<li>R5: 
update issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#103">103</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#112">112</a>; added issues
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#114">114</a> to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#126">126</a>. Format revisions to prepare
for making list public. (30 Dec 98)
</li>
<li>R4: 
post-Santa Cruz II updated: Issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#110">110</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#111">111</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#112">112</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#113">113</a> added, several
issues corrected. (22 Oct 98)
</li>
<li>R3: 
post-Santa Cruz II: Issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#94">94</a> to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#109">109</a>
added, many issues updated to reflect LWG consensus (12 Oct 98)
</li>
<li>R2: 
pre-Santa Cruz II: Issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#73">73</a> to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#93">93</a> added,
issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#17">17</a> updated. (29 Sep 98)
</li>
<li>R1: 
Correction to issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#55">55</a> resolution, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#60">60</a> code
format, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#64">64</a> title. (17 Sep 98)
</li>
</ul>

<h2><a name="Status"></a>Issue Status</h2>

  <p><b><a name="New">New</a></b> - The issue has not yet been
  reviewed by the LWG. Any <b>Proposed Resolution</b> is purely a
  suggestion from the issue submitter, and should not be construed as
  the view of LWG.</p>

  <p><b><a name="Open">Open</a></b> - The LWG has discussed the issue
  but is not yet ready to move the issue forward. There are several
  possible reasons for open status:</p>
     <ul>
        <li>Consensus may have not yet have been reached as to how to deal
            with the issue.</li>
        <li>Informal consensus may have been reached, but the LWG awaits
            exact <b>Proposed Resolution</b> wording for review.</li>
        <li>The LWG wishes to consult additional technical experts before
            proceeding.</li>
        <li>The issue may require further study.</li>
     </ul>

  <p>A <b>Proposed Resolution</b> for an open issue is still not be
  construed as the view of LWG. Comments on the current state of
  discussions are often given at the end of open issues in an italic
  font. Such comments are for information only and should not be given
  undue importance.</p>

  <p><b><a name="Dup">Dup</a></b> - The LWG has reached consensus that
  the issue is a duplicate of another issue, and will not be further
  dealt with. A <b>Rationale</b> identifies the duplicated issue's
  issue number.  </p>

  <p><b><a name="NAD">NAD</a></b> - The LWG has reached consensus that
  the issue is not a defect in the Standard.</p>

  <p><b><a name="NAD Editorial">NAD Editorial</a></b> - The LWG has reached consensus that
  the issue can either be handled editorially, or is handled by a paper (usually
  linked to in the rationale).</p>

  <p><b><a name="NAD Future">NAD Future</a></b> - In addition to the regular
  status, the LWG believes that this issue should be revisited at the
  next revision of the standard.</p>

  <p><b><a name="Review">Review</a></b> - Exact wording of a
  <b>Proposed Resolution</b> is now available for review on an issue
  for which the LWG previously reached informal consensus.</p>

  <p><b><a name="Tentatively Ready">Tentatively Ready</a></b> - The issue has
  been reviewed online, but not in a meeting, and some support has been formed
  for the proposed resolution.  Tentatively Ready issues may be moved to Ready
  and forwarded to full committee within the same meeting.  Unlike Ready issues
  they will be reviewed in subcommittee prior to forwarding to full committee.</p>

  <p><b><a name="Ready">Ready</a></b> - The LWG has reached consensus
  that the issue is a defect in the Standard, the <b>Proposed
  Resolution</b> is correct, and the issue is ready to forward to the
  full committee for further action as a Defect Report (DR).</p>

  <p><b><a name="DR">DR</a></b> - (Defect Report) - The full J16
  committee has voted to forward the issue to the Project Editor to be
  processed as a Potential Defect Report. The Project Editor reviews
  the issue, and then forwards it to the WG21 Convenor, who returns it
  to the full committee for final disposition. This issues list
  accords the status of DR to all these Defect Reports regardless of
  where they are in that process.</p>

  <p><b><a name="TC">TC</a></b> - (Technical Corrigenda) - The full
  WG21 committee has voted to accept the Defect Report's Proposed
  Resolution as a Technical Corrigenda.  Action on this issue is thus
  complete and no further action is possible under ISO rules.</p>

  <p><b><a name="TRDec">TRDec</a></b> - (Decimal TR defect) - The 
  LWG has voted to accept the Defect Report's Proposed
  Resolution into the Decimal TR.  Action on this issue is thus
  complete and no further action is expected.</p>

  <p><b><a name="WP">WP</a></b> - (Working Paper) - The proposed
  resolution has not been accepted as a Technical Corrigendum, but
  the full WG21 committee has voted to apply the Defect Report's Proposed
  Resolution to the working paper.</p>

  <p><b>Pending</b> - This is a <i>status qualifier</i>.  When prepended to
  a status this indicates the issue has been
  processed by the committee, and a decision has been made to move the issue to
  the associated unqualified status.  However for logistical reasons the indicated
  outcome of the issue has not yet appeared in the latest working paper.

  </p><p>Issues are always given the status of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a> when
  they first appear on the issues list. They may progress to
  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a> or <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Review">Review</a> while the LWG
  is actively working on them. When the LWG has reached consensus on
  the disposition of an issue, the status will then change to
  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>, or
  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a> as appropriate.  Once the full J16 committee votes to
  forward Ready issues to the Project Editor, they are given the
  status of Defect Report ( <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#DR">DR</a>). These in turn may
  become the basis for Technical Corrigenda (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC">TC</a>),
  or are closed without action other than a Record of Response
  (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#RR">RR</a> ). The intent of this LWG process is that
  only issues which are truly defects in the Standard move to the
  formal ISO DR status.
  </p>


<h2>Active Issues</h2>
<hr>
<h3><a name="23"></a>23. Num_get overflow result</h3>
<p><b>Section:</b> 22.2.2.1.2 [facet.num.get.virtuals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Nathan Myers <b>Date:</b> 1998-08-06</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#facet.num.get.virtuals">active issues</a> in [facet.num.get.virtuals].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#facet.num.get.virtuals">issues</a> in [facet.num.get.virtuals].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>The current description of numeric input does not account for the
possibility of overflow. This is an implicit result of changing the
description to rely on the definition of scanf() (which fails to
report overflow), and conflicts with the documented behavior of
traditional and current implementations. </p>

<p>Users expect, when reading a character sequence that results in a
value unrepresentable in the specified type, to have an error
reported. The standard as written does not permit this. </p>

<p><b>Further comments from Dietmar:</b></p>

<p>
I don't feel comfortable with the proposed resolution to issue 23: It
kind of simplifies the issue to much. Here is what is going on:
</p>

<p>
Currently, the behavior of numeric overflow is rather counter intuitive
and hard to trace, so I will describe it briefly:
</p>

<ul>
  <li>
    According to 22.2.2.1.2 [facet.num.get.virtuals]
    paragraph 11 <tt>failbit</tt> is set if <tt>scanf()</tt> would
    return an input error; otherwise a value is converted to the rules
    of <tt>scanf</tt>.
  </li>
  <li> 
    <tt>scanf()</tt> is defined in terms of <tt>fscanf()</tt>. 
  </li>
  <li>
    <tt>fscanf()</tt> returns an input failure if during conversion no
    character matching the conversion specification could be extracted
    before reaching EOF. This is the only reason for <tt>fscanf()</tt>
    to fail due to an input error and clearly does not apply to the case
    of overflow.
  </li>
  <li>
    Thus, the conversion is performed according to the rules of
    <tt>fscanf()</tt> which basically says that <tt>strtod</tt>,
    <tt>strtol()</tt>, etc. are to be used for the conversion.
  </li>
  <li>
    The <tt>strtod()</tt>, <tt>strtol()</tt>, etc. functions consume as
    many matching characters as there are and on overflow continue to
    consume matching characters but also return a value identical to
    the maximum (or minimum for signed types if there was a leading minus)
    value of the corresponding type and set <tt>errno</tt> to <tt>ERANGE</tt>.
  </li>
  <li>
    Thus, according to the current wording in the standard, overflows
    can be detected! All what is to be done is to check <tt>errno</tt>
    after reading an element and, of course, clearing <tt>errno</tt>
    before trying a conversion. With the current wording, it can be
    detected whether the overflow was due to a positive or negative
    number for signed types.
  </li>
</ul>

<p><b>Further discussion from Redmond:</b></p>

<p>The basic problem is that we've defined our behavior,
including our error-reporting behavior, in terms of C90.  However,
C90's method of reporting overflow in scanf is not technically an
"input error".  The <tt>strto_*</tt> functions are more precise.</p>

<p>There was general consensus that <tt>failbit</tt> should be set
upon overflow.  We considered three options based on this:</p>
<ol>
<li>Set failbit upon conversion error (including overflow), and 
    don't store any value.</li>
<li>Set failbit upon conversion error, and also set <tt>errno</tt> to 
    indicated the precise nature of the error.</li>
<li>Set failbit upon conversion error.  If the error was due to
    overflow, store +-numeric_limits&lt;T&gt;::max() as an
    overflow indication.</li>
</ol>

<p>Straw poll: (1) 5; (2) 0; (3) 8.</p>


<p>Discussed at Lillehammer.  General outline of what we want the
  solution to look like: we want to say that overflow is an error, and
  provide a way to distinguish overflow from other kinds of errors.
  Choose candidate field the same way scanf does, but don't describe
  the rest of the process in terms of format.  If a finite input field
  is too large (positive or negative) to be represented as a finite
  value, then set failbit and assign the nearest representable value.
  Bill will provide wording.</p>

<p>
Discussed at Toronto:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2327.pdf">N2327</a>
is in alignment with the direction we wanted to go with in Lillehammer.  Bill
to work on.
</p>



<p><b>Proposed resolution:</b></p>

<p>
Change 22.2.2.1.2 [facet.num.get.virtuals], end of p3:
</p>

<blockquote>
<p>
<b>Stage 3:</b> <del>The result of stage 2 processing can be one of</del>
<ins>The sequence of <tt>char</tt>s accumulated in stage 2 (the field) is
converted to a numeric value by the rules of one of the functions declared
in the header <tt>&lt;cstdlib&gt;</tt>:</ins>
</p>
<ul>
<li>
<del>A sequence of <tt>char</tt>s has been accumulated in stage 2 that is
converted (according to the rules of <tt>scanf</tt>) to a value of the
type of <i>val</i>. This value is stored in <i>val</i> and <tt>ios_base::goodbit</tt> is
stored in <i>err</i>.</del>
<ins>For a signed integer value, the function <tt>strtoll</tt>.</ins>
</li>
<li>
<del>The sequence of <tt>char</tt>s accumulated in stage 2 would have caused
<tt>scanf</tt> to report an input failure. <tt>ios_base::failbit</tt> is
assigned to <i>err</i>.</del>
<ins>For an unsigned integer value, the function <tt>strtoull</tt>.</ins>
</li>
<li>
<ins>For a floating-point value, the function <tt>strtold</tt>.</ins>
</li>
</ul>
<p>
<ins>The numeric value to be stored can be one of:</ins>
</p>
<ul>
<li><ins>zero, if the conversion function fails to convert the entire field.
<tt>ios_base::failbit</tt> is assigned to err.</ins></li>
<li><ins>the most positive representable value, if the field represents a value
too large positive to be represented in <i>val</i>. <tt>ios_base::failbit</tt> is assigned
to <i>err</i>.</ins></li>
<li><ins>the most negative representable value (zero for unsigned integer), if
the field represents a value too large negative to be represented in <i>val</i>.
<tt>ios_base::failbit</tt> is assigned to <i>err</i>.</ins></li>
<li><ins>the converted value, otherwise.</ins></li>
</ul>

<p><ins>
The resultant numeric value is stored in <i>val</i>.
</ins></p>
</blockquote>

<p>
Change 22.2.2.1.2 [facet.num.get.virtuals], p6-p7:
</p>

<blockquote>
<pre>iter_type do_get(iter_type <i>in</i>, iter_type <i>end</i>, ios_base&amp; <i>str</i>, 
                 ios_base::iostate&amp; <i>err</i>, bool&amp; <i>val</i>) const;
</pre>
<blockquote>
<p>
-6- <i>Effects:</i> If
<tt>(<i>str</i>.flags()&amp;ios_base::boolalpha)==0</tt> then input
proceeds as it would for a <tt>long</tt> except that if a value is being
stored into <i>val</i>, the value is determined according to the
following: If the value to be stored is 0 then <tt>false</tt> is stored.
If the value is 1 then <tt>true</tt> is stored. Otherwise
<del><tt><i>err</i>|=ios_base::failbit</tt> is performed and no value</del> <ins><tt>true</tt></ins> is
stored<del>.</del> <ins>and <tt>ios_base::failbit</tt> is assigned to <i>err</i>.</ins>
</p>
<p>
-7- Otherwise target sequences are determined "as if" by calling the
members <tt>falsename()</tt> and <tt>truename()</tt> of the facet
obtained by <tt>use_facet&lt;numpunct&lt;charT&gt;
&gt;(<i>str</i>.getloc())</tt>. Successive characters in the range
<tt>[<i>in</i>,<i>end</i>)</tt> (see 23.1.1) are obtained and matched
against corresponding positions in the target sequences only as
necessary to identify a unique match. The input iterator <i>in</i> is
compared to <i>end</i> only when necessary to obtain a character. If <del>and
only if</del> a target sequence is uniquely matched, <i>val</i> is set to the
corresponding value. <ins>Otherwise <tt>false</tt> is stored and <tt>ios_base::failbit</tt>
is assigned to <i>err</i>.</ins>
</p>
</blockquote>
</blockquote>





<hr>
<h3><a name="96"></a>96. Vector&lt;bool&gt; is not a container</h3>
<p><b>Section:</b> 23.2.6 [vector] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> AFNOR <b>Date:</b> 1998-10-07</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#vector">issues</a> in [vector].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><tt>vector&lt;bool&gt;</tt> is not a container as its reference and
pointer types are not references and pointers. </p>

<p>Also it forces everyone to have a space optimization instead of a
speed one.</p>

<p><b>See also:</b> 99-0008 == N1185 Vector&lt;bool&gt; is
Nonconforming, Forces Optimization Choice.</p>

<p><i>[In Santa Cruz the LWG felt that this was Not A Defect.]</i></p>


<p><i>[In Dublin many present felt that failure to meet Container
requirements was a defect. There was disagreement as to whether
or not the optimization requirements constituted a defect.]</i></p>


<p><i>[The LWG looked at the following resolutions in some detail:
<br>
&nbsp;&nbsp;&nbsp;&nbsp; * Not A Defect.<br>
&nbsp;&nbsp;&nbsp;&nbsp; * Add a note explaining that vector&lt;bool&gt; does not meet
Container requirements.<br>
&nbsp;&nbsp;&nbsp;&nbsp; * Remove vector&lt;bool&gt;.<br>
&nbsp;&nbsp;&nbsp;&nbsp; * Add a new category of container requirements which
vector&lt;bool&gt; would meet.<br>
&nbsp;&nbsp;&nbsp;&nbsp; * Rename vector&lt;bool&gt;.<br>
<br>
No alternative had strong, wide-spread, support and every alternative
had at least one "over my dead body" response.<br>
<br>
There was also mention of a transition scheme something like (1) add
vector_bool and deprecate vector&lt;bool&gt; in the next standard. (2)
Remove vector&lt;bool&gt; in the following standard.]</i></p>


<p><i>[Modifying container requirements to permit returning proxies
(thus allowing container requirements conforming vector&lt;bool&gt;)
was also discussed.]</i></p>


<p><i>[It was also noted that there is a partial but ugly workaround in
that vector&lt;bool&gt; may be further specialized with a customer
allocator.]</i></p>


<p><i>[Kona: Herb Sutter presented his paper J16/99-0035==WG21/N1211,
vector&lt;bool&gt;: More Problems, Better Solutions. Much discussion
of a two step approach: a) deprecate, b) provide replacement under a
new name.  LWG straw vote on that: 1-favor, 11-could live with, 2-over
my dead body.  This resolution was mentioned in the LWG report to the
full committee, where several additional committee members indicated
over-my-dead-body positions.]</i></p>


<p>Discussed at Lillehammer.  General agreement that we should
  deprecate vector&lt;bool&gt; and introduce this functionality under
  a different name, e.g. bit_vector.  This might make it possible to
  remove the vector&lt;bool&gt; specialization in the standard that comes
  after C++0x. There was also a suggestion that
  in C++0x we could additional say that it's implementation defined
  whether vector&lt;bool&gt; refers to the specialization or to the
  primary template, but there wasn't general agreement that this was a
  good idea.</p>

<p>We need a paper for the new bit_vector class.</p>




<p><b>Proposed resolution:</b></p>
<p>
We now have:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2050.pdf">N2050</a>
and
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2160.html">N2160</a>.
</p>

<p><i>[
Batavia: The LWG feels we need something closer to SGI's <tt>bitvector</tt> to ease migration
from <tt>vector&lt;bool&gt;</tt>.  Although some of the funcitonality from
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2050.pdf">N2050</a>
could well be used in such a template.  The concern is easing the API migration for those
users who want to continue using a bit-packed container.  Alan and Beman to work.
]</i></p>






<hr>
<h3><a name="128"></a>128. Need open_mode() function for file stream, string streams, file buffers, and string&nbsp; buffers</h3>
<p><b>Section:</b> 27.7 [string.streams], 27.8 [file.streams] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Angelika Langer <b>Date:</b> 1999-02-22</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#string.streams">issues</a> in [string.streams].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>The following question came from Thorsten Herlemann:</p>

<blockquote>
  <p>You can set a mode when constructing or opening a file-stream or
  filebuf, e.g.  ios::in, ios::out, ios::binary, ... But how can I get
  that mode later on, e.g. in my own operator &lt;&lt; or operator
  &gt;&gt; or when I want to check whether a file-stream or
  file-buffer object passed as parameter is opened for input or output
  or binary? Is there no possibility? Is this a design-error in the
  standard C++ library? </p>
</blockquote>

<p>It is indeed impossible to find out what a stream's or stream
buffer's open mode is, and without that knowledge you don't know
how certain operations behave. Just think of the append mode. </p>

<p>Both streams and stream buffers should have a <tt>mode()</tt> function that returns the
current open mode setting. </p>

<p><i>[
post Bellevue:  Alisdair requested to re-Open.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>For stream buffers, add a function to the base class as a non-virtual function
qualified as const to 27.5.2 [streambuf]:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;<tt>openmode mode() const</tt>;</p>

<p><b>&nbsp;&nbsp;&nbsp; Returns</b> the current open mode.</p>

<p>With streams, I'm not sure what to suggest. In principle, the mode
could already be returned by <tt>ios_base</tt>, but the mode is only
initialized for file and string stream objects, unless I'm overlooking
anything. For this reason it should be added to the most derived
stream classes. Alternatively, it could be added to <tt>basic_ios</tt>
and would be default initialized in <tt>basic_ios&lt;&gt;::init()</tt>.</p>


<p><b>Rationale:</b></p>
<p>This might be an interesting extension for some future, but it is
not a defect in the current standard. The Proposed Resolution is
retained for future reference.</p>





<hr>
<h3><a name="180"></a>180. Container member iterator arguments constness has unintended consequences</h3>
<p><b>Section:</b> 23 [containers] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Dave Abrahams <b>Date:</b> 1999-07-01</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#containers">active issues</a> in [containers].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#containers">issues</a> in [containers].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>It is the constness of the container which should control whether
it can be modified through a member function such as erase(), not the
constness of the iterators. The iterators only serve to give
positioning information.</p>

<p>Here's a simple and typical example problem which is currently very
difficult or impossible to solve without the change proposed
below.</p>

<p>Wrap a standard container C in a class W which allows clients to
find and read (but not modify) a subrange of (C.begin(), C.end()]. The
only modification clients are allowed to make to elements in this
subrange is to erase them from C through the use of a member function
of W.</p>

<p><i>[
post Bellevue, Alisdair adds:
]</i></p>


<blockquote>
<p>
This issue was implemented by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2350.pdf">N2350</a>
for everything but <tt>basic_string</tt>.
</p>

<p>
Note that the specific example in this issue (<tt>basic_string</tt>) is the one place
we forgot to amend in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2350.pdf">N2350</a>,
so we might open this issue for that
single container?
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>Change all non-const iterator parameters of standard library
container member functions to accept const_iterator parameters.
Note that this change applies to all library clauses, including
strings.</p>

<p>For example, in   21.3.5.5  change:<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <tt>iterator erase(iterator p);</tt><br>
<br>
to:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <tt>iterator erase(const_iterator p);</tt>
</p>


<p><b>Rationale:</b></p>
<p>The issue was discussed at length. It was generally agreed that 1)
There is no major technical argument against the change (although
there is a minor argument that some obscure programs may break), and
2) Such a change would not break const correctness. The concerns about
making the change were 1) it is user detectable (although only in
boundary cases), 2) it changes a large number of signatures, and 3) it
seems more of a design issue that an out-and-out defect.</p>

<p>The LWG believes that this issue should be considered as part of a
general review of const issues for the next revision of the
standard. Also see issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#200">200</a>.</p>




<hr>
<h3><a name="190"></a>190. min() and max() functions should be std::binary_functions</h3>
<p><b>Section:</b> 25.3.7 [alg.min.max] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Mark Rintoul <b>Date:</b> 1999-08-26</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#alg.min.max">active issues</a> in [alg.min.max].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.min.max">issues</a> in [alg.min.max].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>Both std::min and std::max are defined as template functions.  This
is very different than the definition of std::plus (and similar
structs) which are defined as function objects which inherit
std::binary_function.<br>
<br>
        This lack of inheritance leaves std::min and std::max somewhat useless in standard library algorithms which require
a function object that inherits std::binary_function.</p>

<p><i>[
post Bellevue:  Alisdair requested to re-Open.
]</i></p>




<p><b>Rationale:</b></p>
<p>Although perhaps an unfortunate design decision, the omission is not a defect
in the current standard.&nbsp; A future standard may wish to consider additional
function objects.</p>




<hr>
<h3><a name="255"></a>255. Why do <tt>basic_streambuf&lt;&gt;::pbump()</tt> and <tt>gbump()</tt> take an int?</h3>
<p><b>Section:</b> 27.5.2 [streambuf] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Martin Sebor <b>Date:</b> 2000-08-12</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#streambuf">issues</a> in [streambuf].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The basic_streambuf members gbump() and pbump() are specified to take an
int argument. This requirement prevents the functions from effectively
manipulating buffers larger than std::numeric_limits&lt;int&gt;::max()
characters. It also makes the common use case for these functions
somewhat difficult as many compilers will issue a warning when an
argument of type larger than int (such as ptrdiff_t on LLP64
architectures) is passed to either of the function. Since it's often the
result of the subtraction of two pointers that is passed to the
functions, a cast is necessary to silence such warnings. Finally, the
usage of a native type in the functions signatures is inconsistent with
other member functions (such as sgetn() and sputn()) that manipulate the
underlying character buffer. Those functions take a streamsize argument.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change the signatures of these functions in the synopsis of template
class basic_streambuf (27.5.2) and in their descriptions (27.5.2.3.1, p4
and 27.5.2.3.2, p4) to take a streamsize argument.
</p>

<p>
Although this change has the potential of changing the ABI of the
library, the change will affect only platforms where int is different
than the definition of streamsize. However, since both functions are
typically inline (they are on all known implementations), even on such
platforms the change will not affect any user code unless it explicitly
relies on the existing type of the functions (e.g., by taking their
address). Such a possibility is IMO quite remote.
</p>

<p>
Alternate Suggestion from Howard Hinnant, c++std-lib-7780:
</p>

<p>
This is something of a nit, but I'm wondering if streamoff wouldn't be a 
better choice than streamsize.  The argument to pbump and gbump MUST be 
signed.  But the standard has this to say about streamsize 
(27.4.1/2/Footnote):
</p>

<blockquote><p>
     [Footnote: streamsize is used in most places where ISO C would use
     size_t.  Most of the uses of streamsize could use size_t, except for
     the strstreambuf constructors, which require negative values. It
     should probably be the signed type corresponding to size_t (which is
     what Posix.2 calls ssize_t). --- end footnote]
</p></blockquote>

<p>
This seems a little weak for the argument to pbump and gbump.  Should we 
ever really get rid of strstream, this footnote might go with it, along 
with the reason to make streamsize signed.
</p>


<p><b>Rationale:</b></p>
<p>The LWG believes this change is too big for now.  We may wish to
reconsider this for a future revision of the standard.  One
possibility is overloading pbump, rather than changing the
signature.</p>
<p><i>[
[2006-05-04: Reopened at the request of Chris (Krzysztof ?elechowski)]
]</i></p>





<hr>
<h3><a name="290"></a>290. Requirements to for_each and its function object</h3>
<p><b>Section:</b> 25.1.1 [alg.foreach] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Angelika Langer <b>Date:</b> 2001-01-03</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.foreach">issues</a> in [alg.foreach].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>The specification of the for_each algorithm does not have a
"Requires" section, which means that there are no
restrictions imposed on the function object whatsoever. In essence it
means that I can provide any function object with arbitrary side
effects and I can still expect a predictable result. In particular I
can expect that the function object is applied exactly last - first
times, which is promised in the "Complexity" section.
</p>

<p>I don't see how any implementation can give such a guarantee
without imposing requirements on the function object.
</p>

<p>Just as an example: consider a function object that removes
elements from the input sequence.  In that case, what does the
complexity guarantee (applies f exactly last - first times) mean?
</p>

<p>One can argue that this is obviously a nonsensical application and
a theoretical case, which unfortunately it isn't.  I have seen
programmers shooting themselves in the foot this way, and they did not
understand that there are restrictions even if the description of the
algorithm does not say so.
</p>
<p><i>[Lillehammer: This is more general than for_each.  We don't want
  the function object in transform invalidiating iterators
  either. There should be a note somewhere in clause 17 (17, not 25)
  saying that user code operating on a range may not invalidate
  iterators unless otherwise specified.  Bill will provide wording.]</i></p>



<p><b>Proposed resolution:</b></p>






<hr>
<h3><a name="299"></a>299. Incorrect return types for iterator dereference</h3>
<p><b>Section:</b> 24.1.4 [bidirectional.iterators], 24.1.5 [random.access.iterators] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> John Potter <b>Date:</b> 2001-01-22</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#bidirectional.iterators">issues</a> in [bidirectional.iterators].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In section 24.1.4 [bidirectional.iterators],
Table 75 gives the return type of *r-- as convertible to T.  This is
not consistent with Table 74 which gives the return type of *r++ as
T&amp;.  *r++ = t is valid while *r-- = t is invalid.
</p>

<p>
In section 24.1.5 [random.access.iterators],
Table 76 gives the return type of a[n] as convertible to T.  This is
not consistent with the semantics of *(a + n) which returns T&amp; by
Table 74.  *(a + n) = t is valid while a[n] = t is invalid.
</p>

<p>
Discussion from the Copenhagen meeting: the first part is
uncontroversial.  The second part, operator[] for Random Access
Iterators, requires more thought.  There are reasonable arguments on
both sides.  Return by value from operator[] enables some potentially
useful iterators, e.g. a random access "iota iterator" (a.k.a
"counting iterator" or "int iterator").  There isn't any obvious way
to do this with return-by-reference, since the reference would be to a
temporary.  On the other hand, <tt>reverse_iterator</tt> takes an
arbitrary Random Access Iterator as template argument, and its
operator[] returns by reference.  If we decided that the return type
in Table 76 was correct, we would have to change
<tt>reverse_iterator</tt>.  This change would probably affect user
code.
</p>

<p>
History: the contradiction between <tt>reverse_iterator</tt> and the
Random Access Iterator requirements has been present from an early
stage.  In both the STL proposal adopted by the committee
(N0527==94-0140) and the STL technical report (HPL-95-11 (R.1), by
Stepanov and Lee), the Random Access Iterator requirements say that
operator[]'s return value is "convertible to T".  In N0527
reverse_iterator's operator[] returns by value, but in HPL-95-11
(R.1), and in the STL implementation that HP released to the public,
reverse_iterator's operator[] returns by reference.  In 1995, the
standard was amended to reflect the contents of HPL-95-11 (R.1).  The
original intent for operator[] is unclear.
</p>

<p>
In the long term it may be desirable to add more fine-grained 
iterator requirements, so that access method and traversal strategy
can be decoupled.  (See "Improved Iterator Categories and
Requirements", N1297 = 01-0011, by Jeremy Siek.)  Any decisions
about issue 299 should keep this possibility in mind.
</p>

<p>Further discussion: I propose a compromise between John Potter's
resolution, which requires <tt>T&amp;</tt> as the return type of
<tt>a[n]</tt>, and the current wording, which requires convertible to
<tt>T</tt>. The compromise is to keep the convertible to <tt>T</tt>
for the return type of the expression <tt>a[n]</tt>, but to also add
<tt>a[n] = t</tt> as a valid expression. This compromise "saves" the
common case uses of random access iterators, while at the same time
allowing iterators such as counting iterator and caching file
iterators to remain random access iterators (iterators where the
lifetime of the object returned by <tt>operator*()</tt> is tied to the
lifetime of the iterator).
</p>

<p>
Note that the compromise resolution necessitates a change to
<tt>reverse_iterator</tt>. It would need to use a proxy to support
<tt>a[n] = t</tt>.
</p>

<p>
Note also there is one kind of mutable random access iterator that
will no longer meet the new requirements. Currently, iterators that
return an r-value from <tt>operator[]</tt> meet the requirements for a
mutable random access iterartor, even though the expression <tt>a[n] =
t</tt> will only modify a temporary that goes away. With this proposed
resolution, <tt>a[n] = t</tt> will be required to have the same
operational semantics as <tt>*(a + n) = t</tt>.
</p>



<p><b>Proposed resolution:</b></p>

<p>
In section 24.1.4 [lib.bidirectdional.iterators], change the return
type in table 75 from "convertible to <tt>T</tt>" to
<tt>T&amp;</tt>.
</p>

<p>
In section 24.1.5 [lib.random.access.iterators], change the
operational semantics for <tt>a[n]</tt> to " the r-value of
<tt>a[n]</tt> is equivalent to the r-value of <tt>*(a +
n)</tt>". Add a new row in the table for the expression <tt>a[n] = t</tt>
with a return type of convertible to <tt>T</tt> and operational semantics of
<tt>*(a + n) = t</tt>.
</p>

<p><i>[Lillehammer: Real problem, but should be addressed as part of
  iterator redesign]</i></p>








<hr>
<h3><a name="309"></a>309. Does sentry catch exceptions?</h3>
<p><b>Section:</b> 27.6 [iostream.format] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Martin Sebor <b>Date:</b> 2001-03-19</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#iostream.format">issues</a> in [iostream.format].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The descriptions of the constructors of basic_istream&lt;&gt;::sentry
(27.6.1.1.3 [istream::sentry]) and basic_ostream&lt;&gt;::sentry
(27.6.2.4 [ostream::sentry]) do not explain what the functions do in
case an exception is thrown while they execute. Some current
implementations allow all exceptions to propagate, others catch them
and set ios_base::badbit instead, still others catch some but let
others propagate.
</p>

<p>
The text also mentions that the functions may call setstate(failbit)
(without actually saying on what object, but presumably the stream
argument is meant).  That may have been fine for
basic_istream&lt;&gt;::sentry prior to issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#195">195</a>, since
the function performs an input operation which may fail. However,
issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#195">195</a> amends 27.6.1.1.3 [istream::sentry], p2 to
clarify that the function should actually call setstate(failbit |
eofbit), so the sentence in p3 is redundant or even somewhat
contradictory.
</p>

<p>
The same sentence that appears in 27.6.2.4 [ostream::sentry], p3
doesn't seem to be very meaningful for basic_istream&lt;&gt;::sentry
which performs no input. It is actually rather misleading since it
would appear to guide library implementers to calling
setstate(failbit) when os.tie()-&gt;flush(), the only called function,
throws an exception (typically, it's badbit that's set in response to
such an event).
</p>

<p><b>Additional comments from Martin, who isn't comfortable with the
    current proposed resolution</b> (see c++std-lib-11530)</p>

<p>
The istream::sentry ctor says nothing about how the function
deals with exemptions (27.6.1.1.2, p1 says that the class is
responsible for doing "exception safe"(*) prefix and suffix
operations but it doesn't explain what level of exception
safety the class promises to provide). The mockup example
of a "typical implementation of the sentry ctor" given in
27.6.1.1.2, p6, removed in ISO/IEC 14882:2003, doesn't show
exception handling, either. Since the ctor is not classified
as a formatted or unformatted input function, the text in
27.6.1.1, p1 through p4 does not apply. All this would seem
to suggest that the sentry ctor should not catch or in any
way handle exceptions thrown from any functions it may call.
Thus, the typical implementation of an istream extractor may
look something like [1].
</p>

<p>
The problem with [1] is that while it correctly sets ios::badbit
if an exception is thrown from one of the functions called from
the sentry ctor, if the sentry ctor reaches EOF while extracting
whitespace from a stream that has eofbit or failbit set in
exceptions(), it will cause an ios::failure to be thrown, which
will in turn cause the extractor to set ios::badbit.
</p>

<p>
The only straightforward way to prevent this behavior is to
move the definition of the sentry object in the extractor
above the try block (as suggested by the example in 22.2.8,
p9 and also indirectly supported by 27.6.1.3, p1). See [2].
But such an implementation will allow exceptions thrown from
functions called from the ctor to freely propagate to the
caller regardless of the setting of ios::badbit in the stream
object's exceptions().
</p>

<p>
So since neither [1] nor [2] behaves as expected, the only
possible solution is to have the sentry ctor catch exceptions
thrown from called functions, set badbit, and propagate those
exceptions if badbit is also set in exceptions(). (Another
solution exists that deals with both kinds of sentries, but
the code is non-obvious and cumbersome -- see [3].)
</p>

<p>
Please note that, as the issue points out, current libraries
do not behave consistently, suggesting  that implementors are
not quite clear on the exception handling in istream::sentry,
despite the fact that some LWG members might feel otherwise.
(As documented by the parenthetical comment here:
http://anubis.dkuug.dk/jtc1/sc22/wg21/docs/papers/2003/n1480.html#309)
</p>

<p>
Also please note that those LWG members who in Copenhagen
felt that "a sentry's constructor should not catch exceptions,
because sentries should only be used within (un)formatted input
functions and that exception handling is the responsibility of
those functions, not of the sentries," as noted here
http://anubis.dkuug.dk/jtc1/sc22/wg21/docs/papers/2001/n1310.html#309
would in effect be either arguing for the behavior described
in [1] or for extractors implemented along the lines of [3].
</p>

<p>
The original proposed resolution (Revision 25 of the issues
list) clarifies the role of the sentry ctor WRT exception
handling by making it clear that extractors (both library
or user-defined) should be implemented along the lines of
[2] (as opposed to [1]) and that no exception thrown from
the callees should propagate out of either function unless
badbit is also set in exceptions().
</p>


<p>[1] Extractor that catches exceptions thrown from sentry:</p>

<blockquote>
<pre>struct S { long i; };

istream&amp; operator&gt;&gt; (istream &amp;strm, S &amp;s)
{
    ios::iostate err = ios::goodbit;
    try {
        const istream::sentry guard (strm, false);
        if (guard) {
            use_facet&lt;num_get&lt;char&gt; &gt;(strm.getloc ())
                .get (istreambuf_iterator&lt;char&gt;(strm),
                      istreambuf_iterator&lt;char&gt;(),
                      strm, err, s.i);
        }
    }
    catch (...) {
        bool rethrow;
        try {
            strm.setstate (ios::badbit);
            rethrow = false;
        }
        catch (...) {
            rethrow = true;
        }
        if (rethrow)
            throw;
    }
    if (err)
        strm.setstate (err);
    return strm;
}
</pre>
</blockquote>

<p>[2] Extractor that propagates exceptions thrown from sentry:</p>

<blockquote>
<pre>istream&amp; operator&gt;&gt; (istream &amp;strm, S &amp;s)
{
    istream::sentry guard (strm, false);
    if (guard) {
        ios::iostate err = ios::goodbit;
        try {
            use_facet&lt;num_get&lt;char&gt; &gt;(strm.getloc ())
                .get (istreambuf_iterator&lt;char&gt;(strm),
                      istreambuf_iterator&lt;char&gt;(),
                      strm, err, s.i);
        }
        catch (...) {
            bool rethrow;
            try {
                strm.setstate (ios::badbit);
                rethrow = false;
            }
            catch (...) {
                rethrow = true;
            }
            if (rethrow)
                throw;
        }
        if (err)
            strm.setstate (err);
    }
    return strm;
}
</pre>
</blockquote>

<p>
[3] Extractor that catches exceptions thrown from sentry
but doesn't set badbit if the exception was thrown as a
result of a call to strm.clear().
</p>

<blockquote>
<pre>istream&amp; operator&gt;&gt; (istream &amp;strm, S &amp;s)
{
    const ios::iostate state = strm.rdstate ();
    const ios::iostate except = strm.exceptions ();
    ios::iostate err = std::ios::goodbit;
    bool thrown = true;
    try {
        const istream::sentry guard (strm, false);
        thrown = false;
        if (guard) {
            use_facet&lt;num_get&lt;char&gt; &gt;(strm.getloc ())
                .get (istreambuf_iterator&lt;char&gt;(strm),
                      istreambuf_iterator&lt;char&gt;(),
                      strm, err, s.i);
        }
    }
    catch (...) {
        if (thrown &amp;&amp; state &amp; except)
            throw;
        try {
            strm.setstate (ios::badbit);
            thrown = false;
        }
        catch (...) {
            thrown = true;
        }
        if (thrown)
            throw;
    }
    if (err)
        strm.setstate (err);

    return strm;
}
</pre>
</blockquote>

<p>
[Pre-Berlin] Reopened at the request of Paolo Carlini and Steve Clamage.
</p>

<p>
[Pre-Portland] A relevant newsgroup post:
</p>

<p>
The current proposed resolution of issue #309
(http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#309)  is
unacceptable.   I write commerical software and coding around this
makes my code ugly, non-intuitive, and requires comments referring
people to this very issue.   Following is the full explanation of my
experience.
</p>
<p>
In the course of writing software for commercial use, I constructed
std::ifstream's based on user-supplied pathnames on typical POSIX
systems.
</p>
<p>
It was expected that some files that opened successfully might not read
successfully -- such as a pathname which actually refered to a
directory.   Intuitively, I expected the streambuffer underflow() code
to throw an exception in this situation, and recent implementations of
libstdc++'s basic_filebuf do just that (as well as many of my own
custom streambufs).
</p>
<p>
I also intuitively expected that the istream code would convert these
exceptions to the "badbit' set on the stream object, because I had not
requested exceptions.    I refer to 27.6.1.1. P4.
</p>
<p>
However, this was not the case on at least two implementations -- if
the first thing I did with an istream was call operator&gt;&gt;( T&amp; ) for T
among the basic arithmetic types and std::string.   Looking further I
found that the sentry's constructor was invoking the exception when it
pre-scanned for whitespace, and the extractor function (operator&gt;&gt;())
was not catching exceptions in this situation.
</p>
<p>
So, I was in a situation where setting 'noskipws' would change the
istream's behavior even though no characters (whitespace or not) could
ever be successfully read.
</p>
<p>
Also, calling .peek() on the istream before calling the extractor()
changed the behavior (.peek() had the effect of setting the badbit
ahead of time).
</p>
<p>
I found this all to be so inconsistent and inconvenient for me and my
code design, that I filed a bugzilla entry for libstdc++.   I was then
told that the bug cannot be fixed until issue #309 is resolved by the
committee.
</p>



<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>The LWG agrees there is minor variation between implementations,
  but believes that it doesn't matter. This is a rarely used corner
  case. There is no evidence that this has any commercial importance
  or that it causes actual portability problems for customers trying
  to write code that runs on multiple implementations.</p>





<hr>
<h3><a name="342"></a>342. seek and eofbit</h3>
<p><b>Section:</b> 27.6.1.3 [istream.unformatted] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Howard Hinnant <b>Date:</b> 2001-10-09</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#istream.unformatted">issues</a> in [istream.unformatted].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>I think we have a defect.</p>

<p>According to lwg issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#60">60</a> which is now a dr, the
description of seekg in 27.6.1.3 [istream.unformatted] paragraph 38 now looks
like:</p>

<blockquote><p>
Behaves as an unformatted input function (as described in 27.6.1.3, 
paragraph 1), except that it does not count the number of characters 
extracted and does not affect the value returned by subsequent calls to 
gcount(). After constructing a sentry object, if fail() != true, 
executes rdbuf()-&gt;pubseekpos( pos).
</p></blockquote>

<p>And according to lwg issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#243">243</a> which is also now a dr,
27.6.1.3, paragraph 1 looks like:</p>

<blockquote><p>
Each unformatted input function begins execution by constructing an 
object of class sentry with the default argument noskipws (second) 
argument true. If the sentry object returns true, when converted to a 
value of type bool, the function endeavors to obtain the requested 
input.  Otherwise, if the sentry constructor exits by throwing an 
exception or if the sentry object returns false, when converted to a 
value of type bool, the function returns without attempting to obtain 
any input. In either case the number of extracted characters is set to 
0; unformatted input functions taking a character array of non-zero 
size as an argument shall also store a null character (using charT()) 
in the first location of the array. If an exception is thrown during 
input then ios::badbit is turned on in *this'ss error state. If 
(exception()&amp;badbit)!= 0 then the exception is rethrown. It also counts 
the number of characters extracted. If no exception has been thrown it 
ends by storing the count in a member object and returning the value 
specified. In any event the sentry object is destroyed before leaving 
the unformatted input function.
</p></blockquote>

<p>And finally 27.6.1.1.2/5 says this about sentry:</p>

<blockquote><p>
If, after any preparation is completed, is.good() is true, ok_ != false 
otherwise, ok_ == false.
</p></blockquote>

<p>
So although the seekg paragraph says that the operation proceeds if 
!fail(), the behavior of unformatted functions says the operation 
proceeds only if good().  The two statements are contradictory when only 
eofbit is set.  I don't think the current text is clear which condition 
should be respected.
</p>

<p><b>Further discussion from Redmond:</b></p>

<p>PJP: It doesn't seem quite right to say that <tt>seekg</tt> is
"unformatted". That makes specific claims about sentry that
aren't quite appropriate for seeking, which has less fragile failure
modes than actual input.  If we do really mean that it's unformatted
input, it should behave the same way as other unformatted input.  On
the other hand, "principle of least surprise" is that seeking from EOF
ought to be OK.</p>

<p>
Pre-Berlin:  Paolo points out several problems with the proposed resolution in
Ready state:
</p>

<ul>
<li>It should apply to both overloads of seekg.</li>
<li>tellg has similar issues, except that it should not call clear().</li>
<li>The point about clear() seems to apply to seekp().</li>
<li>Depending on the outcome of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#419">419</a>
if the sentry
sets <tt>failbit</tt> when it finds <tt>eofbit</tt> already set, then
you can never seek away from the end of stream.</li>
</ul>



<p><b>Proposed resolution:</b></p>

<p>Change 27.6.1.3 [istream.unformatted] to:</p>
<blockquote><p>
Behaves as an unformatted input function (as described in 27.6.1.3,
paragraph 1), except that it does not count the number of characters
extracted, does not affect the value returned by subsequent calls to
gcount(), and does not examine the value returned by the sentry
object. After constructing a sentry object, if <tt>fail() !=
true</tt>, executes <tt>rdbuf()-&gt;pubseekpos(pos)</tt>.  In
case of success, the function calls clear().
In case of failure, the function calls <tt>setstate(failbit)</tt>
(which may throw <tt>ios_base::failure</tt>).
</p></blockquote>

<p><i>[Lillehammer: Matt provided wording.]</i></p>




<p><b>Rationale:</b></p>
<p>In C, fseek does clear EOF.  This is probably what most users would
  expect.  We agree that having eofbit set should not deter a seek,
  and that a successful seek should clear eofbit. Note
  that <tt>fail()</tt> is true only if <tt>failbit</tt>
  or <tt>badbit</tt> is set, so using <tt>!fail()</tt>, rather
  than <tt>good()</tt>, satisfies this goal.</p>





<hr>
<h3><a name="343"></a>343. Unspecified library header dependencies</h3>
<p><b>Section:</b> 21 [strings], 23 [containers], 27 [input.output] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Martin Sebor <b>Date:</b> 2001-10-09</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#strings">issues</a> in [strings].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The synopses of the C++ library headers clearly show which names are
required to be defined in each header. Since in order to implement the
classes and templates defined in these headers declarations of other
templates (but not necessarily their definitions) are typically
necessary the standard in 17.4.4, p1 permits library implementers to
include any headers needed to implement the definitions in each header.
</p>

<p>
For instance, although it is not explicitly specified in the synopsis of
&lt;string&gt;, at the point of definition of the std::basic_string template
the declaration of the std::allocator template must be in scope. All
current implementations simply include &lt;memory&gt; from within &lt;string&gt;,
either directly or indirectly, to bring the declaration of
std::allocator into scope.
</p>

<p>
Additionally, however, some implementation also include &lt;istream&gt; and
&lt;ostream&gt; at the top of &lt;string&gt; to bring the declarations of
std::basic_istream and std::basic_ostream into scope (which are needed
in order to implement the string inserter and extractor operators
(21.3.7.9 [lib.string.io])). Other implementations only include
&lt;iosfwd&gt;, since strictly speaking, only the declarations and not the
full definitions are necessary.
</p>

<p>
Obviously, it is possible to implement &lt;string&gt; without actually
providing the full definitions of all the templates std::basic_string
uses (std::allocator, std::basic_istream, and std::basic_ostream).
Furthermore, not only is it possible, doing so is likely to have a
positive effect on compile-time efficiency.
</p>

<p>
But while it may seem perfectly reasonable to expect a program that uses
the std::basic_string insertion and extraction operators to also
explicitly include &lt;istream&gt; or &lt;ostream&gt;, respectively, it doesn't seem
reasonable to also expect it to explicitly include &lt;memory&gt;. Since
what's reasonable and what isn't is highly subjective one would expect
the standard to specify what can and what cannot be assumed.
Unfortunately, that isn't the case.
</p>

<p>The examples below demonstrate the issue.</p>

<p>Example 1:</p>

<p>It is not clear whether the following program is complete:</p>

<pre>#include &lt;string&gt;

extern std::basic_ostream&lt;char&gt; &amp;strm;

int main () {
    strm &lt;&lt; std::string ("Hello, World!\n");
}
</pre>    

<p>or whether one must explicitly include &lt;memory&gt; or
&lt;ostream&gt; (or both) in addition to &lt;string&gt; in order for
the program to compile.</p>


<p>Example 2:</p>

<p>Similarly, it is unclear whether the following program is complete:</p>

<pre>#include &lt;istream&gt;

extern std::basic_iostream&lt;char&gt; &amp;strm;

int main () {
    strm &lt;&lt; "Hello, World!\n";
}
</pre>

<p>
or whether one needs to explicitly include &lt;ostream&gt;, and
perhaps even other headers containing the definitions of other
required templates:</p>

<pre>#include &lt;ios&gt;
#include &lt;istream&gt;
#include &lt;ostream&gt;
#include &lt;streambuf&gt;

extern std::basic_iostream&lt;char&gt; &amp;strm;

int main () {
    strm &lt;&lt; "Hello, World!\n";
}
</pre>

<p>Example 3:</p>

<p>Likewise, it seems unclear whether the program below is complete:</p>
<pre>#include &lt;iterator&gt;

bool foo (std::istream_iterator&lt;int&gt; a, std::istream_iterator&lt;int&gt; b)
{
    return a == b;
}

int main () { }
</pre>

<p>or whether one should be required to include &lt;istream&gt;.</p>

<p>There are many more examples that demonstrate this lack of a
requirement.  I believe that in a good number of cases it would be
unreasonable to require that a program explicitly include all the
headers necessary for a particular template to be specialized, but I
think that there are cases such as some of those above where it would
be desirable to allow implementations to include only as much as
necessary and not more.</p>

<p><i>[
post Bellevue:
]</i></p>


<blockquote>
Position taken in prior reviews is that the idea of a table of header
dependencies is a good one. Our view is that a full paper is needed to
do justice to this, and we've made that recommendation to the issue
author.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
For every C++ library header, supply a minimum set of other C++ library
headers that are required to be included by that header. The proposed
list is below (C++ headers for C Library Facilities, table 12 in
17.4.1.2, p3, are omitted):
</p>

<pre>+------------+--------------------+
| C++ header |required to include |
+============+====================+
|&lt;algorithm&gt; |                    |
+------------+--------------------+
|&lt;bitset&gt;    |                    |
+------------+--------------------+
|&lt;complex&gt;   |                    |
+------------+--------------------+
|&lt;deque&gt;     |&lt;memory&gt;            |
+------------+--------------------+
|&lt;exception&gt; |                    |
+------------+--------------------+
|&lt;fstream&gt;   |&lt;ios&gt;               |
+------------+--------------------+
|&lt;functional&gt;|                    |
+------------+--------------------+
|&lt;iomanip&gt;   |&lt;ios&gt;               |
+------------+--------------------+
|&lt;ios&gt;       |&lt;streambuf&gt;         |
+------------+--------------------+
|&lt;iosfwd&gt;    |                    |
+------------+--------------------+
|&lt;iostream&gt;  |&lt;istream&gt;, &lt;ostream&gt;|
+------------+--------------------+
|&lt;istream&gt;   |&lt;ios&gt;               |
+------------+--------------------+
|&lt;iterator&gt;  |                    |
+------------+--------------------+
|&lt;limits&gt;    |                    |
+------------+--------------------+
|&lt;list&gt;      |&lt;memory&gt;            |
+------------+--------------------+
|&lt;locale&gt;    |                    |
+------------+--------------------+
|&lt;map&gt;       |&lt;memory&gt;            |
+------------+--------------------+
|&lt;memory&gt;    |                    |
+------------+--------------------+
|&lt;new&gt;       |&lt;exception&gt;         |
+------------+--------------------+
|&lt;numeric&gt;   |                    |
+------------+--------------------+
|&lt;ostream&gt;   |&lt;ios&gt;               |
+------------+--------------------+
|&lt;queue&gt;     |&lt;deque&gt;             |
+------------+--------------------+
|&lt;set&gt;       |&lt;memory&gt;            |
+------------+--------------------+
|&lt;sstream&gt;   |&lt;ios&gt;, &lt;string&gt;     |
+------------+--------------------+
|&lt;stack&gt;     |&lt;deque&gt;             |
+------------+--------------------+
|&lt;stdexcept&gt; |                    |
+------------+--------------------+
|&lt;streambuf&gt; |&lt;ios&gt;               |
+------------+--------------------+
|&lt;string&gt;    |&lt;memory&gt;            |
+------------+--------------------+
|&lt;strstream&gt; |                    |
+------------+--------------------+
|&lt;typeinfo&gt;  |&lt;exception&gt;         |
+------------+--------------------+
|&lt;utility&gt;   |                    |
+------------+--------------------+
|&lt;valarray&gt;  |                    |
+------------+--------------------+
|&lt;vector&gt;    |&lt;memory&gt;            |
+------------+--------------------+
</pre>


<p><b>Rationale:</b></p>
<p>The portability problem is real.  A program that works correctly on
one implementation might fail on another, because of different header
dependencies.  This problem was understood before the standard was
completed, and it was a conscious design choice.</p>
<p>One possible way to deal with this, as a library extension, would
be an &lt;all&gt; header.</p>

<p>
Hinnant:  It's time we dealt with this issue for C++0X.  Reopened.
</p>







<hr>
<h3><a name="382"></a>382. codecvt do_in/out result</h3>
<p><b>Section:</b> 22.2.1.4 [locale.codecvt] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Martin Sebor <b>Date:</b> 2002-08-30</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.codecvt">issues</a> in [locale.codecvt].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It seems that the descriptions of codecvt do_in() and do_out() leave
sufficient room for interpretation so that two implementations of
codecvt may not work correctly with the same filebuf. Specifically,
the following seems less than adequately specified:
</p>

<ol>
<li>
  the conditions under which the functions terminate
</li>
<li>
  precisely when the functions return ok
</li>
<li>
  precisely when the functions return partial
</li>
<li>
  the full set of conditions when the functions return error
</li>
</ol>

<ol>
<li>
   22.2.1.4.2 [locale.codecvt.virtuals], p2 says this about the effects of the
   function: ...Stops if it encounters a character it cannot
   convert...  This assumes that there *is* a character to
   convert. What happens when there is a sequence that doesn't form a
   valid source character, such as an unassigned or invalid UNICODE
   character, or a sequence that cannot possibly form a character
   (e.g., the sequence "\xc0\xff" in UTF-8)?
</li>
<li>
   Table 53 says that the function returns codecvt_base::ok
   to indicate that the function(s) "completed the conversion."
   Suppose that the source sequence is "\xc0\x80" in UTF-8,
   with from pointing to '\xc0' and (from_end==from + 1).
   It is not clear whether the return value should be ok
   or partial (see below).
</li>
<li>
   Table 53 says that the function returns codecvt_base::partial
   if "not all source characters converted." With the from pointers
   set up the same way as above, it is not clear whether the return
   value should be partial or ok (see above).
</li>
<li>
   Table 53, in the row describing the meaning of error mistakenly
   refers to a "from_type" character, without the symbol from_type
   having been defined. Most likely, the word "source" character
   is intended, although that is not sufficient. The functions
   may also fail when they encounter an invalid source sequence
   that cannot possibly form a valid source character (e.g., as
   explained in bullet 1 above).
</li>
</ol>
<p>
Finally, the conditions described at the end of 22.2.1.4.2 [locale.codecvt.virtuals], p4 don't seem to be possible:
</p>
<blockquote><p>
    "A return value of partial, if (from_next == from_end),
    indicates that either the destination sequence has not
    absorbed all the available destination elements, or that
    additional source elements are needed before another
    destination element can be produced."
</p></blockquote>
<p>
If the value is partial, it's not clear to me that (from_next
==from_end) could ever hold if there isn't enough room
in the destination buffer. In order for (from_next==from_end) to
hold, all characters in that range must have been successfully
converted (according to 22.2.1.4.2 [locale.codecvt.virtuals], p2) and since there are no
further source characters to convert, no more room in the
destination buffer can be needed.
</p>
<p>
It's also not clear to me that (from_next==from_end) could ever
hold if additional source elements are needed to produce another
destination character (not element as incorrectly stated in the
text). partial is returned if "not all source characters have
been converted" according to Table 53, which also implies that
(from_next==from) does NOT hold.
</p>
<p>
Could it be that the intended qualifying condition was actually
(from_next != from_end), i.e., that the sentence was supposed
to read
</p>
<blockquote><p>
    "A return value of partial, if (from_next != from_end),..."
</p></blockquote>
<p>
which would make perfect sense, since, as far as I understand it,
partial can only occur if (from_next != from_end)?
</p>
<p><i>[Lillehammer: Defer for the moment, but this really needs to be
  fixed. Right now, the description of codecvt is too vague for it to
  be a useful contract between providers and clients of codecvt
  facets.  (Note that both vendors and users can be both providers and
  clients of codecvt facets.) The major philosophical issue is whether
  the standard should only describe mappings that take a single wide
  character to multiple narrow characters (and vice versa), or whether
  it should describe fully general N-to-M conversions. When the
  original standard was written only the former was contemplated, but
  today, in light of the popularity of utf8 and utf16, that doesn't
  seem sufficient for C++0x. Bill supports general N-to-M conversions;
  we need to make sure Martin and Howard agree.]</i></p>



<p><b>Proposed resolution:</b></p>




<hr>
<h3><a name="387"></a>387. std::complex over-encapsulated</h3>
<p><b>Section:</b> 26.3 [complex.numbers] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Gabriel Dos Reis <b>Date:</b> 2002-11-08</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#complex.numbers">issues</a> in [complex.numbers].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The absence of explicit description of std::complex&lt;T&gt; layout
makes it imposible to reuse existing software developed in traditional
languages like Fortran or C with unambigous and commonly accepted
layout assumptions.  There ought to be a way for practitioners to
predict with confidence the layout of std::complex&lt;T&gt; whenever T
is a numerical datatype.  The absence of ways to access individual
parts of a std::complex&lt;T&gt; object as lvalues unduly promotes
severe pessimizations. For example, the only way to change,
independently, the real and imaginary parts is to write something like
</p>

<pre>complex&lt;T&gt; z;
// ...
// set the real part to r
z = complex&lt;T&gt;(r, z.imag());
// ...
// set the imaginary part to i
z = complex&lt;T&gt;(z.real(), i);
</pre>

<p>
At this point, it seems appropriate to recall that a complex number
is, in effect, just a pair of numbers with no particular invariant to
maintain.  Existing practice in numerical computations has it that a
complex number datatype is usually represented by Cartesian
coordinates. Therefore the over-encapsulation put in the specification
of std::complex&lt;&gt; is not justified.
</p>



<p><b>Proposed resolution:</b></p>
<p>Add the following requirements to 26.3 [complex.numbers] as 26.3/4:</p>
<blockquote>
<p>If z is an lvalue expression of type cv std::complex&lt;T&gt; then</p>

<ul>
<li>the expression reinterpret_cast&lt;cv T(&amp;)[2]&gt;(z)
is well-formed; and</li>
<li>reinterpret_cast&lt;cv T(&amp;)[2]&gt;(z)[0]designates the
real part of z; and</li>
<li>reinterpret_cast&lt;cv T(&amp;)[2]&gt;(z)[1]designates the
imaginary part of z.</li>
</ul>

<p>
Moreover, if a is an expression of pointer type cv complex&lt;T&gt;*
and the expression a[i] is well-defined for an integer expression
i then:
</p>

<ul>
<li>reinterpret_cast&lt;cv T*&gt;(a)[2*i] designates the real
part of a[i]; and</li>
<li>reinterpret_cast&lt;cv T*&gt;(a)[2*i+1] designates the
imaginary part of a[i].</li>
</ul>
</blockquote>

<p>
In 26.3.2 [complex] Add the member functions
</p>

<blockquote><pre>void real(T);
void imag(T);
</pre></blockquote>

<p>
Add to 26.3.4 [complex.members]
</p>

<blockquote>
<pre>T real() const;
</pre>
<blockquote>
<i>Returns:</i> the value of the real component
</blockquote>
<pre>void real(T val);
</pre>
<blockquote>
Assigns val to the real component.
</blockquote>
<pre>T imag() const;
</pre>
<blockquote>
<i>Returns:</i> the value of the imaginary component
</blockquote>
<pre>void imag(T val);
</pre>
<blockquote>
Assigns val to the imaginary component.
</blockquote>
</blockquote>

<p><i>[Kona: The layout guarantee is absolutely necessary for C
  compatibility.  However, there was disagreement about the other part
  of this proposal: retrieving elements of the complex number as
  lvalues.  An alternative: continue to have real() and imag() return
  rvalues, but add set_real() and set_imag().  Straw poll: return
  lvalues - 2, add setter functions - 5.  Related issue: do we want
  reinterpret_cast as the interface for converting a complex to an
  array of two reals, or do we want to provide a more explicit way of
  doing it?  Howard will try to resolve this issue for the next
  meeting.]</i></p>


<p><i>[pre-Sydney: Howard summarized the options in n1589.]</i></p>


<p><i>[
Bellevue:
]</i></p>


<blockquote>
Second half of proposed wording replaced and moved to Ready.
</blockquote>


<p><b>Rationale:</b></p>
<p>The LWG believes that C99 compatibility would be enough
justification for this change even without other considerations.  All
existing implementations already have the layout proposed here.</p>





<hr>
<h3><a name="394"></a>394. behavior of formatted output on failure</h3>
<p><b>Section:</b> 27.6.2.6.1 [ostream.formatted.reqmts] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Martin Sebor <b>Date:</b> 2002-12-27</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There is a contradiction in Formatted output about what bit is
supposed to be set if the formatting fails. On sentence says it's
badbit and another that it's failbit.
</p>
<p>
27.6.2.5.1, p1 says in the Common Requirements on Formatted output
functions:
</p>
<pre>     ... If the generation fails, then the formatted output function
     does setstate(ios::failbit), which might throw an exception.
</pre>
<p>
27.6.2.5.2, p1 goes on to say this about Arithmetic Inserters:
</p>
<p>
     ... The formatting conversion occurs as if it performed the
     following code fragment:
</p>
<pre>     bool failed =
         use_facet&lt;num_put&lt;charT,ostreambuf_iterator&lt;charT,traits&gt;
         &gt; &gt;
         (getloc()).put(*this, *this, fill(), val). failed();

     ... If failed is true then does setstate(badbit) ...
</pre>
<p>
The original intent of the text, according to Jerry Schwarz (see
c++std-lib-10500), is captured in the following paragraph:
</p>
<p>
In general "badbit" should mean that the stream is unusable because
of some underlying failure, such as disk full or socket closure;
"failbit" should mean that the requested formatting wasn't possible
because of some inconsistency such as negative widths.  So typically
if you clear badbit and try to output something else you'll fail
again, but if you clear failbit and try to output something else
you'll succeed.
</p>
<p>
In the case of the arithmetic inserters, since num_put cannot
report failure by any means other than exceptions (in response
to which the stream must set badbit, which prevents the kind of
recoverable error reporting mentioned above), the only other
detectable failure is if the iterator returned from num_put
returns true from failed().
</p>
<p>
Since that can only happen (at least with the required iostream
specializations) under such conditions as the underlying failure
referred to above (e.g., disk full), setting badbit would seem
to be the appropriate response (indeed, it is required in
27.6.2.5.2, p1). It follows that failbit can never be directly
set by the arithmetic (it can only be set by the sentry object
under some unspecified conditions).
</p>
<p>
The situation is different for other formatted output functions
which can fail as a result of the streambuf functions failing
(they may do so by means other than exceptions), and which are
then required to set failbit.
</p>
<p>
The contradiction, then, is that ostream::operator&lt;&lt;(int) will
set badbit if the disk is full, while operator&lt;&lt;(ostream&amp;,
char) will set failbit under the same conditions. To make the behavior
consistent, the Common requirements sections for the Formatted output
functions should be changed as proposed below.
</p>
<p><i>[Kona: There's agreement that this is a real issue.  What we
  decided at Kona: 1. An error from the buffer (which can be detected
  either directly from streambuf's member functions or by examining a
  streambuf_iterator) should always result in badbit getting set.
  2. There should never be a circumstance where failbit gets set.
  That represents a formatting error, and there are no circumstances
  under which the output facets are specified as signaling a
  formatting error. (Even more so for string output that for numeric
  because there's nothing to format.)  If we ever decide to make it
  possible for formatting errors to exist then the facets can signal
  the error directly, and that should go in clause 22, not clause 27.
  3. The phrase "if generation fails" is unclear and should be
  eliminated.  It's not clear whether it's intended to mean a buffer
  error (e.g. a full disk), a formatting error, or something else.
  Most people thought it was supposed to refer to buffer errors; if
  so, we should say so.  Martin will provide wording.]</i></p>




<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>






<hr>
<h3><a name="396"></a>396. what are characters zero and one</h3>
<p><b>Section:</b> 23.3.5.1 [bitset.cons] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Martin Sebor <b>Date:</b> 2003-01-05</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#bitset.cons">active issues</a> in [bitset.cons].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#bitset.cons">issues</a> in [bitset.cons].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
    <p>
23.3.5.1, p6 [lib.bitset.cons] talks about a generic character
having the value of 0 or 1 but there is no definition of what
that means for charT other than char and wchar_t. And even for
those two types, the values 0 and 1 are not actually what is
intended -- the values '0' and '1' are. This, along with the
converse problem in the description of to_string() in 23.3.5.2,
p33, looks like a defect remotely related to DR 303.
    </p>
    <p>
http://anubis.dkuug.dk/jtc1/sc22/wg21/docs/lwg-defects.html#303
    </p>
    <pre>23.3.5.1:
  -6-  An element of the constructed string has value zero if the
       corresponding character in str, beginning at position pos,
       is 0. Otherwise, the element has the value one.
    </pre>
    <pre>23.3.5.2:
  -33-  Effects: Constructs a string object of the appropriate
        type and initializes it to a string of length N characters.
        Each character is determined by the value of its
        corresponding bit position in *this. Character position N
        ?- 1 corresponds to bit position zero. Subsequent decreasing
        character positions correspond to increasing bit positions.
        Bit value zero becomes the character 0, bit value one becomes
        the character 1.
    </pre>
    <p>
Also note the typo in 23.3.5.1, p6: the object under construction
is a bitset, not a string.
    </p>
  

<p><b>Proposed resolution:</b></p>
<p>Change the constructor's function declaration immediately before 
23.3.5.1 [bitset.cons] p3 to:</p>
<pre>    template &lt;class charT, class traits, class Allocator&gt;
    explicit
    bitset(const basic_string&lt;charT, traits, Allocator&gt;&amp; str,
           typename basic_string&lt;charT, traits, Allocator&gt;::size_type pos = 0,
           typename basic_string&lt;charT, traits, Allocator&gt;::size_type n =
             basic_string&lt;charT, traits, Allocator&gt;::npos,
           charT zero = charT('0'), charT one = charT('1'))
</pre>
<p>Change the first two sentences of 23.3.5.1 [bitset.cons] p6 to: "An
element of the constructed string has value 0 if the corresponding
character in <i>str</i>, beginning at position <i>pos</i>,
is <i>zero</i>. Otherwise, the element has the value 1.</p>

<p>Change the text of the second sentence in 23.3.5.1, p5 to read:
    "The function then throws invalid_argument if any of the rlen
    characters in str beginning at position pos is other than <i>zero</i>
    or <i>one</i>. The function uses traits::eq() to compare the character
    values."
</p>

<p>Change the declaration of the <tt>to_string</tt> member function
  immediately before 23.3.5.2 [bitset.members] p33 to:</p>
<pre>    template &lt;class charT, class traits, class Allocator&gt;
    basic_string&lt;charT, traits, Allocator&gt; 
    to_string(charT zero = charT('0'), charT one = charT('1')) const;
</pre>
<p>Change the last sentence of 23.3.5.2 [bitset.members] p33 to: "Bit
  value 0 becomes the character <tt><i>zero</i></tt>, bit value 1 becomes the
  character <tt><i>one</i></tt>.</p>
<p>Change 23.3.5.3 [bitset.operators] p8 to:</p>
<p><b>Returns</b>:</p> 
<pre>  os &lt;&lt; x.template to_string&lt;charT,traits,allocator&lt;charT&gt; &gt;(
      use_facet&lt;ctype&lt;charT&gt; &gt;(<i>os</i>.getloc()).widen('0'),
      use_facet&lt;ctype&lt;charT&gt; &gt;(<i>os</i>.getloc()).widen('1'));
</pre>


<p><b>Rationale:</b></p>
<p>There is a real problem here: we need the character values of '0'
  and '1', and we have no way to get them since strings don't have
  imbued locales. In principle the "right" solution would be to
  provide an extra object, either a ctype facet or a full locale,
  which would be used to widen '0' and '1'. However, there was some
  discomfort about using such a heavyweight mechanism.  The proposed
  resolution allows those users who care about this issue to get it
  right.</p>
<p>We fix the inserter to use the new arguments.  Note that we already
  fixed the analogous problem with the extractor in issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#303">303</a>.</p>



<p><i>[
post Bellevue:
]</i></p>


<blockquote>
We are happy with the resolution as proposed, and we move this to Ready.
</blockquote>




<hr>
<h3><a name="397"></a>397. ostream::sentry dtor throws exceptions</h3>
<p><b>Section:</b> 27.6.2.4 [ostream::sentry] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Martin Sebor <b>Date:</b> 2003-01-05</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#ostream::sentry">active issues</a> in [ostream::sentry].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#ostream::sentry">issues</a> in [ostream::sentry].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
    <p>
17.4.4.8, p3 prohibits library dtors from throwing exceptions.
    </p>
    <p>
27.6.2.3, p4 says this about the ostream::sentry dtor:
    </p>
    <pre>    -4- If ((os.flags() &amp; ios_base::unitbuf) &amp;&amp; !uncaught_exception())
        is true, calls os.flush().
    </pre>
    <p>
27.6.2.6, p7 that describes ostream::flush() says:
    </p>
    <pre>    -7- If rdbuf() is not a null pointer, calls rdbuf()-&gt;pubsync().
        If that function returns ?-1 calls setstate(badbit) (which
        may throw ios_base::failure (27.4.4.3)).
    </pre>
    <p>
That seems like a defect, since both pubsync() and setstate() can
throw an exception. 
    </p>
<p><i>[
The contradiction is real.  Clause 17 says destructors may never
throw exceptions, and clause 27 specifies a destructor that does
throw.  In principle we might change either one.  We're leaning
toward changing clause 17: putting in an "unless otherwise specified"
clause, and then putting in a footnote saying the sentry destructor
is the only one that can throw.  PJP suggests specifying that
sentry::~sentry() should internally catch any exceptions it might cause.
]</i></p>


<p><i>[
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#418">418</a> and <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#622">622</a> for related issues.
]</i></p>


  

<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="398"></a>398. effects of end-of-file on unformatted input functions</h3>
<p><b>Section:</b> 27.6.2.4 [ostream::sentry] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Martin Sebor <b>Date:</b> 2003-01-05</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#ostream::sentry">active issues</a> in [ostream::sentry].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#ostream::sentry">issues</a> in [ostream::sentry].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
    <p>
While reviewing unformatted input member functions of istream
for their behavior when they encounter end-of-file during input
I found that the requirements vary, sometimes unexpectedly, and
in more than one case even contradict established practice (GNU
libstdc++ 3.2, IBM VAC++ 6.0, STLPort 4.5, SunPro 5.3, HP aCC
5.38, Rogue Wave libstd 3.1, and Classic Iostreams).
    </p>
    <p>
The following unformatted input member functions set eofbit if they
encounter an end-of-file (this is the expected behavior, and also
the behavior of all major implementations):
    </p>
    <pre>    basic_istream&lt;charT, traits&gt;&amp;
    get (char_type*, streamsize, char_type);
    </pre>
    <p>
    Also sets failbit if it fails to extract any characters.
    </p>
    <pre>    basic_istream&lt;charT, traits&gt;&amp;
    get (char_type*, streamsize);
    </pre>
    <p>
    Also sets failbit if it fails to extract any characters.
    </p>
    <pre>    basic_istream&lt;charT, traits&gt;&amp;
    getline (char_type*, streamsize, char_type);
    </pre>
    <p>
    Also sets failbit if it fails to extract any characters.
    </p>
    <pre>    basic_istream&lt;charT, traits&gt;&amp;
    getline (char_type*, streamsize);
    </pre>
    <p>
    Also sets failbit if it fails to extract any characters.
    </p>
    <pre>    basic_istream&lt;charT, traits&gt;&amp;
    ignore (int, int_type);
    </pre>
    <pre>    basic_istream&lt;charT, traits&gt;&amp;
    read (char_type*, streamsize);
    </pre>
    <p>
    Also sets failbit if it encounters end-of-file.
    </p>
    <pre>    streamsize readsome (char_type*, streamsize);
    </pre>

    <p>
The following unformated input member functions set failbit but
not eofbit if they encounter an end-of-file (I find this odd
since the functions make it impossible to distinguish a general
failure from a failure due to end-of-file; the requirement is
also in conflict with all major implementation which set both
eofbit and failbit):
    </p>
    <pre>    int_type get();
    </pre>
    <pre>    basic_istream&lt;charT, traits&gt;&amp;
    get (char_type&amp;);
    </pre>
    <p>
These functions only set failbit of they extract no characters,
otherwise they don't set any bits, even on failure (I find this
inconsistency quite unexpected; the requirement is also in
conflict with all major implementations which set eofbit
whenever they encounter end-of-file):
    </p>
    <pre>    basic_istream&lt;charT, traits&gt;&amp;
    get (basic_streambuf&lt;charT, traits&gt;&amp;, char_type);
    </pre>
    <pre>    basic_istream&lt;charT, traits&gt;&amp;
    get (basic_streambuf&lt;charT, traits&gt;&amp;);
    </pre>
    <p>
This function sets no bits (all implementations except for
STLport and Classic Iostreams set eofbit when they encounter
end-of-file):
    </p>
    <pre>    int_type peek ();
    </pre>
<p>Informally, what we want is a global statement of intent saying
  that eofbit gets set if we trip across EOF, and then we can take
  away the specific wording for individual functions.  A full review
  is necessary.  The wording currently in the standard is a mishmash,
  and changing it on an individual basis wouldn't make things better.
  Dietmar will do this work.</p>
  

<p><b>Proposed resolution:</b></p>




<hr>
<h3><a name="408"></a>408. Is vector&lt;reverse_iterator&lt;char*&gt; &gt; forbidden?</h3>
<p><b>Section:</b> 24.1 [iterator.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Nathan Myers <b>Date:</b> 2003-06-03</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#iterator.requirements">active issues</a> in [iterator.requirements].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#iterator.requirements">issues</a> in [iterator.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I've been discussing iterator semantics with Dave Abrahams, and a 
surprise has popped up.  I don't think this has been discussed before.
</p>

<p>
24.1 [iterator.requirements] says that the only operation that can be performed on "singular"
iterator values is to assign a non-singular value to them.  (It 
doesn't say they can be destroyed, and that's probably a defect.)  
Some implementations have taken this to imply that there is no need 
to initialize the data member of a reverse_iterator&lt;&gt; in the default
constructor.  As a result, code like
</p>
<blockquote><pre>  std::vector&lt;std::reverse_iterator&lt;char*&gt; &gt; v(7);
  v.reserve(1000);
</pre></blockquote>
<p>
invokes undefined behavior, because it must default-initialize the
vector elements, and then copy them to other storage.  Of course many 
other vector operations on these adapters are also left undefined,
and which those are is not reliably deducible from the standard.
</p>

<p>
I don't think that 24.1 was meant to make standard-library iterator 
types unsafe.  Rather, it was meant to restrict what operations may 
be performed by functions which take general user- and standard 
iterators as arguments, so that raw pointers would qualify as
iterators.  However, this is not clear in the text, others have come 
to the opposite conclusion.
</p>

<p>
One question is whether the standard iterator adaptors have defined
copy semantics.  Another is whether they have defined destructor
semantics: is
</p>
<blockquote><pre>  { std::vector&lt;std::reverse_iterator&lt;char*&gt; &gt;  v(7); }
</pre></blockquote>
<p>
undefined too?
</p>

<p>
Note this is not a question of whether algorithms are allowed to
rely on copy semantics for arbitrary iterators, just whether the
types we actually supply support those operations.  I believe the 
resolution must be expressed in terms of the semantics of the 
adapter's argument type.  It should make clear that, e.g., the 
reverse_iterator&lt;T&gt; constructor is actually required to execute
T(), and so copying is defined if the result of T() is copyable.
</p>

<p>
Issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#235">235</a>, which defines reverse_iterator's default
constructor more precisely, has some relevance to this issue.
However, it is not the whole story.
</p>

<p>
The issue was whether 
</p>
<blockquote><pre>  reverse_iterator() { }
</pre></blockquote>
<p>
is allowed, vs. 
</p>
<blockquote><pre>  reverse_iterator() : current() { }
</pre></blockquote>

<p>
The difference is when T is char*, where the first leaves the member
uninitialized, and possibly equal to an existing pointer value, or
(on some targets) may result in a hardware trap when copied.
</p>

<p>
8.5 paragraph 5 seems to make clear that the second is required to
satisfy DR <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#235">235</a>, at least for non-class Iterator argument
types.
</p>

<p>
But that only takes care of reverse_iterator, and doesn't establish
a policy for all iterators.  (The reverse iterator adapter was just
an example.)  In particular, does my function
</p>
<blockquote><pre>  template &lt;typename Iterator&gt;
    void f() { std::vector&lt;Iterator&gt;  v(7); } 
</pre></blockquote>
<p>
evoke undefined behavior for some conforming iterator definitions?
I think it does, now, because vector&lt;&gt; will destroy those singular
iterator values, and that's explicitly disallowed.
</p>

<p>
24.1 shouldn't give blanket permission to copy all singular iterators,
because then pointers wouldn't qualify as iterators.  However, it
should allow copying of that subset of singular iterator values that
are default-initialized, and it should explicitly allow destroying any
iterator value, singular or not, default-initialized or not.
</p>

<p>Related issue: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#407">407</a></p>
<p><i>[
We don't want to require all singular iterators to be copyable,
because that is not the case for pointers.  However, default
construction may be a special case.  Issue: is it really default
construction we want to talk about, or is it something like value
initialization?  We need to check with core to see whether default
constructed pointers are required to be copyable; if not, it would be
wrong to impose so strict a requirement for iterators.
]</i></p>




<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="417"></a>417. what does ctype::do_widen() return on failure</h3>
<p><b>Section:</b> 22.2.1.1.2 [locale.ctype.virtuals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Martin Sebor <b>Date:</b> 2003-09-18</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.ctype.virtuals">issues</a> in [locale.ctype.virtuals].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The Effects and Returns clauses of the do_widen() member function of
the ctype facet fail to specify the behavior of the function on failure.
That the function may not be able to simply cast the narrow character
argument to the type of the result since doing so may yield the wrong value
for some wchar_t encodings. Popular implementations of ctype&lt;wchar_t&gt; that
use mbtowc() and UTF-8 as the native encoding (e.g., GNU glibc) will fail
when the argument's MSB is set. There is no way for the the rest of locale
and iostream to reliably detect this failure. 
</p>
<p><i>[Kona: This is a real problem.  Widening can fail.  It's unclear
  what the solution should be.  Returning WEOF works for the wchar_t
  specialization, but not in general.  One option might be to add a
  default, like <i>narrow</i>.  But that's an incompatible change.
  Using <i>traits::eof</i> might seem like a good idea, but facets
  don't have access to traits (a recurring problem).  We could
  have <i>widen</i> throw an exception, but that's a scary option;
  existing library components aren't written with the assumption
  that <i>widen</i> can throw.]</i></p>



<p><b>Proposed resolution:</b></p>




<hr>
<h3><a name="418"></a>418. exceptions thrown during iostream cleanup</h3>
<p><b>Section:</b> 27.4.2.1.6 [ios::Init] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Martin Sebor <b>Date:</b> 2003-09-18</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The dtor of the ios_base::Init object is supposed to call flush() on the
6 standard iostream objects cout, cerr, clog, wcout, wcerr, and wclog.
This call may cause an exception to be thrown.
</p>

<p>
17.4.4.8, p3 prohibits all library destructors from throwing exceptions.
</p>

<p>
The question is: What should this dtor do if one or more of these calls
to flush() ends up throwing an exception? This can happen quite easily
if one of the facets installed in the locale imbued in the iostream
object throws.
</p>
<p><i>[Kona: We probably can't do much better than what we've got, so
  the LWG is leaning toward NAD.  At the point where the standard
  stream objects are being cleaned up, the usual error reporting
  mechanism are all unavailable.  And exception from flush at this
  point will definitely cause problems.  A quality implementation
  might reasonably swallow the exception, or call abort, or do
  something even more drastic.]</i></p>


<p><i>[
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#397">397</a> and <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#622">622</a> for related issues.
]</i></p>




<p><b>Proposed resolution:</b></p>




<hr>
<h3><a name="419"></a>419. istream extractors not setting failbit if eofbit is already set</h3>
<p><b>Section:</b> 27.6.1.1.3 [istream::sentry] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Martin Sebor <b>Date:</b> 2003-09-18</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#istream::sentry">issues</a> in [istream::sentry].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
        <p>

27.6.1.1.3 [istream::sentry], p2 says that istream::sentry ctor prepares for input if is.good()
is true. p4 then goes on to say that the ctor sets the sentry::ok_ member to
true if the stream state is good after any preparation. 27.6.1.2.1 [istream.formatted.reqmts], p1 then
says that a formatted input function endeavors to obtain the requested input
if the sentry's operator bool() returns true.

Given these requirements, no formatted extractor should ever set failbit if
the initial stream rdstate() == eofbit. That is contrary to the behavior of
all implementations I tested. The program below prints out

eof = 1, fail = 0
eof = 1, fail = 1

on all of them.
        </p>
<pre>
#include &lt;sstream&gt;
#include &lt;cstdio&gt;

int main()
{
    std::istringstream strm ("1");

    int i = 0;

    strm &gt;&gt; i;

    std::printf ("eof = %d, fail = %d\n",
                 !!strm.eof (), !!strm.fail ());

    strm &gt;&gt; i;

    std::printf ("eof = %d, fail = %d\n",
                 !!strm.eof (), !!strm.fail ());
}

</pre>
        <p>
<br>

Comments from Jerry Schwarz (c++std-lib-11373):
<br>

Jerry Schwarz wrote:
<br>

I don't know where (if anywhere) it says it in the standard, but the
formatted extractors are supposed to set failbit if they don't extract
any characters. If they didn't then simple loops like
<br>

while (cin &gt;&gt; x);
<br>

would loop forever.
<br>

Further comments from Martin Sebor:
<br>

The question is which part of the extraction should prevent this from happening
by setting failbit when eofbit is already set. It could either be the sentry
object or the extractor. It seems that most implementations have chosen to
set failbit in the sentry [...] so that's the text that will need to be
corrected. 

        </p>
<p>
Pre Berlin:  This issue is related to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#342">342</a>.  If the sentry
sets <tt>failbit</tt> when it finds <tt>eofbit</tt> already set, then
you can never seek away from the end of stream.
</p>
<p>Kona: Possibly NAD.  If eofbit is set then good() will return false.  We
  then set <i>ok</i> to false.  We believe that the sentry's
  constructor should always set failbit when <i>ok</i> is false, and
  we also think the standard already says that.  Possibly it could be
  clearer.</p> 

    

<p><b>Proposed resolution:</b></p>
<p>
Change 27.6.1.1.3 [istream::sentry], p2 to:
</p>

<blockquote>
<pre>explicit sentry(basic_istream&lt;charT,traits&gt;&amp; <i>is</i> , bool <i>noskipws</i> = false);</pre>
<p>
-2- <i>Effects:</i> If <tt>is.good()</tt> is <del><tt>true</tt></del>
<ins><tt>false</tt></ins>, <ins>calls <tt>is.setstate(failbit)</tt>. 
Otherwise</ins> prepares for formatted or unformatted input. ...
</p>
</blockquote>






<hr>
<h3><a name="421"></a>421. is basic_streambuf copy-constructible?</h3>
<p><b>Section:</b> 27.5.2.1 [streambuf.cons] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Martin Sebor <b>Date:</b> 2003-09-18</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#streambuf.cons">issues</a> in [streambuf.cons].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The reflector thread starting with c++std-lib-11346 notes that the class
template basic_streambuf, along with basic_stringbuf and basic_filebuf,
is copy-constructible but that the semantics of the copy constructors
are not defined anywhere. Further, different implementations behave
differently in this respect: some prevent copy construction of objects
of these types by declaring their copy ctors and assignment operators
private, others exhibit undefined behavior, while others still give
these operations well-defined semantics.
</p>

<p>
Note that this problem doesn't seem to be isolated to just the three
types mentioned above. A number of other types in the library section
of the standard provide a compiler-generated copy ctor and assignment
operator yet fail to specify their semantics.  It's believed that the
only types for which this is actually a problem (i.e. types where the
compiler-generated default may be inappropriate and may not have been
intended) are locale facets.  See issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#439">439</a>.
</p>


<p><b>Proposed resolution:</b></p>
<p>
27.5.2 [lib.streambuf]:  Add into the synopsis, public section, just above the destructor declaration:
</p>

<blockquote>
<pre>basic_streambuf(const basic_streambuf&amp; sb);
basic_streambuf&amp; operator=(const basic_streambuf&amp; sb);
</pre>
</blockquote>

<p>Insert after 27.5.2.1, paragraph 2:</p>
<blockquote>
<pre>basic_streambuf(const basic_streambuf&amp; sb);
</pre>

<p>Constructs a copy of sb.</p>
<p>Postcondtions:</p>
<pre>                eback() == sb.eback()
                gptr()  == sb.gptr()
                egptr() == sb.egptr()
                pbase() == sb.pbase()
                pptr()  == sb.pptr()
                epptr() == sb.epptr()
                getloc() == sb.getloc()
</pre>

<pre>basic_streambuf&amp; operator=(const basic_streambuf&amp; sb);
</pre>

<p>Assigns the data members of sb to this.</p>

<p>Postcondtions:</p>
<pre>                eback() == sb.eback()
                gptr()  == sb.gptr()
                egptr() == sb.egptr()
                pbase() == sb.pbase()
                pptr()  == sb.pptr()
                epptr() == sb.epptr()
                getloc() == sb.getloc()
</pre>

<p>Returns: *this.</p>
</blockquote>

<p>27.7.1 [lib.stringbuf]:</p>

<p><b>Option A:</b></p>

<blockquote>
<p>Insert into the basic_stringbuf synopsis in the private section:</p>

<pre>basic_stringbuf(const basic_stringbuf&amp;);             // not defined
basic_stringbuf&amp; operator=(const basic_stringbuf&amp;);  // not defined
</pre>
</blockquote>

<p><b>Option B:</b></p>

<blockquote>
<p>Insert into the basic_stringbuf synopsis in the public section:</p>

<pre>basic_stringbuf(const basic_stringbuf&amp; sb);
basic_stringbuf&amp; operator=(const basic_stringbuf&amp; sb);
</pre>

<p>27.7.1.1, insert after paragraph 4:</p>

<pre>basic_stringbuf(const basic_stringbuf&amp; sb);</pre>

<p>
Constructs an independent copy of sb as if with sb.str(), and with the openmode that sb was constructed with.
</p>

<p>Postcondtions: </p>
<pre>               str() == sb.str()
               gptr()  - eback() == sb.gptr()  - sb.eback()
               egptr() - eback() == sb.egptr() - sb.eback()
               pptr()  - pbase() == sb.pptr()  - sb.pbase()
               getloc() == sb.getloc()
</pre>

<p>
Note: The only requirement on epptr() is that it point beyond the
initialized range if an output sequence exists. There is no requirement
that epptr() - pbase() == sb.epptr() - sb.pbase().
</p>

<pre>basic_stringbuf&amp; operator=(const basic_stringbuf&amp; sb);</pre>
<p>After assignment the basic_stringbuf has the same state as if it
were initially copy constructed from sb, except that the
basic_stringbuf is allowed to retain any excess capacity it might have,
which may in turn effect the value of epptr().
</p>
</blockquote>

<p>27.8.1.1 [lib.filebuf]</p>

<p>Insert at the bottom of the basic_filebuf synopsis:</p>

<blockquote>
<pre>private:
  basic_filebuf(const basic_filebuf&amp;);             // not defined
  basic_filebuf&amp; operator=(const basic_filebuf&amp;);  // not defined
</pre>
</blockquote>
<p><i>[Kona: this is an issue for basic_streambuf itself and for its
  derived classes.  We are leaning toward allowing basic_streambuf to
  be copyable, and specifying its precise semantics.  (Probably the
  obvious: copying the buffer pointers.)  We are less sure whether
  the streambuf derived classes should be copyable.  Howard will
  write up a proposal.]</i></p>


<p><i>[Sydney: Dietmar presented a new argument against basic_streambuf
  being copyable: it can lead to an encapsulation violation. Filebuf
  inherits from streambuf. Now suppose you inhert a my_hijacking_buf
  from streambuf. You can copy the streambuf portion of a filebuf to a
  my_hijacking_buf, giving you access to the pointers into the
  filebuf's internal buffer. Perhaps not a very strong argument, but
  it was strong enough to make people nervous. There was weak
  preference for having streambuf not be copyable. There was weak
  preference for having stringbuf not be copyable even if streambuf
  is. Move this issue to open for now.
]</i></p>


<p><i>[
2007-01-12, Howard:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1862.html#27.5.2%20-%20Class%20template%20basic_streambuf%3CcharT,traits%3E">Rvalue Reference Recommendations for Chapter 27</a>
recommends protected copy constructor and assignment for <tt>basic_streambuf</tt> with the same semantics
as would be generated by the compiler.  These members aid in derived classes implementing move semantics.
A protected copy constructor and copy assignment operator do not expose encapsulation more so than it is
today as each data member of a <tt>basic_streambuf</tt> is already both readable and writable by derived
classes via various get/set protected member functions (<tt>eback()</tt>, <tt>setp()</tt>, etc.).  Rather
a protected copy constructor and copy assignment operator simply make the job of derived classes implementing
move semantics less tedious and error prone.
]</i></p>




<p><b>Rationale:</b></p>
<p>
27.5.2 [lib.streambuf]: The proposed basic_streambuf copy constructor
and assignment operator are the same as currently implied by the lack
of declarations: public and simply copies the data members.  This
resolution is not a change but a clarification of the current
standard.
</p>

<p>
27.7.1 [lib.stringbuf]: There are two reasonable options: A) Make
basic_stringbuf not copyable.  This is likely the status-quo of
current implementations.  B) Reasonable copy semantics of
basic_stringbuf can be defined and implemented.  A copyable
basic_streambuf is arguably more useful than a non-copyable one.  This
should be considered as new functionality and not the fixing of a
defect.  If option B is chosen, ramifications from issue 432 are taken
into account.
</p>

<p>
27.8.1.1 [lib.filebuf]: There are no reasonable copy semantics for
basic_filebuf.
</p>






<hr>
<h3><a name="423"></a>423. effects of negative streamsize in iostreams</h3>
<p><b>Section:</b> 27 [input.output] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Martin Sebor <b>Date:</b> 2003-09-18</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#input.output">issues</a> in [input.output].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
A third party test suite tries to exercise istream::ignore(N) with
a negative value of N and expects that the implementation will treat
N as if it were 0. Our implementation asserts that (N &gt;= 0) holds and
aborts the test.
</p>

<p>
I can't find anything in section 27 that prohibits such values but I don't
see what the effects of such calls should be, either (this applies to
a number of unformatted input functions as well as some member functions
of the basic_streambuf template).
</p>


<p><b>Proposed resolution:</b></p>
<p>
I propose that we add to each function in clause 27 that takes an argument,
say N, of type streamsize a Requires clause saying that "N &gt;= 0." The intent
is to allow negative streamsize values in calls to precision() and width()
but disallow it in calls to streambuf::sgetn(), istream::ignore(), or
ostream::write().
</p>

<p><i>[Kona: The LWG agreed that this is probably what we want.  However, we
  need a review to find all places where functions in clause 27 take
  arguments of type streamsize that shouldn't be allowed to go
  negative.  Martin will do that review.]</i></p>






<hr>
<h3><a name="427"></a>427. stage 2 and rationale of DR 221</h3>
<p><b>Section:</b> 22.2.2.1.2 [facet.num.get.virtuals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Martin Sebor <b>Date:</b> 2003-09-18</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#facet.num.get.virtuals">active issues</a> in [facet.num.get.virtuals].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#facet.num.get.virtuals">issues</a> in [facet.num.get.virtuals].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The requirements specified in Stage 2 and reiterated in the rationale
of DR 221 (and echoed again in DR 303) specify that num_get&lt;charT&gt;::
do_get() compares characters on the stream against the widened elements
of "012...abc...ABCX+-"
</p>

<p>
An implementation is required to allow programs to instantiate the num_get
template on any charT that satisfies the requirements on a user-defined
character type. These requirements do not include the ability of the
character type to be equality comparable (the char_traits template must
be used to perform tests for equality). Hence, the num_get template cannot
be implemented to support any arbitrary character type. The num_get template
must either make the assumption that the character type is equality-comparable
(as some popular implementations do), or it may use char_traits&lt;charT&gt; to do
the comparisons (some other popular implementations do that). This diversity
of approaches makes it difficult to write portable programs that attempt to
instantiate the num_get template on user-defined types.
</p>

<p><i>[Kona: the heart of the problem is that we're theoretically
  supposed to use traits classes for all fundamental character
  operations like assignment and comparison, but facets don't have
  traits parameters.  This is a fundamental design flaw and it
  appears all over the place, not just in this one place.  It's not
  clear what the correct solution is, but a thorough review of facets
  and traits is in order.  The LWG considered and rejected the
  possibility of changing numeric facets to use narrowing instead of
  widening.  This may be a good idea for other reasons (see issue
  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#459">459</a>), but it doesn't solve the problem raised by this
  issue.  Whether we use widen or narrow the <tt>num_get</tt> facet
  still has no idea which traits class the user wants to use for 
  the comparison, because only streams, not facets, are passed traits
  classes.   The standard does not require that two different
  traits classes with the same <tt>char_type</tt> must necessarily 
  have the same behavior.]</i></p>


<p>Informally, one possibility: require that some of the basic
character operations, such as <tt>eq</tt>, <tt>lt</tt>,
and <tt>assign</tt>, must behave the same way for all traits classes
with the same <tt>char_type</tt>.  If we accept that limitation on
traits classes, then the facet could reasonably be required to
use <tt>char_traits&lt;charT&gt;</tt>.</p>


<p><b>Proposed resolution:</b></p>




<hr>
<h3><a name="430"></a>430. valarray subset operations</h3>
<p><b>Section:</b> 26.5.2.4 [valarray.sub] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Martin Sebor <b>Date:</b> 2003-09-18</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The standard fails to specify the behavior of valarray::operator[](slice)
and other valarray subset operations when they are passed an "invalid"
slice object, i.e., either a slice that doesn't make sense at all (e.g.,
slice (0, 1, 0) or one that doesn't specify a valid subset of the valarray
object (e.g., slice (2, 1, 1) for a valarray of size 1).
</p>
<p><i>[Kona: the LWG believes that invalid slices should invoke
  undefined behavior.  Valarrays are supposed to be designed for high
  performance, so we don't want to require specific checking.  We
  need wording to express this decision.]</i></p>


<p><i>[
Bellevue:
]</i></p>


<blockquote>
Please note that the standard also fails to specify the behavior of
slice_array and gslice_array in the valid case. Bill Plauger will
endeavor to provide revised wording for slice_array and gslice_array.
</blockquote>

<p><i>[
post-Bellevue:  Bill provided wording.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
Insert after 26.5.2.4 [valarray.sub], paragraph 1:
</p>

<blockquote>
<p>
The member operator is overloaded to provide several ways to select
sequences
of elements from among those controlled by <tt>*this</tt>. The first group of five
member operators work in conjunction with various overloads of <tt>operator=</tt>
(and other assigning operators) to allow selective replacement (slicing) of
the controlled sequence. The selected elements must exist.
</p>
<p>
The first member operator selects element off. For example:
</p>

<blockquote><pre>valarray&lt;char&gt; v0("abcdefghijklmnop", 16);
v0[3] = 'A';
// v0 == valarray&lt;char&gt;("abcAefghijklmnop", 16)
</pre></blockquote>

<p>
The second member operator selects those elements of the controlled sequence
designated by <tt>slicearr</tt>. For example:
</p>

<blockquote><pre>valarray&lt;char&gt; v0("abcdefghijklmnop", 16);
valarray&lt;char&gt; v1("ABCDE", 5);
v0[slice(2, 5, 3)] = v1;
// v0 == valarray&lt;char&gt;("abAdeBghCjkDmnEp", 16)
</pre></blockquote>

<p>
The third member operator selects those elements of the controlled sequence
designated by <tt>gslicearr</tt>. For example:
</p>

<blockquote><pre>valarray&lt;char&gt; v0("abcdefghijklmnop", 16);
valarray&lt;char&gt; v1("ABCDEF", 6);
const size_t lv[] = {2, 3};
const size_t dv[] = {7, 2};
const valarray&lt;size_t&gt; len(lv, 2), str(dv, 2);
v0[gslice(3, len, str)] = v1;
// v0 == valarray&lt;char&gt;("abcAeBgCijDlEnFp", 16)
</pre></blockquote>

<p>
The fourth member operator selects those elements of the controlled sequence
designated by <tt>boolarr</tt>. For example:
</p>

<blockquote><pre>valarray&lt;char&gt; v0("abcdefghijklmnop", 16);
valarray&lt;char&gt; v1("ABC", 3);
const bool vb[] = {false, false, true, true, false, true};
v0[valarray&lt;bool&gt;(vb, 6)] = v1;
// v0 == valarray&lt;char&gt;("abABeCghijklmnop", 16)
</pre></blockquote>

<p>
The fifth member operator selects those elements of the controlled sequence
designated by indarr. For example:
</p>

<blockquote><pre>valarray&lt;char&gt; v0("abcdefghijklmnop", 16);
valarray&lt;char&gt; v1("ABCDE", 5);
const size_t vi[] = {7, 5, 2, 3, 8};
v0[valarray&lt;size_t&gt;(vi, 5)] = v1;
// v0 == valarray&lt;char&gt;("abCDeBgAEjklmnop", 16)
</pre></blockquote>

<p>
The second group of five member operators each construct an object that
represents the value(s) selected. The selected elements must exist.
</p>

<p>
The sixth member operator returns the value of element off. For example:
</p>

<blockquote><pre>valarray&lt;char&gt; v0("abcdefghijklmnop", 16);
// v0[3] returns 'd'
</pre></blockquote>

<p>
The seventh member operator returns an object of class <tt>valarray&lt;Ty&gt;</tt>
containing those elements of the controlled sequence designated by <tt>slicearr</tt>.
For example:
</p>

<blockquote><pre>valarray&lt;char&gt; v0("abcdefghijklmnop", 16);
// v0[slice(2, 5, 3)] returns valarray&lt;char&gt;("cfilo", 5)
</pre></blockquote>

<p>
The eighth member operator selects those elements of the controlled sequence
designated by <tt>gslicearr</tt>. For example:
</p>

<blockquote><pre>valarray&lt;char&gt; v0("abcdefghijklmnop", 16);
const size_t lv[] = {2, 3};
const size_t dv[] = {7, 2};
const valarray&lt;size_t&gt; len(lv, 2), str(dv, 2);
// v0[gslice(3, len, str)] returns
// &nbsp;&nbsp;&nbsp;valarray&lt;char&gt;("dfhkmo", 6)
</pre></blockquote>

<p>
The ninth member operator selects those elements of the controlled sequence
designated by <tt>boolarr</tt>. For example:
</p>

<blockquote><pre>valarray&lt;char&gt; v0("abcdefghijklmnop", 16);
const bool vb[] = {false, false, true, true, false, true};
// v0[valarray&lt;bool&gt;(vb, 6)] returns
// &nbsp;&nbsp;&nbsp;valarray&lt;char&gt;("cdf", 3)
</pre></blockquote>

<p>
The last member operator selects those elements of the controlled sequence
designated by <tt>indarr</tt>. For example:
</p>

<blockquote><pre>valarray&lt;char&gt; v0("abcdefghijklmnop", 16);
const size_t vi[] = {7, 5, 2, 3, 8};
// v0[valarray&lt;size_t&gt;(vi, 5)] returns
//    valarray&lt;char&gt;("hfcdi", 5)
</pre></blockquote>

</blockquote>





<hr>
<h3><a name="431"></a>431. Swapping containers with unequal allocators</h3>
<p><b>Section:</b> 20.1.2 [allocator.requirements], 25 [algorithms] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Matt Austern <b>Date:</b> 2003-09-20</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#allocator.requirements">active issues</a> in [allocator.requirements].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#allocator.requirements">issues</a> in [allocator.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>Clause 20.1.2 [allocator.requirements] paragraph 4 says that implementations
  are permitted to supply containers that are unable to cope with
  allocator instances and that container implementations may assume
  that all instances of an allocator type compare equal.  We gave
  implementers this latitude as a temporary hack, and eventually we
  want to get rid of it.  What happens when we're dealing with
  allocators that <i>don't</i> compare equal?
</p>

<p>In particular: suppose that <tt>v1</tt> and <tt>v2</tt> are both
  objects of type <tt>vector&lt;int, my_alloc&gt;</tt> and that
  <tt>v1.get_allocator() != v2.get_allocator()</tt>.  What happens if
  we write <tt>v1.swap(v2)</tt>?  Informally, three possibilities:</p>

<p>1. This operation is illegal.  Perhaps we could say that an
  implementation is required to check and to throw an exception, or
  perhaps we could say it's undefined behavior.</p>
<p>2. The operation performs a slow swap (i.e. using three
  invocations of <tt>operator=</tt>, leaving each allocator with its
  original container.  This would be an O(N) operation.</p>
<p>3. The operation swaps both the vectors' contents and their
  allocators.  This would be an O(1) operation. That is:</p>
  <blockquote>
  <pre>    my_alloc a1(...);
    my_alloc a2(...);
    assert(a1 != a2);

    vector&lt;int, my_alloc&gt; v1(a1);
    vector&lt;int, my_alloc&gt; v2(a2);
    assert(a1 == v1.get_allocator());
    assert(a2 == v2.get_allocator());

    v1.swap(v2);
    assert(a1 == v2.get_allocator());
    assert(a2 == v1.get_allocator());
  </pre>
  </blockquote>

<p><i>[Kona: This is part of a general problem.  We need a paper
  saying how to deal with unequal allocators in general.]</i></p>


<p><i>[pre-Sydney: Howard argues for option 3 in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1599.html">N1599</a>.
]</i></p>


<p><i>[
2007-01-12, Howard:  This issue will now tend to come up more often with move constructors
and move assignment operators.  For containers, these members transfer resources (i.e.
the allocated memory) just like swap.
]</i></p>


<p><i>[
Batavia:  There is agreement to overload the container <tt>swap</tt> on the allocator's Swappable
requirement using concepts.  If the allocator supports Swappable, then container's swap will
swap allocators, else it will perform a "slow swap" using copy construction and copy assignment.
]</i></p>




<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="446"></a>446. Iterator equality between different containers</h3>
<p><b>Section:</b> 24.1 [iterator.requirements], 23.1 [container.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Andy Koenig <b>Date:</b> 2003-12-16</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#iterator.requirements">active issues</a> in [iterator.requirements].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#iterator.requirements">issues</a> in [iterator.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
What requirements does the standard place on equality comparisons between
iterators that refer to elements of different containers.  For example, if
v1 and v2 are empty vectors, is v1.end() == v2.end() allowed to yield true?
Is it allowed to throw an exception?
</p>

<p>
The standard appears to be silent on both questions.
</p>
<p><i>[Sydney: The intention is that comparing two iterators from
different containers is undefined, but it's not clear if we say that,
or even whether it's something we should be saying in clause 23 or in
clause 24.  Intuitively we might want to say that equality is defined
only if one iterator is reachable from another, but figuring out how
to say it in any sensible way is a bit tricky: reachability is defined
in terms of equality, so we can't also define equality in terms of
reachability.
]</i></p>




<p><b>Proposed resolution:</b></p>






<hr>
<h3><a name="454"></a>454. basic_filebuf::open should accept wchar_t names</h3>
<p><b>Section:</b> 27.8.1.4 [filebuf.members] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Bill Plauger <b>Date:</b> 2004-01-30</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#filebuf.members">active issues</a> in [filebuf.members].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#filebuf.members">issues</a> in [filebuf.members].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#105">105</a></p>
<p><b>Discussion:</b></p>
<pre>    basic_filebuf *basic_filebuf::open(const char *, ios_base::open_mode);
</pre>

<p>should be supplemented with the overload:</p>

<pre>    basic_filebuf *basic_filebuf::open(const wchar_t *, ios_base::open_mode);
</pre>

<p>
Depending on the operating system, one of these forms is fundamental and
the other requires an implementation-defined mapping to determine the
actual filename.
</p>

<p><i>[Sydney: Yes, we want to allow wchar_t filenames.  Bill will
  provide wording.]</i></p>


<p><i>[
In Toronto we noted that this is issue 5 from
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1569.htm">N1569</a>.
]</i></p>

<p>
How does this interact with the newly-defined character types, and how
do we avoid interface explosion considering <tt>std::string</tt> overloads that
were added? Propose another solution that is different than the
suggestion proposed by PJP.
</p>
<p>
Suggestion is to make a member template function for <tt>basic_string</tt> (for
<tt>char</tt>, <tt>wchar_t</tt>, <tt>u16char</tt>, <tt>u32char</tt> instantiations), and then just keep a
<tt>const char*</tt> member.
</p>
<p>
Goal is to do implicit conversion between character string literals to
appropriate <tt>basic_string</tt> type. Not quite sure if this is possible.
</p>
<p>
Implementors are free to add specific overloads for non-char character
types.
</p>



<p><b>Proposed resolution:</b></p>

<p>Change from:</p>
<blockquote>
<pre>basic_filebuf&lt;charT,traits&gt;* open(
	const char* s,
	ios_base::openmode mode );
</pre>

<p>
Effects: If is_open() != false, returns a null pointer.
Otherwise, initializes the filebuf as required. It then
opens a file, if possible, whose name is the NTBS s ("as if"
by calling std::fopen(s,modstr)).</p>
</blockquote>

<p>to:</p>

<blockquote>
<pre>basic_filebuf&lt;charT,traits&gt;* open(
	const char* s,
	ios_base::openmode mode );

basic_filebuf&lt;charT,traits&gt;* open(
	const wchar_t* ws,
	ios_base::openmode mode );
</pre>

<p>
Effects: If is_open() != false, returns a null pointer.
Otherwise, initializes the filebuf as required. It then
opens a file, if possible, whose name is the NTBS s ("as if"
by calling std::fopen(s,modstr)).
For the second signature, the NTBS s is determined from the
WCBS ws in an implementation-defined manner.
</p>

<p>
(NOTE: For a system that "naturally" represents a filename
as a WCBS, the NTBS s in the first signature may instead
be mapped to a WCBS; if so, it follows the same mapping
rules as the first argument to open.)
</p>
</blockquote>



<p><b>Rationale:</b></p>
<p>
Slightly controversial, but by a 7-1 straw poll the LWG agreed to move
this to Ready.  The controversy was because the mapping between wide
names and files in a filesystem is implementation defined.  The
counterargument, which most but not all LWG members accepted, is that
the mapping between narrow files names and files is also
implemenation defined.</p>

<p><i>[Lillehammer: Moved back to "open" status, at Beman's urging.
(1) Why just basic_filebuf, instead of also basic_fstream (and
possibly other things too). (2) Why not also constructors that take
std::basic_string? (3) We might want to wait until we see Beman's
filesystem library; we might decide that it obviates this.]</i></p>


<p><i>[
post Bellevue:
]</i></p>


<blockquote>
<p>
Move again to Ready.
</p>
<p>
There is a timing issue here. Since the filesystem library will not be
in C++0x, this should be brought forward. This solution would remain
valid in the context of the proposed filesystem.
</p>
<p>
This issue has been kicking around for a while, and the wchar_t addition
alone would help many users. Thus, we suggest putting this on the
reflector list with an invitation for someone to produce proposed
wording that covers basic_fstream. In the meantime, we suggest that the
proposed wording be adopted as-is.
</p>
<p>
If more of the Lillehammer questions come back, they should be
introduced as separate issues.
</p>
</blockquote>








<hr>
<h3><a name="458"></a>458. 24.1.5 contains unintented limitation for operator-</h3>
<p><b>Section:</b> 24.1.5 [random.access.iterators] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Daniel Frey <b>Date:</b> 2004-02-27</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#random.access.iterators">issues</a> in [random.access.iterators].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 24.1.5 [lib.random.access.iterators], table 76 the operational
semantics for the expression "r -= n" are defined as "return r += -n".
This means, that the expression -n must be valid, which is not the case
for unsigned types. 
</p>

<p><i>[
Sydney: Possibly not a real problem, since difference type is required
to be a signed integer type. However, the wording in the standard may
be less clear than we would like.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
To remove this limitation, I suggest to change the
operational semantics for this column to:
</p>
<blockquote><pre>    { Distance m = n; 
      if (m &gt;= 0) 
        while (m--) --r; 
      else 
        while (m++) ++r;
      return r; }
</pre></blockquote>






<hr>
<h3><a name="459"></a>459. Requirement for widening in stage 2 is overspecification</h3>
<p><b>Section:</b> 22.2.2.1.2 [facet.num.get.virtuals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Martin Sebor <b>Date:</b> 2004-03-16</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#facet.num.get.virtuals">active issues</a> in [facet.num.get.virtuals].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#facet.num.get.virtuals">issues</a> in [facet.num.get.virtuals].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>When parsing strings of wide-character digits, the standard
  requires the library to widen narrow-character "atoms" and compare
  the widened atoms against the characters that are being parsed.
  Simply narrowing the wide characters would be far simpler, and
  probably more efficient.  The two choices are equivalent except in
  convoluted test cases, and many implementations already ignore the
  standard and use narrow instead of widen.</p>

<p>
First, I disagree that using narrow() instead of widen() would
necessarily have unfortunate performance implications. A possible
implementation of narrow() that allows num_get to be implemented
in a much simpler and arguably comparably efficient way as calling
widen() allows, i.e. without making a virtual call to do_narrow every
time, is as follows:
</p>

<pre>  inline char ctype&lt;wchar_t&gt;::narrow (wchar_t wc, char dflt) const
  {
      const unsigned wi = unsigned (wc);

      if (wi &gt; UCHAR_MAX)
          return typeid (*this) == typeid (ctype&lt;wchar_t&gt;) ?
                 dflt : do_narrow (wc, dflt);

      if (narrow_ [wi] &lt; 0) {
         const char nc = do_narrow (wc, dflt);
         if (nc == dflt)
             return dflt;
         narrow_ [wi] = nc;
      }

      return char (narrow_ [wi]);
  }
</pre>

<p>
Second, I don't think the change proposed in the issue (i.e., to use
narrow() instead of widen() during Stage 2) would be at all
drastic. Existing implementations with the exception of libstdc++
currently already use narrow() so the impact of the change on programs
would presumably be isolated to just a single implementation. Further,
since narrow() is not required to translate alternate wide digit
representations such as those mentioned in issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#303">303</a>
to
their narrow equivalents (i.e., the portable source characters '0'
through '9'), the change does not necessarily imply that these
alternate digits would be treated as ordinary digits and accepted as
part of numbers during parsing. In fact, the requirement in 22.2.1.1.2
[locale.ctype.virtuals], p13 forbids narrow() to translate an alternate
digit character, wc, to an ordinary digit in the basic source
character set unless the expression
(ctype&lt;charT&gt;::is(ctype_base::digit, wc) == true) holds. This in
turn is prohibited by the C standard (7.25.2.1.5, 7.25.2.1.5, and
5.2.1, respectively) for charT of either char or wchar_t.
</p>

<p><i>[Sydney: To a large extent this is a nonproblem. As long as
you're only trafficking in char and wchar_t we're only dealing with a
stable character set, so you don't really need either 'widen' or
'narrow': can just use literals. Finally, it's not even clear whether
widen-vs-narrow is the right question; arguably we should be using
codecvt instead.]</i></p>




<p><b>Proposed resolution:</b></p>
<p>Change stage 2 so that implementations are permitted to use either
technique to perform the comparison:</p>
<ol>
  <li> call widen on the atoms and compare (either by using
      operator== or char_traits&lt;charT&gt;::eq) the input with
      the widened atoms, or</li>
  <li> call narrow on the input and compare the narrow input
      with the atoms</li>
  <li> do (1) or (2) only if charT is not char or wchar_t,
      respectively; i.e., avoid calling widen or narrow
      if it the source and destination types are the same</li>
</ol>





<hr>
<h3><a name="463"></a>463. auto_ptr usability issues</h3>
<p><b>Section:</b> D.9.1 [auto.ptr] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Rani Sharoni <b>Date:</b> 2003-12-07</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#auto.ptr">issues</a> in [auto.ptr].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
TC1 CWG DR #84 effectively made the template&lt;class Y&gt; operator auto_ptr&lt;Y&gt;()
member of auto_ptr (20.4.5.3/4) obsolete.
</p>

<p>
The sole purpose of this obsolete conversion member is to enable copy
initialization base from r-value derived (or any convertible types like
cv-types) case:
</p>
<pre>#include &lt;memory&gt;
using std::auto_ptr;

struct B {};
struct D : B {};

auto_ptr&lt;D&gt; source();
int sink(auto_ptr&lt;B&gt;);
int x1 = sink( source() ); // #1 EDG - no suitable copy constructor
</pre>

<p>
The excellent analysis of conversion operations that was given in the final
auto_ptr proposal
(http://anubis.dkuug.dk/jtc1/sc22/wg21/docs/papers/1997/N1128.pdf)
explicitly specifies this case analysis (case 4). DR #84 makes the analysis
wrong and actually comes to forbid the loophole that was exploited by the
auto_ptr designers.
</p>

<p>
I didn't encounter any compliant compiler (e.g. EDG, GCC, BCC and VC) that
ever allowed this case. This is probably because it requires 3 user defined
conversions and in fact current compilers conform to DR #84.
</p>

<p>
I was surprised to discover that the obsolete conversion member actually has
negative impact of the copy initialization base from l-value derived
case:</p>
<pre>auto_ptr&lt;D&gt; dp;
int x2 = sink(dp); // #2 EDG - more than one user-defined conversion applies
</pre>

<p>
I'm sure that the original intention was allowing this initialization using
the template&lt;class Y&gt; auto_ptr(auto_ptr&lt;Y&gt;&amp; a) constructor (20.4.5.1/4) but
since in this copy initialization it's merely user defined conversion (UDC)
and the obsolete conversion member is UDC with the same rank (for the early
overloading stage) there is an ambiguity between them.
</p>

<p>
Removing the obsolete member will have impact on code that explicitly
invokes it:
</p>
<pre>int y = sink(source().operator auto_ptr&lt;B&gt;());
</pre>

<p>
IMHO no one ever wrote such awkward code and the reasonable workaround for
#1 is:
</p>
<pre>int y = sink( auto_ptr&lt;B&gt;(source()) );
</pre>

<p>
I was even more surprised to find out that after removing the obsolete
conversion member the initialization was still ill-formed:
int x3 = sink(dp); // #3 EDG - no suitable copy constructor
</p>

<p>
This copy initialization semantically requires copy constructor which means
that both template conversion constructor and the auto_ptr_ref conversion
member (20.4.5.3/3) are required which is what was explicitly forbidden in
DR #84. This is a bit amusing case in which removing ambiguity results with
no candidates.
</p>

<p>
I also found exception safety issue with auto_ptr related to auto_ptr_ref:
</p>
<pre>int f(auto_ptr&lt;B&gt;, std::string);
auto_ptr&lt;B&gt; source2();

// string constructor throws while auto_ptr_ref
// "holds" the pointer
int x4 = f(source2(), "xyz"); // #4
</pre>

<p>
The theoretic execution sequence that will cause a leak:
</p>
<ol>
<li>call auto_ptr&lt;B&gt;::operator auto_ptr_ref&lt;B&gt;()</li>
<li>call string::string(char const*) and throw</li>
</ol>

<p>
According to 20.4.5.3/3 and 20.4.5/2 the auto_ptr_ref conversion member
returns auto_ptr_ref&lt;Y&gt; that holds *this and this is another defect since
the type of *this is auto_ptr&lt;X&gt; where X might be different from Y. Several
library vendors (e.g. SGI) implement auto_ptr_ref&lt;Y&gt; with Y* as member which
is much more reasonable. Other vendor implemented auto_ptr_ref as
defectively required and it results with awkward and catastrophic code:
int oops = sink(auto_ptr&lt;B&gt;(source())); // warning recursive on all control
paths
</p>

<p>
Dave Abrahams noticed that there is no specification saying that
auto_ptr_ref copy constructor can't throw.
</p>

<p>
My proposal comes to solve all the above issues and significantly simplify
auto_ptr implementation. One of the fundamental requirements from auto_ptr
is that it can be constructed in an intuitive manner (i.e. like ordinary
pointers) but with strict ownership semantics which yield that source
auto_ptr in initialization must be non-const. My idea is to add additional
constructor template with sole propose to generate ill-formed, diagnostic
required, instance for const auto_ptr arguments during instantiation of
declaration. This special constructor will not be instantiated for other
types which is achievable using 14.8.2/2 (SFINAE). Having this constructor
in hand makes the constructor template&lt;class Y&gt; auto_ptr(auto_ptr&lt;Y&gt; const&amp;)
legitimate since the actual argument can't be const yet non const r-value
are acceptable.
</p>

<p>
This implementation technique makes the "private auxiliary class"
auto_ptr_ref obsolete and I found out that modern C++ compilers (e.g. EDG,
GCC and VC) consume the new implementation as expected and allow all
intuitive initialization and assignment cases while rejecting illegal cases
that involve const auto_ptr arguments.
</p>

<p>The proposed auto_ptr interface:</p>

<pre>namespace std {
    template&lt;class X&gt; class auto_ptr {
    public:
        typedef X element_type;

        // 20.4.5.1 construct/copy/destroy:
        explicit auto_ptr(X* p=0) throw();
        auto_ptr(auto_ptr&amp;) throw();
        template&lt;class Y&gt; auto_ptr(auto_ptr&lt;Y&gt; const&amp;) throw();
        auto_ptr&amp; operator=(auto_ptr&amp;) throw();
        template&lt;class Y&gt; auto_ptr&amp; operator=(auto_ptr&lt;Y&gt;) throw();
        ~auto_ptr() throw();

        // 20.4.5.2 members:
        X&amp; operator*() const throw();
        X* operator-&gt;() const throw();
        X* get() const throw();
        X* release() throw();
        void reset(X* p=0) throw();

    private:
        template&lt;class U&gt;
        auto_ptr(U&amp; rhs, typename
unspecified_error_on_const_auto_ptr&lt;U&gt;::type = 0);
    };
}
</pre>

<p>
One compliant technique to implement the unspecified_error_on_const_auto_ptr
helper class is using additional private auto_ptr member class template like
the following:
</p>
<pre>template&lt;typename T&gt; struct unspecified_error_on_const_auto_ptr;

template&lt;typename T&gt;
struct unspecified_error_on_const_auto_ptr&lt;auto_ptr&lt;T&gt; const&gt;
{ typedef typename auto_ptr&lt;T&gt;::const_auto_ptr_is_not_allowed type; };
</pre>

<p>
There are other techniques to implement this helper class that might work
better for different compliers (i.e. better diagnostics) and therefore I
suggest defining its semantic behavior without mandating any specific
implementation. IMO, and I didn't found any compiler that thinks otherwise,
14.7.1/5 doesn't theoretically defeat the suggested technique but I suggest
verifying this with core language experts.
</p>

<p><b>Further changes in standard text:</b></p>
<p>Remove section 20.4.5.3</p>

<p>Change 20.4.5/2 to read something like:
Initializing auto_ptr&lt;X&gt; from const auto_ptr&lt;Y&gt; will result with unspecified
ill-formed declaration that will require unspecified diagnostic.</p>

<p>Change 20.4.5.1/4,5,6 to read:</p>

<pre>template&lt;class Y&gt; auto_ptr(auto_ptr&lt;Y&gt; const&amp; a) throw();</pre>
<p> 4 Requires: Y* can be implicitly converted to X*.</p>
<p> 5 Effects: Calls const_cast&lt;auto_ptr&lt;Y&gt;&amp;&gt;(a).release().</p>
<p> 6 Postconditions: *this holds the pointer returned from a.release().</p>

<p>Change 20.4.5.1/10</p>
<pre>template&lt;class Y&gt; auto_ptr&amp; operator=(auto_ptr&lt;Y&gt; a) throw();
</pre>
<p>
10 Requires: Y* can be implicitly converted to X*. The expression delete
get() is well formed.
</p>

<p>LWG TC DR #127 is obsolete.</p>

<p>
Notice that the copy constructor and copy assignment operator should remain
as before and accept non-const auto_ptr&amp; since they have effect on the form
of the implicitly declared copy constructor and copy assignment operator of
class that contains auto_ptr as member per 12.8/5,10:
</p>
<pre>struct X {
    // implicit X(X&amp;)
    // implicit X&amp; operator=(X&amp;)
    auto_ptr&lt;D&gt; aptr_;
};
</pre>

<p>
In most cases this indicates about sloppy programming but preserves the
current auto_ptr behavior.
</p>

<p>
Dave Abrahams encouraged me to suggest fallback implementation in case that
my suggestion that involves removing of auto_ptr_ref will not be accepted.
In this case removing the obsolete conversion member to auto_ptr&lt;Y&gt; and
20.4.5.3/4,5 is still required in order to eliminate ambiguity in legal
cases. The two constructors that I suggested will co exist with the current
members but will make auto_ptr_ref obsolete in initialization contexts.
auto_ptr_ref will be effective in assignment contexts as suggested in DR
#127 and I can't see any serious exception safety issues in those cases
(although it's possible to synthesize such). auto_ptr_ref&lt;X&gt; semantics will
have to be revised to say that it strictly holds pointer of type X and not
reference to an auto_ptr for the favor of cases in which auto_ptr_ref&lt;Y&gt; is
constructed from auto_ptr&lt;X&gt; in which X is different from Y (i.e. assignment
from r-value derived to base).
</p>

<p><i>[Redmond: punt for the moment. We haven't decided yet whether we
  want to fix auto_ptr for C++-0x, or remove it and replace it with
  move_ptr and unique_ptr.]</i></p>


<p><i>[
Oxford 2007: Recommend NAD.  We're just going to deprecate it.  It still works for simple use cases
and people know how to deal with it.  Going forward <tt>unique_ptr</tt> is the recommended
tool.
]</i></p>


<p><i>[
2007-11-09: Reopened at the request of David Abrahams, Alisdair Meredith and Gabriel Dos Reis.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
Change the synopsis in D.9.1 [auto.ptr]:
</p>

<blockquote><pre>namespace std { 
  <del>template &lt;class Y&gt; struct auto_ptr_ref {};</del>

  <ins>// exposition only</ins>
  <ins>template &lt;class T&gt; struct constant_object;</ins>

  <ins>// exposition only</ins>
  <ins>template &lt;class T&gt;</ins>
  <ins>struct cannot_transfer_ownership_from</ins>
    <ins>: constant_object&lt;T&gt; {};</ins>

  template &lt;class X&gt; class auto_ptr { 
  public: 
    typedef X element_type; 

    // D.9.1.1 construct/copy/destroy: 
    explicit auto_ptr(X* p =0) throw(); 
    auto_ptr(auto_ptr&amp;) throw(); 
    template&lt;class Y&gt; auto_ptr(auto_ptr&lt;Y&gt;<ins> const</ins>&amp;) throw(); 
    auto_ptr&amp; operator=(auto_ptr&amp;) throw(); 
    template&lt;class Y&gt; auto_ptr&amp; operator=(auto_ptr&lt;Y&gt;<del>&amp;</del>) throw();
    <del>auto_ptr&amp; operator=(auto_ptr_ref&lt;X&gt; r) throw();</del>
    ~auto_ptr() throw(); 

    // D.9.1.2 members: 
    X&amp; operator*() const throw();
    X* operator-&gt;() const throw();
    X* get() const throw();
    X* release() throw();
    void reset(X* p =0) throw();

    <del>// D.9.1.3 conversions:</del>
    <del>auto_ptr(auto_ptr_ref&lt;X&gt;) throw();</del>
    <del>template&lt;class Y&gt; operator auto_ptr_ref&lt;Y&gt;() throw();</del>
    <del>template&lt;class Y&gt; operator auto_ptr&lt;Y&gt;() throw();</del>

    <ins>// exposition only</ins>
    <ins>template&lt;class U&gt;</ins>
    <ins>auto_ptr(U&amp; rhs, typename cannot_transfer_ownership_from&lt;U&gt;::error = 0);</ins>
  }; 

  template &lt;&gt; class auto_ptr&lt;void&gt; 
  { 
  public: 
    typedef void element_type; 
  }; 

}
</pre></blockquote>

<p>
Remove D.9.1.3 [auto.ptr.conv].
</p>

<p>
Change D.9.1 [auto.ptr], p3:
</p>

<blockquote>
The <tt>auto_ptr</tt> provides a semantics of strict ownership. An
<tt>auto_ptr</tt> owns the object it holds a pointer to. Copying an
<tt>auto_ptr</tt> copies the pointer and transfers ownership to the
destination. If more than one <tt>auto_ptr</tt> owns the same object at
the same time the behavior of the program is undefined. <ins>Templates
<tt>constant_object</tt> and <tt>cannot_transfer_ownership_from</tt>,
and the final constructor of <tt>auto_ptr</tt> are for exposition only.
For any types <tt>X</tt> and <tt>Y</tt>, initializing
<tt>auto_ptr&lt;X&gt;</tt> from <tt>const auto_ptr&lt;Y&gt;</tt> is
ill-formed, diagnostic required.</ins> [<i>Note:</i> The uses of
<tt>auto_ptr</tt> include providing temporary exception-safety for
dynamically allocated memory, passing ownership of dynamically allocated
memory to a function, and returning dynamically allocated memory from a
function. <tt>auto_ptr</tt> does not meet the <tt>CopyConstructible</tt>
and <tt>Assignable</tt> requirements for Standard Library container
elements and thus instantiating a Standard Library container with an
<tt>auto_ptr</tt> results in undefined behavior. <i>-- end note</i>]
</blockquote>

<p>
Change D.9.1.1 [auto.ptr.cons], p5:
</p>

<blockquote>
<pre>template&lt;class Y&gt; auto_ptr(auto_ptr&lt;Y&gt;<ins> const</ins>&amp; a) throw();
</pre>
<blockquote>
<p>
<i>Requires:</i> <tt>Y*</tt> can be implicitly converted to <tt>X*</tt>.
</p>
<p>
<i>Effects:</i> Calls <ins><tt>const_cast&lt;auto_ptr&lt;Y&gt;&amp;&gt;(</tt></ins><tt>a</tt><ins><tt>)</tt></ins><tt>.release()</tt>.
</p>
<p>
<i>Postconditions:</i> <tt>*this</tt> holds the pointer returned from <tt>a.release()</tt>.
</p>
</blockquote>
</blockquote>

<p>
Change D.9.1.1 [auto.ptr.cons], p10:
</p>

<blockquote>
<pre>template&lt;class Y&gt; auto_ptr&amp; operator=(auto_ptr&lt;Y&gt;<del>&amp;</del> a) throw();
</pre>
<blockquote>
<p>
<i>Requires:</i> <tt>Y*</tt> can be implicitly converted to <tt>X*</tt>.
The expression <tt>delete get()</tt> is well formed.
</p>
<p>
<i>Effects:</i> Calls <tt>reset(a.release())</tt>.
</p>
<p>
<i>Returns:</i> <tt>*this</tt>.
</p>
</blockquote>
</blockquote>






<hr>
<h3><a name="471"></a>471. result of what() implementation-defined</h3>
<p><b>Section:</b> 18.6.1 [type.info] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Martin Sebor <b>Date:</b> 2004-06-28</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#type.info">issues</a> in [type.info].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>

<p>[lib.exception] specifies the following:</p>
<pre>    exception (const exception&amp;) throw();
    exception&amp; operator= (const exception&amp;) throw();

    -4- Effects: Copies an exception object.
    -5- Notes: The effects of calling what() after assignment
        are implementation-defined.
</pre>

<p>
First, does the Note only apply to the assignment operator? If so,
what are the effects of calling what() on a copy of an object? Is
the returned pointer supposed to point to an identical copy of
the NTBS returned by what() called on the original object or not?
</p>

<p>
Second, is this Note intended to extend to all the derived classes
in section 19? I.e., does the standard provide any guarantee for
the effects of what() called on a copy of any of the derived class
described in section 19?
</p>

<p>
Finally, if the answer to the first question is no, I believe it
constitutes a defect since throwing an exception object typically
implies invoking the copy ctor on the object. If the answer is yes,
then I believe the standard ought to be clarified to spell out
exactly what the effects are on the copy (i.e., after the copy
ctor was called).
</p>

<p><i>[Redmond: Yes, this is fuzzy.  The issue of derived classes is
  fuzzy too.]</i></p>


<p><i>[
Batavia: Howard provided wording.
]</i></p>


<p><i>[
Bellevue:
]</i></p>


<blockquote>
<p>
Eric concerned this is unimplementable, due to nothrow guarantees.
Suggested implementation would involve reference counting.
</p>
<p>
Is the implied reference counting subtle enough to call out a note on
implementation? Probably not.
</p>
<p>
If reference counting required, could we tighten specification further
to require same pointer value? Probably an overspecification, especially
if exception classes defer evalutation of final string to calls to
what().
</p>
<p>
Remember issue moved open and not resolved at Batavia, but cannot
remember who objected to canvas a disenting opinion - please speak up if
you disagree while reading these minutes!
</p>
<p>
Move to Ready as we are accepting words unmodified.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>

<p>
Change 18.7.1 [exception] to:
</p>

<blockquote>
<pre>exception(const exception&amp; <ins><i>e</i></ins>) throw();
exception&amp; operator=(const exception&amp; <ins><i>e</i></ins>) throw();</pre>
<blockquote>
<p>
-4- <i>Effects:</i> Copies an exception object.
</p>
<p>
<del> -5- <i>Remarks:</i> The effects of calling what() after assignment are implementation-defined.</del>
</p>
<p>
<ins>-5- <i>Throws:</i> Nothing.  This also applies
to all standard library-defined classes that derive from <tt>exception</tt>.</ins>
</p>
<p>
<ins>-7- <i>Postcondition:</i> <tt>strcmp(what(), <i>e</i>.what()) == 0</tt>.  This also applies
to all standard library-defined classes that derive from <tt>exception</tt>.</ins>
</p>

</blockquote>
</blockquote>




<hr>
<h3><a name="473"></a>473. underspecified ctype calls</h3>
<p><b>Section:</b> 22.2.1.1 [locale.ctype] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Martin Sebor <b>Date:</b> 2004-07-01</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Most ctype member functions come in two forms: one that operates
on a single character at a time and another form that operates
on a range of characters. Both forms are typically described by
a single Effects and/or Returns clause.
</p>
<p>
The Returns clause of each of the single-character non-virtual forms
suggests that the function calls the corresponding single character
virtual function, and that the array form calls the corresponding
virtual array form. Neither of the two forms of each virtual member
function is required to be implemented in terms of the other.
</p>
<p>
There are three problems:
</p>
<p>
1. One is that while the standard does suggest that each non-virtual
member function calls the corresponding form of the virtual function,
it doesn't actually explicitly require it.
</p>
<p>
Implementations that cache results from some of the virtual member
functions for some or all values of their arguments might want to
call the array form from the non-array form the first time to fill
the cache and avoid any or most subsequent virtual calls. Programs
that rely on each form of the virtual function being called from
the corresponding non-virtual function will see unexpected behavior
when using such implementations.
</p>
<p>
2. The second problem is that either form of each of the virtual
functions can be overridden by a user-defined function in a derived
class to return a value that is different from the one produced by
the virtual function of the alternate form that has not been
overriden.
</p>
<p>
Thus, it might be possible for, say, ctype::widen(c) to return one
value, while for ctype::widen(&amp;c, &amp;c + 1, &amp;wc) to set
wc to another value. This is almost certainly not intended. Both
forms of every function should be required to return the same result
for the same character, otherwise the same program using an
implementation that calls one form of the functions will behave
differently than when using another implementation that calls the
other form of the function "under the hood."
</p>
<p>
3. The last problem is that the standard text fails to specify whether
one form of any of the virtual functions is permitted to be implemented
in terms of the other form or not, and if so, whether it is required
or permitted to call the overridden virtual function or not.
</p>
<p>
Thus, a program that overrides one of the virtual functions so that
it calls the other form which then calls the base member might end
up in an infinite loop if the called form of the base implementation
of the function in turn calls the other form.
</p>
<p>
Lillehammer: Part of this isn't a real problem. We already talk about
caching. 22.1.1/6 But part is a real problem. ctype virtuals may call
each other, so users don't know which ones to override to avoid avoid
infinite loops.</p>

<p>This is a problem for all facet virtuals, not just ctype virtuals,
so we probably want a blanket statement in clause 22 for all
facets. The LWG is leaning toward a blanket prohibition, that a
facet's virtuals may never call each other. We might want to do that
in clause 27 too, for that matter. A review is necessary.  Bill will
provide wording.</p>


<p><b>Proposed resolution:</b></p>




<hr>
<h3><a name="484"></a>484. Convertible to T</h3>
<p><b>Section:</b> 24.1.1 [input.iterators] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Chris Jefferson <b>Date:</b> 2004-09-16</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#input.iterators">issues</a> in [input.iterators].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>From comp.std.c++:</p>

<p>
I note that given an input iterator a for type T, 
then *a only has to be "convertable to T", not actually of type T.
</p>

<p>Firstly, I can't seem to find an exact definition of "convertable to T". 
While I assume it is the obvious definition (an implicit conversion), I 
can't find an exact definition. Is there one?</p>

<p>Slightly more worryingly, there doesn't seem to be any restriction on 
the this type, other than it is "convertable to T". Consider two input 
iterators a and b. I would personally assume that most people would 
expect *a==*b would perform T(*a)==T(*b), however it doesn't seem that 
the standard requires that, and that whatever type *a is (call it U) 
could have == defined on it with totally different symantics and still 
be a valid inputer iterator.</p>

<p>Is this a correct reading? When using input iterators should I write 
T(*a) all over the place to be sure that the object i'm using is the 
class I expect?</p>

<p>This is especially a nuisance for operations that are defined to be
  "convertible to bool".  (This is probably allowed so that
  implementations could return say an int and avoid an unnessary
  conversion. However all implementations I have seen simply return a
  bool anyway.  Typical implemtations of STL algorithms just write
  things like <tt>while(a!=b &amp;&amp; *a!=0)</tt>.  But strictly
  speaking, there are lots of types that are convertible to T but
  that also overload the appropriate operators so this doesn't behave
  as expected.</p>

<p>If we want to make code like this legal (which most people seem to
  expect), then we'll need to tighten up what we mean by "convertible
  to T".</p>

<p><i>[Lillehammer: The first part is NAD, since "convertible" is
 well-defined in core. The second part is basically about pathological
 overloads. It's a minor problem but a real one. So leave open for
 now, hope we solve it as part of iterator redesign.]</i></p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="485"></a>485. output iterator insufficently constrained</h3>
<p><b>Section:</b> 24.1.2 [output.iterators] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Chris Jefferson <b>Date:</b> 2004-10-13</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#output.iterators">issues</a> in [output.iterators].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The note on 24.1.2 Output iterators insufficently limits what can be
performed on output iterators. While it requires that each iterator is
progressed through only once and that each iterator is written to only
once, it does not require the following things:</p>

<p>Note: Here it is assumed that x is an output iterator of type X which
has not yet been assigned to.</p>

<p>a) That each value of the output iterator is written to:
The standard allows:
++x; ++x; ++x;
</p>

<p>
b) That assignments to the output iterator are made in order
X a(x); ++a; *a=1; *x=2; is allowed
</p>

<p>
c) Chains of output iterators cannot be constructed:
X a(x); ++a; X b(a); ++b; X c(b); ++c; is allowed, and under the current
wording (I believe) x,a,b,c could be written to in any order.
</p>

<p>I do not believe this was the intension of the standard?</p>
<p><i>[Lillehammer: Real issue.  There are lots of constraints we
  intended but didn't specify.  Should be solved as part of iterator
  redesign.]</i></p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="492"></a>492. Invalid iterator arithmetic expressions</h3>
<p><b>Section:</b> 23 [containers], 24 [iterators], 25 [algorithms] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Thomas Mang <b>Date:</b> 2004-12-12</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#containers">active issues</a> in [containers].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#containers">issues</a> in [containers].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>Various clauses other than clause 25 make use of iterator arithmetic not
supported by the iterator category in question.
Algorithms in clause 25 are exceptional because of 25 [lib.algorithms],
paragraph 9, but this paragraph does not provide semantics to the
expression "iterator - n", where n denotes a value of a distance type
between iterators.</p>

<p>1) Examples of current wording:</p>

<p>Current wording outside clause 25:</p>

<p>
23.2.2.4 [lib.list.ops], paragraphs 19-21: "first + 1", "(i - 1)",
"(last - first)"
23.3.1.1 [lib.map.cons], paragraph 4: "last - first"
23.3.2.1 [lib.multimap.cons], paragraph 4: "last - first"
23.3.3.1 [lib.set.cons], paragraph 4: "last - first"
23.3.4.1 [lib.multiset.cons], paragraph 4: "last - first"
24.4.1 [lib.reverse.iterators], paragraph 1: "(i - 1)"
</p>

<p>
[Important note: The list is not complete, just an illustration. The
same issue might well apply to other paragraphs not listed here.]</p>

<p>None of these expressions is valid for the corresponding iterator
category.</p>

<p>Current wording in clause 25:</p>

<p>
25.1.1 [lib.alg.foreach], paragraph 1: "last - 1"
25.1.3 [lib.alg.find.end], paragraph 2: "[first1, last1 -
(last2-first2))"
25.2.8 [lib.alg.unique], paragraph 1: "(i - 1)"
25.2.8 [lib.alg.unique], paragraph 5: "(i - 1)"
</p>

<p>
However, current wording of 25 [lib.algorithms], paragraph 9 covers
neither of these four cases:</p>

<p>Current wording of 25 [lib.algorithms], paragraph 9:</p>

<p>
"In the description of the algorithms operator + and - are used for some
of the iterator categories for which they do not have to be defined. In
these cases the semantics of a+n is the same as that of</p>
<pre>{X tmp = a;
advance(tmp, n);
return tmp;
}
</pre>
<p>and that of b-a is the same as of return distance(a, b)"</p>

<p>
This paragrpah does not take the expression "iterator - n" into account,
where n denotes a value of a distance type between two iterators [Note:
According to current wording, the expression "iterator - n" would be
resolved as equivalent to "return distance(n, iterator)"]. Even if the
expression "iterator - n" were to be reinterpreted as equivalent to
"iterator + -n" [Note: This would imply that "a" and "b" were
interpreted implicitly as values of iterator types, and "n" as value of
a distance type], then 24.3.4/2 interfers because it says: "Requires: n
may be negative only for random access and bidirectional iterators.",
and none of the paragraphs quoted above requires the iterators on which
the algorithms operate to be of random access or bidirectional category.
</p>

<p>2) Description of intended behavior:</p>

<p>
For the rest of this Defect Report, it is assumed that the expression
"iterator1 + n" and "iterator1 - iterator2" has the semantics as
described in current 25 [lib.algorithms], paragraph 9, but applying to
all clauses. The expression "iterator1 - n" is equivalent to an
result-iterator for which the expression "result-iterator + n" yields an
iterator denoting the same position as iterator1 does. The terms
"iterator1", "iterator2" and "result-iterator" shall denote the value of
an iterator type, and the term "n" shall denote a value of a distance
type between two iterators.</p>

<p>
All implementations known to the author of this Defect Report comply
with these assumptions.
No impact on current code is expected.</p>

<p>3) Proposed fixes:</p>


<p>Change 25 [lib.algorithms], paragraph 9 to:</p>

<p>
"In the description of the algorithms operator + and - are used for some
of the iterator categories for which they do not have to be defined. In
this paragraph, a and b denote values of an iterator type, and n denotes
a value of a distance type between two iterators. In these cases the
semantics of a+n is the same as that of</p>
<pre>{X tmp = a;
advance(tmp, n);
return tmp;
}
</pre>
<p>,the semantics of a-n denotes the value of an iterator i for which the
following condition holds:
advance(i, n) == a,
and that of b-a is the same as of
return distance(a, b)".
</p>

<p>Comments to the new wording:</p>

<p>
a) The wording " In this paragraph, a and b denote values of an iterator
type, and n denotes a value of a distance type between two iterators."
was added so the expressions "b-a" and "a-n" are distinguished regarding
the types of the values on which they operate.
b) The wording ",the semantics of a-n denotes the value of an iterator i
for which the following condition holds: advance(i, n) == a" was added
to cover the expression 'iterator - n'. The wording "advance(i, n) == a"
was used to avoid a dependency on the semantics of a+n, as the wording
"i + n == a" would have implied. However, such a dependency might well
be deserved.
c) DR 225 is not considered in the new wording.
</p>

<p>
Proposed fixes regarding invalid iterator arithmetic expressions outside
clause 25:</p>

<p>
Either
a) Move modified 25 [lib.algorithms], paragraph 9 (as proposed above)
before any current invalid iterator arithmetic expression. In that case,
the first sentence of 25 [lib.algorithms], paragraph 9, need also to be
modified and could read: "For the rest of this International Standard,
...." / "In the description of the following clauses including this
...." / "In the description of the text below ..." etc. - anyways
substituting the wording "algorithms", which is a straight reference to
clause 25.
In that case, 25 [lib.algorithms] paragraph 9 will certainly become
obsolete.
Alternatively,
b) Add an appropiate paragraph similar to resolved 25 [lib.algorithms],
paragraph 9, to the beginning of each clause containing invalid iterator
arithmetic expressions.
Alternatively,
c) Fix each paragraph (both current wording and possible resolutions of
DRs) containing invalid iterator arithmetic expressions separately.
</p>

<p>5) References to other DRs:</p>

<p>
See DR 225.
See DR 237. The resolution could then also read "Linear in last -
first".
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
Keep open and ask Bill to provide wording.
</blockquote>


<p><b>Proposed resolution:</b></p>

<p><i>[Lillehammer: Minor issue, but real. We have a blanket statement
about this in 25/11. But (a) it should be in 17, not 25; and (b) it's
not quite broad enough, because there are some arithmetic expressions
it doesn't cover. Bill will provide wording.]</i></p>







<hr>
<h3><a name="498"></a>498. Requirements for partition() and stable_partition() too strong</h3>
<p><b>Section:</b> 25.2.13 [alg.partitions] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Sean Parent, Joe Gottman <b>Date:</b> 2005-05-04</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Problem:
The iterator requirements for partition() and stable_partition() [25.2.12]
are listed as BidirectionalIterator, however, there are efficient algorithms
for these functions that only require ForwardIterator that have been known
since before the standard existed. The SGI implementation includes these (see
<a href="http://www.sgi.com/tech/stl/partition.html">http://www.sgi.com/tech/stl/partition.html</a>
and
<a href="http://www.sgi.com/tech/stl/stable_partition.html">http://www.sgi.com/tech/stl/stable_partition.html</a>).
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change 25.2.12 from </p>
<blockquote><pre>template&lt;class BidirectionalIterator, class Predicate&gt; 
BidirectionalIterator partition(BidirectionalIterato r first, 
                                BidirectionalIterator last, 
                                Predicate pred); 
</pre></blockquote>
<p>to </p>
<blockquote><pre>template&lt;class ForwardIterator, class Predicate&gt; 
ForwardIterator partition(ForwardIterator first, 
                          ForwardIterator last, 
                          Predicate pred); 
</pre></blockquote>
<p>Change the complexity from </p>

<blockquote><p>
At most (last - first)/2 swaps are done. Exactly (last - first) 
applications of the predicate are done. 
</p></blockquote>

<p>to </p>

<blockquote><p>
If ForwardIterator is a bidirectional_iterator, at most (last - first)/2 
swaps are done; otherwise at most (last - first) swaps are done. Exactly 
(last - first) applications of the predicate are done. 
</p></blockquote>



<p><b>Rationale:</b></p>
<p>
Partition is a "foundation" algorithm useful in many contexts (like sorting
as just one example) - my motivation for extending it to include forward
iterators is slist - without this extension you can't partition an slist
(without writing your own partition). Holes like this in the standard
library weaken the argument for generic programming (ideally I'd be able
to provide a library that would refine std::partition() to other concepts
without fear of conflicting with other libraries doing the same - but
that is a digression). I consider the fact that partition isn't defined
to work for ForwardIterator a minor embarrassment.
</p>

<p><i>[Mont Tremblant: Moved to Open, request motivation and use cases
by next meeting. Sean provided further rationale by post-meeting
mailing.]</i></p>







<hr>
<h3><a name="502"></a>502. Proposition: Clarification of the interaction between a facet and an iterator</h3>
<p><b>Section:</b> 22.1.1.1.1 [locale.category] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Christopher Conrade Zseleghovski <b>Date:</b> 2005-06-07</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.category">issues</a> in [locale.category].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Motivation:
</p>

<p>
This requirement seems obvious to me, it is the essence of code modularity. 
I have complained to Mr. Plauger that the Dinkumware library does not 
observe this principle but he objected that this behaviour is not covered in 
the standard.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Append the following point to 22.1.1.1.1:
</p>

<p>
6. The implementation of a facet of Table 52 parametrized with an 
InputIterator/OutputIterator should use that iterator only as character 
source/sink respectively.
For a *_get facet, it means that the value received depends only on the 
sequence of input characters and not on how they are accessed.
For a *_put facet, it means that the sequence of characters output depends 
only on the value to be formatted and not of how the characters are stored.
</p>

<p><i>[
Berlin:  Moved to Open, Need to clean up this area to make it clear
locales don't have to contain open ended sets of facets. Jack, Howard,
Bill.
]</i></p>







<hr>
<h3><a name="503"></a>503. more on locales</h3>
<p><b>Section:</b> 22.2 [locale.categories] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> P.J. Plauger <b>Date:</b> 2005-06-20</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#locale.categories">active issues</a> in [locale.categories].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.categories">issues</a> in [locale.categories].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
a) In 22.2.1.1 para. 2 we refer to "the instantiations required in Table
51" to refer to the facet *objects* associated with a locale. And we
almost certainly mean just those associated with the default or "C"
locale. Otherwise, you can't switch to a locale that enforces a different
mapping between narrow and wide characters, or that defines additional
uppercase characters.
</p>

<p>
b) 22.2.1.5 para. 3 (codecvt) has the same issues.
</p>

<p>
c) 22.2.1.5.2 (do_unshift) is even worse. It *forbids* the generation of
a homing sequence for the basic character set, which might very well need
one.
</p>

<p>
d) 22.2.1.5.2 (do_length) likewise dictates that the default mapping
between wide and narrow characters be taken as one-for-one.
</p>

<p>
e) 22.2.2 para. 2 (num_get/put) is both muddled and vacuous, as far as
I can tell. The muddle is, as before, calling Table 51 a list of
instantiations. But the constraint it applies seems to me to cover
*all* defined uses of num_get/put, so why bother to say so?
</p>

<p>
f) 22.2.3.1.2 para. 1(do_decimal_point) says "The required instantiations
return '.' or L'.'.) Presumably this means "as appropriate for the
character type. But given the vague definition of "required" earlier,
this overrules *any* change of decimal point for non "C" locales.
Surely we don't want to do that.
</p>

<p>
g) 22.2.3.1.2 para. 2 (do_thousands_sep) says "The required instantiations
return ',' or L','.) As above, this probably means "as appropriate for the
character type. But this overrules the "C" locale, which requires *no*
character ('\0') for the thousands separator. Even if we agree that we
don't mean to block changes in decimal point or thousands separator,
we should also eliminate this clear incompatibility with C.
</p>

<p>
h) 22.2.3.1.2 para. 2 (do_grouping) says "The required instantiations
return the empty string, indicating no grouping." Same considerations
as for do_decimal_point.
</p>

<p>
i) 22.2.4.1 para. 1 (collate) refers to "instantiations required in Table
51". Same bad jargon.
</p>

<p>
j) 22.2.4.1.2 para. 1 (do_compare) refers to "instantiations required
in Table 51". Same bad jargon.
</p>

<p>
k) 22.2.5 para. 1 (time_get/put) uses the same muddled and vacuous
as num_get/put.
</p>

<p>
l) 22.2.6 para. 2 (money_get/put) uses the same muddled and vacuous
as num_get/put.
</p>

<p>
m) 22.2.6.3.2 (do_pos/neg_format) says "The instantiations required
in Table 51 ... return an object of type pattern initialized to
{symbol, sign, none, value}." This once again *overrides* the "C"
locale, as well as any other locale."
</p>

<p>
3) We constrain the use_facet calls that can be made by num_get/put,
so why don't we do the same for money_get/put? Or for any of the
other facets, for that matter?
</p>

<p>
4) As an almost aside, we spell out when a facet needs to use the ctype
facet, but several also need to use a codecvt facet and we don't say so.
</p>
<p><i>[
Berlin: Bill to provide wording.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="518"></a>518. Are insert and erase stable for unordered_multiset and unordered_multimap?</h3>
<p><b>Section:</b> 23.1.3 [unord.req], TR1 6.3.1 [tr.unord.req] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Matt Austern <b>Date:</b> 2005-07-03</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#unord.req">issues</a> in [unord.req].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Issue 371 deals with stability of multiset/multimap under insert and erase
(i.e. do they preserve the relative order in ranges of equal elements).
The same issue applies to unordered_multiset and unordered_multimap.
</p>
<p><i>[
Moved to open (from review):  There is no resolution.
]</i></p>


<p><i>[
Toronto:  We have a resolution now.  Moved to Review.  Some concern was noted
as to whether this conflicted with existing practice or not.  An additional
concern was in specifying (partial) ordering for an unordered container.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
Wording for the proposed resolution is taken from the equivalent text for associative containers.
</p>

<p>
Change 23.1.3 [unord.req], Unordered associative containers, paragraph 6 to:
</p>

<blockquote><p>
An unordered associative container supports <i>unique</i> keys if it may 
contain at most one element for each key. Otherwise, it supports <i>equivalent 
keys</i>. <tt>unordered_set</tt> and <tt>unordered_map</tt> support 
unique keys. <tt>unordered_multiset</tt> and <tt>unordered_multimap</tt> 
support equivalent keys. In containers that support equivalent keys, elements 
with equivalent keys are adjacent to each other. <ins>For
<tt>unordered_multiset</tt> 
and <tt>unordered_multimap</tt>,<tt> insert</tt> and <tt>erase</tt> 
preserve the relative ordering of equivalent elements.</ins>
</p></blockquote>

<p>
Change 23.1.3 [unord.req], Unordered associative containers, paragraph 8 to:
</p>

<blockquote>
<p>The elements of an unordered associative container are organized into <i>
buckets</i>. Keys with the same hash code appear in the same bucket. The number 
of buckets is automatically increased as elements are added to an unordered 
associative container, so that the average number of elements per bucket is kept 
below a bound. Rehashing invalidates iterators, changes ordering between 
elements, and changes which buckets elements appear in, but does not invalidate 
pointers or references to elements. <ins>For <tt>unordered_multiset</tt> 
and <tt>unordered_multimap</tt>, rehashing 
preserves the relative ordering of equivalent elements.</ins></p>
</blockquote>






<hr>
<h3><a name="522"></a>522. Tuple doesn't define swap</h3>
<p><b>Section:</b> 20.3 [tuple], TR1 6.1 [tr.tuple] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Andy Koenig <b>Date:</b> 2005-07-03</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#tuple">active issues</a> in [tuple].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#tuple">issues</a> in [tuple].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Tuple doesn't define swap().  It should.
</p>
<p><i>[
Berlin: Doug to provide wording.
]</i></p>

<p><i>[
Batavia: Howard to provide wording.
]</i></p>

<p><i>[
Toronto: Howard to provide wording (really this time).
]</i></p>


<p><i>[
Bellevue:  Alisdair provided wording.
]</i></p>




<p><b>Proposed resolution:</b></p>

<p>
Add these signatures to 20.3 [tuple]
</p>

<blockquote><pre>template &lt;class... Types&gt;
  void swap(tuple&lt;Types...&gt;&amp; x, tuple&lt;Types...&gt;&amp; y);
template &lt;class... Types&gt;
  void swap(tuple&lt;Types...&gt;&amp;&amp; x, tuple&lt;Types...&gt;&amp; y);
template &lt;class... Types&gt;
  void swap(tuple&lt;Types...&gt;&amp; x, tuple&lt;Types...&gt;&amp;&amp; y); 
</pre></blockquote>

<p>
Add this signature to 20.3.1 [tuple.tuple]
</p>

<blockquote><pre>void swap(tuple&amp;&amp;);
</pre></blockquote>

<p>
Add the following two sections to the end of the tuple clauses
</p>

<blockquote>
<p>
20.3.1.7 tuple swap [tuple.swap]
</p>

<pre>void swap(tuple&amp;&amp; rhs); 
</pre>

<blockquote>
<p>
<i>Requires:</i> Each type in <tt>Types</tt> shall be <tt>Swappable</tt>.
</p>
<p>
<i>Effects:</i> Calls <tt>swap</tt> for each element in <tt>*this</tt> and its corresponding element
in <tt>rhs</tt>.
</p>
<p>
<i>Throws:</i> Nothing, unless one of the element-wise <tt>swap</tt> calls throw an
exception. 
</p>
</blockquote>

<p>
20.3.1.8 tuple specialized algorithms [tuple.special]
</p>

<pre>template &lt;class... Types&gt;
  void swap(tuple&lt;Types...&gt;&amp; x, tuple&lt;Types...&gt;&amp; y);
template &lt;class... Types&gt;
  void swap(tuple&lt;Types...&gt;&amp;&amp; x, tuple&lt;Types...&gt;&amp; y);
template &lt;class... Types&gt;
  void swap(tuple&lt;Types...&gt;&amp; x, tuple&lt;Types...&gt;&amp;&amp; y); 
</pre>

<blockquote>
<p>
<i>Effects:</i> x.swap(y)
</p>
</blockquote>
</blockquote>






<hr>
<h3><a name="523"></a>523. regex case-insensitive character ranges are unimplementable as specified</h3>
<p><b>Section:</b> 28 [re] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Eric Niebler <b>Date:</b> 2005-07-01</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#re">issues</a> in [re].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
A problem with TR1 regex is currently being discussed on the Boost 
developers list. It involves the handling of case-insensitive matching 
of character ranges such as [Z-a]. The proper behavior (according to the 
ECMAScript standard) is unimplementable given the current specification 
of the TR1 regex_traits&lt;&gt; class template. John Maddock, the author of 
the TR1 regex proposal, agrees there is a problem. The full discussion 
can be found at http://lists.boost.org/boost/2005/06/28850.php (first 
message copied below). We don't have any recommendations as yet.
</p>
<p>
-- Begin original message --
</p>
<p>
The situation of interest is described in the ECMAScript specification
(ECMA-262), section 15.10.2.15:
</p>
<p>
"Even if the pattern ignores case, the case of the two ends of a range
is significant in determining which characters belong to the range.
Thus, for example, the pattern /[E-F]/i matches only the letters E, F,
e, and f, while the pattern /[E-f]/i matches all upper and lower-case
ASCII letters as well as the symbols [, \, ], ^, _, and `."
</p>
<p>
A more interesting case is what should happen when doing a
case-insentitive match on a range such as [Z-a]. It should match z, Z,
a, A and the symbols [, \, ], ^, _, and `. This is not what happens with
Boost.Regex (it throws an exception from the regex constructor).
</p>
<p>
The tough pill to swallow is that, given the specification in TR1, I
don't think there is any effective way to handle this situation.
According to the spec, case-insensitivity is handled with
regex_traits&lt;&gt;::translate_nocase(CharT) -- two characters are equivalent
if they compare equal after both are sent through the translate_nocase
function. But I don't see any way of using this translation function to
make character ranges case-insensitive. Consider the difficulty of
detecting whether "z" is in the range [Z-a]. Applying the transformation
to "z" has no effect (it is essentially std::tolower). And we're not
allowed to apply the transformation to the ends of the range, because as
ECMA-262 says, "the case of the two ends of a range is significant."
</p>
<p>
So AFAICT, TR1 regex is just broken, as is Boost.Regex. One possible fix
is to redefine translate_nocase to return a string_type containing all
the characters that should compare equal to the specified character. But
this function is hard to implement for Unicode, and it doesn't play nice
with the existing ctype facet. What a mess!
</p>
<p>
-- End original message --
</p>

<p><i>[
John Maddock adds:
]</i></p>


<p>
One small correction, I have since found that ICU's regex package does 
implement this correctly, using a similar mechanism to the current 
TR1.Regex.
</p>
<p>
Given an expression [c1-c2] that is compiled as case insensitive it:
</p>
<p>
Enumerates every character in the range c1 to c2 and converts it to it's 
case folded equivalent.  That case folded character is then used a key to a 
table of equivalence classes, and each member of the class is added to the 
list of possible matches supported by the character-class.  This second step 
isn't possible with our current traits class design, but isn't necessary if 
the input text is also converted to a case-folded equivalent on the fly.
</p>
<p>
ICU applies similar brute force mechanisms to character classes such as 
[[:lower:]] and [[:word:]], however these are at least cached, so the impact 
is less noticeable in this case.
</p>
<p>
Quick and dirty performance comparisons show that expressions such as 
"[X-\\x{fff0}]+" are indeed very slow to compile with ICU (about 200 times 
slower than a "normal" expression).  For an application that uses a lot of 
regexes this could have a noticeable performance impact.  ICU also has an 
advantage in that it knows the range of valid characters codes: code points 
outside that range are assumed not to require enumeration, as they can not 
be part of any equivalence class.  I presume that if we want the TR1.Regex 
to work with arbitrarily large character sets enumeration really does become 
impractical.
</p>
<p>
Finally note that Unicode has:
</p>
<p>
Three cases (upper, lower and title).
One to many, and many to one case transformations.
Character that have context sensitive case translations - for example an 
uppercase sigma has two different lowercase forms  - the form chosen depends 
on context(is it end of a word or not), a caseless match for an upper case 
sigma should match either of the lower case forms, which is why case folding 
is often approximated by tolower(toupper(c)).
</p>
<p>
Probably we need some way to enumerate character equivalence classes, 
including digraphs (either as a result or an input), and some way to tell 
whether the next character pair is a valid digraph in the current locale.
</p>
<p>
Hoping this doesn't make this even more complex that it was already,
</p>

<p><i>[
Portland:  Alisdair: Detect as invalid, throw an exception.
Pete: Possible general problem with case insensitive ranges.
]</i></p>




<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="539"></a>539. partial_sum and adjacent_difference should mention requirements</h3>
<p><b>Section:</b> 26.6.3 [partial.sum] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Review">Review</a>
 <b>Submitter:</b> Marc Schoolderman <b>Date:</b> 2006-02-06</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Review">Review</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There are some problems in the definition of partial_sum and
adjacent_difference in 26.4 [lib.numeric.ops]
</p>

<p>
Unlike <tt>accumulate</tt> and <tt>inner_product</tt>, these functions are not
parametrized on a "type T", instead, 26.4.3 [lib.partial.sum] simply
specifies the effects clause as;
</p>

<blockquote><p>
Assigns to every element referred to by iterator <tt>i</tt> in the range
<tt>[result,result + (last - first))</tt> a value correspondingly equal to
</p>
<blockquote><pre>((...(* first + *( first + 1)) + ...) + *( first + ( i - result )))
</pre></blockquote>
</blockquote>

<p>
And similarly for BinaryOperation. Using just this definition, it seems
logical to expect that:
</p>


<blockquote><pre>char i_array[4] = { 100, 100, 100, 100 };
int  o_array[4];

std::partial_sum(i_array, i_array+4, o_array);
</pre></blockquote>

<p>
Is equivalent to
</p>

<blockquote><pre>int o_array[4] = { 100, 100+100, 100+100+100, 100+100+100+100 };
</pre></blockquote>

<p>
i.e. 100, 200, 300, 400, with addition happening in the <tt>result type</tt>,
<tt>int</tt>.
</p>

<p>
Yet all implementations I have tested produce 100, -56, 44, -112,
because they are using an accumulator of the <tt>InputIterator</tt>'s
<tt>value_type</tt>, which in this case is <tt>char</tt>, not <tt>int</tt>.
</p>

<p>
The issue becomes more noticeable when the result of the expression <tt>*i +
*(i+1)</tt> or <tt>binary_op(*i, *i-1)</tt> can't be converted to the
<tt>value_type</tt>. In a contrived example:
</p>

<blockquote><pre>enum not_int { x = 1, y = 2 };
...
not_int e_array[4] = { x, x, y, y };
std::partial_sum(e_array, e_array+4, o_array);
</pre></blockquote>

<p>
Is it the intent that the operations happen in the <tt>input type</tt>, or in
the <tt>result type</tt>?
</p>

<p>
If the intent is that operations happen in the <tt>result type</tt>, something
like this should be added to the "Requires" clause of 26.4.3/4
[lib.partial.sum]:
</p>

<blockquote><p>
The type of <tt>*i + *(i+1)</tt> or <tt>binary_op(*i, *(i+1))</tt> shall meet the
requirements of <tt>CopyConstructible</tt> (20.1.3) and <tt>Assignable</tt>
(23.1) types.
</p></blockquote>

<p>
(As also required for <tt>T</tt> in 26.4.1 [lib.accumulate] and 26.4.2
[lib.inner.product].)
</p>

<p>
The "auto initializer" feature proposed in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1894.pdf">N1894</a>
is not required to
implement <tt>partial_sum</tt> this way. The 'narrowing' behaviour can still be
obtained by using the <tt>std::plus&lt;&gt;</tt> function object.
</p>

<p>
If the intent is that operations happen in the <tt>input type</tt>, then
something like this should be added instead;
</p>

<blockquote><p>
The type of *first shall meet the requirements of
<tt>CopyConstructible</tt> (20.1.3) and <tt>Assignable</tt> (23.1) types.
The result of <tt>*i + *(i+1)</tt> or <tt>binary_op(*i, *(i+1))</tt> shall be
convertible to this type.
</p></blockquote>

<p>
The 'widening' behaviour can then be obtained by writing a custom proxy
iterator, which is somewhat involved.
</p>

<p>
In both cases, the semantics should probably be clarified.
</p>

<p>
26.4.4 [lib.adjacent.difference] is similarly underspecified, although
all implementations seem to perform operations in the 'result' type:
</p>

<blockquote><pre>unsigned char i_array[4] = { 4, 3, 2, 1 };
int o_array[4];

std::adjacent_difference(i_array, i_array+4, o_array);
</pre></blockquote>

<p>
o_array is 4, -1, -1, -1 as expected, not 4, 255, 255, 255.
</p>

<p>
In any case, <tt>adjacent_difference</tt> doesn't mention the requirements on the
<tt>value_type</tt>; it can be brought in line with the rest of 26.4
[lib.numeric.ops] by adding the following to 26.4.4/2
[lib.adjacent.difference]:
</p>

<blockquote><p>
The type of <tt>*first</tt> shall meet the requirements of
<tt>CopyConstructible</tt> (20.1.3) and <tt>Assignable</tt> (23.1) types."
</p></blockquote>
<p><i>[
Berlin: Giving output iterator's value_types very controversial. Suggestion of
adding signatures to allow user to specify "accumulator".
]</i></p>


<p><i>[
Bellevue:
]</i></p>


<blockquote>
The intent of the algorithms is to perform their calculations using the type of the input iterator.
Proposed wording provided.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Add to section 26.6.3 [partial.sum] paragraph 4 the following two sentences:
</p>

<blockquote>
The type of <tt>*first</tt> shall meet the requirements of <tt>CopyConstructible</tt>?
(20.1.3?) and <tt>Assignable</tt> (23.1?) types. The result of <tt>*i + *(i+1)</tt> or
<tt>binary_op(*i, *(i+1))</tt> shall be convertible to this type.
</blockquote>

<p>
Add to section 26.6.4 [adjacent.difference] paragraph 2 the following sentence:
</p>

<blockquote>
The type of <tt>*first</tt> shall meet the requirements of <tt>CopyConstructible</tt>?
(20.1.3) and <tt>Assignable</tt> (23.1) types.
</blockquote>






<hr>
<h3><a name="546"></a>546. _Longlong and _ULonglong are integer types</h3>
<p><b>Section:</b> TR1 5.1.1 [tr.rand.req] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Matt Austern <b>Date:</b> 2006-01-10</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The TR sneaks in two new integer types, _Longlong and _Ulonglong, in [tr.c99].
The rest of the TR should use that type.  I believe this affects two places.
First, the random number requirements, 5.1.1/10-11, lists all of the types with
which template parameters named IntType and UIntType may be instantiated.
_Longlong (or "long long", assuming it is added to C++0x) should be added to the
IntType list, and UIntType (again, or "unsigned long long") should be added to
the UIntType list.  Second, 6.3.2 lists the types for which hash&lt;&gt; is
required to be instantiable. _Longlong and _Ulonglong should be added to that
list, so that people may use long long as a hash key.
</p>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="550"></a>550. What should the return type of pow(float,int) be?</h3>
<p><b>Section:</b> 26.7 [c.math] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Howard Hinnant <b>Date:</b> 2006-01-12</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#c.math">active issues</a> in [c.math].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#c.math">issues</a> in [c.math].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Assuming we adopt the
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1836.pdf">C
compatibility package from C99</a>  what should be the return type of the
following signature be:
</p>
<blockquote><pre>?  pow(float, int);
</pre></blockquote>
<p>
C++03 says that the return type should be <tt>float</tt>. 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1836.pdf">
TR1</a> and C90/99 say the return type should be <tt>double</tt>.  This can put
clients into a situation where C++03 provides answers that are not as high
quality as C90/C99/TR1.  For example:
</p>
<blockquote><pre>#include &lt;math.h&gt;

int main()
{
    float x = 2080703.375F;
    double y = pow(x, 2);
}
</pre></blockquote>
<p>
Assuming an IEEE 32 bit float and IEEE 64 bit double, C90/C99/TR1 all suggest:
</p>

<blockquote><pre>y = 4329326534736.390625
</pre></blockquote>

<p>
which is exactly right.  While C++98/C++03 demands:
</p>

<blockquote><pre>y = 4329326510080.
</pre></blockquote>

<p>
which is only approximately right.
</p>

<p>
I recommend that C++0X adopt the mixed mode arithmetic already adopted by
Fortran, C and TR1 and make the return type of <tt>pow(float,int)</tt> be
<tt>double</tt>.
</p>

<p><i>[
Kona (2007): Other functions that are affected by this issue include
<tt>ldexp</tt>, <tt>scalbln</tt>, and <tt>scalbn</tt>. We also believe that there is a typo in
26.7/10: <tt>float nexttoward(float, long double);</tt> [sic] should be <tt>float
nexttoward(float, float);</tt> Proposed Disposition: Review (the proposed
resolution appears above, rather than below, the heading "Proposed
resolution")
]</i></p>


<p><i>[
<p>
Howard, post Kona:
</p>
<blockquote>
<p>
Unfortunately I strongly disagree with a part of the resolution
from Kona.  I am moving from New to Open instead of to Review because I do not believe
we have consensus on the intent of the resolution.
</p>
<p>
This issue does not include <tt>ldexp</tt>, <tt>scalbln</tt>, and <tt>scalbn</tt> because
the second integral parameter in each of these signatures (from C99) is <b>not</b> a
<i>generic parameter</i> according to C99 7.22p2.  The corresponding C++ overloads are
intended (as far as I know) to correspond directly to C99's definition of <i>generic parameter</i>.
</p>
<p>
For similar reasons, I do not believe that the second <tt>long double</tt> parameter of
<tt>nexttoward</tt>, nor the return type of this function, is in error.  I believe the
correct signature is:
</p>
<blockquote>
<pre>float nexttoward(float, long double);
</pre>
</blockquote>
<p>
which is what both the C++0X working paper and C99 state (as far as I currently understand).
</p>
<p>
This is really <b>only</b> about <tt>pow(float, int)</tt>.  And this is because C++98 took one
route (with <tt>pow</tt> only) and C99 took another (with many math functions in <tt>&lt;tgmath.h&gt;</tt>.
The proposed resolution basically says: C++98 got it wrong and C99 got it right; let's go with C99.
</p>
</blockquote>
]</i></p>


<p><i>[
Bellevue:
]</i></p>


<blockquote>
This signature was not picked up from C99. Instead, if one types
pow(2.0f,2), the promotion rules will invoke "double pow(double,
double)", which generally gives special treatment for integral
exponents, preserving full accuracy of the result.  New proposed
wording provided.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 26.7 [c.math] p10:
</p>

<blockquote>
<p>
The added signatures are:
</p>
<blockquote><pre>...
<del>float pow(float, int);</del>
...
<del>double pow(double, int);</del>
...
<del>long double pow(long double, int);</del>
</pre></blockquote>
</blockquote>






<hr>
<h3><a name="556"></a>556. is Compare a BinaryPredicate?</h3>
<p><b>Section:</b> 25.3 [alg.sorting] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Martin Sebor <b>Date:</b> 2006-02-05</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.sorting">issues</a> in [alg.sorting].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 25, p8 we allow BinaryPredicates to return a type that's convertible
to bool but need not actually be bool. That allows predicates to return
things like proxies and requires that implementations be careful about
what kinds of expressions they use the result of the predicate in (e.g.,
the expression in if (!pred(a, b)) need not be well-formed since the
negation operator may be inaccessible or return a type that's not
convertible to bool).
</p>
<p>
Here's the text for reference:
</p>
<blockquote><p>
  ...if an algorithm takes BinaryPredicate binary_pred as its argument
 and first1 and first2 as its iterator arguments, it should work
 correctly in the construct if (binary_pred(*first1, first2)){...}.
</p></blockquote>

<p>
In 25.3, p2 we require that the Compare function object return true
of false, which would seem to preclude such proxies. The relevant text
is here:
</p>
<blockquote><p>
  Compare is used as a function object which returns true if the first
  argument is less than the second, and false otherwise...
</p></blockquote>


<p><b>Proposed resolution:</b></p>
<p>
I think we could fix this by rewording 25.3, p2 to read somthing like:
</p>
<blockquote><p>
-2- <tt>Compare</tt> is <del>used as a function object which returns
<tt>true</tt> if the first argument</del> <ins>a <tt>BinaryPredicate</tt>. The
return value of the function call operator applied to an object of type
<tt>Compare</tt>, when converted to type <tt>bool</tt>, yields <tt>true</tt>
if the first argument of the call</ins> is less than the second, and
<tt>false</tt> otherwise. <tt>Compare <i>comp</i></tt> is used throughout for
algorithms assuming an ordering relation. It is assumed that <tt><i>comp</i></tt>
will not apply any non-constant function through the dereferenced iterator.
</p></blockquote>


<p><i>[
Portland:  Jack to define "convertible to bool" such that short circuiting isn't
destroyed.
]</i></p>





<hr>
<h3><a name="564"></a>564. stringbuf seekpos underspecified</h3>
<p><b>Section:</b> 27.7.1.4 [stringbuf.virtuals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Martin Sebor <b>Date:</b> 2006-02-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#stringbuf.virtuals">issues</a> in [stringbuf.virtuals].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The   effects  of  the   <code>seekpos()</code>  member   function  of
<code>basic_stringbuf</code>  simply say  that the  function positions
the  input and/or  output  sequences  but fail  to  spell out  exactly
how. This is in contrast  to the detail in which <code>seekoff()</code>
is described.
</p>


<p><b>Proposed resolution:</b></p>
        <p>

Change 27.7.1.3, p13 to read:

        </p>
<blockquote>
<p>
-13- <i>Effects:</i> <ins>Same as <tt>seekoff(off_type(<i>sp</i>), ios_base::beg,
<i>which</i>)</tt>.</ins> <del>Alters the stream position within the controlled sequences,
if possible, to correspond to the stream position stored in <tt><i>sp</i></tt>
(as described below).</del>
</p>
<ul>
<li><del>If <tt>(<i>which</i> &amp; ios_base::in) != 0</tt>, positions the input sequence.</del></li>
<li><del>If <tt>(<i>which</i> &amp; ios_base::out) != 0</tt>, positions the output sequence.</del></li>
<li><del>If <tt><i>sp</i></tt> is an invalid stream position, or if the function
positions neither sequence, the positioning operation fails. If <tt><i>sp</i></tt>
has not been obtained by a previous successful call to one of the positioning
functions (<tt>seekoff</tt>, <tt>seekpos</tt>, <tt>tellg</tt>, <tt>tellp</tt>)
the effect is undefined.</del></li>
</ul>
</blockquote>


<p><i>[
Kona (2007): A <tt>pos_type</tt> is a position in a stream by
definition, so there is no ambiguity as to what it means. Proposed
Disposition: NAD
]</i></p>


<p><i>[
Post-Kona Martin adds:
I'm afraid I disagree
with the Kona '07 rationale for marking it NAD. The only text
that describes precisely what it means to position the input
or output sequence is in <tt>seekoff()</tt>. The <tt>seekpos()</tt> Effects
clause is inadequate in comparison and the proposed resolution
plugs the hole by specifying <tt>seekpos()</tt> in terms of <tt>seekoff()</tt>.
]</i></p>





<hr>
<h3><a name="565"></a>565. xsputn inefficient</h3>
<p><b>Section:</b> 27.5.2.4.5 [streambuf.virt.put] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Martin Sebor <b>Date:</b> 2006-02-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
        <p>

<tt>streambuf::xsputn()</tt>  is  specified  to  have  the  effect  of
"writing up to  <tt>n</tt> characters to the output  sequence as if by
repeated calls to <tt>sputc(c)</tt>."

        </p>
        <p>

Since  <tt>sputc()</tt> is required  to call  <tt>overflow()</tt> when
<tt>(pptr()    ==   epptr())</tt>    is   true,    strictly   speaking
<tt>xsputn()</tt>  should do  the same.   However, doing  so  would be
suboptimal in  some interesting cases,  such as in unbuffered  mode or
when the buffer is <tt>basic_stringbuf</tt>.

        </p>
        <p>

Assuming  calling <tt>overflow()</tt>  is  not really  intended to  be
required  and the  wording is  simply  meant to  describe the  general
effect of appending to the end  of the sequence it would be worthwhile
to  mention in  <tt>xsputn()</tt> that  the function  is  not actually
required to cause a call to <tt>overflow()</tt>.

        </p>


<p><b>Proposed resolution:</b></p>
        <p>

Add the following sentence  to the <tt>xsputn()</tt> Effects clause in
27.5.2.4.5, p1 (N1804):

        </p>
        <blockquote>    
            <p>
-1- <i>Effects:</i> Writes up to <tt><i>n</i></tt> characters to the output
sequence as if by repeated calls to <tt>sputc(<i>c</i>)</tt>. The characters 
written are obtained from successive elements of the array whose first element
is designated by <tt><i>s</i></tt>. Writing stops when either <tt><i>n</i></tt>
characters have been written or a call to <tt>sputc(<i>c</i>)</tt> would return
<tt>traits::eof()</tt>. <ins>It is  uspecified whether the function  calls
<tt>overflow()</tt> when <tt>(pptr() ==  epptr())</tt> becomes true or whether
it achieves the same effects by other means.</ins>
            </p>
        </blockquote>    
        <p>

In addition,  I suggest to  add a footnote  to this function  with the
same text as Footnote 292 to  make it extra clear that derived classes
are permitted to override <tt>xsputn()</tt> for efficiency.

        </p>


<p><i>[
Kona (2007): We want to permit a <tt>streambuf</tt> that streams output directly
to a device without making calls to <tt>sputc</tt> or <tt>overflow</tt>. We believe that
has always been the intention of the committee. We believe that the
proposed wording doesn't accomplish that. Proposed Disposition: Open
]</i></p>





<hr>
<h3><a name="568"></a>568. log2 overloads missing</h3>
<p><b>Section:</b> TR1 8.16.4 [tr.c99.cmath.over] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Paolo Carlini <b>Date:</b> 2006-03-07</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>log2</tt> is missing from the list of "additional overloads" in TR1 8.16.4 [tr.c99.cmath.over] p1.
</p>

<p>
Hinnant:  This is a TR1 issue only.  It is fixed in the current (N2135) WD.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add <tt>log2</tt> to the list of functions in TR1 8.16.4 [tr.c99.cmath.over] p1.
</p>





<hr>
<h3><a name="570"></a>570. Request adding additional explicit specializations of char_traits</h3>
<p><b>Section:</b> 21.1 [char.traits] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Jack Reeves <b>Date:</b> 2006-04-06</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#char.traits">active issues</a> in [char.traits].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#char.traits">issues</a> in [char.traits].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently, the Standard Library specifies only a declaration for template class
char_traits&lt;&gt; and requires the implementation provide two explicit
specializations: char_traits&lt;char&gt; and char_traits&lt;wchar_t&gt;. I feel the Standard
should require explicit specializations for all built-in character types, i.e.
char, wchar_t, unsigned char, and signed char.
</p>
<p>
I have put together a paper
(<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1985.htm">N1985</a>)
that describes this in more detail and
includes all the necessary wording.
</p>
<p><i>[
Portland: Jack will rewrite
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1985.htm">N1985</a>
to propose a primary template that will work with other integral types.
]</i></p>

<p><i>[
Toronto: issue has grown with addition of <tt>char16_t</tt> and <tt>char32_t</tt>.
]</i></p>


<p><i>[
post Bellevue:
]</i></p>


<blockquote>
<p>
We suggest that Jack be asked about the status of his paper, and if it
is not forthcoming, the work-item be assigned to someone else. If no one
steps forward to do the paper before the next meeting, we propose to
make this NAD without further discussion. We leave this Open for now,
but our recommendation is NAD.
</p>
<p>
Note: the issue statement should be updated, as the Toronto comment has
already been resolved. E.g., char_traits specializations for char16_t
and char32_t are now in the working paper.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="573"></a>573. C++0x file positioning should handle modern file sizes</h3>
<p><b>Section:</b> 27.4.3 [fpos] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Beman Dawes <b>Date:</b> 2006-04-12</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#fpos">issues</a> in [fpos].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There are two deficiencies related to file sizes:
</p>
<ol>
<li>It doesn't appear that the Standard Library is specified in
      a way that handles modern file sizes, which are often too
      large to be represented by an unsigned long.</li>

<li>The std::fpos class does not currently have the ability to
      set/get file positions.</li>
</ol>
<p>
The Dinkumware implementation of the Standard Library as shipped with the Microsoft compiler copes with these issues by:
</p>
<ol type="A">
<li>Defining fpos_t be long long, which is large enough to
      represent any file position likely in the foreseeable future.</li>

<li>Adding member functions to class fpos. For example,
<blockquote><pre>fpos_t seekpos() const;
</pre></blockquote>
</li>
</ol>
<p>
Because there are so many types relating to file positions and offsets (fpos_t,
fpos, pos_type, off_type, streamoff, streamsize, streampos, wstreampos, and
perhaps more), it is difficult to know if the Dinkumware extensions are
sufficient. But they seem a useful starting place for discussions, and they do
represent existing practice.
</p>

<p><i>[
Kona (2007): We need a paper. It would be nice if someone proposed
clarifications to the definitions of <tt>pos_type</tt> and <tt>off_type</tt>. Currently
these definitions are horrible. Proposed Disposition: Open
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="574"></a>574. DR 369 Contradicts Text</h3>
<p><b>Section:</b> 27.3 [iostream.objects] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Pete Becker <b>Date:</b> 2006-04-18</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#iostream.objects">issues</a> in [iostream.objects].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
lib.iostream.objects requires that the standard stream objects are never
destroyed, and it requires that they be destroyed.
</p>
<p>
DR 369 adds words to say that we really mean for ios_base::Init objects to force
construction of standard stream objects. It ends, though, with the phrase "these
stream objects shall be destroyed after the destruction of dynamically ...".
However, the rule for destruction is stated in the standard: "The objects are
not destroyed during program execution."
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change 27.3 [iostream.objects]/1:
</p>

<blockquote>
<p>
-2- The objects are constructed and the associations are established at
some time prior to or during the first time an object of class
<tt>ios_base::Init</tt> is constructed, and in any case before the body of main
begins execution.<sup>290)</sup> The objects are not destroyed during program
execution.<sup>291)</sup> If a translation unit includes <tt>&lt;iostream&amp;t;</tt> or explicitly
constructs an <tt>ios_base::Init</tt> object, these stream objects shall be
constructed before dynamic initialization of non-local objects defined
later in that translation unit<del>, and these stream objects shall be
destroyed after the destruction of dynamically initialized non-local
objects defined later in that translation unit</del>.
</p>
</blockquote>


<p><i>[
Kona (2007): From 27.3 [iostream.objects]/2, strike the words "...and these stream objects
shall be destroyed after the destruction of dynamically initialized
non-local objects defined later in that translation unit." Proposed
Disposition: Review
]</i></p>





<hr>
<h3><a name="580"></a>580. unused allocator members</h3>
<p><b>Section:</b> 20.1.2 [allocator.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Martin Sebor <b>Date:</b> 2006-06-14</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#allocator.requirements">active issues</a> in [allocator.requirements].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#allocator.requirements">issues</a> in [allocator.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#479">479</a></p>
<p><b>Discussion:</b></p>
        <p>

C++ Standard Library  templates that take an allocator  as an argument
are    required    to    call    the    <code>allocate()</code>    and
<code>deallocate()</code>  members of the  allocator object  to obtain
storage.  However, they do not appear to be required to call any other
allocator      members      such     as      <code>construct()</code>,
<code>destroy()</code>,           <code>address()</code>,          and
<code>max_size()</code>.  This makes these allocator members less than
useful in portable programs.

        </p>
        <p>

It's unclear to me whether the absence of the requirement to use these
allocator  members  is  an  unintentional  omission  or  a  deliberate
choice. However,  since the functions exist in  the standard allocator
and  since  they are  required  to  be  provided by  any  user-defined
allocator I  believe the standard  ought to be clarified  to explictly
specify  whether programs  should or  should not  be able  to  rely on
standard containers calling the functions.

        </p>
        <p>

I  propose  that all  containers  be required  to  make  use of  these
functions.

        </p>
<p><i>[
Batavia:  We support this resolution.  Martin to provide wording.
]</i></p>

<p><i>[
pre-Oxford:  Martin provided wording.
]</i></p>

    

    <p><b>Proposed resolution:</b></p>
       <p>

Specifically, I propose to change 23.1 [container.requirements],
p9 as follows:

       </p>
           <blockquote>
<p>
-9- Copy constructors  for all container types defined  in this clause
<ins>that   are  parametrized  on   <code>Allocator</code></ins>  copy
<del>an</del><ins>the</ins>  allocator argument from  their respective
first parameters.

All other  constructors for  these container types  take a<del>n</del>
<ins>const</ins>  <code>Allocator&amp;</code>  argument  (20.1.6),  an
allocator whose <code>value_type</code> is the same as the container's
<code>value_type</code>.

A copy of this  argument <del>is</del><ins>shall be</ins> used for any
memory  allocation <ins> and  deallocation</ins> performed<del>,</del>
by these  constructors and by all  member functions<del>,</del> during
the  lifetime  of each  container  object.   <ins>Allocation shall  be
performed  "as  if"  by  calling  the  <code>allocate()</code>  member
function on  a copy  of the allocator  object of the  appropriate type
<sup>New  Footnote)</sup>,   and  deallocation  "as   if"  by  calling
<code>deallocate()</code> on  a copy of  the same allocator  object of
the corresponding type.</ins>

<ins>A  copy of  this argument  shall also  be used  to  construct and
destroy objects whose lifetime  is managed by the container, including
but not  limited to those of  the container's <code>value_type</code>,
and  to  obtain  their  address.   All  objects  residing  in  storage
allocated by a  container's allocator shall be constructed  "as if" by
calling the <code>construct()</code> member  function on a copy of the
allocator object of  the appropriate type.  The same  objects shall be
destroyed "as if"  by calling <code>destroy()</code> on a  copy of the
same allocator object  of the same type.  The  address of such objects
shall be obtained "as if" by calling the <code>address()</code> member
function  on  a  copy  of  the allocator  object  of  the  appropriate
type.</ins>

<ins>Finally, a copy  of this argument shall be  used by its container
object to determine  the maximum number of objects  of the container's
<code>value_type</code> the container may  store at the same time. The
container  member function <code>max_size()</code> obtains  this number
from      the      value      returned      by     a      call      to
<code>get_allocator().max_size()</code>.</ins>

In   all  container   types  defined   in  this   clause <ins>that  are
parametrized     on    <code>Allocator</code></ins>,     the    member
<code>get_allocator()</code>     returns     a     copy     of     the
<code>Allocator</code>     object     used     to    construct     the
container.<sup>258)</sup>
</p>
<p>
New Footnote: This type  may be different from <code>Allocator</code>:
it     may    be     derived    from     <code>Allocator</code>    via
<code>Allocator::rebind&lt;U&gt;::other</code>   for  the  appropriate
type <code>U</code>.
</p>
           </blockquote>
       <p>

The proposed wording seems cumbersome but I couldn't think of a better
way   to  describe   the   requirement  that   containers  use   their
<code>Allocator</code>  to manage  only objects  (regardless  of their
type)  that  persist  over  their  lifetimes  and  not,  for  example,
temporaries  created on the  stack. That  is, containers  shouldn't be
required  to  call  <code>Allocator::construct(Allocator::allocate(1),
elem)</code>  just to  construct a  temporary copy  of an  element, or
<code>Allocator::destroy(Allocator::address(temp),     1)</code>    to
destroy temporaries.

       </p>


<p><i>[
Howard: This same paragraph will need some work to accommodate <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#431">431</a>.
]</i></p>


<p><i>[
post Oxford:  This would be rendered NAD Editorial by acceptance of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2257.html">N2257</a>.
]</i></p>





<hr>
<h3><a name="582"></a>582. specialized algorithms and volatile storage</h3>
<p><b>Section:</b> 20.6.10.1 [uninitialized.copy] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Martin Sebor <b>Date:</b> 2006-06-14</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#uninitialized.copy">issues</a> in [uninitialized.copy].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
        <p>

The specialized  algorithms [lib.specialized.algorithms] are specified
as having the general effect of invoking the following expression:

        </p>
            <pre>
new (static_cast&lt;void*&gt;(&amp;*i))
    typename iterator_traits&lt;ForwardIterator&gt;::value_type (x)

            </pre>
        <p>

This  expression is  ill-formed  when the  type  of the  subexpression
<code>&amp;*i</code> is some volatile-qualified <code>T</code>.

        </p>

<p><i>[
Batavia:  Lack of support for proposed resolution but agree there is a
defect.  Howard to look at wording.  Concern that move semantics
properly expressed if iterator returns rvalue.
]</i></p>


    

    <p><b>Proposed resolution:</b></p>
        <p>

In order  to allow these algorithms  to operate on  volatile storage I
propose to change the expression so as to make it well-formed even for
pointers  to volatile  types.  Specifically,  I propose  the following
changes to clauses 20 and 24. Change 20.6.4.1, p1 to read:

        </p>
            <pre>
<i>Effects</i>:

typedef typename iterator_traits&lt;ForwardIterator&gt;::pointer    pointer;
typedef typename iterator_traits&lt;ForwardIterator&gt;::value_type value_type;

for (; first != last; ++result, ++first)
    new (static_cast&lt;void*&gt;(const_cast&lt;pointer&gt;(&amp;*result))
        value_type (*first);

            </pre>
        <p>

change 20.6.4.2, p1 to read

        </p>
            <pre>
<i>Effects</i>:

typedef typename iterator_traits&lt;ForwardIterator&gt;::pointer    pointer;
typedef typename iterator_traits&lt;ForwardIterator&gt;::value_type value_type;

for (; first != last; ++result, ++first)
    new (static_cast&lt;void*&gt;(const_cast&lt;pointer&gt;(&amp;*first))
        value_type (*x);

            </pre>
        <p>

and change 20.6.4.3, p1 to read

        </p>
            <pre>
<i>Effects</i>:

typedef typename iterator_traits&lt;ForwardIterator&gt;::pointer    pointer;
typedef typename iterator_traits&lt;ForwardIterator&gt;::value_type value_type;

for (; n--; ++first)
    new (static_cast&lt;void*&gt;(const_cast&lt;pointer&gt;(&amp;*first))
        value_type (*x);

            </pre>
        <p>

In   addition,  since   there   is  no   partial  specialization   for
<code>iterator_traits&lt;volatile T*&gt;</code>  I propose to  add one
to parallel such specialization  for &lt;const T*&gt;. Specifically, I
propose to add the following text to the end of 24.3.1, p3:

        </p>
        <p>

and for pointers to volatile as 

        </p>
            <pre>
namespace std {
template&lt;class T&gt; struct iterator_traits&lt;volatile T*&gt; {
typedef ptrdiff_t difference_type;
typedef T value_type;
typedef volatile T* pointer;
typedef volatile T&amp; reference;
typedef random_access_iterator_tag iterator_category;
};
}

            </pre>
        <p>

Note that  the change to  <code>iterator_traits</code> isn't necessary
in order to implement the  specialized algorithms in a way that allows
them to operate on volatile  strorage. It is only necesassary in order
to specify  their effects in terms  of <code>iterator_traits</code> as
is  done here.   Implementations can  (and some  do) achieve  the same
effect by means of function template overloading.

        </p>
    



<hr>
<h3><a name="585"></a>585. facet error reporting</h3>
<p><b>Section:</b> 22.2 [locale.categories] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Martin Sebor, Paolo Carlini <b>Date:</b> 2006-06-22</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#locale.categories">active issues</a> in [locale.categories].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.categories">issues</a> in [locale.categories].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
        <p>

Section  22.2, paragraph 2  requires facet  <code>get()</code> members
that    take    an    <code>ios_base::iostate&amp;</code>    argument,
<code><i>err</i></code>,  to   ignore  the  (initial)   value  of  the
argument, but to set it to <code>ios_base::failbit</code> in case of a
parse error.

        </p>
        <p>

We  believe  there  are  a   few  minor  problems  with  this  blanket
requirement  in   conjunction  with   the  wording  specific   to  each
<code>get()</code> member function.

        </p>
        <p>

First,  besides <code>get()</code>  there are  other  member functions
with     a      slightly     different     name      (for     example,
<code>get_date()</code>). It's not completely clear that the intent of
the  paragraph  is  to  include  those  as  well,  and  at  least  one
implementation has interpreted the requirement literally.

        </p>
        <p>

Second,    the     requirement    to    "set     the    argument    to
<code>ios_base::failbit</code>  suggests that  the  functions are  not
permitted    to   set    it   to    any   other    value    (such   as
<code>ios_base::eofbit</code>,   or   even  <code>ios_base::eofbit   |
ios_base::failbit</code>).

        </p>
        <p>

However, 22.2.2.1.2, p5 (Stage  3 of <code>num_get</code> parsing) and
p6 (<code>bool</code> parsing)  specifies that the <code>do_get</code>
functions  perform <code><i>err</i> |=  ios_base::eofbit</code>, which
contradicts  the earlier  requirement to  ignore  <i>err</i>'s initial
value.

        </p>
        <p>

22.2.6.1.2,  p1  (the  Effects  clause of  the  <code>money_get</code>
facet's  <code>do_get</code>  member  functions) also  specifies  that
<code><i>err</i></code>'s initial  value be used to  compute the final
value  by  ORing  it  with  either  <code>ios_base::failbit</code>  or
with<code>ios_base::eofbit | ios_base::failbit</code>.

        </p>
    

    <p><b>Proposed resolution:</b></p>
        <p>

We believe the  intent is for all facet member  functions that take an
<code>ios_base::iostate&amp;</code> argument to:

        </p>
            <ul>
                <li>

ignore the initial value of the <code><i>err</i></code> argument,

                </li>
                <li>

reset <code><i>err</i></code>  to <code>ios_base::goodbit</code> prior
to any further processing,

                </li>
                <li>

and       set      either       <code>ios_base::eofbit</code>,      or
<code>ios_base::failbit</code>, or both in <code><i>err</i></code>, as
appropriate,  in response  to  reaching the  end-of-file  or on  parse
error, or both.

                </li>
            </ul>
        <p>

To that effect we propose to change 22.2, p2 as follows:

        </p>
        <p>

The  <i>put</i><del>()</del>  members  make  no  provision  for  error
reporting.   (Any  failures of  the  OutputIterator  argument must  be
extracted   from  the   returned  iterator.)    <ins>Unless  otherwise
specified, </ins>the <i>get</i><del>()</del>  members  <ins>that</ins>
take an  <code>ios_base::iostate&amp;</code> argument <del>whose value
they  ignore,  but  set  to  ios_base::failbit  in  case  of  a  parse
error.</del><ins>,   <code><i>err</i></code>,   start  by   evaluating
<code>err  =   ios_base::goodbit</code>,  and  may   subsequently  set
<i>err</i>     to     either     <code>ios_base::eofbit</code>,     or
<code>ios_base::failbit</code>,     or     <code>ios_base::eofbit    |
ios_base::failbit</code> in response to reaching the end-of-file or in
case of a parse error, or both, respectively.</ins>

        </p>
    
    
<p><i>[
Kona (2007): We need to change the proposed wording to clarify that the
phrase "the get members" actually denotes <tt>get()</tt>, <tt>get_date()</tt>, etc.
Proposed Disposition: Open
]</i></p>




<hr>
<h3><a name="588"></a>588. requirements on zero sized tr1::arrays and other details</h3>
<p><b>Section:</b> 23.2.1 [array] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Gennaro Prota <b>Date:</b> 2006-07-18</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#array">active issues</a> in [array].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#array">issues</a> in [array].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The wording used for section 23.2.1 [lib.array] seems to be subtly
ambiguous about zero sized arrays (N==0). Specifically:
</p>
<p>
* "An instance of array&lt;T, N&gt; stores N elements of type T, so that
[...]"
</p>
<p>
Does this imply that a zero sized array object stores 0 elements, i.e.
that it cannot store any element of type T? The next point clarifies
the rationale behind this question, basically how to implement begin()
and end():
</p>
<p>
* 23.2.1.5 [lib.array.zero], p2: "In the case that N == 0, begin() ==
end() == unique value."
</p>
<p>
What does "unique" mean in this context? Let's consider the following
possible implementations, all relying on a partial specialization:
</p>
<blockquote><pre>a)
    template&lt; typename T &gt;
    class array&lt; T, 0 &gt; {
    
        ....

        iterator begin()
        { return iterator( reinterpret_cast&lt; T * &gt;( this ) ); }
        ....

    };
</pre></blockquote>
<p>
This has been used in boost, probably intending that the return value
had to be unique to the specific array object and that array couldn't
store any T. Note that, besides relying on a reinterpret_cast, has
(more than potential) alignment problems.
</p>
<blockquote><pre>b)
    template&lt; typename T &gt;
    class array&lt; T, 0 &gt; {
    
        T t;

        iterator begin()
        { return iterator( &amp;t ); }
        ....

    };
</pre></blockquote>
<p>
This provides a value which is unique to the object and to the type of
the array, but requires storing a T. Also, it would allow the user to
mistakenly provide an initializer list with one element.
</p>
<p>
A slight variant could be returning *the* null pointer of type T
</p>
<blockquote><pre>    return static_cast&lt;T*&gt;(0);
</pre></blockquote>
<p>
In this case the value would be unique to the type array&lt;T, 0&gt; but not
to the objects (all objects of type array&lt;T, 0&gt; with the same value
for T would yield the same pointer value).
</p>
<p>
Furthermore this is inconsistent with what the standard requires from
allocation functions (see library issue 9).
</p>
<p>
c) same as above but with t being a static data member; again, the
value would be unique to the type, not to the object.
</p>
<p>
d) to avoid storing a T *directly* while disallowing the possibility
to use a one-element initializer list a non-aggregate nested class
could be defined
</p>
<blockquote><pre>    struct holder { holder() {} T t; } h;
</pre></blockquote>
<p>
and then begin be defined as
</p>
<blockquote><pre> iterator begin() { return &amp;h.t; }
</pre></blockquote>
<p>
But then, it's arguable whether the array stores a T or not.
Indirectly it does.
</p>
<p>
-----------------------------------------------------
</p>
<p>
Now, on different issues:
</p>
<p>
* what's the effect of calling assign(T&amp;) on a zero-sized array? There
seems to be only mention of front() and back(), in 23.2.1 [lib.array]
p4 (I would also suggest to move that bullet to section 23.2.1.5
[lib.array.zero], for locality of reference)
</p>
<p>
* (minor) the opening paragraph of 23.2.1 [lib.array] wording is a bit
inconsistent with that of other sequences: that's not a problem in
itself, but compare it for instance with "A vector is a kind of
sequence that supports random access iterators"; though the intent is
obvious one might argue that the wording used for arrays doesn't tell
what an array is, and relies on the reader to infer that it is what
the &lt;array&gt; header defines.
</p>
<p>
* it would be desiderable to have a static const data member of type
std::size_t, with value N, for usage as integral constant expression
</p>
<p>
* section 23.1 [lib.container.requirements] seem not to consider
fixed-size containers at all, as it says: "[containers] control
allocation and deallocation of these objects [the contained objects]
through constructors, destructors, *insert and erase* operations"
</p>
<p>
* max_size() isn't specified: the result is obvious but, technically,
it relies on table 80: "size() of the largest possible container"
which, again, doesn't seem to consider fixed size containers
</p>


<p><b>Proposed resolution:</b></p>
<p>
</p>


<p><i>[
Kona (2007): requirements on zero sized <tt>tr1::array</tt>s and other details
Issue 617: <tt>std::array</tt> is a sequence that doesn't satisfy the sequence
requirements? Alisdair will prepare a paper. Proposed Disposition: Open
]</i></p>





<hr>
<h3><a name="595"></a>595. TR1/C++0x: fabs(complex&lt;T&gt;) redundant / wrongly specified</h3>
<p><b>Section:</b> 26.3.7 [complex.value.ops] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Stefan Groe Pawig <b>Date:</b> 2006-09-24</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#complex.value.ops">active issues</a> in [complex.value.ops].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#complex.value.ops">issues</a> in [complex.value.ops].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
TR1 introduced, in the C compatibility chapter, the function
fabs(complex&lt;T&gt;):
</p>
<blockquote><pre>----- SNIP -----
8.1.1 Synopsis                                [tr.c99.cmplx.syn]

  namespace std {
  namespace tr1 {
[...]
  template&lt;class T&gt; complex&lt;T&gt; fabs(const complex&lt;T&gt;&amp; x);
  } // namespace tr1
  } // namespace std

[...]

8.1.8 Function fabs                          [tr.c99.cmplx.fabs]

1 Effects: Behaves the same as C99 function cabs, defined in
  subclause 7.3.8.1.
----- SNIP -----
</pre></blockquote>

<p>
The current C++0X draft document (n2009.pdf) adopted this
definition in chapter 26.3.1 (under the comment // 26.3.7 values)
and 26.3.7/7.
</p>
<p>
But in C99 (ISO/IEC 9899:1999 as well as the 9899:TC2 draft document
n1124), the referenced subclause reads
</p>

<blockquote><pre>----- SNIP -----
7.3.8.1 The cabs functions

  Synopsis

1 #include &lt;complex.h&gt;
  double cabs(double complex z);
  float cabsf(float complex z);
  long double cabsl(long double z);

  Description

2 The cabs functions compute the complex absolute value (also called
  norm, modulus, or magnitude) of z.

  Returns

3 The cabs functions return the complex absolute value.
----- SNIP -----
</pre></blockquote>

<p>
Note that the return type of the cabs*() functions is not a complex
type.  Thus, they are equivalent to the already well established
  template&lt;class T&gt; T abs(const complex&lt;T&gt;&amp; x);
(26.2.7/2 in ISO/IEC 14882:1998, 26.3.7/2 in the current draft
document n2009.pdf).
</p>
<p>
So either the return value of fabs() is specified wrongly, or fabs()
does not behave the same as C99's cabs*().
</p>

<b>Possible Resolutions</b>

<p>
This depends on the intention behind the introduction of fabs().
</p>
<p>
If the intention was to provide a /complex/ valued function that
calculates the magnitude of its argument, this should be
explicitly specified.  In TR1, the categorization under "C
compatibility" is definitely wrong, since C99 does not provide
such a complex valued function.
</p>
<p>
Also, it remains questionable if such a complex valued function
is really needed, since complex&lt;T&gt; supports construction and
assignment from real valued arguments.  There is no difference
in observable behaviour between
</p>
<blockquote><pre>  complex&lt;double&gt; x, y;
  y = fabs(x);
  complex&lt;double&gt; z(fabs(x));
</pre></blockquote>
<p>
and
</p>
<blockquote><pre>  complex&lt;double&gt; x, y;
  y = abs(x);
  complex&lt;double&gt; z(abs(x));
</pre></blockquote>
<p>
If on the other hand the intention was to provide the intended
functionality of C99, fabs() should be either declared deprecated
or (for C++0X) removed from the standard, since the functionality
is already provided by the corresponding overloads of abs().
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
Bill believes that abs() is a suitable overload. We should remove fabs().
</blockquote>


<p><b>Proposed resolution:</b></p>

<p>
Change the synopsis in 26.3.1 [complex.synopsis]:
</p>

<blockquote><pre><del>template&lt;class T&gt; complex&lt;T&gt; fabs(const complex&lt;T&gt;&amp;);</del>
</pre></blockquote>

<p>
Remove 26.3.7 [complex.value.ops], p7:
</p>

<blockquote>
<pre><del>template&lt;class T&gt; complex&lt;T&gt; fabs(const complex&lt;T&gt;&amp; <i>x</i>);</del>
</pre>
<blockquote>
<p>
<del>-7- <i>Effects:</i> Behaves the same as C99 function <tt>cabs</tt>, defined in subclause 7.3.8.1.</del>
</p>
</blockquote>
</blockquote>



<p><i>[
Kona (2007): Change the return type of <tt>fabs(complex)</tt> to <tt>T</tt>. 
Proposed Disposition: Ready
]</i></p>





<hr>
<h3><a name="596"></a>596. 27.8.1.3 Table 112 omits "a+" and "a+b" modes</h3>
<p><b>Section:</b> 27.8.1.4 [filebuf.members] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Thomas Plum <b>Date:</b> 2006-09-26</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#filebuf.members">active issues</a> in [filebuf.members].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#filebuf.members">issues</a> in [filebuf.members].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In testing 27.8.1.4 [filebuf.members], Table 112 (in the latest N2009 draft), we invoke  
</p>
<blockquote><pre>   ostr.open("somename", ios_base::out | ios_base::in | ios_base::app)
</pre></blockquote>
<p>
and we expect the open to fail, because out|in|app is not listed in
Table 92, and just before the table we see very specific words:
</p>
<blockquote><p>
  If mode is not some combination of flags shown in the table 
  then the open fails.
</p></blockquote>
<p>
But the corresponding table in the C standard, 7.19.5.3, provides two
modes "a+" and "a+b", to which the C++ modes out|in|app and
out|in|app|binary would presumably apply.
</p>
<p>
We would like to argue that the intent of Table 112 was to match the
semantics of 7.19.5.3 and that the omission of "a+" and "a+b" was
unintentional.  (Otherwise there would be valid and useful behaviors
available in C file I/O which are unavailable using C++, for no
valid functional reason.)
</p>
<p>
We further request that the missing modes be explicitly restored to
the WP, for inclusion in C++0x.
</p>

<p><i>[
Martin adds:
]</i></p>


<p>
...besides "a+" and "a+b" the C++ table is also missing a row
for a lone app bit which in at least two current implementation
as well as in Classic Iostreams corresponds to the C stdio "a"
mode and has been traditionally documented as implying ios::out.
Which means the table should also have a row for in|app meaning
the same thing as "a+" already proposed in the issue.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add to the table "File open modes" in 27.8.1.4 [filebuf.members]:
</p>

<blockquote>
<table border="1">
<caption> File open modes</caption>
<tbody><tr>
<th colspan="5"><tt>ios_base</tt> Flag combination</th>
<th><tt>stdio</tt> equivalent</th>
</tr>
<tr>
<th><tt>binary</tt></th><th><tt>in</tt></th><th><tt>out</tt></th><th><tt>trunc</tt></th><th><tt>app</tt></th><th><tt>&nbsp;</tt></th>
</tr>

<tr>
<td>&nbsp;</td> <td>&nbsp;</td> <td><tt>+</tt></td> <td>&nbsp;</td> <td>&nbsp;</td> <td><tt>"w"</tt></td>
</tr>
<tr>
<td>&nbsp;</td> <td>&nbsp;</td> <td><tt>+</tt></td> <td>&nbsp;</td> <td><tt>+</tt></td> <td><tt>"a"</tt></td>
</tr>
<tr>
<td>&nbsp;</td> <td>&nbsp;</td> <td>&nbsp;</td> <td>&nbsp;</td> <td><ins><tt>+</tt></ins></td> <td><ins><tt>"a"</tt></ins></td>
</tr>
<tr>
<td>&nbsp;</td> <td>&nbsp;</td> <td><tt>+</tt></td> <td><tt>+</tt></td> <td>&nbsp;</td> <td><tt>"w"</tt></td>
</tr>
<tr>
<td>&nbsp;</td> <td><tt>+</tt></td> <td>&nbsp;</td> <td>&nbsp;</td> <td>&nbsp;</td> <td><tt>"r"</tt></td>
</tr>
<tr>
<td>&nbsp;</td> <td><tt>+</tt></td> <td><tt>+</tt></td> <td>&nbsp;</td> <td>&nbsp;</td> <td><tt>"r+"</tt></td>
</tr>
<tr>
<td>&nbsp;</td> <td><tt>+</tt></td> <td><tt>+</tt></td> <td><tt>+</tt></td> <td>&nbsp;</td> <td><tt>"w+"</tt></td>
</tr>
<tr>
<td>&nbsp;</td> <td><ins><tt>+</tt></ins></td> <td><ins><tt>+</tt></ins></td> <td>&nbsp;</td> <td><ins><tt>+</tt></ins></td> <td><ins><tt>"a+"</tt></ins></td>
</tr>
<tr>
<td>&nbsp;</td> <td><ins><tt>+</tt></ins></td> <td>&nbsp;</td> <td>&nbsp;</td> <td><ins><tt>+</tt></ins></td> <td><ins><tt>"a+"</tt></ins></td>
</tr>

<tr>
<td><tt>+</tt></td> <td>&nbsp;</td> <td><tt>+</tt></td> <td>&nbsp;</td> <td>&nbsp;</td> <td><tt>"wb"</tt></td>
</tr>
<tr>
<td><tt>+</tt></td> <td>&nbsp;</td> <td><tt>+</tt></td> <td>&nbsp;</td> <td><tt>+</tt></td> <td><tt>"ab"</tt></td>
</tr>
<tr>
<td><ins><tt>+</tt></ins></td> <td>&nbsp;</td> <td>&nbsp;</td> <td>&nbsp;</td> <td><ins><tt>+</tt></ins></td> <td><ins><tt>"ab"</tt></ins></td>
</tr>
<tr>
<td><tt>+</tt></td> <td>&nbsp;</td> <td><tt>+</tt></td> <td><tt>+</tt></td> <td>&nbsp;</td> <td><tt>"wb"</tt></td>
</tr>
<tr>
<td><tt>+</tt></td> <td><tt>+</tt></td> <td>&nbsp;</td> <td>&nbsp;</td> <td>&nbsp;</td> <td><tt>"rb"</tt></td>
</tr>
<tr>
<td><tt>+</tt></td> <td><tt>+</tt></td> <td><tt>+</tt></td> <td>&nbsp;</td> <td>&nbsp;</td> <td><tt>"r+b"</tt></td>
</tr>
<tr>
<td><tt>+</tt></td> <td><tt>+</tt></td> <td><tt>+</tt></td> <td><tt>+</tt></td> <td>&nbsp;</td> <td><tt>"w+b"</tt></td>
</tr><tr>
<td><ins><tt>+</tt></ins></td> <td><ins><tt>+</tt></ins></td> <td><ins><tt>+</tt></ins></td> <td>&nbsp;</td> <td><ins><tt>+</tt></ins></td> <td><ins><tt>"a+b"</tt></ins></td>
</tr>
<tr>
<td><ins><tt>+</tt></ins></td> <td><ins><tt>+</tt></ins></td> <td>&nbsp;</td> <td>&nbsp;</td> <td><ins><tt>+</tt></ins></td> <td><ins><tt>"a+b"</tt></ins></td>
</tr>


</tbody></table>
</blockquote>



<p><i>[
Kona (2007) Added proposed wording and moved to Review.
]</i></p>





<hr>
<h3><a name="597"></a>597. Decimal: The notion of 'promotion' cannot be emulated by user-defined types.</h3>
<p><b>Section:</b> TRDecimal 3.2 [trdec.types.types] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Daveed Vandevoorde <b>Date:</b> 2006-04-05</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#trdec.types.types">active issues</a> in [trdec.types.types].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#trdec.types.types">issues</a> in [trdec.types.types].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In a private email, Daveed writes:
</p>
<blockquote>
<p>
I am not familiar with the C TR, but my guess is that the
class type approach still won't match a built-in type
approach because the notion of "promotion" cannot be
emulated by user-defined types.
</p>
<p>
Here is an example:
</p>
</blockquote>
<pre>
		 struct S {
		   S(_Decimal32 const&amp;);  // Converting constructor
		 };
		 void f(S);

		 void f(_Decimal64);

		 void g(_Decimal32 d) {
		   f(d);
		 }
</pre>

<blockquote>
<p>
If _Decimal32 is a built-in type, the call f(d) will likely
resolve to f(_Decimal64) because that requires only a
promotion, whereas f(S) requires a user-defined conversion.
</p>
<p>
If _Decimal32 is a class type, I think the call f(d) will be
ambiguous because both the conversion to _Decimal64 and the
conversion to S will be user-defined conversions with neither
better than the other.
</p>
</blockquote>
<p>
Robert comments:
</p>
<p>
In general, a library of arithmetic types cannot exactly emulate the
behavior of the intrinsic numeric types. There are several ways to tell
whether an implementation of the decimal types uses compiler
intrinisics or a library. For example:
</p>
<pre>                 _Decimal32 d1;
                 d1.operator+=(5);  // If d1 is a builtin type, this won't compile.
</pre>
<p>
In preparing the decimal TR, we have three options:
</p>
<ol>
<li>require that the decimal types be class types</li>
<li>require that the decimal types be builtin types, like float and double</li>
<li>specify a library of class types, but allow enough implementor
latitude that a conforming implementation could instead provide builtin
types</li>
</ol>
<p>
We decided as a group to pursue option #3, but that approach implies
that implementations may not agree on the semantics of certain use
cases (first example, above), or on whether certain other cases are
well-formed (second example). Another potentially important problem is
that, under the present definition of POD, the decimal classes are not
POD types, but builtins will be.
</p>
<p>Note that neither example above implies any problems with respect to
C-to-C++ compatibility, since neither example can be expressed in C.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="606"></a>606. Decimal: allow narrowing conversions</h3>
<p><b>Section:</b> TRDecimal 3.2 [trdec.types.types] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Martin Sebor <b>Date:</b> 2006-06-15</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#trdec.types.types">active issues</a> in [trdec.types.types].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#trdec.types.types">issues</a> in [trdec.types.types].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In c++std-lib-17205, Martin writes:
</p>
<blockquote><p>...was it a deliberate design choice to make narrowing
assignments ill-formed while permitting narrowing compound assignments?
For instance:
</p></blockquote>
<pre>      decimal32 d32;
      decimal64 d64;

      d32 = 64;     // error
      d32 += 64;    // okay
</pre>
<p>
In c++std-lib-17229, Robert responds:
</p>
<blockquote><p>It is a vestige of an old idea that I forgot to remove
from the paper. Narrowing assignments should be permitted. The bug is
that the converting constructors that cause narrowing should not be
explicit. Thanks for pointing this out.
</p></blockquote>

<p><b>Proposed resolution:</b></p>
<p>
1.  In "3.2.2 Class <code>decimal32</code>" synopsis, remove the <code>explicit</code> specifier from the narrowing conversions:
</p>
<pre>                // <i>3.2.2.2 conversion from floating-point type:</i>
                <del>explicit</del> decimal32(decimal64 <i>d64</i>);
                <del>explicit</del> decimal32(decimal128 <i>d128</i>);
</pre>
<p>
2.  Do the same thing in "3.2.2.2. Conversion from floating-point type."
</p>
<p>
3.  In "3.2.3 Class <code>decimal64</code>" synopsis, remove the <code>explicit</code> specifier from the narrowing conversion:
</p>
<pre>                // <i>3.2.3.2 conversion from floating-point type:</i>
                <del>explicit</del> decimal64(decimal128 <i>d128</i>);
</pre>
<p>
4.  Do the same thing in "3.2.3.2. Conversion from floating-point type."
</p>

<p><i>[
Redmond: We prefer explicit conversions for narrowing and implicit for widening.
]</i></p>






<hr>
<h3><a name="612"></a>612. numeric_limits::is_modulo insufficiently defined</h3>
<p><b>Section:</b> 18.2.1.2 [numeric.limits.members] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Chris Jefferson <b>Date:</b> 2006-11-10</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#numeric.limits.members">issues</a> in [numeric.limits.members].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
18.2.1.2 55 states that "A type is modulo if it is possible to add two
positive numbers together and have a result that wraps around to a
third number that is less".
This seems insufficient for the following reasons:
</p>

<ol>
<li>Doesn't define what that value received is.</li>
<li>Doesn't state the result is repeatable</li>
<li> Doesn't require that doing addition, subtraction and other
operations on all values is defined behaviour.</li>
</ol>

<p><i>[
Batavia: Related to
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2144.pdf">N2144</a>.
Pete: is there an ISO definition of modulo?  Underflow on signed behavior is undefined.
]</i></p>


<p><i>[
Bellevue:  accept resolution, move to ready status.
Does this mandate that is_modulo be true on platforms for which int
happens to b modulo? A: the standard already seems to require that.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
Suggest 18.2.1.2 [numeric.limits.members[numeric.limits.members], paragraph 57 is amended to:
</p>

<blockquote><p>
A type is modulo if<ins>,</ins> <del>it is possible to add two positive numbers
and have a result that wraps around to a third number that is less.</del>
<ins>given any operation involving +,- or * on values of that type whose value
would fall outside the range <tt>[min(), max()]</tt>, then the value returned
differs from the true value by an integer multiple of <tt>(max() - min() +
1)</tt>.</ins>
</p></blockquote>






<hr>
<h3><a name="614"></a>614. std::string allocator requirements still inconsistent</h3>
<p><b>Section:</b> 21.3 [basic.string] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Bo Persson <b>Date:</b> 2006-12-05</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#basic.string">active issues</a> in [basic.string].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#basic.string">issues</a> in [basic.string].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
This is based on N2134, where 21.3.1/2 states:
"... The Allocator object used shall be a copy of the Allocator object 
passed to the basic_string object's constructor or, if the constructor does 
not take an Allocator argument, a copy of a default-constructed Allocator 
object."
</p>
<p>
Section 21.3.2/1 lists two constructors:
</p>
<blockquote><pre>basic_string(const basic_string&lt;charT,traits,Allocator&gt;&amp; str );

basic_string(const basic_string&lt;charT,traits,Allocator&gt;&amp; str ,
             size_type pos , size_type n = npos,
             const Allocator&amp; a = Allocator());
</pre></blockquote>
<p>
and then says "In the first form, the Allocator value used is copied from 
str.get_allocator().", which isn't an option according to 21.3.1.
</p>
<p><i>[
Batavia:  We need blanket statement to the effect of:
]</i></p>


<ol>
<li>If an allocator is passed in, use it, or,</li>
<li>If a string is passed in, use its allocator.</li>
</ol>
<p><i>[
Review constructors and functions that return a string; make sure we follow these
rules (substr, operator+, etc.).  Howard to supply wording.
]</i></p>


<p><i>[
Bo adds:  The new container constructor which takes only a <tt>size_type</tt> is not
consistent with 23.1 [container.requirements], p9 which says in part:

<blockquote>
All other constructors for these container types take an
<tt>Allocator&amp;</tt> argument (20.1.2), an allocator whose value type
is the same as the container's value type. A copy of this argument is
used for any memory allocation performed, by these constructors and by
all member functions, during the lifetime of each container object.
</blockquote>
]</i></p>


<p><i>[
post Bellevue: We re-confirm that the issue is real. Pablo will provide wording.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="617"></a>617. std::array is a sequence that doesn't satisfy the sequence requirements?</h3>
<p><b>Section:</b> 23.2.1 [array] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Bo Persson <b>Date:</b> 2006-12-30</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#array">active issues</a> in [array].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#array">issues</a> in [array].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <tt>&lt;array&gt;</tt> header is given under 23.2 [sequences].
23.2.1 [array]/paragraph 3 says:
</p>
<blockquote><p>
"Unless otherwise specified, all array operations are as described in
23.1 [container.requirements]".
</p></blockquote>
<p>
However, array isn't mentioned at all in section 23.1 [container.requirements].
In particular, Table 82 "Sequence requirements" lists several operations (insert, erase, clear) 
that std::array does not have in 23.2.1 [array].
</p>
<p>
Also, Table 83 "Optional sequence operations" lists several operations that 
std::array does have, but array isn't mentioned.
</p>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="618"></a>618. valarray::cshift() effects on empty array</h3>
<p><b>Section:</b> 26.5.2.7 [valarray.members] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Gabriel Dos Reis <b>Date:</b> 2007-01-10</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I would respectfully request an issue be opened with the intention to
clarify the wording for <tt>size() == 0</tt> for <tt>cshift</tt>.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change 26.5.2.7 [valarray.members], paragraph 10:
</p>

<blockquote>

<pre>valarray&lt;T&gt; cshift(int <i>n</i>) const;
</pre>

<blockquote>
<p>
This function returns an object of class <tt>valarray&lt;T&gt;</tt>, of
length <tt>size()</tt>, <del>each of whose elements <tt>I</tt> is
<tt>(*this)[(I + n ) % size()]</tt>. Thus, if element zero is taken as
the leftmost element, a positive value of <i>n</i> shifts the elements
circularly left <i>n</i> places.</del> <ins>that is a circular shift of <tt>*this</tt>. If
element zero is taken as the leftmost element, a non-negative value of
<i>n</i> shifts the elements circularly left <i>n</i> places and a
negative value of <i>n</i> shifts the elements circularly right
-<i>n</i> places.</ins>
</p>
</blockquote>
</blockquote>



<p><b>Rationale:</b></p>
<p>
We do not believe that there is any real ambiguity about what happens
when <tt>size() == 0</tt>, but we do believe that spelling this out as a C++
expression causes more trouble that it solves. The expression is
certainly wrong when <tt>n &lt; 0</tt>, since the sign of % with negative arguments
is implementation defined.
</p>


<p><i>[
Kona (2007) Changed proposed wording, added rationale and set to Review.
]</i></p>





<hr>
<h3><a name="629"></a>629. complex<t> insertion and locale dependence</t></h3>
<p><b>Section:</b> 26.3.6 [complex.ops] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Gabriel Dos Reis <b>Date:</b> 2007-01-28</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#complex.ops">issues</a> in [complex.ops].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
is there an issue opened for (0,3) as complex number with
the French local?  With the English local, the above parses as an
imaginery complex number.  With the French locale it parses as a
real complex number.
</p>

<p>
Further notes/ideas from the lib-reflector, messages 17982-17984:
</p>

<blockquote>
<p>
Add additional entries in num_punct to cover the complex separator (French would be ';').
</p>
<p>
Insert a space before the comma, which should eliminate the ambiguity.
</p>
<p>
Solve the problem for ordered sequences in general, perhaps with a
dedicated facet.  Then complex should use that solution.
</p>
</blockquote>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
<p>
After much discussion, we agreed on the following: Add a footnote:
</p>
<p>
[In a locale in which comma is being used as a decimal point character,
inserting "showbase" into the output stream forces all outputs to show
an explicit decimal point character; then all inserted complex sequences
will extract unambiguously.]
</p>
<p>
And move this to READY status.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Add a footnote to 26.3.6 [complex.ops] p16:
</p>

<blockquote>
[In a locale in which comma is being used as a decimal point character,
inserting "showbase" into the output stream forces all outputs to show
an explicit decimal point character; then all inserted complex sequences
will extract unambiguously.]
</blockquote>





<hr>
<h3><a name="630"></a>630. arrays of valarray</h3>
<p><b>Section:</b> 26.5.2.1 [valarray.cons] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Martin Sebor <b>Date:</b> 2007-01-28</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#valarray.cons">issues</a> in [valarray.cons].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
        <p>

Section 26.1 [numeric.requirements], p1     suggests     that     a
<code>valarray</code>  specialization on  a  type <code>T</code>  that
satisfies  the requirements enumerated  in the  paragraph is  itself a
valid  type   on  which  <code>valarray</code>   may  be  instantiated
(Footnote       269        makes       this       clear).        I.e.,
<code>valarray&lt;valarray&lt;T&gt;  &gt;</code> is  valid as  long as
<code>T</code>   is   valid.    However,  since   implementations   of
<code>valarray</code> are permitted to initialize storage allocated by
the class by  invoking the default ctor of  <code>T</code> followed by
the    copy    assignment    operator,   such    implementations    of
<code>valarray</code>   wouldn't  work  with   (perhaps  user-defined)
specializations of <code>valarray</code> whose assignment operator had
undefined behavior when the size of its argument didn't match the size
of <code>*this</code>.  By <i>"wouldn't work"</i> I mean that it would
be  impossible  to resize  such  an array  of  arrays  by calling  the
<code>resize()</code> member  function on it if the  function used the
copy  assignment operator  after constructing  all elements  using the
default  ctor (e.g.,  by invoking  <code>new  value_type[N]</code>) to
obtain default-initialized storage) as it's permitted to do.

        </p>
        <p>

Stated      more     generally,      the      problem     is      that
<code>valarray&lt;valarray&lt;T&gt;  &gt;::resize(size_t)</code> isn't
required or  guaranteed to have well-defined semantics  for every type
<code>T</code>     that      satisfies     all     requirements     in
26.1 [numeric.requirements].

        </p>
        <p>

I  believe  this  problem  was  introduced  by  the  adoption  of  the
resolution                outlined                in                <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/1996/N0857.asc">N0857</a>,
<i>Assignment  of  valarrays</i>,  from  1996.   The  copy  assignment
operator  of  the original  numerical  array  classes  proposed in  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/1993/N0280.pdf">N0280</a>,
as      well       as      the      one       proposed      in      <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/1993/N0308.asc">N0308</a>
(both  from 1993), had  well-defined semantics  for arrays  of unequal
size (the  latter explicitly  only when <code>*this</code>  was empty;
assignment of non empty arrays of unequal size was a runtime error).

        </p>
        <p>

The  justification for  the  change given  in  N0857 was the "loss  of
performance [deemed]  only significant  for very simple  operations on
small arrays or for architectures with very few registers."

        </p>
        <p>

Since tiny  arrays on a  limited subset of hardware  architectures are
likely  to  be  an   exceedingly  rare  case  (despite  the  continued
popularity of  x86) I  propose to revert  the resolution and  make the
behavior    of   all   <code>valarray</code>    assignment   operators
well-defined even  for non-conformal  arrays (i.e., arrays  of unequal
size).   I have implemented  this change  and measured  no significant
degradation  in performance in  the common  case (non-empty  arrays of
equal size).  I  have measured a 50% (and in  some cases even greater)
speedup  in the  case of  assignments to  empty arrays  versus calling
<code>resize()</code>  first followed  by  an invocation  of the  copy
assignment operator.

        </p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
If no proposed wording by June meeting, this issue should be closed NAD.
</blockquote>



<p><b>Proposed resolution:</b></p>
        <p>

Change 26.5.2.2 [valarray.assign], p1 as follows:

        </p>
        <blockquote>
            <p>
                <code>

valarray&lt;T&gt;&amp; operator=(const valarray&lt;T&gt;&amp;<ins> x</ins>);

                </code>
            </p>
            <p>

-1- Each element of the <code>*this</code> array is assigned the value
of  the  corresponding  element   of  the  argument  array.   <del>The
resulting behavior is undefined if </del><ins>When </ins>the length of
the  argument  array  is  not   equal  to  the  length  of  the  *this
array<del>.</del><ins>  resizes  <code>*this</code>  to make  the  two
arrays     the      same     length,     as      if     by     calling
<code>resize(x.size())</code>, before performing the assignment.</ins>

            </p>
        </blockquote>
        <p>

And  add a new  paragraph just  below paragraph  1 with  the following
text:

        </p>
        <blockquote>
            <p>

<ins>-2- <i>Postcondition</i>: <code>size() == x.size()</code>.</ins>

            </p>
        </blockquote>
        <p>

Also add the following paragraph to 26.5.2.2 [valarray.assign], immediately after p4:

        </p>
        <blockquote>
            <p>

<ins>-?- When the length,  <i><code>N</code></i> of the array referred
to by the  argument is not equal to  the length of <code>*this</code>,
the  operator resizes <code>*this</code>  to make  the two  arrays the
same  length, as if  by calling  <code>resize(<i>N</i>)</code>, before
performing the assignment.</ins>

            </p>
        </blockquote>


<p><i>[
Kona (2007): Gaby to propose wording for an alternative resolution in
which you can assign to a <tt>valarray</tt> of size 0, but not to any other
<tt>valarray</tt> whose size is unequal to the right hand side of the assignment.
]</i></p>





<hr>
<h3><a name="631"></a>631. conflicting requirements for <tt>BinaryPredicate</tt></h3>
<p><b>Section:</b> 25 [algorithms] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> James Kanze <b>Date:</b> 2007-01-31</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#algorithms">issues</a> in [algorithms].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The general requirements for <tt><tt>BinaryPredicate</tt></tt> (in 25 [algorithms]/8) contradict the implied specific requirements for
some functions. In particular, it says that:
</p>

<blockquote><p>
[...] if an algorithm takes <tt>BinaryPredicate <i>binary_pred</i></tt>
as its argument and <tt><i>first1</i></tt> and <i>first2</i> as its
iterator arguments, it should work correctly in the construct <tt>if
(binary_pred (*<i>first1</i> , *<i>first2</i> )){...}</tt>.
<tt>BinaryPredicate</tt> always takes the first iterator type as its
first argument, that is, in those cases when <tt>T <i>value</i></tt> is
part of the signature, it should work correctly in the context of <tt>if
(binary_pred (*<i>first1</i> , <i>value</i>)){...}</tt>.
</p></blockquote>

<p>
In the description of <tt>upper_bound</tt> (25.3.3.2 [upper.bound]/2), however, the use is described as
"<tt>!comp(<i>value</i>, <i>e</i>)</tt>", where <tt><i>e</i></tt> is an
element of the sequence (a result of dereferencing
<tt>*<i>first</i></tt>).
</p>

<p>
In the description of <tt>lexicographical_compare</tt>, we have both
"<tt>*<i>first1</i> &lt; *<i>first2</i></tt>" and "<tt>*<i>first2</i>
&lt; *<i>first1</i></tt>" (which presumably implies "<tt>comp(
*<i>first1</i>, *<i>first2</i> )</tt>" and "<tt>comp( *<i>first2</i>,
*<i>first1</i> )</tt>".
</p>

<p><i>[
Toronto:  Moved to Open.  ConceptGCC seems to get <tt>lower_bound</tt>
and <tt>upper_bound</tt> to work withoutt these changes.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
Logically, the <tt>BinaryPredicate</tt> is used as an ordering
relationship, with the semantics of "less than".  Depending on the
function, it may be used to determine equality, or any of the inequality
relationships; doing this requires being able to use it with either
parameter first.  I would thus suggest that the requirement be:
</p>

<blockquote><p>
[...] <tt>BinaryPredicate</tt> always takes the first iterator
<tt>value_type</tt> as one of its arguments, it is unspecified which. If
an algorithm takes <tt>BinaryPredicate <i>binary_pred</i></tt> as its
argument and <tt><i><i>first1</i></i></tt> and <i>first2</i> as its
iterator arguments, it should work correctly both in the construct
<tt>if (binary_pred (*<i>first1</i> , *<i>first2</i> )){...}</tt> and
<tt>if (binary_pred (*<i>first2</i>, *<i>first1</i>)){...}</tt>.  In
those cases when <tt>T <i>value</i></tt> is part of the signature, it
should work correctly in the context of <tt>if (binary_pred
(*<i>first1</i> , <i>value</i>)){...}</tt> and of <tt>if (binary_pred
(<i>value</i>, *<i>first1</i>)){...}</tt>. [<i>Note:</i> if the two
types are not identical, and neither is convertable to the other, this
may require that the <tt>BinaryPredicate</tt> be a functional object
with two overloaded <tt>operator()()</tt> functions. <i>--end note</i>]
</p></blockquote>

<p>
Alternatively, one could specify an order for each function. IMHO, this
would be more work for the committee, more work for the implementors,
and of no real advantage for the user: some functions, such as
<tt>lexicographical_compare</tt> or <tt>equal_range</tt>, will still require both
functions, and it seems like a much easier rule to teach that both
functions are always required, rather than to have a complicated list of
when you only need one, and which one.
</p>





<hr>
<h3><a name="632"></a>632. Time complexity of size() for std::set</h3>
<p><b>Section:</b> 23.1 [container.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Lionel B <b>Date:</b> 2007-02-01</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#container.requirements">active issues</a> in [container.requirements].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#container.requirements">issues</a> in [container.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
A recent news group discussion:
</p>
<blockquote>
<p>
Anyone know if the Standard has anything to say about the time complexity
of size() for std::set?   I need to access a set's size (/not/ to know if it is empty!) heavily
during an algorithm and was thus wondering whether I'd be better off
tracking the size "manually" or whether that'd be pointless.
</p>
<p>
That would be pointless. size() is O(1).
</p>
<p>
Nit: the standard says "should" have constant time. Implementations may take
license to do worse. I know that some do this for <tt>std::list&lt;&gt;</tt> as a part of
some trade-off with other operation.
</p>

<p>
I was aware of that, hence my reluctance to use size() for std::set.
</p>
<p>
However, this reason would not apply to <tt>std::set&lt;&gt;</tt> as far as I can see.
</p>
<p>
Ok, I guess the only option is to try it and see...
</p>
</blockquote>

<p>
If I have any recommendation to the C++ Standards Committee it is that
implementations must (not "should"!) document clearly[1], where known, the
time complexity of *all* container access operations.
</p>
<p>
[1] In my case (gcc 4.1.1) I can't swear that the time complexity of size()
for std::set is not documented... but if it is it's certainly well hidden
away.
</p>



<p><b>Proposed resolution:</b></p>
<p>
</p>


<p><i>[
Kona (2007): This issue affects all the containers. We'd love to see a
paper dealing with the broad issue. We think that the complexity of the
<tt>size()</tt> member of every container -- except possibly <tt>list</tt> -- should be
O(1). Alan has volunteered to provide wording.
]</i></p>


<p><i>[
Bellevue:
]</i></p>


<blockquote>
Mandating O(1) size will not fly, too many implementations would be
invalidated. Alan to provide wording that toughens wording, but that
does not absolutely mandate O(1).
</blockquote>




<hr>
<h3><a name="635"></a>635. domain of <tt>allocator::address</tt></h3>
<p><b>Section:</b> 20.1.2 [allocator.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Howard Hinnant <b>Date:</b> 2007-02-08</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#allocator.requirements">active issues</a> in [allocator.requirements].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#allocator.requirements">issues</a> in [allocator.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The table of allocator requirements in 20.1.2 [allocator.requirements] describes
<tt>allocator::address</tt> as:
</p>
<blockquote><pre>a.address(r)
a.address(s)
</pre></blockquote>
<p>
where <tt>r</tt> and <tt>s</tt> are described as:
</p>
<blockquote><p>
a value of type <tt>X::reference</tt> obtained by the expression <tt>*p</tt>. 
</p></blockquote>

<p>
and <tt>p</tt> is 
</p>

<blockquote><p>
a value of type <tt>X::pointer</tt>, obtained by calling <tt>a1.allocate</tt>, 
where <tt>a1 == a</tt>
</p></blockquote>

<p>
This all implies that to get the address of some value of type <tt>T</tt> that
value must have been allocated by this allocator or a copy of it.
</p>

<p>
However sometimes container code needs to compare the address of an external value of
type <tt>T</tt> with an internal value.  For example <tt>list::remove(const T&amp; t)</tt>
may want to compare the address of the external value <tt>t</tt> with that of a value
stored within the list.  Similarly <tt>vector</tt> or <tt>deque insert</tt> may
want to make similar comparisons (to check for self-referencing calls).
</p>

<p>
Mandating that <tt>allocator::address</tt> can only be called for values which the
allocator allocated seems overly restrictive.
</p>



<p><b>Proposed resolution:</b></p>
<p>
Change 20.1.2 [allocator.requirements]:
</p>

<blockquote>
<p>
<tt>r</tt> : a value of type <tt>X::reference</tt> <del>obtained by the expression *p</del>.
</p>
<p>
<tt>s</tt> : a value of type <tt>X::const_reference</tt> <del>obtained by the 
expression <tt>*q</tt> or by conversion from a value <tt>r</tt></del>.
</p>
</blockquote>

<p><i>[
post Oxford:  This would be rendered NAD Editorial by acceptance of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2257.html">N2257</a>.
]</i></p>


<p><i>[
Kona (2007):  This issue is section 8 of N2387.  There was some discussion of it but
no resolution to this issue was recorded.  Moved to Open.
]</i></p>







<hr>
<h3><a name="638"></a>638. deque end invalidation during erase</h3>
<p><b>Section:</b> 23.2.2.3 [deque.modifiers] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Steve LoBasso <b>Date:</b> 2007-02-17</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The standard states at 23.2.2.3 [deque.modifiers]/4:
</p>
<blockquote><pre>deque erase(...)
</pre>
 <p>
<i>Effects:</i> ... An erase at either end of the deque invalidates only
the iterators and the references to the erased elements.
</p>
</blockquote>
<p>
This does not state that iterators to end will be invalidated.
It needs to be amended in such a way as to account for end invalidation.
</p>
<p>
Something like:
</p>
<blockquote><p>
Any time the last element is erased, iterators to end are invalidated.
</p></blockquote>

<p>
This would handle situations like:
</p>
<blockquote><pre>erase(begin(), end())
erase(end() - 1)
pop_back()
resize(n, ...) where n &lt; size()
pop_front() with size() == 1

</pre></blockquote>

<p><i>[
Post Kona, Steve LoBasso notes:
]</i></p>


<blockquote>
My only issue with the proposed resolution is that it might not be clear
that <tt>pop_front()</tt> [where <tt>size() == 1</tt>] can invalidate past-the-end
iterators.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 23.2.2.3 [deque.modifiers], p4:
</p>

<blockquote>
<pre>iterator erase(const_iterator position); 
iterator erase(const_iterator first, const_iterator last);
</pre>

<blockquote>
<p>
-4- <i>Effects:</i> An erase in the middle of the <tt>deque</tt>
invalidates all the iterators and references to elements of the
<tt>deque</tt> <ins>and the past-the-end iterator</ins>. An erase at
either end of the <tt>deque</tt> invalidates only the iterators and the
references to the erased elements<ins>, except that erasing at the end
also invalidates the past-the-end iterator</ins>.
</p>
</blockquote>
</blockquote>



<p><i>[
Kona (2007): Proposed wording added and moved to Review.
]</i></p>


<p><i>[
Bellevue:
]</i></p>


<blockquote>
Note that there is existing code that relies on iterators not being
invalidated, but there are also existing implementations that do
invalidate iterators. Thus, such code is not portable in any case. There
is a pop_front() note, which should possibly be a separate issue. Mike
Spertus to evaluate and, if need be, file an issue.
</blockquote>




<hr>
<h3><a name="659"></a>659. istreambuf_iterator should have an operator-&gt;()</h3>
<p><b>Section:</b> 24.5.3 [istreambuf.iterator] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Niels Dekker <b>Date:</b> 2007-03-25</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#istreambuf.iterator">issues</a> in [istreambuf.iterator].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Greg Herlihy has clearly demonstrated that a user defined input
iterator should have an operator-&gt;(), even if its
value type is a built-in type (comp.std.c++, "Re: Should any iterator
have an operator-&gt;() in C++0x?", March 2007).  And as Howard
Hinnant remarked in the same thread that the input iterator
<tt>istreambuf_iterator</tt> doesn't have one, this must be a
defect!
</p>
<p>
Based on Greg's example, the following code demonstrates the issue:
</p><pre> #include &lt;iostream&gt; 
 #include &lt;fstream&gt;
 #include &lt;streambuf&gt; 

 typedef char C;
 int main ()
 {
   std::ifstream s("filename", std::ios::in);
   std::istreambuf_iterator&lt;char&gt; i(s);

   (*i).~C();  // This is well-formed...
   i-&gt;~C();  // ... so this should be supported!
 }
</pre>

<p>
Of course, operator-&gt; is also needed when the value_type of
istreambuf_iterator is a class.
</p>
<p>
The operator-&gt; could be implemented in various ways.  For instance,
by storing the current value inside the iterator, and returning its
address.  Or by returning a proxy, like operator_arrow_proxy, from
<a href="http://www.boost.org/boost/iterator/iterator_facade.hpp">http://www.boost.org/boost/iterator/iterator_facade.hpp</a>
</p>
<p>
I hope that the resolution of this issue will contribute to getting a
clear and consistent definition of iterator concepts.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add to the synopsis in 24.5.3 [istreambuf.iterator]:
</p>

<blockquote><pre>charT operator*() const;
<ins>pointer operator-&gt;() const;</ins>
istreambuf_iterator&lt;charT,traits&gt;&amp; operator++();
</pre></blockquote>

<p>
Change 24.5.3 [istreambuf.iterator], p1:
</p>

<blockquote><p>
The class template <tt>istreambuf_iterator</tt> reads successive
characters from the <tt>streambuf</tt> for which it was constructed.
<tt>operator*</tt> provides access to the current input character, if
any. <ins><tt>operator-&gt;</tt> may return a proxy.</ins> Each time
<tt>operator++</tt> is evaluated, the iterator advances to the next
input character. If the end of stream is reached
(<tt>streambuf_type::sgetc()</tt> returns <tt>traits::eof()</tt>), the
iterator becomes equal to the end of stream iterator value. The default
constructor <tt>istreambuf_iterator()</tt> and the constructor
<tt>istreambuf_iterator(0)</tt> both construct an end of stream iterator
object suitable for use as an end-of-range.
</p></blockquote>



<p><i>[
Kona (2007): The proposed resolution is inconsistent because the return
type of <tt>istreambuf_iterator::operator-&gt;()</tt> is specified to be <tt>pointer</tt>,
but the proposed text also states that "<tt>operator-&gt;</tt> may return a proxy."
]</i></p>


<p><i>[
Niels Dekker (mailed to Howard Hinnant):
]</i></p>

<blockquote>
<p>
The proposed resolution does
not seem inconsistent to me. <tt>istreambuf_iterator::operator-&gt;()</tt> should
have <tt>istreambuf_iterator::pointer</tt> as return type, and this return type
may in fact be a proxy.
</p>
<p>
AFAIK, the resolution of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#445">445</a> ("<tt>iterator_traits::reference</tt>
unspecified for some iterator categories") implies that for any iterator
class <tt>Iter</tt>, the return type of <tt>operator-&gt;()</tt> is <tt>Iter::pointer</tt>, by
definition.  I don't think <tt>Iter::pointer</tt> needs to be a raw pointer.
</p>
<p>
Still I wouldn't mind if the text "<tt>operator-&gt;</tt> may return a proxy" would
be removed from the resolution. I think it's up to the library
implementation, how to implement <tt>istreambuf_iterator::operator-&gt;()</tt>.  As
longs as it behaves as expected: <tt>i-&gt;m</tt> should have the same effect as
<tt>(*i).m</tt>. Even for an explicit destructor call, <tt>i-&gt;~C()</tt>.  The main issue
is just: <tt>istreambuf_iterator</tt> should have an <tt>operator-&gt;()</tt>!
</p>
</blockquote>




<hr>
<h3><a name="667"></a>667. <tt>money_get</tt>'s widened minus sign</h3>
<p><b>Section:</b> 22.2.6.1.2 [locale.money.get.virtuals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Thomas Plum <b>Date:</b> 2007-04-16</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#locale.money.get.virtuals">active issues</a> in [locale.money.get.virtuals].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.money.get.virtuals">issues</a> in [locale.money.get.virtuals].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
22.2.6.1.2 [locale.money.get.virtuals], para 1 says:
</p>

<blockquote><p>
The result is returned as an integral value 
stored in <tt>units</tt> or as a sequence of digits possibly preceded by a 
minus sign (as produced by <tt>ct.widen(c)</tt> where <tt>c</tt> is '-' or in the range 
from '0' through '9', inclusive) stored in <tt>digits</tt>.
</p></blockquote>

<p>
The following
objection has been raised:
</p>

<blockquote><p>
Some implementations interpret this to mean that a facet derived from
<tt>ctype&lt;wchar_t&gt;</tt> can provide its own member <tt>do_widen(char)</tt>
which produces e.g. <tt>L'@'</tt> for the "widened" minus sign, and that the
<tt>'@'</tt> symbol will appear in the resulting sequence of digits.  Other
implementations have assumed that one or more places in the standard permit the
implementation to "hard-wire" <tt>L'-'</tt> as the "widened" minus sign.  Are
both interpretations permissible, or only  one?
</p></blockquote>

<p>
[Plum ref _222612Y14]
</p>

<p>
Furthermore: if <tt>ct.widen('9')</tt> produces <tt>L'X'</tt> (a non-digit), does a
parse fail if a <tt>'9'</tt> appears in the subject string? [Plum ref _22263Y33]
</p>

<p><i>[
Kona (2007): Bill and Dietmar to provide proposed wording.
]</i></p>


<p><i>[
post Bellevue: Bill adds:
]</i></p>


<blockquote>
The Standard is clear that the minus sign stored in <tt>digits</tt> is <tt>ct.widen('-')</tt>.
The subject string must contain characters <tt>c</tt> in the set <tt>[-0123456789]</tt>
which are translated by <tt>ct.widen(c)</tt> calls before being stored in <tt>digits</tt>;
the widened characters are not relevant to the parsing of the subject string.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="668"></a>668. <tt>money_get</tt>'s empty minus sign</h3>
<p><b>Section:</b> 22.2.6.1.2 [locale.money.get.virtuals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Thomas Plum <b>Date:</b> 2007-04-16</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#locale.money.get.virtuals">active issues</a> in [locale.money.get.virtuals].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.money.get.virtuals">issues</a> in [locale.money.get.virtuals].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
22.2.6.1.2 [locale.money.get.virtuals], para 3 says:
</p>

<blockquote><p>
If <tt>pos</tt> or <tt>neg</tt> is empty, the sign component is
optional, and if no sign is detected, the result is given the sign 
that corresponds to the source of the empty string.
</p></blockquote>

<p>
The following
objection has been raised:
</p>

<blockquote><p>
A <tt>negative_sign</tt> of "" means "there is no 
way to write a negative sign" not "any null sequence is a negative 
sign, so it's always there when you look for it".
</p></blockquote>

<p>
[Plum ref _222612Y32]
</p>

<p><i>[
Kona (2007): Bill to provide proposed wording and interpretation of existing wording.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="669"></a>669. Equivalent postive and negative signs in <tt>money_get</tt></h3>
<p><b>Section:</b> 22.2.6.1.2 [locale.money.get.virtuals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Thomas Plum <b>Date:</b> 2007-04-16</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#locale.money.get.virtuals">active issues</a> in [locale.money.get.virtuals].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.money.get.virtuals">issues</a> in [locale.money.get.virtuals].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
22.2.6.1.2 [locale.money.get.virtuals], para 3 sentence 4 says:
</p>

<blockquote><p>
If the first character of <tt>pos</tt> is equal to the first character of <tt>neg</tt>, 
or if both strings are empty, the result is given a positive sign.
</p></blockquote>

<p>
One interpretation is that an input sequence must match either the
positive pattern or the negative pattern, and then in either event it
is interpreted as positive.  The following objections has been raised:
</p>

<blockquote><p>
The input can successfully match only a positive sign, so the negative
pattern is an unsuccessful match.
</p></blockquote>

<p>
[Plum ref _222612Y34, 222612Y51b]
</p>

<p><i>[
Bill to provide proposed wording and interpretation of existing wording.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="670"></a>670. <tt>money_base::pattern</tt> and <tt>space</tt></h3>
<p><b>Section:</b> 22.2.6.3 [locale.moneypunct] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Thomas Plum <b>Date:</b> 2007-04-16</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
22.2.6.3 [locale.moneypunct], para 2 says:
</p>

<blockquote><p>
The value <tt>space</tt> indicates that at least one space is required at 
that position.
</p></blockquote>

<p>
The following objection has been raised:
</p>

<blockquote><p>
Whitespace is optional when matching space. (See 22.2.6.1.2 [locale.money.get.virtuals], para 2.)
</p></blockquote>

<p>
[Plum ref _22263Y22]
</p>

<p><i>[
Kona (2007): Bill to provide proposed wording. We agree that C++03 is
ambiguous, and that we want C++0X to say "space" means 0 or more
whitespace characters on input.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="671"></a>671. precision of hexfloat</h3>
<p><b>Section:</b> 22.2.2.2.2 [facet.num.put.virtuals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> John Salmon <b>Date:</b> 2007-04-20</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#facet.num.put.virtuals">issues</a> in [facet.num.put.virtuals].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I am trying to understand how TR1 supports hex float (%a) output.
</p>
<p>
As far as I can tell, it does so via the following:
</p>
<p>
8.15 Additions to header &lt;locale&gt; [tr.c99.locale]
</p>
<p>
In subclause 22.2.2.2.2 [facet.num.put.virtuals], Table 58 Floating-point conversions, after
the line:
floatfield == ios_base::scientific %E
</p>
<p>
add the two lines:
</p>
<blockquote><pre>floatfield == ios_base::fixed | ios_base::scientific &amp;&amp; !uppercase %a
floatfield == ios_base::fixed | ios_base::scientific %A 2
</pre></blockquote>
<p>
[Note: The additional requirements on print and scan functions, later
in this clause, ensure that the print functions generate hexadecimal
floating-point fields with a %a or %A conversion specifier, and that
the scan functions match hexadecimal floating-point fields with a %g
conversion specifier. &nbsp;end note]
</p>
<p>
Following the thread, in 22.2.2.2.2 [facet.num.put.virtuals], we find:
</p>
<p>
For conversion from a floating-point type, if (flags &amp; fixed) != 0 or
if str.precision() &gt; 0, then str.precision() is specified in the
conversion specification.
</p>
<p>
This would seem to imply that when floatfield == fixed|scientific, the
precision of the conversion specifier is to be taken from
str.precision(). &nbsp;Is this really what's intended? &nbsp;I sincerely hope
that I'm either missing something or this is an oversight. &nbsp;Please
tell me that the committee did not intend to mandate that hex floats
(and doubles) should by default be printed as if by %.6a.
</p>

<p><i>[
Howard: I think the fundamental issue we overlooked was that with %f,
%e, %g, the default precision was always 6. &nbsp;With %a the default
precision is not 6, it is infinity. &nbsp;So for the first time, we need to
distinguish between the default value of precision, and the precision
value 6.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
</p>


<p><i>[
Kona (2007): Robert volunteers to propose wording.
]</i></p>





<hr>
<h3><a name="672"></a>672. Swappable requirements need updating</h3>
<p><b>Section:</b> 20.1.1 [utility.arg.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Howard Hinnant <b>Date:</b> 2007-05-04</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#utility.arg.requirements">active issues</a> in [utility.arg.requirements].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#utility.arg.requirements">issues</a> in [utility.arg.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The current <tt>Swappable</tt> is:
</p>

<blockquote>
<table border="1">
<caption>Table 37: <tt>Swappable</tt> requirements <b>[swappable]</b></caption>
<tbody><tr><th>expression</th><th>return type</th><th>post-condition</th></tr>
<tr><td><tt>swap(s,t)</tt></td><td><tt>void</tt></td><td><tt>t</tt> has the value originally held by <tt>u</tt>, and <tt>u</tt> has the value originally 
held by <tt>t</tt></td></tr>
<tr><td colspan="3">
<p>
The Swappable requirement is met by satisfying one or more of the following conditions:
</p>
<ul>
<li>
<tt>T</tt> is Swappable if <tt>T</tt> satisfies the <tt>CopyConstructible</tt> requirements (Table 34) 
and the <tt>CopyAssignable</tt> requirements (Table 36);
</li>
<li>
<tt>T</tt> is Swappable if a namespace scope function named <tt>swap</tt> exists in the same 
namespace as the definition of <tt>T</tt>, such that the expression <tt>swap(t,u)</tt> is valid 
and has the semantics described in this table.
</li>
</ul>
</td></tr>
</tbody></table>
</blockquote>

<p>
With the passage of rvalue reference into the language, <tt>Swappable</tt> needs to be updated to
require only <tt>MoveConstructible</tt> and <tt>MoveAssignable</tt>.  This is a minimum.
</p>

<p>
Additionally we may want to support proxy references such that the following code is acceptable:
</p>

<blockquote><pre>namespace Mine {

template &lt;class T&gt;
struct proxy {...};

template &lt;class T&gt;
struct proxied_iterator
{
   typedef T value_type;
   typedef proxy&lt;T&gt; reference;
   reference operator*() const;
   ...
};

struct A
{
   // heavy type, has an optimized swap, maybe isn't even copyable or movable, just swappable
   void swap(A&amp;);
   ...
};

void swap(A&amp;, A&amp;);
void swap(proxy&lt;A&gt;, A&amp;);
void swap(A&amp;, proxy&lt;A&gt;);
void swap(proxy&lt;A&gt;, proxy&lt;A&gt;);

}  // Mine

...

Mine::proxied_iterator&lt;Mine::A&gt; i(...)
Mine::A a;
swap(*i1, a);
</pre></blockquote>

<p>
I.e. here is a call to <tt>swap</tt> which the user enables swapping between a proxy to a class and the class
itself.  We do not need to anything in terms of implementation except not block their way with overly
constrained concepts.  That is, the <tt>Swappable</tt> concept should be expanded to allow swapping
between two different types for the case that one is binding to a user-defined <tt>swap</tt>.
</p>



<p><b>Proposed resolution:</b></p>

<p>
Change 20.1.1 [utility.arg.requirements]:
</p>

<blockquote>

<p>
-1- The template definitions in the C++ Standard Library refer to various
named requirements whose details are set out in tables 31-38. In these
tables, <tt>T</tt> is a type to be supplied by a C++ program
instantiating a template; <tt>a</tt>, <tt>b</tt>, and <tt>c</tt> are
values of type <tt>const T</tt>; <tt>s</tt> and <tt>t</tt> are modifiable
lvalues of type <tt>T</tt>; <tt>u</tt> is a value of type (possibly
<tt>const</tt>) <tt>T</tt>; and <tt>rv</tt> is a non-<tt>const</tt>
rvalue of type <tt>T</tt>.
</p>

<table border="1">
<caption>Table 37: <tt>Swappable</tt> requirements <b>[swappable]</b></caption>
<tbody><tr><th>expression</th><th>return type</th><th>post-condition</th></tr>
<tr><td><tt>swap(s,t)</tt></td><td><tt>void</tt></td>
<td><tt>t</tt> has the value originally
held by <tt>u</tt>, and
<tt>u</tt> has the value originally held
by <tt>t</tt></td></tr>
<tr><td colspan="3">
<p>
The <tt>Swappable</tt> requirement is met by satisfying one or more of the following conditions:
</p>
<ul>
<li>
<tt>T</tt> is <tt>Swappable</tt> if <tt>T</tt> satisfies the
<del><tt>CopyConstructible</tt></del> <ins>MoveConstructible</ins>
requirements (Table <del>34</del> <ins>33</ins>) and the <del><tt>CopyAssignable</tt></del> <ins>MoveAssignable</ins>
requirements (Table <del>36</del> <ins>35</ins>);
</li>
<li>
<tt>T</tt> is <tt>Swappable</tt> if a namespace scope function named
<tt>swap</tt> exists in the same namespace as the definition of
<tt>T</tt>, such that the expression
<tt>swap(t,u)</tt> is valid and has the
semantics described in this table.
</li>
</ul>
</td></tr>
</tbody></table>
</blockquote>



<p><i>[
Kona (2007): We like the change to the <tt>Swappable</tt> requirements to use
move semantics. The issue relating to the support of proxies is
separable from the one relating to move semantics, and it's bigger than
just swap. We'd like to address only the move semantics changes under
this issue, and open a separated issue (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#742">742</a>) to handle proxies. Also, there
may be a third issue, in that the current definition of <tt>Swappable</tt> does
not permit rvalues to be operands to a swap operation, and Howard's
proposed resolution would allow the right-most operand to be an rvalue,
but it would not allow the left-most operand to be an rvalue (some swap
functions in the library have been overloaded to permit left operands to
swap to be rvalues).
]</i></p>





<hr>
<h3><a name="673"></a>673. <tt>unique_ptr</tt> update</h3>
<p><b>Section:</b> 20.6.11 [unique.ptr] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Howard Hinnant <b>Date:</b> 2007-05-04</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#unique.ptr">active issues</a> in [unique.ptr].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#unique.ptr">issues</a> in [unique.ptr].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Since the publication of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1856.html">N1856</a>
there have been a few small but significant advances which should be included into
<tt>unique_ptr</tt>.  There exists a
<a href="http://home.twcny.rr.com/hinnant/cpp_extensions/unique_ptr.html">example implmenation</a>
for all of these changes.
</p>

<ul>

<li>
<p>
Even though <tt>unique_ptr&lt;void&gt;</tt> is not a valid use case (unlike for <tt>shared_ptr&lt;void&gt;</tt>),
unexpected cases to crop up which require the instantiation of the interface of <tt>unique_ptr&lt;void&gt;</tt>
even if it is never used.  For example see
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#541">LWG 541</a> for how this accidently
happened to <tt>auto_ptr</tt>.  I believe the most robust way to protect <tt>unique_ptr</tt> against this
type of failure is to augment the return type of <tt>unique_ptr&lt;T&gt;:operator*()</tt> with
<tt>add_lvalue_reference&lt;T&gt;::type</tt>.  This means that given an instantiated <tt>unique_ptr&lt;void&gt;</tt>
the act of dereferencing it will simply return <tt>void</tt> instead of causing a compile time failure.
This is simpler than creating a <tt>unique_ptr&lt;void&gt;</tt> specialization which isn't robust in the
face of <tt><i>cv-</i></tt>qualified <tt>void</tt> types.
</p>

<p>
This resolution also supports instantiations such as <tt>unique_ptr&lt;void, free_deleter&gt;</tt>
which could be very useful to the client.
</p>

</li>

<li>
<p>
Efforts have been made to better support containers and smart pointers in shared
memory contexts.  One of the key hurdles in such support is not assuming that a
pointer type is actually a <tt>T*</tt>.  This can easily be accomplished
for <tt>unique_ptr</tt> by having the deleter define the pointer type:
<tt>D::pointer</tt>.  Furthermore this type can easily be defaulted to
<tt>T*</tt> should the deleter <tt>D</tt> choose not to define a pointer
type (example implementation
<a href="http://home.twcny.rr.com/hinnant/cpp_extensions/unique_ptr.html">here</a>).
This change has no run time overhead.  It has no interface overhead on
authors of custom delter types.  It simply allows (but not requires)
authors of custom deleter types to define a smart pointer for the
storage type of <tt>unique_ptr</tt> if they find such functionality
useful.  <tt>std::default_delete</tt> is an example of a deleter which
defaults <tt>pointer</tt> to <tt>T*</tt> by simply ignoring this issue
and not including a <tt>pointer typedef</tt>.
</p>
</li>

<li>
<p>
When the deleter type is a function pointer then it is unsafe to construct
a <tt>unique_ptr</tt> without specifying the function pointer in the constructor.
This case is easy to check for with a <tt>static_assert</tt> assuring that the
deleter is not a pointer type in those constructors which do not accept deleters.
</p>

<blockquote><pre>unique_ptr&lt;A, void(*)(void*)&gt; p(new A);  // error, no function given to delete the pointer!
</pre></blockquote>

</li>

</ul>

<p><i>[
Kona (2007): We don't like the solution given to the first bullet in
light of concepts. The second bullet solves the problem of supporting
fancy pointers for one library component only. The full LWG needs to
decide whether to solve the problem of supporting fancy pointers
piecemeal, or whether a paper addressing the whole library is needed. We
think that the third bullet is correct.
]</i></p>


<p><i>[
Post Kona: Howard adds example user code related to the first bullet:
]</i></p>


<blockquote>
<pre>void legacy_code(void*, std::size_t);

void foo(std::size_t N)
{
    std::unique_ptr&lt;void, void(*)(void*)&gt; ptr(std::malloc(N), std::free);
    legacy_code(ptr.get(), N);
}   // unique_ptr used for exception safety purposes
</pre>
</blockquote>

<p>
I.e. <tt>unique_ptr&lt;void&gt;</tt> <i>is</i> a useful tool that we don't want
to disable with concepts.  The only part of <tt>unique_ptr&lt;void&gt;</tt> we
want to disable (with concepts or by other means) are the two member functions:
</p>

<blockquote><pre>T&amp; operator*() const;
T* operator-&gt;() const;
</pre></blockquote>



<p><b>Proposed resolution:</b></p>

<p><i>[
I am grateful for the generous aid of Peter Dimov and Ion Gaztaaga in helping formulate and review
the proposed resolutions below.
]</i></p>


<ul>
<li>

<p>
Change 20.6.11.2 [unique.ptr.single]:
</p>

<blockquote><pre>template &lt;class T, class D = default_delete&lt;T&gt;&gt; class unique_ptr {
   ...
   <del>T&amp;</del> <ins>typename add_lvalue_reference&lt;T&gt;::type</ins> operator*() const;
   ...
};
</pre></blockquote>

<p>
Change 20.6.11.2.4 [unique.ptr.single.observers]:
</p>

<blockquote><pre><del>T&amp;</del> <ins>typename add_lvalue_reference&lt;T&gt;::type</ins> operator*() const;
</pre></blockquote>

</li>

<li>
<p>
Change 20.6.11.2 [unique.ptr.single]:
</p>

<blockquote><pre>template &lt;class T, class D = default_delete&lt;T&gt;&gt; class unique_ptr {
public:
  <ins>typedef <i>implementation (see description below)</i> pointer;</ins>
   ...
   explicit unique_ptr(<del>T*</del> <ins>pointer</ins> p);
   ...
   unique_ptr(<del>T*</del> <ins>pointer</ins> p, <i>implementation defined (see description below)</i> d);
   unique_ptr(<del>T*</del> <ins>pointer</ins> p, <i>implementation defined (see description below)</i> d);
   ...
   <del>T*</del> <ins>pointer</ins> operator-&gt;() const;
   <del>T*</del> <ins>pointer</ins> get() const;
   ...
   <del>T*</del> <ins>pointer</ins> release();
   void reset(<del>T*</del> <ins>pointer</ins> p = <del>0</del> <ins>pointer()</ins>);
};
</pre></blockquote>

<p>
<ins>
-3- If the type <tt>remove_reference&lt;D&gt;::type::pointer</tt>
exists, then <tt>unique_ptr&lt;T, D&gt;::pointer</tt> is a typedef to
<tt>remove_reference&lt;D&gt;::type::pointer</tt>.  Otherwise
<tt>unique_ptr&lt;T, D&gt;::pointer</tt> is a typedef to <tt>T*</tt>.
The type <tt>unique_ptr&lt;T, D&gt;::pointer</tt> shall be <tt>CopyConstructible</tt>
and <tt>CopyAssignable</tt>.
</ins>
</p>

<p>
Change 20.6.11.2.1 [unique.ptr.single.ctor]:
</p>

<blockquote><pre>unique_ptr(<del>T*</del> <ins>pointer</ins> p);
...
unique_ptr(<del>T*</del> <ins>pointer</ins> p, <i>implementation defined</i> d); 
unique_ptr(<del>T*</del> <ins>pointer</ins> p, <i>implementation defined</i> d); 
...
unique_ptr(<del>T*</del> <ins>pointer</ins> p, const A&amp; d);
unique_ptr(<del>T*</del> <ins>pointer</ins> p, A&amp;&amp; d);
...
unique_ptr(<del>T*</del> <ins>pointer</ins> p, A&amp; d); 
unique_ptr(<del>T*</del> <ins>pointer</ins> p, A&amp;&amp; d);
...
unique_ptr(<del>T*</del> <ins>pointer</ins> p, const A&amp; d); 
unique_ptr(<del>T*</del> <ins>pointer</ins> p, const A&amp;&amp; d);
...
</pre></blockquote>

<p>
-23- <i>Requires:</i> If <tt>D</tt> is not a reference type,
construction of the deleter <tt>D</tt> from an rvalue of type <tt>E</tt>
<del>must</del> <ins>shall</ins> be well formed and not throw an exception. If <tt>D</tt> is a
reference type, then <tt>E</tt> <del>must</del> <ins>shall</ins> be the same type as <tt>D</tt>
(diagnostic required). <del><tt>U*</tt></del> <ins><tt>unique_ptr&lt;U,E&gt;::pointer</tt></ins>
<del>must</del> <ins>shall</ins> be implicitly convertible to <del><tt>T*</tt></del>
<ins>pointer</ins>.
</p>

<p>
-25- <i>Postconditions:</i> <tt>get() == value u.get()</tt> had before
the construction, modulo any required offset adjustments resulting from
the cast from <del><tt>U*</tt></del>
<ins><tt>unique_ptr&lt;U,E&gt;::pointer</tt></ins> to <del><tt>T*</tt></del>
<ins>pointer</ins>. <tt>get_deleter()</tt> returns a reference to the
internally stored deleter which was constructed from
<tt>u.get_deleter()</tt>.
</p>

<p>
Change 20.6.11.2.3 [unique.ptr.single.asgn]:
</p>

<blockquote>
<p>
-8- <i>Requires:</i> Assignment of the deleter <tt>D</tt> from an rvalue
<tt>D</tt> <del>must</del> <ins>shall</ins> not throw an exception. <del><tt>U*</tt></del>
<ins><tt>unique_ptr&lt;U,E&gt;::pointer</tt></ins> <del>must</del> <ins>shall</ins> be implicitly
convertible to <del><tt>T*</tt></del> <ins>pointer</ins>.
</p>
</blockquote>

<p>
Change 20.6.11.2.4 [unique.ptr.single.observers]:
</p>

<blockquote>
<pre><del>T*</del> <ins>pointer</ins> operator-&gt;() const;</pre>
...
<pre><del>T*</del> <ins>pointer</ins> get() const;</pre>
</blockquote>

<p>
Change 20.6.11.2.5 [unique.ptr.single.modifiers]:
</p>

<blockquote>
<pre><del>T*</del> <ins>pointer</ins> release();</pre>
...
<pre>void reset(<del>T*</del> <ins>pointer</ins> p = <del>0</del> <ins>pointer()</ins>);</pre>
</blockquote>

<p>
Change 20.6.11.3 [unique.ptr.runtime]:
</p>

<blockquote><pre>template &lt;class T, class D&gt; class unique_ptr&lt;T[], D&gt; {
public:
  <ins>typedef <i>implementation</i> pointer;</ins>
   ...
   explicit unique_ptr(<del>T*</del> <ins>pointer</ins> p);
   ...
   unique_ptr(<del>T*</del> <ins>pointer</ins> p, <i>implementation defined</i> d);
   unique_ptr(<del>T*</del> <ins>pointer</ins> p, <i>implementation defined</i> d);
   ...
   <del>T*</del> <ins>pointer</ins> get() const;
   ...
   <del>T*</del> <ins>pointer</ins> release();
   void reset(<del>T*</del> <ins>pointer</ins> p = <del>0</del> <ins>pointer()</ins>);
};
</pre></blockquote>

<p>
Change 20.6.11.3.1 [unique.ptr.runtime.ctor]:
</p>

<blockquote>
<pre>unique_ptr(<del>T*</del> <ins>pointer</ins> p);
unique_ptr(<del>T*</del> <ins>pointer</ins> p, <i>implementation defined</i> d);
unique_ptr(<del>T*</del> <ins>pointer</ins> p, <i>implementation defined</i> d);
</pre>

<p>
These constructors behave the same as in the primary template except
that they do not accept pointer types which are convertible to
<del><tt>T*</tt></del> <ins><tt>pointer</tt></ins>. [<i>Note:</i> One
implementation technique is to create private templated overloads of
these members. <i>-- end note</i>]
</p>
</blockquote>

<p>
Change 20.6.11.3.3 [unique.ptr.runtime.modifiers]:
</p>

<blockquote>
<pre>void reset(<del>T*</del> <ins>pointer</ins> p = <del>0</del> <ins>pointer()</ins>);
</pre>

<p>
-1- <i>Requires:</i> Does not accept pointer types which are convertible
to <del><tt>T*</tt></del> <ins><tt>pointer</tt></ins> (diagnostic
required). [<i>Note:</i> One implementation technique is to create a private
templated overload. <i>-- end note</i>]
</p>
</blockquote>

</li>

<li>

<p>
Change 20.6.11.2.1 [unique.ptr.single.ctor]:
</p>

<blockquote>
<pre>unique_ptr();</pre>
<blockquote>
<p>
<i>Requires:</i> <tt>D</tt> <del>must</del> <ins>shall</ins> be default constructible, and that
construction <del>must</del> <ins>shall</ins> not throw an exception. <tt>D</tt> <del>must</del> <ins>shall</ins> not be a
reference type <ins>or pointer type (diagnostic required)</ins>.
</p>
</blockquote>
<pre>unique_ptr(<del>T*</del> <ins>pointer</ins> p);</pre>
<blockquote>
<p>
<i>Requires:</i>  The expression <tt>D()(p)</tt> <del>must</del> <ins>shall</ins> be well formed.
The default constructor of <tt>D</tt> <del>must</del> <ins>shall</ins> not throw an exception.
<tt>D</tt> <del>must</del> <ins>shall</ins> not be a reference type <ins>or pointer type (diagnostic
required)</ins>.
</p>
</blockquote>
</blockquote>

<p>
Change 20.6.11.2.1 [unique.ptr.single.ctor]:
</p>

<blockquote>
<pre>unique_ptr();</pre>
<blockquote>
<p>
<i>Requires:</i> <tt>D</tt> <del>must</del> <ins>shall</ins> be default constructible, and that
construction <del>must</del> <ins>shall</ins> not throw an exception. <tt>D</tt> <del>must</del> <ins>shall</ins> not be a
reference type <ins>or pointer type (diagnostic required)</ins>.
</p>
</blockquote>
<pre>unique_ptr(<del>T*</del> <ins>pointer</ins> p);</pre>
<blockquote>
<p>
<i>Requires:</i>  The expression <tt>D()(p)</tt> <del>must</del> <ins>shall</ins> be well formed.
The default constructor of <tt>D</tt> <del>must</del> <ins>shall</ins> not throw an exception.
<tt>D</tt> <del>must</del> <ins>shall</ins> not be a reference type <ins>or pointer type (diagnostic
required)</ins>.
</p>
</blockquote>
</blockquote>

</li>

</ul>






<hr>
<h3><a name="675"></a>675. Move assignment of containers</h3>
<p><b>Section:</b> 23.1 [container.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Howard Hinnant <b>Date:</b> 2007-05-05</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#container.requirements">active issues</a> in [container.requirements].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#container.requirements">issues</a> in [container.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
James Hopkin pointed out to me that if <tt>vector&lt;T&gt;</tt> move assignment is O(1)
(just a <tt>swap</tt>) then containers such as <tt>vector&lt;shared_ptr&lt;ostream&gt;&gt;</tt> might have
the wrong semantics under move assignment when the source is not truly an rvalue, but a
moved-from lvalue (destructors could run late).
</p>

<blockquote><pre><tt>vector&lt;shared_ptr&lt;ostream&gt;&gt;</tt> v1;
<tt>vector&lt;shared_ptr&lt;ostream&gt;&gt;</tt> v2;
...
v1 = v2;               // #1
v1 = std::move(v2);    // #2
</pre></blockquote>

<p>
Move semantics means not caring what happens to the source (<tt>v2</tt> in this example).
It doesn't mean not caring what happens to the target (<tt>v1</tt>).  In the above example
both assignments should have the same effect on <tt>v1</tt>.  Any non-shared <tt>ostream</tt>'s
<tt>v1</tt> owns before the assignment should be closed, whether <tt>v1</tt> is undergoing
copy assignment or move assignment.
</p>

<p>
This implies that the semantics of move assignment of a generic container should be
<tt>clear, swap</tt> instead of just swap.  An alternative which could achieve the same
effect would be to move assign each element.  In either case, the complexity of move
assignment needs to be relaxed to <tt>O(v1.size())</tt>.
</p>

<p>
The performance hit of this change is not nearly as drastic as it sounds. 
In practice, the target of a move assignment has always just been move constructed
or move assigned <i>from</i>.  Therefore under <tt>clear, swap</tt> semantics (in
this common use case) we are still achieving O(1) complexity.
</p>



<p><b>Proposed resolution:</b></p>
<p>
Change 23.1 [container.requirements]:
</p>

<blockquote>
<table border="1">
<caption>Table 86: Container requirements</caption>
<tbody><tr>
<th>expression</th><th>return type</th><th>operational semantics</th>
<th>assertion/note pre/post-condition</th><th>complexity</th>
</tr>
<tr>
<td><tt>a = rv;</tt></td><td><tt>X&amp;</tt></td>
<td><ins>All existing elements of <tt>a</tt> are either move assigned or destructed</ins></td>
<td><tt>a</tt> shall be equal to the 
value that <tt>rv</tt> had 
before this construction
</td>
<td><del>constant</del> <ins>linear in <tt>a.size()</tt></ins></td>
</tr>
</tbody></table>
</blockquote>



<p><i>[
post Bellevute Howard adds:
]</i></p>


<blockquote>
<p>
This issue was voted to WP in Bellevue, but accidently got stepped on by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2525.pdf">N2525</a>
which was voted to WP simulataneously.  Moving back to Open for the purpose of getting
the wording right.  The intent of this issue and N2525 are not in conflict.
</p>
</blockquote>




<hr>
<h3><a name="676"></a>676. Moving the unordered containers</h3>
<p><b>Section:</b> 23.4 [unord] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Howard Hinnant <b>Date:</b> 2007-05-05</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#unord">active issues</a> in [unord].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#unord">issues</a> in [unord].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Move semantics are missing from the <tt>unordered</tt> containers.  The proposed
resolution below adds move-support consistent with
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1858.html">N1858</a>
and the current working draft.
</p>

<p>
The current proposed resolution simply lists the requirements for each function.
These might better be hoisted into the requirements table for unordered associative containers.
Futhermore a mild reorganization of the container requirements could well be in order.
This defect report is purposefully ignoring these larger issues and just focusing
on getting the unordered containers "moved".
</p>



<p><b>Proposed resolution:</b></p>

<p>
Add to 23.4 [unord]:
</p>

<blockquote><pre>template &lt;class Key, class T, class Hash, class Pred, class Alloc&gt; 
  void swap(unordered_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x, 
            unordered_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y); 

<ins>template &lt;class Key, class T, class Hash, class Pred, class Alloc&gt; 
  void swap(unordered_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x, 
            unordered_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp;&amp; y);</ins>

<ins>template &lt;class Key, class T, class Hash, class Pred, class Alloc&gt; 
  void swap(unordered_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp;&amp; x, 
            unordered_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y);</ins>

template &lt;class Key, class T, class Hash, class Pred, class Alloc&gt; 
  void swap(unordered_multimap&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x, 
            unordered_multimap&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y);

<ins>template &lt;class Key, class T, class Hash, class Pred, class Alloc&gt; 
  void swap(unordered_multimap&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x, 
            unordered_multimap&lt;Key, T, Hash, Pred, Alloc&gt;&amp;&amp; y);</ins>

<ins>template &lt;class Key, class T, class Hash, class Pred, class Alloc&gt; 
  void swap(unordered_multimap&lt;Key, T, Hash, Pred, Alloc&gt;&amp;&amp; x, 
            unordered_multimap&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y);</ins>

...

template &lt;class Value, class Hash, class Pred, class Alloc&gt; 
  void swap(unordered_set&lt;Value, Hash, Pred, Alloc&gt;&amp; x, 
            unordered_set&lt;Value, Hash, Pred, Alloc&gt;&amp; y); 

<ins>template &lt;class Value, class Hash, class Pred, class Alloc&gt; 
  void swap(unordered_set&lt;Value, Hash, Pred, Alloc&gt;&amp; x, 
            unordered_set&lt;Value, Hash, Pred, Alloc&gt;&amp;&amp; y);</ins>

<ins>template &lt;class Value, class Hash, class Pred, class Alloc&gt; 
  void swap(unordered_set&lt;Value, Hash, Pred, Alloc&gt;&amp;&amp; x, 
            unordered_set&lt;Value, Hash, Pred, Alloc&gt;&amp; y);</ins>

template &lt;class Value, class Hash, class Pred, class Alloc&gt; 
  void swap(unordered_multiset&lt;Value, Hash, Pred, Alloc&gt;&amp; x, 
            unordered_multiset&lt;Value, Hash, Pred, Alloc&gt;&amp; y);

<ins>template &lt;class Value, class Hash, class Pred, class Alloc&gt; 
  void swap(unordered_multiset&lt;Value, Hash, Pred, Alloc&gt;&amp; x, 
            unordered_multiset&lt;Value, Hash, Pred, Alloc&gt;&amp;&amp; y);</ins>

<ins>template &lt;class Value, class Hash, class Pred, class Alloc&gt; 
  void swap(unordered_multiset&lt;Value, Hash, Pred, Alloc&gt;&amp;&amp; x, 
            unordered_multiset&lt;Value, Hash, Pred, Alloc&gt;&amp; y);</ins>
</pre></blockquote>

<p><b><tt>unordered_map</tt></b></p>

<p>
Change 23.4.1 [unord.map]:
</p>

<blockquote><pre>class unordered_map
{
    ...
    unordered_map(const unordered_map&amp;);
    <ins>unordered_map(unordered_map&amp;&amp;);</ins>
    ~unordered_map();
    unordered_map&amp; operator=(const unordered_map&amp;);
    <ins>unordered_map&amp; operator=(unordered_map&amp;&amp;);</ins>
    ...
    // modifiers 
    <del>std::</del>pair&lt;iterator, bool&gt; insert(const value_type&amp; obj); 
    <ins>template &lt;class P&gt; pair&lt;iterator, bool&gt; insert(P&amp;&amp; obj);</ins>
    iterator       insert(iterator hint, const value_type&amp; obj);
    <ins>template &lt;class P&gt; iterator       insert(iterator hint, P&amp;&amp; obj);</ins>
    const_iterator insert(const_iterator hint, const value_type&amp; obj);
    <ins>template &lt;class P&gt; const_iterator insert(const_iterator hint, P&amp;&amp; obj);</ins>
    ...
    void swap(unordered_map&amp;<ins>&amp;</ins>);
    ...
    mapped_type&amp; operator[](const key_type&amp; k);
    <ins>mapped_type&amp; operator[](key_type&amp;&amp; k);</ins>
    ...
};

template &lt;class Key, class T, class Hash, class Pred, class Alloc&gt; 
  void swap(unordered_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x, 
            unordered_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y);

<ins>template &lt;class Key, class T, class Hash, class Pred, class Alloc&gt; 
  void swap(unordered_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x, 
            unordered_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp;&amp; y);</ins>

<ins>template &lt;class Key, class T, class Hash, class Pred, class Alloc&gt; 
  void swap(unordered_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp;&amp; x, 
            unordered_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y);</ins>
</pre></blockquote>

<p>
Add to 23.4.1.1 [unord.map.cnstr]:
</p>

<blockquote>
<pre>template &lt;class InputIterator&gt;
  unordered_map(InputIterator f, InputIterator l, 
                size_type n = <i>implementation-defined</i>, 
                const hasher&amp; hf = hasher(), 
                const key_equal&amp; eql = key_equal(), 
                const allocator_type&amp; a = allocator_type());
</pre>

<blockquote><p>
<ins>
<i>Requires:</i> If the iterator's dereference operator returns an
lvalue or a const rvalue <tt>pair&lt;key_type, mapped_type&gt;</tt>,
then both <tt>key_type</tt> and <tt>mapped_type</tt> shall be
<tt>CopyConstructible</tt>.
</ins>
</p></blockquote>
</blockquote>

<p>
Add to 23.4.1.2 [unord.map.elem]:
</p>

<blockquote>

<pre>mapped_type&amp; operator[](const key_type&amp; k);</pre>

<blockquote>
<p>...</p>
<p><ins>
<i>Requires:</i> <tt>key_type</tt> shall be <tt>CopyConstructible</tt>
and <tt>mapped_type</tt> shall be <tt>DefaultConstructible</tt>.
</ins></p>
</blockquote>

<pre><ins>mapped_type&amp; operator[](key_type&amp;&amp; k);</ins></pre>

<blockquote>
<p><ins>
<i>Effects:</i> If the <tt>unordered_map</tt> does not already contain an
element whose key is equivalent to <tt>k</tt> , inserts the value
<tt>std::pair&lt;const key_type, mapped_type&gt;(std::move(k), mapped_type())</tt>.
</ins></p>

<p><ins>
<i>Requires:</i> <tt>mapped_type</tt> shall be <tt>DefaultConstructible</tt>.
</ins></p>

<p><ins>
<i>Returns:</i> A reference to <tt>x.second</tt>, where <tt>x</tt> is the
(unique) element whose key is equivalent to <tt>k</tt>.
</ins></p>

</blockquote>

</blockquote>

<p>
Add new section [unord.map.modifiers]:
</p>

<blockquote>
<pre><ins>pair&lt;iterator, bool&gt; insert(const value_type&amp; x);</ins>
<ins>template &lt;class P&gt; pair&lt;iterator, bool&gt; insert(P&amp;&amp; x);</ins>
<ins>iterator       insert(iterator hint, const value_type&amp; x);</ins>
<ins>template &lt;class P&gt; iterator       insert(iterator hint, P&amp;&amp; x);</ins>
<ins>const_iterator insert(const_iterator hint, const value_type&amp; x);</ins>
<ins>template &lt;class P&gt; const_iterator insert(const_iterator hint, P&amp;&amp; x);</ins>
<ins>template &lt;class InputIterator&gt;
  void insert(InputIterator first, InputIterator last);</ins>
</pre>

<blockquote>
<p><ins>
<i>Requires:</i> Those signatures taking a <tt>const value_type&amp;</tt> parameter
requires both the <tt>key_type</tt> and the <tt>mapped_type</tt> to be
<tt>CopyConstructible</tt>.
</ins></p>

<p><ins>
<tt>P</tt> shall be convertible to <tt>value_type</tt>.
 If <tt>P</tt> is instantiated as a reference
type, then the argument <tt>x</tt> is copied from. Otherwise <tt>x</tt>
is considered to be an rvalue as it is converted to <tt>value_type</tt>
and inserted into the <tt>unordered_map</tt>. Specifically, in such
cases <tt>CopyConstructible</tt> is not required of <tt>key_type</tt> or
<tt>mapped_type</tt> unless the conversion from <tt>P</tt> specifically
requires it (e.g. if <tt>P</tt> is a <tt>tuple&lt;const key_type,
mapped_type&gt;</tt>, then <tt>key_type</tt> must be
<tt>CopyConstructible</tt>).
</ins></p>

<p><ins>
The signature taking <tt>InputIterator</tt>
parameters requires <tt>CopyConstructible</tt> of both
<tt>key_type</tt> and <tt>mapped_type</tt> if the dereferenced
<tt>InputIterator</tt> returns an lvalue or <tt>const</tt> rvalue
<tt>value_type</tt>.
</ins></p>

</blockquote>

</blockquote>

<p>
Add to 23.4.1.3 [unord.map.swap]:
</p>

<blockquote>
<pre>template &lt;class Key, class T, class Hash, class Pred, class Alloc&gt; 
  void swap(unordered_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x, 
            unordered_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y);
<ins>template &lt;class Key, class T, class Hash, class Pred, class Alloc&gt; 
  void swap(unordered_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x, 
            unordered_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp;&amp; y);</ins>
<ins>template &lt;class Key, class T, class Hash, class Pred, class Alloc&gt; 
  void swap(unordered_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp;&amp; x, 
            unordered_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y);</ins>
</pre>
</blockquote>

<p><b><tt>unordered_multimap</tt></b></p>

<p>
Change 23.4.2 [unord.multimap]:
</p>

<blockquote><pre>class unordered_multimap
{
    ...
    unordered_multimap(const unordered_multimap&amp;);
    <ins>unordered_multimap(unordered_multimap&amp;&amp;);</ins>
    ~unordered_multimap();
    unordered_multimap&amp; operator=(const unordered_multimap&amp;);
    <ins>unordered_multimap&amp; operator=(unordered_multimap&amp;&amp;);</ins>
    ...
    // modifiers 
    iterator insert(const value_type&amp; obj); 
    <ins>template &lt;class P&gt; iterator insert(P&amp;&amp; obj);</ins>
    iterator       insert(iterator hint, const value_type&amp; obj);
    <ins>template &lt;class P&gt; iterator       insert(iterator hint, P&amp;&amp; obj);</ins>
    const_iterator insert(const_iterator hint, const value_type&amp; obj);
    <ins>template &lt;class P&gt; const_iterator insert(const_iterator hint, P&amp;&amp; obj);</ins>
    ...
    void swap(unordered_multimap&amp;<ins>&amp;</ins>);
    ...
};

template &lt;class Key, class T, class Hash, class Pred, class Alloc&gt; 
  void swap(unordered_multimap&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x, 
            unordered_multimap&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y);

<ins>template &lt;class Key, class T, class Hash, class Pred, class Alloc&gt; 
  void swap(unordered_multimap&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x, 
            unordered_multimap&lt;Key, T, Hash, Pred, Alloc&gt;&amp;&amp; y);</ins>

<ins>template &lt;class Key, class T, class Hash, class Pred, class Alloc&gt; 
  void swap(unordered_multimap&lt;Key, T, Hash, Pred, Alloc&gt;&amp;&amp; x, 
            unordered_multimap&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y);</ins>
</pre></blockquote>

<p>
Add to 23.4.2.1 [unord.multimap.cnstr]:
</p>

<blockquote>
<pre>template &lt;class InputIterator&gt;
  unordered_multimap(InputIterator f, InputIterator l, 
                size_type n = <i>implementation-defined</i>, 
                const hasher&amp; hf = hasher(), 
                const key_equal&amp; eql = key_equal(), 
                const allocator_type&amp; a = allocator_type());
</pre>

<blockquote><p>
<ins>
<i>Requires:</i> If the iterator's dereference operator returns an
lvalue or a const rvalue <tt>pair&lt;key_type, mapped_type&gt;</tt>,
then both <tt>key_type</tt> and <tt>mapped_type</tt> shall be
<tt>CopyConstructible</tt>.
</ins>
</p></blockquote>
</blockquote>

<p>
Add new section [unord.multimap.modifiers]:
</p>

<blockquote>
<pre><ins>iterator insert(const value_type&amp; x);</ins>
<ins>template &lt;class P&gt; iterator       insert(P&amp;&amp; x);</ins>
<ins>iterator       insert(iterator hint, const value_type&amp; x);</ins>
<ins>template &lt;class P&gt; iterator       insert(iterator hint, P&amp;&amp; x);</ins>
<ins>const_iterator insert(const_iterator hint, const value_type&amp; x);</ins>
<ins>template &lt;class P&gt; const_iterator insert(const_iterator hint, P&amp;&amp; x);</ins>
<ins>template &lt;class InputIterator&gt;
  void insert(InputIterator first, InputIterator last);</ins>
</pre>

<blockquote>
<p><ins>
<i>Requires:</i> Those signatures taking a <tt>const value_type&amp;</tt> parameter
requires both the <tt>key_type</tt> and the <tt>mapped_type</tt> to be
<tt>CopyConstructible</tt>.
</ins></p>

<p><ins>
<tt>P</tt> shall be convertible to <tt>value_type</tt>.
 If <tt>P</tt> is instantiated as a reference
type, then the argument <tt>x</tt> is copied from. Otherwise <tt>x</tt>
is considered to be an rvalue as it is converted to <tt>value_type</tt>
and inserted into the <tt>unordered_multimap</tt>. Specifically, in such
cases <tt>CopyConstructible</tt> is not required of <tt>key_type</tt> or
<tt>mapped_type</tt> unless the conversion from <tt>P</tt> specifically
requires it (e.g. if <tt>P</tt> is a <tt>tuple&lt;const key_type,
mapped_type&gt;</tt>, then <tt>key_type</tt> must be
<tt>CopyConstructible</tt>).
</ins></p>

<p><ins>
The signature taking <tt>InputIterator</tt>
parameters requires <tt>CopyConstructible</tt> of both
<tt>key_type</tt> and <tt>mapped_type</tt> if the dereferenced
<tt>InputIterator</tt> returns an lvalue or <tt>const</tt> rvalue
<tt>value_type</tt>.
</ins></p>
</blockquote>

</blockquote>

<p>
Add to 23.4.2.2 [unord.multimap.swap]:
</p>

<blockquote>
<pre>template &lt;class Key, class T, class Hash, class Pred, class Alloc&gt; 
  void swap(unordered_multimap&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x, 
            unordered_multimap&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y);
<ins>template &lt;class Key, class T, class Hash, class Pred, class Alloc&gt; 
  void swap(unordered_multimap&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x, 
            unordered_multimap&lt;Key, T, Hash, Pred, Alloc&gt;&amp;&amp; y);</ins>
<ins>template &lt;class Key, class T, class Hash, class Pred, class Alloc&gt; 
  void swap(unordered_multimap&lt;Key, T, Hash, Pred, Alloc&gt;&amp;&amp; x, 
            unordered_multimap&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y);</ins>
</pre>
</blockquote>

<p><b><tt>unordered_set</tt></b></p>

<p>
Change 23.4.3 [unord.set]:
</p>

<blockquote><pre>class unordered_set
{
    ...
    unordered_set(const unordered_set&amp;);
    <ins>unordered_set(unordered_set&amp;&amp;);</ins>
    ~unordered_set();
    unordered_set&amp; operator=(const unordered_set&amp;);
    <ins>unordered_set&amp; operator=(unordered_set&amp;&amp;);</ins>
    ...
    // modifiers 
    <del>std::</del>pair&lt;iterator, bool&gt; insert(const value_type&amp; obj); 
    <ins>pair&lt;iterator, bool&gt; insert(value_type&amp;&amp; obj);</ins>
    iterator       insert(iterator hint, const value_type&amp; obj);
    <ins>iterator       insert(iterator hint, value_type&amp;&amp; obj);</ins>
    const_iterator insert(const_iterator hint, const value_type&amp; obj);
    <ins>const_iterator insert(const_iterator hint, value_type&amp;&amp; obj);</ins>
    ...
    void swap(unordered_set&amp;<ins>&amp;</ins>);
    ...
};

template &lt;class Key, class T, class Hash, class Pred, class Alloc&gt; 
  void swap(unordered_set&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x, 
            unordered_set&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y);

<ins>template &lt;class Key, class T, class Hash, class Pred, class Alloc&gt; 
  void swap(unordered_set&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x, 
            unordered_set&lt;Key, T, Hash, Pred, Alloc&gt;&amp;&amp; y);</ins>

<ins>template &lt;class Key, class T, class Hash, class Pred, class Alloc&gt; 
  void swap(unordered_set&lt;Key, T, Hash, Pred, Alloc&gt;&amp;&amp; x, 
            unordered_set&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y);</ins>
</pre></blockquote>

<p>
Add to 23.4.3.1 [unord.set.cnstr]:
</p>

<blockquote>
<pre>template &lt;class InputIterator&gt;
  unordered_set(InputIterator f, InputIterator l, 
                size_type n = <i>implementation-defined</i>, 
                const hasher&amp; hf = hasher(), 
                const key_equal&amp; eql = key_equal(), 
                const allocator_type&amp; a = allocator_type());
</pre>

<blockquote><p>
<ins>
<i>Requires:</i> If the iterator's dereference operator returns an
lvalue or a const rvalue <tt>value_type</tt>, then the
<tt>value_type</tt> shall be <tt>CopyConstructible</tt>.
</ins>
</p></blockquote>
</blockquote>

<p>
Add new section [unord.set.modifiers]:
</p>

<blockquote>
<pre><ins>pair&lt;iterator, bool&gt; insert(const value_type&amp; x);</ins>
<ins>pair&lt;iterator, bool&gt; insert(value_type&amp;&amp; x);</ins>
<ins>iterator       insert(iterator hint, const value_type&amp; x);</ins>
<ins>iterator       insert(iterator hint, value_type&amp;&amp; x);</ins>
<ins>const_iterator insert(const_iterator hint, const value_type&amp; x);</ins>
<ins>const_iterator insert(const_iterator hint, value_type&amp;&amp; x);</ins>
<ins>template &lt;class InputIterator&gt;
  void insert(InputIterator first, InputIterator last);</ins>
</pre>

<blockquote>

<p><ins>
<i>Requires:</i> Those signatures taking a <tt>const
value_type&amp;</tt> parameter requires the <tt>value_type</tt> to
be <tt>CopyConstructible</tt>.
</ins></p>

<p><ins>
The signature taking <tt>InputIterator</tt> parameters requires
<tt>CopyConstructible</tt> of <tt>value_type</tt> if the dereferenced
<tt>InputIterator</tt> returns an lvalue or <tt>const</tt> rvalue
<tt>value_type</tt>.
</ins></p>

</blockquote>

</blockquote>

<p>
Add to 23.4.3.2 [unord.set.swap]:
</p>

<blockquote>
<pre>template &lt;class Key, class T, class Hash, class Pred, class Alloc&gt; 
  void swap(unordered_set&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x, 
            unordered_set&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y);
<ins>template &lt;class Key, class T, class Hash, class Pred, class Alloc&gt; 
  void swap(unordered_set&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x, 
            unordered_set&lt;Key, T, Hash, Pred, Alloc&gt;&amp;&amp; y);</ins>
<ins>template &lt;class Key, class T, class Hash, class Pred, class Alloc&gt; 
  void swap(unordered_set&lt;Key, T, Hash, Pred, Alloc&gt;&amp;&amp; x, 
            unordered_set&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y);</ins>
</pre>
</blockquote>

<p><b><tt>unordered_multiset</tt></b></p>

<p>
Change 23.4.4 [unord.multiset]:
</p>

<blockquote><pre>class unordered_multiset
{
    ...
    unordered_multiset(const unordered_multiset&amp;);
    <ins>unordered_multiset(unordered_multiset&amp;&amp;);</ins>
    ~unordered_multiset();
    unordered_multiset&amp; operator=(const unordered_multiset&amp;);
    <ins>unordered_multiset&amp; operator=(unordered_multiset&amp;&amp;);</ins>
    ...
    // modifiers 
    iterator insert(const value_type&amp; obj); 
    <ins>iterator insert(value_type&amp;&amp; obj);</ins>
    iterator       insert(iterator hint, const value_type&amp; obj);
    <ins>iterator       insert(iterator hint, value_type&amp;&amp; obj);</ins>
    const_iterator insert(const_iterator hint, const value_type&amp; obj);
    <ins>const_iterator insert(const_iterator hint, value_type&amp;&amp; obj);</ins>
    ...
    void swap(unordered_multiset&amp;<ins>&amp;</ins>);
    ...
};

template &lt;class Key, class T, class Hash, class Pred, class Alloc&gt; 
  void swap(unordered_multiset&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x, 
            unordered_multiset&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y);

<ins>template &lt;class Key, class T, class Hash, class Pred, class Alloc&gt; 
  void swap(unordered_multiset&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x, 
            unordered_multiset&lt;Key, T, Hash, Pred, Alloc&gt;&amp;&amp; y);</ins>

<ins>template &lt;class Key, class T, class Hash, class Pred, class Alloc&gt; 
  void swap(unordered_multiset&lt;Key, T, Hash, Pred, Alloc&gt;&amp;&amp; x, 
            unordered_multiset&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y);</ins>
</pre></blockquote>

<p>
Add to 23.4.4.1 [unord.multiset.cnstr]:
</p>

<blockquote>
<pre>template &lt;class InputIterator&gt;
  unordered_multiset(InputIterator f, InputIterator l, 
                size_type n = <i>implementation-defined</i>, 
                const hasher&amp; hf = hasher(), 
                const key_equal&amp; eql = key_equal(), 
                const allocator_type&amp; a = allocator_type());
</pre>

<blockquote><p>
<ins>
<i>Requires:</i> If the iterator's dereference operator returns an
lvalue or a const rvalue <tt>value_type</tt>, then the
<tt>value_type</tt> shall be <tt>CopyConstructible</tt>.
</ins>
</p></blockquote>
</blockquote>

<p>
Add new section [unord.multiset.modifiers]:
</p>

<blockquote>
<pre><ins>iterator insert(const value_type&amp; x);</ins>
<ins>iterator insert(value_type&amp;&amp; x);</ins>
<ins>iterator       insert(iterator hint, const value_type&amp; x);</ins>
<ins>iterator       insert(iterator hint, value_type&amp;&amp; x);</ins>
<ins>const_iterator insert(const_iterator hint, const value_type&amp; x);</ins>
<ins>const_iterator insert(const_iterator hint, value_type&amp;&amp; x);</ins>
<ins>template &lt;class InputIterator&gt;
  void insert(InputIterator first, InputIterator last);</ins>
</pre>

<blockquote>

<p><ins>
<i>Requires:</i> Those signatures taking a <tt>const
value_type&amp;</tt> parameter requires the <tt>value_type</tt> to
be <tt>CopyConstructible</tt>.
</ins></p>

<p><ins>
The signature taking <tt>InputIterator</tt> parameters requires
<tt>CopyConstructible</tt> of <tt>value_type</tt> if the dereferenced
<tt>InputIterator</tt> returns an lvalue or <tt>const</tt> rvalue
<tt>value_type</tt>.
</ins></p>

</blockquote>

</blockquote>

<p>
Add to 23.4.4.2 [unord.multiset.swap]:
</p>

<blockquote>
<pre>template &lt;class Key, class T, class Hash, class Pred, class Alloc&gt; 
  void swap(unordered_multiset&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x, 
            unordered_multiset&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y);
<ins>template &lt;class Key, class T, class Hash, class Pred, class Alloc&gt; 
  void swap(unordered_multiset&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x, 
            unordered_multiset&lt;Key, T, Hash, Pred, Alloc&gt;&amp;&amp; y);</ins>
<ins>template &lt;class Key, class T, class Hash, class Pred, class Alloc&gt; 
  void swap(unordered_multiset&lt;Key, T, Hash, Pred, Alloc&gt;&amp;&amp; x, 
            unordered_multiset&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y);</ins>
</pre>
</blockquote>



<p><i>[
Voted to WP in Bellevue.
]</i></p>


<p><i>[
post Bellevue, Pete notes:
]</i></p>


<blockquote>
<p>
Please remind people who are reviewing issues to check that the text
modifications match the current draft. Issue 676, for example, adds two
overloads for unordered_map::insert taking a hint. One takes a
const_iterator and returns a const_iterator, and the other takes an
iterator and returns an iterator. This was correct at the time the issue
was written, but was changed in Toronto so there is only one hint
overload, taking a const_iterator and returning an iterator.
</p>
<p>
This issue is not ready. In addition to the relatively minor signature
problem I mentioned earlier, it puts requirements in the wrong places.
Instead of duplicating requirements throughout the template
specifications, it should put them in the front matter that talks about
requirements for unordered containers in general. This presentation
problem is editorial, but I'm not willing to do the extensive rewrite
that it requires. Please put it back into Open status.
</p>
</blockquote>




<hr>
<h3><a name="685"></a>685. reverse_iterator/move_iterator difference has invalid signatures</h3>
<p><b>Section:</b> 24.4.1.3.19 [reverse.iter.opdiff], 24.4.3.3.14 [move.iter.nonmember] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Bo Persson <b>Date:</b> 2007-06-10</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In C++03 the difference between two <tt>reverse_iterators</tt>
</p>
<blockquote><pre>ri1 - ri2
</pre></blockquote>
<p>
is possible to compute only if both iterators have the same base 
iterator. The result type is the <tt>difference_type</tt> of the base iterator. 
</p>
<p>
In the current draft, the operator is defined as 24.4.1.3.19 [reverse.iter.opdiff] 
</p>
<blockquote><pre>template&lt;class Iterator1, class Iterator2&gt; 
typename reverse_iterator&lt;Iterator&gt;::difference_type 
   operator-(const reverse_iterator&lt;Iterator1&gt;&amp; x, 
                    const reverse_iterator&lt;Iterator2&gt;&amp; y);
</pre></blockquote>
<p>
The return type is the same as the C++03 one, based on the no longer 
present <tt>Iterator</tt> template parameter. 
</p>
<p>
Besides being slightly invalid, should this operator work only when 
<tt>Iterator1</tt> and <tt>Iterator2</tt> has the same <tt>difference_type</tt>? Or should the 
implementation choose one of them? Which one? 
</p>
<p>
The same problem now also appears in <tt>operator-()</tt> for <tt>move_iterator</tt>
24.4.3.3.14 [move.iter.nonmember]. 
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change the synopsis in 24.4.1.1 [reverse.iterator]:
</p>

<blockquote>
<pre>template &lt;class Iterator1, class Iterator2&gt; 
  <del>typename reverse_iterator&lt;Iterator&gt;::difference_type</del> <ins>auto</ins> operator-( 
    const reverse_iterator&lt;Iterator1&gt;&amp; x, 
    const reverse_iterator&lt;Iterator2&gt;&amp; y)<ins> -&gt; decltype(y.current - x.current)</ins>;
</pre>
</blockquote>

<p>
Change 24.4.1.3.19 [reverse.iter.opdiff]:
</p>

<blockquote>
<pre>template &lt;class Iterator1, class Iterator2&gt; 
  <del>typename reverse_iterator&lt;Iterator&gt;::difference_type</del> <ins>auto</ins> operator-( 
    const reverse_iterator&lt;Iterator1&gt;&amp; x, 
    const reverse_iterator&lt;Iterator2&gt;&amp; y)<ins> -&gt; decltype(y.current - x.current)</ins>;
</pre>
<blockquote>
<p>
<i>Returns:</i> <tt>y.current - x.current</tt>.
</p>
</blockquote>
</blockquote>


<p>
Change the synopsis in 24.4.3.1 [move.iterator]:
</p>

<blockquote>
<pre>template &lt;class Iterator1, class Iterator2&gt; 
  <del>typename move_iterator&lt;Iterator&gt;::difference_type</del> <ins>auto</ins> operator-( 
    const move_iterator&lt;Iterator1&gt;&amp; x, 
    const move_iterator&lt;Iterator2&gt;&amp; y)<ins> -&gt; decltype(x.base() - y.base())</ins>;
</pre>
</blockquote>

<p>
Change 24.4.3.3.14 [move.iter.nonmember]:
</p>

<blockquote>
<pre>template &lt;class Iterator1, class Iterator2&gt; 
  <del>typename move_iterator&lt;Iterator&gt;::difference_type</del> <ins>auto</ins> operator-( 
    const move_iterator&lt;Iterator1&gt;&amp; x, 
    const move_iterator&lt;Iterator2&gt;&amp; y)<ins> -&gt; decltype(x.base() - y.base())</ins>;
</pre>
<blockquote>
<p>
<i>Returns:</i> <tt>x.base() - y.base()</tt>.
</p>
</blockquote>
</blockquote>

<p><i>[
Pre Bellevue:  This issue needs to wait until the <tt>auto -&gt; return</tt> language feature
goes in.
]</i></p>







<hr>
<h3><a name="688"></a>688. reference_wrapper, cref unsafe, allow binding to rvalues</h3>
<p><b>Section:</b> 20.5.5.1 [refwrap.const] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Peter Dimov <b>Date:</b> 2007-05-10</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#refwrap.const">issues</a> in [refwrap.const].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
A <tt>reference_wrapper</tt> can be constructed from an rvalue, either by using
the constructor, or via <tt>cref</tt> (and <tt>ref</tt> in some corner cases). This leads
to a dangling reference being stored into the <tt>reference_wrapper</tt> object.
Now that we have a mechanism to detect an rvalue, we can fix them to
disallow this source of undefined behavior.
</p>

<p>
Also please see the thread starting at c++std-lib-17398 for some good discussion on this subject.
</p>



<p><b>Proposed resolution:</b></p>
<p>
In 20.5 [function.objects], add the following two signatures to the synopsis:
</p>

<blockquote><pre>template &lt;class T&gt; void ref(const T&amp;&amp; t) = delete;
template &lt;class T&gt; void cref(const T&amp;&amp; t) = delete;
</pre></blockquote>



<p><i>[
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2292.html">N2292</a>
addresses the first part of the resolution but not the second.
]</i></p>


<p><i>[
Bellevue:  Doug noticed problems with the current wording.
]</i></p>


<p><i>[
post Bellevue:  Howard and Peter provided revised wording.
]</i></p>


<p><i>[
This resolution depends on a "favorable" resolution of CWG 606:  that is,
the "special deduction rule" is disabled with the const T&amp;&amp; pattern.
]</i></p>





<hr>
<h3><a name="691"></a>691. const_local_iterator cbegin, cend missing from TR1</h3>
<p><b>Section:</b> 23.4 [unord], TR1 6.3 [tr.hash] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Review">Review</a>
 <b>Submitter:</b> Joaqun M Lpez Muoz <b>Date:</b> 2007-06-14</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#unord">active issues</a> in [unord].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#unord">issues</a> in [unord].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Review">Review</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The last version of TR1 does not include the following member
functions
for unordered containers:
</p>

<blockquote><pre>const_local_iterator cbegin(size_type n) const;
const_local_iterator cend(size_type n) const;
</pre></blockquote>

<p>
which looks like an oversight to me. I've checked th TR1 issues lists
and the latest working draft of the C++0x std (N2284) and haven't
found any mention to these menfuns or to their absence.
</p>
<p>
Is this really an oversight, or am I missing something?
</p>



<p><b>Proposed resolution:</b></p>
<p>
Add the following two rows to table 93 (unordered associative container
requirements) in section 23.1.3 [unord.req]:
</p>

<blockquote>
<table border="1">
<caption>Unordered associative container requirements (in addition to container)</caption>
<tbody><tr>
<th>expression</th> <th>return type</th> <th>assertion/note pre/post-condition</th> <th>complexity</th>
</tr>
<tr>
<td><ins><tt>b.cbegin(n)</tt></ins></td> <td><ins><tt>const_local_iterator</tt></ins></td> <td><ins><tt>n</tt> shall be in the range <tt>[0, bucket_count())</tt>. Note: <tt>[b.cbegin(n), b.cend(n))</tt> is a valid range containing all of the elements in the <tt>n</tt><sup><i>th</i></sup> bucket.</ins></td> <td><ins>Constant</ins></td> 
</tr>
<tr>
<td><ins><tt>b.cend(n)</tt></ins></td> <td><ins><tt>const_local_iterator</tt></ins></td> <td><ins><tt>n</tt> shall be in the range <tt>[0, bucket_count())</tt>.</ins></td> <td><ins>Constant</ins></td> 
</tr>
</tbody></table>
</blockquote>

<p>
Add to the synopsis in 23.4.1 [unord.map]:
</p>

<blockquote><pre><ins>const_local_iterator cbegin(size_type n) const;
const_local_iterator cend(size_type n) const;</ins>
</pre></blockquote>

<p>
Add to the synopsis in 23.4.2 [unord.multimap]:
</p>

<blockquote><pre><ins>const_local_iterator cbegin(size_type n) const;
const_local_iterator cend(size_type n) const;</ins>
</pre></blockquote>

<p>
Add to the synopsis in 23.4.3 [unord.set]:
</p>

<blockquote><pre><ins>const_local_iterator cbegin(size_type n) const;
const_local_iterator cend(size_type n) const;</ins>
</pre></blockquote>

<p>
Add to the synopsis in 23.4.4 [unord.multiset]:
</p>

<blockquote><pre><ins>const_local_iterator cbegin(size_type n) const;
const_local_iterator cend(size_type n) const;</ins>
</pre></blockquote>






<hr>
<h3><a name="692"></a>692. <code>get_money</code> and <code>put_money</code> should be formatted I/O functions</h3>
<p><b>Section:</b> 27.6.4 [ext.manip] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Martin Sebor <b>Date:</b> 2007-06-22</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#ext.manip">active issues</a> in [ext.manip].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#ext.manip">issues</a> in [ext.manip].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In a private email Bill Plauger notes:
</p>
<blockquote><p>
I  believe that  the function  that  implements <code>get_money</code>
[from <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2072.html">N2072</a>]
should behave  as a  formatted input function,  and the  function that
implements <code>put_money</code> should  behave as a formatted output
function. This  has implications regarding the  skipping of whitespace
and the handling of errors, among other things.
</p>
<p>
The words  don't say that  right now and  I'm far from  convinced that
such a change is editorial.
</p></blockquote>
<p>
Martin's response:
</p>
<blockquote><p>
I agree that the manipulators should handle exceptions the same way as
formatted I/O functions do. The text in N2072 assumes so but the
<i>Returns</i> clause explicitly omits exception handling for the sake
of brevity. The spec should be clarified to that effect.
</p>
<p>
As for dealing  with whitespace, I also agree it  would make sense for
the extractors  and inserters involving the new  manipulators to treat
it the same way as formatted I/O.
</p></blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Add  a new  paragraph immediately  above  p4 of 27.6.4 [ext.manip] with  the
following text:
</p>
<blockquote><p>
<i>Effects</i>:  The   expression  <code><i>in</i> &gt;&gt; get_money(mon, intl)</code>
described below behaves as a formatted input function (as
described in 27.6.1.2.1 [istream.formatted.reqmts]).
</p></blockquote>
<p>
Also change p4 of 27.6.4 [ext.manip] as follows:
</p>
<blockquote><p>
<i>Returns</i>: An object <code>s</code> of unspecified type such that
if <code>in</code> is  an object of type <code>basic_istream&lt;charT,
traits&gt;</code>    then    the    expression   <code><i>in</i> &gt;&gt; get_money(mon, intl)</code> behaves as <ins>a formatted input function
that    calls    </ins><code>f(in, mon, intl)</code><del>    were
called</del>. The function <code>f</code> can be defined as...
</p></blockquote>


<p><i>[
post Bellevue:
]</i></p>


<blockquote>
We recommend moving immediately to Review. We've looked at the issue and
have a consensus that the proposed resolution is correct, but want an
iostream expert to sign off. Alisdair has taken the action item to putt
this up on the reflector for possible movement by Howard to Tenatively
Ready.
</blockquote>




<hr>
<h3><a name="696"></a>696. <code>istream::operator&gt;&gt;(int&amp;)</code> broken</h3>
<p><b>Section:</b> 27.6.1.2.2 [istream.formatted.arithmetic] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Martin Sebor <b>Date:</b> 2007-06-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#istream.formatted.arithmetic">issues</a> in [istream.formatted.arithmetic].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
From message c++std-lib-17897:
</p>
<p>
The  code  shown  in  27.6.1.2.2 [istream.formatted.arithmetic] as  the  "as  if"
implementation  of the  two arithmetic  extractors that  don't  have a
corresponding     <code>num_get</code>     interface    (i.e.,     the
<code>short</code> and <code>int</code>  overloads) is subtly buggy in
how  it  deals  with  <code>EOF</code>, overflow,  and  other  similar
conditions (in addition to containing a few typos).
</p>
<p>
One  problem is  that if  <code>num_get::get()</code> reaches  the EOF
after reading in  an otherwise valid value that  exceeds the limits of
the    narrower    type     (but    not    <code>LONG_MIN</code>    or
<code>LONG_MAX</code>),   it  will   set   <code><i>err</i></code>  to
<code>eofbit</code>.   Because   of  the  if   condition  testing  for
<code>(<i>err</i> == 0)</code>,    the   extractor    won't   set
<code>failbit</code>  (and presumably,  return  a bogus  value to  the
caller).
</p>
<p>
Another  problem with  the code  is that  it never  actually  sets the
argument to  the extracted  value. It can't  happen after the  call to
<code>setstate()</code> since  the function may  throw, so we  need to
show when  and how it's done (we  can't just punt as  say: "it happens
afterwards"). However, it  turns out that showing how  it's done isn't
quite so  easy since  the argument is  normally left unchanged  by the
facet on error  except when the error is due  to a misplaced thousands
separator,  which causes  <code>failbit</code> to  be set  but doesn't
prevent the facet from storing the value.
</p>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="698"></a>698. Some system_error issues</h3>
<p><b>Section:</b> 19.4.5.1 [syserr.syserr.overview] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Daniel Krgler <b>Date:</b> 2007-06-24</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 19.4.5.1 [syserr.syserr.overview] we have the class definition of
<tt>std::system_error</tt>. In contrast to all exception classes, which
are constructible with a <tt>what_arg string</tt> (see 19.1 [std.exceptions],
or <tt>ios_base::failure</tt> in 27.4.2.1.1 [ios::failure]), only overloads with with
<tt>const string&amp;</tt> are possible. For consistency with the re-designed
remaining exception classes this class should also provide
c'tors which accept a const <tt>char* what_arg</tt> string.
</p>
<p>
Please note that this proposed addition makes sense even
considering the given implementation hint for <tt>what()</tt>, because
<tt>what_arg</tt> is required to be set as <tt>what_arg</tt> of the base class
<tt>runtime_error</tt>, which now has the additional c'tor overload
accepting a <tt>const char*</tt>.
</p>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="701"></a>701. assoc laguerre poly's</h3>
<p><b>Section:</b> TR1 5.2.1.1 [tr.num.sf.Lnm] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Christopher Crawford <b>Date:</b> 2007-06-30</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I see that the definition the associated Laguerre
polynomials TR1 5.2.1.1 [tr.num.sf.Lnm] has been corrected since
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1687.pdf">N1687</a>.
However, the draft standard only specifies ranks of integer value <tt>m</tt>,
while the associated Laguerre polynomials are actually valid for real
values of <tt>m &gt; -1</tt>.  In the case of non-integer values of <tt>m</tt>, the
definition  <tt><i>L</i><sub>n</sub><sup>(m)</sup> = (1/n!)e<sup>x</sup>x<sup>-m</sup> (d/dx)<sup>n</sup> (e<sup>-x</sup>x<sup>m+n</sup>)</tt>
must be used, which also holds for integer values of <tt>m</tt>.  See
Abramowitz &amp; Stegun, 22.11.6 for the general case, and 22.5.16-17 for
the integer case.  In fact fractional values are most commonly used in
physics, for example to <tt>m = +/- 1/2</tt> to describe the harmonic
oscillator in 1 dimension, and <tt>1/2, 3/2, 5/2, ...</tt> in 3
dimensions.
</p>
<p>
If I am correct, the calculation of the more general case is no
more difficult, and is in fact the function implemented in the GNU
Scientific Library.  I would urge you to consider upgrading the 
standard, either adding extra functions for real <tt>m</tt> or switching the
current ones to <tt>double</tt>.
</p>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="702"></a>702. Restriction in associated Legendre functions</h3>
<p><b>Section:</b> TR1 5.2.1.2 [tr.num.sf.Plm] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Christopher Crawford <b>Date:</b> 2007-06-30</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
One other small thing, in TR1 5.2.1.2 [tr.num.sf.Plm], the restriction should  be
<tt>|x| &lt;= 1</tt>, not <tt>x &gt;= 0</tt>.</p>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="704"></a>704. MoveAssignable requirement for container value type overly strict</h3>
<p><b>Section:</b> 23.1 [container.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Howard Hinnant <b>Date:</b> 2007-05-20</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#container.requirements">active issues</a> in [container.requirements].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#container.requirements">issues</a> in [container.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The move-related changes inadvertently overwrote the intent of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#276">276</a>.
Issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#276">276</a> removed the requirement of <tt>CopyAssignable</tt> from
most of the member functions of node-based containers.  But the move-related changes
unnecessarily introduced the <tt>MoveAssignable</tt> requirement for those members which used to
require <tt>CopyAssignable</tt>.
</p>

<p>
We also discussed (c++std-lib-18722) the possibility of dropping <tt>MoveAssignable</tt>
from some of the sequence requirements.  Additionally the <i>in-place</i> construction
work may further reduce requirements.  For purposes of an easy reference, here are the
minimum sequence requirements as I currently understand them.  Those items in requirements
table in the working draft which do not appear below have been purposefully omitted for
brevity as they do not have any requirements of this nature.  Some items which do not
have any requirements of this nature are included below just to confirm that they were
not omitted by mistake.
</p>

<table border="1">
<caption>Container Requirements</caption>
<tbody><tr><td><tt>X u(a)</tt></td><td><tt>value_type</tt> must be <tt>CopyConstructible</tt></td></tr>
<tr><td><tt>X u(rv)</tt></td><td><tt>array</tt> requires <tt>value_type</tt> to be <tt>MoveConstructible</tt></td></tr>
<tr><td><tt>a = u</tt></td><td>Sequences require <tt>value_type</tt> to be <tt>CopyConstructible</tt> and <tt>CopyAssignable</tt>.
                               Associative containers require <tt>value_type</tt> to be <tt>CopyConstructible</tt>.</td></tr>
<tr><td><tt>a = rv</tt></td><td><tt>array</tt> requires <tt>value_type</tt> to be <tt>MoveAssignable</tt>.
                                Sequences with non-<tt>Swappable</tt> allocators require <tt>value_type</tt> to be <tt>MoveConstructible</tt> and <tt>MoveAssignable</tt>.
                                Associative containers with non-<tt>Swappable</tt> allocators require <tt>value_type</tt> to be <tt>MoveConstructible</tt>.</td></tr>
<tr><td><tt>swap(a,u)</tt></td><td><tt>array</tt> requires <tt>value_type</tt> to be <tt>Swappable</tt>.
                                Sequences with non-<tt>Swappable</tt> allocators require <tt>value_type</tt> to be <tt>Swappable</tt>, <tt>MoveConstructible</tt> and <tt>MoveAssignable</tt>.
                                Associative containers with non-<tt>Swappable</tt> allocators require <tt>value_type</tt> to be <tt>MoveConstructible</tt>.</td></tr>
</tbody></table>

<p>
</p>

<table border="1">
<caption>Sequence Requirements</caption>
<tbody><tr><td><tt>X(n)</tt></td><td><tt>value_type</tt> must be <tt>DefaultConstructible</tt></td></tr>
<tr><td><tt>X(n, t)</tt></td><td><tt>value_type</tt> must be <tt>CopyConstructible</tt></td></tr>
<tr><td><tt>X(i, j)</tt></td><td>If the iterators return an lvalue the <tt>value_type</tt> must be <tt>CopyConstructible</tt>.
                                 If the iterators return an rvalue the <tt>value_type</tt> must be <tt>MoveConstructible</tt>.</td></tr>
<tr><td><tt>a.insert(p, t)</tt></td><td>The <tt>value_type</tt> must be <tt>CopyConstructible</tt>.
                                        The sequences <tt>vector</tt> and <tt>deque</tt> also require the <tt>value_type</tt> to be <tt>CopyAssignable</tt>.</td></tr>
<tr><td><tt>a.insert(p, rv)</tt></td><td>The <tt>value_type</tt> must be <tt>MoveConstructible</tt>.
                                        The sequences <tt>vector</tt> and <tt>deque</tt> also require the <tt>value_type</tt> to be <tt>MoveAssignable</tt>.</td></tr>
<tr><td><tt>a.insert(p, n, t)</tt></td><td>The <tt>value_type</tt> must be <tt>CopyConstructible</tt>.
                                        The sequences <tt>vector</tt> and <tt>deque</tt> also require the <tt>value_type</tt> to be <tt>CopyAssignable</tt>.</td></tr>
<tr><td><tt>a.insert(p, i, j)</tt></td><td>If the iterators return an lvalue the <tt>value_type</tt> must be <tt>CopyConstructible</tt>.
                                        The sequences <tt>vector</tt> and <tt>deque</tt> also require the <tt>value_type</tt> to be <tt>CopyAssignable</tt> when the iterators return an lvalue.
                                        If the iterators return an rvalue the <tt>value_type</tt> must be <tt>MoveConstructible</tt>.
                                        The sequences <tt>vector</tt> and <tt>deque</tt> also require the <tt>value_type</tt> to be <tt>MoveAssignable</tt> when the iterators return an rvalue.</td></tr>
<tr><td><tt>a.erase(p)</tt></td><td>The sequences <tt>vector</tt> and <tt>deque</tt> require the <tt>value_type</tt> to be <tt>MoveAssignable</tt>.</td></tr>
<tr><td><tt>a.erase(q1, q2)</tt></td><td>The sequences <tt>vector</tt> and <tt>deque</tt> require the <tt>value_type</tt> to be <tt>MoveAssignable</tt>.</td></tr>
<tr><td><tt>a.clear()</tt></td><td></td></tr>
<tr><td><tt>a.assign(i, j)</tt></td><td>If the iterators return an lvalue the <tt>value_type</tt> must be <tt>CopyConstructible</tt> and <tt>CopyAssignable</tt>.
                                        If the iterators return an rvalue the <tt>value_type</tt> must be <tt>MoveConstructible</tt> and <tt>MoveAssignable</tt>.</td></tr>
<tr><td><tt>a.assign(n, t)</tt></td><td>The <tt>value_type</tt> must be <tt>CopyConstructible</tt> and <tt>CopyAssignable</tt>.</td></tr>
<tr><td><tt>a.resize(n)</tt></td><td>The <tt>value_type</tt> must be <tt>DefaultConstructible</tt>.
                                     The sequences <tt>vector</tt> and <tt>deque</tt> also require the <tt>value_type</tt> to be <tt>MoveConstructible</tt>.</td></tr>
<tr><td><tt>a.resize(n, t)</tt></td><td>The <tt>value_type</tt> must be <tt>CopyConstructible</tt>.</td></tr>
</tbody></table>

<p>
</p>

<table border="1">
<caption>Optional Sequence Requirements</caption>
<tbody><tr><td><tt>a.front()</tt></td><td></td></tr>
<tr><td><tt>a.back()</tt></td><td></td></tr>
<tr><td><tt>a.push_front(t)</tt></td><td>The <tt>value_type</tt> must be <tt>CopyConstructible</tt>.</td></tr>
<tr><td><tt>a.push_front(rv)</tt></td><td>The <tt>value_type</tt> must be <tt>MoveConstructible</tt>.</td></tr>
<tr><td><tt>a.push_back(t)</tt></td><td>The <tt>value_type</tt> must be <tt>CopyConstructible</tt>.</td></tr>
<tr><td><tt>a.push_back(rv)</tt></td><td>The <tt>value_type</tt> must be <tt>MoveConstructible</tt>.</td></tr>
<tr><td><tt>a.pop_front()</tt></td><td></td></tr>
<tr><td><tt>a.pop_back()</tt></td><td></td></tr>
<tr><td><tt>a[n]</tt></td><td></td></tr>
<tr><td><tt>a.at[n]</tt></td><td></td></tr>
</tbody></table>

<p>
</p>

<table border="1">
<caption>Associative Container Requirements</caption>
<tbody><tr><td><tt>X(i, j)</tt></td><td>If the iterators return an lvalue the <tt>value_type</tt> must be <tt>CopyConstructible</tt>.
                                 If the iterators return an rvalue the <tt>value_type</tt> must be <tt>MoveConstructible</tt>.</td></tr>
<tr><td><tt>a_uniq.insert(t)</tt></td><td>The <tt>value_type</tt> must be <tt>CopyConstructible</tt>.</td></tr>
<tr><td><tt>a_uniq.insert(rv)</tt></td><td>The <tt>key_type</tt> and the <tt>mapped_type</tt> (if it exists) must be <tt>MoveConstructible</tt>.</td></tr>
<tr><td><tt>a_eq.insert(t)</tt></td><td>The <tt>value_type</tt> must be <tt>CopyConstructible</tt>.</td></tr>
<tr><td><tt>a_eq.insert(rv)</tt></td><td>The <tt>key_type</tt> and the <tt>mapped_type</tt> (if it exists) must be <tt>MoveConstructible</tt>.</td></tr>
<tr><td><tt>a.insert(p, t)</tt></td><td>The <tt>value_type</tt> must be <tt>CopyConstructible</tt>.</td></tr>
<tr><td><tt>a.insert(p, rv)</tt></td><td>The <tt>key_type</tt> and the <tt>mapped_type</tt> (if it exists) must be <tt>MoveConstructible</tt>.</td></tr>
<tr><td><tt>a.insert(i, j)</tt></td><td>If the iterators return an lvalue the <tt>value_type</tt> must be <tt>CopyConstructible</tt>.
                                        If the iterators return an rvalue the <tt>key_type</tt> and the <tt>mapped_type</tt> (if it exists) must be <tt>MoveConstructible</tt>..</td></tr>
</tbody></table>

<p>
</p>

<table border="1">
<caption>Unordered Associative Container Requirements</caption>
<tbody><tr><td><tt>X(i, j, n, hf, eq)</tt></td><td>If the iterators return an lvalue the <tt>value_type</tt> must be <tt>CopyConstructible</tt>.
                                 If the iterators return an rvalue the <tt>value_type</tt> must be <tt>MoveConstructible</tt>.</td></tr>
<tr><td><tt>a_uniq.insert(t)</tt></td><td>The <tt>value_type</tt> must be <tt>CopyConstructible</tt>.</td></tr>
<tr><td><tt>a_uniq.insert(rv)</tt></td><td>The <tt>key_type</tt> and the <tt>mapped_type</tt> (if it exists) must be <tt>MoveConstructible</tt>.</td></tr>
<tr><td><tt>a_eq.insert(t)</tt></td><td>The <tt>value_type</tt> must be <tt>CopyConstructible</tt>.</td></tr>
<tr><td><tt>a_eq.insert(rv)</tt></td><td>The <tt>key_type</tt> and the <tt>mapped_type</tt> (if it exists) must be <tt>MoveConstructible</tt>.</td></tr>
<tr><td><tt>a.insert(p, t)</tt></td><td>The <tt>value_type</tt> must be <tt>CopyConstructible</tt>.</td></tr>
<tr><td><tt>a.insert(p, rv)</tt></td><td>The <tt>key_type</tt> and the <tt>mapped_type</tt> (if it exists) must be <tt>MoveConstructible</tt>.</td></tr>
<tr><td><tt>a.insert(i, j)</tt></td><td>If the iterators return an lvalue the <tt>value_type</tt> must be <tt>CopyConstructible</tt>.
                                        If the iterators return an rvalue the <tt>key_type</tt> and the <tt>mapped_type</tt> (if it exists) must be <tt>MoveConstructible</tt>..</td></tr>
</tbody></table>

<p>
</p>

<table border="1">
<caption>Miscellaneous Requirements</caption>
<tbody><tr><td><tt>map[lvalue-key]</tt></td><td>The <tt>key_type</tt> must be <tt>CopyConstructible</tt>.
                                         The <tt>mapped_type</tt> must be <tt>DefaultConstructible</tt> and <tt>MoveConstructible</tt>.</td></tr>
<tr><td><tt>map[rvalue-key]</tt></td><td>The <tt>key_type</tt> must be <tt>MoveConstructible</tt>.
                                         The <tt>mapped_type</tt> must be <tt>DefaultConstructible</tt> and <tt>MoveConstructible</tt>.</td></tr>
</tbody></table>

<p><i>[
Kona (2007): Howard and Alan to update requirements table in issue with emplace signatures.
]</i></p>


<p><i>[
Bellevue: This should be handled as part of the concepts work.
]</i></p>




<p><b>Proposed resolution:</b></p>






<hr>
<h3><a name="708"></a>708. Locales need to be per thread and updated for POSIX changes</h3>
<p><b>Section:</b> 22 [localization] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Peter Dimov <b>Date:</b> 2007-07-28</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#localization">issues</a> in [localization].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The POSIX "Extended API Set Part 4,"
</p>
<blockquote><p>
<a href="http://www.opengroup.org/sib/details.tpl?id=C065">http://www.opengroup.org/sib/details.tpl?id=C065</a>
</p></blockquote>
<p>
introduces extensions to the C locale mechanism that
allow multiple concurrent locales to be used in the same application
by introducing a type <tt>locale_t</tt> that is very similar to
<tt>std::locale</tt>, and a number of <tt>_l</tt> functions that make use of it.
</p>
<p>
The global locale (set by setlocale) is now specified to be per-
process. If a thread does not call <tt>uselocale</tt>, the global locale is
in effect for that thread. It can install a per-thread locale by
using <tt>uselocale</tt>.
</p>
<p>
There is also a nice <tt>querylocale</tt> mechanism by which one can obtain
the name (such as "de_DE") for a specific <tt>facet</tt>, even for combined
locales, with no <tt>std::locale</tt> equivalent.
</p>
<p>
<tt>std::locale</tt> should be harmonized with the new POSIX <tt>locale_t</tt>
mechanism and provide equivalents for <tt>uselocale</tt> and <tt>querylocale</tt>.
</p>

<p><i>[
Kona (2007): Bill and Nick to provide wording.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="710"></a>710. Missing postconditions</h3>
<p><b>Section:</b> 20.6.12.2 [util.smartptr.shared] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Peter Dimov <b>Date:</b> 2007-08-24</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#util.smartptr.shared">active issues</a> in [util.smartptr.shared].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#util.smartptr.shared">issues</a> in [util.smartptr.shared].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
A discussion on
<a href="http://groups.google.com/group/comp.std.c++/browse_frm/thread/8e89dceb35cd7971">comp.std.c++</a>
has identified a contradiction in the <tt>shared_ptr</tt> specification.
The <tt>shared_ptr</tt> move constructor and the cast functions are
missing postconditions for the <tt>get()</tt> accessor.
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
<p>
Move to "ready", adopting the first (Peter's) proposed resolution.
</p>
<p>
Note to the project editor: there is an editorial issue here. The
wording for the postconditions of the casts is slightly awkward, and the
editor should consider rewording "If w is the return value...", e. g. as
"For a return value w...".
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Add to 20.6.12.2.1 [util.smartptr.shared.const]:
</p>

<blockquote>
<pre>shared_ptr(shared_ptr&amp;&amp; r);
template&lt;class Y&gt; shared_ptr(shared_ptr&lt;Y&gt;&amp;&amp; r);
</pre>
<blockquote>
<p>
<i>Postconditions:</i>  <tt>*this</tt> shall contain the old value of <tt>r</tt>. <tt>r</tt>
shall be empty. <ins><tt>r.get() == 0</tt>.</ins>
</p>
</blockquote>
</blockquote>

<p>
Add to 20.6.12.2.10 [util.smartptr.shared.cast]:
</p>

<blockquote>
<pre>template&lt;class T, class U&gt; shared_ptr&lt;T&gt; static_pointer_cast(shared_ptr&lt;U&gt; const&amp; r);
</pre>
<blockquote>
<p>
<ins><i>Postconditions:</i> If <tt>w</tt> is the return value,
<tt>w.get() == static_cast&lt;T*&gt;(r.get()) &amp;&amp; w.use_count() == r.use_count()</tt>.</ins>
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>template&lt;class T, class U&gt; shared_ptr&lt;T&gt; dynamic_pointer_cast(shared_ptr&lt;U&gt; const&amp; r);
</pre>
<blockquote>
<p>
<ins><i>Postconditions:</i> If <tt>w</tt> is the return value, <tt>w.get() == dynamic_cast&lt;T*&gt;(r.get())</tt>.</ins>
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>template&lt;class T, class U&gt; shared_ptr&lt;T&gt; const_pointer_cast(shared_ptr&lt;U&gt; const&amp; r);
</pre>
<blockquote>
<p>
<ins><i>Postconditions:</i> If <tt>w</tt> is the return value,
<tt>w.get() == const_cast&lt;T*&gt;(r.get()) &amp;&amp; w.use_count() == r.use_count()</tt>.</ins>
</p>
</blockquote>
</blockquote>

<p>
Alberto Ganesh Barbati has written an
<a href="http://barbati.net/c++/shared_ptr.pdf">alternative proposal</a>
where he suggests (among other things) that the casts be respecified in terms of
the aliasing constructor as follows:
</p>

<p>
Change 20.6.12.2.10 [util.smartptr.shared.cast]:
</p>

<blockquote>
<p>
-2- <i>Returns:</i> <del>If <tt>r</tt> is empty, an <tt>empty
shared_ptr&lt;T&gt;;</tt> otherwise, a <tt>shared_ptr&lt;T&gt;</tt>
object that stores <tt>static_cast&lt;T*&gt;(r.get())</tt> and shares ownership with
<tt>r</tt>.</del> <ins><tt>shared_ptr&lt;T&gt;(r, static_cast&lt;T*&gt;(r.get())</tt>.</ins>
</p>
</blockquote>

<blockquote>
<p>
-6- <i>Returns:</i>
</p>
<ul>
<li><del>When <tt>dynamic_cast&lt;T*&gt;(r.get())</tt> returns a nonzero value,
a <tt>shared_ptr&lt;T&gt;</tt> object that stores a copy 
of it and <i>shares ownership</i> with <tt>r</tt>;</del></li>
<li><del>Otherwise, an <i>empty</i> <tt>shared_ptr&lt;T&gt;</tt> object.</del></li>
<li><ins>If <tt>p = dynamic_cast&lt;T*&gt;(r.get())</tt> is a non-null pointer, <tt>shared_ptr&lt;T&gt;(r, p);</tt></ins></li>
<li><ins>Otherwise, <tt>shared_ptr&lt;T&gt;()</tt>.</ins></li>
</ul>
</blockquote>

<blockquote>
<p>
-10- <i>Returns:</i> <del>If <tt>r</tt> is empty, an <tt>empty
shared_ptr&lt;T&gt;;</tt> otherwise, a <tt>shared_ptr&lt;T&gt;</tt>
object that stores <tt>const_cast&lt;T*&gt;(r.get())</tt> and shares ownership with
<tt>r</tt>.</del> <ins><tt>shared_ptr&lt;T&gt;(r, const_cast&lt;T*&gt;(r.get())</tt>.</ins>
</p>
</blockquote>

<p>
This takes care of the missing postconditions for the casts by bringing
in the aliasing constructor postcondition "by reference".
</p>






<hr>
<h3><a name="711"></a>711. Contradiction in empty <tt>shared_ptr</tt></h3>
<p><b>Section:</b> 20.6.12.2.5 [util.smartptr.shared.obs] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Review">Review</a>
 <b>Submitter:</b> Peter Dimov <b>Date:</b> 2007-08-24</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#util.smartptr.shared.obs">issues</a> in [util.smartptr.shared.obs].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Review">Review</a> status.</p>
<p><b>Discussion:</b></p>
<p>
A discussion on
<a href="http://groups.google.com/group/comp.std.c++/browse_frm/thread/8e89dceb35cd7971">comp.std.c++</a>
has identified a contradiction in the <tt>shared_ptr</tt> specification.
The note:
</p>

<blockquote><p>
[ <i>Note:</i> this constructor allows creation of an empty shared_ptr instance with a non-NULL stored pointer.
-end note ]
</p></blockquote>

<p>
after the aliasing constructor
</p>

<blockquote><pre>template&lt;class Y&gt; shared_ptr(shared_ptr&lt;Y&gt; const&amp; r, T *p);
</pre></blockquote>

<p>
reflects the intent of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2351.htm">N2351</a>
to, well, allow the creation of an empty <tt>shared_ptr</tt>
with a non-NULL stored pointer.
</p>

<p>
This is contradicted by the second sentence in the Returns clause of 20.6.12.2.5 [util.smartptr.shared.obs]:
</p>

<blockquote>
<pre>T* get() const;
</pre>
<blockquote><p>
<i>Returns:</i> the stored pointer. Returns a null pointer if <tt>*this</tt> is empty.
</p></blockquote>
</blockquote>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
<p>
Adopt option 1 and move to review, not ready.
</p>
<p>
There was a lot of confusion about what an empty <tt>shared_ptr</tt> is (the term
isn't defined anywhere), and whether we have a good mental model for how
one behaves. We think it might be possible to deduce what the definition
should be, but the words just aren't there. We need to open an issue on
the use of this undefined term. (The resolution of that issue might
affect the resolution of issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#711">711</a>.)
</p>
<p>
The LWG is getting more uncomfortable with the aliasing proposal (N2351)
now that we realize some of its implications, and we need to keep an eye
on it, but there isn't support for removing this feature at this time.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
In keeping the N2351 spirit and obviously my preference, change 20.6.12.2.5 [util.smartptr.shared.obs]:
</p>

<blockquote>
<pre>T* get() const;
</pre>
<blockquote><p>
<i>Returns:</i> the stored pointer. <del>Returns a null pointer if <tt>*this</tt> is empty.</del>
</p></blockquote>
</blockquote>

<p>
Alternative proposed resolution: (I won't be happy if we do this, but it's possible):
</p>

<p>
Change 20.6.12.2.1 [util.smartptr.shared.const]:
</p>

<blockquote>
<pre>template&lt;class Y&gt; shared_ptr(shared_ptr&lt;Y&gt; const&amp; r, T *p);
</pre>
<blockquote>
<p>
<ins><i>Requires:</i> If <tt>r</tt> is empty, <tt>p</tt> shall be <tt>0</tt>.</ins>
</p>
<p>
<del>[ <i>Note:</i> this constructor allows creation of an empty <tt>shared_ptr</tt>
instance with a non-NULL stored pointer. 
-- <i>end note</i> ]</del>
</p>
</blockquote>
</blockquote>






<hr>
<h3><a name="713"></a>713. <tt>sort()</tt> complexity is too lax</h3>
<p><b>Section:</b> 25.3.1.1 [sort] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Matt Austern <b>Date:</b> 2007-08-30</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The complexity of <tt>sort()</tt> is specified as "Approximately <tt>N
log(N)</tt> (where <tt>N == last - first</tt> ) comparisons on the
average", with no worst case complicity specified. The intention was to
allow a median-of-three quicksort implementation, which is usually <tt>O(N
log N)</tt> but can be quadratic for pathological inputs. However, there is
no longer any reason to allow implementers the freedom to have a
worst-cast-quadratic sort algorithm. Implementers who want to use
quicksort can use a variant like David Musser's "Introsort" (Software
Practice and Experience 27:983-993, 1997), which is guaranteed to be <tt>O(N
log N)</tt> in the worst case without incurring additional overhead in the
average case. Most C++ library implementers already do this, and there
is no reason not to guarantee it in the standard.
</p>


<p><b>Proposed resolution:</b></p>
<p>
In 25.3.1.1 [sort], change the complexity to "O(N log N)", and remove footnote 266:
</p>

<blockquote>
<p>
<i>Complexity:</i> <del>Approximately</del> <ins>O(</ins><i>N</i> log(<i>N</i>)<ins>)</ins> <del>(where <i>N</i> == <i>last</i> - <i>first</i> )
</del>comparisons<del> on the average</del>.<del><sup>266)</sup></del>
</p>
<p>
<del><sup>266)</sup>
If the worst case behavior is important <tt>stable_sort()</tt> (25.3.1.2) or <tt>partial_sort()</tt>
(25.3.1.3) should be used.</del>
</p>
</blockquote>






<hr>
<h3><a name="714"></a>714. <tt>search_n</tt> complexity is too lax</h3>
<p><b>Section:</b> 25.1.9 [alg.search] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Matt Austern <b>Date:</b> 2007-08-30</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.search">issues</a> in [alg.search].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The complexity for <tt>search_n</tt> (25.1.9 [alg.search] par 7) is specified as "At most
(last - first ) * count applications of the corresponding predicate if
count is positive, or 0 otherwise." This is unnecessarily pessimistic.
Regardless of the value of count, there is no reason to examine any
element in the range more than once.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change the complexity to "At most (last - first) applications of the corresponding predicate".
</p>

<blockquote>
<pre>template&lt;class ForwardIterator, class Size, class T&gt; 
  ForwardIterator 
    search_n(ForwardIterator first , ForwardIterator last , Size count , 
             const T&amp; value ); 

template&lt;class ForwardIterator, class Size, class T, 
         class BinaryPredicate&gt; 
  ForwardIterator 
    search_n(ForwardIterator first , ForwardIterator last , Size count , 
             const T&amp; value , BinaryPredicate pred );
</pre>
<blockquote>
<p>
<i>Complexity:</i> At most <tt>(last - first ) <del>* count</del></tt> applications of the corresponding predicate
<del>if <tt>count</tt> is positive, or 0 otherwise</del>.
</p>
</blockquote>
</blockquote>






<hr>
<h3><a name="715"></a>715. <tt>minmax_element</tt> complexity is too lax</h3>
<p><b>Section:</b> 25.3.7 [alg.min.max] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Matt Austern <b>Date:</b> 2007-08-30</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#alg.min.max">active issues</a> in [alg.min.max].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.min.max">issues</a> in [alg.min.max].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The complexity for <tt>minmax_element</tt> (25.3.7 [alg.min.max] par 16) says "At most <tt>max(2 *
(last - first ) - 2, 0)</tt> applications of the corresponding comparisons",
i.e. the worst case complexity is no better than calling <tt>min_element</tt> and
<tt>max_element</tt> separately. This is gratuitously inefficient. There is a
well known technique that does better: see section 9.1 of CLRS
(Introduction to Algorithms, by Cormen, Leiserson, Rivest, and Stein).
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change 25.3.7 [alg.min.max] to:
</p>

<blockquote>
<pre>template&lt;class ForwardIterator&gt; 
  pair&lt;ForwardIterator, ForwardIterator&gt; 
    minmax_element(ForwardIterator first , ForwardIterator last); 
template&lt;class ForwardIterator, class Compare&gt; 
  pair&lt;ForwardIterator, ForwardIterator&gt; 
    minmax_element(ForwardIterator first , ForwardIterator last , Compare comp);
</pre>
<blockquote>
<p>
<i>Returns:</i> <tt>make_pair(m, M)</tt>, where <tt>m</tt> is
<del><tt>min_element(first, last)</tt> or <tt>min_element(first, last,
comp)</tt></del> <ins>the first iterator in <tt>[first,
last)</tt> such that no iterator in the range refers to a smaller element,</ins> and
<ins>where</ins> <tt>M</tt> is <del><tt>max_element(first, last)</tt> or
<tt>max_element(first, last, comp)</tt></del> <ins>the last iterator
in <tt>[first, last)</tt> such that no iterator in the range refers to a larger element</ins>.
</p>
<p>
<i>Complexity:</i> At most <del><tt>max(2 * (last - first ) - 2, 0)</tt></del>
<ins><tt>max(&#8970;(3/2) (N-1)&#8971;, 0)</tt></ins> applications of the
corresponding <del>comparisons</del> <ins>predicate, where <tt>N</tt> is <tt>distance(first, last)</tt></ins>.
</p>
</blockquote>
</blockquote>






<hr>
<h3><a name="716"></a>716. Production in [re.grammar] not actually modified</h3>
<p><b>Section:</b> 28.13 [re.grammar] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Date:</b> 2007-08-31</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
TR1 7.13 [tr.re.grammar]/3 and C++0x WP 28.13 [re.grammar]/3 say:
</p>

<blockquote>
<p>
The following productions within the ECMAScript grammar are modified as follows:
</p>

<blockquote><pre>CharacterClass ::
[ [lookahead &#8713; {^}] ClassRanges ]
[ ^ ClassRanges ]
</pre></blockquote>

</blockquote>

<p>
This definition for <tt>CharacterClass</tt> appears to be exactly identical to that in ECMA-262.
</p>

<p>
Was an actual modification intended here and accidentally omitted, or was this production accidentally included?
</p>


<p><b>Proposed resolution:</b></p>
<p>
Remove this mention of the CharacterClass production.
</p>

<blockquote><pre><del>CharacterClass ::
[ [lookahead &#8713; {^}] ClassRanges ]
[ ^ ClassRanges ]</del>
</pre></blockquote>






<hr>
<h3><a name="718"></a>718. <tt>basic_string</tt> is not a sequence</h3>
<p><b>Section:</b> 21.3 [basic.string] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Bo Persson <b>Date:</b> 2007-08-18</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#basic.string">active issues</a> in [basic.string].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#basic.string">issues</a> in [basic.string].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Paragraph 21.3 [basic.string]/3 states:
</p>

<blockquote>
<p>
The class template <tt>basic_string</tt> conforms to the requirements for a 
Sequence (23.1.1) and for a Reversible Container (23.1).
</p>
</blockquote>

<p>
First of all, 23.1.1 [sequence.reqmts] is no longer "Sequence" but "Sequence container". 
Secondly, after the resent changes to containers (<tt>emplace</tt>, <tt>push_back</tt>, 
<tt>const_iterator</tt> parameters to <tt>insert</tt> and <tt>erase</tt>), <tt>basic_string</tt> is not 
even close to conform to the current requirements.
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
<ul>
<li>emplace, for example, may not make sense for strings. Is also likely suboptimal</li>
<li>with concepts do we need to maintain string as sequence container?</li>
<li>One approach might be to say something like: string is a sequence except it doesn't have these functions</li>
</ul>
<ul>
<li>basic_string already has push_back</li>
<li>const_iterator parameters to insert and erase should be added to basic_string</li>
<li>this leaves emplace to handle -- we have the following options:
<ul>
<li>option 1: add it to string even though it's optional</li>
<li>option 2: make emplace optional to sequences (move from table 89 to 90)</li>
<li>option 3: say string not sequence (the proposal),</li>
<li>option 4: add an exception to basic string wording.</li>
</ul>
</li>
</ul>
General consensus is to suggest option 2.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Remove this sentence, in recognition of the fact that <tt>basic_string</tt> is 
not just a <tt>vector</tt>-light for literal types, but something quite 
different, a string abstraction in its own right.
</p>





<hr>
<h3><a name="719"></a>719. <tt>std::is_literal</tt> type traits should be provided</h3>
<p><b>Section:</b> 20.4 [meta] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Daniel Krgler <b>Date:</b> 2007-08-25</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#meta">issues</a> in [meta].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Since the inclusion of <tt>constexpr</tt> in the standard draft N2369 we have
a new type category "literal", which is defined in 3.9 [basic.types]/p.11:
</p>

<blockquote>
<p>
-11- A type is a <i>literal</i> type if it is:
</p>
<ul>
<li>a scalar type; or</li>
<li><p>a class type (clause 9) with</p>
<ul>
<li>a trivial copy constructor,</li>
<li>a trivial destructor,</li>
<li>at least one constexpr constructor other than the copy constructor,</li>
<li>no virtual base classes, and</li>
<li>all non-static data members and base classes of literal types; or</li>
</ul>
</li>
<li>an array of literal type.</li>
</ul>
</blockquote>

<p>
I strongly suggest that the standard provides a type traits for
literal types in 20.4.4.3 [meta.unary.prop] for several reasons:
</p>

<ol type="a">
<li>To keep the traits in sync with existing types.</li>
<li>I see many reasons for programmers to use this trait in template
   code to provide optimized template definitions for these types,
   see below.</li>
<li>A user-provided definition of this trait is practically impossible
to write portably.</li>
</ol>

<p>
The special problem of reason (c) is that I don't see currently a
way to portably test the condition for literal class types:
</p>

<blockquote>
<ul>
<li>at least one constexpr constructor other than the copy constructor,</li>
</ul>
</blockquote>

<p>
Here follows a simply example to demonstrate it's usefulness:
</p>

<blockquote><pre>template &lt;typename T&gt;
constexpr typename std::enable_if&lt;std::is_literal&lt;T&gt;::value, T&gt;::type
abs(T x) {
  return x &lt; T() ? -x : x;
}

template &lt;typename T&gt;
typename std::enable_if&lt;!std::is_literal&lt;T&gt;::value, T&gt;::type
abs(const T&amp; x) {
  return x &lt; T() ? -x : x;
}
</pre></blockquote>

<p>
Here we have the possibility to provide a general <tt>abs</tt> function
template that can be used in ICE's if it's argument is a literal
type which's value is a constant expression, otherwise we
have an optimized version for arguments which are expensive
to copy and therefore need the usage of arguments of
reference type (instead of <tt>const T&amp;</tt> we could decide to
use <tt>T&amp;&amp;</tt>, but that is another issue).
</p>

<p><i>[
Alisdair is considering preparing a paper listing a number of missing
type traits, and feels that it might be useful to handle them all
together rather than piecemeal. This would affect issue 719 and 750.
These two issues should move to OPEN pending AM paper on type traits.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
In 20.4.2 [meta.type.synop] in the group "type properties",
just below the line
</p>

<blockquote><pre>template &lt;class T&gt; struct is_pod;
</pre></blockquote>

<p>
add a new one:
</p>

<blockquote><pre>template &lt;class T&gt; struct is_literal;
</pre></blockquote>

<p>
In 20.4.4.3 [meta.unary.prop], table Type Property Predicates, just
below the line for the <tt>is_pod</tt> property add a new line:
</p>

<table border="1">
<tbody><tr>
<th>Template</th><th>Condition</th><th>Preconditions</th>
</tr>
<tr>
<td><tt>template &lt;class T&gt; struct is_literal;</tt></td>
<td><tt>T</tt> is a literal type (3.9)</td>
<td><tt>T</tt> shall be a complete type, an
array of unknown bound, or
(possibly cv-qualified) <tt>void</tt>.</td>
</tr>
</tbody></table>






<hr>
<h3><a name="720"></a>720. Omissions in constexpr usages</h3>
<p><b>Section:</b> 23.2.1 [array], 23.3.5 [template.bitset] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Daniel Krgler <b>Date:</b> 2007-08-25</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#array">active issues</a> in [array].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#array">issues</a> in [array].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<ol>
<li>
The member function <tt>bool array&lt;T,N&gt;::empty() const</tt> should be a
<tt>constexpr</tt> because this is easily to proof and to implement following it's operational
semantics defined by Table 87 (Container requirements) which says: <tt>a.size() == 0</tt>.
</li>
<li>
The member function <tt>bool bitset&lt;N&gt;::test() const</tt> must be a
<tt>constexpr</tt> (otherwise it would violate the specification of <tt>constexpr
bitset&lt;N&gt;::operator[](size_t) const</tt>, because it's return clause delegates to <tt>test()</tt>).
</li>
<li>
I wonder how the constructor <tt>bitset&lt;N&gt;::bitset(unsigned long)</tt> can
be declared as a <tt>constexpr</tt>. Current implementations usually have no such <tt>bitset</tt>
c'tor which would fulfill the requirements of a <tt>constexpr</tt> c'tor because they have a
non-empty c'tor body that typically contains for-loops or <tt>memcpy</tt> to compute the
initialisation. What have I overlooked here?
</li>
</ol>


<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>In the class template definition of 23.2.1 [array]/p. 3 change</p>
<blockquote><pre><ins>constexpr</ins> bool empty() const;
</pre></blockquote>
</li>

<li>
<p>In the class template definition of 23.3.5 [template.bitset]/p. 1 change</p>
<blockquote><pre><ins>constexpr</ins> bool test(size_t pos ) const;
</pre></blockquote>

<p>
and in 23.3.5.2 [bitset.members] change
</p>

<blockquote><pre><ins>constexpr</ins> bool test(size_t pos ) const;
</pre></blockquote>

</li>
</ol>





<hr>
<h3><a name="721"></a>721. <tt>wstring_convert</tt> inconsistensies</h3>
<p><b>Section:</b> 22.1.3.2.2 [conversions.string] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Bo Persson <b>Date:</b> 2007-08-27</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Paragraph 3 says that the <tt>Codecvt</tt> template parameter shall meet the 
requirements of <tt>std::codecvt</tt>, even though <tt>std::codecvt</tt> itself cannot 
be used (because of a protected destructor).
</p>

<p>
How are we going to explain this code to beginning programmers?
</p>

<blockquote><pre>template&lt;class I, class E, class S&gt;
struct codecvt : std::codecvt&lt;I, E, S&gt;
{
    ~codecvt()
    { }
};

void main()
{
    std::wstring_convert&lt;codecvt&lt;wchar_t, char, std::mbstate_t&gt; &gt; compiles_ok;
    
    std::wstring_convert&lt;std::codecvt&lt;wchar_t, char, std::mbstate_t&gt; &gt;   not_ok;
}
</pre></blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="722"></a>722. Missing [c.math] functions <tt>nanf</tt> and <tt>nanl</tt></h3>
<p><b>Section:</b> 26.7 [c.math] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Daniel Krgler <b>Date:</b> 2007-08-27</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#c.math">active issues</a> in [c.math].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#c.math">issues</a> in [c.math].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In the listing of 26.7 [c.math], table 108: Header <tt>&lt;cmath&gt;</tt> synopsis I miss
the following C99 functions (from 7.12.11.2):
</p>

<blockquote><pre>float nanf(const char *tagp);
long double nanl(const char *tagp);
</pre></blockquote>

<p>
(Note: These functions cannot be overloaded and they are also not
listed anywhere else)
</p>


<p><b>Proposed resolution:</b></p>
<p>
In 26.7 [c.math], table 108, section "Functions", add <tt>nanf</tt> and <tt>nanl</tt>
just after the existing entry <tt>nan</tt>.
</p>





<hr>
<h3><a name="723"></a>723. <tt>basic_regex</tt> should be moveable</h3>
<p><b>Section:</b> 28.8 [re.regex] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Daniel Krgler <b>Date:</b> 2007-08-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#re.regex">issues</a> in [re.regex].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
According to the current state of the standard draft, the class
template <tt>basic_regex</tt>, as described in 28.8 [re.regex]/3, is
neither <tt>MoveConstructible</tt> nor <tt>MoveAssignable</tt>.
IMO it should be, because typical regex state machines tend
to have a rather large data quantum and I have seen several
use cases, where a factory function returns regex values,
which would take advantage of moveabilities.
</p>


<p><b>Proposed resolution:</b></p>
<ol type="a">
<li>
<p>
In the header <tt>&lt;regex&gt;</tt> synopsis 28.4 [re.syn], just below the function
template <tt>swap</tt> add two further overloads:
</p>
<blockquote><pre>template &lt;class charT, class traits&gt; 
  void swap(basic_regex&lt;charT, traits&gt;&amp; e1,  basic_regex&lt;charT, traits&gt;&amp; e2);
<ins>template &lt;class charT, class traits&gt;
  void swap(basic_regex&lt;charT, traits&gt;&amp;&amp; e1, basic_regex&lt;charT, traits&gt;&amp; e2);
template &lt;class charT, class traits&gt;
  void swap(basic_regex&lt;charT, traits&gt;&amp; e1,  basic_regex&lt;charT, traits&gt;&amp;&amp; e2);</ins>
</pre></blockquote>
<p>
In the class definition of <tt>basic_regex</tt>, just below 28.8 [re.regex]/3,
perform the following changes:
</p>
</li>

<li>
<p>Just after the copy c'tor:</p>
<blockquote><pre>basic_regex(basic_regex&amp;&amp;);
</pre></blockquote>
</li>

<li>
<p>Just after the copy-assignment op.:</p>
<blockquote><pre>basic_regex&amp; operator=(basic_regex&amp;&amp;);
</pre></blockquote>
</li>

<li>
<p>Just after the first <tt>assign</tt> overload insert:</p>
<blockquote><pre>basic_regex&amp; assign(basic_regex&amp;&amp; that);
</pre></blockquote>
</li>

<li>
<p>Change the current <tt>swap</tt> function to read:</p>
<blockquote><pre>void swap(basic_regex&amp;&amp;);
</pre></blockquote>
</li>

<li>
<p>In 28.8.2 [re.regex.construct], just below the copy c'tor add a
corresponding member definition of:</p>
<blockquote><pre>basic_regex(basic_regex&amp;&amp;);
</pre></blockquote>
</li>

<li>
<p>Also in 28.8.2 [re.regex.construct], just below the copy assignment
c'tor add a corresponding member definition of:</p>
<blockquote><pre>basic_regex&amp; operator=(basic_regex&amp;&amp;);
</pre></blockquote>
</li>

<li>
<p>In 28.8.3 [re.regex.assign], just below the first <tt>assign</tt> overload add
a corresponding member definition of:</p>
<blockquote><pre>basic_regex&amp; assign(basic_regex&amp;&amp; that);
</pre></blockquote>
</li>

<li>
<p>In 28.8.6 [re.regex.swap], change the signature of <tt>swap</tt> to
say:</p>
<blockquote><pre>void swap(basic_regex&amp;&amp; e);
</pre></blockquote>
</li>

<li>
<p>In 28.8.7.1 [re.regex.nmswap], just below the single binary <tt>swap</tt>
function, add the two missing overloads:</p>
<blockquote><pre>template &lt;class charT, class traits&gt;
  void swap(basic_regex&lt;charT, traits&gt;&amp;&amp; e1, basic_regex&lt;charT, traits&gt;&amp; e2);
template &lt;class charT, class traits&gt;
  void swap(basic_regex&lt;charT, traits&gt;&amp; e1, basic_regex&lt;charT, traits&gt;&amp;&amp; e2);
</pre></blockquote>
</li>
</ol>

<p>
Of course there would be need of corresponding proper standardese
to describe these additions.
</p>






<hr>
<h3><a name="724"></a>724. <tt>DefaultConstructible</tt> is not defined</h3>
<p><b>Section:</b> 20.1.1 [utility.arg.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Pablo Halpern <b>Date:</b> 2007-09-12</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#utility.arg.requirements">active issues</a> in [utility.arg.requirements].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#utility.arg.requirements">issues</a> in [utility.arg.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <tt>DefaultConstructible</tt> requirement is referenced in
several places in the August 2007 working draft
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2369.pdf">N2369</a>,
but is not defined anywhere.
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
<p>
Walking into the default/value-initialization mess...
</p>
<p>
Why two lines? Because we need both expressions to be valid.
</p>
<p>
AJM not sure what the phrase "default constructed" means. This is
unfortunate, as the phrase is already used 24 times in the library!
</p>
<p>
Example: const int would not accept first line, but will accept the second.
</p>
<p>
This is an issue that must be solved by concepts, but we might need to solve it independantly first.
</p>
<p>
It seems that the requirements are the syntax in the proposed first
column is valid, but not clear what semantics we need.
</p>
<p>
A table where there is no post-condition seems odd, but appears to sum up our position best.
</p>
<p>
At a minimum an object is declared and is destuctible.
</p>
<p>
Move to open, as no-one happy to produce wording on the fly.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
In section 20.1.1 [utility.arg.requirements], before table 33, add the
following table:
</p>

<p style="text-align: center;" align="center">Table 33: <tt>DefaultConstructible</tt> requirements</p>

<div align="center">

<table style="border-collapse: collapse;" border="0" cellpadding="0" cellspacing="0">
 <tbody><tr>
  <td style="border-style: solid none double solid; border-color: navy -moz-use-text-color navy navy; border-width: 1pt medium 1.5pt 1pt; padding: 0in 5.4pt; width: 85.5pt;" valign="top" width="114">
  <p style="margin: 0in 0in 0.0001pt; text-align: center;" align="center">expression</p>
  </td>
  <td style="border-style: solid solid double none; border-color: navy navy navy -moz-use-text-color; border-width: 1pt 1pt 1.5pt medium; padding: 0in 5.4pt; width: 243pt;" valign="top" width="324">
  <p style="margin: 0in 0in 0.0001pt; text-align: center;" align="center">post-condition</p>
  </td>
 </tr>
 <tr>
  <td style="border-style: none none solid solid; border-color: -moz-use-text-color -moz-use-text-color navy navy; border-width: medium medium 1pt 1pt; padding: 0in 5.4pt; width: 85.5pt;" valign="top" width="114">
  <p style="margin: 0in 0in 0.0001pt;"><tt>T
  t;</tt><br>
  <tt>T()</tt></p>
  </td>
  <td style="border-style: none solid solid none; border-color: -moz-use-text-color navy navy -moz-use-text-color; border-width: medium 1pt 1pt medium; padding: 0in 5.4pt; width: 243pt;" valign="top" width="324">
  <p style="margin: 0in 0in 0.0001pt;"><tt>T</tt>
  is <i>default constructed.</i></p>
  </td>
 </tr>
</tbody></table>

</div>






<hr>
<h3><a name="726"></a>726. Missing <tt>regex_replace()</tt> overloads</h3>
<p><b>Section:</b> 28.11.4 [re.alg.replace] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Date:</b> 2007-09-22</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#re.alg.replace">active issues</a> in [re.alg.replace].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#re.alg.replace">issues</a> in [re.alg.replace].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Two overloads of <tt>regex_replace()</tt> are currently provided:
</p>

<blockquote><pre>template &lt;class OutputIterator, class BidirectionalIterator, 
    class traits, class charT&gt; 
  OutputIterator 
  regex_replace(OutputIterator out, 
                BidirectionalIterator first, BidirectionalIterator last, 
                const basic_regex&lt;charT, traits&gt;&amp; e, 
                const basic_string&lt;charT&gt;&amp; fmt, 
                regex_constants::match_flag_type flags = 
                  regex_constants::match_default);
 
template &lt;class traits, class charT&gt; 
  basic_string&lt;charT&gt; 
  regex_replace(const basic_string&lt;charT&gt;&amp; s, 
                const basic_regex&lt;charT, traits&gt;&amp; e, 
                const basic_string&lt;charT&gt;&amp; fmt, 
                regex_constants::match_flag_type flags = 
                  regex_constants::match_default);
</pre></blockquote>

<ol>
<li>Overloads taking <tt>const charT *</tt> are provided for <tt>regex_match()</tt> and
<tt>regex_search()</tt>, but not <tt>regex_replace()</tt>.  This is inconsistent.</li>
<li>
<p>The absence of <tt>const charT *</tt> overloads prevents ordinary-looking code from compiling, such as:</p>

<blockquote><pre>const string s("kitten");
const regex r("en");
cout &lt;&lt; regex_replace(s, r, "y") &lt;&lt; endl;
</pre></blockquote>

<p>
The compiler error message will be something like "could not deduce
template argument for 'const std::basic_string&lt;_Elem&gt; &amp;' from 'const
char[1]'".
</p>

<p>
Users expect that anything taking a <tt>basic_string&lt;charT&gt;</tt> can also take a
<tt>const charT *</tt>.  In their own code, when they write a function taking
<tt>std::string</tt> (or <tt>std::wstring</tt>), they can pass a <tt>const char *</tt> (or <tt>const
wchar_t *</tt>), thanks to <tt>basic_string</tt>'s implicit constructor.  Because the
regex algorithms are templated on <tt>charT</tt>, they can't rely on
<tt>basic_string</tt>'s implicit constructor (as the compiler error message
indicates, template argument deduction fails first).
</p>

<p>
If a user figures out what the compiler error message means, workarounds
are available - but they are all verbose.  Explicit template arguments
could be given to <tt>regex_replace()</tt>, allowing <tt>basic_string</tt>'s implicit
constructor to be invoked - but <tt>charT</tt> is the last template argument, not
the first, so this would be extremely verbose.  Therefore, constructing
a <tt>basic_string</tt> from each C string is the simplest workaround.
</p>
</li>

<li>
There is an efficiency consideration: constructing <tt>basic_string</tt>s can
impose performance costs that could be avoided by a library
implementation taking C strings and dealing with them directly. 
(Currently, for replacement sources, C strings can be converted into
iterator pairs at the cost of verbosity, but for format strings, there
is no way to avoid constructing a <tt>basic_string</tt>.)
</li>
</ol>



<p><b>Proposed resolution:</b></p>
<p>
Provide additional overloads for <tt>regex_replace()</tt>: one additional
overload of the iterator-based form (taking <tt>const charT* fmt</tt>), and three
additional overloads of the convenience form (one taking <tt>const charT*
str</tt>, another taking <tt>const charT* fmt</tt>, and the third taking both <tt>const
charT* str</tt> and <tt>const charT* fmt</tt>).  28.11.4 [re.alg.replace]:
</p>

<blockquote>
<pre>template &lt;class OutputIterator, class BidirectionalIterator, 
    class traits, class charT&gt; 
  OutputIterator 
  regex_replace(OutputIterator out, 
                BidirectionalIterator first, BidirectionalIterator last, 
                const basic_regex&lt;charT, traits&gt;&amp; e, 
                const basic_string&lt;charT&gt;&amp; fmt, 
                regex_constants::match_flag_type flags = 
                  regex_constants::match_default);

<ins>template &lt;class OutputIterator, class BidirectionalIterator, 
    class traits, class charT&gt; 
  OutputIterator 
  regex_replace(OutputIterator out, 
                BidirectionalIterator first, BidirectionalIterator last, 
                const basic_regex&lt;charT, traits&gt;&amp; e, 
                const charT* fmt, 
                regex_constants::match_flag_type flags = 
                  regex_constants::match_default);</ins>
</pre>
<p>...</p>
<pre>template &lt;class traits, class charT&gt; 
  basic_string&lt;charT&gt; 
  regex_replace(const basic_string&lt;charT&gt;&amp; s, 
                const basic_regex&lt;charT, traits&gt;&amp; e, 
                const basic_string&lt;charT&gt;&amp; fmt, 
                regex_constants::match_flag_type flags = 
                  regex_constants::match_default);

<ins>template &lt;class traits, class charT&gt; 
  basic_string&lt;charT&gt; 
  regex_replace(const basic_string&lt;charT&gt;&amp; s, 
                const basic_regex&lt;charT, traits&gt;&amp; e, 
                const charT* fmt, 
                regex_constants::match_flag_type flags = 
                  regex_constants::match_default);</ins>

<ins>template &lt;class traits, class charT&gt; 
  basic_string&lt;charT&gt; 
  regex_replace(const charT* s, 
                const basic_regex&lt;charT, traits&gt;&amp; e, 
                const basic_string&lt;charT&gt;&amp; fmt, 
                regex_constants::match_flag_type flags = 
                  regex_constants::match_default);</ins>

<ins>template &lt;class traits, class charT&gt; 
  basic_string&lt;charT&gt; 
  regex_replace(const charT* s, 
                const basic_regex&lt;charT, traits&gt;&amp; e, 
                const charT* fmt, 
                regex_constants::match_flag_type flags = 
                  regex_constants::match_default);</ins>
</pre>
</blockquote>






<hr>
<h3><a name="727"></a>727. <tt>regex_replace()</tt> doesn't accept <tt>basic_string</tt>s with custom traits and allocators</h3>
<p><b>Section:</b> 28.11.4 [re.alg.replace] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Date:</b> 2007-09-22</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#re.alg.replace">active issues</a> in [re.alg.replace].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#re.alg.replace">issues</a> in [re.alg.replace].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>regex_match()</tt> and <tt>regex_search()</tt> take <tt>const basic_string&lt;charT, ST,
SA&gt;&amp;</tt>.  <tt>regex_replace()</tt> takes <tt>const basic_string&lt;charT&gt;&amp;</tt>.  This prevents
<tt>regex_replace()</tt> from accepting <tt>basic_string</tt>s with custom traits and
allocators.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Overloads of <tt>regex_replace()</tt> taking <tt>basic_string</tt> should be additionally
templated on <tt>class ST, class SA</tt> and take <tt>const basic_string&lt;charT, ST,
SA&gt;&amp;</tt>.  Consistency with <tt>regex_match()</tt> and <tt>regex_search()</tt> would place
<tt>class ST, class SA</tt> as the first template arguments; compatibility with
existing code using TR1 and giving explicit template arguments to
<tt>regex_replace()</tt> would place <tt>class ST, class SA</tt> as the last template
arguments.
</p>





<hr>
<h3><a name="728"></a>728. Problem in [rand.eng.mers]/6</h3>
<p><b>Section:</b> 26.4.3.2 [rand.eng.mers] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Review">Review</a>
 <b>Submitter:</b> Stephan Tolksdorf <b>Date:</b> 2007-09-21</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.eng.mers">issues</a> in [rand.eng.mers].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Review">Review</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <tt>mersenne_twister_engine</tt> is required to use a seeding method that is given 
as an algorithm parameterized over the number of bits <tt>W</tt>. I doubt whether the given generalization 
of an algorithm that was originally developed only for unsigned 32-bit integers is appropriate 
for other bit widths. For instance, <tt>W</tt> could be theoretically 16 and <tt>UIntType</tt> a 16-bit integer, in 
which case the given multiplier would not fit into the <tt>UIntType</tt>. Moreover, T. Nishimura and M. 
Matsumoto have chosen a dif ferent multiplier for their 64 bit Mersenne Twister
[<a href="http://www.math.sci.hiroshima-u.ac.jp/%7Em-mat/MT/VERSIONS/C-LANG/mt19937-64.c">reference</a>].
</p>

<p>
I see two possible resolutions: 
</p>

<ol type="a">
<li>Restrict the parameter <tt>W</tt> of the <tt>mersenne_twister_template</tt> to values of 32 or 64 and use the 
multiplier from [the above reference] for the 64-bit case (my preference)</li>
<li>Interpret the state array for any <tt>W</tt> as a 32-bit array of appropriate length (and a specified byte 
order) and always employ the 32-bit algorithm for seeding
</li>
</ol>

<p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2424.pdf">N2424</a>
for further discussion.
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
<p>
Stephan Tolksdorf has additional comments on N2424. He comments: "there
is a typo in the required behaviour for mt19937_64: It should be the
10000th (not 100000th) invocation whose value is given, and the value
should be 9981545732273789042 (not 14002232017267485025)." These values
need checking.
</p>
<p>
Take the proposed recommendation in N2424 and move to REVIEW.
</p>
</blockquote>




<p><b>Proposed resolution:</b></p>

<p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2424.pdf">N2424</a>
for the proposed resolution.
</p>

<p><i>[
Stephan Tolksdorf adds pre-Bellevue:
]</i></p>


<blockquote>
I support the proposed resolution in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2424.pdf">N2424</a>,
but there is a typo in the
required behaviour for <tt>mt19937_64</tt>: It should be the 10000<sup>th</sup> (not
100000<sup>th</sup>) invocation whose value is given, and the value should be
9981545732273789042 (not 14002232017267485025). The change to para. 8
proposed by Charles Karney should also be included in the proposed
wording.
</blockquote>






<hr>
<h3><a name="732"></a>732. Defect in [rand.dist.samp.genpdf]</h3>
<p><b>Section:</b> 26.4.8.5.3 [rand.dist.samp.genpdf] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Stephan Tolksdorf <b>Date:</b> 2007-09-21</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.dist.samp.genpdf">issues</a> in [rand.dist.samp.genpdf].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#795">795</a></p>
<p><b>Discussion:</b></p>
<p>
26.4.8.5.3 [rand.dist.samp.genpdf] describes the interface for a distribution template that is 
meant to simulate random numbers from any general distribution given only the density and the 
support of the distribution. I'm not aware of any general purpose algorithm that would be capable 
of correctly and efficiently implementing the described functionality. From what I know, this is 
essentially an unsolved research problem. Existing algorithms either require more knowledge 
about the distribution and the problem domain or work only under very limited circumstances. 
Even the state of the art special purpose library UNU.RAN does not solve the problem in full 
generality, and in any case, testing and customer support for such a library feature would be a 
nightmare.
</p>

<p>
<b>Possible resolution:</b> For these reasons, I propose to delete section 26.4.8.5.3 [rand.dist.samp.genpdf].
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
<p>
Disagreement persists.
</p>
<p>
Objection to this issue is that this function takes a general functor.
The general approach would be to normalize this function, integrate it,
and take the inverse of the integral, which is not possible in general.
An example function is sin(1+n*x) -- for any spatial frequency that the
implementor chooses, there is a value of n that renders that choice
arbitrarily erroneous.
</p>
<p>
Correction: The formula above should instead read 1+sin(n*x).
</p>
<p>
Objector proposes the following possible compromise positions:
</p>
<ul>
<li>
rand.dist.samp.genpdf takes an number of points so that implementor need not guess.
</li>
<li>replace rand.disk.samp.genpdf with an extension to either or both
of the discrete functions to take arguments that take a functor and
number of points in place of the list of probabilities. Reference
issues 793 and 794.
</li>
</ul>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2424.pdf">N2424</a>
for the proposed resolution.
</p>





<hr>
<h3><a name="734"></a>734. Unnecessary restriction in [rand.dist.norm.chisq]</h3>
<p><b>Section:</b> 26.4.8.4.3 [rand.dist.norm.chisq] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Stephan Tolksdorf <b>Date:</b> 2007-09-21</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>chi_squared_distribution</tt>, <tt>fisher_f_distribution</tt> and <tt>student_t_distribution</tt>
have parameters for the "degrees of freedom" <tt>n</tt> and <tt>m</tt> that are specified as integers. For the 
following two reasons this is an unnecessary restriction: First, in many applications such as 
Bayesian inference or Monte Carlo simulations it is more convenient to treat the respective param- 
eters as continuous variables. Second, the standard non-naive algorithms (i.e. 
O(1) algorithms) 
for simulating from these distributions work with floating-point parameters anyway (all three 
distributions could be easily implemented using the Gamma distribution, for instance).
</p>

<p>
Similar arguments could in principle be made for the parameters <tt>t</tt> and <tt>k</tt> of the discrete 
<tt>binomial_distribution</tt> and <tt>negative_binomial_distribution</tt>, though in both cases continuous
parameters are less frequently used in practice and in case of the <tt>binomial_distribution</tt>
the implementation would be significantly complicated by a non-discrete parameter (in most 
implementations one would need an approximation of the log-gamma function instead of just the 
log-factorial function).
</p>

<p>
<b>Possible resolution:</b> For these reasons, I propose to change the type of the respective parameters 
to double.
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
In N2424. Not wildly enthusiastic, not really felt necessary. Less
frequently used in practice. Not terribly bad either. Move to OPEN.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2424.pdf">N2424</a>
for the proposed resolution.
</p>

<p><i>[
Stephan Tolksdorf adds pre-Bellevue:
]</i></p>


<blockquote>
<p>
In 26.4.8.4.3 [rand.dist.norm.chisq]:
</p>

<blockquote>
<p>
Delete ", where <tt>n</tt> is a positive integer" in the first paragraph.
</p>

<p>
Replace both occurrences of "<tt>explicit chi_squared_distribution(int n = 1);</tt>"
with "<tt>explicit chi_squared_distribution(RealType n = 1);</tt>".
</p>

<p>
Replace both occurrences of "<tt>int n() const;</tt>" with "<tt>RealType n() const;</tt>".
</p>

</blockquote>

<p>
In 26.4.8.4.5 [rand.dist.norm.f]:
</p>
<blockquote>
<p>
Delete ", where <tt>m</tt> and <tt>n</tt> are positive integers" in the first paragraph.
</p>

<p>
Replace both occurrences of
</p>
<blockquote><pre>explicit fisher_f_distribution(int m = 1, int n = 1);
</pre></blockquote>
<p>
with
</p>
<blockquote><pre>explicit fisher_f_distribution(RealType m = 1, RealType n = 1);
</pre></blockquote>

<p>
Replace both occurrences of "<tt>int m() const;" with "RealType m() const;</tt>".
</p>

<p>
Replace both occurrences of "<tt>int n() const;" with "RealType n() const;</tt>".
</p>
</blockquote>

<p>
In 26.4.8.4.6 [rand.dist.norm.t]:
</p>

<blockquote>
<p>
Delete ", where <tt>n</tt> is a positive integer" in the first paragraph.
</p>

<p>
Replace both occurrences of "<tt>explicit student_t_distribution(int n = 1);</tt>"
with "<tt>explicit student_t_distribution(RealType n = 1);</tt>".
</p>

<p>
Replace both occurrences of "<tt>int n() const;</tt>" with "<tt>RealType n() const;</tt>".
</p>
</blockquote>

</blockquote>





<hr>
<h3><a name="740"></a>740. Please remove <tt>*_ptr&lt;T[N]&gt;</tt></h3>
<p><b>Section:</b> 20.6.11.4 [unique.ptr.compiletime] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Herb Sutter <b>Date:</b> 2007-10-04</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Please don't provide <tt>*_ptr&lt;T[N]&gt;</tt>. It doesn't enable any useful
bounds-checking (e.g., you could imagine that doing <tt>op++</tt> on a
<tt>shared_ptr&lt;T[N]&gt;</tt> yields a <tt>shared_ptr&lt;T[N-1]&gt;</tt>, but that promising path
immediately falters on <tt>op--</tt> which can't reliably dereference because we
don't know the lower bound). Also, most buffers you'd want to point to
don't have a compile-time known size.
</p>

<p>
To enable any bounds-checking would require run-time information, with
the usual triplet: base (lower bound), current offset, and max offset
(upper  bound). And I can sympathize with the point of view that you
wouldn't want to require this on <tt>*_ptr</tt> itself. But please let's not
follow the <tt>&lt;T[N]&gt;</tt> path, especially not with additional functions to
query the bounds etc., because this sets wrong user expectations by
embarking on a path that doesn't go all the way to bounds checking as it
seems to imply.
</p>

<p>
If bounds checking is desired, consider a <tt>checked_*_ptr</tt> instead (e.g.,
<tt>checked_shared_ptr</tt>). And make the interfaces otherwise identical so that
user code could easily <tt>#define/typedef</tt> between prepending <tt>checked_</tt> on
debug builds and not doing so on release builds (for example).
</p>

<p>
Note that some may object that <tt>checked_*_ptr</tt> may seem to make the smart
pointer more like <tt>vector</tt>, and we don't want two ways to spell <tt>vector</tt>. I
don't agree, but if that were true that would be another reason to
remove <tt>*_ptr&lt;T[N]&gt;</tt> which equally makes the smart pointer more like
<tt>std::array.</tt> :-)
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
<p>Suggestion that fixed-size array instantiations are going to fail at
compile time anyway (if we remove specialization) due to pointer decay,
at least that appears to be result from available compilers.
</p>
<p>
So concerns about about requiring static_assert seem unfounded.
</p>
<p>After a little more experimentation with compiler, it appears that
fixed size arrays would only work at all if we supply these explicit
specialization. So removing them appears less breaking than originally
thought.
</p>
<p>
straw poll unanimous move to Ready.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change the synopsis under 20.6.11 [unique.ptr] p2:
</p>

<blockquote><pre>...
template&lt;class T&gt; struct default_delete; 
template&lt;class T&gt; struct default_delete&lt;T[]&gt;; 
<del>template&lt;class T, size_t N&gt; struct default_delete&lt;T[N]&gt;;</del>

template&lt;class T, class D = default_delete&lt;T&gt;&gt; class unique_ptr; 
template&lt;class T, class D&gt; class unique_ptr&lt;T[], D&gt;; 
<del>template&lt;class T, class D, size_t N&gt; class unique_ptr&lt;T[N], D&gt;;</del>
...
</pre></blockquote>

<p>
Remove the entire section 20.6.11.1.3 [unique.ptr.dltr.dflt2] <b><tt>default_delete&lt;T[N]&gt;</tt></b>.
</p>

<p>
Remove the entire section 20.6.11.4 [unique.ptr.compiletime] <b><tt>unique_ptr</tt> for array objects with a compile time length</b>
and its subsections: 20.6.11.4.1 [unique.ptr.compiletime.dtor], 20.6.11.4.2 [unique.ptr.compiletime.observers],
20.6.11.4.3 [unique.ptr.compiletime.modifiers].
</p>






<hr>
<h3><a name="742"></a>742. Enabling <tt>swap</tt> for proxy iterators</h3>
<p><b>Section:</b> 20.1.1 [utility.arg.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Howard Hinnant <b>Date:</b> 2007-10-10</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#utility.arg.requirements">active issues</a> in [utility.arg.requirements].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#utility.arg.requirements">issues</a> in [utility.arg.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
This issue was split from <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#672">672</a>. <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#672">672</a> now just
deals with changing the requirements of <tt>T</tt> in the <tt>Swappable</tt>
requirement from <tt>CopyConstructible</tt> and <tt>CopyAssignable</tt> to
<tt>MoveConstructible</tt> and <tt>MoveAssignable</tt>.
</p>

<p>
This issue seeks to widen the <tt>Swappable</tt> requirement to support proxy iterators.  Here
is example code:
</p>

<blockquote><pre>namespace Mine {

template &lt;class T&gt;
struct proxy {...};

template &lt;class T&gt;
struct proxied_iterator
{
   typedef T value_type;
   typedef proxy&lt;T&gt; reference;
   reference operator*() const;
   ...
};

struct A
{
   // heavy type, has an optimized swap, maybe isn't even copyable or movable, just swappable
   void swap(A&amp;);
   ...
};

void swap(A&amp;, A&amp;);
void swap(proxy&lt;A&gt;, A&amp;);
void swap(A&amp;, proxy&lt;A&gt;);
void swap(proxy&lt;A&gt;, proxy&lt;A&gt;);

}  // Mine

...

Mine::proxied_iterator&lt;Mine::A&gt; i(...)
Mine::A a;
<b>swap(*i1, a);</b>
</pre></blockquote>

<p>
The key point to note in the above code is that in the call to <tt>swap</tt>, <tt>*i1</tt>
and <tt>a</tt> are different types (currently types can only be <tt>Swappable</tt> with the
same type).  A secondary point is that to support proxies, one must be able to pass rvalues
to <tt>swap</tt>.  But note that I am not stating that the general purpose <tt>std::swap</tt>
should accept rvalues!  Only that overloaded <tt>swap</tt>s, as in the example above, be allowed
to take rvalues.
</p>

<p>
That is, no standard library code needs to change.  We simply need to have a more flexible
definition of <tt>Swappable</tt>.
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
<p>
While we believe Concepts work will define a swappable concept, we
should still resolve this issue if possible to give guidance to the
Concepts work.
</p>
<p>
Would an ambiguous swap function in two namespaces found by ADL break
this wording? Suggest that the phrase "valid expression" means such a
pair of types would still not be swappable.
</p>
<p>
Motivation is proxy-iterators, but facility is considerably more
general. Are we happy going so far?
</p>
<p>
We think this wording is probably correct and probably an improvement on
what's there in the WP. On the other hand, what's already there in the
WP is awfully complicated. Why do we need the two bullet points? They're
too implementation-centric. They don't add anything to the semantics of
what swap() means, which is there in the post-condition. What's wrong
with saying that types are swappable if you can call swap() and it
satisfies the semantics of swapping?
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 20.1.1 [utility.arg.requirements]:
</p>

<blockquote>

<p>
-1- The template definitions in the C++ Standard Library refer to various
named requirements whose details are set out in tables 31-38. In these
tables, <tt>T</tt> <ins>and <tt>V</tt> are</ins> <del>is a</del> type<ins>s</ins> to be supplied by a C++ program
instantiating a template; <tt>a</tt>, <tt>b</tt>, and <tt>c</tt> are
values of type <tt>const T</tt>; <tt>s</tt> and <tt>t</tt> are modifiable
lvalues of type <tt>T</tt>; <tt>u</tt> is a value of type (possibly
<tt>const</tt>) <tt>T</tt>; <del>and</del> <tt>rv</tt> is a non-<tt>const</tt>
rvalue of type <tt>T</tt><ins>; <tt>w</tt> is a value of type <tt>T</tt>; and <tt>v</tt> is a value of type <tt>V</tt></ins>.
</p>

<table border="1">
<caption>Table 37: <tt>Swappable</tt> requirements <b>[swappable]</b></caption>
<tbody><tr><th>expression</th><th>return type</th><th>post-condition</th></tr>
<tr><td><tt>swap(<del>s</del><ins>w</ins>,<del>t</del><ins>v</ins>)</tt></td><td><tt>void</tt></td>
<td><del><tt>t</tt></del><ins><tt>w</tt></ins> has the value originally
held by <del><tt>u</tt></del><ins><tt>v</tt></ins>, and
<del><tt>u</tt></del><ins><tt>v</tt></ins> has the value originally held
by <del><tt>t</tt></del><ins><tt>w</tt></ins></td></tr>
<tr><td colspan="3">
<p>
The <tt>Swappable</tt> requirement is met by satisfying one or more of the following conditions:
</p>
<ul>
<li>
<tt>T</tt> is <tt>Swappable</tt> if <ins><tt>T</tt> and <tt>V</tt> are
the same type and </ins> <tt>T</tt> satisfies the
<del><tt>CopyConstructible</tt></del>
<ins><tt>MoveConstructible</tt></ins> requirements (Table <del>34</del>
<ins>33</ins>) and the <del><tt>CopyAssignable</tt></del>
<ins><tt>MoveAssignable</tt></ins> requirements (Table <del>36</del>
<ins>35</ins>);
</li>
<li>
<tt>T</tt> is <tt>Swappable</tt> <ins>with <tt>V</tt></ins> if a namespace scope function named
<tt>swap</tt> exists in the same namespace as the definition of
<tt>T</tt> <ins>or <tt>V</tt></ins>, such that the expression
<tt>swap(<del>t</del><ins>w</ins>,<del>u</del> <ins>v</ins>)</tt> is valid and has the
semantics described in this table.
</li>
</ul>
</td></tr>
</tbody></table>
</blockquote>






<hr>
<h3><a name="743"></a>743. rvalue <tt>swap</tt> for <tt>shared_ptr</tt></h3>
<p><b>Section:</b> 20.6.12.2.9 [util.smartptr.shared.spec] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Howard Hinnant <b>Date:</b> 2007-10-10</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
When the LWG looked at <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#674">674</a> in Kona the following note was made:
</p>

<blockquote><p>
We may need to open an issue to deal with the question of
whether <tt>shared_ptr</tt> needs an rvalue <tt>swap</tt>.
</p></blockquote>

<p>
This issue was opened in response to that note.
</p>

<p>
I believe allowing rvalue <tt>shared_ptr</tt>s to <tt>swap</tt> is both
appropriate, and consistent with how other library components are currently specified.
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
<p>
Concern that the three signatures for swap is needlessly complicated,
but this issue merely brings shared_ptr into equal complexity with the
rest of the library. Will open a new issue for concern about triplicate
signatures.
</p>
<p>
Adopt issue as written.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change the synopsis in 20.6.12.2 [util.smartptr.shared]:
</p>

<blockquote><pre>void swap(shared_ptr&amp;<ins>&amp;</ins> r);
...
template&lt;class T&gt; void swap(shared_ptr&lt;T&gt;&amp; a, shared_ptr&lt;T&gt;&amp; b);
<ins>template&lt;class T&gt; void swap(shared_ptr&lt;T&gt;&amp;&amp; a, shared_ptr&lt;T&gt;&amp; b);
template&lt;class T&gt; void swap(shared_ptr&lt;T&gt;&amp; a, shared_ptr&lt;T&gt;&amp;&amp; b);</ins>
</pre></blockquote>

<p>
Change 20.6.12.2.4 [util.smartptr.shared.mod]:
</p>

<blockquote><pre>void swap(shared_ptr&amp;<ins>&amp;</ins> r);
</pre></blockquote>

<p>
Change 20.6.12.2.9 [util.smartptr.shared.spec]:
</p>

<blockquote><pre>template&lt;class T&gt; void swap(shared_ptr&lt;T&gt;&amp; a, shared_ptr&lt;T&gt;&amp; b);
<ins>template&lt;class T&gt; void swap(shared_ptr&lt;T&gt;&amp;&amp; a, shared_ptr&lt;T&gt;&amp; b);
template&lt;class T&gt; void swap(shared_ptr&lt;T&gt;&amp; a, shared_ptr&lt;T&gt;&amp;&amp; b);</ins>
</pre></blockquote>





<hr>
<h3><a name="744"></a>744. What is the lifetime of an exception pointed to by an exception_ptr?</h3>
<p><b>Section:</b> 18.7.5 [propagation] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Alisdair Meredith <b>Date:</b> 2007-10-10</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#propagation">active issues</a> in [propagation].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#propagation">issues</a> in [propagation].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Without some lifetime guarantee, it is hard to know how this type can be
used.  Very specifically, I don't see how the current wording would
guarantee and exception_ptr caught at the end of one thread could be safely
stored and rethrown in another thread - the original motivation for this
API.
</p>
<p>
(Peter Dimov agreed it should be clearer, maybe a non-normative note to
explain?)
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
<p>
Agree the issue is real.
</p>
<p>
Intent is lifetime is similar to a shared_ptr (and we might even want to
consider explicitly saying that it is a shared_ptr&lt; unspecified type &gt;).
</p>
<p>
We expect that most implementations will use shared_ptr, and the
standard should be clear that the exception_ptr type is intended to be
something whose semantics are smart-pointer-like so that the user does
not need to worry about lifetime management. We still need someone to
draught those words - suggest emailing Peter Dimov.
</p>
<p>
Move to Open.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 18.7.5 [propagation]/7:
</p>

<blockquote>
-7- Returns: An <tt>exception_ptr</tt> object that refers to the currently
handled exception or a copy of the currently handled exception, or a
null <tt>exception_ptr</tt> object if no exception is being handled.
<ins>The referenced object remains valid at least as long as there is an
<tt>exception_ptr</tt> that refers to it.</ins>
If the function needs to allocate memory and the attempt
fails, it returns an <tt>exception_ptr</tt> object that refers to an instance of
<tt>bad_alloc</tt>. It is unspecified whether the return values of two successive
calls to <tt>current_exception</tt> refer to the same exception object. [<i>Note:</i>
that is, it is unspecified whether <tt>current_exception</tt> creates a new copy
each time it is called. <i>--end note</i>]
</blockquote>





<hr>
<h3><a name="746"></a>746. current_exception may fail with bad_alloc</h3>
<p><b>Section:</b> 18.7.5 [propagation] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Alisdair Meredith <b>Date:</b> 2007-10-10</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#propagation">active issues</a> in [propagation].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#propagation">issues</a> in [propagation].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I understand that the attempt to copy an exception may run out of memory,
but I believe this is the only part of the standard that mandates failure
with specifically <tt>bad_alloc</tt>, as opposed to allowing an
implementation-defined type derived from <tt>bad_alloc</tt>.  For instance, the Core
language for a failed new expression is:
</p>
<blockquote>
<p>
Any other allocation function that fails to allocate storage shall indicate
failure only by throwing an exception of a type that would match a handler
(15.3) of type <tt>std::bad_alloc</tt> (18.5.2.1).
</p>
</blockquote>
<p>
I think we should allow similar freedom here (or add a blanket
compatible-exception freedom paragraph in 17)
</p>
<p>
I prefer the clause 17 approach myself, and maybe clean up any outstanding
wording that could also rely on it.
</p>
<p>
Although filed against a specific case, this issue is a problem throughout
the library. 
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
<p>
Is issue bigger than library?
</p>
<p>
No - Core are already very clear about their wording, which is inspiration for the issue.
</p>
<p>
While not sold on the original 18.7.5 use case, the generalised 17.4.4.8 wording is the real issue.
</p>
<p>
Accept the broad view and move to ready
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Add the following exemption clause to 17.4.4.8 [res.on.exception.handling]:
</p>

<blockquote>
A function may throw a type not listed in its <i>Throws</i> clause so long as it is
derived from a class named in the <i>Throws</i> clause, and would be caught by an
exception handler for the base type.
</blockquote>





<hr>
<h3><a name="747"></a>747. We have 3 separate type traits to identify classes supporting no-throw operations</h3>
<p><b>Section:</b> 20.4.4.3 [meta.unary.prop] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Date:</b> 2007-10-10</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#meta.unary.prop">active issues</a> in [meta.unary.prop].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#meta.unary.prop">issues</a> in [meta.unary.prop].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
We have 3 separate type traits to identify classes supporting no-throw
operations, which are very useful when trying to provide exception safety
guarantees.  However, I'm not entirely clear on what the current wording
requires of a conforming implementation.  To quote from
<tt>has_nothrow_default_constructor</tt>:
</p>
<blockquote><p>
or <tt>T</tt> is a class type with a default constructor that is known not to throw
any exceptions
</p></blockquote>
<p>
What level of magic do we expect to deduce if this is known?
</p>
<p>
E.g.
</p>

<blockquote><pre>struct test{
 int x;
 test() : x() {}
};
</pre></blockquote>
<p>
Should I expect a conforming compiler to 
 <tt>assert( has_nothrow_constructor&lt;test&gt;::value )</tt>
</p>
<p>
Is this a QoI issue?
</p>
<p>
Should I expect to 'know' only if-and-only-if there is an inline definition
available?
</p>
<p>
Should I never expect that to be true, and insist that the user supplies an
empty throw spec if they want to assert the no-throw guarantee?
</p>
<p>
It would be helpful to maybe have a footnote explaining what is required,
but right now I don't know what to suggest putting in the footnote.
</p>
<p>
(agreement since is that trivial ops and explicit no-throws are required.
Open if QoI should be allowed to detect further)
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
This looks like a QoI issue.
In the case of trivial and nothrow it is known. Static analysis of the program is definitely into QoI.
Move to OPEN. Need to talk to Core about this.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="749"></a>749. Currently <tt>has_nothrow_copy_constructor&lt;T&gt;::value</tt> is true if T has 'a' nothrow copy constructor.</h3>
<p><b>Section:</b> 20.4.4.3 [meta.unary.prop] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Alisdair Meredith <b>Date:</b> 2007-10-10</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#meta.unary.prop">active issues</a> in [meta.unary.prop].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#meta.unary.prop">issues</a> in [meta.unary.prop].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Unfortunately a class can have multiple copy constructors, and I believe to
be useful this trait should only return true is ALL copy constructors are
no-throw.
</p>
<p>
For instance:
</p>
<blockquote>
<pre>struct awkward {
 awkward( const awkward &amp; ) throw() {}
 awkward( awkward &amp; ) { throw "oops"; } };
</pre>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 20.4.4.3 [meta.unary.prop]:
</p>

<blockquote>
<pre>has_trivial_copy_constructor</pre>
<blockquote>
<tt>T</tt> is a trivial type (3.9) or a reference type or a class type <del>with a trivial copy constructor</del>
<ins>where all copy constructors are trivial</ins> (12.8).
</blockquote>
</blockquote>

<blockquote>
<pre>has_trivial_assign</pre>
<blockquote>
<tt>T</tt> is neither <tt>const</tt> nor a reference type, and <tt>T</tt> is a trivial type (3.9)
or a class type <del>with a trivial copy assignment operator</del> <ins>where all copy assignment operators are trivial</ins> (12.8).
</blockquote>
</blockquote>

<blockquote>
<pre>has_nothrow_copy_constructor</pre>
<blockquote>
<tt>has_trivial_copy_constructor&lt;T&gt;::value</tt> is <tt>true</tt> or <tt>T</tt> is a class type <del>with
a</del> <ins>where all</ins> copy constructor<ins>s</ins> <del>that is</del> <ins>are</ins> 
known not to throw any exceptions or <tt>T</tt> is an
array of such a class type
</blockquote>
</blockquote>

<blockquote>
<pre>has_nothrow_assign</pre>
<blockquote>
<tt>T</tt> is neither <tt>const</tt> nor a reference type, and
<tt>has_trivial_assign&lt;T&gt;::value</tt> is <tt>true</tt> or <tt>T</tt> is a class type <del>with a</del>
<ins>where all</ins> copy
assignment operator<ins>s</ins> tak<ins>e</ins><del>ing</del> an lvalue of type <tt>T</tt> that is known not to
throw any exceptions or <tt>T</tt> is an array of such a class type.
</blockquote>
</blockquote>






<hr>
<h3><a name="750"></a>750. The current definition for <tt>is_convertible</tt> requires that the type be
implicitly convertible, so explicit constructors are ignored.</h3>
<p><b>Section:</b> 20.4.5 [meta.rel] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Date:</b> 2007-10-10</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
With the pending arrival of explicit conversion functions though, I'm
wondering if we want an additional trait, <tt>is_explictly_convertible</tt>?
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
Alisdair is considering preparing a paper listing a number of missing
type traits, and feels that it might be useful to handle them all
together rather than piecemeal. This would affect issue 719 and 750.
These two issues should move to OPEN pending AM paper on type traits.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="751"></a>751. change pass-by-reference members of <tt>vector&lt;bool&gt;</tt> to pass-by-value?</h3>
<p><b>Section:</b> 23.2.7 [vector.bool] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Alisdair Meredith <b>Date:</b> 2007-10-10</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#vector.bool">active issues</a> in [vector.bool].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#vector.bool">issues</a> in [vector.bool].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
A number of vector&lt;bool&gt; members take const bool&amp; as arguments.
Is there any chance we could change them to pass-by-value or would I 
be wasting everyone's time if wrote up an issue?
</p>

<p><i>[
post Bellevue:
]</i></p>


<blockquote>
<p>
As we understand it, the original requester (Martin Sebor) would like
for implementations to be permitted to pass-by-value. Alisdair suggests
that if this is to be resolved, it should be resolved more generally,
e.g. in other containers as well.
</p>
<p>
We note that this would break ABI. However, we also suspect that this
might be covered under the "as-if" rule in section 1.9.
</p>
<p>
Many in the group feel that for vector&lt;bool&gt;, this is a "don't care",
and that at this point in the process it's not worth the bandwidth.
</p>
<p>
Issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#679">679</a> -- which was in ready status pre-Bellevue and is
now in the working paper -- is related to this, though not a duplicate.
</p>
<p>
Moving to Open with a task for Alisdair to craft a informative note to
be put whereever appropriate in the WP. This note would clarify places
where pass-by-const-ref can be transformed to pass-by-value under the
as-if rule.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="752"></a>752. Allocator complexity requirement</h3>
<p><b>Section:</b> 20.1.2 [allocator.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Hans Boehm <b>Date:</b> 2007-10-11</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#allocator.requirements">active issues</a> in [allocator.requirements].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#allocator.requirements">issues</a> in [allocator.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Did LWG recently discuss 20.1.2 [allocator.requirements]-2, which states that "All the operations
on the allocators are expected to be amortized constant time."?
</p>
<p>
As I think I pointed out earlier, this is currently fiction for
<tt>allocate()</tt> if it has to obtain memory from the OS, and it's unclear to
me how to interpret this for <tt>construct()</tt> and <tt>destroy()</tt> if they deal with
large objects. &nbsp;Would it be controversial to officially let these take
time linear in the size of the object, as they already do in real life?
</p>
<p>
<tt>Allocate()</tt> more blatantly takes time proportional to the size of the
object if you mix in GC. &nbsp;But it's not really a new problem, and I think
we'd be confusing things by leaving the bogus requirements there. &nbsp;The
current requirement on <tt>allocate()</tt> is generally not important anyway,
since it takes O(size) to construct objects in the resulting space.
There are real performance issues here, but they're all concerned with
the constants, not the asymptotic complexity.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change 20.1.2 [allocator.requirements]/2:
</p>

<blockquote>
<p>
-2- Table 39 describes the requirements on types manipulated through
allocators. All the operations on the allocators are expected to be
amortized constant time<ins>, except that <tt>allocate</tt> and
<tt>construct</tt> may require time proportional to the size of the
object allocated or constructed</ins>. Table 40 describes the
requirements on allocator types.
</p>
</blockquote>





<hr>
<h3><a name="753"></a>753. Move constructor in draft</h3>
<p><b>Section:</b> 20.1.1 [utility.arg.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Yechezkel Mett <b>Date:</b> 2007-10-14</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#utility.arg.requirements">active issues</a> in [utility.arg.requirements].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#utility.arg.requirements">issues</a> in [utility.arg.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The draft standard n2369 uses the term <i>move constructor</i> in a few
places, but doesn't seem to define it.
</p>

<p>
<tt>MoveConstructible</tt> requirements are defined in Table 33 in 20.1.1 [utility.arg.requirements] as
follows:
</p>

<blockquote>
<table border="1">
<caption><tt>MoveConstructible</tt> requirements</caption>
<tbody><tr>
<th>expression</th> <th>post-condition</th>
</tr>
<tr>
<td><tt>T t = rv</tt></td> <td><tt>t</tt> is equivalent to the value of <tt>rv</tt> before the construction</td>
</tr>
<tr>
<td colspan="2">[<i>Note:</i> There is no requirement on the value of <tt>rv</tt> after the 
construction. <i>-- end note</i>]</td>
</tr>
</tbody></table>
</blockquote>

<p>
(where <tt>rv</tt> is a non-const rvalue of type <tt>T</tt>).
</p>

<p>
So I assume the move constructor is the constructor that would be used
in filling the above requirement.
</p>

<p>
For <tt>vector::reserve</tt>, <tt>vector::resize</tt> and the <tt>vector</tt> modifiers given in
23.2.6.4 [vector.modifiers] we have
</p>

<blockquote>
<i>Requires:</i> If <tt>value_type</tt> has a move constructor, that constructor shall
not throw any exceptions.
</blockquote>

<p>
Firstly "If <tt>value_type</tt> has a move constructor" is superfluous; every
type which can be put into a <tt>vector</tt> has a move constructor (a copy
constructor is also a move constructor). Secondly it means that for
any <tt>value_type</tt> which has a throwing copy constructor and no other move
constructor these functions cannot be used -- which I think will come
as a shock to people who have been using such types in <tt>vector</tt> until
now!
</p>

<p>
I can see two ways to correct this. The simpler, which is presumably
what was intended, is to say "If <tt>value_type</tt> has a move constructor and
no copy constructor, the move constructor shall not throw any
exceptions" or "If <tt>value_type</tt> has a move constructor which changes the
value of its parameter,".
</p>

<p>
The other alternative is add to <tt>MoveConstructible</tt> the requirement that
the expression does not throw. This would mean that not every type
that satisfies the <tt>CopyConstructible</tt> requirements also satisfies the
<tt>MoveConstructible</tt> requirements. It would mean changing requirements in
various places in the draft to allow either <tt>MoveConstructible</tt> or
<tt>CopyConstructible</tt>, but I think the result would be clearer and
possibly more concise too.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add new defintions to 17.1 [definitions]:
</p>

<blockquote>
<p>
<b>move constructor</b>
</p>
<p>
a constructor which accepts only rvalue arguments of that type, and modifies the rvalue as a
side effect during the construction.
</p>
<p>
<b>move assignment operator</b>
</p>
<p>
an assignment operator which accepts only rvalue arguments of that type, and modifies the rvalue as a
side effect during the assignment.
</p>
<p>
<b>move assignment</b>
</p>
<p>
use of the move assignment operator.
</p>
</blockquote>

<p><i>[
Howard adds post-Bellevue:
]</i></p>


<blockquote>
<p>
Unfortunately I believe the wording recommended by the LWG in Bellevue is incorrect.  <tt>reserve</tt> et. al. will use a move constructor
if one is available, else it will use a copy constructor.  A type may have both.  If the move constructor is
used, it must not throw.  If the copy constructor is used, it can throw.  The sentence in the proposed wording
is correct without the recommended insertion.  The Bellevue LWG recommended moving this issue to Ready.  I am
unfortunately pulling it back to Open.  But I'm drafting wording to atone for this egregious action. :-)
</p>
</blockquote>






<hr>
<h3><a name="755"></a>755. <tt>std::vector</tt> and <tt>std:string</tt> lack explicit shrink-to-fit operations</h3>
<p><b>Section:</b> 23.2.6.2 [vector.capacity], 21.3.4 [string.capacity] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Beman Dawes <b>Date:</b> 2007-10-31</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#vector.capacity">issues</a> in [vector.capacity].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
A <tt>std::vector</tt> can be shrunk-to-fit via the swap idiom:
</p>

<blockquote><pre>vector&lt;int&gt; v;
...
v.swap(vector&lt;int&gt;(v));  // shrink to fit
</pre>
<blockquote><p>
or:
</p></blockquote>
<pre>vector&lt;int&gt;(v).swap(v);  // shrink to fit
</pre>
<blockquote><p>
or:
</p></blockquote>
<pre>swap(v, vector&lt;int&gt;(v));  // shrink to fit
</pre>
</blockquote>

<p>
A non-binding request for shrink-to-fit can be made to a <tt>std::string</tt> via:
</p>

<blockquote><pre>string s;
...
s.reserve(0);
</pre></blockquote>

<p>
Neither of these is at all obvious to beginners, and even some
experienced C++ programmers are not aware that shrink-to-fit is
trivially available.
</p>
<p>
Lack of explicit functions to perform these commonly requested
operations makes vector and string less usable for non-experts. Because
the idioms are somewhat obscure, code readability is impaired. It is
also unfortunate that two similar vector-like containers use different
syntax for the same operation.
</p>
<p>
The proposed resolution addresses these concerns. The proposed function
takes no arguments to keep the solution simple and focused.
</p>


<p><b>Proposed resolution:</b></p>
<p>
To Class template basic_string 21.3 [basic.string] synopsis,
Class template vector 23.2.6 [vector] synopsis, and Class
vector&lt;bool&gt; 23.2.7 [vector.bool] synopsis, add:
</p>

<blockquote><pre>    
void shrink_to_fit();
</pre></blockquote>

<p>
To basic_string capacity 21.3.4 [string.capacity] and vector
capacity 23.2.6.2 [vector.capacity], add:
</p>

<blockquote>
<pre>void shrink_to_fit();
</pre>
<blockquote>
<i>Remarks:</i> <tt>shrink_to_fit</tt> is a non-binding request to reduce
<tt>capacity()</tt> to <tt>size()</tt>. [<i>Note:</i> The request is non-binding to
allow latitude for implementation-specific optimizations.
<i>-- end note</i>]
</blockquote>
</blockquote>





<hr>
<h3><a name="756"></a>756. Container adaptors push</h3>
<p><b>Section:</b> 23.2.5 [container.adaptors] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Paolo Carlini <b>Date:</b> 2007-10-31</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
After n2369 we have a single <tt>push_back</tt> overload in the sequence containers,
of the "emplace" type. At variance with that, still in n2461, we have
two separate overloads, the C++03 one + one taking an rvalue reference
in the container adaptors. Therefore, simply from a consistency point of
view, I was wondering whether the container adaptors should be aligned
with the specifications of the sequence container themselves: thus have
a single <tt>push</tt> along the lines:
</p>

<blockquote><pre>template&lt;typename... _Args&gt;
void
push(_Args&amp;&amp;... __args)
  { c.push_back(std::forward&lt;_Args&gt;(__args)...); }
</pre></blockquote>

<p><i>[
Related to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#767">767</a>
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
Change 23.2.5.1.1 [queue.defn]:
</p>

<blockquote><pre><del>void push(const value_type&amp; x) { c.push_back(x); }</del>
<del>void push(value_type&amp;&amp; x) { c.push_back(std::move(x)); }</del>
<ins>template&lt;class... Args&gt; void push(Args&amp;&amp;... args) { c.push_back(std::forward&lt;Args&gt;(args)...); }</ins>
</pre></blockquote>

<p>
Change 23.2.5.2 [priority.queue]:
</p>

<blockquote><pre><del>void push(const value_type&amp; x) { c.push_back(x); }</del>
<del>void push(value_type&amp;&amp; x) { c.push_back(std::move(x)); }</del>
<ins>template&lt;class... Args&gt; void push(Args&amp;&amp;... args) { c.push_back(std::forward&lt;Args&gt;(args)...); }</ins>
</pre></blockquote>

<p>
Change 23.2.5.2.2 [priqueue.members]:
</p>

<blockquote>
<pre><del>void push(const value_type&amp; x);</del>
</pre>
<blockquote>
<p>
<del><i>Effects:</i></del>
</p>
<blockquote><pre><del>c.push_back(x);</del>
<del>push_heap(c.begin(), c.end(), comp);</del>
</pre></blockquote>
</blockquote>

<pre><ins>template&lt;class... Args&gt;</ins> void push(<del>value_type</del> <ins>Args</ins>&amp;&amp;<ins>...</ins> <del>x</del> <ins>args</ins>);
</pre>
<blockquote>
<p>
<i>Effects:</i>
</p>
<blockquote><pre>c.push_back(std::<del>move</del><ins>forward&lt;Args&gt;</ins>(<del>x</del> <ins>args</ins>)<ins>...</ins>);
push_heap(c.begin(), c.end(), comp);
</pre></blockquote>
</blockquote>
</blockquote>

<p>
Change 23.2.5.3.1 [stack.defn]:
</p>

<blockquote><pre><del>void push(const value_type&amp; x) { c.push_back(x); }</del>
<del>void push(value_type&amp;&amp; x) { c.push_back(std::move(x)); }</del>
<ins>template&lt;class... Args&gt; void push(Args&amp;&amp;... args) { c.push_back(std::forward&lt;Args&gt;(args)...); }</ins>
</pre></blockquote>






<hr>
<h3><a name="758"></a>758. <tt>shared_ptr</tt> and <tt>nullptr</tt></h3>
<p><b>Section:</b> 20.6.12.2 [util.smartptr.shared] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Joe Gottman <b>Date:</b> 2007-10-31</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#util.smartptr.shared">active issues</a> in [util.smartptr.shared].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#util.smartptr.shared">issues</a> in [util.smartptr.shared].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Consider the following program:
</p>

<blockquote><pre>int main() {
   shared_ptr&lt;int&gt; p(nullptr); 
   return 0;
}
</pre></blockquote>

<p>
This program will fail to compile because <tt>shared_ptr</tt> uses the following 
template constructor to construct itself from pointers:
</p>

<blockquote><pre>template &lt;class Y&gt; shared_ptr(Y *);
</pre></blockquote>

<p>
According
to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2431.pdf">N2431</a>,
the conversion from <tt>nullptr_t</tt> to <tt>Y *</tt> is not
deducible, so the above constructor will not be found.  There are similar problems with the
constructors that take a pointer and a <tt>deleter</tt> or a
pointer, a <tt>deleter</tt> and an allocator, as well as the
corresponding forms of <tt>reset()</tt>. Note that <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2435.htm">N2435</a>
will solve this problem for constructing from just <tt>nullptr</tt>, but not for constructors that use
<tt>deleters</tt> or allocators or for <tt>reset()</tt>.
</p>

<p>
In the case of the functions that take deleters, there is the additional
question of what argument should be passed to the deleter when it is
eventually called.  There are two reasonable possibilities: <tt>nullptr</tt> or
<tt>static_cast&lt;T *&gt;(0)</tt>, where <tt>T</tt> is the template argument of the
<tt>shared_ptr</tt>.  It is not immediately clear which of these is better.  If
<tt>D::operator()</tt> is a template function similar to <tt>shared_ptr</tt>'s
constructor, then <tt>d(static_cast&lt;T*&gt;(0))</tt> will compile and <tt>d(nullptr)</tt>
will not.  On the other hand, if <tt>D::operator()()</tt> takes a parameter that
is a pointer to some type other that <tt>T</tt> (for instance <tt>U*</tt> where <tt>U</tt> derives
from <tt>T</tt>) then <tt>d(nullptr)</tt> will compile and <tt>d(static_cast&lt;T *&gt;(0))</tt> may not.
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
<p>
The general idea is right, we need to be able to pass a nullptr to a
shared_ptr, but there are a few borderline editorial issues here. (For
example, the single-argument nullptr_t constructor in the class synopsis
isn't marked explicit, but it is marked explicit in the proposed wording
for 20.6.6.2.1. There is a missing empty parenthesis in the form that
takes a nullptr_t, a deleter, and an allocator.)
</p>
<p>
More seriously: this issue says that a shared_ptr constructed from a
nullptr is empty. Since "empty" is undefined, it's hard to know whether
that's right. This issue is pending on handling that term better.
</p>
<p>
Peter suggests definition of empty should be "does not own anything"
</p>
<p>
Is there an editorial issue that post-conditions should refer to get() =
nullptr, rather than get() = 0?
</p>
<p>
No strong feeling towards accept or NAD, but prefer to make a decision than leave it open.
</p>
<p>
Seems there are no technical merits between NAD and Ready, comes down to
"Do we intentially want to allow/disallow null pointers with these
functions". Staw Poll - support null pointers 5 - No null pointers 0
</p>
<p>
Move to Ready, modulo editorial comments
</p>
</blockquote>

<p><i>[
post Bellevue Peter adds:
]</i></p>


<blockquote>
<p>
The following wording changes are less intrusive:
</p>

<p>
In 20.6.12.2.1 [util.smartptr.shared.const], add:
</p>

<blockquote><pre>shared_ptr(nullptr_t);
</pre></blockquote>

<p>
after:
</p>

<blockquote><pre>shared_ptr();
</pre></blockquote>

<p>
(Absence of explicit intentional.)
</p>

<p>
<tt>px.reset( nullptr )</tt> seems a somewhat contrived way to write <tt>px.reset()</tt>, so
I'm not convinced of its utility.
</p>
<p>
It's similarly not clear to me whether the deleter constructors need to be
extended to take <tt>nullptr</tt>, but if they need to:
</p>
<p>
Add
</p>

<blockquote><pre>template&lt;class D&gt; shared_ptr(nullptr_t p, D d);
template&lt;class D, class A&gt; shared_ptr(nullptr_t p, D d, A a);
</pre></blockquote>

<p>
after
</p>

<blockquote><pre>template&lt;class Y, class D&gt; shared_ptr(Y* p, D d);
template&lt;class Y, class D, class A&gt; shared_ptr(Y* p, D d, A a);
</pre></blockquote>

<p>
Note that this changes the semantics of the new constructors such that they
consistently call <tt>d(p)</tt> instead of <tt>d((T*)0)</tt> when <tt>p</tt> is <tt>nullptr</tt>.
</p>
<p>
The ability to be able to pass <tt>0/NULL</tt> to a function that takes a <tt>shared_ptr</tt>
has repeatedly been requested by users, but the other additions that the
proposed resolution makes are not supported by real world demand or
motivating examples.
</p>
<p>
It might be useful to split the obvious and non-controversial <tt>nullptr_t</tt>
constructor into a separate issue. Waiting for "empty" to be clarified is
unnecessary; this is effectively an alias for the default constructor.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add the following constructors to 20.6.12.2 [util.smartptr.shared]:
</p>

<blockquote><pre>shared_ptr(nullptr_t);
template &lt;class D&gt; shared_ptr(nullptr_t, D d);
template &lt;class D, class A&gt; shared_ptr(nullptr_t, D d, A a);
</pre></blockquote>

<p>
Add the following methods to 20.6.12.2 [util.smartptr.shared]:
</p>

<blockquote><pre>void reset(nullptr_t);
template &lt;class D&gt; void reset(nullptr_t, D d);
template &lt;class D, class A&gt; void reset(nullptr_t, D d, A a);
</pre></blockquote>

<p>
Add the following constructor definitions to 20.6.12.2.1 [util.smartptr.shared.const]:
</p>

<blockquote>
<pre> explicit shared_ptr(nullptr_t);
</pre>
<blockquote>
<p>
<i>Effects:</i> Constructs an empty shared_ptr object.
</p>
<p>
<i>Postconditions:</i> <tt>use_count() == 0 &amp;&amp; get() == 0</tt>.
</p>
<p>
<i>Throws:</i> nothing.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>template &lt;class D&gt; shared_ptr(nullptr_t, D d);
template &lt;class D, class A&gt; shared_ptr&lt;nullptr_t, D d, A a);
</pre>
<blockquote>
<p>
<i>Requires:</i> <tt>D</tt> shall be <tt>CopyConstructible</tt>. The copy constructor and
destructor of <tt>D</tt> shall not throw exceptions. The expression
<tt>d(static_cast&lt;T *&gt;(0))</tt> shall be well-formed, shall have well defined behavior,
and shall not throw exceptions. <tt>A</tt> shall be an allocator (20.1.2 [allocator.requirements]).
The copy constructor and destructor of <tt>A</tt> shall not throw
exceptions.
</p>
<p>
<i>Effects:</i> Constructs a <tt>shared_ptr</tt> object that owns a null pointer of type <tt>T *</tt>
and  deleter <tt>d</tt>.  The
second constructor shall use a copy of <tt>a</tt> to allocate memory for
internal use.
</p>
<p>
<i>Postconditions:</i> <tt>use_count() == 1</tt> and <tt>get() == 0</tt>.
</p>
<p>
<i>Throws:</i> <tt>bad_alloc</tt>, or an implementation-defined exception when a
resource other than memory could not be obtained.
</p>
<p>
<i>Exception safety:</i> If an exception is thrown, <tt>d(static_cast&lt;Y *&gt;(nullptr))</tt> is called.
</p>
</blockquote>
</blockquote>

<p>
Add the following method definitions to 20.6.12.2.4 [util.smartptr.shared.mod]:
</p>

<blockquote>
<pre>void reset(nullptr_t);
</pre>
<blockquote>
<p>
<i>Effects:</i> Equivalent to <tt>shared_ptr(nullptr).swap(*this)</tt>.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>template &lt;class D&gt; void reset(nullptr_t, const D d)
</pre>
<blockquote>
<p>
<i>Effects:</i> Equivalent to <tt>shared_ptr(nullptr, d).swap(*this)</tt>.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>template &lt;class D, class A&gt; void reset(nullptr_t, D d, A a);
</pre>
<blockquote>
<p>
<i>Effects:</i> Equivalent to <tt>shared_ptr(nullptr, d, a).swap(*this)</tt>.
</p>
</blockquote>
</blockquote>






<hr>
<h3><a name="759"></a>759. A reference is not an object</h3>
<p><b>Section:</b> 23.1 [container.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Jens Maurer <b>Date:</b> 2007-11-06</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#container.requirements">active issues</a> in [container.requirements].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#container.requirements">issues</a> in [container.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
23.1 [container.requirements] says:
</p>

<blockquote>
-12- Objects passed to member functions of a container as rvalue references shall not be elements of that container. No 
diagnostic required.
</blockquote>

<p>
A reference is not an object, but this sentence appears to claim so.
</p>

<p>
What is probably meant here:
</p>
<blockquote>
An object bound to an rvalue
reference parameter of a member function of a container shall not be
an element of that container; no diagnostic required.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 23.1 [container.requirements]:
</p>

<blockquote>
-12- <del>Objects passed to member functions of a container as rvalue references shall not be elements</del>
<ins>An object bound to an rvalue
reference parameter of a member function of a container shall not be
an element</ins>
of that container<del>.</del><ins>;</ins> <del>N</del><ins>n</ins>o 
diagnostic required.
</blockquote>






<hr>
<h3><a name="760"></a>760. The emplace issue</h3>
<p><b>Section:</b> 23.1 [container.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Paolo Carlini <b>Date:</b> 2007-11-11</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#container.requirements">active issues</a> in [container.requirements].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#container.requirements">issues</a> in [container.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In an emplace member function the function parameter pack may be bound
to a priori unlimited number of objects: some or all of them can be
elements of the container itself. Apparently, in order to conform to the
blanket statement 23.1 [container.requirements]/11, the implementation must check all of them for
that possibility. A possible solution can involve extending the
exception in 23.1 [container.requirements]/12 also to the emplace member. As a side note, the
<tt>push_back</tt> and <tt>push_front</tt> member functions are luckily not affected by
this problem, can be efficiently implemented anyway
</p>

<p><i>[
Related to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#767">767</a>
]</i></p>


<p><i>[
Bellevue:
]</i></p>


<blockquote>
<p>
The proposed addition (13) is partially redundant with the existing
paragraph 12. Why was the qualifier "rvalues" added to paragraph 12? Why
does it not cover subelements and pointers?
</p>
<p>
Resolution: Alan Talbot to rework language, then set state to Review.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add after 23.1 [container.requirements]/12:
</p>

<blockquote>
<p>
-12- Objects passed to member functions of a container as rvalue references shall not be elements of that container. No 
diagnostic required.
</p>
<p>
<ins>
-13- Objects bound to the function parameter pack of the <tt>emplace</tt> member function shall not be elements or
sub-objects of elements of the container. No diagnostic required.
</ins>
</p>

</blockquote>






<hr>
<h3><a name="761"></a>761. <tt>unordered_map</tt> needs an <tt>at()</tt> member function</h3>
<p><b>Section:</b> 23.4.1.2 [unord.map.elem] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Joe Gottman <b>Date:</b> 2007-11-15</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The new member function <tt>at()</tt> was recently added to <tt>std::map()</tt>.  It acts 
like <tt>operator[]()</tt>, except it throws an exception when the input key is 
not found.  It is useful when the <tt>map</tt> is <tt>const</tt>, the <tt>value_type</tt> of the 
key doesn't have  a default constructor, it is an error if the key is 
not found, or the user wants to avoid accidentally adding an element to 
the map.  For exactly these same reasons, <tt>at()</tt> would be equally useful 
in <tt>std::unordered_map</tt>.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add the following functions to the definition of <tt>unordered_map</tt> under "lookup" (23.4.1 [unord.map]):
</p>

<blockquote><pre>mapped_type&amp; at(const key_type&amp; k);
const mapped_type &amp;at(const key_type &amp;k) const;
</pre></blockquote>

<p>
Add the following definitions to 23.4.1.2 [unord.map.elem]:
</p>

<blockquote>
<pre>mapped_type&amp; at(const key_type&amp; k);
const mapped_type &amp;at(const key_type &amp;k) const;
</pre>
<blockquote>
<p>
<i>Returns:</i> A reference to <tt>x.second</tt>, where <tt>x</tt> is the (unique) element 
whose key is equivalent to <tt>k</tt>.
</p>
<p>
<i>Throws:</i> An exception object of type <tt>out_of_range</tt> if no such element 
is present.
</p>
</blockquote>
</blockquote>

<p><i>[
Bellevue:  Editorial note: the "(unique)" differs from map.
]</i></p>







<hr>
<h3><a name="762"></a>762. <tt>std::unique_ptr</tt> requires complete type?</h3>
<p><b>Section:</b> 20.6.11 [unique.ptr] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Daniel Krgler <b>Date:</b> 2007-11-30</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#unique.ptr">active issues</a> in [unique.ptr].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#unique.ptr">issues</a> in [unique.ptr].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In contrast to the proposed <tt>std::shared_ptr</tt>, <tt>std::unique_ptr</tt>
does currently not support incomplete types, because it
gives no explicit grant - thus instantiating <tt>unique_ptr</tt> with
an incomplete pointee type <tt>T</tt> automatically belongs to
undefined behaviour according to 17.4.3.7 [res.on.functions]/2, last
bullet. This is an unnecessary restriction and prevents
many well-established patterns - like the bridge pattern -
for <tt>std::unique_ptr</tt>.
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
Move to open. The LWG is comfortable with the intent of allowing
incomplete types and making <tt>unique_ptr</tt> more like <tt>shared_ptr</tt>, but we are
not comfortable with the wording. The specification for <tt>unique_ptr</tt>
should be more like that of <tt>shared_ptr</tt>. We need to know, for individual
member functions, which ones require their types to be complete. The
<tt>shared_ptr</tt> specification is careful to say that for each function, and
we need the same level of care here. We also aren't comfortable with the
"part of the operational semantic" language; it's not used elsewhere in
the standard, and it's not clear what it means. We need a volunteer to
produce new wording.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
The proposed changes in the following revision refers to the current state of
N2521 including the assumption that 20.6.11.4 [unique.ptr.compiletime] will be removed
according to the current state of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#740">740</a>.
</p>
<p>
The specialization <tt>unique_ptr&lt;T[]&gt;</tt> has some more restrictive constraints on
type-completeness on <tt>T</tt> than <tt>unique_ptr&lt;T&gt;</tt>. The following proposed wordings
try to cope with that. If the committee sees less usefulness on relaxed
constraints on <tt>unique_ptr&lt;T[]&gt;</tt>, the alternative would be to stop this relaxation
e.g. by adding one further bullet to 20.6.11.3 [unique.ptr.runtime]/1:
"<tt>T</tt> shall be a complete type, if used as template argument of
<tt>unique_ptr&lt;T[], D&gt;</tt>
</p>
<p>
This issue has some overlap with <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#673">673</a>, but it seems not to cause any
problems with this one,
because <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#673">673</a> adds only optional requirements on <tt>D</tt> that do not conflict
with the here discussed
ones, provided that <tt>D::pointer</tt>'s operations (including default
construction, copy construction/assignment,
and pointer conversion) are specified <em>not</em> to throw, otherwise this
would have impact on the
current specification of <tt>unique_ptr</tt>.
</p>

<ol>
<li>
<p>
In 20.6.11 [unique.ptr]/2 add as the last sentence to the existing para:
</p>

<blockquote>
The <tt>unique_ptr</tt> provides a semantics of strict ownership. A
<tt>unique_ptr</tt> owns the object it holds a pointer to. A
<tt>unique_ptr</tt> is not <tt>CopyConstructible</tt>, nor
<tt>CopyAssignable</tt>, however it is <tt>MoveConstructible</tt> and
<tt>MoveAssignable</tt>. <ins>The template parameter <tt>T</tt> of
<tt>unique_ptr</tt> may be an incomplete type.</ins> [ <i>Note:</i> The
uses of <tt>unique_ptr</tt> include providing exception safety for
dynamically allcoated memory, passing ownership of dynamically allocated
memory to a function, and returning dynamically allocated memory from a
function. -- <i>end note</i> ]
</blockquote>
</li>

<li>
<p>
20.6.11.2.1 [unique.ptr.single.ctor]/1: No changes necessary.
</p>

<blockquote>
<p><i>[
N.B.: We only need the requirement that <tt>D</tt> is <tt>DefaultConstructible</tt>.
The current wording says just this.
]</i></p>

</blockquote>
</li>

<li>
<p>
In 20.6.11.2.1 [unique.ptr.single.ctor]/5 change the requires clause to say:
</p>

<blockquote>
<p>
<i>Requires:</i> <del>The expression <tt>D()(p)</tt> shall be well formed. The default constructor
of <tt>D</tt> shall not throw an exception.</del>
<tt>D</tt> <del>must</del> <ins>shall</ins> not be a reference type.
<ins>
<tt>D</tt> shall be default constructible, and that construction
shall not throw an exception.
</ins>
</p>
<p><i>[
N.B.: There is no need that the expression <tt>D()(p)</tt> is well-formed at
this point. I assume that the current wording is based on the
corresponding <tt>shared_ptr</tt> wording. In case of <tt>shared_ptr</tt> this
requirement is necessary, because the corresponding c'tor *can* fail
and must invoke delete <tt>p/d(p)</tt> in this case. <tt>Unique_ptr</tt> is simpler in
this regard. The *only* functions that must insist on well-formedness
and well-definedness of the expression <tt>get_deleter()(get())</tt> are (1)
the destructor and (2) <tt>reset</tt>. The reasoning for the wording change to
explicitly require <tt>DefaultConstructible</tt> of <tt>D</tt> is to guarantee that
invocation of
<tt>D</tt>'s default c'tor is both well-formed and well-defined. Note also that
we do *not* need the
requirement that <tt>T</tt> must be complete, also in contrast to <tt>shared_ptr</tt>.
<tt>Shared_ptr</tt> needs this, because it's c'tor is a template c'tor which
potentially requires <tt>Convertible&lt;Y*, X*&gt;</tt>, which
again requires Completeness of <tt>Y</tt>, if <tt>!SameType&lt;X, Y&gt;</tt>
]</i></p>

</blockquote>
</li>

<li>
<p>
Merge 20.6.11.2.1 [unique.ptr.single.ctor]/12+13 thereby removing the sentence
of 12, but transferring the "requires" to 13:
</p>

<blockquote>
<p>
<i>Requires:</i> If <tt>D</tt> is not an lvalue-reference type then[..]
</p>
<p><i>[
N.B.: For the same reasons as for (3), there is no need that <tt>d(p)</tt> is
well-formed/well-defined at this point. The current wording guarantees
all what we need, namely that the initialization of both the <tt>T*</tt>
pointer and the <tt>D</tt> deleter are well-formed and well-defined.
]</i></p>

</blockquote>
</li>

<li>
20.6.11.2.1 [unique.ptr.single.ctor]/17: No changes necessary.
</li>
<li>
<p>20.6.11.2.1 [unique.ptr.single.ctor]/21: No changes necessary.</p>

<p><i>[
N.B.: The current wording of 21 already implicitly guarantees that <tt>U</tt>
is completely defined, because it requires that <tt>Convertible&lt;U*, T*&gt;</tt> is
true. If the committee wishes this explicit requirement can be added,
e.g. "<tt>U</tt> shall be a complete type."
]</i></p>

</li>

<li>
<p>
20.6.11.2.2 [unique.ptr.single.dtor]: Just before p1 add a new paragraph:
</p>
<blockquote>
<p>
<i>Requires:</i> The expression <tt>get_deleter()(get())</tt> shall be well-formed,
shall have well-defined behavior, and shall not throw exceptions.
</p>
<p><i>[
N.B.: This requirement ensures that the whole responsibility on
type-completeness of <tt>T</tt> is delegated to this expression.
]</i></p>

</blockquote>
</li>

<li>
<p>
20.6.11.2.3 [unique.ptr.single.asgn]/1: No changes necessary, except the
current editorial issue, that "must shall" has to be changed to
"shall", but this change is not a special part of this resolution.
</p>

<p><i>[
N.B. The current wording is sufficient, because we can delegate all
further requirements on the requirements of the effects clause
]</i></p>

</li>

<li>
<p>
20.6.11.2.3 [unique.ptr.single.asgn]/6: No changes necessary.
</p>
<p><i>[
N.B.: The current wording of p. 6 already implicitly guarantees that
<tt>U</tt> is completely defined, because it requires that <tt>Convertible&lt;U*, T*&gt;</tt>
is true, see (6)+(8).
]</i></p>

</li>

<li>
<p>
20.6.11.2.3 [unique.ptr.single.asgn]/11: No changes necessary.
</p>
<p><i>[
N.B.: Delegation to requirements of effects clause is sufficient.
]</i></p>

</li>

<li>
20.6.11.2.4 [unique.ptr.single.observers]/1+4+7+9+11: No changes necessary.
</li>

<li>
20.6.11.2.5 [unique.ptr.single.modifiers]/1: No changes necessary.
</li>

<li>
<p>
20.6.11.2.5 [unique.ptr.single.modifiers]/4: Just before p. 4 add a new paragraph:
</p>
<blockquote>
<i>Requires:</i> The expression <tt>get_deleter()(get())</tt> shall be well-formed,
shall have well-defined behavior, and shall not throw exceptions.
</blockquote>
</li>

<li>
20.6.11.2.5 [unique.ptr.single.modifiers]/7: No changes necessary.
</li>

<li>
<p>
20.6.11.3.1 [unique.ptr.runtime.ctor]: Add one additional paragraph just
before the current one:
</p>

<blockquote>
<p>
<i>Requires:</i> <tt>T</tt> shall be a complete type.
</p>
<p><i>[
N.B.: We need this requirement, because otherwise it is not
guaranteed that the c'tors can fulfill their requirements to reject
any type that is convertible to <tt>T*</tt>.
]</i></p>

</blockquote>
</li>

<li>
20.6.11.3.2 [unique.ptr.runtime.observers]/1: Change the clause to says:
</li>

<blockquote>
<i>Requires:</i> <tt>i &lt;</tt> the size of the array to which the stored pointer
points. <tt>T</tt> shall be a complete type.
</blockquote>

<li>
<p>
20.6.11.3.3 [unique.ptr.runtime.modifiers]/1: Change the first sentence of the
paragraph to say:
</p>
<blockquote>
<p>
<i>Requires:</i> <tt>T</tt> shall be a complete type. Does not accept pointer types
which are convertible to <tt>T*</tt> (diagnostic required). [ Note: ...]
</p>
<p><i>[
N.B. Similar to (15) we need this requirement such that <tt>reset</tt> can
reject types which are convertible to <tt>T*</tt>
]</i></p>

</blockquote>

</li>
</ol>

<p><i>[
post Bellevue: Daniel provided revised wording.
]</i></p>







<hr>
<h3><a name="765"></a>765. more on iterator validity</h3>
<p><b>Section:</b> 24.1 [iterator.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Martin Sebor <b>Date:</b> 2007-12-14</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#iterator.requirements">active issues</a> in [iterator.requirements].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#iterator.requirements">issues</a> in [iterator.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
       <p>

Issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#278">278</a>
defines the meaning of the term "invalid iterator" as one that may be
singular.

       </p>
       <p>

Consider the following code:

       </p>
       <pre>   std::deque&lt;int&gt; x, y;
   std::deque&lt;int&gt;::iterator i = x.end(), j = y.end();
   x.swap(y);
       </pre>
       <p>

Given that <code>swap()</code> is required not to invalidate iterators
and using the definition above, what should be the expected result of
comparing <code>i</code> and <code>j</code> to <code>x.end()</code>
and <code>y.end()</code>, respectively, after the <code>swap()</code>?

       </p>
       <p>

I.e., is the expression below required to evaluate
to <code>true</code>?

       </p>
       <pre>   i == y.end() &amp;&amp; j == x.end()
       </pre>
       <p>

(There are at least two implementations where the expression
returns <code>false</code>.)

       </p>
       <p>

More generally, is the definition introduced in issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#278">278</a> meant to
make any guarantees about whether iterators actually point to the same
elements or be associated with the same containers after a
non-invalidating operation as they did before?

       </p>
       <p>

Here's a motivating example intended to demonstrate the importance of
the question:

       </p>
       <pre>   Container x, y ({ 1, 2});   // pseudocode to initialize y with { 1, 2 }
   Container::iterator i = y.begin() + 1;
   Container::iterator j = y.end();
   std::swap(x, y);
   std::find(i, j, 3);
       </pre>
       <p>

<code>swap()</code> guarantees that <code>i</code> and <code>j</code>
continue to be valid. Unless the spec says that even though they are
valid they may no longer denote a valid range the code above must be
well-defined. Expert opinions on this differ as does the behavior of
popular implementations for some standard <code>Containers</code>.

       </p>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="766"></a>766. Inconsistent exception guarantees between ordered and unordered associative containers</h3>
<p><b>Section:</b> 23.1 [container.requirements], 23.1.3.1 [unord.req.except] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Ion Gaztaaga <b>Date:</b> 2007-12-22</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#container.requirements">active issues</a> in [container.requirements].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#container.requirements">issues</a> in [container.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
23.1 [container.requirements]p10 states:
</p>

<blockquote>
<p>
Unless otherwise specified (see 23.2.2.3 and 23.2.5.4) all container types defined in this clause meet the following
additional requirements:
</p>
<ul>

<li>[...]</li>

<li>no <tt>erase()</tt>, <tt>pop_back()</tt> or <tt>pop_front()</tt> function throws an exception.</li>

</ul>
</blockquote>

<p>
23.2.2.3 [deque.modifiers] and 23.2.6.4 [vector.modifiers] offer
additional guarantees for <tt>deque</tt>/<tt>vector insert()</tt> and
<tt>erase()</tt> members. However, 23.1 [container.requirements]p10
does not mention 23.1.3.1 [unord.req.except] that specifies exception
safety guarantees
for unordered containers. In addition, 23.1.3.1 [unord.req.except]p1
offers the following guaratee for
<tt>erase()</tt>:
</p>

<blockquote>
No <tt>erase()</tt> function throws an exception unless that exception
is thrown by the container's Hash or Pred object (if any).
</blockquote>

<p>
Summary:
</p>

<p>
According to 23.1 [container.requirements]p10 no
<tt>erase()</tt> function should throw an exception unless otherwise
specified. Although does not explicitly mention 23.1.3.1 [unord.req.except], this section offers additional guarantees
for unordered containers, allowing <tt>erase()</tt> to throw if
predicate or hash function throws.
</p>

<p>
In contrast, associative containers have no exception safety guarantees
section so no <tt>erase()</tt> function should throw, <em>including
<tt>erase(k)</tt></em> that needs to use the predicate function to
perform its work. This means that the predicate of an associative
container is not allowed to throw.
</p>

<p>
So:
</p>

<ol>
<li>
<tt>erase(k)</tt> for associative containers is not allowed to throw. On
the other hand, <tt>erase(k)</tt> for unordered associative containers
is allowed to throw.
</li>
<li>
<tt>erase(q)</tt> for associative containers is not allowed to throw. On
the other hand, <tt>erase(q)</tt> for unordered associative containers
is allowed to throw if it uses the hash or predicate.
</li>
<li>
To fulfill 1), predicates of associative containers are not allowed to throw.
Predicates of unordered associative containers are allowed to throw.
</li>
<li>
2) breaks a widely used programming pattern (flyweight pattern) for
unordered containers, where objects are registered in a global map in
their constructors and unregistered in their destructors. If <tt>erase(q)</tt> is
allowed to throw, the destructor of the object would need to rethrow the
exception or swallow it, leaving the object registered.
</li>
</ol>


<p><b>Proposed resolution:</b></p>
<p>
Create a new sub-section of 23.1.2 [associative.reqmts] (perhaps [associative.req.except]) titled "Exception
safety guarantees".
</p>

<blockquote>
<p>
1 For associative containers, no <tt>clear()</tt> function throws an exception.
<tt>erase(k)</tt> does not throw an exception unless that exception is thrown by
the container's Pred object (if any).
</p>

<p>
2 For associative containers, if an exception is thrown by any operation
from within an <tt>insert()</tt> function inserting a single element, the
<tt>insert()</tt> function has no effect.
</p>

<p>
3 For associative containers, no <tt>swap</tt> function throws an exception
unless that exception is thrown by the copy constructor or copy
assignment operator of the container's Pred object (if any).
</p>
</blockquote>

<p>
Change 23.1.3.1 [unord.req.except]p1:
</p>

<blockquote>
For unordered associative containers, no <tt>clear()</tt> function
throws an exception. <del>No</del> <tt>erase(<ins>k</ins>)</tt>
<del>function</del> <ins>does not</ins> throw<del>s</del> an exception
unless that exception is thrown by the container's Hash or Pred object
(if any).
</blockquote>

<p>
Change 23.1 [container.requirements]p10 to add references to new sections:
</p>

<blockquote>
Unless otherwise specified (see [deque.modifiers]<ins>,</ins>
<del>and</del> [vector.modifiers]<ins>, [associative.req.except],
[unord.req.except]</ins>) all container types defined in this clause meet
the following additional requirements:
</blockquote>

<p>
Change 23.1 [container.requirements]p10 referring to <tt>swap</tt>:
</p>

<blockquote>
<ul>
<li>
no <tt>swap()</tt> function throws an exception<del> unless that exception is thrown
by the copy constructor or assignment operator of the container's
Compare object (if any; see [associative.reqmts])</del>.
</li>
</ul>
</blockquote>






<hr>
<h3><a name="767"></a>767. Forwarding and backward compatibility</h3>
<p><b>Section:</b> 23 [containers] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Sylvain Pion <b>Date:</b> 2007-12-28</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#containers">active issues</a> in [containers].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#containers">issues</a> in [containers].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Playing with g++'s C++0X mode, I noticed that the following
code, which used to compile:
</p>

<blockquote><pre>#include &lt;vector&gt;

int main()
{
    std::vector&lt;char *&gt; v;
    v.push_back(0);
}
</pre></blockquote>

<p>
now fails with the following error message:
</p>

<blockquote>.../include/c++/4.3.0/ext/new_allocator.h: In member
function 'void __gnu_cxx::new_allocator&lt;_Tp&gt;::construct(_Tp*,
_Args&amp;&amp; ...) [with _Args = int, _Tp = char*]':
.../include/c++/4.3.0/bits/stl_vector.h:707: instantiated from 'void
std::vector&lt;_Tp, _Alloc&gt;::push_back(_Args&amp;&amp; ...) [with
_Args = int, _Tp = char*, _Alloc = std::allocator&lt;char*&gt;]'
test.cpp:6: instantiated from here
.../include/c++/4.3.0/ext/new_allocator.h:114: error: invalid
conversion from 'int' to 'char*'
</blockquote>

<p>
As far as I know, g++ follows the current draft here.
</p>
<p>
Does the committee really intend to break compatibility for such cases?
</p>

<p><i>[
Sylvain adds: 
]</i></p>


<blockquote>
<p>
I just noticed that <tt>std::pair</tt> has the same issue.
The following now fails with GCC's -std=c++0x mode:
</p>

<blockquote><pre>#include &lt;utility&gt;

int main()
{
   std::pair&lt;char *, char *&gt; p (0,0);
}
</pre></blockquote>

<p>
I have not made any general audit for such problems elsewhere.
</p>
</blockquote>

<p><i>[
Related to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#756">756</a>
]</i></p>


<p><i>[
Bellevue:
]</i></p>


<blockquote>
<p>
Motivation is to handle the old-style int-zero-valued NULL pointers.
Problem: this solution requires concepts in some cases, which some users
will be slow to adopt. Some discussion of alternatives involving
prohibiting variadic forms and additional library-implementation
complexity.
</p>
<p>
Discussion of "perfect world" solutions, the only such solution put
forward being to retroactively prohibit use of the integer zero for a
NULL pointer. This approach was deemed unacceptable given the large
bodies of pre-existing code that do use integer zero for a NULL pointer.
</p>
<p>
Another approach is to change the member names. Yet another approach is
to forbid the extension in absence of concepts.
</p>
<p>
Resolution: These issues (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#756">756</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#767">767</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#760">760</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#763">763</a>) will be subsumed into a
paper to be produced by Alan Talbot in time for review at the 2008
meeting in France. Once this paper is produced, these issues will be
moved to NAD.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add the following rows to Table 90 "Optional sequence container operations", 23.1.1 [sequence.reqmts]:
</p>

<blockquote>
<table border="1">
<tbody><tr>
<th>expression</th> <th>return type</th> <th>assertion/note<br>pre-/post-condition</th> <th>container</th>
</tr>

<tr>
<td>
<tt>a.push_front(t)</tt>
</td>
<td>
<tt>void</tt>
</td>
<td>
<tt>a.insert(a.begin(), t)</tt><br>
<i>Requires:</i> <tt>T</tt> shall be <tt>CopyConstructible</tt>.
</td>
<td>
<tt>list, deque</tt>
</td>
</tr>

<tr>
<td>
<tt>a.push_front(rv)</tt>
</td>
<td>
<tt>void</tt>
</td>
<td>
<tt>a.insert(a.begin(), rv)</tt><br>
<i>Requires:</i> <tt>T</tt> shall be <tt>MoveConstructible</tt>.
</td>
<td>
<tt>list, deque</tt>
</td>
</tr>

<tr>
<td>
<tt>a.push_back(t)</tt>
</td>
<td>
<tt>void</tt>
</td>
<td>
<tt>a.insert(a.end(), t)</tt><br>
<i>Requires:</i> <tt>T</tt> shall be <tt>CopyConstructible</tt>.
</td>
<td>
<tt>list, deque, vector, basic_string</tt>
</td>
</tr>

<tr>
<td>
<tt>a.push_back(rv)</tt>
</td>
<td>
<tt>void</tt>
</td>
<td>
<tt>a.insert(a.end(), rv)</tt><br>
<i>Requires:</i> <tt>T</tt> shall be <tt>MoveConstructible</tt>.
</td>
<td>
<tt>list, deque, vector, basic_string</tt>
</td>
</tr>

</tbody></table>
</blockquote>

<p>
Change the synopsis in 23.2.2 [deque]:
</p>

<blockquote><pre><ins>void push_front(const T&amp; x);</ins>
<ins>void push_front(T&amp;&amp; x);</ins>
<ins>void push_back(const T&amp; x);</ins>
<ins>void push_back(T&amp;&amp; x);</ins>
template &lt;class... Args&gt; <ins>requires Constructible&lt;T, Args&amp;&amp;...&gt;</ins> void push_front(Args&amp;&amp;... args);
template &lt;class... Args&gt; <ins>requires Constructible&lt;T, Args&amp;&amp;...&gt;</ins> void push_back(Args&amp;&amp;... args);
</pre></blockquote>

<p>
Change 23.2.2.3 [deque.modifiers]:
</p>

<blockquote><pre><ins>void push_front(const T&amp; x);</ins>
<ins>void push_front(T&amp;&amp; x);</ins>
<ins>void push_back(const T&amp; x);</ins>
<ins>void push_back(T&amp;&amp; x);</ins>
template &lt;class... Args&gt; <ins>requires Constructible&lt;T, Args&amp;&amp;...&gt;</ins> void push_front(Args&amp;&amp;... args);
template &lt;class... Args&gt; <ins>requires Constructible&lt;T, Args&amp;&amp;...&gt;</ins> void push_back(Args&amp;&amp;... args);
</pre></blockquote>

<p>
Change the synopsis in 23.2.4 [list]:
</p>

<blockquote><pre><ins>void push_front(const T&amp; x);</ins>
<ins>void push_front(T&amp;&amp; x);</ins>
<ins>void push_back(const T&amp; x);</ins>
<ins>void push_back(T&amp;&amp; x);</ins>
template &lt;class... Args&gt; <ins>requires Constructible&lt;T, Args&amp;&amp;...&gt;</ins> void push_front(Args&amp;&amp;... args);
template &lt;class... Args&gt; <ins>requires Constructible&lt;T, Args&amp;&amp;...&gt;</ins> void push_back(Args&amp;&amp;... args);
</pre></blockquote>

<p>
Change 23.2.4.3 [list.modifiers]:
</p>

<blockquote><pre><ins>void push_front(const T&amp; x);</ins>
<ins>void push_front(T&amp;&amp; x);</ins>
<ins>void push_back(const T&amp; x);</ins>
<ins>void push_back(T&amp;&amp; x);</ins>
template &lt;class... Args&gt; <ins>requires Constructible&lt;T, Args&amp;&amp;...&gt;</ins> void push_front(Args&amp;&amp;... args);
template &lt;class... Args&gt; <ins>requires Constructible&lt;T, Args&amp;&amp;...&gt;</ins> void push_back(Args&amp;&amp;... args);
</pre></blockquote>

<p>
Change the synopsis in 23.2.6 [vector]:
</p>

<blockquote><pre><ins>void push_back(const T&amp; x);</ins>
<ins>void push_back(T&amp;&amp; x);</ins>
template &lt;class... Args&gt; <ins>requires Constructible&lt;T, Args&amp;&amp;...&gt;</ins> void push_back(Args&amp;&amp;... args);
</pre></blockquote>

<p>
Change 23.2.6.4 [vector.modifiers]:
</p>

<blockquote><pre><ins>void push_back(const T&amp; x);</ins>
<ins>void push_back(T&amp;&amp; x);</ins>
template &lt;class... Args&gt; <ins>requires Constructible&lt;T, Args&amp;&amp;...&gt;</ins> void push_back(Args&amp;&amp;... args);
</pre></blockquote>







<hr>
<h3><a name="768"></a>768. Typos in [atomics]?</h3>
<p><b>Section:</b> 29.4.3 [atomics.types.generic] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Alberto Ganesh Barbati <b>Date:</b> 2007-12-28</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
in the latest publicly available draft, paper
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2461.pdf">N2641</a>,
in section 29.4.3 [atomics.types.generic], the following specialization of the template
<tt>atomic&lt;&gt;</tt> is provided for pointers:
</p>

<blockquote><pre>template &lt;class T&gt; struct atomic&lt;T*&gt; : atomic_address { 
  T* fetch_add(ptrdiff_t, memory_order = memory_order_seq_cst) volatile; 
  T* fetch_sub(ptrdiff_t, memory_order = memory_order_seq_cst) volatile; 

  atomic() = default; 
  constexpr explicit atomic(T); 
  atomic(const atomic&amp;) = delete; 
  atomic&amp; operator=(const atomic&amp;) = delete; 

  T* operator=(T*) volatile; 
  T* operator++(int) volatile; 
  T* operator--(int) volatile; 
  T* operator++() volatile; 
  T* operator--() volatile; 
  T* operator+=(ptrdiff_t) volatile;
  T* operator-=(ptrdiff_t) volatile; 
};
</pre></blockquote>

<p>
First of all, there is a typo in the non-default constructor which
should take a <tt>T*</tt> rather than a <tt>T</tt>.
</p>

<p>
As you can see, the specialization redefine and therefore hide a few
methods from the base class <tt>atomic_address</tt>, namely <tt>fetch_add</tt>, <tt>fetch_sub</tt>,
<tt>operator=</tt>, <tt>operator+=</tt> and <tt>operator-=</tt>. That's good, but... what happened
to the other methods, in particular these ones:
</p>

<blockquote><pre>void store(T*, memory_order = memory_order_seq_cst) volatile;
T* load( memory_order = memory_order_seq_cst ) volatile;
T* swap( T*, memory_order = memory_order_seq_cst ) volatile;
bool compare_swap( T*&amp;, T*, memory_order, memory_order ) volatile;
bool compare_swap( T*&amp;, T*, memory_order = memory_order_seq_cst ) volatile;
</pre></blockquote>

<p>
By reading paper
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2427.html">N2427 "C++ Atomic Types and Operations"</a>,
I see that the
definition of the specialization <tt>atomic&lt;T*&gt;</tt> matches the one in the
draft, but in the example implementation the methods <tt>load()</tt>, <tt>swap()</tt>
and <tt>compare_swap()</tt> are indeed present.
</p>

<p>
Strangely, the example implementation does not redefine the method
<tt>store()</tt>. It's true that a <tt>T*</tt> is always convertible to <tt>void*</tt>, but not
hiding the <tt>void*</tt> signature from the base class makes the class
error-prone to say the least: it lets you assign pointers of any type to
a <tt>T*</tt>, without any hint from the compiler.
</p>

<p>
Is there a true intent to remove them from the specialization or are
they just missing from the definition because of a mistake?
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
<p>
The proposed revisions are accepted.
</p>
<p>
Further discussion: why is the ctor labeled "constexpr"? Lawrence said
this permits the object to be statically initialized, and that's
important because otherwise there would be a race condition on
initialization.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change the synopsis in 29.4.3 [atomics.types.generic]:
</p>

<blockquote><pre>template &lt;class T&gt; struct atomic&lt;T*&gt; : atomic_address { 
  <ins>void store(T*, memory_order = memory_order_seq_cst) volatile;</ins>
  <ins>T* load( memory_order = memory_order_seq_cst ) volatile;</ins>
  <ins>T* swap( T*, memory_order = memory_order_seq_cst ) volatile;</ins>
  <ins>bool compare_swap( T*&amp;, T*, memory_order, memory_order ) volatile;</ins>
  <ins>bool compare_swap( T*&amp;, T*, memory_order = memory_order_seq_cst ) volatile;</ins>

  T* fetch_add(ptrdiff_t, memory_order = memory_order_seq_cst) volatile; 
  T* fetch_sub(ptrdiff_t, memory_order = memory_order_seq_cst) volatile; 

  atomic() = default; 
  constexpr explicit atomic(T<ins>*</ins>); 
  atomic(const atomic&amp;) = delete; 
  atomic&amp; operator=(const atomic&amp;) = delete; 

  T* operator=(T*) volatile; 
  T* operator++(int) volatile; 
  T* operator--(int) volatile; 
  T* operator++() volatile; 
  T* operator--() volatile; 
  T* operator+=(ptrdiff_t) volatile;
  T* operator-=(ptrdiff_t) volatile; 
};
</pre></blockquote>






<hr>
<h3><a name="769"></a>769. std::function should use nullptr_t instead of "unspecified-null-pointer-type"</h3>
<p><b>Section:</b> 20.5.15.2 [func.wrap.func] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Daniel Krgler <b>Date:</b> 2008-01-10</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
N2461 already replaced in 20.5.15.2 [func.wrap.func] it's originally proposed
(implicit) conversion operator to "unspecified-bool-type" by the new
explicit bool conversion, but the inverse conversion should also
use the new <tt>std::nullptr_t</tt> type instead of "unspecified-null-pointer-
type".
</p>


<p><b>Proposed resolution:</b></p>

<p>
In 20.5 [function.objects], header <tt>&lt;functional&gt;</tt> synopsis replace:
</p>

<blockquote><pre>template&lt;class R, class... ArgTypes&gt;
  bool operator==(const function&lt;R(ArgTypes...)&gt;&amp;, <del>unspecified-null-pointer-type</del> <ins>nullptr_t</ins>);
template&lt;class R, class... ArgTypes&gt;
  bool operator==(<del>unspecified-null-pointer-type</del> <ins>nullptr_t</ins> , const function&lt;R(ArgTypes...)&gt;&amp;);
template&lt;class R, class... ArgTypes&gt;
  bool operator!=(const function&lt;R(ArgTypes...)&gt;&amp;, <del>unspecified-null-pointer-type</del> <ins>nullptr_t</ins>);
template&lt;class R, class... ArgTypes&gt;
  bool operator!=(<del>unspecified-null-pointer-type</del> <ins>nullptr_t</ins> , const function&lt;R(ArgTypes...)&gt;&amp;);
</pre></blockquote>

<p>
In the class function synopsis of 20.5.15.2 [func.wrap.func] replace
</p>

<blockquote><pre>function(<del>unspecified-null-pointer-type</del> <ins>nullptr_t</ins>);
...
function&amp; operator=(<del>unspecified-null-pointer-type</del> <ins>nullptr_t</ins>);
</pre></blockquote>

<p>
In 20.5.15.2 [func.wrap.func], "Null pointer comparisons" replace:
</p>

<blockquote><pre>template &lt;class R, class... ArgTypes&gt;
  bool operator==(const function&lt;R(ArgTypes...)&gt;&amp;, <del>unspecified-null-pointer-type</del> <ins>nullptr_t</ins>);
template &lt;class R, class... ArgTypes&gt;
  bool operator==(<del>unspecified-null-pointer-type</del> <ins>nullptr_t</ins> , const function&lt;R(ArgTypes...)&gt;&amp;);
template &lt;class R, class... ArgTypes&gt;
  bool operator!=(const function&lt;R(ArgTypes...)&gt;&amp;, <del>unspecified-null-pointer-type</del> <ins>nullptr_t</ins>);
template &lt;class R, class... ArgTypes&gt;
  bool operator!=(<del>unspecified-null-pointer-type</del> <ins>nullptr_t</ins> , const function&lt;R(ArgTypes...)&gt;&amp;);
</pre></blockquote>

<p>
In 20.5.15.2.1 [func.wrap.func.con], replace
</p>

<blockquote><pre>function(<del>unspecified-null-pointer-type</del> <ins>nullptr_t</ins>);
...
function&amp; operator=(<del>unspecified-null-pointer-type</del> <ins>nullptr_t</ins>);
</pre></blockquote>

<p>
In 20.5.15.2.6 [func.wrap.func.nullptr], replace
</p>

<blockquote><pre>template &lt;class R, class... ArgTypes&gt;
  bool operator==(const function&lt;R(ArgTypes...)&gt;&amp; f, <del>unspecified-null-pointer-type</del> <ins>nullptr_t</ins>);
template &lt;class R, class... ArgTypes&gt;
  bool operator==(<del>unspecified-null-pointer-type</del> <ins>nullptr_t</ins> , const function&lt;R(ArgTypes...)&gt;&amp; f);
</pre></blockquote>

<p>
and replace
</p>

<blockquote><pre>template &lt;class R, class... ArgTypes&gt;
  bool operator!=(const function&lt;R(ArgTypes...)&gt;&amp; f, <del>unspecified-null-pointer-type</del> <ins>nullptr_t</ins>);
template &lt;class R, class... ArgTypes&gt;
  bool operator!=(<del>unspecified-null-pointer-type</del> <ins>nullptr_t</ins> , const function&lt;R(ArgTypes...)&gt;&amp; f);
</pre></blockquote>






<hr>
<h3><a name="770"></a>770. std::function should use rvalue swap</h3>
<p><b>Section:</b> 20.5.15 [func.wrap] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Daniel Krgler <b>Date:</b> 2008-01-10</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It is expected that typical implementations of <tt>std::function</tt> will
use dynamic memory allocations at least under given conditions,
so it seems appropriate to change the current lvalue swappabilty of
this class to rvalue swappability.
</p>


<p><b>Proposed resolution:</b></p>
<p>
In 20.5 [function.objects], header <tt>&lt;functional&gt;</tt> synopsis, just below of
</p>

<blockquote><pre>template&lt;class R, class... ArgTypes&gt;
  void swap(function&lt;R(ArgTypes...)&gt;&amp;, function&lt;R(ArgTypes...)&gt;&amp;);
<ins>template&lt;class R, class... ArgTypes&gt;
  void swap(function&lt;R(ArgTypes...)&gt;&amp;&amp;, function&lt;R(ArgTypes...)&gt;&amp;);
template&lt;class R, class... ArgTypes&gt;
  void swap(function&lt;R(ArgTypes...)&gt;&amp;, function&lt;R(ArgTypes...)&gt;&amp;&amp;);</ins>
</pre></blockquote>

<p>
In 20.5.15.2 [func.wrap.func] class <tt>function</tt> definition, change
</p>

<blockquote><pre>void swap(function&amp;<ins>&amp;</ins>);
</pre></blockquote>

<p>
In 20.5.15.2 [func.wrap.func], just below of
</p>

<blockquote><pre>template &lt;class R, class... ArgTypes&gt;
  void swap(function&lt;R(ArgTypes...)&gt;&amp;, function&lt;R(ArgTypes...)&gt;&amp;);
<ins>template &lt;class R, class... ArgTypes&gt;
  void swap(function&lt;R(ArgTypes...)&gt;&amp;&amp;, function&lt;R(ArgTypes...)&gt;&amp;);
template &lt;class R, class... ArgTypes&gt;
  void swap(function&lt;R(ArgTypes...)&gt;&amp;, function&lt;R(ArgTypes...)&gt;&amp;&amp;);</ins>
</pre></blockquote>

<p>
In 20.5.15.2.2 [func.wrap.func.mod] change
</p>

<blockquote><pre>void swap(function&amp;<ins>&amp;</ins> other);
</pre></blockquote>

<p>
In 20.5.15.2.7 [func.wrap.func.alg] add the two overloads
</p>

<blockquote><pre><ins>template&lt;class R, class... ArgTypes&gt;
  void swap(function&lt;R(ArgTypes...)&gt;&amp;&amp; f1, function&lt;R(ArgTypes...)&gt;&amp; f2);
template&lt;class R, class... ArgTypes&gt;
  void swap(function&lt;R(ArgTypes...)&gt;&amp; f1, function&lt;R(ArgTypes...)&gt;&amp;&amp; f2);</ins>
</pre></blockquote>






<hr>
<h3><a name="771"></a>771. Impossible throws clause in [string.conversions]</h3>
<p><b>Section:</b> 21.4 [string.conversions] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Review">Review</a>
 <b>Submitter:</b> Daniel Krgler <b>Date:</b> 2008-01-13</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#string.conversions">active issues</a> in [string.conversions].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#string.conversions">issues</a> in [string.conversions].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Review">Review</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The new <tt>to_string</tt> and <tt>to_wstring</tt> functions described in 21.4 [string.conversions]
have throws clauses (paragraphs 8 and 16) which say:
</p>

<blockquote>
<i>Throws:</i> nothing
</blockquote>

<p>
Since all overloads return either a <tt>std::string</tt> or a <tt>std::wstring</tt> by value
this throws clause is impossible to realize in general, since the <tt>basic_string</tt>
constructors can fail due to out-of-memory conditions. Either these throws
clauses should be removed or should be more detailled like:
</p>

<blockquote>
<i>Throws:</i> Nothing if the string construction throws nothing
</blockquote>

<p>
Further there is an editorial issue in p. 14: All three <tt>to_wstring</tt>
overloads return a <tt>string</tt>, which should be <tt>wstring</tt> instead (The
header <tt>&lt;string&gt;</tt> synopsis of 21.2 [string.classes] is correct in this
regard).
</p>



<p><b>Proposed resolution:</b></p>
<p>
In 21.4 [string.conversions], remove the paragraphs 8 and 16.
</p>

<blockquote>
<pre>string to_string(long long val); 
string to_string(unsigned long long val); 
string to_string(long double val); 
</pre>
<blockquote>
<del><i>Throws:</i> nothing</del>
</blockquote>
</blockquote>

<blockquote>
<pre><ins>w</ins>string to_wstring(long long val); 
<ins>w</ins>string to_wstring(unsigned long long val); 
<ins>w</ins>string to_wstring(long double val); 
</pre>
<blockquote>
<del><i>Throws:</i> nothing</del>
</blockquote>
</blockquote>






<hr>
<h3><a name="772"></a>772.  Impossible return clause in [string.conversions]</h3>
<p><b>Section:</b> 21.4 [string.conversions] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Daniel Krgler <b>Date:</b> 2008-01-13</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#string.conversions">active issues</a> in [string.conversions].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#string.conversions">issues</a> in [string.conversions].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The return clause 21.4 [string.conversions]/paragraph 15 of the new <tt>to_wstring</tt>
overloads says:
</p>

<blockquote>
<i>Returns:</i> each function returns a <tt>wstring</tt> object holding the character
representation of the value of its argument that would be generated by
calling <tt>wsprintf(buf, fmt, val)</tt> with a format specifier of <tt>L"%lld"</tt>, <tt>L"%ulld"</tt>,
or <tt>L"%f"</tt>, respectively.
</blockquote>

<p>
Problem is: There does not exist any <tt>wsprintf</tt> function in C99 (I checked
the 2nd edition of ISO 9899, and the first and the second corrigenda from
2001-09-01 and 2004-11-15). What probably meant here is the function
<tt>swprintf</tt> from <tt>&lt;wchar.h&gt;/&lt;cwchar&gt;</tt>, but this has the non-equivalent
declaration:
</p>

<blockquote><pre>int swprintf(wchar_t * restrict s, size_t n,
const wchar_t * restrict format, ...);
</pre></blockquote>

<p>
therefore the paragraph needs to mention the <tt>size_t</tt> parameter <tt>n</tt>.
</p>



<p><b>Proposed resolution:</b></p>
<p>
Change the current wording of 21.4 [string.conversions]/p. 15 to:
</p>

<blockquote>
<i>Returns:</i> <del>e</del><ins>E</ins>ach function returns a
<tt>wstring</tt> object holding the character representation of the
value of its argument that would be generated by calling
<tt><del>ws</del><ins>sw</ins>printf(buf, <ins>bufsz,</ins> fmt,
val)</tt> with a format specifier <ins><tt>fmt</tt></ins> of <tt>L"%lld"</tt>,
<tt>L"%ulld"</tt>, or <tt>L"%f"</tt>, respectively<ins>, where <tt>buf</tt>
designates an internal character buffer of sufficient size <tt>bufsz</tt></ins>.
</blockquote>

<p>
[Hint to the editor: The resolution also adds to mention the name of
the format specifier "fmt"]
</p>

<p>
I also would like to remark that the current wording of it's equivalent
paragraph 7 should also mention the meaning of <tt>buf</tt> and <tt>fmt</tt>.
</p>

<p>
Change the current wording of 21.4 [string.conversions]/p. 7 to:
</p>

<blockquote>
<i>Returns:</i> <del>e</del><ins>E</ins>ach function returns a string object holding the
character representation of the value of its argument that would be
generated by calling <tt>sprintf(buf, fmt, val)</tt> with a format specifier <ins><tt>fmt</tt></ins> of
<tt>"%lld"</tt>, <tt>"%ulld"</tt>, or <tt>"%f"</tt>, respectively<ins>, where <tt>buf</tt> designates an internal
character buffer of sufficient size</ins>.
</blockquote>






<hr>
<h3><a name="774"></a>774. Member swap undefined for most containers</h3>
<p><b>Section:</b> 23 [containers] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Date:</b> 2008-01-14</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#containers">active issues</a> in [containers].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#containers">issues</a> in [containers].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It appears most containers declare but do not define a member-swap
function.
</p>

<p>
This is unfortunate, as all overload the <tt>swap</tt> algorithm to call the
member-swap function!
(required for <tt>swappable</tt> guarantees [Table 37] and Container Requirements
[Table 87])
</p>

<p>
Note in particular that Table 87 gives semantics of <tt>a.swap(b)</tt> as <tt>swap(a,b)</tt>,
yet for all containers we define <tt>swap(a,b)</tt> to call <tt>a.swap(b)</tt> - a circular
definition.
</p>

<p>
A quick survey of clause 23 shows that the following containers provide a
definition for member-swap:
</p>

<blockquote><pre>array
queue
stack
vector
</pre></blockquote>

<p>
Whereas the following declare it, but do not define the semantics:
</p>

<blockquote><pre>deque
list
map
multimap
multiset
priority_queue
set
unordered_map
unordered_multi_map
unordered_multi_set
unordered_set
</pre></blockquote>

<p>
Suggested resolution:
</p>
<blockquote>
Provide a definition for each of the affected containers...
</blockquote>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
Move to Open and ask Alisdair to provide wording.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Wording provided in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2590.pdf">N2590</a>.
</p>





<hr>
<h3><a name="775"></a>775. Tuple indexing should be unsigned?</h3>
<p><b>Section:</b> 20.3.1.4 [tuple.helper] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Alisdair Meredith <b>Date:</b> 2008-01-16</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The tuple element access API identifies the element in the sequence
using signed integers, and then goes on to enforce the requirement that
I be &gt;= 0.  There is a much easier way to do this - declare I as
<tt>unsigned</tt>.
</p>
<p>
In fact the proposal is to use <code>std::size_t</code>, matching the type used in the <tt>tuple_size</tt> API.
</p>
<p>
A second suggestion is that it is hard to imagine an API that deduces
and index at compile time and returns a reference throwing an exception.
Add a specific <em>Throws:</em> Nothing paragraph to each element
access API.
</p>
<p>
In addition to <code>tuple</code>, update the API applies to
<code>pair</code> and <code>array</code>, and should be updated
accordingly.
</p>

<p>
A third observation is that the return type of the <code>get</code>
functions for <code>std::pair</code> is pseudo-code, but it is not
clearly marked as such.  There is actually no need for pseudo-code as
the return type can be specified precisely with a call to
<code>tuple_element</code>.  This is already done for
<code>std::tuple</code>, and <code>std::array</code> does not have a
problem as all elements are of type <code>T</code>.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Update header &lt;utility&gt; synopsis in 20.2 [utility]
</p>
<pre><em>// 20.2.3, tuple-like access to pair:</em>
template &lt;class T&gt; class tuple_size;
template &lt;<del>int</del><ins>size_t</ins> I, class T&gt; class tuple_element;

template &lt;class T1, class T2&gt; struct tuple_size&lt;std::pair&lt;T1, T2&gt; &gt;;
template &lt;class T1, class T2&gt; struct tuple_element&lt;0, std::pair&lt;T1, T2&gt; &gt;;
template &lt;class T1, class T2&gt; struct tuple_element&lt;1, std::pair&lt;T1, T2&gt; &gt;;

template&lt;<del>int</del><ins>size_t</ins> I, class T1, class T2&gt;
  <del>P</del><ins>typename tuple_element&lt;I, std::pair&lt;T1, T2&gt; &gt;::type </ins>&amp; get(std::pair&lt;T1, T2&gt;&amp;);
template&lt;<del>int</del><ins>size_t</ins> I, class T1, class T2&gt;
  const <del>P</del><ins>typename tuple_element&lt;I, std::pair&lt;T1, T2&gt; &gt;::type </ins>&amp; get(const std::pair&lt;T1, T2&gt;&amp;);
</pre>
<p>
Update <strong>20.2.3 [pairs] Pairs</strong>
</p>
<pre>template&lt;<del>int</del><ins>size_t</ins> I, class T1, class T2&gt;
  <del>P</del><ins>typename tuple_element&lt;I, std::pair&lt;T1, T2&gt; &gt;::type </ins>&amp; get(pair&lt;T1, T2&gt;&amp;);
template&lt;<del>int</del><ins>size_t</ins> I, class T1, class T2&gt;
  const <del>P</del><ins>typename tuple_element&lt;I, std::pair&lt;T1, T2&gt; &gt;::type </ins>&amp; get(const pair&lt;T1, T2&gt;&amp;);
</pre>
<p>
<del>24 <em>Return type:</em> If <code>I == 0</code> then <code>P</code> is <code>T1</code>, if <code>I == 1</code> then <code>P</code> is <code>T2</code>, and otherwise the program is ill-formed.</del>
</p>
<p>
25 <em>Returns:</em> If <code>I == 0</code> returns <code>p.first</code>, <del>otherwise</del> <ins>if <code>I == 1</code></ins> returns <code>p.second</code><ins>, and otherwise the program is ill-formed</ins>.
</p>
<p>
<ins><em>Throws:</em> Nothing.</ins>
</p>


<p>
Update header &lt;tuple&gt; synopsis in 20.3 [tuple] with a APIs as below:
</p>
<pre>template &lt;<del>int</del><ins>size_t</ins> I, class T&gt; class tuple_element; <em>// undefined</em>
template &lt;<del>int</del><ins>size_t</ins> I, class... Types&gt; class tuple_element&lt;I, tuple&lt;Types...&gt; &gt;;

<em>// 20.3.1.4, element access:</em>
template &lt;<del>int</del><ins>size_t</ins> I, class... Types&gt;
  typename tuple_element&lt;I, tuple&lt;Types...&gt; &gt;::type&amp; get(tuple&lt;Types...&gt;&amp;);
template &lt;<del>int</del><ins>size_t</ins> I, class ... types&gt;
  typename tuple_element&lt;I, tuple&lt;Types...&gt; &gt;::type const&amp; get(const tuple&lt;Types...&gt;&amp;);
</pre>

<p>
Update <strong>20.3.1.4 [tuple.helper] Tuple helper classes</strong>
</p>
<pre>template &lt;<del>int</del><ins>size_t</ins> I, class... Types&gt;
class tuple_element&lt;I, tuple&lt;Types...&gt; &gt; {
public:
  typedef TI type;
};</pre>
<p>
1 <em>Requires:</em> <code><del>0 &lt;= I and </del>I &lt; sizeof...(Types)</code>. The program is ill-formed if <code>I</code> is out of bounds.
</p>
<p>
2 <em>Type:</em> <code>TI</code> is the type of the <code>I</code>th element of <code>Types</code>, where indexing is zero-based.
</p>
<p>
Update <strong>20.3.1.5 [tuple.elem] Element access</strong>
</p>
<pre>template &lt;<del>int</del><ins>size_t</ins> I, class... types &gt;
typename tuple_element&lt;I, tuple&lt;Types...&gt; &gt;::type&amp; get(tuple&lt;Types...&gt;&amp; t);
</pre>
1 <em>Requires:</em> <code><del>0 &lt;= I and </del>I &lt; sizeof...(Types)</code>. The program is ill-formed if <code>I</code> is out of bounds.
<p>
2 <em>Returns:</em> A reference to the <code>I</code>th element of <code>t</code>, where indexing is zero-based.
</p>
<ins><em>Throws:</em> Nothing.</ins>
<pre>template &lt;<del>int</del><ins>size_t</ins> I, class... types&gt;
typename tuple_element&lt;I, tuple&lt;Types...&gt; &gt;::type const&amp; get(const tuple&lt;Types...&gt;&amp; t);
</pre>
<p>
3 <em>Requires:</em> <code><del>0 &lt;= I and </del>I &lt; sizeof...(Types)</code>. The program is ill-formed if <code>I</code> is out of bounds.
</p>
<p>
4 <em>Returns:</em> A const reference to the <code>I</code>th element of <code>t</code>, where indexing is zero-based.
</p>
<p>
<ins><em>Throws:</em> Nothing.</ins>
</p>


<p>
Update header &lt;array&gt; synopsis in 20.2 [utility]
</p>
<pre>template &lt;class T&gt; class tuple_size; <em>// forward declaration</em>
template &lt;<del>int</del><ins>size_t</ins> I, class T&gt; class tuple_element; <em>// forward declaration</em>
template &lt;class T, size_t N&gt;
  struct tuple_size&lt;array&lt;T, N&gt; &gt;;
template &lt;<del>int</del><ins>size_t</ins> I, class T, size_t N&gt;
  struct tuple_element&lt;I, array&lt;T, N&gt; &gt;;
template &lt;<del>int</del><ins>size_t</ins> I, class T, size_t N&gt;
  T&amp; get(array&lt;T, N&gt;&amp;);
template &lt;<del>int</del><ins>size_t</ins> I, class T, size_t N&gt;
  const T&amp; get(const array&lt;T, N&gt;&amp;);
</pre>

<p>
Update <strong>23.2.1.6 [array.tuple] Tuple interface to class template array</strong>
</p>
<pre>tuple_element&lt;<ins>size_t </ins>I, array&lt;T, N&gt; &gt;::type
</pre>
<p>
3 <em>Requires:</em> <code><del>0 &lt;= </del>I &lt; N.</code> The program is ill-formed if <code>I</code> is out of bounds.
</p>
<p>
4 <em>Value:</em> The type <code>T</code>.
</p>
<pre>template &lt;<del>int</del><ins>size_t</ins> I, class T, size_t N&gt; T&amp; get(array&lt;T, N&gt;&amp; a);
</pre>
<p>
5 <em>Requires:</em> <code><del>0 &lt;= </del>I &lt; N</code>. The program is ill-formed if <code>I</code> is out of bounds.
</p>
<p>
<em>Returns:</em> A reference to the <code>I</code>th element of <code>a</code>, where indexing is zero-based.
</p>
<p>
<ins><em>Throws:</em> Nothing.</ins>
</p>
<pre>template &lt;<del>int</del><ins>size_t</ins> I, class T, size_t N&gt; const T&amp; get(const array&lt;T, N&gt;&amp; a);
</pre>
<p>
6 <em>Requires:</em> <code><del>0 &lt;= </del>I &lt; N</code>. The program is ill-formed if <code>I</code> is out of bounds.
</p>
<p>
7 <em>Returns:</em> A const reference to the <code>I</code>th element of <code>a</code>, where indexing is zero-based.
</p>
<p>
<ins><em>Throws:</em> Nothing.</ins>
</p>


<p><i>[
Bellevue: Note also that the phrase "The program is ill-formed if I is
out of bounds" in the requires clauses are probably unnecessary, and
could be removed at the editor's discretion. Also std:: qualification
for pair is also unnecessary.
]</i></p>




<hr>
<h3><a name="776"></a>776. Undescribed assign function of std::array</h3>
<p><b>Section:</b> 23.2.1 [array] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Review">Review</a>
 <b>Submitter:</b> Daniel Krgler <b>Date:</b> 2008-01-20</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#array">active issues</a> in [array].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#array">issues</a> in [array].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Review">Review</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The class template array synopsis in 23.2.1 [array]/3 declares a member
function
</p>

<blockquote><pre>void assign(const T&amp; u);
</pre></blockquote>

<p>
which's semantic is no-where described. Since this signature is
not part of the container requirements, such a semantic cannot
be derived by those.
</p>

<p>
I found only one reference to this function in the issue list,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#588">588</a> where the question is raised:
</p>

<blockquote>
what's the effect of calling <tt>assign(T&amp;)</tt> on a zero-sized array?
</blockquote>

<p>
which does not answer the basic question of this issue.
</p>

<p>
If this function shall be part of the <tt>std::array</tt>, it's probable
semantic should correspond to that of <tt>boost::array</tt>, but of
course such wording must be added.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Just after the section 23.2.1.4 [array.data] add the following new section:
</p>

<p>
23.2.1.5 array::fill [array.fill]
</p>

<blockquote>
<pre>void fill(const T&amp; u);
</pre>

<p>
1: <i>Effects:</i> <tt>fill_n(begin(), N, u)</tt>
</p>
</blockquote>

<p>
[N.B: I wonder, why class <tt>array</tt> does not have a "modifiers"
section. If it had, then <tt>assign</tt> would naturally belong to it]
</p>

<p>
Change the synopsis in 23.2.1 [array]/3:
</p>

<blockquote><pre>template &lt;class T, size_t N&gt;
struct array { 
  ...
  void <del>assign</del> <ins>fill</ins>(const T&amp; u);
  ...
</pre></blockquote>


<p><i>[
Bellevue:
]</i></p>


<blockquote>
<p>
Suggest substituting "fill" instead of "assign".
</p>
<p>
Set state to Review given substitution of "fill" for "assign".
</p>
</blockquote>




<hr>
<h3><a name="777"></a>777. Atomics Library Issue</h3>
<p><b>Section:</b> 29.4.4 [atomics.types.operations] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Lawrence Crowl <b>Date:</b> 2008-01-21</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The load functions are defined as
</p>

<blockquote><pre>C atomic_load(volatile A* object);
C atomic_load_explicit(volatile A* object, memory_order);
C A::load(memory_order order = memory_order_seq_cst) volatile;
</pre></blockquote>

<p>
which prevents their use in <tt>const</tt> contexts.
</p>

<p><i>[
post Bellevue Peter adds:
]</i></p>


<blockquote>
<p>
Issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#777">777</a> suggests making <tt>atomic_load</tt> operate on <tt>const</tt> objects. There is a
subtle point here. Atomic loads do not generally write to the object, except
potentially for the <tt>memory_order_seq_cst</tt> constraint. Depending on the
architecture, a dummy write with the same value may be required to be issued
by the atomic load to maintain sequential consistency. This, in turn, may
make the following code:
</p>

<blockquote><pre>const atomic_int x{};

int main()
{
  x.load();
}
</pre></blockquote>

<p>
dump core under a straightforward implementation that puts const objects in
a read-only section.
</p>
<p>
There are ways to sidestep the problem, but it needs to be considered.
</p>
<p>
The tradeoff is between making the data member of the atomic types
mutable and requiring the user to explicitly mark atomic members as
mutable, as is already the case with mutexes.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add the <tt>const</tt> qualifier to <tt>*object</tt> and <tt>*this</tt>.
</p>

<blockquote><pre>C atomic_load(<ins>const</ins> volatile A* object);
C atomic_load_explicit(<ins>const</ins> volatile A* object, memory_order);
C A::load(memory_order order = memory_order_seq_cst) <ins>const</ins> volatile;
</pre></blockquote>






<hr>
<h3><a name="778"></a>778. std::bitset does not have any constructor taking a string literal</h3>
<p><b>Section:</b> 23.3.5.1 [bitset.cons] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Thorsten Ottosen <b>Date:</b> 2008-01-24</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#bitset.cons">active issues</a> in [bitset.cons].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#bitset.cons">issues</a> in [bitset.cons].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#116">116</a></p>
<p><b>Discussion:</b></p>
<p>
A small issue with <tt>std::bitset</tt>: it does not have any constructor
taking a string literal, which is clumsy and looks like an oversigt when
we tried to enable uniform use of <tt>string</tt> and <tt>const char*</tt> in the library.
</p>

<p>
Suggestion: Add
</p>

<blockquote><pre>explicit bitset( const char* str );
</pre></blockquote>

<p>
to std::bitset.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add to synopsis in 23.3.5 [template.bitset]
</p>

<blockquote><pre>explicit bitset( const char* str );
</pre></blockquote>

<p>
Add to synopsis in 23.3.5.1 [bitset.cons]
</p>

<blockquote><pre>explicit bitset( const char* str );
</pre>
<p>
<i>Effects:</i> Constructs a <tt>bitset</tt> as if <tt>bitset(string(str))</tt>.
</p>
</blockquote>






<hr>
<h3><a name="779"></a>779. Resolution of #283 incomplete</h3>
<p><b>Section:</b> 25.2.8 [alg.remove] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Daniel Krgler <b>Date:</b> 2008-01-25</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.remove">issues</a> in [alg.remove].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The resolution of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#283">283</a> did not resolve similar necessary changes for algorithm
<tt>remove_copy[_if]</tt>,
which seems to be an oversight.
</p>


<p><b>Proposed resolution:</b></p>
<p>
In 25.2.8 [alg.remove]/p.6, replace the N2461 requires clause with one of:
</p>

<blockquote>
<i>Requires:</i> <del>Type <tt>T</tt> is <tt>EqualityComparable</tt> (31).</del> The ranges <tt>[first,last)</tt>
and <tt>[result,result + (last - first))</tt> shall not overlap. <ins>The expression <tt>*result = *first</tt> shall be
valid.</ins>
</blockquote>

<p>
or
</p>

<blockquote>
<i>Requires:</i> <del>Type <tt>T</tt> is <tt>EqualityComparable</tt> (31).</del> The ranges <tt>[first,last)</tt>
and <tt>[result,result + (last - first))</tt> shall not overlap.
<ins>The result of the expression <tt>*first</tt> shall
be writable to the output iterator.</ins>
</blockquote>






<hr>
<h3><a name="780"></a>780. <tt>std::merge()</tt> specification incorrect/insufficient</h3>
<p><b>Section:</b> 25.3.4 [alg.merge] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Daniel Krgler <b>Date:</b> 2008-01-25</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Though issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#283">283</a> has fixed many open issues, it seems that some are still open:
</p>

<p>
Both 25.3.4 [lib.alg.merge] in 14882:2003 and 25.3.4 [alg.merge] in N2461
have no Requires element and the Effects element contains some requirements,
which is probably editorial. Worse is that:
</p>

<ul>
<li>
no assignment requirements are specified (neither implicit nor explicit).
</li>

<li>
the effects clause just speaks of "merges", which is badly worded
near to a circular definition.
</li>

<li>
p. 2 mentions a range <tt>[first, last)</tt>, which is not defined by the
function arguments or otherwise.
</li>

<li>
p. 2 says "according to the ordering defined by comp" which is both
incomplete (because
this excludes the first variant with &lt;) and redundant (because the
following subordinate
clause mentions comp again)
</li>
</ul>



<p><b>Proposed resolution:</b></p>
<p>
In 25.3.4 [alg.merge] replace p.1+ 2:
</p>

<blockquote>
<p>
<i>Effects:</i> <del>Merges</del> <ins>Copies all the elements of the</ins> two sorted ranges <tt>[first1,last1)</tt> and
<tt>[first2,last2)</tt> into the range
<del><tt>[result,result + (last1 - first1) + (last2 - first2))</tt></del>
<ins><tt>[result, last)</tt> (where <tt>last</tt> is equal to <tt>result + (last1
- first1) + (last2 - first2))</tt>, such that resulting range will be
sorted in non-decreasing order; that is, for every iterator <tt>i</tt> in
<tt>[result,last)</tt> other than <tt>result</tt>, the condition <tt>*i &lt; *(i - 1)</tt> or,
respectively, <tt>comp(*i, *(i - 1))</tt> will be false</ins>.
</p>

<p>
<ins><i>Requires:</i></ins> The resulting range shall not overlap with either of the original ranges. <del>The list will be sorted in non-decreasing 
order according to the ordering defined by <tt>comp</tt>; that is, for every iterator <tt>i</tt> in
<tt>[first,last)</tt> other than <tt>first</tt>, the condition <tt>*i &lt; *(i - 1)</tt> or
<tt>comp(*i, *(i - 1))</tt> will be false.</del> <ins>The results of the expressions <tt>*first1</tt> and <tt>*first2</tt>
shall be writable to the output iterator.</ins>
</p>
</blockquote>

<p>
[N.B.: I attempted to reuse the wording style of <tt>inplace_merge</tt>,
therefore proposing to
insert ", respectively," between both predicate tests. This is no
strictly necessary as
other parts of <tt>&lt;algorithm&gt;</tt> show, just a matter of consistency]
</p>






<hr>
<h3><a name="781"></a>781. <tt>std::complex</tt> should add missing C99 functions</h3>
<p><b>Section:</b> 26.3.7 [complex.value.ops] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Daniel Krgler <b>Date:</b> 2008-01-26</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#complex.value.ops">active issues</a> in [complex.value.ops].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#complex.value.ops">issues</a> in [complex.value.ops].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
A comparision of the N2461 header <tt>&lt;complex&gt;</tt> synopsis ([complex.synopsis])
with the C99 standard (ISO 9899, 2nd edition and the two corrigenda) show
some complex functions that are missing in C++. These are:
</p>

<ol>
<li>
7.3.9.4: (required elements of the C99 library)<br>
The <tt>cproj</tt> functions
</li>
<li>
7.26.1: (optional elements of the C99 library)<br>
<pre>cerf    cerfc    cexp2
cexpm1  clog10   clog1p
clog2   clgamma  ctgamma
</pre>
</li>
</ol>

<p>
I propose that at least the required <tt>cproj</tt> overloads are provided as equivalent
C++ functions. This addition is easy to do in one sentence (delegation to C99
function).
</p>

<p>
Please note also that the current entry <tt>polar</tt>
in 26.3.9 [cmplx.over]/1
should be removed from the mentioned overload list. It does not make sense to require that a
function already expecting <em>scalar</em> arguments
should cast these arguments into corresponding
<tt>complex&lt;T&gt;</tt> arguments, which are not accepted by
this function.
</p>


<p><b>Proposed resolution:</b></p>
<p>
In 26.3.1 [complex.synopsis] add just between the declaration of <tt>conj</tt> and <tt>fabs</tt>:
</p>

<blockquote><pre>template&lt;class T&gt; complex&lt;T&gt; conj(const complex&lt;T&gt;&amp;);
<ins>template&lt;class T&gt; complex&lt;T&gt; proj(const complex&lt;T&gt;&amp;);</ins>
template&lt;class T&gt; complex&lt;T&gt; fabs(const complex&lt;T&gt;&amp;);
</pre></blockquote>

<p>
In 26.3.7 [complex.value.ops] just after p.6 (return clause of <tt>conj</tt>) add:
</p>

<blockquote>
<pre>template&lt;class T&gt; complex&lt;T&gt; proj(const complex&lt;T&gt;&amp; x);
</pre>
<blockquote>

<i>Effects:</i> Behaves the same as C99 function <tt>cproj</tt>, defined in
subclause 7.3.9.4."
</blockquote>
</blockquote>

<p>
In 26.3.9 [cmplx.over]/1, add one further entry <tt>proj</tt> to
the overload list.
</p>

<blockquote>
<p>
The following function templates shall have additional overloads:
</p>
<blockquote><pre>arg           norm 
conj          <del>polar</del> <ins>proj</ins>
imag          real
</pre></blockquote>
</blockquote>






<hr>
<h3><a name="782"></a>782. Extended <tt>seed_seq</tt> constructor is useless</h3>
<p><b>Section:</b> 26.4.7.1 [rand.util.seedseq] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Daniel Krgler <b>Date:</b> 2008-01-27</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#rand.util.seedseq">active issues</a> in [rand.util.seedseq].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.util.seedseq">issues</a> in [rand.util.seedseq].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Part of the resolution of n2423, issue 8 was the proposal to
extend the <tt>seed_seq</tt> constructor accepting an input range
as follows (which is now part of N2461):
</p>

<blockquote><pre>template&lt;class InputIterator,
size_t u = numeric_limits&lt;iterator_traits&lt;InputIterator&gt;::value_type&gt;::digits&gt;
seed_seq(InputIterator begin, InputIterator end);
</pre></blockquote>

<p>
First, the expression <tt>iterator_traits&lt;InputIterator&gt;::value_type</tt>
is invalid due to missing <tt>typename</tt> keyword, which is easy to
fix.
</p>

<p>
Second (and worse), while the language now supports default
template arguments of function templates, this customization
point via the second <tt>size_t</tt> template parameter is of no advantage,
because <tt>u</tt> can never be deduced, and worse - because it is a
constructor function template - it can also never be explicitly
provided (14.8.1 [temp.arg.explicit]/7).
</p>

<p>
The question arises, which advantages result from a compile-time
knowledge of <tt>u</tt> versus a run time knowledge? If run time knowledge
suffices, this parameter should be provided as normal function
default argument [Resolution marked (A)], if compile-time knowledge
is important, this could be done via a tagging template or more
user-friendly via a standardized helper generator function
(<tt>make_seed_seq</tt>), which allows this [Resolution marked (B)].
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
<p>
Fermilab does not have a strong opinion. Would prefer to go with
solution A. Bill agrees that solution A is a lot simpler and does the
job.
</p>
<p>
Proposed Resolution: Accept Solution A.
</p>
</blockquote>

<p>
Issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#803">803</a> claims to make this issue moot.
</p>



<p><b>Proposed resolution:</b></p>
<ol type="A">
<li>
<p>
In 26.4.7.1 [rand.util.seedseq]/2, class <tt>seed_seq</tt> synopsis replace:
</p>

<blockquote><pre>class seed_seq 
{ 
public:
   ...
   template&lt;class InputIterator<del>,
      size_t u = numeric_limits&lt;iterator_traits&lt;InputIterator&gt;::value_type&gt;::digits</del>&gt;
          seed_seq(InputIterator begin, InputIterator end<ins>,
          size_t u = numeric_limits&lt;typename iterator_traits&lt;InputIterator&gt;::value_type&gt;::digits</ins>);
   ...
};
</pre></blockquote>

<p>
and do a similar replacement in the member description between
p.3 and p.4.
</p>
</li>

<li>
<p>
In 26.4.7.1 [rand.util.seedseq]/2, class <tt>seed_seq</tt> synopsis <em>and</em> in the
member description between p.3 and p.4 replace:
</p>

<blockquote><pre>template&lt;class InputIterator<del>,
  size_t u = numeric_limits&lt;iterator_traits&lt;InputIterator&gt;::value_type&gt;::digits</del>&gt;
	  seed_seq(InputIterator begin, InputIterator end);
<ins>template&lt;class InputIterator, size_t u&gt;
seed_seq(InputIterator begin, InputIterator end, <i>implementation-defined</i> s);</ins>
</pre></blockquote>

<p>
In 26.4.2 [rand.synopsis], header <tt>&lt;random&gt;</tt> synopsis, immediately after the
class <tt>seed_seq</tt> declaration <em>and</em> in 26.4.7.1 [rand.util.seedseq]/2, immediately
after the class <tt>seed_seq</tt> definition add:
</p>

<blockquote><pre>template&lt;size_t u, class InputIterator&gt;
  seed_seq make_seed_seq(InputIterator begin, InputIterator end);
</pre></blockquote>

<p>
In 26.4.7.1 [rand.util.seedseq], just before p.5 insert two paragraphs:
</p>

<blockquote>
<p>
The first constructor behaves as if it would provide an
integral constant expression <tt>u</tt> of type <tt>size_t</tt> of value
<tt>numeric_limits&lt;typename iterator_traits&lt;InputIterator&gt;::value_type&gt;::digits</tt>.
</p>
<p>
The second constructor uses an implementation-defined mechanism
to provide an integral constant expression <tt>u</tt> of type <tt>size_t</tt> and
is called by the function <tt>make_seed_seq</tt>.
</p>
</blockquote>

<p>
In 26.4.7.1 [rand.util.seedseq], just after the last paragraph add:
</p>

<blockquote>
<pre>template&lt;size_t u, class InputIterator&gt;
   seed_seq make_seed_seq(InputIterator begin, InputIterator end);
</pre>
<blockquote>
<p>
where <tt>u</tt> is used to construct an object <tt>s</tt> of implementation-defined type.
</p>
<p>
<i>Returns:</i> <tt>seed_seq(begin, end, s)</tt>;
</p>
</blockquote>
</blockquote>

</li>
</ol>






<hr>
<h3><a name="783"></a>783. <tt>thread::id</tt> reuse</h3>
<p><b>Section:</b> 30.2.1.1 [thread.thread.id] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Hans Boehm <b>Date:</b> 2008-02-01</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The current working paper 
(<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2497.html">N2497</a>,
integrated just before Bellevue) is
not completely clear whether a given <tt>thread::id</tt> value may be reused once
a thread has exited and has been joined or detached.  Posix allows
thread ids (<tt>pthread_t</tt> values) to be reused in this case.  Although it is
not completely clear whether this originally was the right decision, it
is clearly the established practice, and we believe it was always the
intent of the C++ threads API to follow Posix and allow this.  Howard
Hinnant's example implementation implicitly relies on allowing reuse
of ids, since it uses Posix thread ids directly.
</p>

<p>
It is important to be clear on this point, since it the reuse of thread
ids often requires extra care in client code, which would not be
necessary if thread ids were unique across all time.  For example, a
hash table indexed by thread id may have to be careful not to associate
data values from an old thread with a new one that happens to reuse the
id.  Simply removing the old entry after joining a thread may not be
sufficient, if it creates a visible window between the join and removal
during which a new thread with the same id could have been created and
added to the table.
</p>

<p><i>[
post Bellevue Peter adds:
]</i></p>


<blockquote>
<p>
There is a real issue with <tt>thread::id</tt> reuse, but I urge the LWG to
reconsider fixing this by disallowing reuse, rather than explicitly allowing
it. Dealing with thread id reuse is an incredibly painful exercise that
would just force the world to reimplement a non-conflicting <tt>thread::id</tt> over
and over.
</p>
<p>
In addition, it would be nice if a <tt>thread::id</tt> could be manipulated
atomically in a lock-free manner, as motivated by the recursive lock
example:
</p>

<p>
<a href="http://www.decadentplace.org.uk/pipermail/cpp-threads/2006-August/001091.html">http://www.decadentplace.org.uk/pipermail/cpp-threads/2006-August/001091.html</a>
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add a sentence to 30.2.1.1 [thread.thread.id]/p1:
</p>

<blockquote>
<p>
An object of type <code>thread::id</code> provides
a unique identifier for each thread of execution
and a single distinct value for all thread objects
that do not represent a thread of execution ([thread.threads.class]).
Each thread of execution has a <code>thread::id</code>
that is not equal to the <code>thread::id</code>
of other threads of execution
and that is not equal to
the <code>thread::id</code> of <code>std::thread</code> objects
that do not represent threads of execution.
<ins>The library may reuse the value of a <code>thread::id</code> of a
terminated thread that can no longer be joined.</ins>
</p>
</blockquote>





<hr>
<h3><a name="785"></a>785. Random Number Requirements in TR1</h3>
<p><b>Section:</b> TR1 5.1.4.5 [tr.rand.eng.disc], TR1 5.1.4.6 [tr.rand.eng.xor] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> John Maddock <b>Date:</b> 2008-01-15</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Table 16 of TR1 requires that all Pseudo Random Number generators have a
</p>

<blockquote><pre>seed(integer-type s)
</pre></blockquote>

<p>
member function that is equivalent to:
</p>

<blockquote><pre>mygen = Generator(s)
</pre></blockquote>

<p>
But the generators <tt>xor_combine</tt> and <tt>discard_block</tt> have no such seed member, only the
</p>

<blockquote><pre>template &lt;class Gen&gt;
seed(Gen&amp;);
</pre></blockquote>

<p>
member, which will not accept an integer literal as an argument: something that appears to violate the intent of Table 16.
</p>

<p>
So... is this a bug in TR1?
</p>

<p>This is a real issue BTW, since the Boost implementation does adhere
to the requirements of Table 16, while at least one commercial
implementation does not and follows a strict adherence to sections
5.1.4.5 and 5.1.4.6 instead.
</p>

<p><i>[
Jens adds:
]</i></p>


<blockquote>
Both engines do have the necessary
constructor, therefore the omission of the <tt>seed()</tt> member
functions appears to be an oversight.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="786"></a>786. Thread library timed waits, UTC and monotonic clocks</h3>
<p><b>Section:</b> X [datetime.system] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Christopher Kohlhoff, Jeff Garland <b>Date:</b> 2008-02-03</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The draft C++0x thread library requires that the time points of type
<tt>system_time</tt> and returned by <tt>get_system_time()</tt> represent Coordinated
Universal Time (UTC) (section X [datetime.system]). This can lead to
surprising behavior when a library user performs a duration-based wait,
such as <tt>condition_variable::timed_wait()</tt>. A complete explanation of the
problem may be found in the
<a href="http://www.opengroup.org/onlinepubs/009695399/xrat/xsh_chap02.html#tag_03_02_08_19">Rationale for the Monotonic Clock</a>
section in POSIX, but in summary:
</p>

<ul>
<li>
Operations such as <tt>condition_variable::timed_wait()</tt> (and its POSIX
equivalent, <tt>pthread_cond_timedwait()</tt>) are specified using absolute times
to address the problem of spurious wakeups.
</li>

<li>
The typical use of the timed wait operations is to perform a relative
wait. This may be achieved by first calculating an absolute time as the
sum of the current time and the desired duration. In fact, the C++0x
thread library includes duration-based overloads of
<tt>condition_variable::timed_wait()</tt> that behave as if by calling the
corresponding absolute time overload with a time point value of
<tt>get_system_time() + rel_time</tt>.
</li>

<li>
A UTC clock may be affected by changes to the system time, such as
synchronization with an external source, leap seconds, or manual changes
to the clock.
</li>

<li>
Should the clock change during a timed wait operation, the actual
duration of the wait will not be the expected length. For example, a
user may intend a timed wait of one second duration but, due to an
adjustment of the system clock backwards by a minute, the wait instead
takes 61 seconds.
</li>
</ul>

<p>
POSIX solves the problem by introducing a new monotonic clock, which is
unaffected by changes to the system time. When a condition variable is
initialized, the user may specify whether the monotonic clock is to be
used. (It is worth noting that on POSIX systems it is not possible to
use <tt>condition_variable::native_handle()</tt> to access this facility, since
the desired clock type must be specified during construction of the
condition variable object.)
</p>

<p>
In the context of the C++0x thread library, there are added dimensions
to the problem due to the need to support platforms other than POSIX:
</p>

<ul>
<li>
Some environments (such as embedded systems) do not have a UTC clock, but do have a monotonic clock.
</li>

<li>
Some environments do not have a monotonic clock, but do have a UTC clock.
</li>

<li>
The Microsoft Windows API's synchronization functions use relative
timeouts based on an implied monotonic clock. A program that switches
from the Windows API to the C++0x thread library will now find itself
susceptible to clock changes.
</li>
</ul>

<p>
One possible minimal solution:
</p>

<ul>
<li>
Strike normative references to UTC and an epoch based on 1970-01-01.
</li>

<li>
Make the semantics of <tt>system_time</tt> and <tt>get_system_time()</tt>
implementation-defined (i.e standard library implementors may choose the
appropriate underlying clock based on the capabilities of the target
platform).
</li>

<li>
Add a non-normative note encouraging use of a monotonic clock.
</li>

<li>
Remove <tt>system_time::seconds_since_epoch()</tt>.
</li>

<li>
Change the constructor <tt>explicit system_time(time_t secs, nanoseconds ns
= 0)</tt> to <tt>explicit system_time(nanoseconds ns)</tt>.
</li>
</ul>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="787"></a>787. complexity of <tt>binary_search</tt></h3>
<p><b>Section:</b> 25.3.3.4 [binary.search] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Daniel Krgler <b>Date:</b> 2007-09-08</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 25.3.3.4 [binary.search]/3 the complexity of <tt>binary_search</tt> is described as
</p>

<blockquote>
At most <tt>log(last - first) + 2</tt> comparisons.
</blockquote>

<p>
This should be precised and brought in line with the nomenclature used for
<tt>lower_bound</tt>, <tt>upper_bound</tt>, and <tt>equal_range</tt>.
</p>

<p>
All existing libraries I'm aware of, delegate to
<tt>lower_bound</tt> (+ one further comparison). Since
issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#384">384</a>
has now WP status, the resolution of #787 should
be brought in-line with <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#384">384</a> by changing the <tt>+ 2</tt>
to <tt>+ O(1)</tt>.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change 25.3.3.4 [binary.search]/3
</p>

<blockquote>
<i>Complexity:</i> At most <tt>log<ins><sub>2</sub></ins>(last - first) + <del>2</del> <ins><i>O</i>(1)</ins></tt> comparisons.
</blockquote>





<hr>
<h3><a name="788"></a>788. ambiguity in [istream.iterator]</h3>
<p><b>Section:</b> 24.5.1 [istream.iterator] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Martin Sebor <b>Date:</b> 2008-02-06</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#istream.iterator">active issues</a> in [istream.iterator].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#istream.iterator">issues</a> in [istream.iterator].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The description of how an istream_iterator object becomes an
end-of-stream iterator is a) ambiguous and b) out of date WRT
issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#468">468</a>:
</p>

<blockquote>
<tt>istream_iterator</tt> reads (using <tt>operator&gt;&gt;</tt>) successive elements from the
input stream for which it was constructed. After it is constructed, and
every time <tt>++</tt> is used, the iterator reads and stores a value of <tt>T</tt>. If
the end of stream is reached (<tt>operator void*()</tt> on the stream returns
<tt>false</tt>), the iterator becomes equal to the <i>end-of-stream</i> iterator value.
The constructor with no arguments <tt>istream_iterator()</tt> always constructs
an end of stream input iterator object, which is the only legitimate
iterator to be used for the end condition. The result of <tt>operator*</tt> on an
end of stream is not defined. For any other iterator value a <tt>const T&amp;</tt> is
returned. The result of <tt>operator-&gt;</tt> on an end of stream is not defined.
For any other iterator value a <tt>const T*</tt> is returned. It is impossible to
store things into istream iterators. The main peculiarity of the istream
iterators is the fact that <tt>++</tt> operators are not equality preserving,
that is, <tt>i == j</tt> does not guarantee at all that <tt>++i == ++j</tt>. Every time <tt>++</tt>
is used a new value is read.
</blockquote>

<p>
<tt>istream::operator void*()</tt> returns null if <tt>istream::fail()</tt> is <tt>true</tt>,
otherwise non-null. <tt>istream::fail()</tt> returns <tt>true</tt> if <tt>failbit</tt> or
<tt>badbit</tt> is set in <tt>rdstate()</tt>. Reaching the end of stream doesn't
necessarily imply that <tt>failbit</tt> or <tt>badbit</tt> is set (e.g., after
extracting an <tt>int</tt> from <tt>stringstream("123")</tt> the stream object will
have reached the end of stream but <tt>fail()</tt> is <tt>false</tt> and <tt>operator
void*()</tt> will return a non-null value).
</p>

<p>
Also I would prefer to be explicit about calling <tt>fail()</tt> here
(there is no <tt>operator void*()</tt> anymore.)
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change 24.5.1 [istream.iterator]/1:
</p>

<blockquote>
<tt>istream_iterator</tt> reads (using <tt>operator&gt;&gt;</tt>) successive elements from the
input stream for which it was constructed. After it is constructed, and
every time <tt>++</tt> is used, the iterator reads and stores a value of <tt>T</tt>. If
<del>the end of stream is reached</del> <ins>the iterator fails to read and store a value of <tt>T</tt></ins>
(<tt><del>operator void*()</del> <ins>fail()</ins></tt> on the stream returns
<tt><del>false</del> <ins>true</ins></tt>), the iterator becomes equal to the <i>end-of-stream</i> iterator value.
The constructor with no arguments <tt>istream_iterator()</tt> always constructs
an end of stream input iterator object, which is the only legitimate
iterator to be used for the end condition. The result of <tt>operator*</tt> on an
end of stream is not defined. For any other iterator value a <tt>const T&amp;</tt> is
returned. The result of <tt>operator-&gt;</tt> on an end of stream is not defined.
For any other iterator value a <tt>const T*</tt> is returned. It is impossible to
store things into istream iterators. The main peculiarity of the istream
iterators is the fact that <tt>++</tt> operators are not equality preserving,
that is, <tt>i == j</tt> does not guarantee at all that <tt>++i == ++j</tt>. Every time <tt>++</tt>
is used a new value is read.
</blockquote>





<hr>
<h3><a name="789"></a>789. <tt>xor_combine_engine(result_type)</tt> should be explicit</h3>
<p><b>Section:</b> 26.4.4.4 [rand.adapt.xor] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> P.J. Plauger <b>Date:</b> 2008-02-09</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.adapt.xor">issues</a> in [rand.adapt.xor].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>xor_combine_engine(result_type)</tt> should be <tt>explicit</tt>. (Obvious oversight.)
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
Non-controversial. Bill is right, but Fermilab believes that this is
easy to use badly and hard to use right, and so it should be removed
entirely. Got into TR1 by well defined route, do we have permission to
remove stuff? Should probably check with Jens, as it is believed he is
the originator. Broad consensus that this is not a robust engine
adapter.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Remove xor_combine_engine from synopsis of 26.4.2 [rand.synopsis].
</p>
<p>
Remove 26.4.4.4 [rand.adapt.xor] <tt>xor_combine_engine</tt>.
</p>





<hr>
<h3><a name="792"></a>792. <tt>piecewise_constant_distribution</tt> is undefined for a range with just one endpoint</h3>
<p><b>Section:</b> 26.4.8.5.2 [rand.dist.samp.pconst] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> P.J. Plauger <b>Date:</b> 2008-02-09</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#rand.dist.samp.pconst">active issues</a> in [rand.dist.samp.pconst].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.dist.samp.pconst">issues</a> in [rand.dist.samp.pconst].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>piecewise_constant_distribution</tt> is undefined for a range with just one
endpoint. (Probably should be the same as an empty range.)
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change 26.4.8.5.2 [rand.dist.samp.pconst] paragraph 3b:
</p>

<blockquote>
b) If <tt>firstB == lastB</tt> <ins>or the sequence <tt>w</tt> has the length zero</ins>,
</blockquote>





<hr>
<h3><a name="793"></a>793. <tt>discrete_distribution</tt> missing constructor</h3>
<p><b>Section:</b> 26.4.8.5.1 [rand.dist.samp.discrete] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> P.J. Plauger <b>Date:</b> 2008-02-09</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.dist.samp.discrete">issues</a> in [rand.dist.samp.discrete].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>discrete_distribution</tt> should have a constructor like:
</p>

<blockquote><pre>template&lt;class _Fn&gt;
  discrete_distribution(result_type _Count, double _Low, double _High,
                        _Fn&amp; _Func);
</pre></blockquote>

<p>
(Makes it easier to fill a histogram with function vaues over a range.)
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
How do you specify the function so that it does not return negative
values? If you do it is a bad construction. This requirement is already
there. Where in each bin does one evaluate the function? In the middle.
Need to revisit tomorrow.
</blockquote>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="794"></a>794. <tt>piecewise_constant_distribution</tt> missing constructor</h3>
<p><b>Section:</b> 26.4.8.5.2 [rand.dist.samp.pconst] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> P.J. Plauger <b>Date:</b> 2008-02-09</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#rand.dist.samp.pconst">active issues</a> in [rand.dist.samp.pconst].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.dist.samp.pconst">issues</a> in [rand.dist.samp.pconst].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>piecewise_constant_distribution</tt> should have a constructor like:
</p>

<blockquote><pre>template&lt;class _Fn&gt;
   piecewise_constant_distribution(size_t _Count,
            _Ty _Low, _Ty _High, _Fn&amp; _Func);
</pre></blockquote>

<p>
(Makes it easier to fill a histogram with function vaues over a range.
The two (reference <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#793">793</a>) make a sensible replacement for
<tt>general_pdf_distribution</tt>.)
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="798"></a>798. Refactoring of binders lead to interface breakage</h3>
<p><b>Section:</b> D.8 [depr.lib.binders] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Daniel Krgler <b>Date:</b> 2008-02-14</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#depr.lib.binders">issues</a> in [depr.lib.binders].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2521.pdf">N2521</a>
and its earlier predecessors have moved the old binders from
[lib.binders] to D.8 [depr.lib.binders] thereby introducing some renaming
of the template parameter names (<tt>Operation -&gt; Fn</tt>). During this
renaming process the <em>protected</em> data member <tt>op</tt> was also renamed to
<tt>fn</tt>, which seems as an unnecessary interface breakage to me - even if
this user access point is probably rarely used.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change D.8.1 [depr.lib.binder.1st]:
</p>

<blockquote>
<pre>template &lt;class Fn&gt; 
class binder1st 
  : public unary_function&lt;typename Fn::second_argument_type, 
                          typename Fn::result_type&gt; { 
protected: 
  Fn <del>fn</del> <ins>op</ins>; 
  typename Fn::first_argument_type value; 
public: 
  binder1st(const Fn&amp; x, 
            const typename Fn::first_argument_type&amp; y); 
  typename Fn::result_type 
    operator()(const typename Fn::second_argument_type&amp; x) const; 
  typename Fn::result_type 
    operator()(typename Fn::second_argument_type&amp; x) const; 
};
</pre>

<blockquote>
<p>
-1- The constructor initializes <del><tt>fn</tt></del> <ins><tt>op</tt></ins> with <tt>x</tt> and <tt>value</tt> with <tt>y</tt>.
</p>
<p>
-2- <tt>operator()</tt> returns <tt><del>fn</del><ins>op</ins>(value,x)</tt>.
</p>
</blockquote>
</blockquote>

<p>
Change D.8.3 [depr.lib.binder.2nd]:
</p>

<blockquote>
<pre>template &lt;class Fn&gt; 
class binder2nd
  : public unary_function&lt;typename Fn::first_argument_type, 
                          typename Fn::result_type&gt; { 
protected: 
  Fn <del>fn</del> <ins>op</ins>; 
  typename Fn::second_argument_type value; 
public: 
  binder2nd(const Fn&amp; x, 
            const typename Fn::second_argument_type&amp; y); 
  typename Fn::result_type 
    operator()(const typename Fn::first_argument_type&amp; x) const; 
  typename Fn::result_type 
    operator()(typename Fn::first_argument_type&amp; x) const; 
};
</pre>

<blockquote>
<p>
-1- The constructor initializes <del><tt>fn</tt></del> <ins><tt>op</tt></ins> with <tt>x</tt> and <tt>value</tt> with <tt>y</tt>.
</p>
<p>
-2- <tt>operator()</tt> returns <tt><del>fn</del><ins>op</ins>(value,x)</tt>.
</p>
</blockquote>
</blockquote>






<hr>
<h3><a name="800"></a>800. Issues in 26.4.7.1 [rand.util.seedseq](6)</h3>
<p><b>Section:</b> 26.4.7.1 [rand.util.seedseq] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Stephan Tolksdorf <b>Date:</b> 2008-02-18</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#rand.util.seedseq">active issues</a> in [rand.util.seedseq].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.util.seedseq">issues</a> in [rand.util.seedseq].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The for-loop in the algorithm specification has <tt>n</tt> iterations, where <tt>n</tt> is
defined to be <tt>end - begin</tt>, i.e. the number of supplied w-bit quantities.
Previous versions of this algorithm and the general logic behind it
suggest that this is an oversight and that in the context of the
for-loop <tt>n</tt> should be the number of full 32-bit quantities in <tt>b</tt> (rounded
upwards). If <tt>w</tt> is 64, the current algorithm throws away half of all bits
in <tt>b</tt>. If <tt>w</tt> is 16, the current algorithm sets half of all elements in <tt>v</tt>
to 0.
</p>

<p>
There are two more minor issues:
</p>

<ul>
<li>
Strictly speaking <tt>end - begin</tt> is not defined since
<tt>InputIterator</tt> is not required to be a random access iterator.
</li>
<li>
Currently all integral types are allowed as input to the <tt>seed_seq</tt>
constructor, including <tt>bool</tt>. IMHO allowing <tt>bool</tt>s unnecessarily
complicates the implementation without any real benefit to the user.
I'd suggest to exclude <tt>bool</tt>s as input.
</li>
</ul>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
Move to OPEN Bill will try to propose a resolution by the next meeting.
</blockquote>

<p><i>[
post Bellevue:  Bill provided wording.
]</i></p>


<p>
This issue is made moot if <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#803">803</a> is accepted.
</p>



<p><b>Proposed resolution:</b></p>
<p>
Replace 26.4.7.1 [rand.util.seedseq] paragraph 6 with:
</p>

<blockquote>
<p>
<i>Effects:</i> Constructs a <tt>seed_seq</tt> object by effectively concatenating the
low-order <tt>u</tt> bits of each of the elements of the supplied sequence <tt>[begin,
end)</tt>
in ascending order of significance to make a (possibly very large) unsigned
binary number <tt>b</tt> having a total of <tt>n</tt> bits, and then carrying out the
following
algorithm:
</p>

<blockquote><pre>for( v.clear(); n &gt; 0; n -= 32 )
   v.push_back(b mod 2<sup>32</sup>), b /= 2<sup>32</sup>;
</pre></blockquote>
</blockquote>





<hr>
<h3><a name="801"></a>801. <tt>tuple</tt> and <tt>pair</tt> trivial members</h3>
<p><b>Section:</b> 20.3 [tuple] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Lawrence Crowl <b>Date:</b> 2008-02-18</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#tuple">active issues</a> in [tuple].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#tuple">issues</a> in [tuple].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Classes with trivial special member functions are inherently more
efficient than classes without such functions.  This efficiency is
particularly pronounced on modern ABIs that can pass small classes
in registers.  Examples include value classes such as complex numbers
and floating-point intervals.  Perhaps more important, though, are
classes that are simple collections, like <tt>pair</tt> and <tt>tuple</tt>.  When the
parameter types of these classes are trivial, the <tt>pair</tt>s and <tt>tuple</tt>s
themselves can be trivial, leading to substantial performance wins.
</p>
<p>
The current working draft make specification of trivial functions
(where possible) much easer through <tt>default</tt>ed and <tt>delete</tt>d functions.
As long as the semantics of defaulted and deleted functions match
the intended semantics, specification of defaulted and deleted
functions will yield more efficient programs.
</p>
<p>
There are at least two cases where specification of an explicitly
defaulted function may be desirable.
</p>
<p>
First, the <tt>std::pair</tt> template has a non-trivial default constructor,
which prevents static initialization of the pair even when the
types are statically initializable.  Changing the definition to
</p>

<blockquote><pre>pair() = default;
</pre></blockquote>

<p>
would enable such initialization.  Unfortunately, the change is
not semantically neutral in that the current definition effectively
forces value initialization whereas the change would not value
initialize in some contexts.
</p>

<p>
** Does the committee confirm that forced value initialization
was the intent?  If not, does the committee wish to change the
behavior of <tt>std::pair</tt> in C++0x?
</p>
<p>
Second, the same default constructor issue applies to <tt>std::tuple</tt>.
Furthermore, the <tt>tuple</tt> copy constructor is current non-trivial,
which effectively prevents passing it in registers.  To enable
passing <tt>tuples</tt> in registers, the copy constructor should be
make explicitly <tt>default</tt>ed.  The new declarations are:
</p>

<blockquote><pre>tuple() = default;
tuple(const tuple&amp;) = default;
</pre></blockquote>

<p>
This changes is not implementation neutral.  In particular, it
prevents implementations based on pointers to the parameter
types.  It does however, permit implementations using the
parameter types as bases.
</p>
<p>
** How does the committee wish to trade implementation
efficiency versus implementation flexibility?
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
<p>
General agreement; the first half of the issue is NAD.
</p>
<p>
Before voting on the second half, it was agreed that a "Strongly Favor"
vote meant support for trivial tuples (assuming usual requirements met),
even at the expense of other desired qualities. A "Weakly Favor" vote
meant support only if not at the expense of other desired qualities.
</p>
<p>
Concensus: Go forward, but not at expense of other desired qualities.
</p>
<p>
It was agreed to Alisdair should fold this work in with his other
pair/tuple action items, above, and that issue 801 should be "open", but
tabled until Alisdair's proposals are disposed of.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="803"></a>803. Simplification of <tt>seed_seq::seq_seq</tt></h3>
<p><b>Section:</b> 26.4.7.1 [rand.util.seedseq] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Charles Karney <b>Date:</b> 2008-02-22</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#rand.util.seedseq">active issues</a> in [rand.util.seedseq].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.util.seedseq">issues</a> in [rand.util.seedseq].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>seed_seq(InputIterator begin, InputIterator end);</tt> constructs a <tt>seed_seq</tt>
object repacking the bits of supplied sequence <tt>[begin, end)</tt> into a
32-bit vector.
</p>
<p>
This repacking triggers several problems:
</p>
<ol>
<li>
Distinctness of the output of <tt>seed_seq::generate</tt> required the
introduction of the initial "<tt>if (w &lt; 32) v.push_back(n);</tt>"  (Otherwise
the unsigned short vectors [1, 0] and [1] generate the same sequence.)
</li>
<li>
Portability demanded the introduction of the template parameter <tt>u</tt>.
(Otherwise some sequences could not be obtained on computers where no
integer types are exactly 32-bits wide.)
</li>
<li>
The description and algorithm have become unduly complicated.
</li>
</ol>
<p>
I propose simplifying this <tt>seed_seq</tt> constructor to be "32-bit only".
Despite it's being simpler, there is NO loss of functionality (see
below).
</p>
<p>
Here's how the description would read
</p>
<blockquote>
<p>
26.4.7.1 [rand.util.seedseq] Class <tt>seed_seq</tt>
</p>

<blockquote>
<pre>template&lt;class InputIterator&gt;
  seed_seq(InputIterator begin, InputIterator end);
</pre>
<blockquote>
<p>
5 <i>Requires:</i> NO CHANGE
</p>
<p>
6 <i>Effects:</i> Constructs a <tt>seed_seq</tt> object by
</p>
<blockquote>
<pre>for (InputIterator s = begin; s != end; ++s)
   v.push_back((*s) mod 2^32);
</pre>
</blockquote>
</blockquote>
</blockquote>
</blockquote>

<p>
Discussion:
</p>
<p>
The chief virtues here are simplicity, portability, and generality.
</p>
<ul>
<li>
Simplicity -- compare the above specification with the
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2461.pdf">n2461</a> proposal.
</li>
<li>
Portability -- with <tt>iterator_traits&lt;InputIterator&gt;::value_type =
uint_least32_t</tt> the user is guaranteed to get the same behavior across
platforms.
</li>
<li>
Generality -- any behavior that the
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2461.pdf">n2461</a>
proposal can achieve can be
obtained with this simpler proposal (albeit with a shuffling of bits
in the input sequence).
</li>
</ul>
<p>
Arguments (and counter-arguments) against making this change (and
retaining the
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2461.pdf">n2461</a>
behavior) are:
</p>
<ul>
<li>
<p>
The user can pass an array of <tt>unsigned char</tt> and <tt>seed_seq</tt> will nicely
 repack it.
</p>
<p>
 Response: So what?  Consider the seed string "ABC".  The
 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2461.pdf">n2461</a>
 proposal results in
</p>
<blockquote><pre>v = { 0x3, 0x434241 };
</pre></blockquote>
<p>
while the simplified proposal yields
</p>
<blockquote><pre>v = { 0x41, 0x42, 0x43 };
</pre></blockquote>
<p>
The results produced by <tt>seed_seq::generate</tt> with the two inputs are
different but nevertheless equivalently "mixed up" and this remains
true even if the seed string is long.
</p>
</li>
<li>
<p>
With long strings (e.g., with bit-length comparable to the number of
 bits in the state), <tt>v</tt> is longer (by a factor of 4) with the simplified
 proposal and <tt>seed_seq::generate</tt> will be slower.
</p>
<p>
Response: It's unlikely that the efficiency of <tt>seed_seq::generate</tt> will
 be a big issue.  If it is, the user is free to repack the seed vector
 before constructing <tt>seed_seq</tt>.
</p>
</li>
<li>
<p>
A user can pass an array of 64-bit integers and all the bits will be
 used.
</p>
<p>
 Response: Indeed.  However, there are many instances in the 
 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2461.pdf">n2461</a>
 where integers are silently coerced to a narrower width and this
 should just be a case of the user needing to read the documentation.
 The user can of course get equivalent behavior by repacking his seed
 into 32-bit pieces.  Furthermore, the unportability of the 
 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2461.pdf">n2461</a>
 proposal with
</p>
<blockquote><pre>unsigned long s[] = {1, 2, 3, 4};
seed_seq q(s, s+4);
</pre></blockquote>
<p>
 which typically results in <tt>v = {1, 2, 3, 4}</tt> on 32-bit machines and in
<tt>v = {1, 0, 2, 0, 3, 0, 4, 0}</tt> on 64-bit machines is a major pitfall for
 unsuspecting users.
</p>
</li>
</ul>

<p>
Note: this proposal renders moot issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#782">782</a> and <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#800">800</a>.
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
Walter needs to ask Fermilab for guidance. Defer till tomorrow. Bill likes the proposed resolution.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 26.4.7.1 [rand.util.seedseq]:
</p>

<blockquote>
<pre>template&lt;class InputIterator<del>, 
  size_t u = numeric_limits&lt;iterator_traits&lt;InputIterator&gt;::value_type&gt;::digits</del>&gt;
  seed_seq(InputIterator begin, InputIterator end);
</pre>
<blockquote>
<p>
-5- <i>Requires:</i> <tt>InputIterator</tt> shall satisfy the requirements of an input iterator (24.1.1)
such that <tt>iterator_traits&lt;InputIterator&gt;::value_type</tt> shall denote an integral type.
</p>
<p>
-6- Constructs a <tt>seed_seq</tt> object by <del>rearranging some or all of the bits of the supplied sequence
<tt>[begin,end)</tt> of w-bit quantities into 32-bit units, as if by the following: </del>
</p>
<p>
<del>First extract the rightmost <tt>u</tt> bits from each of the <tt>n = end
- begin</tt> elements of the supplied sequence and concatenate all the
extracted bits to initialize a single (possibly very large) unsigned
binary number, <tt>b = &#8721;<sup>n-1</sup><sub>i=0</sub> (begin[i] 
mod 2<sup>u</sup>)  2<sup>wi</sup></tt> (in which the bits of each <tt>begin[i]</tt>
are treated as denoting an unsigned quantity). Then carry out 
the following algorithm:</del>
</p>
<blockquote><pre><del>
v.clear(); 
if ($w$ &lt; 32) 
  v.push_back($n$); 
for( ; $n$ &gt; 0; --$n$) 
  v.push_back(b mod 2<sup>32</sup>), b /= 2<sup>32</sup>;
</del></pre></blockquote>
<blockquote>
<pre><ins>
for (InputIterator s = begin; s != end; ++s)
   v.push_back((*s) mod 2<sup>32</sup>);
</ins></pre>
</blockquote>
</blockquote>
</blockquote>





<hr>
<h3><a name="804"></a>804. Some problems with classes <tt>error_code</tt>/<tt>error_condition</tt></h3>
<p><b>Section:</b> 19.4 [syserr] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Daniel Krgler <b>Date:</b> 2008-02-24</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#syserr">active issues</a> in [syserr].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#syserr">issues</a> in [syserr].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<ol type="A">
<li>
<p>
19.4.2.1 [syserr.errcode.overview]/1, class <tt>error_code</tt> and
19.4.3.1 [syserr.errcondition.overview]/, class <tt>error_condition</tt> synopses
declare an expository data member <tt>cat_</tt>:
</p>
<blockquote><pre>const error_category&amp; cat_; // exposition only
</pre></blockquote>
<p>
which is used to define the semantics of several members. The decision
to use a member of reference type lead to several problems:
</p>
<ol>
<li>
The classes are not <tt>(Copy)Assignable</tt>, which is probably not the intent.
</li>
<li>
The post conditions of all modifiers from
19.4.2.3 [syserr.errcode.modifiers] and 19.4.3.3 [syserr.errcondition.modifiers], resp.,
cannot be fulfilled.
</li>
</ol>
<p>
The simple fix would be to replace the reference by a pointer member.
</p>
</li>

<li>
I would like to give the editorial remark that in both classes the
constrained <tt>operator=</tt>
overload (template with <tt>ErrorCodeEnum</tt> argument) makes in invalid
usage of <tt>std::enable_if</tt>: By using the default value for the second <tt>enable_if</tt>
parameter the return type would be defined to be <tt>void&amp;</tt> even in otherwise
valid circumstances - this return type must be explicitly provided (In
<tt>error_condition</tt> the first declaration uses an explicit value, but of wrong
type).
</li>

<li>
The member function <tt>message</tt> throws clauses (
19.4.1.2 [syserr.errcat.virtuals]/10, 19.4.2.4 [syserr.errcode.observers]/8, and
19.4.3.4 [syserr.errcondition.observers]/6) guarantee "throws nothing",
although
they return a <tt>std::string</tt> by value, which might throw in out-of-memory
conditions (see related issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#771">771</a>).
</li>
</ol>


<p><b>Proposed resolution:</b></p>
<p>
In 19.4.1.2 [syserr.errcat.virtuals], remove the throws clause p. 10.
</p>

<blockquote>
<pre>virtual string message(int ev) const = 0;
</pre>

<blockquote>
<p>
<i>Returns:</i> A string that describes the error condition denoted by <tt>ev</tt>.
</p>
<p>
<del><i>Throws:</i> Nothing.</del>
</p>
</blockquote>
</blockquote>

<p>
In 19.4.2.1 [syserr.errcode.overview]/1, class <tt>error_code</tt> synopsis, modifiers section,
replace the current <tt>operator=</tt> overload by the following:
</p>

<blockquote>
<pre>template &lt;class ErrorCodeEnum&gt; 
  typename enable_if&lt;is_error_code_enum&lt;ErrorCodeEnum&gt;::value<ins>, error_code</ins>&gt;::type&amp; 
    operator=(ErrorCodeEnum e);
</pre>
</blockquote>

<p>
In the private section of the same class replace the current
data member <tt>cat_</tt> definition by:
</p>

<blockquote>
const error_category<del>&amp;</del><ins>*</ins> cat_; // exposition only
</blockquote>

<p>
In 19.4.2.2 [syserr.errcode.constructors], change p. 2 to read:
</p>

<blockquote>
<pre>error_code();
</pre>
<blockquote>
<p>
</p><p>...</p>

<p>
<i>Postconditions:</i> <tt>val_ == 0</tt> and <tt>cat_ == <ins>&amp;</ins>system_category</tt>.
</p>
</blockquote>
</blockquote>

<p>
Change 19.4.2.2 [syserr.errcode.constructors] p. 5 to read:
</p>

<blockquote>
<pre>error_code(int val, const error_category&amp; cat);
</pre>
<blockquote>
<p>...</p>
<p>
<i>Postconditions:</i> <tt>val_ == val</tt> and <tt>cat_ == <ins>&amp;</ins>cat</tt>.
</p>
</blockquote>
</blockquote>

<p>
In 19.4.2.3 [syserr.errcode.modifiers], change p. 1 to read:
</p>

<blockquote>
<pre>void assign(int val, const error_category&amp; cat);
</pre>
<blockquote>
<p>
</p><p>...</p>

<p>
<i>Postconditions:</i> <tt>val_ == val</tt> and <tt>cat_ == <ins>&amp;</ins>cat</tt>.
</p>
</blockquote>
</blockquote>

<p>
In 19.4.2.3 [syserr.errcode.modifiers], change the <tt>operator=</tt> signature to read:
</p>

<blockquote>
<pre>template &lt;class ErrorCodeEnum&gt; 
  typename enable_if&lt;is_error_code_enum&lt;ErrorCodeEnum&gt;::value<ins>, error_code</ins>&gt;::type&amp; 
    operator=(ErrorCodeEnum e);
</pre>
</blockquote>

<p>
In 19.4.2.4 [syserr.errcode.observers], change p. 3 to read:
</p>

<blockquote>
<pre>const error_category&amp; category() const;
</pre>
<blockquote>
<p>
</p><p>...</p>

<p>
<i>Returns:</i> <tt><ins>*</ins>cat_</tt>.
</p>
</blockquote>
</blockquote>

<p>
In 19.4.2.4 [syserr.errcode.observers], remove the throws clause p. 8.
</p>

<blockquote>
<pre>string message() const;
</pre>
<blockquote>
<p>
</p><p>...</p>

<p>
<del><i>Throws:</i> Nothing.</del>
</p>
</blockquote>
</blockquote>

<p>
In 19.4.3.1 [syserr.errcondition.overview]/1, class <tt>error_condition</tt>
synopsis, constructors section, replace the template constructor
overload declaration by one with an added "::value"
</p>

<blockquote>
<pre>template &lt;class ErrorConditionEnum&gt;
  error_condition(ErrorConditionEnum e,
    typename enable_if&lt;is_error_condition_enum&lt;ErrorConditionEnum&gt;<ins>::value</ins>&gt;::type* = 0);
</pre>
</blockquote>

<p>
In 19.4.3.1 [syserr.errcondition.overview]/1, class <tt>error_condition</tt> synopsis,
modifiers section,
replace the <tt>operator=</tt> overload declaration by:
</p>

<blockquote>
<pre>template&lt;typename ErrorConditionEnum&gt; 
  typename enable_if&lt;is_error_condition_enum&lt;ErrorConditionEnum&gt;<ins>::value</ins>, <del>error_code</del> <ins>error_condition</ins>&gt;::type &amp; 
     operator=( ErrorConditionEnum e );
</pre>
</blockquote>

<p>
In the private section of the same class replace the current
data member <tt>cat_</tt> definition by:
</p>

<blockquote><pre>const error_category<del>&amp;</del><ins>*</ins> cat_; // exposition only
</pre></blockquote>

<p>
In 19.4.3.2 [syserr.errcondition.constructors], change p. 2 to read:
</p>

<blockquote>
<pre>error_condition();
</pre>
<blockquote>
<p>
</p><p>...</p>

<p>
<i>Postconditions:</i> <tt>val_ == 0</tt> and <tt>cat_ == <ins>&amp;</ins>posix_category</tt>.
</p>
</blockquote>
</blockquote>

<p>
In the same section, change p. 5 to read:
</p>

<blockquote>
<pre>error_condition(int val, const error_category&amp; cat);
</pre>
<blockquote>
<p>
</p><p>...</p>

<p>
<i>Postconditions:</i> <tt>val_ == val</tt> and <tt>cat_ == <ins>&amp;</ins>cat</tt>.
</p>
</blockquote>
</blockquote>

<p>
In 19.4.3.3 [syserr.errcondition.modifiers], change p. 1 to read:
</p>

<blockquote>
<pre>void assign(int val, const error_category&amp; cat);
</pre>
<blockquote>
<p>
<i>Postconditions:</i> <tt>val_ == val</tt> and <tt>cat_ == <ins>&amp;</ins>cat</tt>.
</p>
</blockquote>
</blockquote>

<p>
In the same section replace the current <tt>operator=</tt> overload declaration by:
</p>

<blockquote>
<pre>template &lt;class ErrorConditionEnum&gt; 
  typename enable_if&lt;is_error_condition_enum&lt;ErrorConditionEnum&gt;::value<ins>, error_condition</ins>&gt;::type&amp;
    operator=(ErrorConditionEnum e);
</pre></blockquote>

<p>
In 19.4.3.4 [syserr.errcondition.observers], change p. 3 to read:
</p>

<blockquote>
<pre>const error_category&amp; category() const;
</pre>
<blockquote>
<p>
<i>Returns:</i> <tt><ins>*</ins>cat_</tt>.
</p>
</blockquote>
</blockquote>

<p>
In 19.4.3.4 [syserr.errcondition.observers], remove the throws clause p. 6.
</p>

<blockquote>
<pre>string message() const;
</pre>
<blockquote>
<p>
</p><p>...</p>

<p>
<del><i>Throws:</i> Nothing.</del>
</p>
</blockquote>
</blockquote>







<hr>
<h3><a name="805"></a>805. <tt>posix_error::posix_errno</tt> concerns</h3>
<p><b>Section:</b> 19.4 [syserr] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Jens Maurer <b>Date:</b> 2008-02-24</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#syserr">active issues</a> in [syserr].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#syserr">issues</a> in [syserr].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
19.4 [syserr]
</p>

<blockquote><pre>namespace posix_error {
  enum posix_errno {
    address_family_not_supported, // EAFNOSUPPORT
    ...
</pre></blockquote>

<p>
should rather use the new scoped-enum  facility (7.2 [dcl.enum]),
which would avoid the necessity for a new <tt>posix_error</tt>
namespace, if I understand correctly.
</p>

<p><i>[
Further discussion:
]</i></p>


<blockquote>
<p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2347.pdf">N2347</a>,
Strongly Typed Enums, since renamed Scoped Enums.
</p>
<p>
Alberto Ganesh Barbati also raised this issue in private email, and also proposed the scoped-enum solution.
</p>
<p>
Nick Stoughton asked in Bellevue that <tt>posix_error</tt> and <tt>posix_errno</tt> not be used as names. The LWG agreed.
</p>
<p>
The wording for the Proposed resolution was provided by Beman Dawes.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change System error support 19.4 [syserr] as indicated:
</p>

<blockquote><pre><del>namespace posix_error {</del>
  enum <del>posix_errno</del> <ins>class errc</ins> {
    address_family_not_supported, // EAFNOSUPPORT
    ...
    wrong_protocol_type, // EPROTOTYPE
  };
<del>} // namespace posix_error</del>

template &lt;&gt; struct is_error_condition_enum&lt;<del>posix_error::posix_errno</del> <ins>errc</ins>&gt;
  : public true_type {}

<del>namespace posix_error {</del>
  error_code make_error_code(<del>posix_errno</del> <ins>errc</ins> e);
  error_condition make_error_condition(<del>posix_errno</del> <ins>errc</ins> e);
<del>} // namespace posix_error</del>
</pre></blockquote>

<p>
Change System error support 19.4 [syserr] :
</p>

<blockquote>
<del>The <tt>is_error_code_enum</tt> and <tt>is_error_condition_enum</tt> templates may be
specialized for user-defined types to indicate that such a type is
eligible for class <tt>error_code</tt> and class <tt>error_condition</tt> automatic
conversions, respectively.</del>
</blockquote>

<p>
Change System error support 19.4 [syserr] and its subsections:
</p>

<blockquote>
<ul>
<li>
remove all occurrences of <tt>posix_error::</tt>
</li>
<li>
change all instances of <tt>posix_errno</tt> to <tt>errc</tt>
</li>
<li>
change all instances of <tt>posix_category</tt> to <tt>generic_category</tt>
</li>
<li>
change all instances of <tt>get_posix_category</tt> to <tt>get_generic_category</tt>
</li>
</ul>
</blockquote>

<p>
Change Error category objects 19.4.1.5 [syserr.errcat.objects], paragraph 2:
</p>

<blockquote>
<i>Remarks:</i> The object's <tt>default_error_condition</tt> and equivalent virtual
functions shall behave as specified for the class <tt>error_category</tt>. The
object's name virtual function shall return a pointer to the string
<del>"POSIX"</del> <ins>"GENERIC"</ins>.
</blockquote>

<p>
Change 19.4.2.5 [syserr.errcode.nonmembers] Class <tt>error_code</tt> non-member functions as indicated:
</p>

<blockquote>
<pre>error_code make_error_code(<del>posix_errno</del> <ins>errc</ins> e);
</pre>

<blockquote>
<i>Returns:</i> <tt>error_code(<ins>static_cast&lt;int&gt;(</ins>e<ins>)</ins>, <del>posix</del><ins>generic</ins>_category)</tt>.
</blockquote>
</blockquote>

<p>
Change 19.4.3.5 [syserr.errcondition.nonmembers] Class <tt>error_condition</tt> non-member functions as indicated:
</p>

<blockquote>
<pre>error_condition make_error_condition(<del>posix_errno</del> <ins>errc</ins> e);
</pre>

<blockquote>
<i>Returns:</i> <tt>error_condition(<ins>static_cast&lt;int&gt;(</ins>e<ins>)</ins>, <del>posix</del><ins>generic</ins>_category)</tt>.
</blockquote>
</blockquote>



<p><b>Rationale:</b></p>
<table border="1">
<tbody><tr>
<th colspan="2">Names Considered</th>
</tr>

<tr>
<td><tt>portable</tt></td>
<td>
Too non-specific. Did not wish to reserve such a common word in
namespace std. Not quite the right meaning, either.
</td>
</tr>

<tr>
<td><tt>portable_error</tt></td>
<td>
Too long. Explicit qualification is always required for scoped enums, so
a short name is desirable. Not quite the right meaning, either. May be
misleading because <tt>*_error</tt> in the std lib is usually an exception class
name.
</td>
</tr>

<tr>
<td><tt>std_error</tt></td>
<td>
Fairly short, yet explicit. But in fully qualified names like
<tt>std::std_error::not_enough_memory</tt>, the std_ would be unfortunate. Not
quite the right meaning, either. May be misleading because <tt>*_error</tt> in
the std lib is usually an exception class name.
</td>
</tr>

<tr>
<td><tt>generic</tt></td>
<td>
Short enough. The category could be <tt>generic_category</tt>. Fully qualified
names like <tt>std::generic::not_enough_memory</tt> read well. Reserving in
namespace std seems dicey.
</td>
</tr>

<tr>
<td><tt>generic_error</tt></td>
<td>
Longish. The category could be <tt>generic_category</tt>. Fully qualified names
like <tt>std::generic_error::not_enough_memory</tt> read well. Misleading because
<tt>*_error</tt> in the std lib is usually an exception class name.
</td>
</tr>

<tr>
<td><tt>generic_err</tt></td>
<td>
A bit less longish. The category could be <tt>generic_category</tt>. Fully
qualified names like <tt>std::generic_err::not_enough_memory</tt> read well.
</td>
</tr>

<tr>
<td><tt>gen_err</tt></td>
<td>
Shorter still. The category could be <tt>generic_category</tt>. Fully qualified
names like <tt>std::gen_err::not_enough_memory</tt> read well.
</td>
</tr>

<tr>
<td><tt>generr</tt></td>
<td>
Shorter still. The category could be <tt>generic_category</tt>. Fully qualified
names like <tt>std::generr::not_enough_memory</tt> read well.
</td>
</tr>

<tr>
<td><tt>error</tt></td>
<td>
Shorter still. The category could be <tt>generic_category</tt>. Fully qualified
names like <tt>std::error::not_enough_memory</tt> read well. Do we want to use
this general a name?
</td>
</tr>

<tr>
<td><tt>err</tt></td>
<td>
Shorter still. The category could be <tt>generic_category</tt>. Fully qualified
names like <tt>std::err::not_enough_memory</tt> read well. Although alone it
looks odd as a name, given the existing <tt>errno</tt> and <tt>namespace std</tt> names,
it seems fairly intuitive.
Problem: <tt>err</tt> is used throughout the standard library as an argument name
and in examples as a variable name; it seems too confusing to add yet
another use of the name.
</td>
</tr>

<tr>
<td><tt>errc</tt></td>
<td>
Short enough. The "c" stands for "constant". The category could be
<tt>generic_category</tt>. Fully qualified names like
<tt>std::errc::not_enough_memory</tt> read well. Although alone it looks odd as a
name, given the existing <tt>errno</tt> and <tt>namespace std</tt> names, it seems fairly
intuitive. There are no uses of <tt>errc</tt> in the current C++ standard.
</td>
</tr>
</tbody></table>





<hr>
<h3><a name="806"></a>806. <tt>unique_ptr::reset</tt> effects incorrect, too permissive</h3>
<p><b>Section:</b> 20.6.11.2.5 [unique.ptr.single.modifiers] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Peter Dimov <b>Date:</b> 2008-03-13</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>void unique_ptr::reset(T* p = 0)</tt> is currently specified as:
</p>

<blockquote>
<i>Effects:</i> If <tt>p == get()</tt> there are no effects. Otherwise <tt>get_deleter()(get())</tt>.
</blockquote>

<p>
There are two problems with this. One, if <tt>get() == 0</tt> and <tt>p != 0</tt>, the
deleter is called with a NULL pointer, and this is probably not what's
intended (the destructor avoids calling the deleter with 0.)
</p>

<p>
Two, the special check for <tt>get() == p</tt> is generally not needed and such a
situation usually indicates an error in the client code, which is being
masked. As a data point, <tt>boost::shared_ptr</tt> was changed to assert on such
self-resets in 2001 and there were no complaints.
</p>

<p>
One might think that self-resets are necessary for operator= to work; it's specified to perform
</p>

<blockquote><pre>reset( u.release() );
</pre></blockquote>

<p>
and the self-assignment
</p>

<blockquote><pre>p = move(p);
</pre></blockquote>

<p>
might appear to result in a self-reset. But it doesn't; the <tt>release()</tt> is
performed first, zeroing the stored pointer. In other words, <tt>p.reset(
q.release() )</tt> works even when <tt>p</tt> and <tt>q</tt> are the same <tt>unique_ptr</tt>, and there
is no need to special-case <tt>p.reset( q.get() )</tt> to work in a similar
scenario, as it definitely doesn't when <tt>p</tt> and <tt>q</tt> are separate.
</p>



<p><b>Proposed resolution:</b></p>

<p>
Change 20.6.11.2.5 [unique.ptr.single.modifiers]:
</p>

<blockquote>
<pre>void reset(T* p = 0);
</pre>
<blockquote>
-4- <i>Effects:</i> If <tt><del>p ==</del> get()<ins> == 0</ins></tt> there are no effects. Otherwise <tt>get_deleter()(get())</tt>.
</blockquote>
</blockquote>

<p>
Change 20.6.11.3.3 [unique.ptr.runtime.modifiers]:
</p>

<blockquote>
<pre>void reset(T* p = 0);
</pre>
<blockquote>
<p>...</p>
<p>
-2- <i>Effects:</i> If <tt><del>p ==</del> get()<ins> == 0</ins></tt> there are no effects. Otherwise <tt>get_deleter()(get())</tt>.
</p>
</blockquote>
</blockquote>






<hr>
<h3><a name="807"></a>807. <tt>tuple</tt> construction should not fail unless its element's construction fails</h3>
<p><b>Section:</b> 20.3.1.2 [tuple.cnstr] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Howard Hinnant <b>Date:</b> 2008-03-13</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#527">527</a> Added a throws clause to <tt>bind</tt> constructors.  I believe the same throws clause
should be added to <tt>tuple</tt> except it ought to take into account move constructors as well.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add to 20.3.1.2 [tuple.cnstr]:
</p>

<blockquote>
<p>
For each <tt>tuple</tt> constructor and assignment operator, an exception is thrown only if the construction
or assignment of one of the types in <tt>Types</tt> throws an exception.
</p>
</blockquote>





<hr>
<h3><a name="808"></a>808. [forward] incorrect redundant specification</h3>
<p><b>Section:</b> 20.2.2 [forward] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Jens Maurer <b>Date:</b> 2008-03-13</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#forward">active issues</a> in [forward].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#forward">issues</a> in [forward].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
p4 (forward) says:
</p>
<blockquote>
<i>Return type:</i> If <tt>T</tt> is an lvalue-reference type, an lvalue; otherwise, an rvalue.
</blockquote>

<p>
First of all, lvalue-ness and rvalue-ness are properties of an expression,
not of a type (see 3.10 [basic.lval]).  Thus, the phrasing "Return type" is wrong.
Second, the phrase says exactly what the core language wording says for
folding references in 14.3.1 [temp.arg.type]/p4  and for function return values
in 5.2.2 [expr.call]/p10.  (If we feel the wording should be retained, it should
at most be a note with cross-references to those sections.)
</p>
<p>
The prose after the example talks about "forwarding as an <tt>int&amp;</tt> (an lvalue)" etc.
In my opinion, this is a category error:  "<tt>int&amp;</tt>" is a type, "lvalue" is a
property of an expression, orthogonal to its type.  (Btw, expressions cannot
have reference type, ever.)
</p>
<p>
Similar with move:
</p>
<blockquote>
Return type: an rvalue.
</blockquote>
<p>
is just wrong and also redundant.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change 20.2.2 [forward] as indicated:
</p>

<blockquote>
<pre>template &lt;class T&gt; T&amp;&amp; forward(typename identity&lt;T&gt;::type&amp;&amp; t);
</pre>

<blockquote>
<p>...</p>
<p>
<del><i>Return type:</i> If <tt>T</tt> is an lvalue-reference type, an lvalue; otherwise, an rvalue.</del>
</p>
<p>...</p>
<p>
-7- In the first call to <tt>factory</tt>, <tt>A1</tt> is deduced as <tt>int</tt>, so 2 is forwarded to <tt>A</tt>'s constructor
as <del>an <tt>int&amp;&amp;</tt> (</del>an rvalue<del>)</del>. In the second call to factory, <tt>A1</tt> is deduced
as <tt>int&amp;</tt>, so <tt>i</tt> is forwarded to <tt>A</tt>'s constructor as <del>an <tt>int&amp;</tt> (</del>an lvalue<del>)</del>.
In both cases, <tt>A2</tt> is deduced as double, so 1.414 is forwarded to <tt>A</tt>'s constructor as
<del><tt>double&amp;&amp;</tt> (</del>an rvalue<del>)</del>.
</p>
</blockquote>

<pre>template &lt;class T&gt; typename remove_reference&lt;T&gt;::type&amp;&amp; move(T&amp;&amp; t);
</pre>

<blockquote>
<p>...</p>
<p>
<del><i>Return type:</i>  an rvalue.</del>
</p>
</blockquote>

</blockquote>






<hr>
<h3><a name="809"></a>809. std::swap should be overloaded for array types</h3>
<p><b>Section:</b> 25.2.3 [alg.swap] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Niels Dekker <b>Date:</b> 2008-02-28</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.swap">issues</a> in [alg.swap].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
For the sake of generic programming, the header <code>&lt;algorithm&gt;</code> should provide an
overload of <code>std::swap</code> for array types:
</p><pre>template&lt;class T, size_t N&gt; void swap(T (&amp;a)[N], T (&amp;b)[N]);
</pre>


<p>
It became apparent to me that this overload is missing, when I considered how to write a swap
function for a generic wrapper class template.
(Actually I was thinking of Boost's <a href="http://www.boost.org/libs/utility/value_init.htm">value_initialized</a>.)
Please look at the following template, <code>W</code>, and suppose that is intended to be a very
<em>generic</em> wrapper:
</p><pre>template&lt;class T&gt; class W {
public:
   T data;
};
</pre>
Clearly <code>W&lt;T&gt;</code> is <em>CopyConstructible and CopyAssignable</em>, and therefore
<em>Swappable</em>, whenever <code>T</code> is <em>CopyConstructible and CopyAssignable</em>.
Moreover, <code>W&lt;T&gt;</code> is <em>also</em> Swappable when <code>T</code> is an array type
whose element type is CopyConstructible and CopyAssignable.
Still it is recommended to add a <em>custom</em> swap function template to such a class template,
for the sake of efficiency and exception safety.
(E.g., <em>Scott Meyers, Effective C++, Third Edition, item 25: Consider support for a non-throwing
swap</em>.)
This function template is typically written as follows:
<pre>template&lt;class T&gt; void swap(W&lt;T&gt;&amp; x, W&lt;T&gt;&amp; y) {
  using std::swap;
  swap(x.data, y.data);
}
</pre>
Unfortunately, this will introduce an undesirable inconsistency, when <code>T</code> is an array.
For instance, <code>W&lt;std::string[8]&gt;</code> is Swappable, but the current Standard does not
allow calling the custom swap function that was especially written for <code>W</code>!
<pre>W&lt;std::string[8]&gt; w1, w2;  // Two objects of a Swappable type.
std::swap(w1, w2);  // Well-defined, but inefficient.
using std::swap;
swap(w1, w2);  // Ill-formed, just because ADL finds W's swap function!!!
</pre>

<code>W</code>'s <code>swap</code> function would try to call <code>std::swap</code> for an array,
<code>std::string[8]</code>, which is not supported by the Standard Library.
This issue is easily solved by providing an overload of <code>std::swap</code> for array types.
This swap function should be implemented in terms of swapping the elements of the arrays, so that
it would be non-throwing for arrays whose element types have a non-throwing swap.


<p>
Note that such an overload of <code>std::swap</code> should also support <em>multi-dimensional</em>
arrays. Fortunately that isn't really an issue, because it would do so <i>automatically</i>, by
means of recursion.
</p>

<p>
For your information, there was a discussion on this issue at comp.lang.c++.moderated: <a href="http://groups.google.com/group/comp.lang.c++.moderated/browse_thread/thread/9341ebd3635c9c74">[Standard
Library] Shouldn't std::swap be overloaded for C-style arrays?</a>
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add an extra condition to the definition of Swappable requirements [swappable] in 20.1.1 [utility.arg.requirements]:
</p>
<blockquote>
- <tt>T</tt> is <tt>Swappable</tt> if <tt>T</tt> is an array type whose element type is <tt>Swappable</tt>.
</blockquote>
<p>
Add the following to 25.2.3 [alg.swap]:
</p>
<blockquote>
<pre>template&lt;class T, size_t N&gt; void swap(T (&amp;a)[N], T (&amp;b)[N]);
</pre>
<blockquote>
<i>Requires:</i> Type <code>T</code> shall be <tt>Swappable</tt>.
</blockquote>
<blockquote>
<i>Effects:</i> <code>swap_ranges(a, a + N, b);</code>
</blockquote>
</blockquote>





<hr>
<h3><a name="810"></a>810. Missing traits dependencies in operational semantics of extended manipulators</h3>
<p><b>Section:</b> 27.6.4 [ext.manip] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Daniel Krgler <b>Date:</b> 2008-03-01</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#ext.manip">active issues</a> in [ext.manip].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#ext.manip">issues</a> in [ext.manip].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The recent draft (as well as the original proposal n2072) uses an
operational semantic
for <tt>get_money</tt> ([ext.manip]/3) and <tt>put_money</tt> ([ext.manip]/5), which uses
</p>

<blockquote><pre>istreambuf_iterator&lt;charT&gt;
</pre></blockquote>

<p>
and
</p>

<blockquote><pre>ostreambuf_iterator&lt;charT&gt;
</pre></blockquote>

<p>
resp, instead of the iterator instances, with explicitly provided
traits argument (The operational semantic defined by <tt>f</tt> is also traits
dependent). This is an obvious oversight because both <tt>*stream_buf</tt>
c'tors expect a <tt>basic_streambuf&lt;charT,traits&gt;</tt> as argument.
</p>
<p>
The same problem occurs within the <tt>get_time</tt> and <tt>put_time</tt> semantic (p.
7 and p. 9)
of n2071 incorporated in N2521, where additional to the problem we
have an editorial issue in <tt>get_time</tt> (<tt>streambuf_iterator</tt> instead of
<tt>istreambuf_iterator</tt>).
</p>


<p><b>Proposed resolution:</b></p>
<p>
In 27.6.4 [ext.manip]/3 within function <tt>f</tt> replace the first line
</p>

<blockquote><pre>template &lt;class charT, class traits, class moneyT&gt; 
void f(basic_ios&lt;charT, traits&gt;&amp; str, moneyT&amp; mon, bool intl) { 
   typedef istreambuf_iterator&lt;charT<ins>, traits</ins>&gt; Iter;
   ...
</pre></blockquote>

<p>
In 27.6.4 [ext.manip]/4 remove the first template <tt>charT</tt> parameter:
</p>

<blockquote><pre>template &lt;<del>class charT, </del>class moneyT&gt; unspecified put_money(const moneyT&amp; mon, bool intl = false<ins>)</ins>;
</pre></blockquote>

<p>
In 27.6.4 [ext.manip]/5 within function <tt>f</tt> replace the first line
</p>

<blockquote><pre>template &lt;class charT, class traits, class moneyT&gt; 
void f(basic_ios&lt;charT, traits&gt;&amp; str, const moneyT&amp; mon, bool intl) { 
  typedef ostreambuf_iterator&lt;charT<ins>, traits</ins>&gt; Iter;
  ...
</pre></blockquote>

<p>
In 27.6.4 [ext.manip]/7 within function <tt>f</tt> replace the first line
</p>

<blockquote><pre>template &lt;class charT, class traits&gt; 
void f(basic_ios&lt;charT, traits&gt;&amp; str, struct tm *tmb, const charT *fmt) { 
  typedef <ins>i</ins>streambuf_iterator&lt;charT<ins>, traits</ins>&gt; Iter;
  ...
</pre></blockquote>

<p>
In 27.6.4 [ext.manip]/8 add const:
</p>

<blockquote><pre>template &lt;class charT&gt; unspecified put_time(<ins>const</ins> struct tm *tmb, const charT *fmt);
</pre></blockquote>

<p>
In 27.6.4 [ext.manip]/9 within function <tt>f</tt> replace the first line
</p>

<blockquote><pre>template &lt;class charT, class traits&gt; 
void f(basic_ios&lt;charT, traits&gt;&amp; str, const struct tm *tmb, const charT *fmt) { 
  typedef ostreambuf_iterator&lt;charT<ins>, traits</ins>&gt; Iter;
  ...
</pre></blockquote>

<p>
Add to the <tt>&lt;iomanip&gt;</tt> synopsis in 27.6 [iostream.format]
</p>

<blockquote><pre>template &lt;class moneyT&gt; unspecified get_money(moneyT&amp; mon, bool intl = false);
template &lt;class moneyT&gt; unspecified put_money(const moneyT&amp; mon, bool intl = false);
template &lt;class charT&gt; unspecified get_time(struct tm *tmb, const charT *fmt);
template &lt;class charT&gt; unspecified put_time(const struct tm *tmb, const charT *fmt);
</pre></blockquote>






<hr>
<h3><a name="811"></a>811. <tt>pair</tt> of pointers no longer works with literal 0</h3>
<p><b>Section:</b> 20.2.3 [pairs] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Doug Gregor <b>Date:</b> 2008-03-14</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#pairs">issues</a> in [pairs].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<blockquote><pre>#include &lt;utility&gt;

int main()
{
   std::pair&lt;char *, char *&gt; p (0,0);
}
</pre></blockquote>

<p>
I just got a bug report about that, because it's valid C++03, but not
C++0x. The important realization, for me, is that the emplace
proposal---which made <tt>push_back</tt> variadic, causing the <tt>push_back(0)</tt>
issue---didn't cause this break in backward compatibility. The break
actually happened when we added this pair constructor as part of adding
rvalue references into the language, long before variadic templates or
emplace came along:
</p>

<blockquote><pre>template&lt;class U, class V&gt; pair(U&amp;&amp; x, V&amp;&amp; y);
</pre></blockquote>

<p>
Now, concepts will address this issue by constraining that <tt>pair</tt>
constructor to only <tt>U</tt>'s and <tt>V</tt>'s that can properly construct "first" and
"second", e.g. (from
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2322.pdf">N2322</a>):
</p>

<blockquote><pre>template&lt;class U , class V &gt;
requires Constructible&lt;T1, U&amp;&amp;&gt; &amp;&amp; Constructible&lt;T2, V&amp;&amp;&gt;
pair(U&amp;&amp; x , V&amp;&amp; y );
</pre></blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="812"></a>812. unsolicited multithreading considered harmful?</h3>
<p><b>Section:</b> 25.3.1 [alg.sort] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Paul McKenney <b>Date:</b> 2008-02-27</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Multi-threading is a good thing, but unsolicited multi-threading can
potentially be harmful.  For example, <tt>sort()</tt> performance might be
greatly increased via a multithreaded implementation.  However, such
a multithreaded implementation could result in concurrent invocations
of the user-supplied comparator.  This would in turn result in problems
given a caching comparator that might be written for complex sort keys.
Please note that this is not a theoretical issue, as multithreaded
implementations of <tt>sort()</tt> already exist.
</p>
<p>
Having a multithreaded <tt>sort()</tt> available is good, but it should not
be the default for programs that are not explicitly multithreaded.
Users should not be forced to deal with concurrency unless they have
asked for it.
</p>

<p><i>[
This may be covered by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2410.html">N2410</a>
Thread-Safety in the Standard Library (Rev 1).
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="813"></a>813. "empty" undefined for <tt>shared_ptr</tt></h3>
<p><b>Section:</b> 20.6.12.2 [util.smartptr.shared] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Matt Austern <b>Date:</b> 2008-02-26</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#util.smartptr.shared">active issues</a> in [util.smartptr.shared].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#util.smartptr.shared">issues</a> in [util.smartptr.shared].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Several places in 20.6.12.2 [util.smartptr.shared] refer to an "empty" <tt>shared_ptr</tt>.
However, that term is nowhere defined. The closest thing we have to a
definition is that the default constructor creates an empty <tt>shared_ptr</tt>
and that a copy of a default-constructed <tt>shared_ptr</tt> is empty. Are any
other <tt>shared_ptr</tt>s empty? For example, is <tt>shared_ptr((T*) 0)</tt> empty? What
are the properties of an empty <tt>shared_ptr</tt>? We should either clarify this
term or stop using it.
</p><p>
</p>
One reason it's not good enough to leave this term up to the reader's
intuition is that, in light of
<a href="http://www.open-std.org/JTC1/sc22/WG21/docs/papers/2007/n2351.htm">N2351</a>
and issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#711">711</a>, most readers'
intuitive understanding is likely to be wrong. Intuitively one might
expect that an empty <tt>shared_ptr</tt> is one that doesn't store a pointer,
but, whatever the definition is, that isn't it.


<p><i>[
Peter adds:
]</i></p>


<blockquote>
<p>
Or, what is an "empty" <tt>shared_ptr</tt>?
</p>

<ul>
<li>
<p>
Are any other <tt>shared_ptrs</tt> empty?
</p>
<p>
Yes. Whether a given <tt>shared_ptr</tt> instance is empty or not is (*)
completely specified by the last mutating operation on that instance.
Give me an example and I'll tell you whether the <tt>shared_ptr</tt> is empty or
not.
</p>
<blockquote>
(*) If it isn't, this is a legitimate defect.
</blockquote>
</li>

<li>
<p>
For example, is <tt>shared_ptr((T*) 0)</tt> empty?
</p>
<p>
No. If it were empty, it would have a <tt>use_count()</tt> of 0, whereas it is
specified to have an <tt>use_count()</tt> of 1.
</p>
</li>

<li>
<p>
What are the properties of an empty <tt>shared_ptr</tt>?
</p>
<p>
The properties of an empty <tt>shared_ptr</tt> can be derived from the
specification. One example is that its destructor is a no-op. Another is
that its <tt>use_count()</tt> returns 0. I can enumerate the full list if you
really like.
</p>
</li>

<li>
<p>
We should either clarify this term or stop using it.
</p>
<p>
I don't agree with the imperative tone
</p>
<p>
A clarification would be either a no-op - if it doesn't contradict the
existing wording - or a big mistake if it does.
</p>
<p>
I agree that a clarification that is formally a no-op may add value.
</p>
</li>

<li>
<p>
However, that term is nowhere defined.
</p>
<p>
Terms can be useful without a definition. Consider the following
simplistic example. We have a type <tt>X</tt> with the following operations
defined:
</p>
<blockquote><pre>X x;
X x2(x);
X f(X x);
X g(X x1, X x2);
</pre></blockquote>
<p>
A default-constructed value is green.<br>
A copy has the same color as the original.<br>
<tt>f(x)</tt> returns a red value if the argument is green, a green value otherwise.<br>
<tt>g(x1,x2)</tt> returns a green value if the arguments are of the same color, a red value otherwise.
</p>

<p>
Given these definitions, you can determine the color of every instance
of type <tt>X</tt>, even if you have absolutely no idea what green and red mean.
</p>

<p>
Green and red are "nowhere defined" and completely defined at the same time.
</p>
</li>
</ul>

<p>
Alisdair's wording is fine.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Append the following sentance to 20.6.12.2 [util.smartptr.shared]
</p>
<blockquote>
The <code>shared_ptr</code> class template stores a pointer, usually obtained
via <code>new</code>. <code>shared_ptr</code> implements semantics of
shared ownership; the last remaining owner of the pointer is responsible for
destroying the object, or otherwise releasing  the resources associated with
the stored pointer. <ins>A <code>shared_ptr</code> object that does not own
a pointer is said to be <i>empty</i>.</ins>
</blockquote>





<hr>
<h3><a name="814"></a>814. <tt>vector&lt;bool&gt;::swap(reference, reference)</tt> not defined</h3>
<p><b>Section:</b> 23.2.7 [vector.bool] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Alisdair Meredith <b>Date:</b> 2008-03-17</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#vector.bool">active issues</a> in [vector.bool].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#vector.bool">issues</a> in [vector.bool].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>vector&lt;bool&gt;::swap(reference, reference)</tt> has no definition.
</p>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="815"></a>815. <tt>std::function</tt> and <tt>reference_closure</tt> do not use perfect forwarding</h3>
<p><b>Section:</b> 20.5.15.2.4 [func.wrap.func.inv] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Alisdair Meredith <b>Date:</b> 2008-03-16</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>std::function</tt> and <tt>reference_closure</tt> should use "perfect forwarding" as
described in the rvalue core proposal.
</p>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="816"></a>816. Should <tt>bind()</tt>'s returned functor have a nofail copy ctor when <tt>bind()</tt> is nofail?</h3>
<p><b>Section:</b> 20.5.11.1.3 [func.bind.bind] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Date:</b> 2008-02-08</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#func.bind.bind">active issues</a> in [func.bind.bind].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#func.bind.bind">issues</a> in [func.bind.bind].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Library Issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#527">527</a> notes that <tt>bind(f, t1, ..., tN)</tt>
should be nofail when <tt>f, t1, ..., tN</tt> have nofail copy ctors.
</p>
<p>
However, no guarantees are provided for the copy ctor of the functor
returned by <tt>bind()</tt>.  (It's guaranteed to have a copy ctor, which can
throw implementation-defined exceptions: <tt>bind()</tt> returns a forwarding
call wrapper, TR1 3.6.3/2.  A forwarding call wrapper is a call wrapper,
TR1 3.3/4.  Every call wrapper shall be CopyConstructible, TR1 3.3/4. 
Everything without an exception-specification may throw
implementation-defined exceptions unless otherwise specified, C++03
17.4.4.8/3.)
</p>
<p>
Should the nofail guarantee requested by Library Issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#527">527</a> be extended
to cover both calling <tt>bind()</tt> and copying the returned functor?
</p>

<p><i>[
Howard adds:
]</i></p>


<blockquote>
<tt>tuple</tt> construction should probably have a similar guarantee.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="817"></a>817. <tt>bind</tt> needs to be moved</h3>
<p><b>Section:</b> 20.5.11.1.3 [func.bind.bind] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Howard Hinnant <b>Date:</b> 2008-03-17</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#func.bind.bind">active issues</a> in [func.bind.bind].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#func.bind.bind">issues</a> in [func.bind.bind].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The functor retureed by <tt>bind()</tt> should have a move constructor that
requires only move construction of its contained functor and bound arguments.
That way move-only functors can be passed to objects such as <tt>thread</tt>.
</p>
<p>
This issue is related to issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#816">816</a>.
</p>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="818"></a>818. wording for memory ordering</h3>
<p><b>Section:</b> 29.1 [atomics.order] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Jens Maurer <b>Date:</b> 2008-03-22</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
29.1 [atomics.order] p1 says in the table that
</p>

<blockquote>
<table border="1">
<tbody><tr>
<th>Element</th><th>Meaning</th>
</tr>
<tr>
<td><tt>memory_order_acq_rel</tt></td>
<td>the operation has both acquire and release semantics</td>
</tr>
</tbody></table>
</blockquote>

<p>
To my naked eye, that seems to imply that even an atomic read has both
acquire and release semantics.
</p>

<p>
Then, p1 says in the table:
</p>

<blockquote>
<table border="1">
<tbody><tr>
<th>Element</th><th>Meaning</th>
</tr>
<tr>
<td><tt>memory_order_seq_cst</tt></td>
<td>the operation has both acquire and release semantics,
    and, in addition, has sequentially-consistent operation ordering</td>
</tr>
</tbody></table>
</blockquote>

<p>
So that seems to be "the same thing" as <tt>memory_order_acq_rel</tt>, with additional
constraints.
</p>

<p>
I'm then reading p2, where it says:
</p>

<blockquote>
The <tt>memory_order_seq_cst</tt> operations that load a value are acquire operations
on the affected locations. The <tt>memory_order_seq_cst</tt> operations that store a value
are release operations on the affected locations.
</blockquote>

<p>
That seems to imply that atomic reads only have acquire semantics.  If that
is intended, does this also apply to <tt>memory_order_acq_rel</tt> and the individual
load/store operations as well?
</p>

<p>
Also, the table in p1 contains phrases with "thus" that seem to indicate
consequences of normative wording in 1.10 [intro.multithread].  That shouldn't be in
normative text, for the fear of redundant or inconsistent specification with
the other normative text.
</p>

<p>
Double-check 29.4.4 [atomics.types.operations] that each
operation clearly says whether it's a load or a store operation, or
both.  (It could be clearer, IMO.  Solution not in current proposed resolution.)
</p>

<p>
29.1 [atomics.order] p2:  What's a "consistent execution"?  It's not defined in
1.10 [intro.multithread], it's just used in notes there.
</p>

<p>
And why does 29.4.4 [atomics.types.operations] p9 for "load" say:
</p>


<blockquote>
<i>Requires:</i> The order argument shall not be <tt>memory_order_acquire</tt>
nor <tt>memory_order_acq_rel</tt>.
</blockquote>

<p>
(Since this is exactly the same restriction as for "store", it seems to be a typo.)
</p>

<p>
And then: 29.4.4 [atomics.types.operations] p12:
</p>

<blockquote>
These operations are read-modify-write operations in the sense of the
"synchronizes with" definition (1.10 [intro.multithread]), so both such an operation and the
evaluation that produced the input value synchronize with any evaluation
that reads the updated value.
</blockquote>

<p>
This is redundant with 1.10 [intro.multithread], see above for the reasoning.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Replace the cross-reference in p1 to refer to 1.1 [intro.scope] instead of
1.7 [intro.memory].
Rephrase the table in as follows (maybe don't use a table):
</p>

<blockquote>
<p>
For <tt>memory_order_relaxed</tt>, no operation orders memory.
</p>

<p>
For <tt>memory_order_release</tt>, <tt>memory_order_acq_rel</tt>, and <tt>memory_order_seq_cst</tt>,
a store operation performs a release operation on the affected memory location.
</p>

<p>
For <tt>memory_order_acquire</tt>, <tt>memory_order_acq_rel</tt>, and <tt>memory_order_seq_cst</tt>,
a load operation performs an acquire operation on the affected memory location.
</p>
</blockquote>

<p>
Rephrase 29.1 [atomics.order] p2:
</p>

<blockquote>
<del>The <tt>memory_order_seq_cst</tt> operations that load a value are
acquire operations on the affected locations. The
<tt>memory_order_seq_cst</tt> operations that store a value are release
operations on the affected locations.</del>
<del>In addition, in a consistent
execution, t</del><ins>T</ins>here <del>must be</del> <ins>is</ins> a single
total order <tt>S</tt> on all
<tt>memory_order_seq_cst</tt> operations, consistent with the happens before
order and modification orders for all affected locations, such that each
<tt>memory_order_seq_cst</tt> operation observes either the last preceding
modification according to this order <tt>S</tt>, or the result of an operation
that is not <tt>memory_order_seq_cst</tt>. [<i>Note:</i> Although it is not explicitly
required that <tt>S</tt> include locks, it can always be extended to an order
that does include lock and unlock operations, since the ordering between
those is already included in the happens before ordering. <i>-- end note</i>]
</blockquote>

<p>
Rephrase 29.4.4 [atomics.types.operations] p12 as:
</p>

<blockquote>
<i>Effects:</i> Atomically replaces the value pointed to by object or by
this with desired. Memory is affected according to the value of order.
These operations are read-modify-write operations <del>in the sense of the
"synchronizes with" definition</del> (1.10 [intro.multithread])<del>, so both such an operation and the
evaluation that produced the input value synchronize with any evaluation
that reads the updated value</del>.
</blockquote>

<p>
Same in p15, p20, p22.
</p>






<hr>
<h3><a name="819"></a>819. rethrow_if_nested</h3>
<p><b>Section:</b> 18.7.6 [except.nested] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Alisdair Meredith <b>Date:</b> 2008-03-25</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Looking at the wording I submitted for <tt>rethrow_if_nested</tt>, I don't think I
got it quite right.
</p>

<p>
The current wording says:
</p>

<blockquote>
<pre>template &lt;class E&gt; void rethrow_if_nested(const E&amp; e);
</pre>
<blockquote>
<p>
<i>Effects:</i> Calls <tt>e.rethrow_nested()</tt> only if <tt>e</tt>
is publicly derived from <tt>nested_exception</tt>.
</p>
</blockquote>
</blockquote>

<p>
This is trying to be a bit subtle, by requiring <tt>e</tt> (not <tt>E</tt>) to be publicly
derived from <tt>nested_exception</tt> the idea is that a <tt>dynamic_cast</tt> would be
required to be sure.  Unfortunately, if <tt>e</tt> is dynamically but not statically
derived from <tt>nested_exception</tt>, <tt>e.rethrow_nested()</tt> is ill-formed.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="820"></a>820. <tt>current_exception()</tt>'s interaction with throwing copy ctors</h3>
<p><b>Section:</b> 18.7.5 [propagation] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Date:</b> 2008-03-26</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#propagation">active issues</a> in [propagation].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#propagation">issues</a> in [propagation].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
As of N2521, the Working Paper appears to be silent about what
<tt>current_exception()</tt> should do if it tries to copy the currently handled
exception and its copy constructor throws.  18.7.5 [propagation]/7 says "If the
function needs to allocate memory and the attempt fails, it returns an
<tt>exception_ptr</tt> object that refers to an instance of <tt>bad_alloc</tt>.", but
doesn't say anything about what should happen if memory allocation
succeeds but the actual copying fails.
</p>

<p>
I see three alternatives: (1) return an <tt>exception_ptr</tt> object that refers
to an instance of some fixed exception type, (2) return an <tt>exception_ptr</tt>
object that refers to an instance of the copy ctor's thrown exception
(but if that has a throwing copy ctor, an infinite loop can occur), or
(3) call <tt>terminate()</tt>.
</p>

<p>
I believe that <tt>terminate()</tt> is the most reasonable course of action, but
before we go implement that, I wanted to raise this issue.
</p>

<p><i>[
Peter's summary:
]</i></p>


<blockquote>
<p>
The current practice is to not have throwing copy constructors in
exception classes, because this can lead to <tt>terminate()</tt> as described in
15.5.1 [except.terminate]. Thus calling <tt>terminate()</tt> in this situation seems
consistent and does not introduce any new problems.
</p>

<p>
However, the resolution of core issue 475 may relax this requirement:
</p>

<blockquote>
The CWG agreed with the position that <tt>std::uncaught_exception()</tt> should
return <tt>false</tt> during the copy to the exception object and that <tt>std::terminate()</tt>
should not be called if that constructor exits with an exception.
</blockquote>

<p>
Since throwing copy constructors will no longer call <tt>terminate()</tt>, option
(3) doesn't seem reasonable as it is deemed too drastic a response in a
recoverable situation.
</p>

<p>
Option (2) cannot be adopted by itself, because a potential infinite
recursion will need to be terminated by one of the other options.
</p>

</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Add the following paragraph after 18.7.5 [propagation]/7:
</p>

<blockquote>
<p>
<i>Returns (continued):</i> If the attempt to copy the current exception
object throws an exception, the function returns an <tt>exception_ptr</tt> that
refers to the thrown exception or, if this is not possible, to an
instance of <tt>bad_exception</tt>.
</p>
<p>
[<i>Note:</i> The copy constructor of the thrown exception may also fail, so
the implementation is allowed to substitute a <tt>bad_exception</tt> to avoid
infinite recursion. <i>-- end note.</i>]
</p>
</blockquote>






<hr>
<h3><a name="821"></a>821. Minor cleanup : <tt>unique_ptr</tt></h3>
<p><b>Section:</b> 20.6.11.3.3 [unique.ptr.runtime.modifiers] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Alisdair Meredith <b>Date:</b> 2008-03-30</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Reading resolution of LWG issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#673">673</a> I noticed the following:
</p>

<blockquote>
<pre>void reset(<del>T*</del> <ins>pointer</ins> p = <del>0</del> <ins>pointer()</ins>);
</pre>

<p>
-1- <i>Requires:</i> Does not accept pointer types which are convertible
to <del><tt>T*</tt></del> <ins><tt>pointer</tt></ins> (diagnostic
required). [<i>Note:</i> One implementation technique is to create a private
templated overload. <i>-- end note</i>]
</p>
</blockquote>

<p>
This could be cleaned up by mandating the overload as a public deleted
function.  In addition, we should probably overload <tt>reset</tt> on <tt>nullptr_t</tt>
to be a stronger match than the deleted overload. Words...
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add to class template definition in 20.6.11.3 [unique.ptr.runtime]
</p>

<blockquote>
<pre>// modifiers 
T* release(); 
void reset(T* p = 0); 
<ins>void reset( nullptr_t );</ins>
<ins>template&lt; typename T &gt; void reset( T ) = delete;</ins>
void swap(unique_ptr&amp;&amp; u);
</pre>
</blockquote>

<p>
Update 20.6.11.3.3 [unique.ptr.runtime.modifiers]
</p>

<blockquote>
<pre>void reset(pointer p = pointer());
<ins>void reset(nullptr_t);</ins>
</pre>

<p>
<del>-1- <i>Requires:</i> Does not accept pointer types which are convertible
to <tt>pointer</tt> (diagnostic
required). [<i>Note:</i> One implementation technique is to create a private
templated overload. <i>-- end note</i>]</del>
</p>
<p>
<i>Effects:</i> If <tt>get() == nullptr</tt> there are no effects. Otherwise <tt>get_deleter()(get())</tt>. 
</p>
<p>...</p>
</blockquote>

<p><i>[
Note this wording incorporates resolutions for <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#806">806</a> (New) and <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#673">673</a> (Ready).
]</i></p>






<hr>
<h3><a name="822"></a>822. Object with explicit copy constructor no longer <tt>CopyConstructible</tt></h3>
<p><b>Section:</b> 20.1.1 [utility.arg.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> James Kanze <b>Date:</b> 2008-04-01</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#utility.arg.requirements">active issues</a> in [utility.arg.requirements].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#utility.arg.requirements">issues</a> in [utility.arg.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I just noticed that the following program is legal in C++03, but
is forbidden in the current draft:
</p>

<blockquote><pre>#include &lt;vector&gt;
#include &lt;iostream&gt;

class Toto
{
public:
    Toto() {}
    explicit Toto( Toto const&amp; ) {}
} ;

int
main()
{
    std::vector&lt; Toto &gt; v( 10 ) ;
    return 0 ;
}
</pre></blockquote>

<p>
Is this change intentional?  (And if so, what is the
justification?  I wouldn't call such code good, but I don't see
any reason to break it unless we get something else in return.)
</p>



<p><b>Proposed resolution:</b></p>
<p>
In 20.1.1 [utility.arg.requirements] change Table 33: <tt>MoveConstructible</tt> requirements [moveconstructible]:
</p>

<blockquote>
<table border="1">
<tbody><tr>
<th>expression</th><th>post-condition</th>
</tr>
<tr>
<td><tt>T t<ins>(rv)</ins><del> = rv</del></tt></td><td><tt>t</tt> is equivalent to the value of <tt>rv</tt> before the construction</td>
</tr>
<tr>
<td colspan="2" align="center">...</td>
</tr>
</tbody></table>
</blockquote>

<p>
In 20.1.1 [utility.arg.requirements] change Table 34: <tt>CopyConstructible</tt> requirements [copyconstructible]:
</p>

<blockquote>
<table border="1">
<tbody><tr>
<th>expression</th><th>post-condition</th>
</tr>
<tr>
<td><tt>T t<ins>(u)</ins><del> = u</del></tt></td><td>the value of <tt>u</tt> is unchanged and is equivalent to <tt>t</tt></td>
</tr>
<tr>
<td colspan="2" align="center">...</td>
</tr>
</tbody></table>
</blockquote>





<hr>
<h3><a name="823"></a>823. <tt>identity&lt;void&gt;</tt> seems broken</h3>
<p><b>Section:</b> 20.2.2 [forward] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Walter Brown <b>Date:</b> 2008-04-09</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#forward">active issues</a> in [forward].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#forward">issues</a> in [forward].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
N2588 seems to have added an <tt>operator()</tt> member function to the
<tt>identity&lt;&gt;</tt> helper in 20.2.2 [forward].  I believe this change makes it no
longer possible to instantiate <tt>identity&lt;void&gt;</tt>, as it would require
forming a reference-to-<tt>void</tt> type as this <tt>operator()</tt>'s parameter type.
</p>

<p>
Suggested resolution:  Specialize <tt>identity&lt;void&gt;</tt> so as not to require
the member function's presence.
</p>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="824"></a>824. rvalue ref issue with <tt>basic_string</tt> inserter</h3>
<p><b>Section:</b> 21.3.8.9 [string.io] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Alisdair Meredith <b>Date:</b> 2008-04-10</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#string.io">issues</a> in [string.io].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In the current working paper, the <tt>&lt;string&gt;</tt> header synopsis at the end of
21.2 [string.classes] lists a single <tt>operator&lt;&lt;</tt> overload
for <tt>basic_string</tt>.
</p>

<blockquote><pre>template&lt;class charT, class traits, class Allocator&gt;
 basic_ostream&lt;charT, traits&gt;&amp;
   operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp;&amp; os,
              const basic_string&lt;charT,traits,Allocator&gt;&amp; str);
</pre></blockquote>

<p>
The definition in 21.3.8.9 [string.io] lists two:
</p>

<blockquote><pre>template&lt;class charT, class traits, class Allocator&gt;
 basic_ostream&lt;charT, traits&gt;&amp;
   operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp; os,
              const basic_string&lt;charT,traits,Allocator&gt;&amp; str);

template&lt;class charT, class traits, class Allocator&gt;
 basic_ostream&lt;charT, traits&gt;&amp;
   operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp;&amp; os,
              const basic_string&lt;charT,traits,Allocator&gt;&amp; str);
</pre></blockquote>

<p>
I believe the synopsis in 21.2 [string.classes] is correct, and the first of the two
signatures in 21.3.8.9 [string.io] should be deleted.
</p>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="825"></a>825. Missing rvalues reference stream insert/extract operators?</h3>
<p><b>Section:</b> 19.4.2.1 [syserr.errcode.overview], 20.6.12.2.8
[util.smartptr.shared.io], 22.2.8 [facets.examples], 23.3.5.3
[bitset.operators], 26.3.6 [complex.ops], 27.5 [stream.buffers], 28.9
[re.submatch] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Alisdair Meredith <b>Date:</b> 2008-04-10</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Should the following use rvalues references to stream in insert/extract
operators?
</p>

<ul>
<li>19.4.2.1 [syserr.errcode.overview]</li>
<li>20.6.12.2.8 [util.smartptr.shared.io]</li>
<li>22.2.8 [facets.examples]</li>
<li>23.3.5.3 [bitset.operators]</li>
<li>26.3.6 [complex.ops]</li>
<li>Doubled signatures in 27.5 [stream.buffers] for character inserters
(ref 27.6.2.6.4 [ostream.inserters.character])
+ definition 27.6.2.6.4 [ostream.inserters.character]</li>
<li>28.9 [re.submatch]</li>
</ul>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="826"></a>826. Equivalent of <tt>%'d</tt>, or rather, lack thereof?</h3>
<p><b>Section:</b> 22.2.2.2 [locale.nm.put] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Peter Dimov <b>Date:</b> 2008-04-07</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In the spirit of <tt>printf vs iostream</tt>...
</p>

<p>
POSIX <tt>printf</tt> says that <tt>%'d</tt> should insert grouping characters (and the
implication is that in the absence of <tt>'</tt> no grouping characters are
inserted). The <tt>num_put</tt> facet, on the other hand, seems to always insert
grouping characters. Can this be considered a defect worth fixing for
C++0x? Maybe <tt>ios_base</tt> needs an additional flag?
</p>

<p><i>[
Pablo Halpern:
]</i></p>


<blockquote>
I'm not sure it constitutes a defect, but I would be in favor of adding
another flag (and corresponding manipulator).
</blockquote>

<p><i>[
Martin Sebor:
]</i></p>


<blockquote>
I don't know if it qualifies as a defect but I agree that there
should be an easy way to control whether the thousands separator
should or shouldn't be inserted. A new flag would be in line with
the current design of iostreams (like <tt>boolalpha</tt>, <tt>showpos</tt>, or
<tt>showbase</tt>).
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="827"></a>827. <tt>constexpr shared_ptr::shared_ptr()?</tt></h3>
<p><b>Section:</b> 20.6.12.2.1 [util.smartptr.shared.const] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Peter Dimov <b>Date:</b> 2008-04-11</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#util.smartptr.shared.const">issues</a> in [util.smartptr.shared.const].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Would anyone object to making the default constructor of <tt>shared_ptr</tt> (and
<tt>weak_ptr</tt> and <tt>enable_shared_from_this) constexpr</tt>? This would enable
static initialization for <tt>shared_ptr</tt> variables, eliminating another
unfair advantage of raw pointers.
</p>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="828"></a>828. Static initialization for <tt>std::mutex</tt>?</h3>
<p><b>Section:</b> 30.3.1.1 [thread.mutex.class] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Peter Dimov <b>Date:</b> 2008-04-18</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
[Note: I'm assuming here that 3.6.2 [basic.start.init]/1 will be fixed.]
</p>
<p>
Currently <tt>std::mutex</tt> doesn't support static initialization. This is a
regression with respect to <tt>pthread_mutex_t</tt>, which does. I believe that
we should strive to eliminate such regressions in expressive power where
possible, both to ease migration and to not provide incentives to (or
force) people to forego the C++ primitives in favor of pthreads.
</p>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="829"></a>829. current_exception wording unclear about exception type</h3>
<p><b>Section:</b> 18.7.5 [propagation] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Beman Dawes <b>Date:</b> 2008-04-20</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#propagation">active issues</a> in [propagation].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#propagation">issues</a> in [propagation].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>Consider this code:</p>

<blockquote>
<pre>exception_ptr xp;</pre>
<pre>try {do_something(); }

catch (const runtime_error&amp; ) {xp = current_exception();}

...

rethrow_exception(xp);</pre>
</blockquote>

<p>
Say <code>do_something()</code> throws an exception object of type <code>
range_error</code>. What is the type of the exception object thrown by <code>
rethrow_exception(xp)</code> above? It must have a type of <code>range_error</code>; 
if it were of type <code>runtime_error</code> it still isn't possible to 
propagate an exception and the exception_ptr/current_exception/rethrow_exception 
machinery serves no useful purpose.
</p>

<p>
Unfortunately, the current wording does not explicitly say that. Different 
people read the current wording and come to different conclusions. While it may 
be possible to deduce the correct type from the current wording, it would be 
much clearer to come right out and explicitly say what the type of the referred 
to exception is.
</p>

<p><i>[
Peter adds:
]</i></p>


<blockquote>
<p>
I don't like the proposed resolution of 829. The normative text is
unambiguous that the <tt>exception_ptr</tt> refers to the <em>currently handled
exception</em>. This term has a standard meaning, see 15.3 [except.handle]/8; this is the
exception that <tt>throw;</tt> would rethrow, see 15.1 [except.throw]/7.
</p>
<p>
A better way to address this is to simply add the non-normative example
in question as a clarification. The term <i>currently handled exception</i>
should be italicized and cross-referenced. A [<i>Note:</i> the currently
handled exception is the exception that a throw expression without an
operand (15.1 [except.throw]/7) would rethrow. <i>--end note</i>] is also an option.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>

<p>
After 18.7.5 [propagation] , paragraph 7, add the indicated text:
</p>

<blockquote>
<pre>exception_ptr current_exception();</pre>

<blockquote>
<p>
<i>Returns:</i> <code>exception_ptr</code> object that refers 
to the currently handled exception or a copy of the currently handled 
exception, or a null <code>exception_ptr</code> object if no exception is being handled. If 
the function needs to allocate memory and the attempt fails, it returns an
<code>exception_ptr</code> object that refers to an instance of <code>bad_alloc</code>. 
It is unspecified whether the return values of two successive calls to
<code>current_exception</code> refer to the same exception object. 
[<i>Note:</i> that is, it 
is unspecified whether <code>current_exception</code>
creates a new copy each time it is called.
<i>-- end note</i>]
</p>

<p>
<ins><i>Remarks:</i> The type of the exception object 
referred to by the returned <code>exception_ptr</code> is the most-derived 
type of the currently handled exception.</ins>
</p>

<p>
<i>Throws:</i> nothing.
</p>

</blockquote>
</blockquote>






<hr>
<h3><a name="830"></a>830. Incomplete list of char_traits specializations</h3>
<p><b>Section:</b> 21.1 [char.traits] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Dietmar Khl <b>Date:</b> 2008-04-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#char.traits">active issues</a> in [char.traits].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#char.traits">issues</a> in [char.traits].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
  Paragraph 4 of 21.1 [char.traits] mentions that this
  section specifies two specializations (<code>char_traits&lt;char&gt;</code>
  and (<code>char_traits&lt;wchar_t&gt;</code>). However, there are actually
  four specializations provided, i.e. in addition to the two above also
  <code>char_traits&lt;char16_t&gt;</code> and <code>char_traits&lt;char32_t&gt;</code>).
  I guess this was just an oversight and there is nothing wrong with just
  fixing this.
</p>

<p><i>[
Alisdair adds:
]</i></p>

<blockquote>
<tt>char_traits&lt; char16/32_t &gt;</tt>
should also be added to <tt>&lt;ios_fwd&gt;</tt> in 27.2 [iostream.forward], and all the specializations
taking a <tt>char_traits</tt> parameter in that header.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
  Replace paragraph 4 of 21.1 [char.traits] by:
</p>
<blockquote>
<p>
  This subclause specifies a struct template, <code>char_traits&lt;charT&gt;</code>,
  and four explicit specializations of it, <code>char_traits&lt;char&gt;</code>,
  <code>char_traits&lt;char16_t&gt;</code>, <code>char_traits&lt;char32_t&gt;</code>, and
  <code>char_traits&lt;wchar_t&gt;</code>, all of which appear in the header
  &lt;string&gt; and satisfy the requirements below.
</p>
</blockquote>





<hr>
<h3><a name="831"></a>831. wrong type for not_eof()</h3>
<p><b>Section:</b> 21.1.3 [char.traits.specializations] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Dietmar Khl <b>Date:</b> 2008-04-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#char.traits.specializations">issues</a> in [char.traits.specializations].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
  In Table 56 (Traits requirements) the <tt>not_eof()</tt> member function
  is using an argument of type <i>e</i> which denotes an object of
  type <code>X::int_type</code>. However, the specializations in
  21.1.3 [char.traits.specializations] all use <code>char_type</code>.
  This would effectively mean that the argument type actually can't
  represent EOF in the first place. I'm pretty sure that the type used
  to be <code>int_type</code> which is quite obviously the only sensible
  argument.
</p>
<p>
  This issue is close to being editorial. I suspect that the proposal
  changing this section to include the specializations for <code>char16_t</code>
  and <code>char32_t</code> accidentally used the wrong type.
</p>


<p><b>Proposed resolution:</b></p>
<p>
  In 21.1.3.1 [char.traits.specializations.char],
  21.1.3.2 [char.traits.specializations.char16_t],
  21.1.3.3 [char.traits.specializations.char32_t], and
   [char.traits.specializations.wchar_t] correct the
  argument type from <code>char_type</code> to <code>int_type</code>.
</p>





<hr>
<h3><a name="832"></a>832. Applying constexpr to System error support</h3>
<p><b>Section:</b> 19.4 [syserr] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Beman Dawes <b>Date:</b> 2008-05-14</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#syserr">active issues</a> in [syserr].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#syserr">issues</a> in [syserr].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Initialization of objects of class <tt>error_code</tt>
(19.4.2 [syserr.errcode]) and class
<tt>error_condition</tt> (19.4.3 [syserr.errcondition]) can be made simpler and more reliable by use of
the new <tt>constexpr</tt> feature 
[<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2349.pdf">N2349</a>]
of C++0x. Less code will need to be
generated for both library implementations and user programs when
manipulating constant objects of these types. 
</p>

<p>
This was not proposed originally because the constant expressions
proposal was moving into the standard at about the same time as the
Diagnostics Enhancements proposal 
[<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2241.html">N2241</a>],
and it wasn't desirable to
make the later depend on the former. There were also technical concerns
as to how <tt>constexpr</tt> would apply to references. Those concerns are now
resolved; <tt>constexpr</tt> can't be used for references, and that fact is
reflected in the proposed resolution.
</p>

<p>
Thanks to Jens Maurer, Gabriel Dos Reis, and Bjarne Stroustrup for clarification of <tt>constexpr</tt> requirements.
</p>

<p>
LWG issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#804">804</a> is related in that it raises the question of whether the
exposition only member <tt>cat_</tt> of class <tt>error_code</tt> (19.4.2 [syserr.errcode]) and class
<tt>error_condition</tt> (19.4.3 [syserr.errcondition]) should be presented as a reference or pointer.
While in the context of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#804">804</a> that is arguably an editorial question,
presenting it as a pointer becomes more or less required with this
proposal, given <tt>constexpr</tt> does not play well with references. The
proposed resolution thus changes the private member to a pointer, which
also brings it in sync with real implementations.
</p>


<p><b>Proposed resolution:</b></p>
<p>
The proposed wording assumes the LWG <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#805">805</a> proposed wording has been
applied to the WP, resulting in the former <tt>posix_category</tt> being renamed
<tt>generic_category</tt>. If <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#805">805</a> has not been applied, the names in this
proposal must be adjusted accordingly.
</p>

<p>
Change 19.4.1.1 [syserr.errcat.overview] Class
<tt>error_category</tt> overview <tt>error_category</tt> synopsis  as
indicated:
</p>

<blockquote><pre><del>const error_category&amp; get_generic_category();</del>
<del>const error_category&amp; get_system_category();</del>

<del>static</del> <ins>extern</ins> const error_category<del>&amp;</del><ins>* const</ins> generic_category<del> = get_generic_category()</del>;
<del>static</del> <ins>extern</ins> const error_category<del>&amp;</del><ins>* const</ins> <del>native_category</del> system_category<del> = get_system_category()</del>;
</pre></blockquote>

<p>
Change 19.4.1.5 [syserr.errcat.objects] Error category objects as indicated:
</p>

<blockquote>
<pre><ins>extern</ins> const error_category<del>&amp;</del><ins>* const</ins> <del>get_</del>generic_category<del>()</del>;
</pre>
<p>
<del><i>Returns:</i> A reference</del> <ins><tt>generic_category</tt> shall point</ins>
to <del>an</del> <ins>a statically initialized</ins> object of a type derived from
class <tt>error_category</tt>.
</p>

<p>
<del><i>Remarks:</i></del> The object's <tt>default_error_condition</tt> and <tt>equivalent</tt> virtual
functions shall behave as specified for the class <tt>error_category</tt>. The
object's <tt>name</tt> virtual function shall return a pointer to the string
<tt>"GENERIC"</tt>.
</p>

<pre><ins>extern</ins> const error_category<del>&amp;</del><ins>* const</ins> <del>get_</del>system_category<del>()</del>;
</pre>

<p>
<del><i>Returns:</i> A reference</del> <ins><tt>system_category</tt> shall point</ins>
to <del>an</del> <ins>a statically
initialized</ins> object of a type derived from class <tt>error_category</tt>.
</p>

<p>
<del><i>Remarks:</i></del>  The object's <tt>equivalent</tt> virtual functions shall behave as
specified for class <tt>error_category</tt>. The object's <tt>name</tt> virtual function
shall return a pointer to the string <tt>"system"</tt>. The object's
<tt>default_error_condition</tt> virtual function shall behave as follows:
</p>

<p>
If the argument <tt>ev</tt> corresponds to a POSIX <tt>errno</tt> value <tt>posv</tt>, the function
shall return <tt>error_condition(posv, generic_category)</tt>. Otherwise, the
function shall return <tt>error_condition(ev, system_category)</tt>. What
constitutes correspondence for any given operating system is
unspecified. [<i>Note:</i> The number of potential system error codes is large
and unbounded, and some may not correspond to any POSIX <tt>errno</tt> value.
Thus implementations are given latitude in determining correspondence.
<i>-- end note</i>]
</p>
</blockquote>

<p>
Change 19.4.2.1 [syserr.errcode.overview] Class <tt>error_code</tt> overview as indicated:
</p>

<blockquote><pre>class error_code {
public:
  ...;
  <ins>constexpr</ins> error_code(int val, const error_category<del>&amp;</del><ins>*</ins> cat);
  ...
  void assign(int val, const error_category<del>&amp;</del><ins>*</ins> cat);
  ...
  const error_category<del>&amp;</del><ins>*</ins> category() const;
  ...
private:
  int val_;                    // exposition only
  const error_category<del>&amp;</del><ins>*</ins> cat_; // exposition only
</pre></blockquote>

<p>
Change 19.4.2.2 [syserr.errcode.constructors] Class <tt>error_code</tt> constructors as indicated:
</p>

<blockquote>
<pre><ins>constexpr</ins> error_code(int val, const error_category<del>&amp;</del><ins>*</ins> cat);
</pre>
<p>
<i>Effects:</i> Constructs an object of type <tt>error_code</tt>.
</p>
<p>
<i>Postconditions:</i> <tt>val_ == val</tt> and <tt>cat_ == cat</tt>.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>

<p>
Change 19.4.2.3 [syserr.errcode.modifiers] Class <tt>error_code</tt> modifiers  as indicated:
</p>

<blockquote>
<pre>void assign(int val, const error_category<del>&amp;</del><ins>*</ins> cat);
</pre>
<p>
<i>Postconditions:</i> <tt>val_ == val</tt> and <tt>cat_ == cat</tt>.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>

<p>
Change 19.4.2.4 [syserr.errcode.observers] Class <tt>error_code</tt> observers  as indicated:
</p>

<blockquote>
<pre>const error_category<del>&amp;</del><ins>*</ins> category() const;
</pre>

<p>
<i>Returns:</i> <tt>cat_</tt>.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>

<p>
Change 19.4.3.1 [syserr.errcondition.overview] Class <tt>error_condition</tt> overview   as indicated:
</p>

<blockquote>
<pre>class error_condition {
public:
  ...;
  <ins>constexpr</ins> error_condition(int val, const error_category<del>&amp;</del><ins>*</ins> cat);
  ...
  void assign(int val, const error_category<del>&amp;</del><ins>*</ins> cat);
  ...
  const error_category<del>&amp;</del><ins>*</ins> category() const;
  ...
private:
  int val_;                    // exposition only
  const error_category<del>&amp;</del><ins>*</ins> cat_; // exposition only
</pre>
</blockquote>

<p>
Change 19.4.3.2 [syserr.errcondition.constructors] Class <tt>error_condition</tt> constructors as indicated:
</p>

<blockquote>
<pre>constexpr error_condition(int val, const error_category<del>&amp;</del><ins>*</ins> cat);
</pre>
<p>
<i>Effects:</i> Constructs an object of type <tt>error_condition</tt>.
</p>
<p>
<i>Postconditions:</i> <tt>val_ == val</tt> and <tt>cat_ == cat</tt>.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>

<p>
Change 19.4.3.3 [syserr.errcondition.modifiers] Class <tt>error_condition</tt> modifiers as indicated:
</p>

<blockquote>
<pre>void assign(int val, const error_category<del>&amp;</del><ins>*</ins> cat);
</pre>
<p>
<i>Postconditions:</i> <tt>val_ == val</tt> and <tt>cat_ == cat</tt>.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>

<p>
Change 19.4.3.4 [syserr.errcondition.observers] Class <tt>error_condition</tt> observers as indicated:
</p>

<blockquote>
<pre>const error_category<del>&amp;</del><ins>*</ins> category() const;
</pre>
<p>
<i>Returns:</i> <tt>cat_</tt>.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>

<p>
Throughout 19.4 [syserr] System error support, change "<tt>category().</tt>"  to "<tt>category()-&gt;</tt>".
Appears approximately six times.
</p>

<p>
<i>[Partially Editorial]</i> In 19.4.4 [syserr.compare] Comparison operators,
paragraphs 2 and 4, change "<tt>category.equivalent(</tt>"  to
"<tt>category()-&gt;equivalent(</tt>".
</p>





<hr>
<h3><a name="833"></a>833. Freestanding implementations header list needs review for C++0x</h3>
<p><b>Section:</b> 17.4.1.3 [compliance] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Beman Dawes <b>Date:</b> 2008-05-14</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Once the C++0x standard library is feature complete, the LWG needs to
review 17.4.1.3 [compliance] Freestanding implementations header list to
ensure it reflects LWG consensus.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="834"></a>834. Unique_ptr::pointer requirements underspecified</h3>
<p><b>Section:</b> 20.6.11.2 [unique.ptr.single] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Daniel Krgler <b>Date:</b> 2008-05-14</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#673">673</a> (including recent updates by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#821">821</a>) proposes a useful
extension point for <tt>unique_ptr</tt> by granting support for an optional
<tt>deleter_type::pointer</tt> to act as pointer-like replacement for <tt>element_type*</tt>
(In the following: <tt>pointer</tt>).
</p>
<p>
Unfortunately no requirements are specified for the type <tt>pointer</tt> which has
impact on at least two key features of <tt>unique_ptr</tt>:
</p>

<ol>
<li>Operational fail-safety.</li>
<li>(Well-)Definedness of expressions.</li>
</ol>

<p>
<tt>Unique_ptr</tt> specification makes great efforts to require that essentially *all*
operations cannot throw and therefore adds proper wording to the affected
operations of the deleter as well. If user-provided <tt>pointer</tt>-emulating types
("smart pointers") will be allowed, either *all* throw-nothing clauses have to
be replaced by weaker "An exception is thrown only if <tt>pointer</tt>'s {op} throws
an exception"-clauses or it has to be said explicitly that all used
operations of
<tt>pointer</tt> are required *not* to throw. I understand the main focus of <tt>unique_ptr</tt>
to be as near as possible to the advantages of native pointers which cannot
fail and thus strongly favor the second choice. Also, the alternative position
would make it much harder to write safe and simple template code for
<tt>unique_ptr</tt>. Additionally, I assume that a general statement need to be given
that all of the expressions of <tt>pointer</tt> used to define semantics are required to
be well-formed and well-defined (also as back-end for <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#762">762</a>).
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add the following sentence just at the end of the newly proposed
20.6.11.2 [unique.ptr.single]/p. 3:
</p>

<blockquote>
<tt>unique_ptr&lt;T, D&gt;::pointer</tt>'s operations shall be well-formed, shall have well
defined behavior, and shall not throw exceptions.
</blockquote>





<hr>
<h3><a name="835"></a>835. tying two streams together (correction to DR 581)</h3>
<p><b>Section:</b> 27.4.4.2 [basic.ios.members] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Martin Sebor <b>Date:</b> 2008-05-17</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#basic.ios.members">active issues</a> in [basic.ios.members].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#basic.ios.members">issues</a> in [basic.ios.members].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
       <p>

The fix for
issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#581">581</a>,
now integrated into the working paper, overlooks a couple of minor
problems.

       </p>
       <p>

First, being an unformatted function once again, <code>flush()</code>
is required to create a sentry object whose constructor must, among
other things, flush the tied stream. When two streams are tied
together, either directly or through another intermediate stream
object, flushing one will also cause a call to <code>flush()</code> on
the other tied stream(s) and vice versa, ad infinitum. The program
below demonstrates the problem.

       </p>
       <p>

Second, as Bo Persson notes in his
comp.lang.c++.moderated <a href="http://groups.google.com/group/comp.lang.c++.moderated/tree/browse_frm/thread/f2187794e9cc036d/305df31dc583054a">post</a>,
for streams with the <code>unitbuf</code> flag set such
as <code>std::stderr</code>, the destructor of the sentry object will
again call <code>flush()</code>. This seems to create an infinite
recursion for <code>std::cerr &lt;&lt; std::flush;</code>

       </p>
       <blockquote>
           <pre>#include &lt;iostream&gt;

int main ()
{
   std::cout.tie (&amp;std::cerr);
   std::cerr.tie (&amp;std::cout);
   std::cout &lt;&lt; "cout\n";
   std::cerr &lt;&lt; "cerr\n";
} 
           </pre>
       </blockquote>
   
   <p><b>Proposed resolution:</b></p>
       <p>

I think an easy way to plug the first hole is to add a requires clause
to <code>ostream::tie(ostream *tiestr)</code> requiring the this
pointer not be equal to any pointer on the list starting
with <code>tiestr-&gt;tie()</code>
through <code>tiestr()-&gt;tie()-&gt;tie()</code> and so on. I am not
proposing that we require implementations to traverse this list,
although I think we could since the list is unlikely to be very long.

       </p>
       <p>

Add a <i>Requires</i> clause to 27.4.4.2 [basic.ios.members] withethe following
text:

       </p>
       <blockquote>

<i>Requires:</i> If <code>(tiestr != 0)</code> is
true, <code>tiestr</code> must not be reachable by traversing the
linked list of tied stream objects starting
from <code>tiestr-&gt;tie()</code>.

       </blockquote>
       <p>

In addition, to prevent the infinite recursion that Bo writes about in
his comp.lang.c++.moderated post, I propose to change
27.6.2.4 [ostream::sentry], p2 like so:

       </p>
       <blockquote>

If <code>((os.flags() &amp; ios_base::unitbuf) &amp;&amp;
!uncaught_exception())</code> is true,
calls <del>os.flush()</del> <ins><code>os.rdbuf()-&gt;pubsync()</code></ins>.

       </blockquote>
   



<hr>
<h3><a name="836"></a>836. 
       effects of <code>money_base::space</code> and
       <code>money_base::none</code> on <code>money_get</code>
   </h3>
<p><b>Section:</b> 22.2.6.1.2 [locale.money.get.virtuals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Martin Sebor <b>Date:</b> 2008-05-17</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#locale.money.get.virtuals">active issues</a> in [locale.money.get.virtuals].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.money.get.virtuals">issues</a> in [locale.money.get.virtuals].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
       <p>

In paragraph 2, 22.2.6.1.2 [locale.money.get.virtuals] specifies the following:

       </p>
       <blockquote>

Where <code>space</code> or <code>none</code> appears in the format
pattern, except at the end, optional white space (as recognized
by <code>ct.is</code>) is consumed after any required space.

       </blockquote>
       <p>

This requirement can be (and has been) interpreted two mutually
exclusive ways by different readers. One possible interpretation
is that:

       </p>
       <blockquote>
           <ol>
               <li>

where <code>money_base::space</code> appears in the format, at least
one space is required, and

               </li>
               <li>

where <code>money_base::none</code> appears in the format, space is
allowed but not required.

               </li>
           </ol>
       </blockquote>
       <p>

The other is that:

       </p>
       <blockquote>

where either <code>money_base::space</code> or <code>money_base::none</code> appears in the format, white space is optional.

       </blockquote>
   

   <p><b>Proposed resolution:</b></p>
       <p>

I propose to change the text to make it clear that the first
interpretation is intended, that is, to make following change to
22.2.6.1.2 [locale.money.get.virtuals], p2:

       </p>

       <blockquote>

When <code><ins>money_base::</ins>space</code>
or <code><ins>money_base::</ins>none</code> appears <ins>as the last
element </ins>in the format pattern, <del>except at the end, optional
white space (as recognized by <code>ct.is</code>) is consumed after
any required space.</del> <ins>no white space is consumed. Otherwise,
where <code>money_base::space</code> appears in any of the initial
elements of the format pattern, at least one white space character is
required. Where <code>money_base::none</code> appears in any of the
initial elements of the format pattern, white space is allowed but not
required. In either case, any required followed by all optional white
space (as recognized by <code>ct.is()</code>) is consumed.</ins>
If <code>(str.flags() &amp; str.showbase)</code> is <code>false</code>, ...

       </blockquote>
   



<hr>
<h3><a name="837"></a>837. 
   <code>basic_ios::copyfmt()</code> overly loosely specified
 </h3>
<p><b>Section:</b> 27.4.4.2 [basic.ios.members] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Martin Sebor <b>Date:</b> 2008-05-17</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#basic.ios.members">active issues</a> in [basic.ios.members].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#basic.ios.members">issues</a> in [basic.ios.members].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
   <p>

The <code>basic_ios::copyfmt()</code> member function is specified in 27.4.4.2 [basic.ios.members] to have the following effects:

   </p>
   <blockquote>

<i>Effects</i>: If <code>(this == &amp;rhs)</code> does
nothing. Otherwise assigns to the member objects of <code>*this</code>
the corresponding member objects of <code>rhs</code>, except that

     <ul>
       <li>

<code>rdstate()</code> and <code>rdbuf()</code> are left unchanged;

       </li>
       <li>

<code>exceptions()</code> is altered last by
calling <code>exceptions(rhs.except)</code>

       </li>
       <li>

the contents of arrays pointed at by <code>pword</code>
and <code>iword</code> are copied not the pointers themselves

       </li>
     </ul>
   </blockquote>
   <p>

Since the rest of the text doesn't specify what the member objects
of <code>basic_ios</code> are this seems a little too loose.

   </p>
 

 <p><b>Proposed resolution:</b></p>
   <p>

I propose to tighten things up by adding a <i>Postcondition</i> clause
to the function like so:

   </p>
   <blockquote>
     <i>Postconditions:</i>

     <table border="1">
       <thead>
         <tr>
           <th colspan="2"><code>copyfmt()</code> postconditions</th>
         </tr>
         <tr>
           <th>Element</th>
           <th>Value</th>
         </tr>
       </thead>
       <tbody>
         <tr>
           <td><code>rdbuf()</code></td>
           <td><i>unchanged</i></td>
         </tr>
         <tr> 
           <td><code>tie()</code></td>
           <td><code>rhs.tie()</code></td>
         </tr>
         <tr> 
           <td><code>rdstate()</code></td>
           <td><i>unchanged</i></td>
         </tr>
         <tr> 
           <td><code>exceptions()</code></td>
           <td><code>rhs.exceptions()</code></td>
         </tr>
         <tr> 
           <td><code>flags()</code></td>
           <td><code>rhs.flags()</code></td>
         </tr>
         <tr> 
           <td><code>width()</code></td>
           <td><code>rhs.width()</code></td>
         </tr>
         <tr> 
           <td><code>precision()</code></td>
           <td><code>rhs.precision()</code></td>
         </tr>
         <tr> 
           <td><code>fill()</code></td>
           <td><code>rhs.fill()</code></td>
         </tr>
         <tr> 
           <td><code>getloc()</code></td>
           <td><code>rhs.getloc()</code></td>
         </tr>
       </tbody>
     </table>
   </blockquote>
   <p>

The format of the table follows Table 117 (as
of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2588.pdf">N2588</a>): <code>basic_ios::init()</code>
effects.

   </p>
   <p>

The intent of the new table is not to impose any new requirements or
change existing ones, just to be more explicit about what I believe is
already there.

   </p>
 



<hr>
<h3><a name="838"></a>838. 
   can an <i>end-of-stream</i> iterator become a <i>non-end-of-stream</i> one?
 </h3>
<p><b>Section:</b> 24.5.1 [istream.iterator] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Martin Sebor <b>Date:</b> 2008-05-17</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#istream.iterator">active issues</a> in [istream.iterator].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#istream.iterator">issues</a> in [istream.iterator].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
   <p>

From message c++std-lib-20003...

   </p>
   <p>

The description of <code>istream_iterator</code> in
24.5.1 [istream.iterator], p1 specifies that objects of the
class become the <i>end-of-stream</i> (EOS) iterators under the
following condition (see also issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#836">836</a> another problem
with this paragraph):

   </p>
   <blockquote>

If the end of stream is reached (<code>operator void*()</code> on the
stream returns <code>false</code>), the iterator becomes equal to
the <i>end-of-stream</i> iterator value.

   </blockquote>
   <p>

One possible implementation approach that has been used in practice is
for the iterator to set its <code>in_stream</code> pointer to 0 when
it reaches the end of the stream, just like the default ctor does on
initialization. The problem with this approach is that
the <i>Effects</i> clause for <code>operator++()</code> says the
iterator unconditionally extracts the next value from the stream by
evaluating <code>*in_stream &gt;&gt; value</code>, without checking
for <code>(in_stream == 0)</code>.

   </p>
   <p>

Conformance to the requirement outlined in the <i>Effects</i> clause
can easily be verified in programs by setting <code>eofbit</code>
or <code>failbit</code> in <code>exceptions()</code> of the associated
stream and attempting to iterate past the end of the stream: each
past-the-end access should trigger an exception. This suggests that
some other, more elaborate technique might be intended.

   </p>
   <p>

Another approach, one that allows <code>operator++()</code> to attempt
to extract the value even for EOS iterators (just as long
as <code>in_stream</code> is non-0) is for the iterator to maintain a
flag indicating whether it has reached the end of the stream. This
technique would satisfy the presumed requirement implied by
the <i>Effects</i> clause mentioned above, but it isn't supported by
the exposition-only members of the class (no such flag is shown). This
approach is also found in existing practice.

   </p>
   <p>

The inconsistency between existing implementations raises the question
of whether the intent of the specification is that a non-EOS iterator
that has reached the EOS become a non-EOS one again after the
stream's <code>eofbit</code> flag has been cleared? That is, are the
assertions in the program below expected to pass?

   </p>
   <blockquote>
     <pre>   sstream strm ("1 ");
   istream_iterator eos;
   istream_iterator it (strm);
   int i;
   i = *it++
   assert (it == eos);
   strm.clear ();
   strm &lt;&lt; "2 3 ";
   assert (it != eos);
   i = *++it;
   assert (3 == i);
     </pre>
   </blockquote>
   <p>

Or is it intended that once an iterator becomes EOS it stays EOS until
the end of its lifetime?

   </p>
 

 <p><b>Proposed resolution:</b></p>
   <p>

The discussion of this issue on the reflector suggests that the intent
of the standard is for an <code>istreambuf_iterator</code> that has
reached the EOS to remain in the EOS state until the end of its
lifetime. Implementations that permit EOS iterators to return to a
non-EOS state may only do so as an extension, and only as a result of
calling <code>istream_iterator</code> member functions on EOS
iterators whose behavior is in this case undefined.

   </p>
   <p>

To this end we propose to change 24.5.1 [istream.iterator], p1,
as follows:

   </p>
   <blockquote>

The result of operator-&gt; on an end<ins>-</ins>of<ins>-</ins>stream
is not defined. For any other iterator value a <code>const T*</code>
is returned.<ins> Invoking <code>operator++()</code> on
an <i>end-of-stream</i> iterator is undefined.</ins> It is impossible
to store things into istream iterators...

   </blockquote>
   <p>

Add pre/postconditions to the member function descriptions of <code>istream_iterator</code> like so:

   </p>
   <blockquote>

<pre>istream_iterator();</pre>

<i>Effects</i>: Constructs the <i>end-of-stream</i> iterator.<br>
<ins><i>Postcondition</i>: <code>in_stream == 0</code>.</ins>

<pre>istream_iterator(istream_type &amp;s);</pre>

<i>Effects</i>: Initializes <code>in_stream</code> with &amp;s. value
may be initialized during construction or the first time it is
referenced.<br>
<ins><i>Postcondition</i>: <code>in_stream == &amp;s</code>.</ins>

<pre>istream_iterator(const istream_iterator &amp;x);</pre>

<i>Effects</i>: Constructs a copy of <code>x</code>.<br>
<ins><i>Postcondition</i>: <code>in_stream == x.in_stream</code>.</ins>

<pre>istream_iterator&amp; operator++();</pre>

<ins><i>Requires</i>: <code>in_stream != 0</code>.</ins><br>
<i>Effects</i>: <code>*in_stream &gt;&gt; value</code>.

<pre>istream_iterator&amp; operator++(int);</pre>

<ins><i>Requires</i>: <code>in_stream != 0</code>.</ins><br>
<i>Effects</i>:
   <blockquote><pre>istream_iterator tmp (*this);
*in_stream &gt;&gt; value;
return tmp;
     </pre>
     </blockquote>
   </blockquote>
 




</body></html>