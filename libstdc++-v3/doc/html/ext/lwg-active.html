<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">


<title>C++ Standard Library Active Issues List</title>
<style type="text/css">
p {text-align:justify}
li {text-align:justify}
ins {background-color:#A0FFA0}
del {background-color:#FFA0A0}
</style>
</head><body>
<table>
<tbody><tr>
<td align="left">Doc. no.</td>
<td align="left">N2894=09-0084</td>
</tr>
<tr>
<td align="left">Date:</td>
<td align="left">2009-06-21</td>
</tr>
<tr>
<td align="left">Project:</td>
<td align="left">Programming Language C++</td>
</tr>
<tr>
<td align="left">Reply to:</td>
<td align="left">Howard Hinnant &lt;<a href="mailto:howard.hinnant@gmail.com">howard.hinnant@gmail.com</a>&gt;</td>
</tr>
</tbody></table>
<h1>C++ Standard Library Active Issues List (Revision R65)</h1>

  <p>Reference ISO/IEC IS 14882:2003(E)</p>
  <p>Also see:</p>
  <ul>
      <li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-toc.html">Table of Contents</a> for all library issues.</li>
      <li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html">Index by Section</a> for all library issues.</li>
      <li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html">Index by Status</a> for all library issues.</li>
      <li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html">Library Defect Reports List</a></li>
      <li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html">Library Closed Issues List</a></li>
  </ul>
  <p>The purpose of this document is to record the status of issues
  which have come before the Library Working Group (LWG) of the ANSI
  (J16) and ISO (WG21) C++ Standards Committee. Issues represent
  potential defects in the ISO/IEC IS 14882:2003(E) document.  
  </p>

  <p>This document contains only library issues which are actively being
  considered by the Library Working Group. That is, issues which have a
  status of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>, 
  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a>, and <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Review">Review</a>. See
  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html">Library Defect Reports List</a> for issues considered defects and 
  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html">Library Closed Issues List</a> for issues considered closed.</p>

  <p>The issues in these lists are not necessarily formal ISO Defect
  Reports (DR's). While some issues will eventually be elevated to
  official Defect Report status, other issues will be disposed of in
  other ways. See <a href="#Status">Issue Status</a>.</p>

  <p>Prior to Revision 14, library issues lists existed in two slightly
  different versions; a Committee Version and a Public
  Version. Beginning with Revision 14 the two versions were combined
  into a single version.</p>

  <p>This document includes <i>[bracketed italicized notes]</i> as a
  reminder to the LWG of current progress on issues. Such notes are
  strictly unofficial and should be read with caution as they may be
  incomplete or incorrect. Be aware that LWG support for a particular
  resolution can quickly change if new viewpoints or killer examples are
  presented in subsequent discussions.</p>

  <p>For the most current official version of this document see 
  <a href="http://www.open-std.org/jtc1/sc22/wg21/">http://www.open-std.org/jtc1/sc22/wg21/</a>.
  Requests for further information about this document should include
  the document number above, reference ISO/IEC 14882:2003(E), and be
  submitted to Information Technology Industry Council (ITI), 1250 Eye
  Street NW, Washington, DC 20005.</p>

  <p>Public information as to how to obtain a copy of the C++ Standard,
  join the standards committee, submit an issue, or comment on an issue
  can be found in the comp.std.c++ FAQ.
  </p>


<h2>Revision History</h2>
<ul>
<li>R65: 
2009-06-19 pre-Frankfurt mailing.
<ul>
<li><b>Summary:</b><ul>
<li>378 open issues, up by 32.</li>
<li>765 closed issues, up by 0.</li>
<li>1143 issues total, up by 32.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1115">1115</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1116">1116</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1117">1117</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1118">1118</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1119">1119</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1120">1120</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1121">1121</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1122">1122</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1123">1123</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1124">1124</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1125">1125</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1126">1126</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1127">1127</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1128">1128</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1129">1129</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1130">1130</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1131">1131</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1132">1132</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1133">1133</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1134">1134</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1135">1135</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1136">1136</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1137">1137</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1138">1138</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1139">1139</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1140">1140</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1141">1141</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1142">1142</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1143">1143</a>.</li>
<li>Added the following Open issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1112">1112</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1113">1113</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1114">1114</a>.</li>
<li>Changed the following issues from Pending NAD Editorial to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#937">937</a>.</li>
<li>Changed the following issues from New to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#696">696</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#716">716</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#727">727</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#865">865</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#900">900</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#911">911</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#916">916</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#917">917</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#920">920</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#933">933</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#935">935</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#941">941</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#947">947</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#951">951</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#953">953</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#954">954</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#955">955</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#956">956</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#977">977</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#978">978</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#985">985</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#989">989</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#996">996</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1033">1033</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1054">1054</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1056">1056</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1057">1057</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1059">1059</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1062">1062</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1068">1068</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1069">1069</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1071">1071</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1072">1072</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1076">1076</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1090">1090</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1092">1092</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1096">1096</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1098">1098</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1099">1099</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1105">1105</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1106">1106</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1108">1108</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1110">1110</a>.</li>
<li>Changed the following issues from Review to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#817">817</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#971">971</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#992">992</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1004">1004</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1010">1010</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1012">1012</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1015">1015</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1019">1019</a>.</li>
<li>Changed the following issues from New to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#780">780</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#835">835</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#897">897</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#919">919</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#939">939</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#957">957</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#983">983</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1001">1001</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1080">1080</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1091">1091</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1093">1093</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1094">1094</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1095">1095</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1097">1097</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1102">1102</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1104">1104</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1111">1111</a>.</li>
<li>Changed the following issues from Open to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#921">921</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#987">987</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1087">1087</a>.</li>
<li>Changed the following issues from New to Tentatively NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#568">568</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#701">701</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#702">702</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#785">785</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#863">863</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#903">903</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#912">912</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#918">918</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#946">946</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#995">995</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1074">1074</a>.</li>
<li>Changed the following issues from Open to Tentatively NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#458">458</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#644">644</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#667">667</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#668">668</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#669">669</a>.</li>
<li>Changed the following issues from Review to Tentatively NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#901">901</a>.</li>
<li>Changed the following issues from Tentatively Ready to Tentatively NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#822">822</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#988">988</a>.</li>
<li>Changed the following issues from New to Tentatively NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#837">837</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#862">862</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#867">867</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#927">927</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#945">945</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#952">952</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#969">969</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#972">972</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#973">973</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#979">979</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1058">1058</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1060">1060</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1061">1061</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1077">1077</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1101">1101</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1109">1109</a>.</li>
<li>Changed the following issues from Open to Tentatively NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#424">424</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#825">825</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#830">830</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#884">884</a>.</li>
<li>Changed the following issues from Review to Tentatively NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1023">1023</a>.</li>
<li>Changed the following issues from Open to Tentatively NAD Future: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#96">96</a>.</li>
<li>Changed the following issues from New to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#810">810</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#898">898</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#906">906</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#910">910</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#913">913</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#914">914</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#915">915</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#925">925</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#974">974</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#976">976</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#981">981</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#982">982</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#984">984</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#990">990</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#998">998</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#999">999</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1063">1063</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1067">1067</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1070">1070</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1073">1073</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1100">1100</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1103">1103</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1107">1107</a>.</li>
<li>Changed the following issues from Open to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#688">688</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#814">814</a>.</li>
<li>Changed the following issues from Review to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#899">899</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#907">907</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#909">909</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#934">934</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#938">938</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#940">940</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#943">943</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#950">950</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#965">965</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#970">970</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#975">975</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#986">986</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#991">991</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#993">993</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#994">994</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#997">997</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1002">1002</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1006">1006</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1011">1011</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1013">1013</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1014">1014</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1021">1021</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1024">1024</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1037">1037</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1038">1038</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1039">1039</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1040">1040</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1044">1044</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1045">1045</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1065">1065</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1066">1066</a>.</li>
</ul></li>
</ul>
</li>
<li>R64: 
2009-05-01 mid-term mailing.
<ul>
<li><b>Summary:</b><ul>
<li>346 open issues, up by 19.</li>
<li>765 closed issues, up by 0.</li>
<li>1111 issues total, up by 19.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1093">1093</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1094">1094</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1095">1095</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1096">1096</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1097">1097</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1098">1098</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1099">1099</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1100">1100</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1101">1101</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1102">1102</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1103">1103</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1104">1104</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1105">1105</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1106">1106</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1107">1107</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1108">1108</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1109">1109</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1110">1110</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1111">1111</a>.</li>
<li>Changed the following issues from DR to CD1: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#130">130</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#386">386</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#406">406</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#409">409</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#413">413</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#434">434</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#438">438</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#444">444</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#445">445</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#455">455</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#457">457</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#460">460</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#469">469</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#533">533</a>.</li>
<li>Changed the following issues from Review to New: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1070">1070</a>.</li>
</ul></li>
</ul>
</li>
<li>R63: 
2009-03-20 post-Summit mailing.
<ul>
<li><b>Summary:</b><ul>
<li>327 open issues, up by 96.</li>
<li>765 closed issues, up by 14.</li>
<li>1092 issues total, up by 110.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following NAD Editorial issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1022">1022</a>.</li>
<li>Added the following NAD Future issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1025">1025</a>.</li>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#983">983</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#984">984</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#985">985</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#989">989</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#990">990</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#995">995</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#996">996</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#998">998</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#999">999</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1001">1001</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1033">1033</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1054">1054</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1056">1056</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1057">1057</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1058">1058</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1059">1059</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1060">1060</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1061">1061</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1062">1062</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1063">1063</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1067">1067</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1068">1068</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1069">1069</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1071">1071</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1072">1072</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1073">1073</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1074">1074</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1076">1076</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1077">1077</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1080">1080</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1090">1090</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1091">1091</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1092">1092</a>.</li>
<li>Added the following Open issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#987">987</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1000">1000</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1007">1007</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1008">1008</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1016">1016</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1017">1017</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1018">1018</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1020">1020</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1026">1026</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1027">1027</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1028">1028</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1029">1029</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1030">1030</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1031">1031</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1032">1032</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1034">1034</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1035">1035</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1036">1036</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1041">1041</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1042">1042</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1046">1046</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1048">1048</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1051">1051</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1052">1052</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1053">1053</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1055">1055</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1064">1064</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1075">1075</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1078">1078</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1079">1079</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1081">1081</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1082">1082</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1083">1083</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1084">1084</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1085">1085</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1086">1086</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1087">1087</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1088">1088</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1089">1089</a>.</li>
<li>Added the following Review issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#986">986</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#991">991</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#992">992</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#993">993</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#994">994</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#997">997</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1002">1002</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1003">1003</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1004">1004</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1005">1005</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1006">1006</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1009">1009</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1010">1010</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1011">1011</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1012">1012</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1013">1013</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1014">1014</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1015">1015</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1019">1019</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1021">1021</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1023">1023</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1024">1024</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1037">1037</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1038">1038</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1039">1039</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1040">1040</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1043">1043</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1044">1044</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1045">1045</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1047">1047</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1049">1049</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1050">1050</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1065">1065</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1066">1066</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1070">1070</a>.</li>
<li>Added the following Tentatively Ready issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#988">988</a>.</li>
<li>Changed the following issues from New to Dup: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#905">905</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#942">942</a>.</li>
<li>Changed the following issues from New to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#980">980</a>.</li>
<li>Changed the following issues from New to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#874">874</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#875">875</a>.</li>
<li>Changed the following issues from Open to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#732">732</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#793">793</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#794">794</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#800">800</a>.</li>
<li>Changed the following issues from Pending NAD Editorial to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#683">683</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#892">892</a>.</li>
<li>Changed the following issues from Ready to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#803">803</a>.</li>
<li>Changed the following issues from NAD to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#466">466</a>.</li>
<li>Changed the following issues from NAD Future to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#111">111</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#138">138</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#149">149</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#219">219</a>.</li>
<li>Changed the following issues from New to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#880">880</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#891">891</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#893">893</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#902">902</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#908">908</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#921">921</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#923">923</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#924">924</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#926">926</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#930">930</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#936">936</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#944">944</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#958">958</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#959">959</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#960">960</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#961">961</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#962">962</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#963">963</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#964">964</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#966">966</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#967">967</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#968">968</a>.</li>
<li>Changed the following issues from Ready to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#788">788</a>.</li>
<li>Changed the following issues from New to Pending NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#937">937</a>.</li>
<li>Changed the following issues from New to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#879">879</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#899">899</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#901">901</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#907">907</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#909">909</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#929">929</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#934">934</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#938">938</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#940">940</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#943">943</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#950">950</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#965">965</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#970">970</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#971">971</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#975">975</a>.</li>
<li>Changed the following issues from Open to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#817">817</a>.</li>
<li>Changed the following issues from New to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#904">904</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#922">922</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#928">928</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#931">931</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#932">932</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#948">948</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#949">949</a>.</li>
<li>Changed the following issues from Open to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#890">890</a>.</li>
<li>Changed the following issues from Review to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#765">765</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#822">822</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#853">853</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#869">869</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#878">878</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#888">888</a>.</li>
<li>Changed the following issues from Ready to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#752">752</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#753">753</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#758">758</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#821">821</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#866">866</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#894">894</a>.</li>
</ul></li>
</ul>
</li>
<li>R62: 
2009-02-06 pre-Summit mailing.
<ul>
<li><b>Summary:</b><ul>
<li>231 open issues, up by 44.</li>
<li>751 closed issues, up by 0.</li>
<li>982 issues total, up by 44.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#939">939</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#940">940</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#941">941</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#942">942</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#943">943</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#944">944</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#945">945</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#946">946</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#947">947</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#948">948</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#949">949</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#950">950</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#951">951</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#952">952</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#953">953</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#954">954</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#955">955</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#956">956</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#957">957</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#958">958</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#959">959</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#960">960</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#961">961</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#962">962</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#963">963</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#964">964</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#965">965</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#966">966</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#967">967</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#968">968</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#969">969</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#970">970</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#971">971</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#972">972</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#973">973</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#974">974</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#975">975</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#976">976</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#977">977</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#978">978</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#979">979</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#980">980</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#981">981</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#982">982</a>.</li>
</ul></li>
</ul>
</li>
<li>R61: 
2008-12-05 mid-term mailing.
<ul>
<li><b>Summary:</b><ul>
<li>187 open issues, up by 20.</li>
<li>751 closed issues, up by 0.</li>
<li>938 issues total, up by 20.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#919">919</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#920">920</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#921">921</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#922">922</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#923">923</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#924">924</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#925">925</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#926">926</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#927">927</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#928">928</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#929">929</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#930">930</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#931">931</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#932">932</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#933">933</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#934">934</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#935">935</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#936">936</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#937">937</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#938">938</a>.</li>
</ul></li>
</ul>
</li>
<li>R60: 
2008-10-03 post-San Francisco mailing.
<ul>
<li><b>Summary:</b><ul>
<li>167 open issues, down by 25.</li>
<li>751 closed issues, up by 65.</li>
<li>918 issues total, up by 40.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following CD1 issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#882">882</a>.</li>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#879">879</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#880">880</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#891">891</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#893">893</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#897">897</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#898">898</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#899">899</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#900">900</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#901">901</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#902">902</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#903">903</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#904">904</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#905">905</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#906">906</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#907">907</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#908">908</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#909">909</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#910">910</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#911">911</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#912">912</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#913">913</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#914">914</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#915">915</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#916">916</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#917">917</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#918">918</a>.</li>
<li>Added the following Open issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#881">881</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#883">883</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#884">884</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#885">885</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#886">886</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#887">887</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#889">889</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#890">890</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#895">895</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#896">896</a>.</li>
<li>Added the following Pending NAD Editorial issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#892">892</a>.</li>
<li>Added the following Ready issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#894">894</a>.</li>
<li>Added the following Review issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#888">888</a>.</li>
<li>Changed the following issues from New to CD1: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#818">818</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#820">820</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#843">843</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#845">845</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#846">846</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#856">856</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#858">858</a>.</li>
<li>Changed the following issues from Ready to CD1: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#180">180</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#387">387</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#396">396</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#522">522</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#629">629</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#691">691</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#713">713</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#714">714</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#720">720</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#728">728</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#762">762</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#769">769</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#771">771</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#772">772</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#776">776</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#779">779</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#787">787</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#805">805</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#806">806</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#807">807</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#808">808</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#809">809</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#813">813</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#824">824</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#829">829</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#842">842</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#844">844</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#848">848</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#850">850</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#852">852</a>.</li>
<li>Changed the following issues from Review to CD1: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#23">23</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#675">675</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#692">692</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#698">698</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#709">709</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#734">734</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#804">804</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#823">823</a>.</li>
<li>Changed the following issues from WP to CD1: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#44">44</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#49">49</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#76">76</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#91">91</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#92">92</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#98">98</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#103">103</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#109">109</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#117">117</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#118">118</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#120">120</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#123">123</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#136">136</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#153">153</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#165">165</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#167">167</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#171">171</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#179">179</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#182">182</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#183">183</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#184">184</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#185">185</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#186">186</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#187">187</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#198">198</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#200">200</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#201">201</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#202">202</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#206">206</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#214">214</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#221">221</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#225">225</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#226">226</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#228">228</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#229">229</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#230">230</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#231">231</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#232">232</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#233">233</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#234">234</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#235">235</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#237">237</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#238">238</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#239">239</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#240">240</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#241">241</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#242">242</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#243">243</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#247">247</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#248">248</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#250">250</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#251">251</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#252">252</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#253">253</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#254">254</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#256">256</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#258">258</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#259">259</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#260">260</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#261">261</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#262">262</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#263">263</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#264">264</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#265">265</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#266">266</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#268">268</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#270">270</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#271">271</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#272">272</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#273">273</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#274">274</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#275">275</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#276">276</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#278">278</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#280">280</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#281">281</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#282">282</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#283">283</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#284">284</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#285">285</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#286">286</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#288">288</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#291">291</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#292">292</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#294">294</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#295">295</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#297">297</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#298">298</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#300">300</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#301">301</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#303">303</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#305">305</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#306">306</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#307">307</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#308">308</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#310">310</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#311">311</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#312">312</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#315">315</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#316">316</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#317">317</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#318">318</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#319">319</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#320">320</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#321">321</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#322">322</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#324">324</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#325">325</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#327">327</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#328">328</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#329">329</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#331">331</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#333">333</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#334">334</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#335">335</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#336">336</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#337">337</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#338">338</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#339">339</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#340">340</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#341">341</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#345">345</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#346">346</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#347">347</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#349">349</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#352">352</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#354">354</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#355">355</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#358">358</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#359">359</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#360">360</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#362">362</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#363">363</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#364">364</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#365">365</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#369">369</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#370">370</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#371">371</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#373">373</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#375">375</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#376">376</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#379">379</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#380">380</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#381">381</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#383">383</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#384">384</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#389">389</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#391">391</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#395">395</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#400">400</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#401">401</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#402">402</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#403">403</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#404">404</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#405">405</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#407">407</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#410">410</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#411">411</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#412">412</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#414">414</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#415">415</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#416">416</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#420">420</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#422">422</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#425">425</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#426">426</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#428">428</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#432">432</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#435">435</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#436">436</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#441">441</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#442">442</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#443">443</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#448">448</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#449">449</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#453">453</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#456">456</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#461">461</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#464">464</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#465">465</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#467">467</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#468">468</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#474">474</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#475">475</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#478">478</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#488">488</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#495">495</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#496">496</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#497">497</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#505">505</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#507">507</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#508">508</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#518">518</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#519">519</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#520">520</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#521">521</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#524">524</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#527">527</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#530">530</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#531">531</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#534">534</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#535">535</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#537">537</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#538">538</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#540">540</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#541">541</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#542">542</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#543">543</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#545">545</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#550">550</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#551">551</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#552">552</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#559">559</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#561">561</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#562">562</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#563">563</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#566">566</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#567">567</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#574">574</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#575">575</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#576">576</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#577">577</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#578">578</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#581">581</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#586">586</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#589">589</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#593">593</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#595">595</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#596">596</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#607">607</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#608">608</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#609">609</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#610">610</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#611">611</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#612">612</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#613">613</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#616">616</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#618">618</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#619">619</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#620">620</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#621">621</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#622">622</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#623">623</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#624">624</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#628">628</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#634">634</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#638">638</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#640">640</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#643">643</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#646">646</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#650">650</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#651">651</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#652">652</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#654">654</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#655">655</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#660">660</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#661">661</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#664">664</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#665">665</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#666">666</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#672">672</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#673">673</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#674">674</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#677">677</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#678">678</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#679">679</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#680">680</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#681">681</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#682">682</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#685">685</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#687">687</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#689">689</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#693">693</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#694">694</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#695">695</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#699">699</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#700">700</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#703">703</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#705">705</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#706">706</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#710">710</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#712">712</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#715">715</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#722">722</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#740">740</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#743">743</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#744">744</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#746">746</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#749">749</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#755">755</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#759">759</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#761">761</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#766">766</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#768">768</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#770">770</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#775">775</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#777">777</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#778">778</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#781">781</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#782">782</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#783">783</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#789">789</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#792">792</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#798">798</a>.</li>
<li>Changed the following issues from Open to Dup: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#670">670</a>.</li>
<li>Changed the following issues from New to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#849">849</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#855">855</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#871">871</a>.</li>
<li>Changed the following issues from Open to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#454">454</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#832">832</a>.</li>
<li>Changed the following issues from New to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#811">811</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#812">812</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#841">841</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#864">864</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#870">870</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#872">872</a>.</li>
<li>Changed the following issues from Open to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#299">299</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#484">484</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#556">556</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#631">631</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#676">676</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#704">704</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#724">724</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#742">742</a>.</li>
<li>Changed the following issues from Pending NAD Editorial to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#532">532</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#594">594</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#717">717</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#725">725</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#738">738</a>.</li>
<li>Changed the following issues from New to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#721">721</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#751">751</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#814">814</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#816">816</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#817">817</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#819">819</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#827">827</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#836">836</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#838">838</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#847">847</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#857">857</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#859">859</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#860">860</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#861">861</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#868">868</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#873">873</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#876">876</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#877">877</a>.</li>
<li>Changed the following issues from Pending NAD Editorial to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#424">424</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#625">625</a>.</li>
<li>Changed the following issues from Review to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#851">851</a>.</li>
<li>Changed the following issues from New to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#788">788</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#821">821</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#866">866</a>.</li>
<li>Changed the following issues from Open to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#753">753</a>.</li>
<li>Changed the following issues from Review to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#752">752</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#758">758</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#803">803</a>.</li>
<li>Changed the following issues from New to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#765">765</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#822">822</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#853">853</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#854">854</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#869">869</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#878">878</a>.</li>
<li>Changed the following issues from TC to TC1: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1">1</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#3">3</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#5">5</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#7">7</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#8">8</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#9">9</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#11">11</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#13">13</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#14">14</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#15">15</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#16">16</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#17">17</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#18">18</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#19">19</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#20">20</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#21">21</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#22">22</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#24">24</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#25">25</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#26">26</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#27">27</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#28">28</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#29">29</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#30">30</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#31">31</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#32">32</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#33">33</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#34">34</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#35">35</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#36">36</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#37">37</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#38">38</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#39">39</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#40">40</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#41">41</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#42">42</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#46">46</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#47">47</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#48">48</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#50">50</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#51">51</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#52">52</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#53">53</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#54">54</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#55">55</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#56">56</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#57">57</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#59">59</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#60">60</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#61">61</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#62">62</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#63">63</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#64">64</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#66">66</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#68">68</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#69">69</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#70">70</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#71">71</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#74">74</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#75">75</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#78">78</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#79">79</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#80">80</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#83">83</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#86">86</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#90">90</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#106">106</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#108">108</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#110">110</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#112">112</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#114">114</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#115">115</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#119">119</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#122">122</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#124">124</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#125">125</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#126">126</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#127">127</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#129">129</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#132">132</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#133">133</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#134">134</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#137">137</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#139">139</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#141">141</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#142">142</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#144">144</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#146">146</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#147">147</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#148">148</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#150">150</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#151">151</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#152">152</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#154">154</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#155">155</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#156">156</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#158">158</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#159">159</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#160">160</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#161">161</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#164">164</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#168">168</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#169">169</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#170">170</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#172">172</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#173">173</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#174">174</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#175">175</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#176">176</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#181">181</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#189">189</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#193">193</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#195">195</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#199">199</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#208">208</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#209">209</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#210">210</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#211">211</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#212">212</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#217">217</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#220">220</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#222">222</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#223">223</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#224">224</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#227">227</a>.</li>
</ul></li>
</ul>
</li>
<li>R59: 
2008-08-22 pre-San Francisco mailing.
<ul>
<li><b>Summary:</b><ul>
<li>192 open issues, up by 9.</li>
<li>686 closed issues, up by 0.</li>
<li>878 issues total, up by 9.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#870">870</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#871">871</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#872">872</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#873">873</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#874">874</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#875">875</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#876">876</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#877">877</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#878">878</a>.</li>
</ul></li>
</ul>
</li>
<li>R58: 
2008-07-28 mid-term mailing.
<ul>
<li><b>Summary:</b><ul>
<li>183 open issues, up by 12.</li>
<li>686 closed issues, down by 4.</li>
<li>869 issues total, up by 8.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#862">862</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#863">863</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#864">864</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#865">865</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#866">866</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#867">867</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#868">868</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#869">869</a>.</li>
<li>Changed the following issues from Pending NAD Editorial to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#393">393</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#557">557</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#592">592</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#754">754</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#757">757</a>.</li>
<li>Changed the following issues from Pending WP to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#644">644</a>.</li>
<li>Changed the following issues from WP to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#387">387</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#629">629</a>.</li>
<li>Changed the following issues from Pending NAD Editorial to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#709">709</a>.</li>
</ul></li>
</ul>
</li>
<li>R57: 
2008-06-27 post-Sophia Antipolis mailing.
<ul>
<li><b>Summary:</b><ul>
<li>171 open issues, down by 20.</li>
<li>690 closed issues, up by 43.</li>
<li>861 issues total, up by 23.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following NAD issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#840">840</a>.</li>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#841">841</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#843">843</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#845">845</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#846">846</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#847">847</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#849">849</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#853">853</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#854">854</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#855">855</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#856">856</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#857">857</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#858">858</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#859">859</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#860">860</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#861">861</a>.</li>
<li>Added the following Open issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#839">839</a>.</li>
<li>Added the following Ready issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#842">842</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#844">844</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#848">848</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#850">850</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#852">852</a>.</li>
<li>Added the following Review issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#851">851</a>.</li>
<li>Changed the following issues from New to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#826">826</a>.</li>
<li>Changed the following issues from Open to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#570">570</a>.</li>
<li>Changed the following issues from New to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#786">786</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#831">831</a>.</li>
<li>Changed the following issues from Open to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#756">756</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#767">767</a>.</li>
<li>Changed the following issues from New to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#723">723</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#726">726</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#794">794</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#815">815</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#825">825</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#830">830</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#833">833</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#834">834</a>.</li>
<li>Changed the following issues from Ready to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#471">471</a>.</li>
<li>Changed the following issues from Review to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#539">539</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#711">711</a>.</li>
<li>Changed the following issues from New to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#713">713</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#714">714</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#769">769</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#772">772</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#779">779</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#787">787</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#805">805</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#806">806</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#807">807</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#808">808</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#809">809</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#813">813</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#824">824</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#829">829</a>.</li>
<li>Changed the following issues from Open to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#180">180</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#396">396</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#522">522</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#720">720</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#762">762</a>.</li>
<li>Changed the following issues from Review to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#691">691</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#728">728</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#771">771</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#776">776</a>.</li>
<li>Changed the following issues from New to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#692">692</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#698">698</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#752">752</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#804">804</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#823">823</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#828">828</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#832">832</a>.</li>
<li>Changed the following issues from Open to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#23">23</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#675">675</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#734">734</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#803">803</a>.</li>
<li>Changed the following issues from Ready to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#758">758</a>.</li>
<li>Changed the following issues from Ready to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#387">387</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#518">518</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#550">550</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#574">574</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#595">595</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#596">596</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#612">612</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#618">618</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#629">629</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#638">638</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#672">672</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#673">673</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#685">685</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#710">710</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#715">715</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#722">722</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#740">740</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#743">743</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#744">744</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#746">746</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#749">749</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#755">755</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#759">759</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#761">761</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#766">766</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#768">768</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#770">770</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#775">775</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#777">777</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#778">778</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#781">781</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#782">782</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#783">783</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#789">789</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#792">792</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#798">798</a>.</li>
</ul></li>
</ul>
</li>
<li>R56: 
2008-05-16 pre-Sophia Antipolis mailing.
<ul>
<li><b>Summary:</b><ul>
<li>191 open issues, up by 24.</li>
<li>647 closed issues, up by 1.</li>
<li>838 issues total, up by 25.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#814">814</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#815">815</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#816">816</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#817">817</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#818">818</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#819">819</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#820">820</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#821">821</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#822">822</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#823">823</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#824">824</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#825">825</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#826">826</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#827">827</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#828">828</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#829">829</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#830">830</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#831">831</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#832">832</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#833">833</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#834">834</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#835">835</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#836">836</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#837">837</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#838">838</a>.</li>
<li>Changed the following issues from New to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#802">802</a>.</li>
</ul></li>
</ul>
</li>
<li>R55: 
2008-03-14 post-Bellevue mailing.
<ul>
<li><b>Summary:</b><ul>
<li>167 open issues, down by 39.</li>
<li>646 closed issues, up by 65.</li>
<li>813 issues total, up by 26.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following Dup issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#795">795</a>.</li>
<li>Added the following NAD issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#790">790</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#791">791</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#796">796</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#797">797</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#799">799</a>.</li>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#788">788</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#794">794</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#802">802</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#804">804</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#805">805</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#806">806</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#807">807</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#808">808</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#809">809</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#810">810</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#811">811</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#812">812</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#813">813</a>.</li>
<li>Added the following Open issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#793">793</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#800">800</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#801">801</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#803">803</a>.</li>
<li>Added the following Ready issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#789">789</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#792">792</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#798">798</a>.</li>
<li>Changed the following issues from NAD Future to Dup: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#116">116</a>.</li>
<li>Changed the following issues from NAD Future to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#188">188</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#323">323</a>.</li>
<li>Changed the following issues from New to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#729">729</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#730">730</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#731">731</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#733">733</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#735">735</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#736">736</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#737">737</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#739">739</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#741">741</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#745">745</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#748">748</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#763">763</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#764">764</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#773">773</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#784">784</a>.</li>
<li>Changed the following issues from Open to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#388">388</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#462">462</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#579">579</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#627">627</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#653">653</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#686">686</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#707">707</a>.</li>
<li>Changed the following issues from NAD Future to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#140">140</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#390">390</a>.</li>
<li>Changed the following issues from Open to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#529">529</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#626">626</a>.</li>
<li>Changed the following issues from Review to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#645">645</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#684">684</a>.</li>
<li>Changed the following issues from NAD Future to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#128">128</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#180">180</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#190">190</a>.</li>
<li>Changed the following issues from New to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#617">617</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#718">718</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#719">719</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#720">720</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#724">724</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#732">732</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#734">734</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#742">742</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#747">747</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#750">750</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#753">753</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#756">756</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#760">760</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#762">762</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#767">767</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#774">774</a>.</li>
<li>Changed the following issues from Ready to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#675">675</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#676">676</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#688">688</a>.</li>
<li>Changed the following issues from New to Pending NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#709">709</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#717">717</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#725">725</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#738">738</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#754">754</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#757">757</a>.</li>
<li>Changed the following issues from Open to Pending NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#424">424</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#557">557</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#625">625</a>.</li>
<li>Changed the following issues from New to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#710">710</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#715">715</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#722">722</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#740">740</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#743">743</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#744">744</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#746">746</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#749">749</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#755">755</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#758">758</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#759">759</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#761">761</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#766">766</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#768">768</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#770">770</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#775">775</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#777">777</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#778">778</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#781">781</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#782">782</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#783">783</a>.</li>
<li>Changed the following issues from Open to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#387">387</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#471">471</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#550">550</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#612">612</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#629">629</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#673">673</a>.</li>
<li>Changed the following issues from Review to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#518">518</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#574">574</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#596">596</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#618">618</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#638">638</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#672">672</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#685">685</a>.</li>
<li>Changed the following issues from New to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#711">711</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#728">728</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#771">771</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#776">776</a>.</li>
<li>Changed the following issues from Open to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#539">539</a>.</li>
<li>Changed the following issues from Ready to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#561">561</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#562">562</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#563">563</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#567">567</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#581">581</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#620">620</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#621">621</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#622">622</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#623">623</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#624">624</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#661">661</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#664">664</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#665">665</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#666">666</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#674">674</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#679">679</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#680">680</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#687">687</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#689">689</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#693">693</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#694">694</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#695">695</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#700">700</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#703">703</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#705">705</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#706">706</a>.</li>
<li>Changed the following issues from Tentatively Ready to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#527">527</a>.</li>
</ul></li>
</ul>
</li>
<li>R54: 
2008-02-01 pre-Bellevue mailing.
<ul>
<li><b>Summary:</b><ul>
<li>206 open issues, up by 23.</li>
<li>581 closed issues, up by 0.</li>
<li>787 issues total, up by 23.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#765">765</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#766">766</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#767">767</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#768">768</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#769">769</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#770">770</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#771">771</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#772">772</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#773">773</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#774">774</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#775">775</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#776">776</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#777">777</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#778">778</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#779">779</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#780">780</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#781">781</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#782">782</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#783">783</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#784">784</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#785">785</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#786">786</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#787">787</a>.</li>
<li>Changed the following issues from NAD Future to Dup: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#105">105</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#348">348</a>.</li>
<li>Changed the following issues from NAD Future to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#353">353</a>.</li>
<li>Changed the following issues from New to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#697">697</a>.</li>
<li>Changed the following issues from NAD Future to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#388">388</a>.</li>
<li>Changed the following issues from Open to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#527">527</a>.</li>
</ul></li>
</ul>
</li>
<li>R53: 
2007-12-09 mid-term mailing.
<ul>
<li><b>Summary:</b><ul>
<li>183 open issues, up by 11.</li>
<li>581 closed issues, down by 1.</li>
<li>764 issues total, up by 10.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#755">755</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#756">756</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#757">757</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#758">758</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#759">759</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#760">760</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#761">761</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#762">762</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#763">763</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#764">764</a>.</li>
<li>Changed the following issues from NAD to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#463">463</a>.</li>
<li>Changed the following issues from Pending WP to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#607">607</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#608">608</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#654">654</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#655">655</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#677">677</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#682">682</a>.</li>
</ul></li>
</ul>
</li>
<li>R52: 
2007-10-19 post-Kona mailing.
<ul>
<li><b>Summary:</b><ul>
<li>172 open issues, up by 4.</li>
<li>582 closed issues, up by 27.</li>
<li>754 issues total, up by 31.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#724">724</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#725">725</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#726">726</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#727">727</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#728">728</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#729">729</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#730">730</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#731">731</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#732">732</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#733">733</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#734">734</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#735">735</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#736">736</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#737">737</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#738">738</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#739">739</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#740">740</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#741">741</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#742">742</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#743">743</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#744">744</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#745">745</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#746">746</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#747">747</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#748">748</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#749">749</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#750">750</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#751">751</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#752">752</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#753">753</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#754">754</a>.</li>
<li>Changed the following issues from NAD Future to Dup: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#77">77</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#350">350</a>.</li>
<li>Changed the following issues from New to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#639">639</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#657">657</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#663">663</a>.</li>
<li>Changed the following issues from Open to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#548">548</a>.</li>
<li>Changed the following issues from New to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#546">546</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#550">550</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#564">564</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#565">565</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#573">573</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#585">585</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#588">588</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#627">627</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#629">629</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#630">630</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#632">632</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#635">635</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#653">653</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#659">659</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#667">667</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#668">668</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#669">669</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#670">670</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#671">671</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#673">673</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#686">686</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#704">704</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#707">707</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#708">708</a>.</li>
<li>Changed the following issues from New to Pending NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#393">393</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#592">592</a>.</li>
<li>Changed the following issues from New to Pending WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#607">607</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#608">608</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#654">654</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#655">655</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#677">677</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#682">682</a>.</li>
<li>Changed the following issues from New to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#561">561</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#562">562</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#563">563</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#567">567</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#581">581</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#595">595</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#620">620</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#621">621</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#622">622</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#623">623</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#624">624</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#661">661</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#664">664</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#665">665</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#666">666</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#674">674</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#675">675</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#676">676</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#679">679</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#687">687</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#688">688</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#689">689</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#693">693</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#694">694</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#695">695</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#700">700</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#703">703</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#705">705</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#706">706</a>.</li>
<li>Changed the following issues from Open to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#680">680</a>.</li>
<li>Changed the following issues from New to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#574">574</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#596">596</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#618">618</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#638">638</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#645">645</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#672">672</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#684">684</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#685">685</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#691">691</a>.</li>
<li>Changed the following issues from New to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#552">552</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#634">634</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#650">650</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#651">651</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#652">652</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#678">678</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#681">681</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#699">699</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#712">712</a>.</li>
<li>Changed the following issues from Open to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#258">258</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#401">401</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#524">524</a>.</li>
<li>Changed the following issues from Ready to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#488">488</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#577">577</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#660">660</a>.</li>
</ul></li>
</ul>
</li>
<li>R51: 
2007-09-09 pre-Kona mailing.
<ul>
<li><b>Summary:</b><ul>
<li>168 open issues, up by 15.</li>
<li>555 closed issues, up by 0.</li>
<li>723 issues total, up by 15.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#709">709</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#710">710</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#711">711</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#712">712</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#713">713</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#714">714</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#715">715</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#716">716</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#717">717</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#718">718</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#719">719</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#720">720</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#721">721</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#722">722</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#723">723</a>.</li>
</ul></li>
</ul>
</li>
<li>R50: 
2007-08-05 post-Toronto mailing.
<ul>
<li><b>Summary:</b><ul>
<li>153 open issues, down by 5.</li>
<li>555 closed issues, up by 17.</li>
<li>708 issues total, up by 12.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#697">697</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#698">698</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#699">699</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#700">700</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#701">701</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#702">702</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#703">703</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#704">704</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#705">705</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#706">706</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#707">707</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#708">708</a>.</li>
<li>Changed the following issues from New to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#583">583</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#584">584</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#662">662</a>.</li>
<li>Changed the following issues from Open to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#528">528</a>.</li>
<li>Changed the following issues from New to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#637">637</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#647">647</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#658">658</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#690">690</a>.</li>
<li>Changed the following issues from Open to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#525">525</a>.</li>
<li>Changed the following issues from Pending NAD Editorial to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#553">553</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#571">571</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#591">591</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#633">633</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#636">636</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#641">641</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#642">642</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#648">648</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#649">649</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#656">656</a>.</li>
<li>Changed the following issues from New to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#579">579</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#631">631</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#680">680</a>.</li>
<li>Changed the following issues from Pending WP to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#258">258</a>.</li>
<li>Changed the following issues from Ready to Pending WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#644">644</a>.</li>
<li>Changed the following issues from New to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#577">577</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#660">660</a>.</li>
<li>Changed the following issues from Open to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#488">488</a>.</li>
<li>Changed the following issues from Open to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#518">518</a>.</li>
<li>Changed the following issues from Ready to TRDec: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#604">604</a>.</li>
<li>Changed the following issues from DR to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#453">453</a>.</li>
<li>Changed the following issues from Ready to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#531">531</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#551">551</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#566">566</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#628">628</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#640">640</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#643">643</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#646">646</a>.</li>
</ul></li>
</ul>
</li>
<li>R49: 
2007-06-23 pre-Toronto mailing.
<ul>
<li><b>Summary:</b><ul>
<li>158 open issues, up by 13.</li>
<li>538 closed issues, up by 7.</li>
<li>696 issues total, up by 20.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#677">677</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#678">678</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#679">679</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#680">680</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#681">681</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#682">682</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#684">684</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#685">685</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#686">686</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#687">687</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#688">688</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#689">689</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#690">690</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#691">691</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#692">692</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#693">693</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#694">694</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#695">695</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#696">696</a>.</li>
<li>Added the following Pending NAD Editorial issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#683">683</a>.</li>
<li>Changed the following issues from New to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#587">587</a>.</li>
<li>Changed the following issues from Open to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#590">590</a>.</li>
<li>Changed the following issues from New to Pending NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#636">636</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#642">642</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#648">648</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#649">649</a>.</li>
</ul></li>
</ul>
</li>
<li>R48: 
2007-05-06 post-Oxford mailing.
<ul>
<li><b>Summary:</b><ul>
<li>145 open issues, down by 33.</li>
<li>531 closed issues, up by 53.</li>
<li>676 issues total, up by 20.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#657">657</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#658">658</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#659">659</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#660">660</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#661">661</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#662">662</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#663">663</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#664">664</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#665">665</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#666">666</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#667">667</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#668">668</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#669">669</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#670">670</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#671">671</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#672">672</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#673">673</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#674">674</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#675">675</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#676">676</a>.</li>
<li>Changed the following issues from Tentatively Ready to Dup: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#479">479</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#536">536</a>.</li>
<li>Changed the following issues from Tentatively Ready to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#385">385</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#463">463</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#466">466</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#470">470</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#515">515</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#526">526</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#547">547</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#560">560</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#572">572</a>.</li>
<li>Changed the following issues from NAD to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#351">351</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#357">357</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#368">368</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#499">499</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#504">504</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#512">512</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#513">513</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#514">514</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#516">516</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#544">544</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#549">549</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#555">555</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#558">558</a>.</li>
<li>Changed the following issues from Tentatively Ready to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#482">482</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#615">615</a>.</li>
<li>Changed the following issues from NAD_Future to NAD Future: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#77">77</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#105">105</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#111">111</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#116">116</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#128">128</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#138">138</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#140">140</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#149">149</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#180">180</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#188">188</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#190">190</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#219">219</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#323">323</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#348">348</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#350">350</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#353">353</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#388">388</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#390">390</a>.</li>
<li>Changed the following issues from Tentatively Ready to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#471">471</a>.</li>
<li>Changed the following issues from New to Pending NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#633">633</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#641">641</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#656">656</a>.</li>
<li>Changed the following issues from Tentatively Ready to Pending NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#532">532</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#553">553</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#571">571</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#591">591</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#594">594</a>.</li>
<li>Changed the following issues from Tentatively Ready to Pending WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#258">258</a>.</li>
<li>Changed the following issues from New to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#566">566</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#628">628</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#640">640</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#643">643</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#644">644</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#646">646</a>.</li>
<li>Changed the following issues from Review to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#531">531</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#551">551</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#604">604</a>.</li>
<li>Changed the following issues from Ready to TRDec: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#598">598</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#599">599</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#600">600</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#601">601</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#602">602</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#603">603</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#605">605</a>.</li>
<li>Changed the following issues from Ready to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#543">543</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#545">545</a>.</li>
<li>Changed the following issues from Tentatively Ready to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#201">201</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#206">206</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#233">233</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#254">254</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#416">416</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#422">422</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#456">456</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#534">534</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#542">542</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#559">559</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#575">575</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#576">576</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#578">578</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#586">586</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#589">589</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#593">593</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#609">609</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#610">610</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#611">611</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#613">613</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#616">616</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#619">619</a>.</li>
</ul></li>
</ul>
</li>
<li>R47: 
2007-03-09 pre-Oxford mailing.
<ul>
<li><b>Summary:</b><ul>
<li>178 open issues, up by 37.</li>
<li>478 closed issues, up by 0.</li>
<li>656 issues total, up by 37.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#620">620</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#621">621</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#622">622</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#623">623</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#624">624</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#627">627</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#628">628</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#629">629</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#630">630</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#631">631</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#632">632</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#633">633</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#634">634</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#635">635</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#636">636</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#637">637</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#638">638</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#639">639</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#640">640</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#641">641</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#642">642</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#643">643</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#644">644</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#645">645</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#646">646</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#647">647</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#648">648</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#649">649</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#650">650</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#651">651</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#652">652</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#653">653</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#654">654</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#655">655</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#656">656</a>.</li>
<li>Added the following Open issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#625">625</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#626">626</a>.</li>
<li>Changed the following issues from New to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#570">570</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#580">580</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#582">582</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#590">590</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#612">612</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#614">614</a>.</li>
<li>Changed the following issues from New to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#547">547</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#553">553</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#560">560</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#571">571</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#572">572</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#575">575</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#576">576</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#578">578</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#586">586</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#589">589</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#591">591</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#593">593</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#594">594</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#609">609</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#610">610</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#611">611</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#613">613</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#615">615</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#616">616</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#619">619</a>.</li>
<li>Changed the following issues from Open to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#201">201</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#206">206</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#233">233</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#254">254</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#258">258</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#385">385</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#416">416</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#422">422</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#456">456</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#463">463</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#466">466</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#470">470</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#471">471</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#479">479</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#482">482</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#515">515</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#526">526</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#532">532</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#536">536</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#542">542</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#559">559</a>.</li>
<li>Changed the following issues from Review to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#534">534</a>.</li>
</ul></li>
</ul>
</li>
<li>R46: 
2007-01-12 mid-term mailing.
<ul>
<li><b>Summary:</b><ul>
<li>141 open issues, up by 11.</li>
<li>478 closed issues, down by 1.</li>
<li>619 issues total, up by 10.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#610">610</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#611">611</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#612">612</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#613">613</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#614">614</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#615">615</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#616">616</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#617">617</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#618">618</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#619">619</a>.</li>
</ul></li>
</ul>
</li>
<li>R45: 
2006-11-03 post-Portland mailing.
<ul>
<li><b>Summary:</b><ul>
<li>130 open issues, up by 0.</li>
<li>479 closed issues, up by 17.</li>
<li>609 issues total, up by 17.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Moved issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#520">520</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#521">521</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#530">530</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#535">535</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#537">537</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#538">538</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#540">540</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#541">541</a> to WP.</li>
<li>Moved issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#504">504</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#512">512</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#516">516</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#544">544</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#549">549</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#554">554</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#555">555</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#558">558</a> to NAD.</li>
<li>Moved issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#569">569</a> to Dup.</li>
<li>Moved issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#518">518</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#523">523</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#524">524</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#542">542</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#556">556</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#557">557</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#559">559</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#597">597</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#606">606</a> to Open.</li>
<li>Moved issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#543">543</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#545">545</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#549">549</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#549">549</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#598">598</a> - <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#603">603</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#605">605</a> to Ready.</li>
<li>Moved issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#531">531</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#551">551</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#604">604</a> to Review.</li>
<li>Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#593">593</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#594">594</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#595">595</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#596">596</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#597">597</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#598">598</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#599">599</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#600">600</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#601">601</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#602">602</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#603">603</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#604">604</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#605">605</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#606">606</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#607">607</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#608">608</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#609">609</a>.</li>
</ul></li>
</ul>
</li>
<li>R44: 
2006-09-08 pre-Portland mailing.
<ul>
<li><b>Summary:</b><ul>
<li>130 open issues, up by 6.</li>
<li>462 closed issues, down by 1.</li>
<li>592 issues total, up by 5.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#583">583</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#584">584</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#585">585</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#586">586</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#587">587</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#588">588</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#589">589</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#590">590</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#591">591</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#592">592</a>.</li>
</ul></li>
</ul>
</li>
<li>R43: 
2006-06-23 mid-term mailing.
<ul>
<li><b>Summary:</b><ul>
<li>124 open issues, up by 14.</li>
<li>463 closed issues, down by 1.</li>
<li>587 issues total, up by 13.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#575">575</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#576">576</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#577">577</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#578">578</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#579">579</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#580">580</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#581">581</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#582">582</a>.</li>
<li>Reopened <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#255">255</a>.</li>
<li>Moved issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#520">520</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#541">541</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#544">544</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#569">569</a> to Tentatively Ready.</li>
</ul></li>
</ul>
</li>
<li>R42: 
2006-04-21 post-Berlin mailing.
<ul>
<li><b>Summary:</b><ul>
<li>110 open issues, down by 16.</li>
<li>464 closed issues, up by 24.</li>
<li>574 issues total, up by 8.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#567">567</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#568">568</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#569">569</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#570">570</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#571">571</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#572">572</a>.</li>
<li>Moved issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#499">499</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#501">501</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#506">506</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#509">509</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#510">510</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#511">511</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#513">513</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#514">514</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#517">517</a> to NAD.</li>
<li>Moved issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#502">502</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#503">503</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#515">515</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#516">516</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#522">522</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#525">525</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#526">526</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#527">527</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#528">528</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#529">529</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#532">532</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#536">536</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#539">539</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#548">548</a> to Open.</li>
<li>Moved issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#504">504</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#512">512</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#521">521</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#530">530</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#531">531</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#535">535</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#537">537</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#538">538</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#540">540</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#549">549</a> to Ready.</li>
<li>Moved issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#247">247</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#294">294</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#362">362</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#369">369</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#371">371</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#376">376</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#384">384</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#475">475</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#478">478</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#495">495</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#497">497</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#505">505</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#507">507</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#508">508</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#519">519</a> to WP.</li>
<li>Moved issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#534">534</a> to Review.</li>
</ul></li>
</ul>
</li>
<li>R41: 
2006-02-24 pre-Berlin mailing.
<ul>
<li><b>Summary:</b><ul>
<li>126 open issues, up by 31.</li>
<li>440 closed issues, up by 0.</li>
<li>566 issues total, up by 31.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#536">536</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#537">537</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#538">538</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#539">539</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#540">540</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#541">541</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#542">542</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#543">543</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#544">544</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#545">545</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#546">546</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#547">547</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#548">548</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#549">549</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#550">550</a> ,<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#551">551</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#552">552</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#553">553</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#554">554</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#555">555</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#556">556</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#557">557</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#558">558</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#559">559</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#560">560</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#561">561</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#562">562</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#563">563</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#564">564</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#565">565</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#566">566</a>.</li>
<li>Moved <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#342">342</a> from Ready to Open.</li>
<li>Reopened <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#309">309</a>.</li>
</ul></li>
</ul>
</li>
<li>R40: 
2005-12-16 mid-term mailing.
<ul>
<li><b>Summary:</b><ul>
<li>95 open issues.</li>
<li>440 closed issues.</li>
<li>535 issues total.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#529">529</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#530">530</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#531">531</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#532">532</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#533">533</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#534">534</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#535">535</a>.</li>
</ul></li>
</ul>
</li>
<li>R39: 
2005-10-14 post-Mont Tremblant mailing.
Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#526">526</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#528">528</a>.
Moved issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#280">280</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#461">461</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#464">464</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#465">465</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#467">467</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#468">468</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#474">474</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#496">496</a> from Ready to WP as per the vote from Mont Tremblant.
Moved issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#247">247</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#294">294</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#342">342</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#362">362</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#369">369</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#371">371</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#376">376</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#384">384</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#475">475</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#478">478</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#495">495</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#497">497</a> from Review to Ready.
Moved issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#498">498</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#504">504</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#506">506</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#509">509</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#510">510</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#511">511</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#512">512</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#513">513</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#514">514</a> from New to Open.
Moved issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#505">505</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#507">507</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#508">508</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#519">519</a> from New to Ready.
Moved issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#500">500</a> from New to NAD.
Moved issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#518">518</a> from New to Review.
</li>
<li>R38: 
2005-07-03 pre-Mont Tremblant mailing.
Merged open TR1 issues in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#504">504</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#522">522</a>.
Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#523">523</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#523">523</a>
</li>
<li>R37: 
2005-06 mid-term mailing.
Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#498">498</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#503">503</a>.
</li>
<li>R36: 
2005-04 post-Lillehammer mailing. All issues in "ready" status except
for <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#454">454</a> were moved to "DR" status, and all issues
previously in "DR" status were moved to "WP".
</li>
<li>R35: 
2005-03 pre-Lillehammer mailing.
</li>
<li>R34: 
2005-01 mid-term mailing.  Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#488">488</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#494">494</a>.
</li>
<li>R33: 
2004-11 post-Redmond mailing. Reflects actions taken in Redmond.
</li>
<li>R32: 
2004-09 pre-Redmond mailing: reflects new proposed resolutions and
new issues received after the 2004-07 mailing.  Added
new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#479">479</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#481">481</a>.
</li>
<li>R31: 
2004-07 mid-term mailing: reflects new proposed resolutions and
new issues received after the post-Sydney mailing.  Added
new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#463">463</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#478">478</a>.
</li>
<li>R30: 
Post-Sydney mailing: reflects decisions made at the Sydney meeting.
Voted all "Ready" issues from R29 into the working paper.
Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#460">460</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#462">462</a>.
</li>
<li>R29: 
Pre-Sydney mailing.  Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#441">441</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#457">457</a>.
</li>
<li>R28: 
Post-Kona mailing: reflects decisions made at the Kona meeting.
Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#432">432</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#440">440</a>.
</li>
<li>R27: 
Pre-Kona mailing.  Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#404">404</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#431">431</a>.
</li>
<li>R26: 
Post-Oxford mailing: reflects decisions made at the Oxford meeting.
All issues in Ready status were voted into DR status.  All issues in
DR status were voted into WP status.
</li>
<li>R25: 
Pre-Oxford mailing.  Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#390">390</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#402">402</a>.
</li>
<li>R24: 
Post-Santa Cruz mailing: reflects decisions made at the Santa Cruz
meeting.  All Ready issues from R23 with the exception of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#253">253</a>, which has been given a new proposed resolution, were
moved to DR status.  Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#383">383</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#389">389</a>.  (Issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#387">387</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#389">389</a> were discussed
at the meeting.)  Made progress on issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#225">225</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#226">226</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#229">229</a>: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#225">225</a> and <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#229">229</a> have been moved to Ready status, and the only remaining
concerns with <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#226">226</a> involve wording.
</li>
<li>R23: 
Pre-Santa Cruz mailing.  Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#367">367</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#382">382</a>.
Moved issues in the TC to TC status.
</li>
<li>R22: 
Post-Curaao mailing.  Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#362">362</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#366">366</a>.
</li>
<li>R21: 
Pre-Curaao mailing.  Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#351">351</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#361">361</a>.
</li>
<li>R20: 
Post-Redmond mailing; reflects actions taken in Redmond.  Added
new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#336">336</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#350">350</a>, of which issues 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#347">347</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#350">350</a> were added since Redmond, hence
not discussed at the meeting.  

All Ready issues were moved to DR status, with the exception of issues
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#284">284</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#241">241</a>, and <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#267">267</a>.

Noteworthy issues discussed at Redmond include 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#120">120</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#202">202</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#226">226</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#233">233</a>, 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#270">270</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#253">253</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#254">254</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#323">323</a>.
</li>
<li>R19: 
Pre-Redmond mailing.  Added new issues 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#323">323</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#335">335</a>.
</li>
<li>R18: 
Post-Copenhagen mailing; reflects actions taken in Copenhagen.
Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#312">312</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#317">317</a>, and discussed
new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#271">271</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#314">314</a>.

Changed status of issues
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#103">103</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#118">118</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#136">136</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#153">153</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#165">165</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#171">171</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#183">183</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#184">184</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#185">185</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#186">186</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#214">214</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#221">221</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#234">234</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#237">237</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#243">243</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#248">248</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#251">251</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#252">252</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#256">256</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#260">260</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#261">261</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#262">262</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#263">263</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#265">265</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#268">268</a>
to DR.

Changed status of issues
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#49">49</a>  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#109">109</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#117">117</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#182">182</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#228">228</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#230">230</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#232">232</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#235">235</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#238">238</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#241">241</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#242">242</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#250">250</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#259">259</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#264">264</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#266">266</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#267">267</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#271">271</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#272">272</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#273">273</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#275">275</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#281">281</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#284">284</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#285">285</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#286">286</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#288">288</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#292">292</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#295">295</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#297">297</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#298">298</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#301">301</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#303">303</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#306">306</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#307">307</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#308">308</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#312">312</a>
to Ready.

Closed issues 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#111">111</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#277">277</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#279">279</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#287">287</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#289">289</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#293">293</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#302">302</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#313">313</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#314">314</a>
as NAD.

</li>
<li>R17: 
Pre-Copenhagen mailing.  Converted issues list to XML.  Added proposed
resolutions for issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#49">49</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#76">76</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#91">91</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#235">235</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#250">250</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#267">267</a>.
Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#278">278</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#311">311</a>.
</li>
<li>R16:  
post-Toronto mailing; reflects actions taken in Toronto. Added new
issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#265">265</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#277">277</a>.  Changed status of issues
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#3">3</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#8">8</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#9">9</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#19">19</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#26">26</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#31">31</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#61">61</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#63">63</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#86">86</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#108">108</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#112">112</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#114">114</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#115">115</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#122">122</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#127">127</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#129">129</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#134">134</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#137">137</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#142">142</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#144">144</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#146">146</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#147">147</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#159">159</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#164">164</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#170">170</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#181">181</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#199">199</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#208">208</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#209">209</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#210">210</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#211">211</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#212">212</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#217">217</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#220">220</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#222">222</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#223">223</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#224">224</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#227">227</a> to "DR".  Reopened issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#23">23</a>. Reopened
issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#187">187</a>. Changed issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#2">2</a> and
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#4">4</a> to NAD. Fixed a typo in issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#17">17</a>. Fixed
issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#70">70</a>: signature should be changed both places it
appears. Fixed issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#160">160</a>: previous version didn't fix
the bug in enough places.
</li>
<li>R15: 
pre-Toronto mailing. Added issues
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#233">233</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#264">264</a>. Some small HTML formatting
changes so that we pass Weblint tests.
</li>
<li>R14: 
post-Tokyo II mailing; reflects committee actions taken in
Tokyo. Added issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#228">228</a> to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#232">232</a>. (00-0019R1/N1242)
</li>
<li>R13: 
pre-Tokyo II updated: Added issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#212">212</a> to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#227">227</a>.
</li>
<li>R12: 
pre-Tokyo II mailing: Added issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#199">199</a> to
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#211">211</a>. Added "and paragraph 5" to the proposed resolution
of issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#29">29</a>.  Add further rationale to issue
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#178">178</a>.
</li>
<li>R11: 
post-Kona mailing: Updated to reflect LWG and full committee actions
in Kona (99-0048/N1224). Note changed resolution of issues
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#4">4</a> and <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#38">38</a>. Added issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#196">196</a>
to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#198">198</a>. Closed issues list split into "defects" and
"closed" documents.  Changed the proposed resolution of issue
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#4">4</a> to NAD, and changed the wording of proposed resolution
of issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#38">38</a>.
</li>
<li>R10: 
pre-Kona updated.  Added proposed resolutions <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#83">83</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#86">86</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#91">91</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#92">92</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#109">109</a>. Added issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#190">190</a> to
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#195">195</a>. (99-0033/D1209, 14 Oct 99)
</li>
<li>R9: 
pre-Kona mailing.  Added issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#140">140</a> to
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#189">189</a>. Issues list split into separate "active" and
"closed" documents. (99-0030/N1206, 25 Aug 99)
</li>
<li>R8: 
post-Dublin mailing. Updated to reflect LWG and full committee actions
in Dublin. (99-0016/N1193, 21 Apr 99)
</li>
<li>R7: 
pre-Dublin updated: Added issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#130">130</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#131">131</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#132">132</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#133">133</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#134">134</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#135">135</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#136">136</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#137">137</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#138">138</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#139">139</a> (31 Mar 99)
</li>
<li>R6: 
pre-Dublin mailing. Added issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#127">127</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#128">128</a>,
and <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#129">129</a>.  (99-0007/N1194, 22 Feb 99)
</li>
<li>R5: 
update issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#103">103</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#112">112</a>; added issues
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#114">114</a> to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#126">126</a>. Format revisions to prepare
for making list public. (30 Dec 98)
</li>
<li>R4: 
post-Santa Cruz II updated: Issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#110">110</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#111">111</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#112">112</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#113">113</a> added, several
issues corrected. (22 Oct 98)
</li>
<li>R3: 
post-Santa Cruz II: Issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#94">94</a> to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#109">109</a>
added, many issues updated to reflect LWG consensus (12 Oct 98)
</li>
<li>R2: 
pre-Santa Cruz II: Issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#73">73</a> to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#93">93</a> added,
issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#17">17</a> updated. (29 Sep 98)
</li>
<li>R1: 
Correction to issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#55">55</a> resolution, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#60">60</a> code
format, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#64">64</a> title. (17 Sep 98)
</li>
</ul>

<h2><a name="Status"></a>Issue Status</h2>

  <p><b><a name="New">New</a></b> - The issue has not yet been
  reviewed by the LWG. Any <b>Proposed Resolution</b> is purely a
  suggestion from the issue submitter, and should not be construed as
  the view of LWG.</p>

  <p><b><a name="Open">Open</a></b> - The LWG has discussed the issue
  but is not yet ready to move the issue forward. There are several
  possible reasons for open status:</p>
     <ul>
        <li>Consensus may have not yet have been reached as to how to deal
            with the issue.</li>
        <li>Informal consensus may have been reached, but the LWG awaits
            exact <b>Proposed Resolution</b> wording for review.</li>
        <li>The LWG wishes to consult additional technical experts before
            proceeding.</li>
        <li>The issue may require further study.</li>
     </ul>

  <p>A <b>Proposed Resolution</b> for an open issue is still not be
  construed as the view of LWG. Comments on the current state of
  discussions are often given at the end of open issues in an italic
  font. Such comments are for information only and should not be given
  undue importance.</p>

  <p><b><a name="Dup">Dup</a></b> - The LWG has reached consensus that
  the issue is a duplicate of another issue, and will not be further
  dealt with. A <b>Rationale</b> identifies the duplicated issue's
  issue number.  </p>

  <p><b><a name="NAD">NAD</a></b> - The LWG has reached consensus that
  the issue is not a defect in the Standard.</p>

  <p><b><a name="NAD Editorial">NAD Editorial</a></b> - The LWG has reached consensus that
  the issue can either be handled editorially, or is handled by a paper (usually
  linked to in the rationale).</p>

  <p><b><a name="NAD Future">NAD Future</a></b> - In addition to the regular
  status, the LWG believes that this issue should be revisited at the
  next revision of the standard.</p>

  <p><b><a name="Review">Review</a></b> - Exact wording of a
  <b>Proposed Resolution</b> is now available for review on an issue
  for which the LWG previously reached informal consensus.</p>

  <p><b><a name="Ready">Ready</a></b> - The LWG has reached consensus
  that the issue is a defect in the Standard, the <b>Proposed
  Resolution</b> is correct, and the issue is ready to forward to the
  full committee for further action as a Defect Report (DR).</p>

  <p><b><a name="DR">DR</a></b> - (Defect Report) - The full J16
  committee has voted to forward the issue to the Project Editor to be
  processed as a Potential Defect Report. The Project Editor reviews
  the issue, and then forwards it to the WG21 Convenor, who returns it
  to the full committee for final disposition. This issues list
  accords the status of DR to all these Defect Reports regardless of
  where they are in that process.</p>

  <p><b><a name="TC1">TC1</a></b> - (Technical Corrigenda 1) - The full
  WG21 committee has voted to accept the Defect Report's Proposed
  Resolution as a Technical Corrigenda.  Action on this issue is thus
  complete and no further action is possible under ISO rules.</p>

  <p><b><a name="CD1">CD1</a></b> - (Committee Draft 2008) - The full
  WG21 committee has voted to accept the Defect Report's Proposed
  Resolution into the Fall 2008 Committee Draft.</p>

  <p><b><a name="TRDec">TRDec</a></b> - (Decimal TR defect) - The 
  LWG has voted to accept the Defect Report's Proposed
  Resolution into the Decimal TR.  Action on this issue is thus
  complete and no further action is expected.</p>

  <p><b><a name="WP">WP</a></b> - (Working Paper) - The proposed
  resolution has not been accepted as a Technical Corrigendum, but
  the full WG21 committee has voted to apply the Defect Report's Proposed
  Resolution to the working paper.</p>

  <p><b>Tentatively</b> - This is a <i>status qualifier</i>.  The issue has
  been reviewed online, or at an unofficial meeting, but not in an official meeting, and some support has been formed
  for the qualified status.  Tentatively qualified issues may be moved to the unqualified status
  and forwarded to full committee (if Ready) within the same meeting.  Unlike Ready issues, Tentatively Ready issues
  will be reviewed in subcommittee prior to forwarding to full committee.  When a status is
  qualified with Tentatively, the issue is still considered active.</p>

  <p><b>Pending</b> - This is a <i>status qualifier</i>.  When prepended to
  a status this indicates the issue has been
  processed by the committee, and a decision has been made to move the issue to
  the associated unqualified status.  However for logistical reasons the indicated
  outcome of the issue has not yet appeared in the latest working paper.

  </p><p>Issues are always given the status of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a> when
  they first appear on the issues list. They may progress to
  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a> or <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Review">Review</a> while the LWG
  is actively working on them. When the LWG has reached consensus on
  the disposition of an issue, the status will then change to
  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>, or
  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Ready</a> as appropriate.  Once the full J16 committee votes to
  forward Ready issues to the Project Editor, they are given the
  status of Defect Report ( <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#DR">DR</a>). These in turn may
  become the basis for Technical Corrigenda (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC">TC</a>),
  or are closed without action other than a Record of Response
  (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#RR">RR</a> ). The intent of this LWG process is that
  only issues which are truly defects in the Standard move to the
  formal ISO DR status.
  </p>


<h2>Active Issues</h2>
<hr>
<h3><a name="96"></a>96. Vector&lt;bool&gt; is not a container</h3>
<p><b>Section:</b> 23.3.6 [vector] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Future">Tentatively NAD Future</a>
 <b>Submitter:</b> AFNOR <b>Opened:</b> 1998-10-07  <b>Last modified:</b> 2009-05-25</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#vector">issues</a> in [vector].</p>
<p><b>Discussion:</b></p>
<p><tt>vector&lt;bool&gt;</tt> is not a container as its reference and
pointer types are not references and pointers. </p>

<p>Also it forces everyone to have a space optimization instead of a
speed one.</p>

<p><b>See also:</b> 99-0008 == N1185 Vector&lt;bool&gt; is
Nonconforming, Forces Optimization Choice.</p>

<p><i>[In Santa Cruz the LWG felt that this was Not A Defect.]</i></p>


<p><i>[In Dublin many present felt that failure to meet Container
requirements was a defect. There was disagreement as to whether
or not the optimization requirements constituted a defect.]</i></p>


<p><i>[The LWG looked at the following resolutions in some detail:
<br>
&nbsp;&nbsp;&nbsp;&nbsp; * Not A Defect.<br>
&nbsp;&nbsp;&nbsp;&nbsp; * Add a note explaining that vector&lt;bool&gt; does not meet
Container requirements.<br>
&nbsp;&nbsp;&nbsp;&nbsp; * Remove vector&lt;bool&gt;.<br>
&nbsp;&nbsp;&nbsp;&nbsp; * Add a new category of container requirements which
vector&lt;bool&gt; would meet.<br>
&nbsp;&nbsp;&nbsp;&nbsp; * Rename vector&lt;bool&gt;.<br>
<br>
No alternative had strong, wide-spread, support and every alternative
had at least one "over my dead body" response.<br>
<br>
There was also mention of a transition scheme something like (1) add
vector_bool and deprecate vector&lt;bool&gt; in the next standard. (2)
Remove vector&lt;bool&gt; in the following standard.]</i></p>


<p><i>[Modifying container requirements to permit returning proxies
(thus allowing container requirements conforming vector&lt;bool&gt;)
was also discussed.]</i></p>


<p><i>[It was also noted that there is a partial but ugly workaround in
that vector&lt;bool&gt; may be further specialized with a customer
allocator.]</i></p>


<p><i>[Kona: Herb Sutter presented his paper J16/99-0035==WG21/N1211,
vector&lt;bool&gt;: More Problems, Better Solutions. Much discussion
of a two step approach: a) deprecate, b) provide replacement under a
new name.  LWG straw vote on that: 1-favor, 11-could live with, 2-over
my dead body.  This resolution was mentioned in the LWG report to the
full committee, where several additional committee members indicated
over-my-dead-body positions.]</i></p>


<p>Discussed at Lillehammer.  General agreement that we should
  deprecate vector&lt;bool&gt; and introduce this functionality under
  a different name, e.g. bit_vector.  This might make it possible to
  remove the vector&lt;bool&gt; specialization in the standard that comes
  after C++0x. There was also a suggestion that
  in C++0x we could additional say that it's implementation defined
  whether vector&lt;bool&gt; refers to the specialization or to the
  primary template, but there wasn't general agreement that this was a
  good idea.</p>

<p>We need a paper for the new bit_vector class.</p>

<p><i>[
Batavia:
]</i></p>

<blockquote>
The LWG feels we need something closer to SGI's <tt>bitvector</tt> to ease migration
from <tt>vector&lt;bool&gt;</tt>.  Although some of the funcitonality from
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2050.pdf">N2050</a>
could well be used in such a template.  The concern is easing the API migration for those
users who want to continue using a bit-packed container.  Alan and Beman to work.
</blockquote>

<p><i>[
Post Summit Alisdair adds:
]</i></p>


<blockquote>
<p>
<tt>vector&lt;bool&gt;</tt> is now a conforming container under the revised terms of C++0x,
which supports containers of proxies.
</p>
<p>
Recommend NAD.
</p>
<p>
Two issues remain:
</p>
<p>
i/ premature optimization in the specification.
There is still some sentiment that deprecation is the correct way to go,
although it is still not clear what it would mean to deprecate a single
specialization of a template.
</p>
<p>
Recommend: Create a new issue for the discussion, leave as Open.
</p>
<p>
ii/ Request for a new bitvector class to guarantee the optimization, perhaps
with a better tuned interface.
</p>
<p>
This is a clear extension request that may be handled via a future TR.
</p>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We note that most of this issue has become moot over time,
and agree with Alisdair's recommendations.
Move to NAD Future for reconsideration of part (ii).
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
We now have:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2050.pdf">N2050</a>
and
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2160.html">N2160</a>.
</p>






<hr>
<h3><a name="111"></a>111. istreambuf_iterator::equal overspecified, inefficient</h3>
<p><b>Section:</b> 24.6.3.5 [istreambuf.iterator::equal] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Nathan Myers <b>Opened:</b> 1998-10-15  <b>Last modified:</b> 2009-03-13</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#istreambuf.iterator::equal">active issues</a> in [istreambuf.iterator::equal].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#istreambuf.iterator::equal">issues</a> in [istreambuf.iterator::equal].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>The member istreambuf_iterator&lt;&gt;::equal is specified to be
unnecessarily inefficient. While this does not affect the efficiency
of conforming implementations of iostreams, because they can
"reach into" the iterators and bypass this function, it does
affect users who use istreambuf_iterators. </p>

<p>The inefficiency results from a too-scrupulous definition, which
requires a "true" result if neither iterator is at eof. In
practice these iterators can only usefully be compared with the
"eof" value, so the extra test implied provides no benefit,
but slows down users' code. </p>

<p>The solution is to weaken the requirement on the function to return
true only if both iterators are at eof. </p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Reopened by Alisdair.
</blockquote>

<p><i>[
Post Summit Daniel adds:
]</i></p>


<blockquote>
<p>
Recommend NAD. The proposed wording would violate the axioms of
concept requirement <tt>EqualityComparable</tt> axioms as part of concept <tt>InputIterator</tt>
and more specifically it would violate the explicit wording of
24.2.2 [input.iterators]/7:
</p>

<blockquote>
If two iterators <tt>a</tt> and <tt>b</tt> of the same type are equal, then either <tt>a</tt>
and <tt>b</tt> are both
dereferenceable or else neither is dereferenceable.
</blockquote>

</blockquote>



<p><b>Proposed resolution:</b></p>
<p>Replace 24.6.3.5 [istreambuf.iterator::equal],
paragraph 1, </p>

<blockquote>
  <p>-1- Returns: true if and only if both iterators are at end-of-stream, or neither is at
  end-of-stream, regardless of what streambuf object they use. </p>
</blockquote>

<p>with</p>

<blockquote>
  <p>-1- Returns: true if and only if both iterators are at
  end-of-stream, regardless of what streambuf object they use. </p>
</blockquote>



<p><b>Rationale:</b></p>
<p>It is not clear that this is a genuine defect.  Additionally, the
LWG was reluctant to make a change that would result in 
operator== not being a equivalence relation.  One consequence of
this change is that an algorithm that's passed the range [i, i)
would no longer treat it as an empty range.</p>





<hr>
<h3><a name="128"></a>128. Need open_mode() function for file stream, string streams, file buffers, and string&nbsp; buffers</h3>
<p><b>Section:</b> 27.8 [string.streams], 27.9 [file.streams] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Angelika Langer <b>Opened:</b> 1999-02-22  <b>Last modified:</b> 2008-03-14</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#string.streams">issues</a> in [string.streams].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>The following question came from Thorsten Herlemann:</p>

<blockquote>
  <p>You can set a mode when constructing or opening a file-stream or
  filebuf, e.g.  ios::in, ios::out, ios::binary, ... But how can I get
  that mode later on, e.g. in my own operator &lt;&lt; or operator
  &gt;&gt; or when I want to check whether a file-stream or
  file-buffer object passed as parameter is opened for input or output
  or binary? Is there no possibility? Is this a design-error in the
  standard C++ library? </p>
</blockquote>

<p>It is indeed impossible to find out what a stream's or stream
buffer's open mode is, and without that knowledge you don't know
how certain operations behave. Just think of the append mode. </p>

<p>Both streams and stream buffers should have a <tt>mode()</tt> function that returns the
current open mode setting. </p>

<p><i>[
post Bellevue:  Alisdair requested to re-Open.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>For stream buffers, add a function to the base class as a non-virtual function
qualified as const to 27.6.2 [streambuf]:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;<tt>openmode mode() const</tt>;</p>

<p><b>&nbsp;&nbsp;&nbsp; Returns</b> the current open mode.</p>

<p>With streams, I'm not sure what to suggest. In principle, the mode
could already be returned by <tt>ios_base</tt>, but the mode is only
initialized for file and string stream objects, unless I'm overlooking
anything. For this reason it should be added to the most derived
stream classes. Alternatively, it could be added to <tt>basic_ios</tt>
and would be default initialized in <tt>basic_ios&lt;&gt;::init()</tt>.</p>


<p><b>Rationale:</b></p>
<p>This might be an interesting extension for some future, but it is
not a defect in the current standard. The Proposed Resolution is
retained for future reference.</p>





<hr>
<h3><a name="138"></a>138. Class ctype_byname&lt;char&gt; redundant and misleading</h3>
<p><b>Section:</b> 22.4.1.4 [locale.codecvt] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Angelika Langer <b>Opened:</b> 1999-03-18  <b>Last modified:</b> 2009-03-09</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#locale.codecvt">active issues</a> in [locale.codecvt].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.codecvt">issues</a> in [locale.codecvt].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>Section 22.4.1.4 [locale.codecvt] specifies that
ctype_byname&lt;char&gt; must be a specialization of the ctype_byname
template.</p>

<p>It is common practice in the standard that specializations of class templates are only
mentioned where the interface of the specialization deviates from the interface of the
template that it is a specialization of. Otherwise, the fact whether or not a required
instantiation is an actual instantiation or a specialization is left open as an
implementation detail. </p>

<p>Clause 22.2.1.4 deviates from that practice and for that reason is misleading. The
fact, that ctype_byname&lt;char&gt; is specified as a specialization suggests that there
must be something "special" about it, but it has the exact same interface as the
ctype_byname template. Clause 22.2.1.4 does not have any explanatory value, is at best
redundant, at worst misleading - unless I am missing anything. </p>

<p>Naturally, an implementation will most likely implement ctype_byname&lt;char&gt; as a
specialization, because the base class ctype&lt;char&gt; is a specialization with an
interface different from the ctype template, but that's an implementation detail and need
not be mentioned in the standard. </p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Reopened by Alisdair.
</blockquote>



<p><b>Rationale:</b></p>
<p> The standard as written is mildly misleading, but the correct fix
is to deal with the underlying problem in the ctype_byname base class,
not in the specialization. See issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#228">228</a>.</p>




<hr>
<h3><a name="149"></a>149. Insert should return iterator to first element inserted</h3>
<p><b>Section:</b> 23.2.3 [sequence.reqmts] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Andrew Koenig <b>Opened:</b> 1999-06-28  <b>Last modified:</b> 2009-05-01</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#sequence.reqmts">active issues</a> in [sequence.reqmts].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#sequence.reqmts">issues</a> in [sequence.reqmts].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>Suppose that c and c1 are sequential containers and i is an
iterator that refers to an element of c.  Then I can insert a copy of
c1's elements into c ahead of element i by executing </p>

<blockquote>

<pre>c.insert(i, c1.begin(), c1.end());</pre>

</blockquote>

<p>If c is a vector, it is fairly easy for me to find out where the
newly inserted elements are, even though i is now invalid: </p>

<blockquote>

<pre>size_t i_loc = i - c.begin();
c.insert(i, c1.begin(), c1.end());</pre>

</blockquote>

<p>and now the first inserted element is at c.begin()+i_loc and one
past the last is at c.begin()+i_loc+c1.size().<br>
<br>
But what if c is a list? I can still find the location of one past the
last inserted element, because i is still valid. To find the location
of the first inserted element, though, I must execute something like </p>

<blockquote>

<pre>for (size_t n = c1.size(); n; --n)
   --i;</pre>

</blockquote>

<p>because i is now no longer a random-access iterator.<br>
<br>
Alternatively, I might write something like </p>

<blockquote>

<pre>bool first = i == c.begin();
list&lt;T&gt;::iterator j = i;
if (!first) --j;
c.insert(i, c1.begin(), c1.end());
if (first)
   j = c.begin();
else
   ++j;</pre>

</blockquote>

<p>which, although wretched, requires less overhead.<br>
<br>
But I think the right solution is to change the definition of insert
so that instead of returning void, it returns an iterator that refers
to the first element inserted, if any, and otherwise is a copy of its
first argument.&nbsp; </p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Reopened by Alisdair.
</blockquote>

<p><i>[
Post Summit Alisdair adds:
]</i></p>


<blockquote>
<p>
In addition to the original rationale for C++03, this change also gives a
consistent interface for all container insert operations i.e. they all
return an iterator to the (first) inserted item.
</p>

<p>
Proposed wording provided.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
<sef ref="[sequence.reqmts]"> Table 83
change return type from <tt>void</tt> to <tt>iterator</tt> for the following rows:
</sef></p>

<blockquote>
<table border="1">
<caption>Table 83 -- Sequence container requirements (in addition to container)</caption>
<tbody><tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion/note pre-/post-condition</th>
</tr>
<tr>
<td>
<tt>a.insert(p,n,t)</tt>
</td>
<td>
<tt><del>void</del> <ins>iterator</ins></tt>
</td>
<td>
Inserts <tt>n</tt> copies of <tt>t</tt> before <tt>p</tt>.
</td>
</tr>

<tr>
<td>
<tt>a.insert(p,i,j)</tt>
</td>
<td>
<tt><del>void</del> <ins>iterator</ins></tt>
</td>
<td>
Each iterator in the range <tt>[i,j)</tt> shall be 
dereferenced exactly once. 
pre: <tt>i</tt> and <tt>j</tt> are not iterators into <tt>a</tt>. 
Inserts copies of elements in <tt>[i, j)</tt> before <tt>p</tt>
</td>
</tr>

<tr>
<td>
<tt>a.insert(p,il)</tt>
</td>
<td>
<tt><del>void</del> <ins>iterator</ins></tt>
</td>
<td>
<tt>a.insert(p, il.begin(), il.end())</tt>.
</td>
</tr>
</tbody></table>
</blockquote>

<p>
Add after p6 23.2.3 [sequence.reqmts]:
</p>

<blockquote>
<p>-6- ...</p>

<p><ins>
The iterator returned from <tt>a.insert(p,n,t)</tt> points to the copy of the
first element inserted into <tt>a</tt>, or <tt>p</tt> if <tt>n == 0</tt>.
</ins></p>

<p><ins>
The iterator returned from <tt>a.insert(p,i,j)</tt> points to the copy of the
first element inserted into <tt>a</tt>, or <tt>p</tt> if <tt>i == j</tt>.
</ins></p>

<p><ins>
The iterator returned from <tt>a.insert(p,il)</tt> points to the copy of the
first element inserted into <tt>a</tt>, or <tt>p</tt> if <tt>il</tt> is empty.
</ins></p>

</blockquote>

<p>
p9 23.2.6.1 [container.concepts.free] change return type from
<tt>void</tt> to <tt>iterator</tt>:
</p>

<blockquote><pre>concept RangeInsertionContainer&lt;typename C, typename Iter&gt; : InsertionContainer&lt;C&gt; {
  requires InputIterator&lt;Iter&gt;;
  <del>void</del> <ins>iterator</ins> insert(C&amp;, const_iterator position, Iter first, Iter last);
}
</pre></blockquote>

<p>
p9 23.2.6.2 [container.concepts.member] change return type from
<tt>void</tt> to <tt>iterator</tt>:
</p>

<blockquote><pre>auto concept MemberRangeInsertionContainer&lt;typename C, typename Iter&gt; : MemberInsertionContainer&lt;C&gt; {
  requires InputIterator&lt;Iter&gt;;
  <del>void</del> <ins>iterator</ins> C::insert(const_iterator position, Iter first, Iter last);
}
</pre></blockquote>

<p>
p8 23.2.6.3 [container.concepts.maps] change return type from
<tt>void</tt> to <tt>iterator</tt>, add return statement:
</p>

<blockquote><pre>template &lt;MemberRangeInsertionContainer C, InputIterator Iter&gt;
concept_map RangeInsertionContainer&lt;C, Iter&gt; {
  <del>void</del> <ins>iterator</ins> insert(C&amp; c, Container&lt;C&gt;::const_iterator i, Iter first, Iter last)
  { <ins>return</ins> c.insert(i, first, last); }
}
</pre></blockquote>

<p>
p2 23.3.2 [deque] Update class definition, change return type
from <tt>void</tt> to <tt>iterator</tt>:
</p>

<blockquote><pre>requires AllocatableElement&lt;Alloc, T, const T&amp;&gt; &amp;&amp; MoveAssignable&lt;T&gt;
  <del>void</del> <ins>iterator</ins> insert(const_iterator position, size_type n, const T&amp; x);
template &lt;InputIterator Iter&gt;
  requires AllocatableElement&lt;Alloc, T, Iter::reference&gt; &amp;&amp; MoveAssignable&lt;T&gt;
  <del>void</del> <ins>iterator</ins> insert(const_iterator position, Iter first, Iter last);
requires AllocatableElement&lt;Alloc, T, const T&amp;&gt; &amp;&amp; MoveAssignable&lt;T&gt;
  <del>void</del> <ins>iterator</ins> insert(const_iterator position, initializer_list&lt;T&gt;);
</pre></blockquote>

<p>
23.3.2.3 [deque.modifiers] change return type from <tt>void</tt> to <tt>iterator</tt> on following declarations:
</p>

<blockquote><pre>requires AllocatableElement&lt;Alloc, T, const T&amp;&gt; &amp;&amp; MoveAssignable&lt;T&gt;
  <del>void</del> <ins>iterator</ins> insert(const_iterator position, size_type n, const T&amp; x);
template &lt;InputIterator Iter&gt;
  requires AllocatableElement&lt;Alloc, T, Iter::reference&gt; &amp;&amp; MoveAssignable&lt;T&gt;
  <del>void</del> <ins>iterator</ins> insert(const_iterator position, Iter first, Iter last);
</pre></blockquote>

<p>
Add the following (missing) declaration
</p>

<blockquote><pre><ins>requires AllocatableElement&lt;Alloc, T, const T&amp;&gt; &amp;&amp; MoveAssignable&lt;T&gt;
  iterator insert(const_iterator position, initializer_list&lt;T&gt;);</ins>
</pre></blockquote>

<p>
23.3.3 [forwardlist] Update class definition, change return type
from <tt>void</tt> to <tt>iterator</tt>:
</p>

<blockquote><pre>requires AllocatableElement&lt;Alloc, T, const T&amp;&gt;
  <del>void</del> <ins>iterator</ins> insert_after(const_iterator position, initializer_list&lt;T&gt; il);
requires AllocatableElement&lt;Alloc, T, const T&amp;&gt;
  <del>void</del> <ins>iterator</ins> insert_after(const_iterator position, size_type n, const T&amp; x);
template &lt;InputIterator Iter&gt;
  requires AllocatableElement&lt;Alloc, T, Iter::reference&gt;
  <del>void</del> <ins>iterator</ins> insert_after(const_iterator position, Iter first, Iter last);
</pre></blockquote>

<p>
p8 23.3.3.4 [forwardlist.modifiers] change return type from <tt>void</tt> to <tt>iterator</tt>:
</p>

<blockquote><pre>requires AllocatableElement&lt;Alloc, T, const T&amp;&gt;
  <del>void</del> <ins>iterator</ins> insert_after(const_iterator position, size_type n, const T&amp; x);
</pre></blockquote>

<p>
Add paragraph:
</p>

<blockquote>
Returns: position.
</blockquote>

<p>
p10 23.3.3.4 [forwardlist.modifiers] change return type from <tt>void</tt> to <tt>iterator</tt>:
</p>

<blockquote><pre>template &lt;InputIterator Iter&gt;
  requires AllocatableElement&lt;Alloc, T, Iter::reference&gt;
  <del>void</del> <ins>iterator</ins> insert_after(const_iterator position, Iter first, Iter last);
</pre></blockquote>

<p>
Add paragraph:
</p>

<blockquote>
Returns: position.
</blockquote>

<p>
p12 23.3.3.4 [forwardlist.modifiers] change return type from <tt>void</tt> to <tt>iterator</tt> on following declarations:
</p>

<blockquote><pre>requires AllocatableElement&lt;Alloc, T, const T&amp;&gt;
  <del>void</del> <ins>iterator</ins> insert_after(const_iterator position, initializer_list&lt;T&gt; il);
</pre></blockquote>

<p>
change return type from <tt>void</tt> to <tt>iterator</tt> on following declarations:
</p>

<p>
p2 23.3.4 [list] Update class definition, change return type from <tt>void</tt> to <tt>iterator</tt>:
</p>

<blockquote><pre>requires AllocatableElement&lt;Alloc, T, const T&amp;&gt; &amp;&amp; MoveAssignable&lt;T&gt;
  <del>void</del> <ins>iterator</ins> insert(const_iterator position, size_type n, const T&amp; x);

template &lt;InputIterator Iter&gt;
  requires AllocatableElement&lt;Alloc, T, Iter::reference&gt; &amp;&amp; MoveAssignable&lt;T&gt;
  <del>void</del> <ins>iterator</ins> insert(const_iterator position, Iter first, Iter last);

requires AllocatableElement&lt;Alloc, T, const T&amp;&gt; &amp;&amp; MoveAssignable&lt;T&gt;
  <del>void</del> <ins>iterator</ins> insert(const_iterator position, initializer_list&lt;T&gt;);
</pre></blockquote>


<p>
23.3.4.3 [list.modifiers] change return type from <tt>void</tt> to <tt>iterator</tt> on following declarations:
</p>

<blockquote><pre>requires AllocatableElement&lt;Alloc, T, const T&amp;&gt; &amp;&amp; MoveAssignable&lt;T&gt;
  <del>void</del> <ins>iterator</ins> insert(const_iterator position, size_type n, const T&amp; x);

template &lt;InputIterator Iter&gt;
  requires AllocatableElement&lt;Alloc, T, Iter::reference&gt; &amp;&amp; MoveAssignable&lt;T&gt;
  <del>void</del> <ins>iterator</ins> insert(const_iterator position, Iter first, Iter last);
</pre></blockquote>

<p>
Add the following (missing) declaration
</p>

<blockquote><pre>requires AllocatableElement&lt;Alloc, T, const T&amp;&gt; &amp;&amp; MoveAssignable&lt;T&gt;
  iterator insert(const_iterator position, initializer_list&lt;T&gt;);
</pre></blockquote>

<p>
p2 23.3.6 [vector]
</p>

<p>
Update class definition, change return type from <tt>void</tt> to <tt>iterator</tt>:
</p>

<blockquote><pre>requires AllocatableElement&lt;Alloc, T, T&amp;&amp;&gt; &amp;&amp; MoveAssignable&lt;T&gt;
  <del>void</del> <ins>iterator</ins> insert(const_iterator position, T&amp;&amp; x);

requires AllocatableElement&lt;Alloc, T, const T&amp;&gt; &amp;&amp; MoveAssignable&lt;T&gt;
  <del>void</del> <ins>iterator</ins> insert(const_iterator position, size_type n, const T&amp; x);

template &lt;InputIterator Iter&gt;
  requires AllocatableElement&lt;Alloc, T, Iter::reference&gt; &amp;&amp; MoveAssignable&lt;T&gt;
  <del>void</del> <ins>iterator</ins> insert(const_iterator position, Iter first, Iter last);

requires AllocatableElement&lt;Alloc, T, const T&amp;&gt; &amp;&amp; MoveAssignable&lt;T&gt;
  <del>void</del> <ins>iterator</ins> insert(const_iterator position, initializer_list&lt;T&gt;);
</pre></blockquote>

<p>
23.3.6.4 [vector.modifiers] change return type from <tt>void</tt> to <tt>iterator</tt> on following declarations:
</p>

<blockquote><pre>requires AllocatableElement&lt;Alloc, T, const T&amp;&gt; &amp;&amp; MoveAssignable&lt;T&gt;
  <del>void</del> <ins>iterator</ins> insert(const_iterator position, size_type n, const T&amp; x);

template &lt;InputIterator Iter&gt;
  requires AllocatableElement&lt;Alloc, T, Iter::reference&gt; &amp;&amp; MoveAssignable&lt;T&gt;
  <del>void</del> <ins>iterator</ins> insert(const_iterator position, Iter first, Iter last);
</pre></blockquote>

<p>
Add the following (missing) declaration
</p>

<blockquote><pre>requires AllocatableElement&lt;Alloc, T, const T&amp;&gt; &amp;&amp; MoveAssignable&lt;T&gt;
  iterator insert(const_iterator position, initializer_list&lt;T&gt;);
</pre></blockquote>


<p>
p1 23.3.7 [vector.bool] Update class definition, change return type from <tt>void</tt> to <tt>iterator</tt>:
</p>

<blockquote><pre><del>void</del> <ins>iterator</ins> insert (const_iterator position, size_type n, const bool&amp; x);

template &lt;InputIterator Iter&gt;
  requires Convertible&lt;Iter::reference, bool&gt;
  <del>void</del> <ins>iterator</ins> insert(const_iterator position, Iter first, Iter last);

  <del>void</del> <ins>iterator</ins> insert(const_iterator position, initializer_list&lt;bool&gt; il);
</pre></blockquote>

<p>
p5 21.4 [basic.string] Update class definition, change return type from <tt>void</tt> to <tt>iterator</tt>:
</p>

<blockquote><pre><del>void</del> <ins>iterator</ins> insert(const_iterator p, size_type n, charT c);

template&lt;class InputIterator&gt;
  <del>void</del> <ins>iterator</ins> insert(const_iterator p, InputIterator first, InputIterator last);

<del>void</del> <ins>iterator</ins> insert(const_iterator p, initializer_list&lt;charT&gt;);
</pre></blockquote>

<p>
p13 21.4.6.4 [string::insert] change return type from <tt>void</tt> to <tt>iterator</tt>:
</p>

<blockquote><pre><del>void</del> <ins>iterator</ins> insert(const_iterator p, size_type n, charT c);
</pre></blockquote>

<p>
Add paragraph:
</p>

<blockquote>
<i>Returns:</i> an iterator which refers to the copy of the first inserted
character, or <tt>p</tt> if <tt>n == 0</tt>.
</blockquote>

<p>
p15 21.4.6.4 [string::insert] change return type from <tt>void</tt> to <tt>iterator</tt>:
</p>

<blockquote><pre>template&lt;class InputIterator&gt;
  <del>void</del> <ins>iterator</ins> insert(const_iterator p, InputIterator first, InputIterator last);
</pre></blockquote>

<p>
Add paragraph:
</p>

<blockquote>
<i>Returns:</i> an iterator which refers to the copy of the first inserted
character, or <tt>p</tt> if <tt>first == last</tt>.
</blockquote>

<p>
p17 21.4.6.4 [string::insert] change return type from <tt>void</tt> to <tt>iterator</tt>:
</p>

<blockquote><pre><del>void</del> <ins>iterator</ins> insert(const_iterator p, initializer_list&lt;charT&gt; il);
</pre></blockquote>

<p>
Add paragraph:
</p>

<blockquote>
<i>Returns:</i> an iterator which refers to the copy of the first inserted
character, or <tt>p</tt> if <tt>il</tt> is empty.
</blockquote>



<p><b>Rationale:</b></p>

<p><i>[
The following was the C++98/03 rationale and does not necessarily apply to the
proposed resolution in the C++0X time frame:
]</i></p>


<blockquote>
<p>The LWG believes this was an intentional design decision and so is
not a defect. It may be worth revisiting for the next standard.</p>
</blockquote>




<hr>
<h3><a name="190"></a>190. min() and max() functions should be std::binary_functions</h3>
<p><b>Section:</b> 25.5.7 [alg.min.max] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Mark Rintoul <b>Opened:</b> 1999-08-26  <b>Last modified:</b> 2008-03-14</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#alg.min.max">active issues</a> in [alg.min.max].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.min.max">issues</a> in [alg.min.max].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>Both std::min and std::max are defined as template functions.  This
is very different than the definition of std::plus (and similar
structs) which are defined as function objects which inherit
std::binary_function.<br>
<br>
        This lack of inheritance leaves std::min and std::max somewhat useless in standard library algorithms which require
a function object that inherits std::binary_function.</p>

<p><i>[
post Bellevue:  Alisdair requested to re-Open.
]</i></p>




<p><b>Rationale:</b></p>
<p>Although perhaps an unfortunate design decision, the omission is not a defect
in the current standard.&nbsp; A future standard may wish to consider additional
function objects.</p>




<hr>
<h3><a name="219"></a>219. find algorithm missing version that takes a binary predicate argument</h3>
<p><b>Section:</b> 25.3.5 [alg.find] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Pablo Halpern <b>Opened:</b> 2000-03-06  <b>Last modified:</b> 2009-03-09</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.find">issues</a> in [alg.find].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>The find function always searches for a value using operator== to compare the
value argument to each element in the input iterator range. This is inconsistent
with other find-related functions such as find_end and find_first_of, which
allow the caller to specify a binary predicate object to be used for determining
equality. The fact that this can be accomplished using a combination of find_if
and bind_1st or bind_2nd does not negate the desirability of a consistent,
simple, alternative interface to find.</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Reopened by Alisdair.
</blockquote>



<p><b>Proposed resolution:</b></p>
<blockquote>
<p>In section 25.3.5 [alg.find], add a second prototype for find
(between the existing prototype and the prototype for find_if), as
follows:</p>
<pre>    template&lt;class InputIterator, class T, class BinaryPredicate&gt;
      InputIterator find(InputIterator first, InputIterator last,
                         const T&amp; value, BinaryPredicate bin_pred);</pre>
<p>Change the description of the return from:</p>
<blockquote>
  <p>Returns: The first iterator i in the range [first, last) for which the following corresponding
  conditions hold: *i == value, pred(*i) != false. Returns last if no such iterator is found.</p>
</blockquote>
<p>&nbsp;to:</p>
<blockquote>
  <p>Returns: The first iterator i in the range [first, last) for which the following&nbsp;
  corresponding condition holds: *i == value, bin_pred(*i,value) != false, pred(*)
  != false. Return last if no such iterator is found.</p>
</blockquote>
</blockquote>


<p><b>Rationale:</b></p>
<p>This is request for a pure extension, so it is not a defect in the
current standard.&nbsp; As the submitter pointed out, "this can
be accomplished using a combination of find_if and bind_1st or
bind_2nd".</p>




<hr>
<h3><a name="255"></a>255. Why do <tt>basic_streambuf&lt;&gt;::pbump()</tt> and <tt>gbump()</tt> take an int?</h3>
<p><b>Section:</b> 27.6.2 [streambuf] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2000-08-12  <b>Last modified:</b> 2007-01-15</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#streambuf">issues</a> in [streambuf].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The basic_streambuf members gbump() and pbump() are specified to take an
int argument. This requirement prevents the functions from effectively
manipulating buffers larger than std::numeric_limits&lt;int&gt;::max()
characters. It also makes the common use case for these functions
somewhat difficult as many compilers will issue a warning when an
argument of type larger than int (such as ptrdiff_t on LLP64
architectures) is passed to either of the function. Since it's often the
result of the subtraction of two pointers that is passed to the
functions, a cast is necessary to silence such warnings. Finally, the
usage of a native type in the functions signatures is inconsistent with
other member functions (such as sgetn() and sputn()) that manipulate the
underlying character buffer. Those functions take a streamsize argument.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change the signatures of these functions in the synopsis of template
class basic_streambuf (27.5.2) and in their descriptions (27.5.2.3.1, p4
and 27.5.2.3.2, p4) to take a streamsize argument.
</p>

<p>
Although this change has the potential of changing the ABI of the
library, the change will affect only platforms where int is different
than the definition of streamsize. However, since both functions are
typically inline (they are on all known implementations), even on such
platforms the change will not affect any user code unless it explicitly
relies on the existing type of the functions (e.g., by taking their
address). Such a possibility is IMO quite remote.
</p>

<p>
Alternate Suggestion from Howard Hinnant, c++std-lib-7780:
</p>

<p>
This is something of a nit, but I'm wondering if streamoff wouldn't be a 
better choice than streamsize.  The argument to pbump and gbump MUST be 
signed.  But the standard has this to say about streamsize 
(27.4.1/2/Footnote):
</p>

<blockquote><p>
     [Footnote: streamsize is used in most places where ISO C would use
     size_t.  Most of the uses of streamsize could use size_t, except for
     the strstreambuf constructors, which require negative values. It
     should probably be the signed type corresponding to size_t (which is
     what Posix.2 calls ssize_t). --- end footnote]
</p></blockquote>

<p>
This seems a little weak for the argument to pbump and gbump.  Should we 
ever really get rid of strstream, this footnote might go with it, along 
with the reason to make streamsize signed.
</p>


<p><b>Rationale:</b></p>
<p>The LWG believes this change is too big for now.  We may wish to
reconsider this for a future revision of the standard.  One
possibility is overloading pbump, rather than changing the
signature.</p>
<p><i>[
[2006-05-04: Reopened at the request of Chris (Krzysztof ?elechowski)]
]</i></p>





<hr>
<h3><a name="290"></a>290. Requirements to for_each and its function object</h3>
<p><b>Section:</b> 25.3.4 [alg.foreach] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Angelika Langer <b>Opened:</b> 2001-01-03  <b>Last modified:</b> 2006-12-27</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#alg.foreach">active issues</a> in [alg.foreach].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.foreach">issues</a> in [alg.foreach].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>The specification of the for_each algorithm does not have a
"Requires" section, which means that there are no
restrictions imposed on the function object whatsoever. In essence it
means that I can provide any function object with arbitrary side
effects and I can still expect a predictable result. In particular I
can expect that the function object is applied exactly last - first
times, which is promised in the "Complexity" section.
</p>

<p>I don't see how any implementation can give such a guarantee
without imposing requirements on the function object.
</p>

<p>Just as an example: consider a function object that removes
elements from the input sequence.  In that case, what does the
complexity guarantee (applies f exactly last - first times) mean?
</p>

<p>One can argue that this is obviously a nonsensical application and
a theoretical case, which unfortunately it isn't.  I have seen
programmers shooting themselves in the foot this way, and they did not
understand that there are restrictions even if the description of the
algorithm does not say so.
</p>
<p><i>[Lillehammer: This is more general than for_each.  We don't want
  the function object in transform invalidiating iterators
  either. There should be a note somewhere in clause 17 (17, not 25)
  saying that user code operating on a range may not invalidate
  iterators unless otherwise specified.  Bill will provide wording.]</i></p>



<p><b>Proposed resolution:</b></p>






<hr>
<h3><a name="309"></a>309. Does sentry catch exceptions?</h3>
<p><b>Section:</b> 27.7 [iostream.format] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2001-03-19  <b>Last modified:</b> 2006-12-27</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#iostream.format">issues</a> in [iostream.format].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The descriptions of the constructors of basic_istream&lt;&gt;::sentry
(27.7.1.1.3 [istream::sentry]) and basic_ostream&lt;&gt;::sentry
(27.7.2.4 [ostream::sentry]) do not explain what the functions do in
case an exception is thrown while they execute. Some current
implementations allow all exceptions to propagate, others catch them
and set ios_base::badbit instead, still others catch some but let
others propagate.
</p>

<p>
The text also mentions that the functions may call setstate(failbit)
(without actually saying on what object, but presumably the stream
argument is meant).  That may have been fine for
basic_istream&lt;&gt;::sentry prior to issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#195">195</a>, since
the function performs an input operation which may fail. However,
issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#195">195</a> amends 27.7.1.1.3 [istream::sentry], p2 to
clarify that the function should actually call setstate(failbit |
eofbit), so the sentence in p3 is redundant or even somewhat
contradictory.
</p>

<p>
The same sentence that appears in 27.7.2.4 [ostream::sentry], p3
doesn't seem to be very meaningful for basic_istream&lt;&gt;::sentry
which performs no input. It is actually rather misleading since it
would appear to guide library implementers to calling
setstate(failbit) when os.tie()-&gt;flush(), the only called function,
throws an exception (typically, it's badbit that's set in response to
such an event).
</p>

<p><b>Additional comments from Martin, who isn't comfortable with the
    current proposed resolution</b> (see c++std-lib-11530)</p>

<p>
The istream::sentry ctor says nothing about how the function
deals with exemptions (27.6.1.1.2, p1 says that the class is
responsible for doing "exception safe"(*) prefix and suffix
operations but it doesn't explain what level of exception
safety the class promises to provide). The mockup example
of a "typical implementation of the sentry ctor" given in
27.6.1.1.2, p6, removed in ISO/IEC 14882:2003, doesn't show
exception handling, either. Since the ctor is not classified
as a formatted or unformatted input function, the text in
27.6.1.1, p1 through p4 does not apply. All this would seem
to suggest that the sentry ctor should not catch or in any
way handle exceptions thrown from any functions it may call.
Thus, the typical implementation of an istream extractor may
look something like [1].
</p>

<p>
The problem with [1] is that while it correctly sets ios::badbit
if an exception is thrown from one of the functions called from
the sentry ctor, if the sentry ctor reaches EOF while extracting
whitespace from a stream that has eofbit or failbit set in
exceptions(), it will cause an ios::failure to be thrown, which
will in turn cause the extractor to set ios::badbit.
</p>

<p>
The only straightforward way to prevent this behavior is to
move the definition of the sentry object in the extractor
above the try block (as suggested by the example in 22.2.8,
p9 and also indirectly supported by 27.6.1.3, p1). See [2].
But such an implementation will allow exceptions thrown from
functions called from the ctor to freely propagate to the
caller regardless of the setting of ios::badbit in the stream
object's exceptions().
</p>

<p>
So since neither [1] nor [2] behaves as expected, the only
possible solution is to have the sentry ctor catch exceptions
thrown from called functions, set badbit, and propagate those
exceptions if badbit is also set in exceptions(). (Another
solution exists that deals with both kinds of sentries, but
the code is non-obvious and cumbersome -- see [3].)
</p>

<p>
Please note that, as the issue points out, current libraries
do not behave consistently, suggesting  that implementors are
not quite clear on the exception handling in istream::sentry,
despite the fact that some LWG members might feel otherwise.
(As documented by the parenthetical comment here:
http://anubis.dkuug.dk/jtc1/sc22/wg21/docs/papers/2003/n1480.html#309)
</p>

<p>
Also please note that those LWG members who in Copenhagen
felt that "a sentry's constructor should not catch exceptions,
because sentries should only be used within (un)formatted input
functions and that exception handling is the responsibility of
those functions, not of the sentries," as noted here
http://anubis.dkuug.dk/jtc1/sc22/wg21/docs/papers/2001/n1310.html#309
would in effect be either arguing for the behavior described
in [1] or for extractors implemented along the lines of [3].
</p>

<p>
The original proposed resolution (Revision 25 of the issues
list) clarifies the role of the sentry ctor WRT exception
handling by making it clear that extractors (both library
or user-defined) should be implemented along the lines of
[2] (as opposed to [1]) and that no exception thrown from
the callees should propagate out of either function unless
badbit is also set in exceptions().
</p>


<p>[1] Extractor that catches exceptions thrown from sentry:</p>

<blockquote>
<pre>struct S { long i; };

istream&amp; operator&gt;&gt; (istream &amp;strm, S &amp;s)
{
    ios::iostate err = ios::goodbit;
    try {
        const istream::sentry guard (strm, false);
        if (guard) {
            use_facet&lt;num_get&lt;char&gt; &gt;(strm.getloc ())
                .get (istreambuf_iterator&lt;char&gt;(strm),
                      istreambuf_iterator&lt;char&gt;(),
                      strm, err, s.i);
        }
    }
    catch (...) {
        bool rethrow;
        try {
            strm.setstate (ios::badbit);
            rethrow = false;
        }
        catch (...) {
            rethrow = true;
        }
        if (rethrow)
            throw;
    }
    if (err)
        strm.setstate (err);
    return strm;
}
</pre>
</blockquote>

<p>[2] Extractor that propagates exceptions thrown from sentry:</p>

<blockquote>
<pre>istream&amp; operator&gt;&gt; (istream &amp;strm, S &amp;s)
{
    istream::sentry guard (strm, false);
    if (guard) {
        ios::iostate err = ios::goodbit;
        try {
            use_facet&lt;num_get&lt;char&gt; &gt;(strm.getloc ())
                .get (istreambuf_iterator&lt;char&gt;(strm),
                      istreambuf_iterator&lt;char&gt;(),
                      strm, err, s.i);
        }
        catch (...) {
            bool rethrow;
            try {
                strm.setstate (ios::badbit);
                rethrow = false;
            }
            catch (...) {
                rethrow = true;
            }
            if (rethrow)
                throw;
        }
        if (err)
            strm.setstate (err);
    }
    return strm;
}
</pre>
</blockquote>

<p>
[3] Extractor that catches exceptions thrown from sentry
but doesn't set badbit if the exception was thrown as a
result of a call to strm.clear().
</p>

<blockquote>
<pre>istream&amp; operator&gt;&gt; (istream &amp;strm, S &amp;s)
{
    const ios::iostate state = strm.rdstate ();
    const ios::iostate except = strm.exceptions ();
    ios::iostate err = std::ios::goodbit;
    bool thrown = true;
    try {
        const istream::sentry guard (strm, false);
        thrown = false;
        if (guard) {
            use_facet&lt;num_get&lt;char&gt; &gt;(strm.getloc ())
                .get (istreambuf_iterator&lt;char&gt;(strm),
                      istreambuf_iterator&lt;char&gt;(),
                      strm, err, s.i);
        }
    }
    catch (...) {
        if (thrown &amp;&amp; state &amp; except)
            throw;
        try {
            strm.setstate (ios::badbit);
            thrown = false;
        }
        catch (...) {
            thrown = true;
        }
        if (thrown)
            throw;
    }
    if (err)
        strm.setstate (err);

    return strm;
}
</pre>
</blockquote>

<p>
[Pre-Berlin] Reopened at the request of Paolo Carlini and Steve Clamage.
</p>

<p>
[Pre-Portland] A relevant newsgroup post:
</p>

<p>
The current proposed resolution of issue #309
(http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#309)  is
unacceptable.   I write commerical software and coding around this
makes my code ugly, non-intuitive, and requires comments referring
people to this very issue.   Following is the full explanation of my
experience.
</p>
<p>
In the course of writing software for commercial use, I constructed
std::ifstream's based on user-supplied pathnames on typical POSIX
systems.
</p>
<p>
It was expected that some files that opened successfully might not read
successfully -- such as a pathname which actually refered to a
directory.   Intuitively, I expected the streambuffer underflow() code
to throw an exception in this situation, and recent implementations of
libstdc++'s basic_filebuf do just that (as well as many of my own
custom streambufs).
</p>
<p>
I also intuitively expected that the istream code would convert these
exceptions to the "badbit' set on the stream object, because I had not
requested exceptions.    I refer to 27.6.1.1. P4.
</p>
<p>
However, this was not the case on at least two implementations -- if
the first thing I did with an istream was call operator&gt;&gt;( T&amp; ) for T
among the basic arithmetic types and std::string.   Looking further I
found that the sentry's constructor was invoking the exception when it
pre-scanned for whitespace, and the extractor function (operator&gt;&gt;())
was not catching exceptions in this situation.
</p>
<p>
So, I was in a situation where setting 'noskipws' would change the
istream's behavior even though no characters (whitespace or not) could
ever be successfully read.
</p>
<p>
Also, calling .peek() on the istream before calling the extractor()
changed the behavior (.peek() had the effect of setting the badbit
ahead of time).
</p>
<p>
I found this all to be so inconsistent and inconvenient for me and my
code design, that I filed a bugzilla entry for libstdc++.   I was then
told that the bug cannot be fixed until issue #309 is resolved by the
committee.
</p>



<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>The LWG agrees there is minor variation between implementations,
  but believes that it doesn't matter. This is a rarely used corner
  case. There is no evidence that this has any commercial importance
  or that it causes actual portability problems for customers trying
  to write code that runs on multiple implementations.</p>





<hr>
<h3><a name="342"></a>342. seek and eofbit</h3>
<p><b>Section:</b> 27.7.1.3 [istream.unformatted] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2001-10-09  <b>Last modified:</b> 2007-01-15</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#istream.unformatted">issues</a> in [istream.unformatted].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>I think we have a defect.</p>

<p>According to lwg issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#60">60</a> which is now a dr, the
description of seekg in 27.7.1.3 [istream.unformatted] paragraph 38 now looks
like:</p>

<blockquote><p>
Behaves as an unformatted input function (as described in 27.6.1.3, 
paragraph 1), except that it does not count the number of characters 
extracted and does not affect the value returned by subsequent calls to 
gcount(). After constructing a sentry object, if fail() != true, 
executes rdbuf()-&gt;pubseekpos( pos).
</p></blockquote>

<p>And according to lwg issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#243">243</a> which is also now a dr,
27.6.1.3, paragraph 1 looks like:</p>

<blockquote><p>
Each unformatted input function begins execution by constructing an 
object of class sentry with the default argument noskipws (second) 
argument true. If the sentry object returns true, when converted to a 
value of type bool, the function endeavors to obtain the requested 
input.  Otherwise, if the sentry constructor exits by throwing an 
exception or if the sentry object returns false, when converted to a 
value of type bool, the function returns without attempting to obtain 
any input. In either case the number of extracted characters is set to 
0; unformatted input functions taking a character array of non-zero 
size as an argument shall also store a null character (using charT()) 
in the first location of the array. If an exception is thrown during 
input then ios::badbit is turned on in *this'ss error state. If 
(exception()&amp;badbit)!= 0 then the exception is rethrown. It also counts 
the number of characters extracted. If no exception has been thrown it 
ends by storing the count in a member object and returning the value 
specified. In any event the sentry object is destroyed before leaving 
the unformatted input function.
</p></blockquote>

<p>And finally 27.6.1.1.2/5 says this about sentry:</p>

<blockquote><p>
If, after any preparation is completed, is.good() is true, ok_ != false 
otherwise, ok_ == false.
</p></blockquote>

<p>
So although the seekg paragraph says that the operation proceeds if 
!fail(), the behavior of unformatted functions says the operation 
proceeds only if good().  The two statements are contradictory when only 
eofbit is set.  I don't think the current text is clear which condition 
should be respected.
</p>

<p><b>Further discussion from Redmond:</b></p>

<p>PJP: It doesn't seem quite right to say that <tt>seekg</tt> is
"unformatted". That makes specific claims about sentry that
aren't quite appropriate for seeking, which has less fragile failure
modes than actual input.  If we do really mean that it's unformatted
input, it should behave the same way as other unformatted input.  On
the other hand, "principle of least surprise" is that seeking from EOF
ought to be OK.</p>

<p>
Pre-Berlin:  Paolo points out several problems with the proposed resolution in
Ready state:
</p>

<ul>
<li>It should apply to both overloads of seekg.</li>
<li>tellg has similar issues, except that it should not call clear().</li>
<li>The point about clear() seems to apply to seekp().</li>
<li>Depending on the outcome of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#419">419</a>
if the sentry
sets <tt>failbit</tt> when it finds <tt>eofbit</tt> already set, then
you can never seek away from the end of stream.</li>
</ul>



<p><b>Proposed resolution:</b></p>

<p>Change 27.7.1.3 [istream.unformatted] to:</p>
<blockquote><p>
Behaves as an unformatted input function (as described in 27.6.1.3,
paragraph 1), except that it does not count the number of characters
extracted, does not affect the value returned by subsequent calls to
gcount(), and does not examine the value returned by the sentry
object. After constructing a sentry object, if <tt>fail() !=
true</tt>, executes <tt>rdbuf()-&gt;pubseekpos(pos)</tt>.  In
case of success, the function calls clear().
In case of failure, the function calls <tt>setstate(failbit)</tt>
(which may throw <tt>ios_base::failure</tt>).
</p></blockquote>

<p><i>[Lillehammer: Matt provided wording.]</i></p>




<p><b>Rationale:</b></p>
<p>In C, fseek does clear EOF.  This is probably what most users would
  expect.  We agree that having eofbit set should not deter a seek,
  and that a successful seek should clear eofbit. Note
  that <tt>fail()</tt> is true only if <tt>failbit</tt>
  or <tt>badbit</tt> is set, so using <tt>!fail()</tt>, rather
  than <tt>good()</tt>, satisfies this goal.</p>





<hr>
<h3><a name="343"></a>343. Unspecified library header dependencies</h3>
<p><b>Section:</b> 17 [library] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2001-10-09  <b>Last modified:</b> 2009-03-11</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The synopses of the C++ library headers clearly show which names are
required to be defined in each header. Since in order to implement the
classes and templates defined in these headers declarations of other
templates (but not necessarily their definitions) are typically
necessary the standard in 17.4.4, p1 permits library implementers to
include any headers needed to implement the definitions in each header.
</p>

<p>
For instance, although it is not explicitly specified in the synopsis of
&lt;string&gt;, at the point of definition of the std::basic_string template
the declaration of the std::allocator template must be in scope. All
current implementations simply include &lt;memory&gt; from within &lt;string&gt;,
either directly or indirectly, to bring the declaration of
std::allocator into scope.
</p>

<p>
Additionally, however, some implementation also include &lt;istream&gt; and
&lt;ostream&gt; at the top of &lt;string&gt; to bring the declarations of
std::basic_istream and std::basic_ostream into scope (which are needed
in order to implement the string inserter and extractor operators
(21.3.7.9 [lib.string.io])). Other implementations only include
&lt;iosfwd&gt;, since strictly speaking, only the declarations and not the
full definitions are necessary.
</p>

<p>
Obviously, it is possible to implement &lt;string&gt; without actually
providing the full definitions of all the templates std::basic_string
uses (std::allocator, std::basic_istream, and std::basic_ostream).
Furthermore, not only is it possible, doing so is likely to have a
positive effect on compile-time efficiency.
</p>

<p>
But while it may seem perfectly reasonable to expect a program that uses
the std::basic_string insertion and extraction operators to also
explicitly include &lt;istream&gt; or &lt;ostream&gt;, respectively, it doesn't seem
reasonable to also expect it to explicitly include &lt;memory&gt;. Since
what's reasonable and what isn't is highly subjective one would expect
the standard to specify what can and what cannot be assumed.
Unfortunately, that isn't the case.
</p>

<p>The examples below demonstrate the issue.</p>

<p>Example 1:</p>

<p>It is not clear whether the following program is complete:</p>

<pre>#include &lt;string&gt;

extern std::basic_ostream&lt;char&gt; &amp;strm;

int main () {
    strm &lt;&lt; std::string ("Hello, World!\n");
}
</pre>    

<p>or whether one must explicitly include &lt;memory&gt; or
&lt;ostream&gt; (or both) in addition to &lt;string&gt; in order for
the program to compile.</p>


<p>Example 2:</p>

<p>Similarly, it is unclear whether the following program is complete:</p>

<pre>#include &lt;istream&gt;

extern std::basic_iostream&lt;char&gt; &amp;strm;

int main () {
    strm &lt;&lt; "Hello, World!\n";
}
</pre>

<p>
or whether one needs to explicitly include &lt;ostream&gt;, and
perhaps even other headers containing the definitions of other
required templates:</p>

<pre>#include &lt;ios&gt;
#include &lt;istream&gt;
#include &lt;ostream&gt;
#include &lt;streambuf&gt;

extern std::basic_iostream&lt;char&gt; &amp;strm;

int main () {
    strm &lt;&lt; "Hello, World!\n";
}
</pre>

<p>Example 3:</p>

<p>Likewise, it seems unclear whether the program below is complete:</p>
<pre>#include &lt;iterator&gt;

bool foo (std::istream_iterator&lt;int&gt; a, std::istream_iterator&lt;int&gt; b)
{
    return a == b;
}

int main () { }
</pre>

<p>or whether one should be required to include &lt;istream&gt;.</p>

<p>There are many more examples that demonstrate this lack of a
requirement.  I believe that in a good number of cases it would be
unreasonable to require that a program explicitly include all the
headers necessary for a particular template to be specialized, but I
think that there are cases such as some of those above where it would
be desirable to allow implementations to include only as much as
necessary and not more.</p>

<p><i>[
post Bellevue:
]</i></p>


<blockquote>
Position taken in prior reviews is that the idea of a table of header
dependencies is a good one. Our view is that a full paper is needed to
do justice to this, and we've made that recommendation to the issue
author.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
For every C++ library header, supply a minimum set of other C++ library
headers that are required to be included by that header. The proposed
list is below (C++ headers for C Library Facilities, table 12 in
17.4.1.2, p3, are omitted):
</p>

<pre>+------------+--------------------+
| C++ header |required to include |
+============+====================+
|&lt;algorithm&gt; |                    |
+------------+--------------------+
|&lt;bitset&gt;    |                    |
+------------+--------------------+
|&lt;complex&gt;   |                    |
+------------+--------------------+
|&lt;deque&gt;     |&lt;memory&gt;            |
+------------+--------------------+
|&lt;exception&gt; |                    |
+------------+--------------------+
|&lt;fstream&gt;   |&lt;ios&gt;               |
+------------+--------------------+
|&lt;functional&gt;|                    |
+------------+--------------------+
|&lt;iomanip&gt;   |&lt;ios&gt;               |
+------------+--------------------+
|&lt;ios&gt;       |&lt;streambuf&gt;         |
+------------+--------------------+
|&lt;iosfwd&gt;    |                    |
+------------+--------------------+
|&lt;iostream&gt;  |&lt;istream&gt;, &lt;ostream&gt;|
+------------+--------------------+
|&lt;istream&gt;   |&lt;ios&gt;               |
+------------+--------------------+
|&lt;iterator&gt;  |                    |
+------------+--------------------+
|&lt;limits&gt;    |                    |
+------------+--------------------+
|&lt;list&gt;      |&lt;memory&gt;            |
+------------+--------------------+
|&lt;locale&gt;    |                    |
+------------+--------------------+
|&lt;map&gt;       |&lt;memory&gt;            |
+------------+--------------------+
|&lt;memory&gt;    |                    |
+------------+--------------------+
|&lt;new&gt;       |&lt;exception&gt;         |
+------------+--------------------+
|&lt;numeric&gt;   |                    |
+------------+--------------------+
|&lt;ostream&gt;   |&lt;ios&gt;               |
+------------+--------------------+
|&lt;queue&gt;     |&lt;deque&gt;             |
+------------+--------------------+
|&lt;set&gt;       |&lt;memory&gt;            |
+------------+--------------------+
|&lt;sstream&gt;   |&lt;ios&gt;, &lt;string&gt;     |
+------------+--------------------+
|&lt;stack&gt;     |&lt;deque&gt;             |
+------------+--------------------+
|&lt;stdexcept&gt; |                    |
+------------+--------------------+
|&lt;streambuf&gt; |&lt;ios&gt;               |
+------------+--------------------+
|&lt;string&gt;    |&lt;memory&gt;            |
+------------+--------------------+
|&lt;strstream&gt; |                    |
+------------+--------------------+
|&lt;typeinfo&gt;  |&lt;exception&gt;         |
+------------+--------------------+
|&lt;utility&gt;   |                    |
+------------+--------------------+
|&lt;valarray&gt;  |                    |
+------------+--------------------+
|&lt;vector&gt;    |&lt;memory&gt;            |
+------------+--------------------+
</pre>


<p><b>Rationale:</b></p>
<p>The portability problem is real.  A program that works correctly on
one implementation might fail on another, because of different header
dependencies.  This problem was understood before the standard was
completed, and it was a conscious design choice.</p>
<p>One possible way to deal with this, as a library extension, would
be an &lt;all&gt; header.</p>

<p>
Hinnant:  It's time we dealt with this issue for C++0X.  Reopened.
</p>







<hr>
<h3><a name="382"></a>382. codecvt do_in/out result</h3>
<p><b>Section:</b> 22.4.1.4 [locale.codecvt] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2002-08-30  <b>Last modified:</b> 2007-01-15</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#locale.codecvt">active issues</a> in [locale.codecvt].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.codecvt">issues</a> in [locale.codecvt].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It seems that the descriptions of codecvt do_in() and do_out() leave
sufficient room for interpretation so that two implementations of
codecvt may not work correctly with the same filebuf. Specifically,
the following seems less than adequately specified:
</p>

<ol>
<li>
  the conditions under which the functions terminate
</li>
<li>
  precisely when the functions return ok
</li>
<li>
  precisely when the functions return partial
</li>
<li>
  the full set of conditions when the functions return error
</li>
</ol>

<ol>
<li>
   22.4.1.4.2 [locale.codecvt.virtuals], p2 says this about the effects of the
   function: ...Stops if it encounters a character it cannot
   convert...  This assumes that there *is* a character to
   convert. What happens when there is a sequence that doesn't form a
   valid source character, such as an unassigned or invalid UNICODE
   character, or a sequence that cannot possibly form a character
   (e.g., the sequence "\xc0\xff" in UTF-8)?
</li>
<li>
   Table 53 says that the function returns codecvt_base::ok
   to indicate that the function(s) "completed the conversion."
   Suppose that the source sequence is "\xc0\x80" in UTF-8,
   with from pointing to '\xc0' and (from_end==from + 1).
   It is not clear whether the return value should be ok
   or partial (see below).
</li>
<li>
   Table 53 says that the function returns codecvt_base::partial
   if "not all source characters converted." With the from pointers
   set up the same way as above, it is not clear whether the return
   value should be partial or ok (see above).
</li>
<li>
   Table 53, in the row describing the meaning of error mistakenly
   refers to a "from_type" character, without the symbol from_type
   having been defined. Most likely, the word "source" character
   is intended, although that is not sufficient. The functions
   may also fail when they encounter an invalid source sequence
   that cannot possibly form a valid source character (e.g., as
   explained in bullet 1 above).
</li>
</ol>
<p>
Finally, the conditions described at the end of 22.4.1.4.2 [locale.codecvt.virtuals], p4 don't seem to be possible:
</p>
<blockquote><p>
    "A return value of partial, if (from_next == from_end),
    indicates that either the destination sequence has not
    absorbed all the available destination elements, or that
    additional source elements are needed before another
    destination element can be produced."
</p></blockquote>
<p>
If the value is partial, it's not clear to me that (from_next
==from_end) could ever hold if there isn't enough room
in the destination buffer. In order for (from_next==from_end) to
hold, all characters in that range must have been successfully
converted (according to 22.4.1.4.2 [locale.codecvt.virtuals], p2) and since there are no
further source characters to convert, no more room in the
destination buffer can be needed.
</p>
<p>
It's also not clear to me that (from_next==from_end) could ever
hold if additional source elements are needed to produce another
destination character (not element as incorrectly stated in the
text). partial is returned if "not all source characters have
been converted" according to Table 53, which also implies that
(from_next==from) does NOT hold.
</p>
<p>
Could it be that the intended qualifying condition was actually
(from_next != from_end), i.e., that the sentence was supposed
to read
</p>
<blockquote><p>
    "A return value of partial, if (from_next != from_end),..."
</p></blockquote>
<p>
which would make perfect sense, since, as far as I understand it,
partial can only occur if (from_next != from_end)?
</p>
<p><i>[Lillehammer: Defer for the moment, but this really needs to be
  fixed. Right now, the description of codecvt is too vague for it to
  be a useful contract between providers and clients of codecvt
  facets.  (Note that both vendors and users can be both providers and
  clients of codecvt facets.) The major philosophical issue is whether
  the standard should only describe mappings that take a single wide
  character to multiple narrow characters (and vice versa), or whether
  it should describe fully general N-to-M conversions. When the
  original standard was written only the former was contemplated, but
  today, in light of the popularity of utf8 and utf16, that doesn't
  seem sufficient for C++0x. Bill supports general N-to-M conversions;
  we need to make sure Martin and Howard agree.]</i></p>



<p><b>Proposed resolution:</b></p>




<hr>
<h3><a name="394"></a>394. behavior of formatted output on failure</h3>
<p><b>Section:</b> 27.7.2.6.1 [ostream.formatted.reqmts] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2002-12-27  <b>Last modified:</b> 2007-01-15</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There is a contradiction in Formatted output about what bit is
supposed to be set if the formatting fails. On sentence says it's
badbit and another that it's failbit.
</p>
<p>
27.6.2.5.1, p1 says in the Common Requirements on Formatted output
functions:
</p>
<pre>     ... If the generation fails, then the formatted output function
     does setstate(ios::failbit), which might throw an exception.
</pre>
<p>
27.6.2.5.2, p1 goes on to say this about Arithmetic Inserters:
</p>
<p>
     ... The formatting conversion occurs as if it performed the
     following code fragment:
</p>
<pre>     bool failed =
         use_facet&lt;num_put&lt;charT,ostreambuf_iterator&lt;charT,traits&gt;
         &gt; &gt;
         (getloc()).put(*this, *this, fill(), val). failed();

     ... If failed is true then does setstate(badbit) ...
</pre>
<p>
The original intent of the text, according to Jerry Schwarz (see
c++std-lib-10500), is captured in the following paragraph:
</p>
<p>
In general "badbit" should mean that the stream is unusable because
of some underlying failure, such as disk full or socket closure;
"failbit" should mean that the requested formatting wasn't possible
because of some inconsistency such as negative widths.  So typically
if you clear badbit and try to output something else you'll fail
again, but if you clear failbit and try to output something else
you'll succeed.
</p>
<p>
In the case of the arithmetic inserters, since num_put cannot
report failure by any means other than exceptions (in response
to which the stream must set badbit, which prevents the kind of
recoverable error reporting mentioned above), the only other
detectable failure is if the iterator returned from num_put
returns true from failed().
</p>
<p>
Since that can only happen (at least with the required iostream
specializations) under such conditions as the underlying failure
referred to above (e.g., disk full), setting badbit would seem
to be the appropriate response (indeed, it is required in
27.6.2.5.2, p1). It follows that failbit can never be directly
set by the arithmetic (it can only be set by the sentry object
under some unspecified conditions).
</p>
<p>
The situation is different for other formatted output functions
which can fail as a result of the streambuf functions failing
(they may do so by means other than exceptions), and which are
then required to set failbit.
</p>
<p>
The contradiction, then, is that ostream::operator&lt;&lt;(int) will
set badbit if the disk is full, while operator&lt;&lt;(ostream&amp;,
char) will set failbit under the same conditions. To make the behavior
consistent, the Common requirements sections for the Formatted output
functions should be changed as proposed below.
</p>
<p><i>[Kona: There's agreement that this is a real issue.  What we
  decided at Kona: 1. An error from the buffer (which can be detected
  either directly from streambuf's member functions or by examining a
  streambuf_iterator) should always result in badbit getting set.
  2. There should never be a circumstance where failbit gets set.
  That represents a formatting error, and there are no circumstances
  under which the output facets are specified as signaling a
  formatting error. (Even more so for string output that for numeric
  because there's nothing to format.)  If we ever decide to make it
  possible for formatting errors to exist then the facets can signal
  the error directly, and that should go in clause 22, not clause 27.
  3. The phrase "if generation fails" is unclear and should be
  eliminated.  It's not clear whether it's intended to mean a buffer
  error (e.g. a full disk), a formatting error, or something else.
  Most people thought it was supposed to refer to buffer errors; if
  so, we should say so.  Martin will provide wording.]</i></p>




<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>






<hr>
<h3><a name="397"></a>397. ostream::sentry dtor throws exceptions</h3>
<p><b>Section:</b> 27.7.2.4 [ostream::sentry] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2003-01-05  <b>Last modified:</b> 2007-07-25</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#ostream::sentry">active issues</a> in [ostream::sentry].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#ostream::sentry">issues</a> in [ostream::sentry].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
    <p>
17.4.4.8, p3 prohibits library dtors from throwing exceptions.
    </p>
    <p>
27.6.2.3, p4 says this about the ostream::sentry dtor:
    </p>
    <pre>    -4- If ((os.flags() &amp; ios_base::unitbuf) &amp;&amp; !uncaught_exception())
        is true, calls os.flush().
    </pre>
    <p>
27.6.2.6, p7 that describes ostream::flush() says:
    </p>
    <pre>    -7- If rdbuf() is not a null pointer, calls rdbuf()-&gt;pubsync().
        If that function returns ?-1 calls setstate(badbit) (which
        may throw ios_base::failure (27.4.4.3)).
    </pre>
    <p>
That seems like a defect, since both pubsync() and setstate() can
throw an exception. 
    </p>
<p><i>[
The contradiction is real.  Clause 17 says destructors may never
throw exceptions, and clause 27 specifies a destructor that does
throw.  In principle we might change either one.  We're leaning
toward changing clause 17: putting in an "unless otherwise specified"
clause, and then putting in a footnote saying the sentry destructor
is the only one that can throw.  PJP suggests specifying that
sentry::~sentry() should internally catch any exceptions it might cause.
]</i></p>


<p><i>[
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#418">418</a> and <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#622">622</a> for related issues.
]</i></p>


  

<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="398"></a>398. effects of end-of-file on unformatted input functions</h3>
<p><b>Section:</b> 27.7.2.4 [ostream::sentry] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2003-01-05  <b>Last modified:</b> 2007-01-15</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#ostream::sentry">active issues</a> in [ostream::sentry].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#ostream::sentry">issues</a> in [ostream::sentry].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
    <p>
While reviewing unformatted input member functions of istream
for their behavior when they encounter end-of-file during input
I found that the requirements vary, sometimes unexpectedly, and
in more than one case even contradict established practice (GNU
libstdc++ 3.2, IBM VAC++ 6.0, STLPort 4.5, SunPro 5.3, HP aCC
5.38, Rogue Wave libstd 3.1, and Classic Iostreams).
    </p>
    <p>
The following unformatted input member functions set eofbit if they
encounter an end-of-file (this is the expected behavior, and also
the behavior of all major implementations):
    </p>
    <pre>    basic_istream&lt;charT, traits&gt;&amp;
    get (char_type*, streamsize, char_type);
    </pre>
    <p>
    Also sets failbit if it fails to extract any characters.
    </p>
    <pre>    basic_istream&lt;charT, traits&gt;&amp;
    get (char_type*, streamsize);
    </pre>
    <p>
    Also sets failbit if it fails to extract any characters.
    </p>
    <pre>    basic_istream&lt;charT, traits&gt;&amp;
    getline (char_type*, streamsize, char_type);
    </pre>
    <p>
    Also sets failbit if it fails to extract any characters.
    </p>
    <pre>    basic_istream&lt;charT, traits&gt;&amp;
    getline (char_type*, streamsize);
    </pre>
    <p>
    Also sets failbit if it fails to extract any characters.
    </p>
    <pre>    basic_istream&lt;charT, traits&gt;&amp;
    ignore (int, int_type);
    </pre>
    <pre>    basic_istream&lt;charT, traits&gt;&amp;
    read (char_type*, streamsize);
    </pre>
    <p>
    Also sets failbit if it encounters end-of-file.
    </p>
    <pre>    streamsize readsome (char_type*, streamsize);
    </pre>

    <p>
The following unformated input member functions set failbit but
not eofbit if they encounter an end-of-file (I find this odd
since the functions make it impossible to distinguish a general
failure from a failure due to end-of-file; the requirement is
also in conflict with all major implementation which set both
eofbit and failbit):
    </p>
    <pre>    int_type get();
    </pre>
    <pre>    basic_istream&lt;charT, traits&gt;&amp;
    get (char_type&amp;);
    </pre>
    <p>
These functions only set failbit of they extract no characters,
otherwise they don't set any bits, even on failure (I find this
inconsistency quite unexpected; the requirement is also in
conflict with all major implementations which set eofbit
whenever they encounter end-of-file):
    </p>
    <pre>    basic_istream&lt;charT, traits&gt;&amp;
    get (basic_streambuf&lt;charT, traits&gt;&amp;, char_type);
    </pre>
    <pre>    basic_istream&lt;charT, traits&gt;&amp;
    get (basic_streambuf&lt;charT, traits&gt;&amp;);
    </pre>
    <p>
This function sets no bits (all implementations except for
STLport and Classic Iostreams set eofbit when they encounter
end-of-file):
    </p>
    <pre>    int_type peek ();
    </pre>
<p>Informally, what we want is a global statement of intent saying
  that eofbit gets set if we trip across EOF, and then we can take
  away the specific wording for individual functions.  A full review
  is necessary.  The wording currently in the standard is a mishmash,
  and changing it on an individual basis wouldn't make things better.
  Dietmar will do this work.</p>
  

<p><b>Proposed resolution:</b></p>




<hr>
<h3><a name="408"></a>408. Is vector&lt;reverse_iterator&lt;char*&gt; &gt; forbidden?</h3>
<p><b>Section:</b> 24.2 [iterator.concepts] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Nathan Myers <b>Opened:</b> 2003-06-03  <b>Last modified:</b> 2009-05-10</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#iterator.concepts">active issues</a> in [iterator.concepts].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#iterator.concepts">issues</a> in [iterator.concepts].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I've been discussing iterator semantics with Dave Abrahams, and a 
surprise has popped up.  I don't think this has been discussed before.
</p>

<p>
24.2 [iterator.concepts] says that the only operation that can be performed on "singular"
iterator values is to assign a non-singular value to them.  (It 
doesn't say they can be destroyed, and that's probably a defect.)  
Some implementations have taken this to imply that there is no need 
to initialize the data member of a reverse_iterator&lt;&gt; in the default
constructor.  As a result, code like
</p>
<blockquote><pre>  std::vector&lt;std::reverse_iterator&lt;char*&gt; &gt; v(7);
  v.reserve(1000);
</pre></blockquote>
<p>
invokes undefined behavior, because it must default-initialize the
vector elements, and then copy them to other storage.  Of course many 
other vector operations on these adapters are also left undefined,
and which those are is not reliably deducible from the standard.
</p>

<p>
I don't think that 24.1 was meant to make standard-library iterator 
types unsafe.  Rather, it was meant to restrict what operations may 
be performed by functions which take general user- and standard 
iterators as arguments, so that raw pointers would qualify as
iterators.  However, this is not clear in the text, others have come 
to the opposite conclusion.
</p>

<p>
One question is whether the standard iterator adaptors have defined
copy semantics.  Another is whether they have defined destructor
semantics: is
</p>
<blockquote><pre>  { std::vector&lt;std::reverse_iterator&lt;char*&gt; &gt;  v(7); }
</pre></blockquote>
<p>
undefined too?
</p>

<p>
Note this is not a question of whether algorithms are allowed to
rely on copy semantics for arbitrary iterators, just whether the
types we actually supply support those operations.  I believe the 
resolution must be expressed in terms of the semantics of the 
adapter's argument type.  It should make clear that, e.g., the 
reverse_iterator&lt;T&gt; constructor is actually required to execute
T(), and so copying is defined if the result of T() is copyable.
</p>

<p>
Issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#235">235</a>, which defines reverse_iterator's default
constructor more precisely, has some relevance to this issue.
However, it is not the whole story.
</p>

<p>
The issue was whether 
</p>
<blockquote><pre>  reverse_iterator() { }
</pre></blockquote>
<p>
is allowed, vs. 
</p>
<blockquote><pre>  reverse_iterator() : current() { }
</pre></blockquote>

<p>
The difference is when T is char*, where the first leaves the member
uninitialized, and possibly equal to an existing pointer value, or
(on some targets) may result in a hardware trap when copied.
</p>

<p>
8.5 paragraph 5 seems to make clear that the second is required to
satisfy DR <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#235">235</a>, at least for non-class Iterator argument
types.
</p>

<p>
But that only takes care of reverse_iterator, and doesn't establish
a policy for all iterators.  (The reverse iterator adapter was just
an example.)  In particular, does my function
</p>
<blockquote><pre>  template &lt;typename Iterator&gt;
    void f() { std::vector&lt;Iterator&gt;  v(7); } 
</pre></blockquote>
<p>
evoke undefined behavior for some conforming iterator definitions?
I think it does, now, because vector&lt;&gt; will destroy those singular
iterator values, and that's explicitly disallowed.
</p>

<p>
24.1 shouldn't give blanket permission to copy all singular iterators,
because then pointers wouldn't qualify as iterators.  However, it
should allow copying of that subset of singular iterator values that
are default-initialized, and it should explicitly allow destroying any
iterator value, singular or not, default-initialized or not.
</p>

<p>Related issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#407">407</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1012">1012</a></p>
<p><i>[
We don't want to require all singular iterators to be copyable,
because that is not the case for pointers.  However, default
construction may be a special case.  Issue: is it really default
construction we want to talk about, or is it something like value
initialization?  We need to check with core to see whether default
constructed pointers are required to be copyable; if not, it would be
wrong to impose so strict a requirement for iterators.
]</i></p>


<p><i>[
2009-05-10 Alisdair provided wording.
]</i></p>


<blockquote>
The comments regarding destroying singular iterators have already been
resolved.  That just leaves copying (with moving implied).
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add to the end of Iterator concepts 24.2 [iterator.concepts] para 6 (the one
describing singular iterators)
</p>
<blockquote>
Any Iterator that satisfies the <tt>DefaultConstructible</tt> concept shall
be safely copyable after value-initialization, even if it would otherwise be
singular. [<i>Note:</i> This guarantee is not offered for default-initialization
(8.5 [dcl.init]), although the distinction only matters for types with
trivial default constructors such as pointers. &#8212; <i>end note</i>]
</blockquote>






<hr>
<h3><a name="417"></a>417. what does ctype::do_widen() return on failure</h3>
<p><b>Section:</b> 22.4.1.1.2 [locale.ctype.virtuals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2003-09-18  <b>Last modified:</b> 2006-12-27</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.ctype.virtuals">issues</a> in [locale.ctype.virtuals].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The Effects and Returns clauses of the do_widen() member function of
the ctype facet fail to specify the behavior of the function on failure.
That the function may not be able to simply cast the narrow character
argument to the type of the result since doing so may yield the wrong value
for some wchar_t encodings. Popular implementations of ctype&lt;wchar_t&gt; that
use mbtowc() and UTF-8 as the native encoding (e.g., GNU glibc) will fail
when the argument's MSB is set. There is no way for the the rest of locale
and iostream to reliably detect this failure. 
</p>
<p><i>[Kona: This is a real problem.  Widening can fail.  It's unclear
  what the solution should be.  Returning WEOF works for the wchar_t
  specialization, but not in general.  One option might be to add a
  default, like <i>narrow</i>.  But that's an incompatible change.
  Using <i>traits::eof</i> might seem like a good idea, but facets
  don't have access to traits (a recurring problem).  We could
  have <i>widen</i> throw an exception, but that's a scary option;
  existing library components aren't written with the assumption
  that <i>widen</i> can throw.]</i></p>



<p><b>Proposed resolution:</b></p>




<hr>
<h3><a name="418"></a>418. exceptions thrown during iostream cleanup</h3>
<p><b>Section:</b> 27.5.2.1.6 [ios::Init] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2003-09-18  <b>Last modified:</b> 2007-07-25</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#ios::Init">active issues</a> in [ios::Init].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#ios::Init">issues</a> in [ios::Init].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The dtor of the ios_base::Init object is supposed to call flush() on the
6 standard iostream objects cout, cerr, clog, wcout, wcerr, and wclog.
This call may cause an exception to be thrown.
</p>

<p>
17.4.4.8, p3 prohibits all library destructors from throwing exceptions.
</p>

<p>
The question is: What should this dtor do if one or more of these calls
to flush() ends up throwing an exception? This can happen quite easily
if one of the facets installed in the locale imbued in the iostream
object throws.
</p>
<p><i>[Kona: We probably can't do much better than what we've got, so
  the LWG is leaning toward NAD.  At the point where the standard
  stream objects are being cleaned up, the usual error reporting
  mechanism are all unavailable.  And exception from flush at this
  point will definitely cause problems.  A quality implementation
  might reasonably swallow the exception, or call abort, or do
  something even more drastic.]</i></p>


<p><i>[
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#397">397</a> and <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#622">622</a> for related issues.
]</i></p>




<p><b>Proposed resolution:</b></p>




<hr>
<h3><a name="419"></a>419. istream extractors not setting failbit if eofbit is already set</h3>
<p><b>Section:</b> 27.7.1.1.3 [istream::sentry] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2003-09-18  <b>Last modified:</b> 2007-01-30</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#istream::sentry">issues</a> in [istream::sentry].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
        <p>

27.7.1.1.3 [istream::sentry], p2 says that istream::sentry ctor prepares for input if is.good()
is true. p4 then goes on to say that the ctor sets the sentry::ok_ member to
true if the stream state is good after any preparation. 27.7.1.2.1 [istream.formatted.reqmts], p1 then
says that a formatted input function endeavors to obtain the requested input
if the sentry's operator bool() returns true.

Given these requirements, no formatted extractor should ever set failbit if
the initial stream rdstate() == eofbit. That is contrary to the behavior of
all implementations I tested. The program below prints out

eof = 1, fail = 0
eof = 1, fail = 1

on all of them.
        </p>
<pre>
#include &lt;sstream&gt;
#include &lt;cstdio&gt;

int main()
{
    std::istringstream strm ("1");

    int i = 0;

    strm &gt;&gt; i;

    std::printf ("eof = %d, fail = %d\n",
                 !!strm.eof (), !!strm.fail ());

    strm &gt;&gt; i;

    std::printf ("eof = %d, fail = %d\n",
                 !!strm.eof (), !!strm.fail ());
}

</pre>
        <p>
<br>

Comments from Jerry Schwarz (c++std-lib-11373):
<br>

Jerry Schwarz wrote:
<br>

I don't know where (if anywhere) it says it in the standard, but the
formatted extractors are supposed to set failbit if they don't extract
any characters. If they didn't then simple loops like
<br>

while (cin &gt;&gt; x);
<br>

would loop forever.
<br>

Further comments from Martin Sebor:
<br>

The question is which part of the extraction should prevent this from happening
by setting failbit when eofbit is already set. It could either be the sentry
object or the extractor. It seems that most implementations have chosen to
set failbit in the sentry [...] so that's the text that will need to be
corrected. 

        </p>
<p>
Pre Berlin:  This issue is related to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#342">342</a>.  If the sentry
sets <tt>failbit</tt> when it finds <tt>eofbit</tt> already set, then
you can never seek away from the end of stream.
</p>
<p>Kona: Possibly NAD.  If eofbit is set then good() will return false.  We
  then set <i>ok</i> to false.  We believe that the sentry's
  constructor should always set failbit when <i>ok</i> is false, and
  we also think the standard already says that.  Possibly it could be
  clearer.</p> 

    

<p><b>Proposed resolution:</b></p>
<p>
Change 27.7.1.1.3 [istream::sentry], p2 to:
</p>

<blockquote>
<pre>explicit sentry(basic_istream&lt;charT,traits&gt;&amp; <i>is</i> , bool <i>noskipws</i> = false);</pre>
<p>
-2- <i>Effects:</i> If <tt>is.good()</tt> is <del><tt>true</tt></del>
<ins><tt>false</tt></ins>, <ins>calls <tt>is.setstate(failbit)</tt>. 
Otherwise</ins> prepares for formatted or unformatted input. ...
</p>
</blockquote>






<hr>
<h3><a name="421"></a>421. is basic_streambuf copy-constructible?</h3>
<p><b>Section:</b> 27.6.2.1 [streambuf.cons] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2003-09-18  <b>Last modified:</b> 2007-01-15</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#streambuf.cons">issues</a> in [streambuf.cons].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The reflector thread starting with c++std-lib-11346 notes that the class
template basic_streambuf, along with basic_stringbuf and basic_filebuf,
is copy-constructible but that the semantics of the copy constructors
are not defined anywhere. Further, different implementations behave
differently in this respect: some prevent copy construction of objects
of these types by declaring their copy ctors and assignment operators
private, others exhibit undefined behavior, while others still give
these operations well-defined semantics.
</p>

<p>
Note that this problem doesn't seem to be isolated to just the three
types mentioned above. A number of other types in the library section
of the standard provide a compiler-generated copy ctor and assignment
operator yet fail to specify their semantics.  It's believed that the
only types for which this is actually a problem (i.e. types where the
compiler-generated default may be inappropriate and may not have been
intended) are locale facets.  See issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#439">439</a>.
</p>


<p><b>Proposed resolution:</b></p>
<p>
27.5.2 [lib.streambuf]:  Add into the synopsis, public section, just above the destructor declaration:
</p>

<blockquote>
<pre>basic_streambuf(const basic_streambuf&amp; sb);
basic_streambuf&amp; operator=(const basic_streambuf&amp; sb);
</pre>
</blockquote>

<p>Insert after 27.5.2.1, paragraph 2:</p>
<blockquote>
<pre>basic_streambuf(const basic_streambuf&amp; sb);
</pre>

<p>Constructs a copy of sb.</p>
<p>Postcondtions:</p>
<pre>                eback() == sb.eback()
                gptr()  == sb.gptr()
                egptr() == sb.egptr()
                pbase() == sb.pbase()
                pptr()  == sb.pptr()
                epptr() == sb.epptr()
                getloc() == sb.getloc()
</pre>

<pre>basic_streambuf&amp; operator=(const basic_streambuf&amp; sb);
</pre>

<p>Assigns the data members of sb to this.</p>

<p>Postcondtions:</p>
<pre>                eback() == sb.eback()
                gptr()  == sb.gptr()
                egptr() == sb.egptr()
                pbase() == sb.pbase()
                pptr()  == sb.pptr()
                epptr() == sb.epptr()
                getloc() == sb.getloc()
</pre>

<p>Returns: *this.</p>
</blockquote>

<p>27.7.1 [lib.stringbuf]:</p>

<p><b>Option A:</b></p>

<blockquote>
<p>Insert into the basic_stringbuf synopsis in the private section:</p>

<pre>basic_stringbuf(const basic_stringbuf&amp;);             // not defined
basic_stringbuf&amp; operator=(const basic_stringbuf&amp;);  // not defined
</pre>
</blockquote>

<p><b>Option B:</b></p>

<blockquote>
<p>Insert into the basic_stringbuf synopsis in the public section:</p>

<pre>basic_stringbuf(const basic_stringbuf&amp; sb);
basic_stringbuf&amp; operator=(const basic_stringbuf&amp; sb);
</pre>

<p>27.7.1.1, insert after paragraph 4:</p>

<pre>basic_stringbuf(const basic_stringbuf&amp; sb);</pre>

<p>
Constructs an independent copy of sb as if with sb.str(), and with the openmode that sb was constructed with.
</p>

<p>Postcondtions: </p>
<pre>               str() == sb.str()
               gptr()  - eback() == sb.gptr()  - sb.eback()
               egptr() - eback() == sb.egptr() - sb.eback()
               pptr()  - pbase() == sb.pptr()  - sb.pbase()
               getloc() == sb.getloc()
</pre>

<p>
Note: The only requirement on epptr() is that it point beyond the
initialized range if an output sequence exists. There is no requirement
that epptr() - pbase() == sb.epptr() - sb.pbase().
</p>

<pre>basic_stringbuf&amp; operator=(const basic_stringbuf&amp; sb);</pre>
<p>After assignment the basic_stringbuf has the same state as if it
were initially copy constructed from sb, except that the
basic_stringbuf is allowed to retain any excess capacity it might have,
which may in turn effect the value of epptr().
</p>
</blockquote>

<p>27.8.1.1 [lib.filebuf]</p>

<p>Insert at the bottom of the basic_filebuf synopsis:</p>

<blockquote>
<pre>private:
  basic_filebuf(const basic_filebuf&amp;);             // not defined
  basic_filebuf&amp; operator=(const basic_filebuf&amp;);  // not defined
</pre>
</blockquote>
<p><i>[Kona: this is an issue for basic_streambuf itself and for its
  derived classes.  We are leaning toward allowing basic_streambuf to
  be copyable, and specifying its precise semantics.  (Probably the
  obvious: copying the buffer pointers.)  We are less sure whether
  the streambuf derived classes should be copyable.  Howard will
  write up a proposal.]</i></p>


<p><i>[Sydney: Dietmar presented a new argument against basic_streambuf
  being copyable: it can lead to an encapsulation violation. Filebuf
  inherits from streambuf. Now suppose you inhert a my_hijacking_buf
  from streambuf. You can copy the streambuf portion of a filebuf to a
  my_hijacking_buf, giving you access to the pointers into the
  filebuf's internal buffer. Perhaps not a very strong argument, but
  it was strong enough to make people nervous. There was weak
  preference for having streambuf not be copyable. There was weak
  preference for having stringbuf not be copyable even if streambuf
  is. Move this issue to open for now.
]</i></p>


<p><i>[
2007-01-12, Howard:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1862.html#27.5.2%20-%20Class%20template%20basic_streambuf%3CcharT,traits%3E">Rvalue Reference Recommendations for Chapter 27</a>
recommends protected copy constructor and assignment for <tt>basic_streambuf</tt> with the same semantics
as would be generated by the compiler.  These members aid in derived classes implementing move semantics.
A protected copy constructor and copy assignment operator do not expose encapsulation more so than it is
today as each data member of a <tt>basic_streambuf</tt> is already both readable and writable by derived
classes via various get/set protected member functions (<tt>eback()</tt>, <tt>setp()</tt>, etc.).  Rather
a protected copy constructor and copy assignment operator simply make the job of derived classes implementing
move semantics less tedious and error prone.
]</i></p>




<p><b>Rationale:</b></p>
<p>
27.5.2 [lib.streambuf]: The proposed basic_streambuf copy constructor
and assignment operator are the same as currently implied by the lack
of declarations: public and simply copies the data members.  This
resolution is not a change but a clarification of the current
standard.
</p>

<p>
27.7.1 [lib.stringbuf]: There are two reasonable options: A) Make
basic_stringbuf not copyable.  This is likely the status-quo of
current implementations.  B) Reasonable copy semantics of
basic_stringbuf can be defined and implemented.  A copyable
basic_streambuf is arguably more useful than a non-copyable one.  This
should be considered as new functionality and not the fixing of a
defect.  If option B is chosen, ramifications from issue 432 are taken
into account.
</p>

<p>
27.8.1.1 [lib.filebuf]: There are no reasonable copy semantics for
basic_filebuf.
</p>






<hr>
<h3><a name="423"></a>423. effects of negative streamsize in iostreams</h3>
<p><b>Section:</b> 27 [input.output] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2003-09-18  <b>Last modified:</b> 2006-12-27</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#input.output">active issues</a> in [input.output].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#input.output">issues</a> in [input.output].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
A third party test suite tries to exercise istream::ignore(N) with
a negative value of N and expects that the implementation will treat
N as if it were 0. Our implementation asserts that (N &gt;= 0) holds and
aborts the test.
</p>

<p>
I can't find anything in section 27 that prohibits such values but I don't
see what the effects of such calls should be, either (this applies to
a number of unformatted input functions as well as some member functions
of the basic_streambuf template).
</p>


<p><b>Proposed resolution:</b></p>
<p>
I propose that we add to each function in clause 27 that takes an argument,
say N, of type streamsize a Requires clause saying that "N &gt;= 0." The intent
is to allow negative streamsize values in calls to precision() and width()
but disallow it in calls to streambuf::sgetn(), istream::ignore(), or
ostream::write().
</p>

<p><i>[Kona: The LWG agreed that this is probably what we want.  However, we
  need a review to find all places where functions in clause 27 take
  arguments of type streamsize that shouldn't be allowed to go
  negative.  Martin will do that review.]</i></p>






<hr>
<h3><a name="424"></a>424. normative notes</h3>
<p><b>Section:</b> 17.5.1.2 [structure.summary] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">Tentatively NAD Editorial</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2003-09-18  <b>Last modified:</b> 2009-05-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20NAD%20Editorial">Tentatively NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p>
The text in 17.3.1.1, p1 says:
<br>

"Paragraphs labelled "Note(s):" or "Example(s):" are informative, other
paragraphs are normative."
<br>

The library section makes heavy use of paragraphs labeled "Notes(s),"
some of which are clearly intended to be normative (see list 1), while
some others are not (see list 2). There are also those where the intent
is not so clear (see list 3).
<br><br>

List 1 -- Examples of (presumably) normative Notes:
<br>

20.8.6.1 [allocator.members], p3,<br>
20.8.6.1 [allocator.members], p10,<br>
21.4.2 [string.cons], p11,<br>
22.3.1.2 [locale.cons], p11,<br>
23.3.2.3 [deque.modifiers], p2,<br>
25.5.7 [alg.min.max], p3,<br>
26.4.6 [complex.ops], p15,<br>
27.6.2.4.3 [streambuf.virt.get], p7.<br>
<br>

List 2 -- Examples of (presumably) informative Notes:
<br>

18.6.1.3 [new.delete.placement], p3,<br>
21.4.6.6 [string::replace], p14,<br>
22.4.1.4.2 [locale.codecvt.virtuals], p3,<br>
25.3.4 [alg.foreach], p4,<br>
26.4.5 [complex.member.ops], p1,<br>
27.5.2.5 [ios.base.storage], p6.<br>
<br>

List 3 -- Examples of Notes that are not clearly either normative
or informative:
<br>

22.3.1.2 [locale.cons], p8,<br>
22.3.1.5 [locale.statics], p6,<br>
27.6.2.4.5 [streambuf.virt.put], p4.<br>
<br>

None of these lists is meant to be exhaustive.
</p>

<p><i>[Definitely a real problem.  The big problem is there's material
  that doesn't quite fit any of the named paragraph categories
  (e.g. <b>Effects</b>).  Either we need a new kind of named
  paragraph, or we need to put more material in unnamed paragraphs
  jsut after the signature.  We need to talk to the Project Editor
  about how to do this.
]</i></p>


<p><i>[
Bellevue: Specifics of list 3: First 2 items correct in std (22.1.1.2,
22.1.1.5) Third item should be non-normative (27.5.2.4.5), which Pete
will handle editorially.
]</i></p>


<p><i>[
post San Francisco:  Howard: reopened, needs attention.
]</i></p>


<p><i>[Pete: I changed the paragraphs marked "Note" and "Notes" to use "Remark" and "Remarks".
Fixed as editorial.  This change has been in the WD since the post-Redmond mailing, in 2004.
Recommend NAD.]</i></p>


<p><i>[
Batavia:  We feel that the references in List 2 above should be changed from <i>Remarks</i>
to <i>Notes</i>.  We also feel that those items in List 3 need to be double checked for
the same change.  Alan and Pete to review.
]</i></p>


<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
A spot-check of List 2 suggests the issue is still relevant,
and a review of List 3 still seems called-for.
</p>
<p>
Move to NAD Editorial.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>




<hr>
<h3><a name="427"></a>427. stage 2 and rationale of DR 221</h3>
<p><b>Section:</b> 22.4.2.1.2 [facet.num.get.virtuals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2003-09-18  <b>Last modified:</b> 2007-01-15</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#facet.num.get.virtuals">active issues</a> in [facet.num.get.virtuals].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#facet.num.get.virtuals">issues</a> in [facet.num.get.virtuals].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The requirements specified in Stage 2 and reiterated in the rationale
of DR 221 (and echoed again in DR 303) specify that num_get&lt;charT&gt;::
do_get() compares characters on the stream against the widened elements
of "012...abc...ABCX+-"
</p>

<p>
An implementation is required to allow programs to instantiate the num_get
template on any charT that satisfies the requirements on a user-defined
character type. These requirements do not include the ability of the
character type to be equality comparable (the char_traits template must
be used to perform tests for equality). Hence, the num_get template cannot
be implemented to support any arbitrary character type. The num_get template
must either make the assumption that the character type is equality-comparable
(as some popular implementations do), or it may use char_traits&lt;charT&gt; to do
the comparisons (some other popular implementations do that). This diversity
of approaches makes it difficult to write portable programs that attempt to
instantiate the num_get template on user-defined types.
</p>

<p><i>[Kona: the heart of the problem is that we're theoretically
  supposed to use traits classes for all fundamental character
  operations like assignment and comparison, but facets don't have
  traits parameters.  This is a fundamental design flaw and it
  appears all over the place, not just in this one place.  It's not
  clear what the correct solution is, but a thorough review of facets
  and traits is in order.  The LWG considered and rejected the
  possibility of changing numeric facets to use narrowing instead of
  widening.  This may be a good idea for other reasons (see issue
  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#459">459</a>), but it doesn't solve the problem raised by this
  issue.  Whether we use widen or narrow the <tt>num_get</tt> facet
  still has no idea which traits class the user wants to use for 
  the comparison, because only streams, not facets, are passed traits
  classes.   The standard does not require that two different
  traits classes with the same <tt>char_type</tt> must necessarily 
  have the same behavior.]</i></p>


<p>Informally, one possibility: require that some of the basic
character operations, such as <tt>eq</tt>, <tt>lt</tt>,
and <tt>assign</tt>, must behave the same way for all traits classes
with the same <tt>char_type</tt>.  If we accept that limitation on
traits classes, then the facet could reasonably be required to
use <tt>char_traits&lt;charT&gt;</tt>.</p>


<p><b>Proposed resolution:</b></p>




<hr>
<h3><a name="430"></a>430. valarray subset operations</h3>
<p><b>Section:</b> 26.6.2.4 [valarray.sub] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2003-09-18  <b>Last modified:</b> 2009-05-01</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The standard fails to specify the behavior of valarray::operator[](slice)
and other valarray subset operations when they are passed an "invalid"
slice object, i.e., either a slice that doesn't make sense at all (e.g.,
slice (0, 1, 0) or one that doesn't specify a valid subset of the valarray
object (e.g., slice (2, 1, 1) for a valarray of size 1).
</p>
<p><i>[Kona: the LWG believes that invalid slices should invoke
  undefined behavior.  Valarrays are supposed to be designed for high
  performance, so we don't want to require specific checking.  We
  need wording to express this decision.]</i></p>


<p><i>[
Bellevue:
]</i></p>


<blockquote>
Please note that the standard also fails to specify the behavior of
slice_array and gslice_array in the valid case. Bill Plauger will
endeavor to provide revised wording for slice_array and gslice_array.
</blockquote>

<p><i>[
post-Bellevue:  Bill provided wording.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
Insert after 26.6.2.4 [valarray.sub], paragraph 1:
</p>

<blockquote>
<p>
The member operator is overloaded to provide several ways to select
sequences
of elements from among those controlled by <tt>*this</tt>. The first group of five
member operators work in conjunction with various overloads of <tt>operator=</tt>
(and other assigning operators) to allow selective replacement (slicing) of
the controlled sequence. The selected elements must exist.
</p>
<p>
The first member operator selects element off. For example:
</p>

<blockquote><pre>valarray&lt;char&gt; v0("abcdefghijklmnop", 16);
v0[3] = 'A';
// v0 == valarray&lt;char&gt;("abcAefghijklmnop", 16)
</pre></blockquote>

<p>
The second member operator selects those elements of the controlled sequence
designated by <tt>slicearr</tt>. For example:
</p>

<blockquote><pre>valarray&lt;char&gt; v0("abcdefghijklmnop", 16);
valarray&lt;char&gt; v1("ABCDE", 5);
v0[slice(2, 5, 3)] = v1;
// v0 == valarray&lt;char&gt;("abAdeBghCjkDmnEp", 16)
</pre></blockquote>

<p>
The third member operator selects those elements of the controlled sequence
designated by <tt>gslicearr</tt>. For example:
</p>

<blockquote><pre>valarray&lt;char&gt; v0("abcdefghijklmnop", 16);
valarray&lt;char&gt; v1("ABCDEF", 6);
const size_t lv[] = {2, 3};
const size_t dv[] = {7, 2};
const valarray&lt;size_t&gt; len(lv, 2), str(dv, 2);
v0[gslice(3, len, str)] = v1;
// v0 == valarray&lt;char&gt;("abcAeBgCijDlEnFp", 16)
</pre></blockquote>

<p>
The fourth member operator selects those elements of the controlled sequence
designated by <tt>boolarr</tt>. For example:
</p>

<blockquote><pre>valarray&lt;char&gt; v0("abcdefghijklmnop", 16);
valarray&lt;char&gt; v1("ABC", 3);
const bool vb[] = {false, false, true, true, false, true};
v0[valarray&lt;bool&gt;(vb, 6)] = v1;
// v0 == valarray&lt;char&gt;("abABeCghijklmnop", 16)
</pre></blockquote>

<p>
The fifth member operator selects those elements of the controlled sequence
designated by indarr. For example:
</p>

<blockquote><pre>valarray&lt;char&gt; v0("abcdefghijklmnop", 16);
valarray&lt;char&gt; v1("ABCDE", 5);
const size_t vi[] = {7, 5, 2, 3, 8};
v0[valarray&lt;size_t&gt;(vi, 5)] = v1;
// v0 == valarray&lt;char&gt;("abCDeBgAEjklmnop", 16)
</pre></blockquote>

<p>
The second group of five member operators each construct an object that
represents the value(s) selected. The selected elements must exist.
</p>

<p>
The sixth member operator returns the value of element off. For example:
</p>

<blockquote><pre>valarray&lt;char&gt; v0("abcdefghijklmnop", 16);
// v0[3] returns 'd'
</pre></blockquote>

<p>
The seventh member operator returns an object of class <tt>valarray&lt;Ty&gt;</tt>
containing those elements of the controlled sequence designated by <tt>slicearr</tt>.
For example:
</p>

<blockquote><pre>valarray&lt;char&gt; v0("abcdefghijklmnop", 16);
// v0[slice(2, 5, 3)] returns valarray&lt;char&gt;("cfilo", 5)
</pre></blockquote>

<p>
The eighth member operator selects those elements of the controlled sequence
designated by <tt>gslicearr</tt>. For example:
</p>

<blockquote><pre>valarray&lt;char&gt; v0("abcdefghijklmnop", 16);
const size_t lv[] = {2, 3};
const size_t dv[] = {7, 2};
const valarray&lt;size_t&gt; len(lv, 2), str(dv, 2);
// v0[gslice(3, len, str)] returns
//    valarray&lt;char&gt;("dfhkmo", 6)
</pre></blockquote>

<p>
The ninth member operator selects those elements of the controlled sequence
designated by <tt>boolarr</tt>. For example:
</p>

<blockquote><pre>valarray&lt;char&gt; v0("abcdefghijklmnop", 16);
const bool vb[] = {false, false, true, true, false, true};
// v0[valarray&lt;bool&gt;(vb, 6)] returns
//    valarray&lt;char&gt;("cdf", 3)
</pre></blockquote>

<p>
The last member operator selects those elements of the controlled sequence
designated by <tt>indarr</tt>. For example:
</p>

<blockquote><pre>valarray&lt;char&gt; v0("abcdefghijklmnop", 16);
const size_t vi[] = {7, 5, 2, 3, 8};
// v0[valarray&lt;size_t&gt;(vi, 5)] returns
//    valarray&lt;char&gt;("hfcdi", 5)
</pre></blockquote>

</blockquote>





<hr>
<h3><a name="431"></a>431. Swapping containers with unequal allocators</h3>
<p><b>Section:</b> X [allocator.requirements], 25 [algorithms] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2003-09-20  <b>Last modified:</b> 2009-05-01</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#allocator.requirements">active issues</a> in [allocator.requirements].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#allocator.requirements">issues</a> in [allocator.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>Clause X [allocator.requirements] paragraph 4 says that implementations
  are permitted to supply containers that are unable to cope with
  allocator instances and that container implementations may assume
  that all instances of an allocator type compare equal.  We gave
  implementers this latitude as a temporary hack, and eventually we
  want to get rid of it.  What happens when we're dealing with
  allocators that <i>don't</i> compare equal?
</p>

<p>In particular: suppose that <tt>v1</tt> and <tt>v2</tt> are both
  objects of type <tt>vector&lt;int, my_alloc&gt;</tt> and that
  <tt>v1.get_allocator() != v2.get_allocator()</tt>.  What happens if
  we write <tt>v1.swap(v2)</tt>?  Informally, three possibilities:</p>

<p>1. This operation is illegal.  Perhaps we could say that an
  implementation is required to check and to throw an exception, or
  perhaps we could say it's undefined behavior.</p>
<p>2. The operation performs a slow swap (i.e. using three
  invocations of <tt>operator=</tt>, leaving each allocator with its
  original container.  This would be an O(N) operation.</p>
<p>3. The operation swaps both the vectors' contents and their
  allocators.  This would be an O(1) operation. That is:</p>
  <blockquote>
  <pre>    my_alloc a1(...);
    my_alloc a2(...);
    assert(a1 != a2);

    vector&lt;int, my_alloc&gt; v1(a1);
    vector&lt;int, my_alloc&gt; v2(a2);
    assert(a1 == v1.get_allocator());
    assert(a2 == v2.get_allocator());

    v1.swap(v2);
    assert(a1 == v2.get_allocator());
    assert(a2 == v1.get_allocator());
  </pre>
  </blockquote>

<p><i>[Kona: This is part of a general problem.  We need a paper
  saying how to deal with unequal allocators in general.]</i></p>


<p><i>[pre-Sydney: Howard argues for option 3 in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1599.html">N1599</a>.
]</i></p>


<p><i>[
2007-01-12, Howard:  This issue will now tend to come up more often with move constructors
and move assignment operators.  For containers, these members transfer resources (i.e.
the allocated memory) just like swap.
]</i></p>


<p><i>[
Batavia:  There is agreement to overload the container <tt>swap</tt> on the allocator's Swappable
requirement using concepts.  If the allocator supports Swappable, then container's swap will
swap allocators, else it will perform a "slow swap" using copy construction and copy assignment.
]</i></p>


<p><i>[
2009-04-28 Pablo adds:
]</i></p>

<blockquote>
Fixed in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2525.pdf">N2525</a>.
I argued for marking this Tentatively-Ready right after Bellevue,
but there was a concern that
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2525.pdf">N2525</a>
would break in the presence of the RVO. (That breakage had nothing to do with
swap, but never-the-less). I addressed that breakage in in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2840.pdf">N2840</a>
(Summit) my means of a non-normative reference:

<blockquote>
[<i>Note:</i> in situations where the copy constructor for a container is elided,
this function is not called. The behavior in these cases is as if
<tt>select_on_container_copy_construction</tt> returned <tt>x</tt> &#8212; <i>end note</i>]
</blockquote>

</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="446"></a>446. Iterator equality between different containers</h3>
<p><b>Section:</b> 24.2 [iterator.concepts], 23.2 [container.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Andy Koenig <b>Opened:</b> 2003-12-16  <b>Last modified:</b> 2008-09-30</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#iterator.concepts">active issues</a> in [iterator.concepts].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#iterator.concepts">issues</a> in [iterator.concepts].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
What requirements does the standard place on equality comparisons between
iterators that refer to elements of different containers.  For example, if
v1 and v2 are empty vectors, is v1.end() == v2.end() allowed to yield true?
Is it allowed to throw an exception?
</p>

<p>
The standard appears to be silent on both questions.
</p>
<p><i>[Sydney: The intention is that comparing two iterators from
different containers is undefined, but it's not clear if we say that,
or even whether it's something we should be saying in clause 23 or in
clause 24.  Intuitively we might want to say that equality is defined
only if one iterator is reachable from another, but figuring out how
to say it in any sensible way is a bit tricky: reachability is defined
in terms of equality, so we can't also define equality in terms of
reachability.
]</i></p>




<p><b>Proposed resolution:</b></p>






<hr>
<h3><a name="458"></a>458. 24.1.5 contains unintented limitation for operator-</h3>
<p><b>Section:</b> 24.2.6 [random.access.iterators] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Daniel Frey <b>Opened:</b> 2004-02-27  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#random.access.iterators">active issues</a> in [random.access.iterators].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#random.access.iterators">issues</a> in [random.access.iterators].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 24.1.5 [lib.random.access.iterators], table 76 the operational
semantics for the expression "r -= n" are defined as "return r += -n".
This means, that the expression -n must be valid, which is not the case
for unsigned types.
</p>

<p><i>[
Sydney: Possibly not a real problem, since difference type is required
to be a signed integer type. However, the wording in the standard may
be less clear than we would like.
]</i></p>


<p><i>[
Post Summit Alisdair adds:
]</i></p>


<blockquote>
<p>
This issue refers to a requirements table we have removed.
</p>
<p>
The issue might now relate to 24.2.6 [random.access.iterators] p5.
However, the rationale in the issue already recognises that the
<tt>difference_type</tt> must be signed, so this really looks NAD.
</p>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We agree with Alisdair's observations.
</p>
<p>
Move to NAD.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
To remove this limitation, I suggest to change the
operational semantics for this column to:
</p>
<blockquote><pre>    { Distance m = n;
      if (m &gt;= 0)
        while (m--) --r;
      else
        while (m++) ++r;
      return r; }
</pre></blockquote>






<hr>
<h3><a name="459"></a>459. Requirement for widening in stage 2 is overspecification</h3>
<p><b>Section:</b> 22.4.2.1.2 [facet.num.get.virtuals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2004-03-16  <b>Last modified:</b> 2006-12-27</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#facet.num.get.virtuals">active issues</a> in [facet.num.get.virtuals].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#facet.num.get.virtuals">issues</a> in [facet.num.get.virtuals].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>When parsing strings of wide-character digits, the standard
  requires the library to widen narrow-character "atoms" and compare
  the widened atoms against the characters that are being parsed.
  Simply narrowing the wide characters would be far simpler, and
  probably more efficient.  The two choices are equivalent except in
  convoluted test cases, and many implementations already ignore the
  standard and use narrow instead of widen.</p>

<p>
First, I disagree that using narrow() instead of widen() would
necessarily have unfortunate performance implications. A possible
implementation of narrow() that allows num_get to be implemented
in a much simpler and arguably comparably efficient way as calling
widen() allows, i.e. without making a virtual call to do_narrow every
time, is as follows:
</p>

<pre>  inline char ctype&lt;wchar_t&gt;::narrow (wchar_t wc, char dflt) const
  {
      const unsigned wi = unsigned (wc);

      if (wi &gt; UCHAR_MAX)
          return typeid (*this) == typeid (ctype&lt;wchar_t&gt;) ?
                 dflt : do_narrow (wc, dflt);

      if (narrow_ [wi] &lt; 0) {
         const char nc = do_narrow (wc, dflt);
         if (nc == dflt)
             return dflt;
         narrow_ [wi] = nc;
      }

      return char (narrow_ [wi]);
  }
</pre>

<p>
Second, I don't think the change proposed in the issue (i.e., to use
narrow() instead of widen() during Stage 2) would be at all
drastic. Existing implementations with the exception of libstdc++
currently already use narrow() so the impact of the change on programs
would presumably be isolated to just a single implementation. Further,
since narrow() is not required to translate alternate wide digit
representations such as those mentioned in issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#303">303</a>
to
their narrow equivalents (i.e., the portable source characters '0'
through '9'), the change does not necessarily imply that these
alternate digits would be treated as ordinary digits and accepted as
part of numbers during parsing. In fact, the requirement in 22.4.1.1.2
[locale.ctype.virtuals], p13 forbids narrow() to translate an alternate
digit character, wc, to an ordinary digit in the basic source
character set unless the expression
(ctype&lt;charT&gt;::is(ctype_base::digit, wc) == true) holds. This in
turn is prohibited by the C standard (7.25.2.1.5, 7.25.2.1.5, and
5.2.1, respectively) for charT of either char or wchar_t.
</p>

<p><i>[Sydney: To a large extent this is a nonproblem. As long as
you're only trafficking in char and wchar_t we're only dealing with a
stable character set, so you don't really need either 'widen' or
'narrow': can just use literals. Finally, it's not even clear whether
widen-vs-narrow is the right question; arguably we should be using
codecvt instead.]</i></p>




<p><b>Proposed resolution:</b></p>
<p>Change stage 2 so that implementations are permitted to use either
technique to perform the comparison:</p>
<ol>
  <li> call widen on the atoms and compare (either by using
      operator== or char_traits&lt;charT&gt;::eq) the input with
      the widened atoms, or</li>
  <li> call narrow on the input and compare the narrow input
      with the atoms</li>
  <li> do (1) or (2) only if charT is not char or wchar_t,
      respectively; i.e., avoid calling widen or narrow
      if it the source and destination types are the same</li>
</ol>





<hr>
<h3><a name="463"></a>463. auto_ptr usability issues</h3>
<p><b>Section:</b> D.9.1 [auto.ptr] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Rani Sharoni <b>Opened:</b> 2003-12-07  <b>Last modified:</b> 2007-11-15</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#auto.ptr">active issues</a> in [auto.ptr].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#auto.ptr">issues</a> in [auto.ptr].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
TC1 CWG DR #84 effectively made the template&lt;class Y&gt; operator auto_ptr&lt;Y&gt;()
member of auto_ptr (20.4.5.3/4) obsolete.
</p>

<p>
The sole purpose of this obsolete conversion member is to enable copy
initialization base from r-value derived (or any convertible types like
cv-types) case:
</p>
<pre>#include &lt;memory&gt;
using std::auto_ptr;

struct B {};
struct D : B {};

auto_ptr&lt;D&gt; source();
int sink(auto_ptr&lt;B&gt;);
int x1 = sink( source() ); // #1 EDG - no suitable copy constructor
</pre>

<p>
The excellent analysis of conversion operations that was given in the final
auto_ptr proposal
(http://anubis.dkuug.dk/jtc1/sc22/wg21/docs/papers/1997/N1128.pdf)
explicitly specifies this case analysis (case 4). DR #84 makes the analysis
wrong and actually comes to forbid the loophole that was exploited by the
auto_ptr designers.
</p>

<p>
I didn't encounter any compliant compiler (e.g. EDG, GCC, BCC and VC) that
ever allowed this case. This is probably because it requires 3 user defined
conversions and in fact current compilers conform to DR #84.
</p>

<p>
I was surprised to discover that the obsolete conversion member actually has
negative impact of the copy initialization base from l-value derived
case:</p>
<pre>auto_ptr&lt;D&gt; dp;
int x2 = sink(dp); // #2 EDG - more than one user-defined conversion applies
</pre>

<p>
I'm sure that the original intention was allowing this initialization using
the template&lt;class Y&gt; auto_ptr(auto_ptr&lt;Y&gt;&amp; a) constructor (20.4.5.1/4) but
since in this copy initialization it's merely user defined conversion (UDC)
and the obsolete conversion member is UDC with the same rank (for the early
overloading stage) there is an ambiguity between them.
</p>

<p>
Removing the obsolete member will have impact on code that explicitly
invokes it:
</p>
<pre>int y = sink(source().operator auto_ptr&lt;B&gt;());
</pre>

<p>
IMHO no one ever wrote such awkward code and the reasonable workaround for
#1 is:
</p>
<pre>int y = sink( auto_ptr&lt;B&gt;(source()) );
</pre>

<p>
I was even more surprised to find out that after removing the obsolete
conversion member the initialization was still ill-formed:
int x3 = sink(dp); // #3 EDG - no suitable copy constructor
</p>

<p>
This copy initialization semantically requires copy constructor which means
that both template conversion constructor and the auto_ptr_ref conversion
member (20.4.5.3/3) are required which is what was explicitly forbidden in
DR #84. This is a bit amusing case in which removing ambiguity results with
no candidates.
</p>

<p>
I also found exception safety issue with auto_ptr related to auto_ptr_ref:
</p>
<pre>int f(auto_ptr&lt;B&gt;, std::string);
auto_ptr&lt;B&gt; source2();

// string constructor throws while auto_ptr_ref
// "holds" the pointer
int x4 = f(source2(), "xyz"); // #4
</pre>

<p>
The theoretic execution sequence that will cause a leak:
</p>
<ol>
<li>call auto_ptr&lt;B&gt;::operator auto_ptr_ref&lt;B&gt;()</li>
<li>call string::string(char const*) and throw</li>
</ol>

<p>
According to 20.4.5.3/3 and 20.4.5/2 the auto_ptr_ref conversion member
returns auto_ptr_ref&lt;Y&gt; that holds *this and this is another defect since
the type of *this is auto_ptr&lt;X&gt; where X might be different from Y. Several
library vendors (e.g. SGI) implement auto_ptr_ref&lt;Y&gt; with Y* as member which
is much more reasonable. Other vendor implemented auto_ptr_ref as
defectively required and it results with awkward and catastrophic code:
int oops = sink(auto_ptr&lt;B&gt;(source())); // warning recursive on all control
paths
</p>

<p>
Dave Abrahams noticed that there is no specification saying that
auto_ptr_ref copy constructor can't throw.
</p>

<p>
My proposal comes to solve all the above issues and significantly simplify
auto_ptr implementation. One of the fundamental requirements from auto_ptr
is that it can be constructed in an intuitive manner (i.e. like ordinary
pointers) but with strict ownership semantics which yield that source
auto_ptr in initialization must be non-const. My idea is to add additional
constructor template with sole propose to generate ill-formed, diagnostic
required, instance for const auto_ptr arguments during instantiation of
declaration. This special constructor will not be instantiated for other
types which is achievable using 14.8.2/2 (SFINAE). Having this constructor
in hand makes the constructor template&lt;class Y&gt; auto_ptr(auto_ptr&lt;Y&gt; const&amp;)
legitimate since the actual argument can't be const yet non const r-value
are acceptable.
</p>

<p>
This implementation technique makes the "private auxiliary class"
auto_ptr_ref obsolete and I found out that modern C++ compilers (e.g. EDG,
GCC and VC) consume the new implementation as expected and allow all
intuitive initialization and assignment cases while rejecting illegal cases
that involve const auto_ptr arguments.
</p>

<p>The proposed auto_ptr interface:</p>

<pre>namespace std {
    template&lt;class X&gt; class auto_ptr {
    public:
        typedef X element_type;

        // 20.4.5.1 construct/copy/destroy:
        explicit auto_ptr(X* p=0) throw();
        auto_ptr(auto_ptr&amp;) throw();
        template&lt;class Y&gt; auto_ptr(auto_ptr&lt;Y&gt; const&amp;) throw();
        auto_ptr&amp; operator=(auto_ptr&amp;) throw();
        template&lt;class Y&gt; auto_ptr&amp; operator=(auto_ptr&lt;Y&gt;) throw();
        ~auto_ptr() throw();

        // 20.4.5.2 members:
        X&amp; operator*() const throw();
        X* operator-&gt;() const throw();
        X* get() const throw();
        X* release() throw();
        void reset(X* p=0) throw();

    private:
        template&lt;class U&gt;
        auto_ptr(U&amp; rhs, typename
unspecified_error_on_const_auto_ptr&lt;U&gt;::type = 0);
    };
}
</pre>

<p>
One compliant technique to implement the unspecified_error_on_const_auto_ptr
helper class is using additional private auto_ptr member class template like
the following:
</p>
<pre>template&lt;typename T&gt; struct unspecified_error_on_const_auto_ptr;

template&lt;typename T&gt;
struct unspecified_error_on_const_auto_ptr&lt;auto_ptr&lt;T&gt; const&gt;
{ typedef typename auto_ptr&lt;T&gt;::const_auto_ptr_is_not_allowed type; };
</pre>

<p>
There are other techniques to implement this helper class that might work
better for different compliers (i.e. better diagnostics) and therefore I
suggest defining its semantic behavior without mandating any specific
implementation. IMO, and I didn't found any compiler that thinks otherwise,
14.7.1/5 doesn't theoretically defeat the suggested technique but I suggest
verifying this with core language experts.
</p>

<p><b>Further changes in standard text:</b></p>
<p>Remove section 20.4.5.3</p>

<p>Change 20.4.5/2 to read something like:
Initializing auto_ptr&lt;X&gt; from const auto_ptr&lt;Y&gt; will result with unspecified
ill-formed declaration that will require unspecified diagnostic.</p>

<p>Change 20.4.5.1/4,5,6 to read:</p>

<pre>template&lt;class Y&gt; auto_ptr(auto_ptr&lt;Y&gt; const&amp; a) throw();</pre>
<p> 4 Requires: Y* can be implicitly converted to X*.</p>
<p> 5 Effects: Calls const_cast&lt;auto_ptr&lt;Y&gt;&amp;&gt;(a).release().</p>
<p> 6 Postconditions: *this holds the pointer returned from a.release().</p>

<p>Change 20.4.5.1/10</p>
<pre>template&lt;class Y&gt; auto_ptr&amp; operator=(auto_ptr&lt;Y&gt; a) throw();
</pre>
<p>
10 Requires: Y* can be implicitly converted to X*. The expression delete
get() is well formed.
</p>

<p>LWG TC DR #127 is obsolete.</p>

<p>
Notice that the copy constructor and copy assignment operator should remain
as before and accept non-const auto_ptr&amp; since they have effect on the form
of the implicitly declared copy constructor and copy assignment operator of
class that contains auto_ptr as member per 12.8/5,10:
</p>
<pre>struct X {
    // implicit X(X&amp;)
    // implicit X&amp; operator=(X&amp;)
    auto_ptr&lt;D&gt; aptr_;
};
</pre>

<p>
In most cases this indicates about sloppy programming but preserves the
current auto_ptr behavior.
</p>

<p>
Dave Abrahams encouraged me to suggest fallback implementation in case that
my suggestion that involves removing of auto_ptr_ref will not be accepted.
In this case removing the obsolete conversion member to auto_ptr&lt;Y&gt; and
20.4.5.3/4,5 is still required in order to eliminate ambiguity in legal
cases. The two constructors that I suggested will co exist with the current
members but will make auto_ptr_ref obsolete in initialization contexts.
auto_ptr_ref will be effective in assignment contexts as suggested in DR
#127 and I can't see any serious exception safety issues in those cases
(although it's possible to synthesize such). auto_ptr_ref&lt;X&gt; semantics will
have to be revised to say that it strictly holds pointer of type X and not
reference to an auto_ptr for the favor of cases in which auto_ptr_ref&lt;Y&gt; is
constructed from auto_ptr&lt;X&gt; in which X is different from Y (i.e. assignment
from r-value derived to base).
</p>

<p><i>[Redmond: punt for the moment. We haven't decided yet whether we
  want to fix auto_ptr for C++-0x, or remove it and replace it with
  move_ptr and unique_ptr.]</i></p>


<p><i>[
Oxford 2007: Recommend NAD.  We're just going to deprecate it.  It still works for simple use cases
and people know how to deal with it.  Going forward <tt>unique_ptr</tt> is the recommended
tool.
]</i></p>


<p><i>[
2007-11-09: Reopened at the request of David Abrahams, Alisdair Meredith and Gabriel Dos Reis.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
Change the synopsis in D.9.1 [auto.ptr]:
</p>

<blockquote><pre>namespace std { 
  <del>template &lt;class Y&gt; struct auto_ptr_ref {};</del>

  <ins>// exposition only</ins>
  <ins>template &lt;class T&gt; struct constant_object;</ins>

  <ins>// exposition only</ins>
  <ins>template &lt;class T&gt;</ins>
  <ins>struct cannot_transfer_ownership_from</ins>
    <ins>: constant_object&lt;T&gt; {};</ins>

  template &lt;class X&gt; class auto_ptr { 
  public: 
    typedef X element_type; 

    // D.9.1.1 construct/copy/destroy: 
    explicit auto_ptr(X* p =0) throw(); 
    auto_ptr(auto_ptr&amp;) throw(); 
    template&lt;class Y&gt; auto_ptr(auto_ptr&lt;Y&gt;<ins> const</ins>&amp;) throw(); 
    auto_ptr&amp; operator=(auto_ptr&amp;) throw(); 
    template&lt;class Y&gt; auto_ptr&amp; operator=(auto_ptr&lt;Y&gt;<del>&amp;</del>) throw();
    <del>auto_ptr&amp; operator=(auto_ptr_ref&lt;X&gt; r) throw();</del>
    ~auto_ptr() throw(); 

    // D.9.1.2 members: 
    X&amp; operator*() const throw();
    X* operator-&gt;() const throw();
    X* get() const throw();
    X* release() throw();
    void reset(X* p =0) throw();

    <del>// D.9.1.3 conversions:</del>
    <del>auto_ptr(auto_ptr_ref&lt;X&gt;) throw();</del>
    <del>template&lt;class Y&gt; operator auto_ptr_ref&lt;Y&gt;() throw();</del>
    <del>template&lt;class Y&gt; operator auto_ptr&lt;Y&gt;() throw();</del>

    <ins>// exposition only</ins>
    <ins>template&lt;class U&gt;</ins>
    <ins>auto_ptr(U&amp; rhs, typename cannot_transfer_ownership_from&lt;U&gt;::error = 0);</ins>
  }; 

  template &lt;&gt; class auto_ptr&lt;void&gt; 
  { 
  public: 
    typedef void element_type; 
  }; 

}
</pre></blockquote>

<p>
Remove D.9.1.3 [auto.ptr.conv].
</p>

<p>
Change D.9.1 [auto.ptr], p3:
</p>

<blockquote>
The <tt>auto_ptr</tt> provides a semantics of strict ownership. An
<tt>auto_ptr</tt> owns the object it holds a pointer to. Copying an
<tt>auto_ptr</tt> copies the pointer and transfers ownership to the
destination. If more than one <tt>auto_ptr</tt> owns the same object at
the same time the behavior of the program is undefined. <ins>Templates
<tt>constant_object</tt> and <tt>cannot_transfer_ownership_from</tt>,
and the final constructor of <tt>auto_ptr</tt> are for exposition only.
For any types <tt>X</tt> and <tt>Y</tt>, initializing
<tt>auto_ptr&lt;X&gt;</tt> from <tt>const auto_ptr&lt;Y&gt;</tt> is
ill-formed, diagnostic required.</ins> [<i>Note:</i> The uses of
<tt>auto_ptr</tt> include providing temporary exception-safety for
dynamically allocated memory, passing ownership of dynamically allocated
memory to a function, and returning dynamically allocated memory from a
function. <tt>auto_ptr</tt> does not meet the <tt>CopyConstructible</tt>
and <tt>Assignable</tt> requirements for Standard Library container
elements and thus instantiating a Standard Library container with an
<tt>auto_ptr</tt> results in undefined behavior. <i>-- end note</i>]
</blockquote>

<p>
Change D.9.1.1 [auto.ptr.cons], p5:
</p>

<blockquote>
<pre>template&lt;class Y&gt; auto_ptr(auto_ptr&lt;Y&gt;<ins> const</ins>&amp; a) throw();
</pre>
<blockquote>
<p>
<i>Requires:</i> <tt>Y*</tt> can be implicitly converted to <tt>X*</tt>.
</p>
<p>
<i>Effects:</i> Calls <ins><tt>const_cast&lt;auto_ptr&lt;Y&gt;&amp;&gt;(</tt></ins><tt>a</tt><ins><tt>)</tt></ins><tt>.release()</tt>.
</p>
<p>
<i>Postconditions:</i> <tt>*this</tt> holds the pointer returned from <tt>a.release()</tt>.
</p>
</blockquote>
</blockquote>

<p>
Change D.9.1.1 [auto.ptr.cons], p10:
</p>

<blockquote>
<pre>template&lt;class Y&gt; auto_ptr&amp; operator=(auto_ptr&lt;Y&gt;<del>&amp;</del> a) throw();
</pre>
<blockquote>
<p>
<i>Requires:</i> <tt>Y*</tt> can be implicitly converted to <tt>X*</tt>.
The expression <tt>delete get()</tt> is well formed.
</p>
<p>
<i>Effects:</i> Calls <tt>reset(a.release())</tt>.
</p>
<p>
<i>Returns:</i> <tt>*this</tt>.
</p>
</blockquote>
</blockquote>






<hr>
<h3><a name="466"></a>466. basic_string ctor should prevent null pointer error</h3>
<p><b>Section:</b> 21.4.1 [string.require] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Daniel Frey <b>Opened:</b> 2004-06-10  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#string.require">active issues</a> in [string.require].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#string.require">issues</a> in [string.require].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Today, my colleagues and me wasted a lot of time. After some time, I
found the problem. It could be reduced to the following short example:
</p>

<pre>  #include &lt;string&gt;
  int main() { std::string( 0 ); }
</pre>

<p>The problem is that the tested compilers (GCC 2.95.2, GCC 3.3.1 and
Comeau online) compile the above without errors or warnings! The
programs (at least for the GCC) resulted in a SEGV.</p>

<p>I know that the standard explicitly states that the ctor of string
requires a char* which is not zero. STLs could easily detect the above
case with a private ctor for basic_string which takes a single 'int'
argument. This would catch the above code at compile time and would not
ambiguate any other legal ctors.</p>

<p><i>[Redmond: No great enthusiasm for doing this.  If we do,
  however, we want to do it for all places that take <tt>charT*</tt>
  pointers, not just the single-argument constructor.  The other
  question is whether we want to catch this at compile time (in which
  case we catch the error of a literal 0, but not an expression whose
  value is a null pointer), at run time, or both.
  Recommend NAD.  Relegate this functionality to debugging implementations.]</i></p>


<p><i>[
Post Summit: Alisdair requests this be re-opened as several new language facilities are
designed to solve exactly this kind of problem.
]</i></p>


<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We are unable to achieve consensus on an approach to a resolution.
There is some sentiment for treating this as a QOI matter.
It is also possible
that when <tt>string</tt> is brought into the concepts world,
this issue might be addressed in that context.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Add to the synopsis in 21.4 [basic.string]
</p>

<blockquote><pre><ins>basic_string( nullptr_t ) = delete;</ins>
</pre></blockquote>





<hr>
<h3><a name="471"></a>471. result of what() implementation-defined</h3>
<p><b>Section:</b> 18.7.1 [type.info] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2004-06-28  <b>Last modified:</b> 2009-05-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#type.info">issues</a> in [type.info].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>[lib.exception] specifies the following:</p>
<pre>    exception (const exception&amp;) throw();
    exception&amp; operator= (const exception&amp;) throw();

    -4- Effects: Copies an exception object.
    -5- Notes: The effects of calling what() after assignment
        are implementation-defined.
</pre>

<p>
First, does the Note only apply to the assignment operator? If so,
what are the effects of calling what() on a copy of an object? Is
the returned pointer supposed to point to an identical copy of
the NTBS returned by what() called on the original object or not?
</p>

<p>
Second, is this Note intended to extend to all the derived classes
in section 19? I.e., does the standard provide any guarantee for
the effects of what() called on a copy of any of the derived class
described in section 19?
</p>

<p>
Finally, if the answer to the first question is no, I believe it
constitutes a defect since throwing an exception object typically
implies invoking the copy ctor on the object. If the answer is yes,
then I believe the standard ought to be clarified to spell out
exactly what the effects are on the copy (i.e., after the copy
ctor was called).
</p>

<p><i>[Redmond: Yes, this is fuzzy.  The issue of derived classes is
  fuzzy too.]</i></p>


<p><i>[
Batavia: Howard provided wording.
]</i></p>


<p><i>[
Bellevue:
]</i></p>


<blockquote>
<p>
Eric concerned this is unimplementable, due to nothrow guarantees.
Suggested implementation would involve reference counting.
</p>
<p>
Is the implied reference counting subtle enough to call out a note on
implementation? Probably not.
</p>
<p>
If reference counting required, could we tighten specification further
to require same pointer value? Probably an overspecification, especially
if exception classes defer evalutation of final string to calls to
what().
</p>
<p>
Remember issue moved open and not resolved at Batavia, but cannot
remember who objected to canvas a disenting opinion - please speak up if
you disagree while reading these minutes!
</p>
<p>
Move to Ready as we are accepting words unmodified.
</p>
</blockquote>

<p><i>[
Sophia Antipolis:
]</i></p>


<blockquote>
The issue was pulled from Ready.  It needs to make clear that only homogenous copying
is intended to be supported, not coping from a derived to a base.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Howard supplied the following replacement wording
for paragraph 7 of the proposed resolution:
</p>
<blockquote>
<ins>-7- <i>Postcondition:</i> <tt>what()</tt> shall return the same NTBS
  as would be obtained by using <tt>static_cast</tt>
  to cast the rhs to the same types as the lhs
  and then calling <tt>what()</tt> on that possibly sliced object.</ins>
</blockquote>
<p>
Pete asks what "the same NTBS" means.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>

<p>
Change 18.8.1 [exception] to:
</p>

<blockquote>
<pre>exception(const exception&amp; <ins><i>e</i></ins>) throw();
exception&amp; operator=(const exception&amp; <ins><i>e</i></ins>) throw();</pre>
<blockquote>
<p>
-4- <i>Effects:</i> Copies an exception object.
</p>
<p>
<del> -5- <i>Remarks:</i> The effects of calling what() after assignment are implementation-defined.</del>
</p>
<p>
<ins>-5- <i>Throws:</i> Nothing.  This also applies
to all standard library-defined classes that derive from <tt>exception</tt>.</ins>
</p>
<p>
<ins>-7- <i>Postcondition:</i> <tt>strcmp(what(), <i>e</i>.what()) == 0</tt>.  This also applies
to all standard library-defined classes that derive from <tt>exception</tt>.</ins>
</p>

</blockquote>
</blockquote>




<hr>
<h3><a name="473"></a>473. underspecified ctype calls</h3>
<p><b>Section:</b> 22.4.1.1 [locale.ctype] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2004-07-01  <b>Last modified:</b> 2006-12-27</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Most ctype member functions come in two forms: one that operates
on a single character at a time and another form that operates
on a range of characters. Both forms are typically described by
a single Effects and/or Returns clause.
</p>
<p>
The Returns clause of each of the single-character non-virtual forms
suggests that the function calls the corresponding single character
virtual function, and that the array form calls the corresponding
virtual array form. Neither of the two forms of each virtual member
function is required to be implemented in terms of the other.
</p>
<p>
There are three problems:
</p>
<p>
1. One is that while the standard does suggest that each non-virtual
member function calls the corresponding form of the virtual function,
it doesn't actually explicitly require it.
</p>
<p>
Implementations that cache results from some of the virtual member
functions for some or all values of their arguments might want to
call the array form from the non-array form the first time to fill
the cache and avoid any or most subsequent virtual calls. Programs
that rely on each form of the virtual function being called from
the corresponding non-virtual function will see unexpected behavior
when using such implementations.
</p>
<p>
2. The second problem is that either form of each of the virtual
functions can be overridden by a user-defined function in a derived
class to return a value that is different from the one produced by
the virtual function of the alternate form that has not been
overriden.
</p>
<p>
Thus, it might be possible for, say, ctype::widen(c) to return one
value, while for ctype::widen(&amp;c, &amp;c + 1, &amp;wc) to set
wc to another value. This is almost certainly not intended. Both
forms of every function should be required to return the same result
for the same character, otherwise the same program using an
implementation that calls one form of the functions will behave
differently than when using another implementation that calls the
other form of the function "under the hood."
</p>
<p>
3. The last problem is that the standard text fails to specify whether
one form of any of the virtual functions is permitted to be implemented
in terms of the other form or not, and if so, whether it is required
or permitted to call the overridden virtual function or not.
</p>
<p>
Thus, a program that overrides one of the virtual functions so that
it calls the other form which then calls the base member might end
up in an infinite loop if the called form of the base implementation
of the function in turn calls the other form.
</p>
<p>
Lillehammer: Part of this isn't a real problem. We already talk about
caching. 22.1.1/6 But part is a real problem. ctype virtuals may call
each other, so users don't know which ones to override to avoid avoid
infinite loops.</p>

<p>This is a problem for all facet virtuals, not just ctype virtuals,
so we probably want a blanket statement in clause 22 for all
facets. The LWG is leaning toward a blanket prohibition, that a
facet's virtuals may never call each other. We might want to do that
in clause 27 too, for that matter. A review is necessary.  Bill will
provide wording.</p>


<p><b>Proposed resolution:</b></p>




<hr>
<h3><a name="485"></a>485. output iterator insufficently constrained</h3>
<p><b>Section:</b> 24.2.3 [output.iterators] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Chris Jefferson <b>Opened:</b> 2004-10-13  <b>Last modified:</b> 2006-12-27</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#output.iterators">issues</a> in [output.iterators].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The note on 24.1.2 Output iterators insufficently limits what can be
performed on output iterators. While it requires that each iterator is
progressed through only once and that each iterator is written to only
once, it does not require the following things:</p>

<p>Note: Here it is assumed that x is an output iterator of type X which
has not yet been assigned to.</p>

<p>a) That each value of the output iterator is written to:
The standard allows:
++x; ++x; ++x;
</p>

<p>
b) That assignments to the output iterator are made in order
X a(x); ++a; *a=1; *x=2; is allowed
</p>

<p>
c) Chains of output iterators cannot be constructed:
X a(x); ++a; X b(a); ++b; X c(b); ++c; is allowed, and under the current
wording (I believe) x,a,b,c could be written to in any order.
</p>

<p>I do not believe this was the intension of the standard?</p>
<p><i>[Lillehammer: Real issue.  There are lots of constraints we
  intended but didn't specify.  Should be solved as part of iterator
  redesign.]</i></p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="492"></a>492. Invalid iterator arithmetic expressions</h3>
<p><b>Section:</b> 17.5.1.4 [structure.specifications] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Thomas Mang <b>Opened:</b> 2004-12-12  <b>Last modified:</b> 2009-05-10</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#structure.specifications">active issues</a> in [structure.specifications].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#structure.specifications">issues</a> in [structure.specifications].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>Various clauses other than clause 25 make use of iterator arithmetic not
supported by the iterator category in question.
Algorithms in clause 25 are exceptional because of 25 [lib.algorithms],
paragraph 9, but this paragraph does not provide semantics to the
expression "iterator - n", where n denotes a value of a distance type
between iterators.</p>

<p>1) Examples of current wording:</p>

<p>Current wording outside clause 25:</p>

<p>
23.2.2.4 [lib.list.ops], paragraphs 19-21: "first + 1", "(i - 1)",
"(last - first)"
23.3.1.1 [lib.map.cons], paragraph 4: "last - first"
23.3.2.1 [lib.multimap.cons], paragraph 4: "last - first"
23.3.3.1 [lib.set.cons], paragraph 4: "last - first"
23.3.4.1 [lib.multiset.cons], paragraph 4: "last - first"
24.4.1 [lib.reverse.iterators], paragraph 1: "(i - 1)"
</p>

<p>
[Important note: The list is not complete, just an illustration. The
same issue might well apply to other paragraphs not listed here.]</p>

<p>None of these expressions is valid for the corresponding iterator
category.</p>

<p>Current wording in clause 25:</p>

<p>
25.1.1 [lib.alg.foreach], paragraph 1: "last - 1"
25.1.3 [lib.alg.find.end], paragraph 2: "[first1, last1 -
(last2-first2))"
25.2.8 [lib.alg.unique], paragraph 1: "(i - 1)"
25.2.8 [lib.alg.unique], paragraph 5: "(i - 1)"
</p>

<p>
However, current wording of 25 [lib.algorithms], paragraph 9 covers
neither of these four cases:</p>

<p>Current wording of 25 [lib.algorithms], paragraph 9:</p>

<p>
"In the description of the algorithms operator + and - are used for some
of the iterator categories for which they do not have to be defined. In
these cases the semantics of a+n is the same as that of</p>
<pre>{X tmp = a;
advance(tmp, n);
return tmp;
}
</pre>
<p>and that of b-a is the same as of return distance(a, b)"</p>

<p>
This paragrpah does not take the expression "iterator - n" into account,
where n denotes a value of a distance type between two iterators [Note:
According to current wording, the expression "iterator - n" would be
resolved as equivalent to "return distance(n, iterator)"]. Even if the
expression "iterator - n" were to be reinterpreted as equivalent to
"iterator + -n" [Note: This would imply that "a" and "b" were
interpreted implicitly as values of iterator types, and "n" as value of
a distance type], then 24.3.4/2 interfers because it says: "Requires: n
may be negative only for random access and bidirectional iterators.",
and none of the paragraphs quoted above requires the iterators on which
the algorithms operate to be of random access or bidirectional category.
</p>

<p>2) Description of intended behavior:</p>

<p>
For the rest of this Defect Report, it is assumed that the expression
"iterator1 + n" and "iterator1 - iterator2" has the semantics as
described in current 25 [lib.algorithms], paragraph 9, but applying to
all clauses. The expression "iterator1 - n" is equivalent to an
result-iterator for which the expression "result-iterator + n" yields an
iterator denoting the same position as iterator1 does. The terms
"iterator1", "iterator2" and "result-iterator" shall denote the value of
an iterator type, and the term "n" shall denote a value of a distance
type between two iterators.</p>

<p>
All implementations known to the author of this Defect Report comply
with these assumptions.
No impact on current code is expected.</p>

<p>3) Proposed fixes:</p>


<p>Change 25 [lib.algorithms], paragraph 9 to:</p>

<p>
"In the description of the algorithms operator + and - are used for some
of the iterator categories for which they do not have to be defined. In
this paragraph, a and b denote values of an iterator type, and n denotes
a value of a distance type between two iterators. In these cases the
semantics of a+n is the same as that of</p>
<pre>{X tmp = a;
advance(tmp, n);
return tmp;
}
</pre>
<p>,the semantics of a-n denotes the value of an iterator i for which the
following condition holds:
advance(i, n) == a,
and that of b-a is the same as of
return distance(a, b)".
</p>

<p>Comments to the new wording:</p>

<p>
a) The wording " In this paragraph, a and b denote values of an iterator
type, and n denotes a value of a distance type between two iterators."
was added so the expressions "b-a" and "a-n" are distinguished regarding
the types of the values on which they operate.
b) The wording ",the semantics of a-n denotes the value of an iterator i
for which the following condition holds: advance(i, n) == a" was added
to cover the expression 'iterator - n'. The wording "advance(i, n) == a"
was used to avoid a dependency on the semantics of a+n, as the wording
"i + n == a" would have implied. However, such a dependency might well
be deserved.
c) DR 225 is not considered in the new wording.
</p>

<p>
Proposed fixes regarding invalid iterator arithmetic expressions outside
clause 25:</p>

<p>
Either
a) Move modified 25 [lib.algorithms], paragraph 9 (as proposed above)
before any current invalid iterator arithmetic expression. In that case,
the first sentence of 25 [lib.algorithms], paragraph 9, need also to be
modified and could read: "For the rest of this International Standard,
...." / "In the description of the following clauses including this
...." / "In the description of the text below ..." etc. - anyways
substituting the wording "algorithms", which is a straight reference to
clause 25.
In that case, 25 [lib.algorithms] paragraph 9 will certainly become
obsolete.
Alternatively,
b) Add an appropiate paragraph similar to resolved 25 [lib.algorithms],
paragraph 9, to the beginning of each clause containing invalid iterator
arithmetic expressions.
Alternatively,
c) Fix each paragraph (both current wording and possible resolutions of
DRs) containing invalid iterator arithmetic expressions separately.
</p>

<p>5) References to other DRs:</p>

<p>
See DR 225.
See DR 237. The resolution could then also read "Linear in last -
first".
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
Keep open and ask Bill to provide wording.
</blockquote>

<p><i>[
2009-05-09 Alisdair adds:
]</i></p>


<blockquote>
This issue is related to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#997">997</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>

<p><i>[Lillehammer: Minor issue, but real. We have a blanket statement
about this in 25/11. But (a) it should be in 17, not 25; and (b) it's
not quite broad enough, because there are some arithmetic expressions
it doesn't cover. Bill will provide wording.]</i></p>







<hr>
<h3><a name="498"></a>498. Requirements for partition() and stable_partition() too strong</h3>
<p><b>Section:</b> 25.4.13 [alg.partitions] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Sean Parent, Joe Gottman <b>Opened:</b> 2005-05-04  <b>Last modified:</b> 2009-05-01</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Problem:
The iterator requirements for partition() and stable_partition() [25.2.12]
are listed as BidirectionalIterator, however, there are efficient algorithms
for these functions that only require ForwardIterator that have been known
since before the standard existed. The SGI implementation includes these (see
<a href="http://www.sgi.com/tech/stl/partition.html">http://www.sgi.com/tech/stl/partition.html</a>
and
<a href="http://www.sgi.com/tech/stl/stable_partition.html">http://www.sgi.com/tech/stl/stable_partition.html</a>).
</p>

<p><i>[
2009-04-30 Alisdair adds:
]</i></p>


<blockquote>
<p>
Now we have concepts this is easier to express!
</p>
<p>
Proposed resolution:
</p>
<p>
Add the following signature to:
</p>
<p>
Header <tt>&lt;algorithm&gt;</tt> synopsis 25.2 [algorithms.syn]<br>
p3 Partitions 25.4.13 [alg.partitions]
</p>
<blockquote><pre> template&lt;ForwardIterator Iter, Predicate&lt;auto, Iter::value_type&gt; Pred&gt;
   requires ShuffleIterator&lt;Iter&gt;
         &amp;&amp; CopyConstructible&lt;Pred&gt;
   Iter partition(Iter first, Iter last, Pred pred);
</pre></blockquote>

<p>
Update p3 Partitions 25.4.13 [alg.partitions]:
</p>

<blockquote>
<p>
<i>Complexity:</i> <del>At most <tt>(last - first)/2</tt> swaps. Exactly <tt>last - first</tt>
applications of the predicate
are done.</del>
<ins>
If <tt>Iter</tt> satisfies <tt>BidirectionalIterator</tt>, at most <tt>(last -
first)/2</tt> swaps. Exactly <tt>last - first</tt> applications of the predicate
are done.
</ins>
</p>
<p><ins>
If <tt>Iter</tt> merely satisfied <tt>ForwardIterator</tt> at most <tt>(last - first)</tt> swaps
are done. Exactly <tt>(last - first)</tt> applications of the predicate are done.
</ins></p>
</blockquote>

<p>
[Editorial note: I looked for existing precedent in how we might call out
distinct overloads overloads from a set of constrained templates, but there
is not much existing practice to lean on.   advance/distance were the only
algorithms I could find, and that wording is no clearer.]
</p>

</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 25.2.12 from </p>
<blockquote><pre>template&lt;class BidirectionalIterator, class Predicate&gt; 
BidirectionalIterator partition(BidirectionalIterato r first, 
                                BidirectionalIterator last, 
                                Predicate pred); 
</pre></blockquote>
<p>to </p>
<blockquote><pre>template&lt;class ForwardIterator, class Predicate&gt; 
ForwardIterator partition(ForwardIterator first, 
                          ForwardIterator last, 
                          Predicate pred); 
</pre></blockquote>
<p>Change the complexity from </p>

<blockquote><p>
At most (last - first)/2 swaps are done. Exactly (last - first) 
applications of the predicate are done. 
</p></blockquote>

<p>to </p>

<blockquote><p>
If ForwardIterator is a bidirectional_iterator, at most (last - first)/2 
swaps are done; otherwise at most (last - first) swaps are done. Exactly 
(last - first) applications of the predicate are done. 
</p></blockquote>



<p><b>Rationale:</b></p>
<p>
Partition is a "foundation" algorithm useful in many contexts (like sorting
as just one example) - my motivation for extending it to include forward
iterators is foward_list - without this extension you can't partition an foward_list
(without writing your own partition). Holes like this in the standard
library weaken the argument for generic programming (ideally I'd be able
to provide a library that would refine std::partition() to other concepts
without fear of conflicting with other libraries doing the same - but
that is a digression). I consider the fact that partition isn't defined
to work for ForwardIterator a minor embarrassment.
</p>

<p><i>[Mont Tremblant: Moved to Open, request motivation and use cases
by next meeting. Sean provided further rationale by post-meeting
mailing.]</i></p>







<hr>
<h3><a name="502"></a>502. Proposition: Clarification of the interaction between a facet and an iterator</h3>
<p><b>Section:</b> 22.3.1.1.1 [locale.category] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Christopher Conrade Zseleghovski <b>Opened:</b> 2005-06-07  <b>Last modified:</b> 2008-03-13</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.category">issues</a> in [locale.category].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Motivation:
</p>

<p>
This requirement seems obvious to me, it is the essence of code modularity. 
I have complained to Mr. Plauger that the Dinkumware library does not 
observe this principle but he objected that this behaviour is not covered in 
the standard.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Append the following point to 22.1.1.1.1:
</p>

<p>
6. The implementation of a facet of Table 52 parametrized with an 
InputIterator/OutputIterator should use that iterator only as character 
source/sink respectively.
For a *_get facet, it means that the value received depends only on the 
sequence of input characters and not on how they are accessed.
For a *_put facet, it means that the sequence of characters output depends 
only on the value to be formatted and not of how the characters are stored.
</p>

<p><i>[
Berlin:  Moved to Open, Need to clean up this area to make it clear
locales don't have to contain open ended sets of facets. Jack, Howard,
Bill.
]</i></p>







<hr>
<h3><a name="503"></a>503. more on locales</h3>
<p><b>Section:</b> 22.4 [locale.categories] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> P.J. Plauger <b>Opened:</b> 2005-06-20  <b>Last modified:</b> 2008-03-13</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#locale.categories">active issues</a> in [locale.categories].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.categories">issues</a> in [locale.categories].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
a) In 22.2.1.1 para. 2 we refer to "the instantiations required in Table
51" to refer to the facet *objects* associated with a locale. And we
almost certainly mean just those associated with the default or "C"
locale. Otherwise, you can't switch to a locale that enforces a different
mapping between narrow and wide characters, or that defines additional
uppercase characters.
</p>

<p>
b) 22.2.1.5 para. 3 (codecvt) has the same issues.
</p>

<p>
c) 22.2.1.5.2 (do_unshift) is even worse. It *forbids* the generation of
a homing sequence for the basic character set, which might very well need
one.
</p>

<p>
d) 22.2.1.5.2 (do_length) likewise dictates that the default mapping
between wide and narrow characters be taken as one-for-one.
</p>

<p>
e) 22.2.2 para. 2 (num_get/put) is both muddled and vacuous, as far as
I can tell. The muddle is, as before, calling Table 51 a list of
instantiations. But the constraint it applies seems to me to cover
*all* defined uses of num_get/put, so why bother to say so?
</p>

<p>
f) 22.2.3.1.2 para. 1(do_decimal_point) says "The required instantiations
return '.' or L'.'.) Presumably this means "as appropriate for the
character type. But given the vague definition of "required" earlier,
this overrules *any* change of decimal point for non "C" locales.
Surely we don't want to do that.
</p>

<p>
g) 22.2.3.1.2 para. 2 (do_thousands_sep) says "The required instantiations
return ',' or L','.) As above, this probably means "as appropriate for the
character type. But this overrules the "C" locale, which requires *no*
character ('\0') for the thousands separator. Even if we agree that we
don't mean to block changes in decimal point or thousands separator,
we should also eliminate this clear incompatibility with C.
</p>

<p>
h) 22.2.3.1.2 para. 2 (do_grouping) says "The required instantiations
return the empty string, indicating no grouping." Same considerations
as for do_decimal_point.
</p>

<p>
i) 22.2.4.1 para. 1 (collate) refers to "instantiations required in Table
51". Same bad jargon.
</p>

<p>
j) 22.2.4.1.2 para. 1 (do_compare) refers to "instantiations required
in Table 51". Same bad jargon.
</p>

<p>
k) 22.2.5 para. 1 (time_get/put) uses the same muddled and vacuous
as num_get/put.
</p>

<p>
l) 22.2.6 para. 2 (money_get/put) uses the same muddled and vacuous
as num_get/put.
</p>

<p>
m) 22.2.6.3.2 (do_pos/neg_format) says "The instantiations required
in Table 51 ... return an object of type pattern initialized to
{symbol, sign, none, value}." This once again *overrides* the "C"
locale, as well as any other locale."
</p>

<p>
3) We constrain the use_facet calls that can be made by num_get/put,
so why don't we do the same for money_get/put? Or for any of the
other facets, for that matter?
</p>

<p>
4) As an almost aside, we spell out when a facet needs to use the ctype
facet, but several also need to use a codecvt facet and we don't say so.
</p>
<p><i>[
Berlin: Bill to provide wording.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="523"></a>523. regex case-insensitive character ranges are unimplementable as specified</h3>
<p><b>Section:</b> 28 [re] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Eric Niebler <b>Opened:</b> 2005-07-01  <b>Last modified:</b> 2008-03-13</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#re">active issues</a> in [re].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#re">issues</a> in [re].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
A problem with TR1 regex is currently being discussed on the Boost 
developers list. It involves the handling of case-insensitive matching 
of character ranges such as [Z-a]. The proper behavior (according to the 
ECMAScript standard) is unimplementable given the current specification 
of the TR1 regex_traits&lt;&gt; class template. John Maddock, the author of 
the TR1 regex proposal, agrees there is a problem. The full discussion 
can be found at http://lists.boost.org/boost/2005/06/28850.php (first 
message copied below). We don't have any recommendations as yet.
</p>
<p>
-- Begin original message --
</p>
<p>
The situation of interest is described in the ECMAScript specification
(ECMA-262), section 15.10.2.15:
</p>
<p>
"Even if the pattern ignores case, the case of the two ends of a range
is significant in determining which characters belong to the range.
Thus, for example, the pattern /[E-F]/i matches only the letters E, F,
e, and f, while the pattern /[E-f]/i matches all upper and lower-case
ASCII letters as well as the symbols [, \, ], ^, _, and `."
</p>
<p>
A more interesting case is what should happen when doing a
case-insentitive match on a range such as [Z-a]. It should match z, Z,
a, A and the symbols [, \, ], ^, _, and `. This is not what happens with
Boost.Regex (it throws an exception from the regex constructor).
</p>
<p>
The tough pill to swallow is that, given the specification in TR1, I
don't think there is any effective way to handle this situation.
According to the spec, case-insensitivity is handled with
regex_traits&lt;&gt;::translate_nocase(CharT) -- two characters are equivalent
if they compare equal after both are sent through the translate_nocase
function. But I don't see any way of using this translation function to
make character ranges case-insensitive. Consider the difficulty of
detecting whether "z" is in the range [Z-a]. Applying the transformation
to "z" has no effect (it is essentially std::tolower). And we're not
allowed to apply the transformation to the ends of the range, because as
ECMA-262 says, "the case of the two ends of a range is significant."
</p>
<p>
So AFAICT, TR1 regex is just broken, as is Boost.Regex. One possible fix
is to redefine translate_nocase to return a string_type containing all
the characters that should compare equal to the specified character. But
this function is hard to implement for Unicode, and it doesn't play nice
with the existing ctype facet. What a mess!
</p>
<p>
-- End original message --
</p>

<p><i>[
John Maddock adds:
]</i></p>


<p>
One small correction, I have since found that ICU's regex package does 
implement this correctly, using a similar mechanism to the current 
TR1.Regex.
</p>
<p>
Given an expression [c1-c2] that is compiled as case insensitive it:
</p>
<p>
Enumerates every character in the range c1 to c2 and converts it to it's 
case folded equivalent.  That case folded character is then used a key to a 
table of equivalence classes, and each member of the class is added to the 
list of possible matches supported by the character-class.  This second step 
isn't possible with our current traits class design, but isn't necessary if 
the input text is also converted to a case-folded equivalent on the fly.
</p>
<p>
ICU applies similar brute force mechanisms to character classes such as 
[[:lower:]] and [[:word:]], however these are at least cached, so the impact 
is less noticeable in this case.
</p>
<p>
Quick and dirty performance comparisons show that expressions such as 
"[X-\\x{fff0}]+" are indeed very slow to compile with ICU (about 200 times 
slower than a "normal" expression).  For an application that uses a lot of 
regexes this could have a noticeable performance impact.  ICU also has an 
advantage in that it knows the range of valid characters codes: code points 
outside that range are assumed not to require enumeration, as they can not 
be part of any equivalence class.  I presume that if we want the TR1.Regex 
to work with arbitrarily large character sets enumeration really does become 
impractical.
</p>
<p>
Finally note that Unicode has:
</p>
<p>
Three cases (upper, lower and title).
One to many, and many to one case transformations.
Character that have context sensitive case translations - for example an 
uppercase sigma has two different lowercase forms  - the form chosen depends 
on context(is it end of a word or not), a caseless match for an upper case 
sigma should match either of the lower case forms, which is why case folding 
is often approximated by tolower(toupper(c)).
</p>
<p>
Probably we need some way to enumerate character equivalence classes, 
including digraphs (either as a result or an input), and some way to tell 
whether the next character pair is a valid digraph in the current locale.
</p>
<p>
Hoping this doesn't make this even more complex that it was already,
</p>

<p><i>[
Portland:  Alisdair: Detect as invalid, throw an exception.
Pete: Possible general problem with case insensitive ranges.
]</i></p>




<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="539"></a>539. partial_sum and adjacent_difference should mention requirements</h3>
<p><b>Section:</b> 26.7.3 [partial.sum] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Marc Schoolderman <b>Opened:</b> 2006-02-06  <b>Last modified:</b> 2009-05-10</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There are some problems in the definition of partial_sum and
adjacent_difference in 26.4 [lib.numeric.ops]
</p>

<p>
Unlike <tt>accumulate</tt> and <tt>inner_product</tt>, these functions are not
parametrized on a "type T", instead, 26.4.3 [lib.partial.sum] simply
specifies the effects clause as;
</p>

<blockquote><p>
Assigns to every element referred to by iterator <tt>i</tt> in the range
<tt>[result,result + (last - first))</tt> a value correspondingly equal to
</p>
<blockquote><pre>((...(* first + *( first + 1)) + ...) + *( first + ( i - result )))
</pre></blockquote>
</blockquote>

<p>
And similarly for BinaryOperation. Using just this definition, it seems
logical to expect that:
</p>


<blockquote><pre>char i_array[4] = { 100, 100, 100, 100 };
int  o_array[4];

std::partial_sum(i_array, i_array+4, o_array);
</pre></blockquote>

<p>
Is equivalent to
</p>

<blockquote><pre>int o_array[4] = { 100, 100+100, 100+100+100, 100+100+100+100 };
</pre></blockquote>

<p>
i.e. 100, 200, 300, 400, with addition happening in the <tt>result type</tt>,
<tt>int</tt>.
</p>

<p>
Yet all implementations I have tested produce 100, -56, 44, -112,
because they are using an accumulator of the <tt>InputIterator</tt>'s
<tt>value_type</tt>, which in this case is <tt>char</tt>, not <tt>int</tt>.
</p>

<p>
The issue becomes more noticeable when the result of the expression <tt>*i +
*(i+1)</tt> or <tt>binary_op(*i, *i-1)</tt> can't be converted to the
<tt>value_type</tt>. In a contrived example:
</p>

<blockquote><pre>enum not_int { x = 1, y = 2 };
...
not_int e_array[4] = { x, x, y, y };
std::partial_sum(e_array, e_array+4, o_array);
</pre></blockquote>

<p>
Is it the intent that the operations happen in the <tt>input type</tt>, or in
the <tt>result type</tt>?
</p>

<p>
If the intent is that operations happen in the <tt>result type</tt>, something
like this should be added to the "Requires" clause of 26.4.3/4
[lib.partial.sum]:
</p>

<blockquote><p>
The type of <tt>*i + *(i+1)</tt> or <tt>binary_op(*i, *(i+1))</tt> shall meet the
requirements of <tt>CopyConstructible</tt> (20.1.3) and <tt>Assignable</tt>
(23.1) types.
</p></blockquote>

<p>
(As also required for <tt>T</tt> in 26.4.1 [lib.accumulate] and 26.4.2
[lib.inner.product].)
</p>

<p>
The "auto initializer" feature proposed in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1894.pdf">N1894</a>
is not required to
implement <tt>partial_sum</tt> this way. The 'narrowing' behaviour can still be
obtained by using the <tt>std::plus&lt;&gt;</tt> function object.
</p>

<p>
If the intent is that operations happen in the <tt>input type</tt>, then
something like this should be added instead;
</p>

<blockquote><p>
The type of *first shall meet the requirements of
<tt>CopyConstructible</tt> (20.1.3) and <tt>Assignable</tt> (23.1) types.
The result of <tt>*i + *(i+1)</tt> or <tt>binary_op(*i, *(i+1))</tt> shall be
convertible to this type.
</p></blockquote>

<p>
The 'widening' behaviour can then be obtained by writing a custom proxy
iterator, which is somewhat involved.
</p>

<p>
In both cases, the semantics should probably be clarified.
</p>

<p>
26.4.4 [lib.adjacent.difference] is similarly underspecified, although
all implementations seem to perform operations in the 'result' type:
</p>

<blockquote><pre>unsigned char i_array[4] = { 4, 3, 2, 1 };
int o_array[4];

std::adjacent_difference(i_array, i_array+4, o_array);
</pre></blockquote>

<p>
o_array is 4, -1, -1, -1 as expected, not 4, 255, 255, 255.
</p>

<p>
In any case, <tt>adjacent_difference</tt> doesn't mention the requirements on the
<tt>value_type</tt>; it can be brought in line with the rest of 26.4
[lib.numeric.ops] by adding the following to 26.4.4/2
[lib.adjacent.difference]:
</p>

<blockquote><p>
The type of <tt>*first</tt> shall meet the requirements of
<tt>CopyConstructible</tt> (20.1.3) and <tt>Assignable</tt> (23.1) types."
</p></blockquote>
<p><i>[
Berlin: Giving output iterator's value_types very controversial. Suggestion of
adding signatures to allow user to specify "accumulator".
]</i></p>


<p><i>[
Bellevue:
]</i></p>


<blockquote>
The intent of the algorithms is to perform their calculations using the type of the input iterator.
Proposed wording provided.
</blockquote>

<p><i>[
Sophia Antipolis:
]</i></p>


<blockquote>
We did not agree that the proposed resolution was correct. For example,
when the arguments are types <tt>(float*, float*, double*)</tt>, the
highest-quality solution would use double as the type of the
accumulator. If the intent of the wording is to require that the type of
the accumulator must be the <tt>input_iterator</tt>'s <tt>value_type</tt>, the wording
should specify it.
</blockquote>

<p><i>[
2009-05-09 Alisdair adds:
]</i></p>


<blockquote>
<p>
Now that we have the facility, the 'best' accumulator type could probably be
deduced as:
</p>
<blockquote><pre>std::common_type&lt;InIter::value_type, OutIter::reference&gt;::type
</pre></blockquote>
<p>
This type would then have additional requirements of constructability and
incrementability/assignability.
</p>
<p>
If this extracting an accumulator type from a pair/set of iterators (with
additional requirements on that type) is a problem for multiple functions,
it might be worth extracting into a SharedAccumulator concept or similar.
</p>
<p>
I'll go no further in writing up wording now, until the group gives a
clearer indication of preferred direction.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add to section 26.7.3 [partial.sum] paragraph 4 the following two sentences:
</p>

<blockquote>
The type of <tt>*first</tt> shall meet the requirements of <tt>CopyConstructible</tt>?
(20.1.3?) and <tt>Assignable</tt> (23.1?) types. The result of <tt>*i + *(i+1)</tt> or
<tt>binary_op(*i, *(i+1))</tt> shall be convertible to this type.
</blockquote>

<p>
Add to section 26.7.4 [adjacent.difference] paragraph 2 the following sentence:
</p>

<blockquote>
The type of <tt>*first</tt> shall meet the requirements of <tt>CopyConstructible</tt>?
(20.1.3) and <tt>Assignable</tt> (23.1) types.
</blockquote>






<hr>
<h3><a name="546"></a>546. _Longlong and _ULonglong are integer types</h3>
<p><b>Section:</b> TR1 5.1.1 [tr.rand.req] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2006-01-10  <b>Last modified:</b> 2007-10-09</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The TR sneaks in two new integer types, _Longlong and _Ulonglong, in [tr.c99].
The rest of the TR should use that type.  I believe this affects two places.
First, the random number requirements, 5.1.1/10-11, lists all of the types with
which template parameters named IntType and UIntType may be instantiated.
_Longlong (or "long long", assuming it is added to C++0x) should be added to the
IntType list, and UIntType (again, or "unsigned long long") should be added to
the UIntType list.  Second, 6.3.2 lists the types for which hash&lt;&gt; is
required to be instantiable. _Longlong and _Ulonglong should be added to that
list, so that people may use long long as a hash key.
</p>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="564"></a>564. stringbuf seekpos underspecified</h3>
<p><b>Section:</b> 27.8.1.4 [stringbuf.virtuals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2006-02-23  <b>Last modified:</b> 2007-10-10</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#stringbuf.virtuals">issues</a> in [stringbuf.virtuals].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The   effects  of  the   <code>seekpos()</code>  member   function  of
<code>basic_stringbuf</code>  simply say  that the  function positions
the  input and/or  output  sequences  but fail  to  spell out  exactly
how. This is in contrast  to the detail in which <code>seekoff()</code>
is described.
</p>


<p><b>Proposed resolution:</b></p>
        <p>

Change 27.7.1.3, p13 to read:

        </p>
<blockquote>
<p>
-13- <i>Effects:</i> <ins>Same as <tt>seekoff(off_type(<i>sp</i>), ios_base::beg,
<i>which</i>)</tt>.</ins> <del>Alters the stream position within the controlled sequences,
if possible, to correspond to the stream position stored in <tt><i>sp</i></tt>
(as described below).</del>
</p>
<ul>
<li><del>If <tt>(<i>which</i> &amp; ios_base::in) != 0</tt>, positions the input sequence.</del></li>
<li><del>If <tt>(<i>which</i> &amp; ios_base::out) != 0</tt>, positions the output sequence.</del></li>
<li><del>If <tt><i>sp</i></tt> is an invalid stream position, or if the function
positions neither sequence, the positioning operation fails. If <tt><i>sp</i></tt>
has not been obtained by a previous successful call to one of the positioning
functions (<tt>seekoff</tt>, <tt>seekpos</tt>, <tt>tellg</tt>, <tt>tellp</tt>)
the effect is undefined.</del></li>
</ul>
</blockquote>


<p><i>[
Kona (2007): A <tt>pos_type</tt> is a position in a stream by
definition, so there is no ambiguity as to what it means. Proposed
Disposition: NAD
]</i></p>


<p><i>[
Post-Kona Martin adds:
I'm afraid I disagree
with the Kona '07 rationale for marking it NAD. The only text
that describes precisely what it means to position the input
or output sequence is in <tt>seekoff()</tt>. The <tt>seekpos()</tt> Effects
clause is inadequate in comparison and the proposed resolution
plugs the hole by specifying <tt>seekpos()</tt> in terms of <tt>seekoff()</tt>.
]</i></p>





<hr>
<h3><a name="565"></a>565. xsputn inefficient</h3>
<p><b>Section:</b> 27.6.2.4.5 [streambuf.virt.put] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2006-02-23  <b>Last modified:</b> 2007-10-09</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
        <p>

<tt>streambuf::xsputn()</tt>  is  specified  to  have  the  effect  of
"writing up to  <tt>n</tt> characters to the output  sequence as if by
repeated calls to <tt>sputc(c)</tt>."

        </p>
        <p>

Since  <tt>sputc()</tt> is required  to call  <tt>overflow()</tt> when
<tt>(pptr()    ==   epptr())</tt>    is   true,    strictly   speaking
<tt>xsputn()</tt>  should do  the same.   However, doing  so  would be
suboptimal in  some interesting cases,  such as in unbuffered  mode or
when the buffer is <tt>basic_stringbuf</tt>.

        </p>
        <p>

Assuming  calling <tt>overflow()</tt>  is  not really  intended to  be
required  and the  wording is  simply  meant to  describe the  general
effect of appending to the end  of the sequence it would be worthwhile
to  mention in  <tt>xsputn()</tt> that  the function  is  not actually
required to cause a call to <tt>overflow()</tt>.

        </p>


<p><b>Proposed resolution:</b></p>
        <p>

Add the following sentence  to the <tt>xsputn()</tt> Effects clause in
27.5.2.4.5, p1 (N1804):

        </p>
        <blockquote>    
            <p>
-1- <i>Effects:</i> Writes up to <tt><i>n</i></tt> characters to the output
sequence as if by repeated calls to <tt>sputc(<i>c</i>)</tt>. The characters 
written are obtained from successive elements of the array whose first element
is designated by <tt><i>s</i></tt>. Writing stops when either <tt><i>n</i></tt>
characters have been written or a call to <tt>sputc(<i>c</i>)</tt> would return
<tt>traits::eof()</tt>. <ins>It is  uspecified whether the function  calls
<tt>overflow()</tt> when <tt>(pptr() ==  epptr())</tt> becomes true or whether
it achieves the same effects by other means.</ins>
            </p>
        </blockquote>    
        <p>

In addition,  I suggest to  add a footnote  to this function  with the
same text as Footnote 292 to  make it extra clear that derived classes
are permitted to override <tt>xsputn()</tt> for efficiency.

        </p>


<p><i>[
Kona (2007): We want to permit a <tt>streambuf</tt> that streams output directly
to a device without making calls to <tt>sputc</tt> or <tt>overflow</tt>. We believe that
has always been the intention of the committee. We believe that the
proposed wording doesn't accomplish that. Proposed Disposition: Open
]</i></p>





<hr>
<h3><a name="568"></a>568. log2 overloads missing</h3>
<p><b>Section:</b> TR1 8.16.4 [tr.c99.cmath.over] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Paolo Carlini <b>Opened:</b> 2006-03-07  <b>Last modified:</b> 2009-05-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>log2</tt> is missing from the list of "additional overloads" in TR1 8.16.4 [tr.c99.cmath.over] p1.
</p>

<p>
Hinnant:  This is a TR1 issue only.  It is fixed in the current (N2135) WD.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree this has been fixed in the Working Draft.
Move to NAD.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Add <tt>log2</tt> to the list of functions in TR1 8.16.4 [tr.c99.cmath.over] p1.
</p>





<hr>
<h3><a name="573"></a>573. C++0x file positioning should handle modern file sizes</h3>
<p><b>Section:</b> 27.5.3 [fpos] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Beman Dawes <b>Opened:</b> 2006-04-12  <b>Last modified:</b> 2007-10-09</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#fpos">issues</a> in [fpos].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There are two deficiencies related to file sizes:
</p>
<ol>
<li>It doesn't appear that the Standard Library is specified in
      a way that handles modern file sizes, which are often too
      large to be represented by an unsigned long.</li>

<li>The std::fpos class does not currently have the ability to
      set/get file positions.</li>
</ol>
<p>
The Dinkumware implementation of the Standard Library as shipped with the Microsoft compiler copes with these issues by:
</p>
<ol type="A">
<li>Defining fpos_t be long long, which is large enough to
      represent any file position likely in the foreseeable future.</li>

<li>Adding member functions to class fpos. For example,
<blockquote><pre>fpos_t seekpos() const;
</pre></blockquote>
</li>
</ol>
<p>
Because there are so many types relating to file positions and offsets (fpos_t,
fpos, pos_type, off_type, streamoff, streamsize, streampos, wstreampos, and
perhaps more), it is difficult to know if the Dinkumware extensions are
sufficient. But they seem a useful starting place for discussions, and they do
represent existing practice.
</p>

<p><i>[
Kona (2007): We need a paper. It would be nice if someone proposed
clarifications to the definitions of <tt>pos_type</tt> and <tt>off_type</tt>. Currently
these definitions are horrible. Proposed Disposition: Open
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="580"></a>580. unused allocator members</h3>
<p><b>Section:</b> 23.2.1 [container.requirements.general] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2006-06-14  <b>Last modified:</b> 2009-05-01</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#container.requirements.general">active issues</a> in [container.requirements.general].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#container.requirements.general">issues</a> in [container.requirements.general].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#479">479</a></p>
<p><b>Discussion:</b></p>
        <p>

C++ Standard Library  templates that take an allocator  as an argument
are    required    to    call    the    <code>allocate()</code>    and
<code>deallocate()</code>  members of the  allocator object  to obtain
storage.  However, they do not appear to be required to call any other
allocator      members      such     as      <code>construct()</code>,
<code>destroy()</code>,           <code>address()</code>,          and
<code>max_size()</code>.  This makes these allocator members less than
useful in portable programs.

        </p>
        <p>

It's unclear to me whether the absence of the requirement to use these
allocator  members  is  an  unintentional  omission  or  a  deliberate
choice. However,  since the functions exist in  the standard allocator
and  since  they are  required  to  be  provided by  any  user-defined
allocator I  believe the standard  ought to be clarified  to explictly
specify  whether programs  should or  should not  be able  to  rely on
standard containers calling the functions.

        </p>
        <p>

I  propose  that all  containers  be required  to  make  use of  these
functions.

        </p>
<p><i>[
Batavia:  We support this resolution.  Martin to provide wording.
]</i></p>

<p><i>[
pre-Oxford:  Martin provided wording.
]</i></p>


<p><i>[
2009-04-28 Pablo adds:
]</i></p>


<blockquote>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2554.pdf">N2554</a>
(scoped allocators),
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2768.pdf">N2768</a>
(allocator concepts), and
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2810.pdf">N2810</a>
(allocator defects), address all of these points EXCEPT <tt>max_size()</tt>.
So, I would add a note to that affect and re-class the defect as belonging
to section 23.2.1 [container.requirements.general].
</blockquote>

    

    <p><b>Proposed resolution:</b></p>
       <p>

Specifically, I propose to change 23.2 [container.requirements],
p9 as follows:

       </p>
           <blockquote>
<p>
-9- Copy constructors  for all container types defined  in this clause
<ins>that   are  parametrized  on   <code>Allocator</code></ins>  copy
<del>an</del><ins>the</ins>  allocator argument from  their respective
first parameters.

All other  constructors for  these container types  take a<del>n</del>
<ins>const</ins>  <code>Allocator&amp;</code>  argument  (20.1.6),  an
allocator whose <code>value_type</code> is the same as the container's
<code>value_type</code>.

A copy of this  argument <del>is</del><ins>shall be</ins> used for any
memory  allocation <ins> and  deallocation</ins> performed<del>,</del>
by these  constructors and by all  member functions<del>,</del> during
the  lifetime  of each  container  object.   <ins>Allocation shall  be
performed  "as  if"  by  calling  the  <code>allocate()</code>  member
function on  a copy  of the allocator  object of the  appropriate type
<sup>New  Footnote)</sup>,   and  deallocation  "as   if"  by  calling
<code>deallocate()</code> on  a copy of  the same allocator  object of
the corresponding type.</ins>

<ins>A  copy of  this argument  shall also  be used  to  construct and
destroy objects whose lifetime  is managed by the container, including
but not  limited to those of  the container's <code>value_type</code>,
and  to  obtain  their  address.   All  objects  residing  in  storage
allocated by a  container's allocator shall be constructed  "as if" by
calling the <code>construct()</code> member  function on a copy of the
allocator object of  the appropriate type.  The same  objects shall be
destroyed "as if"  by calling <code>destroy()</code> on a  copy of the
same allocator object  of the same type.  The  address of such objects
shall be obtained "as if" by calling the <code>address()</code> member
function  on  a  copy  of  the allocator  object  of  the  appropriate
type.</ins>

<ins>Finally, a copy  of this argument shall be  used by its container
object to determine  the maximum number of objects  of the container's
<code>value_type</code> the container may  store at the same time. The
container  member function <code>max_size()</code> obtains  this number
from      the      value      returned      by     a      call      to
<code>get_allocator().max_size()</code>.</ins>

In   all  container   types  defined   in  this   clause <ins>that  are
parametrized     on    <code>Allocator</code></ins>,     the    member
<code>get_allocator()</code>     returns     a     copy     of     the
<code>Allocator</code>     object     used     to    construct     the
container.<sup>258)</sup>
</p>
<p>
New Footnote: This type  may be different from <code>Allocator</code>:
it     may    be     derived    from     <code>Allocator</code>    via
<code>Allocator::rebind&lt;U&gt;::other</code>   for  the  appropriate
type <code>U</code>.
</p>
           </blockquote>
       <p>

The proposed wording seems cumbersome but I couldn't think of a better
way   to  describe   the   requirement  that   containers  use   their
<code>Allocator</code>  to manage  only objects  (regardless  of their
type)  that  persist  over  their  lifetimes  and  not,  for  example,
temporaries  created on the  stack. That  is, containers  shouldn't be
required  to  call  <code>Allocator::construct(Allocator::allocate(1),
elem)</code>  just to  construct a  temporary copy  of an  element, or
<code>Allocator::destroy(Allocator::address(temp),     1)</code>    to
destroy temporaries.

       </p>


<p><i>[
Howard: This same paragraph will need some work to accommodate <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#431">431</a>.
]</i></p>


<p><i>[
post Oxford:  This would be rendered NAD Editorial by acceptance of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2257.html">N2257</a>.
]</i></p>





<hr>
<h3><a name="582"></a>582. specialized algorithms and volatile storage</h3>
<p><b>Section:</b> 20.8.11.2 [uninitialized.copy] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2006-06-14  <b>Last modified:</b> 2009-03-14</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#uninitialized.copy">issues</a> in [uninitialized.copy].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>Related to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1029">1029</a></p>
        <p>

The specialized  algorithms [lib.specialized.algorithms] are specified
as having the general effect of invoking the following expression:

        </p>
            <pre>
new (static_cast&lt;void*&gt;(&amp;*i))
    typename iterator_traits&lt;ForwardIterator&gt;::value_type (x)

            </pre>
        <p>

This  expression is  ill-formed  when the  type  of the  subexpression
<code>&amp;*i</code> is some volatile-qualified <code>T</code>.

        </p>

<p><i>[
Batavia:  Lack of support for proposed resolution but agree there is a
defect.  Howard to look at wording.  Concern that move semantics
properly expressed if iterator returns rvalue.
]</i></p>


    

    <p><b>Proposed resolution:</b></p>
        <p>

In order  to allow these algorithms  to operate on  volatile storage I
propose to change the expression so as to make it well-formed even for
pointers  to volatile  types.  Specifically,  I propose  the following
changes to clauses 20 and 24. Change 20.6.4.1, p1 to read:

        </p>
            <pre>
<i>Effects</i>:

typedef typename iterator_traits&lt;ForwardIterator&gt;::pointer    pointer;
typedef typename iterator_traits&lt;ForwardIterator&gt;::value_type value_type;

for (; first != last; ++result, ++first)
    new (static_cast&lt;void*&gt;(const_cast&lt;pointer&gt;(&amp;*result))
        value_type (*first);

            </pre>
        <p>

change 20.6.4.2, p1 to read

        </p>
            <pre>
<i>Effects</i>:

typedef typename iterator_traits&lt;ForwardIterator&gt;::pointer    pointer;
typedef typename iterator_traits&lt;ForwardIterator&gt;::value_type value_type;

for (; first != last; ++result, ++first)
    new (static_cast&lt;void*&gt;(const_cast&lt;pointer&gt;(&amp;*first))
        value_type (*x);

            </pre>
        <p>

and change 20.6.4.3, p1 to read

        </p>
            <pre>
<i>Effects</i>:

typedef typename iterator_traits&lt;ForwardIterator&gt;::pointer    pointer;
typedef typename iterator_traits&lt;ForwardIterator&gt;::value_type value_type;

for (; n--; ++first)
    new (static_cast&lt;void*&gt;(const_cast&lt;pointer&gt;(&amp;*first))
        value_type (*x);

            </pre>
        <p>

In   addition,  since   there   is  no   partial  specialization   for
<code>iterator_traits&lt;volatile T*&gt;</code>  I propose to  add one
to parallel such specialization  for &lt;const T*&gt;. Specifically, I
propose to add the following text to the end of 24.3.1, p3:

        </p>
        <p>

and for pointers to volatile as 

        </p>
            <pre>
namespace std {
template&lt;class T&gt; struct iterator_traits&lt;volatile T*&gt; {
typedef ptrdiff_t difference_type;
typedef T value_type;
typedef volatile T* pointer;
typedef volatile T&amp; reference;
typedef random_access_iterator_tag iterator_category;
};
}

            </pre>
        <p>

Note that  the change to  <code>iterator_traits</code> isn't necessary
in order to implement the  specialized algorithms in a way that allows
them to operate on volatile  strorage. It is only necesassary in order
to specify  their effects in terms  of <code>iterator_traits</code> as
is  done here.   Implementations can  (and some  do) achieve  the same
effect by means of function template overloading.

        </p>
    



<hr>
<h3><a name="585"></a>585. facet error reporting</h3>
<p><b>Section:</b> 22.4 [locale.categories] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Martin Sebor, Paolo Carlini <b>Opened:</b> 2006-06-22  <b>Last modified:</b> 2007-10-09</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#locale.categories">active issues</a> in [locale.categories].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.categories">issues</a> in [locale.categories].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
        <p>

Section  22.2, paragraph 2  requires facet  <code>get()</code> members
that    take    an    <code>ios_base::iostate&amp;</code>    argument,
<code><i>err</i></code>,  to   ignore  the  (initial)   value  of  the
argument, but to set it to <code>ios_base::failbit</code> in case of a
parse error.

        </p>
        <p>

We  believe  there  are  a   few  minor  problems  with  this  blanket
requirement  in   conjunction  with   the  wording  specific   to  each
<code>get()</code> member function.

        </p>
        <p>

First,  besides <code>get()</code>  there are  other  member functions
with     a      slightly     different     name      (for     example,
<code>get_date()</code>). It's not completely clear that the intent of
the  paragraph  is  to  include  those  as  well,  and  at  least  one
implementation has interpreted the requirement literally.

        </p>
        <p>

Second,    the     requirement    to    "set     the    argument    to
<code>ios_base::failbit</code>  suggests that  the  functions are  not
permitted    to   set    it   to    any   other    value    (such   as
<code>ios_base::eofbit</code>,   or   even  <code>ios_base::eofbit   |
ios_base::failbit</code>).

        </p>
        <p>

However, 22.2.2.1.2, p5 (Stage  3 of <code>num_get</code> parsing) and
p6 (<code>bool</code> parsing)  specifies that the <code>do_get</code>
functions  perform <code><i>err</i> |=  ios_base::eofbit</code>, which
contradicts  the earlier  requirement to  ignore  <i>err</i>'s initial
value.

        </p>
        <p>

22.2.6.1.2,  p1  (the  Effects  clause of  the  <code>money_get</code>
facet's  <code>do_get</code>  member  functions) also  specifies  that
<code><i>err</i></code>'s initial  value be used to  compute the final
value  by  ORing  it  with  either  <code>ios_base::failbit</code>  or
with<code>ios_base::eofbit | ios_base::failbit</code>.

        </p>
    

    <p><b>Proposed resolution:</b></p>
        <p>

We believe the  intent is for all facet member  functions that take an
<code>ios_base::iostate&amp;</code> argument to:

        </p>
            <ul>
                <li>

ignore the initial value of the <code><i>err</i></code> argument,

                </li>
                <li>

reset <code><i>err</i></code>  to <code>ios_base::goodbit</code> prior
to any further processing,

                </li>
                <li>

and       set      either       <code>ios_base::eofbit</code>,      or
<code>ios_base::failbit</code>, or both in <code><i>err</i></code>, as
appropriate,  in response  to  reaching the  end-of-file  or on  parse
error, or both.

                </li>
            </ul>
        <p>

To that effect we propose to change 22.2, p2 as follows:

        </p>
        <p>

The  <i>put</i><del>()</del>  members  make  no  provision  for  error
reporting.   (Any  failures of  the  OutputIterator  argument must  be
extracted   from  the   returned  iterator.)    <ins>Unless  otherwise
specified, </ins>the <i>get</i><del>()</del>  members  <ins>that</ins>
take an  <code>ios_base::iostate&amp;</code> argument <del>whose value
they  ignore,  but  set  to  ios_base::failbit  in  case  of  a  parse
error.</del><ins>,   <code><i>err</i></code>,   start  by   evaluating
<code>err  =   ios_base::goodbit</code>,  and  may   subsequently  set
<i>err</i>     to     either     <code>ios_base::eofbit</code>,     or
<code>ios_base::failbit</code>,     or     <code>ios_base::eofbit    |
ios_base::failbit</code> in response to reaching the end-of-file or in
case of a parse error, or both, respectively.</ins>

        </p>
    
    
<p><i>[
Kona (2007): We need to change the proposed wording to clarify that the
phrase "the get members" actually denotes <tt>get()</tt>, <tt>get_date()</tt>, etc.
Proposed Disposition: Open
]</i></p>




<hr>
<h3><a name="588"></a>588. requirements on zero sized tr1::arrays and other details</h3>
<p><b>Section:</b> 23.3.1 [array] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Gennaro Prota <b>Opened:</b> 2006-07-18  <b>Last modified:</b> 2009-05-30</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#array">active issues</a> in [array].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#array">issues</a> in [array].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The wording used for section 23.2.1 [lib.array] seems to be subtly
ambiguous about zero sized arrays (N==0). Specifically:
</p>
<p>
* "An instance of array&lt;T, N&gt; stores N elements of type T, so that
[...]"
</p>
<p>
Does this imply that a zero sized array object stores 0 elements, i.e.
that it cannot store any element of type T? The next point clarifies
the rationale behind this question, basically how to implement begin()
and end():
</p>
<p>
* 23.2.1.5 [lib.array.zero], p2: "In the case that N == 0, begin() ==
end() == unique value."
</p>
<p>
What does "unique" mean in this context? Let's consider the following
possible implementations, all relying on a partial specialization:
</p>
<blockquote><pre>a)
    template&lt; typename T &gt;
    class array&lt; T, 0 &gt; {
    
        ....

        iterator begin()
        { return iterator( reinterpret_cast&lt; T * &gt;( this ) ); }
        ....

    };
</pre></blockquote>
<p>
This has been used in boost, probably intending that the return value
had to be unique to the specific array object and that array couldn't
store any T. Note that, besides relying on a reinterpret_cast, has
(more than potential) alignment problems.
</p>
<blockquote><pre>b)
    template&lt; typename T &gt;
    class array&lt; T, 0 &gt; {
    
        T t;

        iterator begin()
        { return iterator( &amp;t ); }
        ....

    };
</pre></blockquote>
<p>
This provides a value which is unique to the object and to the type of
the array, but requires storing a T. Also, it would allow the user to
mistakenly provide an initializer list with one element.
</p>
<p>
A slight variant could be returning *the* null pointer of type T
</p>
<blockquote><pre>    return static_cast&lt;T*&gt;(0);
</pre></blockquote>
<p>
In this case the value would be unique to the type array&lt;T, 0&gt; but not
to the objects (all objects of type array&lt;T, 0&gt; with the same value
for T would yield the same pointer value).
</p>
<p>
Furthermore this is inconsistent with what the standard requires from
allocation functions (see library issue 9).
</p>
<p>
c) same as above but with t being a static data member; again, the
value would be unique to the type, not to the object.
</p>
<p>
d) to avoid storing a T *directly* while disallowing the possibility
to use a one-element initializer list a non-aggregate nested class
could be defined
</p>
<blockquote><pre>    struct holder { holder() {} T t; } h;
</pre></blockquote>
<p>
and then begin be defined as
</p>
<blockquote><pre> iterator begin() { return &amp;h.t; }
</pre></blockquote>
<p>
But then, it's arguable whether the array stores a T or not.
Indirectly it does.
</p>
<p>
-----------------------------------------------------
</p>
<p>
Now, on different issues:
</p>
<p>
* what's the effect of calling assign(T&amp;) on a zero-sized array? There
seems to be only mention of front() and back(), in 23.2.1 [lib.array]
p4 (I would also suggest to move that bullet to section 23.2.1.5
[lib.array.zero], for locality of reference)
</p>
<p>
* (minor) the opening paragraph of 23.2.1 [lib.array] wording is a bit
inconsistent with that of other sequences: that's not a problem in
itself, but compare it for instance with "A vector is a kind of
sequence that supports random access iterators"; though the intent is
obvious one might argue that the wording used for arrays doesn't tell
what an array is, and relies on the reader to infer that it is what
the &lt;array&gt; header defines.
</p>
<p>
* it would be desiderable to have a static const data member of type
std::size_t, with value N, for usage as integral constant expression
</p>
<p>
* section 23.1 [lib.container.requirements] seem not to consider
fixed-size containers at all, as it says: "[containers] control
allocation and deallocation of these objects [the contained objects]
through constructors, destructors, *insert and erase* operations"
</p>
<p>
* max_size() isn't specified: the result is obvious but, technically,
it relies on table 80: "size() of the largest possible container"
which, again, doesn't seem to consider fixed size containers
</p>

<p><i>[
2009-05-29 Daniel adds:
]</i></p>


<blockquote>
<ol type="a">
<li>
<p>
star bullet 1 ("what's the effect of calling <tt>assign(T&amp;)</tt> on a
zero-sized array?[..]");
</p>
<blockquote>
<tt>assign</tt> has been renamed to <tt>fill</tt> and the semantic of <tt>fill</tt> is now
defined in terms of
the free algorithm <tt>fill_n</tt>, which is well-defined for this situation.
</blockquote>
</li>
<li>
<p>
star bullet 3 ("it would be desiderable to have a static const data
member..."):
</p>
<blockquote>
It seems that <tt>tuple_size&lt;array&lt;T, N&gt; &gt;::value</tt> as of 23.3.1.7 [array.tuple] does
provide this functionality now.
</blockquote>
</li>
</ol>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>


<p><i>[
Kona (2007): requirements on zero sized <tt>tr1::array</tt>s and other details
Issue 617: <tt>std::array</tt> is a sequence that doesn't satisfy the sequence
requirements? Alisdair will prepare a paper. Proposed Disposition: Open
]</i></p>





<hr>
<h3><a name="597"></a>597. Decimal: The notion of 'promotion' cannot be emulated by user-defined types.</h3>
<p><b>Section:</b> TRDecimal 3.2 [trdec.types.types] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Daveed Vandevoorde <b>Opened:</b> 2006-04-05  <b>Last modified:</b> 2009-05-01</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#trdec.types.types">active issues</a> in [trdec.types.types].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#trdec.types.types">issues</a> in [trdec.types.types].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In a private email, Daveed writes:
</p>
<blockquote>
<p>
I am not familiar with the C TR, but my guess is that the
class type approach still won't match a built-in type
approach because the notion of "promotion" cannot be
emulated by user-defined types.
</p>
<p>
Here is an example:
</p>
</blockquote>
<pre>
         struct S {
           S(_Decimal32 const&amp;);  // Converting constructor
         };
         void f(S);

         void f(_Decimal64);

         void g(_Decimal32 d) {
           f(d);
         }
</pre>

<blockquote>
<p>
If _Decimal32 is a built-in type, the call f(d) will likely
resolve to f(_Decimal64) because that requires only a
promotion, whereas f(S) requires a user-defined conversion.
</p>
<p>
If _Decimal32 is a class type, I think the call f(d) will be
ambiguous because both the conversion to _Decimal64 and the
conversion to S will be user-defined conversions with neither
better than the other.
</p>
</blockquote>
<p>
Robert comments:
</p>
<p>
In general, a library of arithmetic types cannot exactly emulate the
behavior of the intrinsic numeric types. There are several ways to tell
whether an implementation of the decimal types uses compiler
intrinisics or a library. For example:
</p>
<pre>                 _Decimal32 d1;
                 d1.operator+=(5);  // If d1 is a builtin type, this won't compile.
</pre>
<p>
In preparing the decimal TR, we have three options:
</p>
<ol>
<li>require that the decimal types be class types</li>
<li>require that the decimal types be builtin types, like float and double</li>
<li>specify a library of class types, but allow enough implementor
latitude that a conforming implementation could instead provide builtin
types</li>
</ol>
<p>
We decided as a group to pursue option #3, but that approach implies
that implementations may not agree on the semantics of certain use
cases (first example, above), or on whether certain other cases are
well-formed (second example). Another potentially important problem is
that, under the present definition of POD, the decimal classes are not
POD types, but builtins will be.
</p>
<p>Note that neither example above implies any problems with respect to
C-to-C++ compatibility, since neither example can be expressed in C.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="606"></a>606. Decimal: allow narrowing conversions</h3>
<p><b>Section:</b> TRDecimal 3.2 [trdec.types.types] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2006-06-15  <b>Last modified:</b> 2007-01-15</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#trdec.types.types">active issues</a> in [trdec.types.types].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#trdec.types.types">issues</a> in [trdec.types.types].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In c++std-lib-17205, Martin writes:
</p>
<blockquote><p>...was it a deliberate design choice to make narrowing
assignments ill-formed while permitting narrowing compound assignments?
For instance:
</p></blockquote>
<pre>      decimal32 d32;
      decimal64 d64;

      d32 = 64;     // error
      d32 += 64;    // okay
</pre>
<p>
In c++std-lib-17229, Robert responds:
</p>
<blockquote><p>It is a vestige of an old idea that I forgot to remove
from the paper. Narrowing assignments should be permitted. The bug is
that the converting constructors that cause narrowing should not be
explicit. Thanks for pointing this out.
</p></blockquote>

<p><b>Proposed resolution:</b></p>
<p>
1.  In "3.2.2 Class <code>decimal32</code>" synopsis, remove the <code>explicit</code> specifier from the narrowing conversions:
</p>
<pre>                // <i>3.2.2.2 conversion from floating-point type:</i>
                <del>explicit</del> decimal32(decimal64 <i>d64</i>);
                <del>explicit</del> decimal32(decimal128 <i>d128</i>);
</pre>
<p>
2.  Do the same thing in "3.2.2.2. Conversion from floating-point type."
</p>
<p>
3.  In "3.2.3 Class <code>decimal64</code>" synopsis, remove the <code>explicit</code> specifier from the narrowing conversion:
</p>
<pre>                // <i>3.2.3.2 conversion from floating-point type:</i>
                <del>explicit</del> decimal64(decimal128 <i>d128</i>);
</pre>
<p>
4.  Do the same thing in "3.2.3.2. Conversion from floating-point type."
</p>

<p><i>[
Redmond: We prefer explicit conversions for narrowing and implicit for widening.
]</i></p>






<hr>
<h3><a name="614"></a>614. std::string allocator requirements still inconsistent</h3>
<p><b>Section:</b> 21.4 [basic.string] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Bo Persson <b>Opened:</b> 2006-12-05  <b>Last modified:</b> 2008-03-12</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#basic.string">active issues</a> in [basic.string].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#basic.string">issues</a> in [basic.string].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
This is based on N2134, where 21.3.1/2 states:
"... The Allocator object used shall be a copy of the Allocator object 
passed to the basic_string object's constructor or, if the constructor does 
not take an Allocator argument, a copy of a default-constructed Allocator 
object."
</p>
<p>
Section 21.3.2/1 lists two constructors:
</p>
<blockquote><pre>basic_string(const basic_string&lt;charT,traits,Allocator&gt;&amp; str );

basic_string(const basic_string&lt;charT,traits,Allocator&gt;&amp; str ,
             size_type pos , size_type n = npos,
             const Allocator&amp; a = Allocator());
</pre></blockquote>
<p>
and then says "In the first form, the Allocator value used is copied from 
str.get_allocator().", which isn't an option according to 21.3.1.
</p>
<p><i>[
Batavia:  We need blanket statement to the effect of:
]</i></p>


<ol>
<li>If an allocator is passed in, use it, or,</li>
<li>If a string is passed in, use its allocator.</li>
</ol>
<p><i>[
Review constructors and functions that return a string; make sure we follow these
rules (substr, operator+, etc.).  Howard to supply wording.
]</i></p>


<p><i>[
Bo adds:  The new container constructor which takes only a <tt>size_type</tt> is not
consistent with 23.2 [container.requirements], p9 which says in part:

<blockquote>
All other constructors for these container types take an
<tt>Allocator&amp;</tt> argument (20.1.2), an allocator whose value type
is the same as the container's value type. A copy of this argument is
used for any memory allocation performed, by these constructors and by
all member functions, during the lifetime of each container object.
</blockquote>
]</i></p>


<p><i>[
post Bellevue: We re-confirm that the issue is real. Pablo will provide wording.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="617"></a>617. std::array is a sequence that doesn't satisfy the sequence requirements?</h3>
<p><b>Section:</b> 23.3.1 [array] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Bo Persson <b>Opened:</b> 2006-12-30  <b>Last modified:</b> 2008-03-14</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#array">active issues</a> in [array].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#array">issues</a> in [array].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <tt>&lt;array&gt;</tt> header is given under 23.3 [sequences].
23.3.1 [array]/paragraph 3 says:
</p>
<blockquote><p>
"Unless otherwise specified, all array operations are as described in
23.2 [container.requirements]".
</p></blockquote>
<p>
However, array isn't mentioned at all in section 23.2 [container.requirements].
In particular, Table 82 "Sequence requirements" lists several operations (insert, erase, clear) 
that std::array does not have in 23.3.1 [array].
</p>
<p>
Also, Table 83 "Optional sequence operations" lists several operations that 
std::array does have, but array isn't mentioned.
</p>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="625"></a>625. mixed up <i>Effects</i> and <i>Returns</i> clauses</h3>
<p><b>Section:</b> 17 [library] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2007-01-20  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
 <p>

Many member functions of <code>basic_string</code> are overloaded,
with some of the overloads taking a <code>string</code> argument,
others <code>value_type*</code>, others <code>size_type</code>, and
others still <code>iterators</code>. Often, the requirements on one of
the overloads are expressed in the form of <i>Effects</i>,
<i>Throws</i>, and in the Working Paper
(<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2134.pdf">N2134</a>)
also <i>Remark</i> clauses, while those on the rest of the overloads
via a reference to this overload and using a <i>Returns</i> clause.
</p>

<p>
The difference between the two forms of specification is that per
17.5.1.4 [structure.specifications], p3, an <i>Effects</i> clause specifies
<i>"actions performed by the functions,"</i> i.e., its observable
effects, while a <i>Returns</i> clause is <i>"a description of the
return value(s) of a function"</i> that does not impose any
requirements on the function's observable effects.
</p>

<p>
Since only <i>Notes</i> are explicitly defined to be informative and
all other paragraphs are explicitly defined to be normative, like
<i>Effects</i> and <i>Returns</i>, the new <i>Remark</i> clauses also
impose normative requirements.
</p>

<p>
So by this strict reading of the standard there are some member
functions of <code>basic_string</code> that are required to throw an
exception under some conditions or use specific traits members while
many other otherwise equivalent overloads, while obliged to return the
same values, aren't required to follow the exact same requirements
with regards to the observable effects.
</p>

<p>
Here's an example of this problem that was precipitated by the change
from informative Notes to normative <i>Remark</i>s (presumably made to
address <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#424">424</a>):
</p>

<p>
In the Working Paper, <code>find(string, size_type)</code> contains a
<i>Remark</i> clause (which is just a <i>Note</i> in the current
standard) requiring it to use <code>traits::eq()</code>.
</p>

<p>
<code>find(const charT *s, size_type pos)</code> is specified to
return <code>find(string(s), pos)</code> by a <i>Returns</i> clause
and so it is not required to use <code>traits::eq()</code>. However,
the Working Paper has replaced the original informative <i>Note</i>
about the function using <code>traits::length()</code> with a
normative requirement in the form of a <i>Remark</i>. Calling
<code>traits::length()</code> may be suboptimal, for example when the
argument is a very long array whose initial substring doesn't appear
anywhere in <code>*this</code>.
</p>

<p>
Here's another similar example, one that existed even prior to the
introduction of <i>Remark</i>s:
</p>

<p>
<code> insert(size_type pos, string, size_type, size_type)</code> is
required to throw <code>out_of_range</code> if <code>pos &gt;
size()</code>.
</p>

<p>
<code>insert(size_type pos, string str)</code> is specified to return
<code>insert(pos, str, 0, npos)</code> by a <i>Returns</i> clause and
so its effects when <code>pos &gt; size()</code> are strictly speaking
unspecified.
</p><p>

</p>
I believe a careful review of the current <i>Effects</i> and
<i>Returns</i> clauses is needed in order to identify all such
problematic cases. In addition, a review of the Working Paper should
be done to make sure that the newly introduced normative <i>Remark</i>
clauses do not impose any undesirable normative requirements in place
of the original informative <i>Notes</i>.


<p><i>[
Batavia: Alan and Pete to work.
]</i></p>


<p><i>[
Bellevue: Marked as NAD Editorial.
]</i></p>


<p><i>[
Post-Sophia Antipolis:
Martin indicates there is still work to be done on this issue.
Reopened.
]</i></p>


<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Tom proposes we say that, unless specified otherwise,
it is always the caller's responsibility to verify that supplied arguments
meet the called function's requirements.
If further semantics are specified
(e.g., that the function throws under certain conditions),
then it is up to the implementer to check those conditions.
Alan feels strongly that our current use of Requires in this context
is confusing, especially now that <tt>requires</tt> is a new keyword.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="630"></a>630. arrays of valarray</h3>
<p><b>Section:</b> 26.6.2.1 [valarray.cons] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2007-01-28  <b>Last modified:</b> 2008-06-02</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#valarray.cons">active issues</a> in [valarray.cons].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#valarray.cons">issues</a> in [valarray.cons].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
        <p>

Section 26.2 [numeric.requirements], p1     suggests     that     a
<code>valarray</code>  specialization on  a  type <code>T</code>  that
satisfies  the requirements enumerated  in the  paragraph is  itself a
valid  type   on  which  <code>valarray</code>   may  be  instantiated
(Footnote       269        makes       this       clear).        I.e.,
<code>valarray&lt;valarray&lt;T&gt;  &gt;</code> is  valid as  long as
<code>T</code>   is   valid.    However,  since   implementations   of
<code>valarray</code> are permitted to initialize storage allocated by
the class by  invoking the default ctor of  <code>T</code> followed by
the    copy    assignment    operator,   such    implementations    of
<code>valarray</code>   wouldn't  work  with   (perhaps  user-defined)
specializations of <code>valarray</code> whose assignment operator had
undefined behavior when the size of its argument didn't match the size
of <code>*this</code>.  By <i>"wouldn't work"</i> I mean that it would
be  impossible  to resize  such  an array  of  arrays  by calling  the
<code>resize()</code> member  function on it if the  function used the
copy  assignment operator  after constructing  all elements  using the
default  ctor (e.g.,  by invoking  <code>new  value_type[N]</code>) to
obtain default-initialized storage) as it's permitted to do.

        </p>
        <p>

Stated      more     generally,      the      problem     is      that
<code>valarray&lt;valarray&lt;T&gt;  &gt;::resize(size_t)</code> isn't
required or  guaranteed to have well-defined semantics  for every type
<code>T</code>     that      satisfies     all     requirements     in
26.2 [numeric.requirements].

        </p>
        <p>

I  believe  this  problem  was  introduced  by  the  adoption  of  the
resolution                outlined                in                <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/1996/N0857.asc">N0857</a>,
<i>Assignment  of  valarrays</i>,  from  1996.   The  copy  assignment
operator  of  the original  numerical  array  classes  proposed in  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/1993/N0280.pdf">N0280</a>,
as      well       as      the      one       proposed      in      <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/1993/N0308.asc">N0308</a>
(both  from 1993), had  well-defined semantics  for arrays  of unequal
size (the  latter explicitly  only when <code>*this</code>  was empty;
assignment of non empty arrays of unequal size was a runtime error).

        </p>
        <p>

The  justification for  the  change given  in  N0857 was the "loss  of
performance [deemed]  only significant  for very simple  operations on
small arrays or for architectures with very few registers."

        </p>
        <p>

Since tiny  arrays on a  limited subset of hardware  architectures are
likely  to  be  an   exceedingly  rare  case  (despite  the  continued
popularity of  x86) I  propose to revert  the resolution and  make the
behavior    of   all   <code>valarray</code>    assignment   operators
well-defined even  for non-conformal  arrays (i.e., arrays  of unequal
size).   I have implemented  this change  and measured  no significant
degradation  in performance in  the common  case (non-empty  arrays of
equal size).  I  have measured a 50% (and in  some cases even greater)
speedup  in the  case of  assignments to  empty arrays  versus calling
<code>resize()</code>  first followed  by  an invocation  of the  copy
assignment operator.

        </p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
If no proposed wording by June meeting, this issue should be closed NAD.
</blockquote>



<p><b>Proposed resolution:</b></p>
        <p>

Change 26.6.2.2 [valarray.assign], p1 as follows:

        </p>
        <blockquote>
            <p>
                <code>

valarray&lt;T&gt;&amp; operator=(const valarray&lt;T&gt;&amp;<ins> x</ins>);

                </code>
            </p>
            <p>

-1- Each element of the <code>*this</code> array is assigned the value
of  the  corresponding  element   of  the  argument  array.   <del>The
resulting behavior is undefined if </del><ins>When </ins>the length of
the  argument  array  is  not   equal  to  the  length  of  the  *this
array<del>.</del><ins>  resizes  <code>*this</code>  to make  the  two
arrays     the      same     length,     as      if     by     calling
<code>resize(x.size())</code>, before performing the assignment.</ins>

            </p>
        </blockquote>
        <p>

And  add a new  paragraph just  below paragraph  1 with  the following
text:

        </p>
        <blockquote>
            <p>

<ins>-2- <i>Postcondition</i>: <code>size() == x.size()</code>.</ins>

            </p>
        </blockquote>
        <p>

Also add the following paragraph to 26.6.2.2 [valarray.assign], immediately after p4:

        </p>
        <blockquote>
            <p>

<ins>-?- When the length,  <i><code>N</code></i> of the array referred
to by the  argument is not equal to  the length of <code>*this</code>,
the  operator resizes <code>*this</code>  to make  the two  arrays the
same  length, as if  by calling  <code>resize(<i>N</i>)</code>, before
performing the assignment.</ins>

            </p>
        </blockquote>

<p><i>[
pre-Sophia Antipolis, Martin adds the following compromise wording, but
prefers the original proposed resolution:
]</i></p>


<p>
Change 26.6.2.2 [valarray.assign], p1 as follows:
</p>

<blockquote>
<p>
 -1- <i>Requires:</i> <tt>size() == 0 || size() == x.size()</tt>.
</p>
<p>
 -2- <i>Effects:</i> If <tt>size() == 0</tt> calls <tt>x.resize(x.size())</tt> first.
     Each element of the <tt>*this</tt> array is assigned the value of the
     corresponding element of the argument array.
</p>
<p>
 -3- <i>Postcondition:</i> <tt>size() == x.size()</tt>.
</p>
</blockquote>

<p>
Add the following paragraph to 26.6.2.2 [valarray.assign], immediately after
p4:
</p>

<blockquote>
<p>
 -?- When <tt>size() == 0</tt> and the length, <tt>N</tt> of the array referred to by
     the argument is not equal to the length of <tt>*this</tt>, the operator
     resizes <tt>*this</tt> to make the two arrays the same length, as if by
     calling <tt>resize(N)</tt>, before performing the assignment. Otherwise,
     when <tt>size() &gt; 0</tt> and <tt>size() != N</tt>, the behavior is undefined.
</p>
</blockquote>



<p><i>[
Kona (2007): Gaby to propose wording for an alternative resolution in
which you can assign to a <tt>valarray</tt> of size 0, but not to any other
<tt>valarray</tt> whose size is unequal to the right hand side of the assignment.
]</i></p>





<hr>
<h3><a name="632"></a>632. Time complexity of size() for std::set</h3>
<p><b>Section:</b> 23.2 [container.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Lionel B <b>Opened:</b> 2007-02-01  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#container.requirements">active issues</a> in [container.requirements].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#container.requirements">issues</a> in [container.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
A recent news group discussion:
</p>
<blockquote>
<p>
Anyone know if the Standard has anything to say about the time complexity
of size() for std::set?   I need to access a set's size (/not/ to know if it is empty!) heavily
during an algorithm and was thus wondering whether I'd be better off
tracking the size "manually" or whether that'd be pointless.
</p>
<p>
That would be pointless. size() is O(1).
</p>
<p>
Nit: the standard says "should" have constant time. Implementations may take
license to do worse. I know that some do this for <tt>std::list&lt;&gt;</tt> as a part of
some trade-off with other operation.
</p>

<p>
I was aware of that, hence my reluctance to use size() for std::set.
</p>
<p>
However, this reason would not apply to <tt>std::set&lt;&gt;</tt> as far as I can see.
</p>
<p>
Ok, I guess the only option is to try it and see...
</p>
</blockquote>

<p>
If I have any recommendation to the C++ Standards Committee it is that
implementations must (not "should"!) document clearly[1], where known, the
time complexity of *all* container access operations.
</p>
<p>
[1] In my case (gcc 4.1.1) I can't swear that the time complexity of size()
for std::set is not documented... but if it is it's certainly well hidden
away.
</p>

<p><i>[
Kona (2007): This issue affects all the containers. We'd love to see a
paper dealing with the broad issue. We think that the complexity of the
<tt>size()</tt> member of every container -- except possibly <tt>list</tt> -- should be
O(1). Alan has volunteered to provide wording.
]</i></p>


<p><i>[
Bellevue:
]</i></p>


<blockquote>
Mandating O(1) size will not fly, too many implementations would be
invalidated. Alan to provide wording that toughens wording, but that
does not absolutely mandate O(1).
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We observed that the wording "should" (in note a) has no effect.
Howard prefers that O(1) size be mandated.
It is not clear that this issue can be resolved to everyone's satisfaction,
but Alan will provide wording nonetheless.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="635"></a>635. domain of <tt>allocator::address</tt></h3>
<p><b>Section:</b> X [allocator.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2007-02-08  <b>Last modified:</b> 2009-05-01</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#allocator.requirements">active issues</a> in [allocator.requirements].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#allocator.requirements">issues</a> in [allocator.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The table of allocator requirements in X [allocator.requirements] describes
<tt>allocator::address</tt> as:
</p>
<blockquote><pre>a.address(r)
a.address(s)
</pre></blockquote>
<p>
where <tt>r</tt> and <tt>s</tt> are described as:
</p>
<blockquote><p>
a value of type <tt>X::reference</tt> obtained by the expression <tt>*p</tt>. 
</p></blockquote>

<p>
and <tt>p</tt> is 
</p>

<blockquote><p>
a value of type <tt>X::pointer</tt>, obtained by calling <tt>a1.allocate</tt>, 
where <tt>a1 == a</tt>
</p></blockquote>

<p>
This all implies that to get the address of some value of type <tt>T</tt> that
value must have been allocated by this allocator or a copy of it.
</p>

<p>
However sometimes container code needs to compare the address of an external value of
type <tt>T</tt> with an internal value.  For example <tt>list::remove(const T&amp; t)</tt>
may want to compare the address of the external value <tt>t</tt> with that of a value
stored within the list.  Similarly <tt>vector</tt> or <tt>deque insert</tt> may
want to make similar comparisons (to check for self-referencing calls).
</p>

<p>
Mandating that <tt>allocator::address</tt> can only be called for values which the
allocator allocated seems overly restrictive.
</p>

<p><i>[
post San Francisco:
]</i></p>


<blockquote>
Pablo recommends NAD Editorial, solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2768.pdf">N2768</a>.
</blockquote>

<p><i>[
2009-04-28 Pablo adds:
]</i></p>


<blockquote>
Tentatively-ready NAD Editorial as fixed by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2768.pdf">N2768</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change X [allocator.requirements]:
</p>

<blockquote>
<p>
<tt>r</tt> : a value of type <tt>X::reference</tt> <del>obtained by the expression *p</del>.
</p>
<p>
<tt>s</tt> : a value of type <tt>X::const_reference</tt> <del>obtained by the 
expression <tt>*q</tt> or by conversion from a value <tt>r</tt></del>.
</p>
</blockquote>

<p><i>[
post Oxford:  This would be rendered NAD Editorial by acceptance of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2257.html">N2257</a>.
]</i></p>


<p><i>[
Kona (2007):  This issue is section 8 of N2387.  There was some discussion of it but
no resolution to this issue was recorded.  Moved to Open.
]</i></p>







<hr>
<h3><a name="644"></a>644. Possible typos in 'function' description</h3>
<p><b>Section:</b> 20.7.16.2 [func.wrap.func] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Bo Persson <b>Opened:</b> 2007-02-25  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#func.wrap.func">active issues</a> in [func.wrap.func].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#func.wrap.func">issues</a> in [func.wrap.func].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
20.7.16.2 [func.wrap.func]
</p>
<p>
The note in paragraph 2 refers to 'undefined void operators', while the
section declares a pair of operators returning bool.
</p>

<p><i>[
Post-Sophia Antipolis:
]</i></p>


<blockquote>
Changed from Pending WP to Open.  This issue was voted to WP at the same time the operators were
changed from private to deleted.  The two issues stepped on each other.  What do we want the return
type of these deleted functions to be?
</blockquote>

<p><i>[
2009-05-02 Daniel adds:
]</i></p>


<blockquote>
<p>
I suggest harmonizing this issue with similar classes. E.g. in
20.8.13.3 [util.smartptr.weak] <tt>bool</tt> return values for
</p>
<blockquote><pre>template &lt;class Y&gt; bool operator&lt;(weak_ptr&lt;Y&gt; const&amp;) const = delete;
template &lt;class Y&gt; bool operator&lt;=(weak_ptr&lt;Y&gt; const&amp;) const = delete;
template &lt;class Y&gt; bool operator&gt;(weak_ptr&lt;Y&gt; const&amp;) const = delete;
template &lt;class Y&gt; bool operator&gt;=(weak_ptr&lt;Y&gt; const&amp;) const = delete;
</pre></blockquote>

<p>
are used and basically all <em>newer</em> provided deleted copy assignment operators
of type <tt>X</tt> use the canonical return type <tt>X&amp;</tt> instead of <tt>void</tt>. Since the note
mentioned in the issue description has now already been changed to
</p>
<blockquote>
deleted overloads close possible hole in the type system
</blockquote>
<p>
it seems to be of even lesser need to perform the change. Therefore
I recommend declaring the issue as NAD.
</p>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We agree with Daniel's recommendation.
</p>
<p>
Move to NAD.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 20.7.16.2 [func.wrap.func]
</p>

<blockquote><pre>...
private:
   // 20.7.16.2 [func.wrap.func], undefined operators:
   template&lt;class Function2&gt; <del>bool</del> <ins>void</ins> operator==(const function&lt;Function2&gt;&amp;);
   template&lt;class Function2&gt; <del>bool</del> <ins>void</ins> operator!=(const function&lt;Function2&gt;&amp;);
};
</pre></blockquote>

<p>
Change 20.7.16.2 [func.wrap.func]
</p>

<blockquote><pre>template&lt;class Function2&gt; <del>bool</del> <ins>void</ins> operator==(const function&lt;Function2&gt;&amp;);
template&lt;class Function2&gt; <del>bool</del> <ins>void</ins> operator!=(const function&lt;Function2&gt;&amp;);
</pre></blockquote>





<hr>
<h3><a name="659"></a>659. istreambuf_iterator should have an operator-&gt;()</h3>
<p><b>Section:</b> 24.6.3 [istreambuf.iterator] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Niels Dekker <b>Opened:</b> 2007-03-25  <b>Last modified:</b> 2009-05-30</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#istreambuf.iterator">issues</a> in [istreambuf.iterator].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Greg Herlihy has clearly demonstrated that a user defined input
iterator should have an operator-&gt;(), even if its
value type is a built-in type (comp.std.c++, "Re: Should any iterator
have an operator-&gt;() in C++0x?", March 2007).  And as Howard
Hinnant remarked in the same thread that the input iterator
<tt>istreambuf_iterator</tt> doesn't have one, this must be a
defect!
</p>
<p>
Based on Greg's example, the following code demonstrates the issue:
</p><pre> #include &lt;iostream&gt; 
 #include &lt;fstream&gt;
 #include &lt;streambuf&gt; 

 typedef char C;
 int main ()
 {
   std::ifstream s("filename", std::ios::in);
   std::istreambuf_iterator&lt;char&gt; i(s);

   (*i).~C();  // This is well-formed...
   i-&gt;~C();  // ... so this should be supported!
 }
</pre>

<p>
Of course, operator-&gt; is also needed when the value_type of
istreambuf_iterator is a class.
</p>
<p>
The operator-&gt; could be implemented in various ways.  For instance,
by storing the current value inside the iterator, and returning its
address.  Or by returning a proxy, like operator_arrow_proxy, from
<a href="http://www.boost.org/boost/iterator/iterator_facade.hpp">http://www.boost.org/boost/iterator/iterator_facade.hpp</a>
</p>
<p>
I hope that the resolution of this issue will contribute to getting a
clear and consistent definition of iterator concepts.
</p>

<p><i>[
Kona (2007): The proposed resolution is inconsistent because the return
type of <tt>istreambuf_iterator::operator-&gt;()</tt> is specified to be <tt>pointer</tt>,
but the proposed text also states that "<tt>operator-&gt;</tt> may return a proxy."
]</i></p>


<p><i>[
Niels Dekker (mailed to Howard Hinnant):
]</i></p>

<blockquote>
<p>
The proposed resolution does
not seem inconsistent to me. <tt>istreambuf_iterator::operator-&gt;()</tt> should
have <tt>istreambuf_iterator::pointer</tt> as return type, and this return type
may in fact be a proxy.
</p>
<p>
AFAIK, the resolution of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#445">445</a> ("<tt>iterator_traits::reference</tt>
unspecified for some iterator categories") implies that for any iterator
class <tt>Iter</tt>, the return type of <tt>operator-&gt;()</tt> is <tt>Iter::pointer</tt>, by
definition.  I don't think <tt>Iter::pointer</tt> needs to be a raw pointer.
</p>
<p>
Still I wouldn't mind if the text "<tt>operator-&gt;</tt> may return a proxy" would
be removed from the resolution. I think it's up to the library
implementation, how to implement <tt>istreambuf_iterator::operator-&gt;()</tt>.  As
longs as it behaves as expected: <tt>i-&gt;m</tt> should have the same effect as
<tt>(*i).m</tt>. Even for an explicit destructor call, <tt>i-&gt;~C()</tt>.  The main issue
is just: <tt>istreambuf_iterator</tt> should have an <tt>operator-&gt;()</tt>!
</p>
</blockquote>

<p><i>[
2009-04-30 Alisdair adds:
]</i></p>


<blockquote>
Note that operator-&gt; is now a requirement in the <tt>InputIterator</tt> concept, so
this issue cannot be ignored or existing valid programs will break when
compiled with an 0x library.
</blockquote>

<p><i>[
2009-05-29 Alisdair adds:
]</i></p>


<blockquote>
<p>
I agree with the observation that in principle the type 'pointer' may be a
proxy, and the words highlighting this are redundant.
</p>
<p>
However, in the current draught <tt>pointer</tt> is required to be exactly '<tt>charT *</tt>'
by the derivation from <tt>std::iterator</tt>.  At a minimum, the 4th parameter of
this base class template should become unspecified.  That permits the
introduction of a proxy as a nested class in some further undocumented (not
even exposition-only) base.
</p>
<p>
It also permits the <tt>istream_iterator</tt> approach where the cached value is
stored in the iterator itself, and the iterator serves as its own proxy for
post-increment <tt>operator++</tt> - removing the need for the existing
exposition-only nested class <tt>proxy</tt>.
</p>
<p>
Note that the current <tt>proxy</tt> class also has exactly the right properties to
serve as the pointer <tt>proxy</tt> too.  This is likely to be a common case where an
<tt>InputIterator</tt> does not hold internal state but delegates to another class.
</p>
<p>
Proposed Resolution:
</p>
<p>
In addition to the current proposal:
</p>
<p>
24.6.3 [istreambuf.iterator]
</p>
<blockquote><pre>template&lt;class charT, class traits = char_traits&lt;charT&gt; &gt;
class istreambuf_iterator
  : public iterator&lt;input_iterator_tag, charT,
                    typename traits::off_type, <del>charT*</del> <ins><i>unspecified</i></ins>, charT&gt; {
</pre></blockquote>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Add to the synopsis in 24.6.3 [istreambuf.iterator]:
</p>

<blockquote><pre>charT operator*() const;
<ins>pointer operator-&gt;() const;</ins>
istreambuf_iterator&lt;charT,traits&gt;&amp; operator++();
</pre></blockquote>

<p>
Change 24.6.3 [istreambuf.iterator], p1:
</p>

<blockquote><p>
The class template <tt>istreambuf_iterator</tt> reads successive
characters from the <tt>streambuf</tt> for which it was constructed.
<tt>operator*</tt> provides access to the current input character, if
any. <ins><tt>operator-&gt;</tt> may return a proxy.</ins> Each time
<tt>operator++</tt> is evaluated, the iterator advances to the next
input character. If the end of stream is reached
(<tt>streambuf_type::sgetc()</tt> returns <tt>traits::eof()</tt>), the
iterator becomes equal to the end of stream iterator value. The default
constructor <tt>istreambuf_iterator()</tt> and the constructor
<tt>istreambuf_iterator(0)</tt> both construct an end of stream iterator
object suitable for use as an end-of-range.
</p></blockquote>







<hr>
<h3><a name="667"></a>667. <tt>money_get</tt>'s widened minus sign</h3>
<p><b>Section:</b> 22.4.6.1.2 [locale.money.get.virtuals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Thomas Plum <b>Opened:</b> 2007-04-16  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#locale.money.get.virtuals">active issues</a> in [locale.money.get.virtuals].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.money.get.virtuals">issues</a> in [locale.money.get.virtuals].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
22.4.6.1.2 [locale.money.get.virtuals], para 1 says:
</p>

<blockquote><p>
The result is returned as an integral value
stored in <tt>units</tt> or as a sequence of digits possibly preceded by a
minus sign (as produced by <tt>ct.widen(c)</tt> where <tt>c</tt> is '-' or in the range
from '0' through '9', inclusive) stored in <tt>digits</tt>.
</p></blockquote>

<p>
The following
objection has been raised:
</p>

<blockquote><p>
Some implementations interpret this to mean that a facet derived from
<tt>ctype&lt;wchar_t&gt;</tt> can provide its own member <tt>do_widen(char)</tt>
which produces e.g. <tt>L'@'</tt> for the "widened" minus sign, and that the
<tt>'@'</tt> symbol will appear in the resulting sequence of digits.  Other
implementations have assumed that one or more places in the standard permit the
implementation to "hard-wire" <tt>L'-'</tt> as the "widened" minus sign.  Are
both interpretations permissible, or only  one?
</p></blockquote>

<p>
[Plum ref _222612Y14]
</p>

<p>
Furthermore: if <tt>ct.widen('9')</tt> produces <tt>L'X'</tt> (a non-digit), does a
parse fail if a <tt>'9'</tt> appears in the subject string? [Plum ref _22263Y33]
</p>

<p><i>[
Kona (2007): Bill and Dietmar to provide proposed wording.
]</i></p>


<p><i>[
post Bellevue: Bill adds:
]</i></p>


<blockquote>
The Standard is clear that the minus sign stored in <tt>digits</tt> is <tt>ct.widen('-')</tt>.
The subject string must contain characters <tt>c</tt> in the set <tt>[-0123456789]</tt>
which are translated by <tt>ct.widen(c)</tt> calls before being stored in <tt>digits</tt>;
the widened characters are not relevant to the parsing of the subject string.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with Bill's comment above,
in line with the first of the interpretations offered in the issue.
Move to NAD.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="668"></a>668. <tt>money_get</tt>'s empty minus sign</h3>
<p><b>Section:</b> 22.4.6.1.2 [locale.money.get.virtuals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Thomas Plum <b>Opened:</b> 2007-04-16  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#locale.money.get.virtuals">active issues</a> in [locale.money.get.virtuals].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.money.get.virtuals">issues</a> in [locale.money.get.virtuals].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
22.4.6.1.2 [locale.money.get.virtuals], para 3 says:
</p>

<blockquote><p>
If <tt>pos</tt> or <tt>neg</tt> is empty, the sign component is
optional, and if no sign is detected, the result is given the sign
that corresponds to the source of the empty string.
</p></blockquote>

<p>
The following objection has been raised:
</p>

<blockquote><p>
A <tt>negative_sign</tt> of "" means "there is no
way to write a negative sign" not "any null sequence is a negative
sign, so it's always there when you look for it".
</p></blockquote>

<p>
[Plum ref _222612Y32]
</p>

<p><i>[
Kona (2007): Bill to provide proposed wording and interpretation of existing wording.
]</i></p>


<p>
Related to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#669">669</a>.
</p>

<p><i>[
2009-05-17 Howard adds:
]</i></p>


<blockquote>
<p>
I disagree that a <tt>negative_sign</tt> of "" means "there is no
way to
write a negative sign". The meaning requires the sentences of
22.4.6.1.2 [locale.money.get.virtuals] p3 following that quoted above
to be
taken into account:
</p>

<blockquote>
-3- ... If <tt>pos</tt> or <tt>neg</tt> is empty, the sign component is
optional, and if no sign is detected, the result is given the sign that
corresponds to the source of the empty string. Otherwise, the character
in the indicated position must match the first character of <tt>pos</tt>
or <tt>neg</tt>, and the result is given the corresponding sign. If the
first character of <tt>pos</tt> is equal to the first character of
<tt>neg</tt>, or if both strings are empty, the result is given a
positive sign.
</blockquote>

<p>
So a <tt>negative_sign</tt> of "" means "there is no way to write a
negative sign" only when <tt>positive_sign</tt> is also "".  However
when <tt>negative_sign</tt> is "" and <tt>postive_sign.size() &gt;
0</tt>, then one writes a negative value by not writing the
<tt>postive_sign</tt> in the position indicated by
<tt>money_base::sign</tt>.
For example:
</p>

<blockquote><pre>pattern = {symbol, sign, value, none}
positive_sign = "+"
negative_sign = ""
$123   // a negative value, using optional sign
$+123  // a positive value
$-123  // a parse error
</pre></blockquote>

<p>
And:
</p>

<blockquote><pre>pattern = {symbol, sign, value, none}
positive_sign = ""
negative_sign = ""
$123   // a positive value, no sign possible
$+123  // a parse error
$-123  // a parse error
</pre></blockquote>


<p>
And (regarding <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#669">669</a>):
</p>

<blockquote><pre>pattern = {symbol, sign, value, none}
positive_sign = "-"
negative_sign = "-"
$123   // a parse error, sign is mandatory
$+123  // a parse error
$-123  // a positive value
</pre></blockquote>


<p>
The text seems both unambiguous and clear to me.  I recommend NAD for
both this issue and <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#669">669</a>.  However I would have no
objection to adding examples such as those above.
</p>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
This discussion applies equally to issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#669">669</a> (q.v.).
Howard has added examples above,
and recommends either NAD or a resolution that adds his (or similar) examples
to the Working Paper.
</p>
<p>
Alan would like to rewrite paragraph 3.
</p>
<p>
We recommend moving to NAD.
Anyone who feels strongly about adding the examples
is invited to submit corresponding wording.
We further recommend issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#669">669</a> be handled identically.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="669"></a>669. Equivalent postive and negative signs in <tt>money_get</tt></h3>
<p><b>Section:</b> 22.4.6.1.2 [locale.money.get.virtuals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Thomas Plum <b>Opened:</b> 2007-04-16  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#locale.money.get.virtuals">active issues</a> in [locale.money.get.virtuals].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.money.get.virtuals">issues</a> in [locale.money.get.virtuals].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
22.4.6.1.2 [locale.money.get.virtuals], para 3 sentence 4 says:
</p>

<blockquote><p>
If the first character of <tt>pos</tt> is equal to the first character of <tt>neg</tt>, 
or if both strings are empty, the result is given a positive sign.
</p></blockquote>

<p>
One interpretation is that an input sequence must match either the
positive pattern or the negative pattern, and then in either event it
is interpreted as positive.  The following objections has been raised:
</p>

<blockquote><p>
The input can successfully match only a positive sign, so the negative
pattern is an unsuccessful match.
</p></blockquote>

<p>
[Plum ref _222612Y34, 222612Y51b]
</p>

<p><i>[
Bill to provide proposed wording and interpretation of existing wording.
]</i></p>


<p><i>[
2009-05-17 See Howard's comments in related issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#668">668</a>.
]</i></p>


<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
This discussion applies equally to issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#668">668</a> (q.v.).
Howard has added examples there,
and recommends either NAD or a resolution that adds his (or similar) examples
to the Working Paper.
</p>
<p>
We recommend moving to NAD.
Anyone who feels strongly about adding the examples
is invited to submit corresponding wording.
We further recommend issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#668">668</a> be handled identically.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="671"></a>671. precision of hexfloat</h3>
<p><b>Section:</b> 22.4.2.2.2 [facet.num.put.virtuals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> John Salmon <b>Opened:</b> 2007-04-20  <b>Last modified:</b> 2009-03-12</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#facet.num.put.virtuals">issues</a> in [facet.num.put.virtuals].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I am trying to understand how TR1 supports hex float (%a) output.
</p>
<p>
As far as I can tell, it does so via the following:
</p>
<p>
8.15 Additions to header &lt;locale&gt; [tr.c99.locale]
</p>
<p>
In subclause 22.4.2.2.2 [facet.num.put.virtuals], Table 58 Floating-point conversions, after
the line:
floatfield == ios_base::scientific %E
</p>
<p>
add the two lines:
</p>
<blockquote><pre>floatfield == ios_base::fixed | ios_base::scientific &amp;&amp; !uppercase %a
floatfield == ios_base::fixed | ios_base::scientific %A 2
</pre></blockquote>
<p>
[Note: The additional requirements on print and scan functions, later
in this clause, ensure that the print functions generate hexadecimal
floating-point fields with a %a or %A conversion specifier, and that
the scan functions match hexadecimal floating-point fields with a %g
conversion specifier.  end note]
</p>
<p>
Following the thread, in 22.4.2.2.2 [facet.num.put.virtuals], we find:
</p>
<p>
For conversion from a floating-point type, if (flags &amp; fixed) != 0 or
if str.precision() &gt; 0, then str.precision() is specified in the
conversion specification.
</p>
<p>
This would seem to imply that when floatfield == fixed|scientific, the
precision of the conversion specifier is to be taken from
str.precision().  Is this really what's intended?  I sincerely hope
that I'm either missing something or this is an oversight.  Please
tell me that the committee did not intend to mandate that hex floats
(and doubles) should by default be printed as if by %.6a.
</p>

<p><i>[
Howard: I think the fundamental issue we overlooked was that with %f,
%e, %g, the default precision was always 6.  With %a the default
precision is not 6, it is infinity.  So for the first time, we need to
distinguish between the default value of precision, and the precision
value 6.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
</p>


<p><i>[
Kona (2007): Robert volunteers to propose wording.
]</i></p>





<hr>
<h3><a name="688"></a>688. reference_wrapper, cref unsafe, allow binding to rvalues</h3>
<p><b>Section:</b> 20.7.5.1 [refwrap.const] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Peter Dimov <b>Opened:</b> 2007-05-10  <b>Last modified:</b> 2009-05-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#refwrap.const">issues</a> in [refwrap.const].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
A <tt>reference_wrapper</tt> can be constructed from an rvalue, either by using
the constructor, or via <tt>cref</tt> (and <tt>ref</tt> in some corner cases). This leads
to a dangling reference being stored into the <tt>reference_wrapper</tt> object.
Now that we have a mechanism to detect an rvalue, we can fix them to
disallow this source of undefined behavior.
</p>

<p>
Also please see the thread starting at c++std-lib-17398 for some good discussion on this subject.
</p>

<p><i>[
2009-05-09 Alisdair adds:
]</i></p>


<blockquote>
<p>
Now that <tt>ref/cref</tt> are constained that <tt>T</tt> must be an <tt>ObjectType</tt>, I do not
believe there is any risk of binding <tt>ref</tt> to a temporary (which would rely on
deducing <tt>T</tt> to be an rvalue reference type)
</p>
<p>
However, the problem for <tt>cref</tt> remains, so I recommend retaining that deleted
overload.
</p>
</blockquote>

<p><i>[
2009-05-10 Howard adds:
]</i></p>


<blockquote>
<p>
Without:
</p>

<blockquote><pre>template &lt;class T&gt; void ref(const T&amp;&amp; t) = delete;
</pre></blockquote>
<p>
I believe this program will compile:
</p>

<blockquote><pre>#include &lt;functional&gt;

struct A {};

const A source() {return A();}

int main()
{
   std::reference_wrapper&lt;const A&gt; r = std::ref(source());
}
</pre></blockquote>
<p>
I.e. in:
</p>
<blockquote><pre>template &lt;ObjectType T&gt; reference_wrapper&lt;T&gt; ref(T&amp; t);
</pre></blockquote>

<p>
this:
</p>

<blockquote><pre>ref(source())
</pre></blockquote>
<p>
deduces <tt>T</tt> as <tt>const A</tt>, and so:
</p>

<blockquote><pre>ref(const A&amp; t)
</pre></blockquote>

<p>
will bind to a temporary (tested with a pre-concepts rvalue-ref enabled compiler).
</p>
<p>
Therefore I think we still need the ref-protection.  I respectfully disagree with Alisdair's
comment and am in favor of the proposed wording as it stands.  Also, CWG 606
(noted below) has now been "favorably" resolved.
</p>

</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution.
Move to Tentatively Ready.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
In 20.7 [function.objects], add the following two signatures to the synopsis:
</p>

<blockquote><pre>template &lt;class T&gt; void ref(const T&amp;&amp; t) = delete;
template &lt;class T&gt; void cref(const T&amp;&amp; t) = delete;
</pre></blockquote>



<p><i>[
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2292.html">N2292</a>
addresses the first part of the resolution but not the second.
]</i></p>


<p><i>[
Bellevue:  Doug noticed problems with the current wording.
]</i></p>


<p><i>[
post Bellevue:  Howard and Peter provided revised wording.
]</i></p>


<p><i>[
This resolution depends on a "favorable" resolution of CWG 606:  that is,
the "special deduction rule" is disabled with the const T&amp;&amp; pattern.
]</i></p>





<hr>
<h3><a name="696"></a>696. <code>istream::operator&gt;&gt;(int&amp;)</code> broken</h3>
<p><b>Section:</b> 27.7.1.2.2 [istream.formatted.arithmetic] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2007-06-23  <b>Last modified:</b> 2009-05-28</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#istream.formatted.arithmetic">issues</a> in [istream.formatted.arithmetic].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
From message c++std-lib-17897:
</p>
<p>
The code shown in 27.7.1.2.2 [istream.formatted.arithmetic] as the "as if"
implementation of the two arithmetic extractors that don't have a
corresponding <code>num_get</code> interface (i.e., the
<code>short</code> and <code>int</code> overloads) is subtly buggy in
how it deals with <code>EOF</code>, overflow, and other similar
conditions (in addition to containing a few typos).
</p>
<p>
One problem is that if <code>num_get::get()</code> reaches the EOF
after reading in an otherwise valid value that exceeds the limits of
the narrower type (but not <code>LONG_MIN</code> or
<code>LONG_MAX</code>), it will set <code><i>err</i></code> to
<code>eofbit</code>. Because of the if condition testing for
<code>(<i>err</i> == 0)</code>, the extractor won't set
<code>failbit</code> (and presumably, return a bogus value to the
caller).
</p>
<p>
Another problem with the code is that it never actually sets the
argument to the extracted value. It can't happen after the call to
<code>setstate()</code> since the function may throw, so we need to
show when and how it's done (we can't just punt as say: "it happens
afterwards"). However, it turns out that showing how it's done isn't
quite so easy since the argument is normally left unchanged by the
facet on error except when the error is due to a misplaced thousands
separator, which causes <code>failbit</code> to be set but doesn't
prevent the facet from storing the value.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We believe this part of the Standard has been recently adjusted
and that this issue was addressed during that rewrite.
</p>
<p>
Move to NAD.
</p>
</blockquote>

<p><i>[
2009-05-28 Howard adds:
]</i></p>


<blockquote>
<p>
I've moved this issue from Tentatively NAD to Open.
</p>

<p>
The current wording of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2857.pdf">N2857</a>
in 22.4.2.1.2 [facet.num.get.virtuals] p3, stage 3 appears to indicate that
in parsing arithmetic types, the value is always set, but sometimes in addition
to setting <tt>failbit</tt>.
</p>

<ul>
<li>
If there is a range error, the value is set to min or max, else
</li>
<li>
if there is a conversion error, the value is set to 0, else
</li>
<li>
if there is a grouping error, the value is set to whatever it would be if grouping were ignored, else
</li>
<li>
the value is set to its error-free result.
</li>
</ul>

<p>
However there is a contradictory sentence in 22.4.2.1.2 [facet.num.get.virtuals] p1.
</p>

<p>
27.7.1.2.2 [istream.formatted.arithmetic] should mimic the behavior of 22.4.2.1.2 [facet.num.get.virtuals]
(whatever we decide that behavior is) for
<tt>int</tt> and <tt>short</tt>, and currently does not.  I believe that the
correct code fragment should look like:
</p>

<blockquote><pre>typedef num_get&lt;charT,istreambuf_iterator&lt;charT,traits&gt; &gt; numget;
iostate err = ios_base::goodbit;
long lval;
use_facet&lt;numget&gt;(loc).get(*this, 0, *this, err, lval);
if (lval &lt; numeric_limits&lt;int&gt;::min())
{
  err |= ios_base::failbit;
  val = numeric_limits&lt;int&gt;::min();
}
else if (lval &gt; numeric_limits&lt;int&gt;::max())
{
  err |= ios_base::failbit;
  val = numeric_limits&lt;int&gt;::max();
}
else
  val = static_cast&lt;int&gt;(lval);
setstate(err);
</pre></blockquote>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 22.4.2.1.2 [facet.num.get.virtuals], p1:
</p>

<blockquote>
-1- <i>Effects:</i> Reads characters from <tt>in</tt>, interpreting them
according to <tt>str.flags()</tt>, <tt>use_facet&lt;ctype&lt;charT&gt;
&gt;(loc)</tt>, and <tt>use_facet&lt; numpunct&lt;charT&gt;
&gt;(loc)</tt>, where <tt>loc</tt> is <tt>str.getloc()</tt>. <del>If an error
occurs, <tt>val</tt> is unchanged; otherwise it is set to the resulting value.</del>
</blockquote>

<p>
Change 27.7.1.2.2 [istream.formatted.arithmetic], p2 and p3:
</p>

<blockquote>
<pre>operator&gt;&gt;(short&amp; val);
</pre>
<blockquote>
<p>
-2- The conversion occurs as if performed by the following code fragment (using the same notation as for 
the preceding code fragment):
</p>

<blockquote><pre>typedef num_get&lt;charT,istreambuf_iterator&lt;charT,traits&gt; &gt; numget;
iostate err = ios<del>tate</del><ins>_base</ins>::goodbit;
long lval;
use_facet&lt;numget&gt;(loc).get(*this, 0, *this, err, lval);
<del>if (err != 0)
  ;
else if (lval &lt; numeric_limits&lt;short&gt;::min()
  || numeric_limits&lt;short&gt;::max() &lt; lval)
     err = ios_base::failbit;</del>
<ins>if (lval &lt; numeric_limits&lt;short&gt;::min())
{
  err |= ios_base::failbit;
  val = numeric_limits&lt;short&gt;::min();
}
else if (lval &gt; numeric_limits&lt;short&gt;::max())
{
  err |= ios_base::failbit;
  val = numeric_limits&lt;short&gt;::max();
}</ins>
else
  val = static_cast&lt;short&gt;(lval);
setstate(err);
</pre></blockquote>

</blockquote>

<pre>operator&gt;&gt;(int&amp; val);
</pre>
<blockquote>
<p>
-3- The conversion occurs as if performed by the following code fragment (using the same notation as for 
the preceding code fragment):
</p>

<blockquote><pre>typedef num_get&lt;charT,istreambuf_iterator&lt;charT,traits&gt; &gt; numget;
iostate err = ios<del>tate</del><ins>_base</ins>::goodbit;
long lval;
use_facet&lt;numget&gt;(loc).get(*this, 0, *this, err, lval);
<del>if (err != 0)
  ;
else if (lval &lt; numeric_limits&lt;int&gt;::min()
  || numeric_limits&lt;int&gt;::max() &lt; lval)
     err = ios_base::failbit;</del>
<ins>if (lval &lt; numeric_limits&lt;int&gt;::min())
{
  err |= ios_base::failbit;
  val = numeric_limits&lt;int&gt;::min();
}
else if (lval &gt; numeric_limits&lt;int&gt;::max())
{
  err |= ios_base::failbit;
  val = numeric_limits&lt;int&gt;::max();
}</ins>
else
  val = static_cast&lt;int&gt;(lval);
setstate(err);
</pre></blockquote>

</blockquote>

</blockquote>





<hr>
<h3><a name="701"></a>701. assoc laguerre poly's</h3>
<p><b>Section:</b> TR1 5.2.1.1 [tr.num.sf.Lnm] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Christopher Crawford <b>Opened:</b> 2007-06-30  <b>Last modified:</b> 2009-05-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I see that the definition the associated Laguerre
polynomials TR1 5.2.1.1 [tr.num.sf.Lnm] has been corrected since
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1687.pdf">N1687</a>.
However, the draft standard only specifies ranks of integer value <tt>m</tt>,
while the associated Laguerre polynomials are actually valid for real
values of <tt>m &gt; -1</tt>.  In the case of non-integer values of <tt>m</tt>, the
definition  <tt><i>L</i><sub>n</sub><sup>(m)</sup> = (1/n!)e<sup>x</sup>x<sup>-m</sup> (d/dx)<sup>n</sup> (e<sup>-x</sup>x<sup>m+n</sup>)</tt>
must be used, which also holds for integer values of <tt>m</tt>.  See
Abramowitz &amp; Stegun, 22.11.6 for the general case, and 22.5.16-17 for
the integer case.  In fact fractional values are most commonly used in
physics, for example to <tt>m = +/- 1/2</tt> to describe the harmonic
oscillator in 1 dimension, and <tt>1/2, 3/2, 5/2, ...</tt> in 3
dimensions.
</p>
<p>
If I am correct, the calculation of the more general case is no
more difficult, and is in fact the function implemented in the GNU
Scientific Library.  I would urge you to consider upgrading the 
standard, either adding extra functions for real <tt>m</tt> or switching the
current ones to <tt>double</tt>.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We understand the issue, and have opted not to extend as recommended.
</p>
<p>
Move to NAD.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="702"></a>702. Restriction in associated Legendre functions</h3>
<p><b>Section:</b> TR1 5.2.1.2 [tr.num.sf.Plm] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Christopher Crawford <b>Opened:</b> 2007-06-30  <b>Last modified:</b> 2009-05-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
One other small thing, in TR1 5.2.1.2 [tr.num.sf.Plm], the restriction should  be
<tt>|x| &lt;= 1</tt>, not <tt>x &gt;= 0</tt>.</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
The error has been corrected in the pending IS.
</p>
<p>
Move to NAD.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="708"></a>708. Locales need to be per thread and updated for POSIX changes</h3>
<p><b>Section:</b> 22 [localization] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Peter Dimov <b>Opened:</b> 2007-07-28  <b>Last modified:</b> 2008-09-17</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#localization">active issues</a> in [localization].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#localization">issues</a> in [localization].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The POSIX "Extended API Set Part 4,"
</p>
<blockquote><p>
<a href="http://www.opengroup.org/sib/details.tpl?id=C065">http://www.opengroup.org/sib/details.tpl?id=C065</a>
</p></blockquote>
<p>
introduces extensions to the C locale mechanism that
allow multiple concurrent locales to be used in the same application
by introducing a type <tt>locale_t</tt> that is very similar to
<tt>std::locale</tt>, and a number of <tt>_l</tt> functions that make use of it.
</p>
<p>
The global locale (set by setlocale) is now specified to be per-
process. If a thread does not call <tt>uselocale</tt>, the global locale is
in effect for that thread. It can install a per-thread locale by
using <tt>uselocale</tt>.
</p>
<p>
There is also a nice <tt>querylocale</tt> mechanism by which one can obtain
the name (such as "de_DE") for a specific <tt>facet</tt>, even for combined
locales, with no <tt>std::locale</tt> equivalent.
</p>
<p>
<tt>std::locale</tt> should be harmonized with the new POSIX <tt>locale_t</tt>
mechanism and provide equivalents for <tt>uselocale</tt> and <tt>querylocale</tt>.
</p>

<p><i>[
Kona (2007): Bill and Nick to provide wording.
]</i></p>


<p><i>[
San Francisco: Bill and Nick still intend to provide wording, but this
is a part of the task to be addressed by the group that will look into
issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#860">860</a>.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="711"></a>711. Contradiction in empty <tt>shared_ptr</tt></h3>
<p><b>Section:</b> 20.8.13.2.5 [util.smartptr.shared.obs] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Peter Dimov <b>Opened:</b> 2007-08-24  <b>Last modified:</b> 2008-06-18</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#util.smartptr.shared.obs">issues</a> in [util.smartptr.shared.obs].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
A discussion on
<a href="http://groups.google.com/group/comp.std.c++/browse_frm/thread/8e89dceb35cd7971">comp.std.c++</a>
has identified a contradiction in the <tt>shared_ptr</tt> specification.
The note:
</p>

<blockquote><p>
[ <i>Note:</i> this constructor allows creation of an empty shared_ptr instance with a non-NULL stored pointer.
-end note ]
</p></blockquote>

<p>
after the aliasing constructor
</p>

<blockquote><pre>template&lt;class Y&gt; shared_ptr(shared_ptr&lt;Y&gt; const&amp; r, T *p);
</pre></blockquote>

<p>
reflects the intent of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2351.htm">N2351</a>
to, well, allow the creation of an empty <tt>shared_ptr</tt>
with a non-NULL stored pointer.
</p>

<p>
This is contradicted by the second sentence in the Returns clause of 20.8.13.2.5 [util.smartptr.shared.obs]:
</p>

<blockquote>
<pre>T* get() const;
</pre>
<blockquote><p>
<i>Returns:</i> the stored pointer. Returns a null pointer if <tt>*this</tt> is empty.
</p></blockquote>
</blockquote>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
<p>
Adopt option 1 and move to review, not ready.
</p>
<p>
There was a lot of confusion about what an empty <tt>shared_ptr</tt> is (the term
isn't defined anywhere), and whether we have a good mental model for how
one behaves. We think it might be possible to deduce what the definition
should be, but the words just aren't there. We need to open an issue on
the use of this undefined term. (The resolution of that issue might
affect the resolution of issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#711">711</a>.)
</p>
<p>
The LWG is getting more uncomfortable with the aliasing proposal (N2351)
now that we realize some of its implications, and we need to keep an eye
on it, but there isn't support for removing this feature at this time.
</p>
</blockquote>

<p><i>[
Sophia Antipolis:
]</i></p>


<blockquote>
<p>
We heard from Peter Dimov, who explained his reason for preferring solution 1.
</p>
<p>
Because it doesn't seem to add anything. It simply makes the behavior
for p = 0 undefined. For programmers who don't create empty pointers
with p = 0, there is no difference. Those who do insist on creating them
presumably have a good reason, and it costs nothing for us to define the
behavior in this case.
</p>
<p>
The aliasing constructor is sharp enough as it is, so "protecting" users
doesn't make much sense in this particular case.
</p>
<p>
&gt; Do you have a use case for r being empty and r being non-null? 
</p>
<p>
I have received a few requests for it from "performance-conscious"
people (you should be familiar with this mindset) who don't like the
overhead of allocating and maintaining a control block when a null
deleter is used to approximate a raw pointer. It is obviously an "at
your own risk", low-level feature; essentially a raw pointer behind a
shared_ptr facade.
</p>
<p>
We could not agree upon a resolution to the issue; some of us thought
that Peter's description above is supporting an undesirable behavior.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
In keeping the N2351 spirit and obviously my preference, change 20.8.13.2.5 [util.smartptr.shared.obs]:
</p>

<blockquote>
<pre>T* get() const;
</pre>
<blockquote><p>
<i>Returns:</i> the stored pointer. <del>Returns a null pointer if <tt>*this</tt> is empty.</del>
</p></blockquote>
</blockquote>

<p>
Alternative proposed resolution: (I won't be happy if we do this, but it's possible):
</p>

<p>
Change 20.8.13.2.1 [util.smartptr.shared.const]:
</p>

<blockquote>
<pre>template&lt;class Y&gt; shared_ptr(shared_ptr&lt;Y&gt; const&amp; r, T *p);
</pre>
<blockquote>
<p>
<ins><i>Requires:</i> If <tt>r</tt> is empty, <tt>p</tt> shall be <tt>0</tt>.</ins>
</p>
<p>
<del>[ <i>Note:</i> this constructor allows creation of an empty <tt>shared_ptr</tt>
instance with a non-NULL stored pointer. 
-- <i>end note</i> ]</del>
</p>
</blockquote>
</blockquote>






<hr>
<h3><a name="716"></a>716. Production in [re.grammar] not actually modified</h3>
<p><b>Section:</b> 28.14 [re.grammar] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2007-08-31  <b>Last modified:</b> 2009-05-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
TR1 7.13 [tr.re.grammar]/3 and C++0x WP 28.14 [re.grammar]/3 say:
</p>

<blockquote>
<p>
The following productions within the ECMAScript grammar are modified as follows:
</p>

<blockquote><pre>CharacterClass ::
[ [lookahead &#8713; {^}] ClassRanges ]
[ ^ ClassRanges ]
</pre></blockquote>

</blockquote>

<p>
This definition for <tt>CharacterClass</tt> appears to be exactly identical to that in ECMA-262.
</p>

<p>
Was an actual modification intended here and accidentally omitted, or was this production accidentally included?
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We agree that what is specified is identical to what ECMA-262 specifies.
Pete would like to take a bit of time to assess whether we had intended,
but failed, to make a change.
It would also be useful to hear from John Maddock on the issue.
</p>
<p>
Move to Open.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Remove this mention of the CharacterClass production.
</p>

<blockquote><pre><del>CharacterClass ::
[ [lookahead &#8713; {^}] ClassRanges ]
[ ^ ClassRanges ]</del>
</pre></blockquote>






<hr>
<h3><a name="718"></a>718. <tt>basic_string</tt> is not a sequence</h3>
<p><b>Section:</b> 21.4 [basic.string] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Bo Persson <b>Opened:</b> 2007-08-18  <b>Last modified:</b> 2008-03-12</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#basic.string">active issues</a> in [basic.string].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#basic.string">issues</a> in [basic.string].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Paragraph 21.4 [basic.string]/3 states:
</p>

<blockquote>
<p>
The class template <tt>basic_string</tt> conforms to the requirements for a 
Sequence (23.1.1) and for a Reversible Container (23.1).
</p>
</blockquote>

<p>
First of all, 23.2.3 [sequence.reqmts] is no longer "Sequence" but "Sequence container". 
Secondly, after the resent changes to containers (<tt>emplace</tt>, <tt>push_back</tt>, 
<tt>const_iterator</tt> parameters to <tt>insert</tt> and <tt>erase</tt>), <tt>basic_string</tt> is not 
even close to conform to the current requirements.
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
<ul>
<li>emplace, for example, may not make sense for strings. Is also likely suboptimal</li>
<li>with concepts do we need to maintain string as sequence container?</li>
<li>One approach might be to say something like: string is a sequence except it doesn't have these functions</li>
</ul>
<ul>
<li>basic_string already has push_back</li>
<li>const_iterator parameters to insert and erase should be added to basic_string</li>
<li>this leaves emplace to handle -- we have the following options:
<ul>
<li>option 1: add it to string even though it's optional</li>
<li>option 2: make emplace optional to sequences (move from table 89 to 90)</li>
<li>option 3: say string not sequence (the proposal),</li>
<li>option 4: add an exception to basic string wording.</li>
</ul>
</li>
</ul>
General consensus is to suggest option 2.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Remove this sentence, in recognition of the fact that <tt>basic_string</tt> is 
not just a <tt>vector</tt>-light for literal types, but something quite 
different, a string abstraction in its own right.
</p>





<hr>
<h3><a name="719"></a>719. <tt>std::is_literal</tt> type traits should be provided</h3>
<p><b>Section:</b> 20.6 [meta] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2007-08-25  <b>Last modified:</b> 2009-03-14</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#meta">active issues</a> in [meta].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#meta">issues</a> in [meta].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Since the inclusion of <tt>constexpr</tt> in the standard draft N2369 we have
a new type category "literal", which is defined in 3.9 [basic.types]/p.11:
</p>

<blockquote>
<p>
-11- A type is a <i>literal</i> type if it is:
</p>
<ul>
<li>a scalar type; or</li>
<li><p>a class type (clause 9) with</p>
<ul>
<li>a trivial copy constructor,</li>
<li>a trivial destructor,</li>
<li>at least one constexpr constructor other than the copy constructor,</li>
<li>no virtual base classes, and</li>
<li>all non-static data members and base classes of literal types; or</li>
</ul>
</li>
<li>an array of literal type.</li>
</ul>
</blockquote>

<p>
I strongly suggest that the standard provides a type traits for
literal types in 20.6.4.3 [meta.unary.prop] for several reasons:
</p>

<ol type="a">
<li>To keep the traits in sync with existing types.</li>
<li>I see many reasons for programmers to use this trait in template
   code to provide optimized template definitions for these types,
   see below.</li>
<li>A user-provided definition of this trait is practically impossible
to write portably.</li>
</ol>

<p>
The special problem of reason (c) is that I don't see currently a
way to portably test the condition for literal class types:
</p>

<blockquote>
<ul>
<li>at least one constexpr constructor other than the copy constructor,</li>
</ul>
</blockquote>



<p><i>[
Alisdair is considering preparing a paper listing a number of missing
type traits, and feels that it might be useful to handle them all
together rather than piecemeal. This would affect issue 719 and 750.
These two issues should move to OPEN pending AM paper on type traits.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
In 20.6.2 [meta.type.synop] in the group "type properties",
just below the line
</p>

<blockquote><pre>template &lt;class T&gt; struct is_pod;
</pre></blockquote>

<p>
add a new one:
</p>

<blockquote><pre>template &lt;class T&gt; struct is_literal;
</pre></blockquote>

<p>
In 20.6.4.3 [meta.unary.prop], table Type Property Predicates, just
below the line for the <tt>is_pod</tt> property add a new line:
</p>

<table border="1">
<tbody><tr>
<th>Template</th><th>Condition</th><th>Preconditions</th>
</tr>
<tr>
<td><tt>template &lt;class T&gt; struct is_literal;</tt></td>
<td><tt>T</tt> is a literal type (3.9)</td>
<td><tt>T</tt> shall be a complete type, an
array of unknown bound, or
(possibly cv-qualified) <tt>void</tt>.</td>
</tr>
</tbody></table>






<hr>
<h3><a name="721"></a>721. <tt>wstring_convert</tt> inconsistensies</h3>
<p><b>Section:</b> 22.3.3.2.2 [conversions.string] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Bo Persson <b>Opened:</b> 2007-08-27  <b>Last modified:</b> 2008-09-18</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#conversions.string">active issues</a> in [conversions.string].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#conversions.string">issues</a> in [conversions.string].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Paragraph 3 says that the <tt>Codecvt</tt> template parameter shall meet the 
requirements of <tt>std::codecvt</tt>, even though <tt>std::codecvt</tt> itself cannot 
be used (because of a protected destructor).
</p>

<p>
How are we going to explain this code to beginning programmers?
</p>

<blockquote><pre>template&lt;class I, class E, class S&gt;
struct codecvt : std::codecvt&lt;I, E, S&gt;
{
    ~codecvt()
    { }
};

void main()
{
    std::wstring_convert&lt;codecvt&lt;wchar_t, char, std::mbstate_t&gt; &gt; compiles_ok;
    
    std::wstring_convert&lt;std::codecvt&lt;wchar_t, char, std::mbstate_t&gt; &gt;   not_ok;
}
</pre></blockquote>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
Bill will propose a resolution.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="723"></a>723. <tt>basic_regex</tt> should be moveable</h3>
<p><b>Section:</b> 28.9 [re.regex] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2007-08-29  <b>Last modified:</b> 2009-03-13</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#re.regex">issues</a> in [re.regex].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 316</b></p>

<p>
According to the current state of the standard draft, the class
template <tt>basic_regex</tt>, as described in 28.9 [re.regex]/3, is
neither <tt>MoveConstructible</tt> nor <tt>MoveAssignable</tt>.
IMO it should be, because typical regex state machines tend
to have a rather large data quantum and I have seen several
use cases, where a factory function returns regex values,
which would take advantage of moveabilities.
</p>

<p><i>[
Sophia Antipolis:
]</i></p>


<blockquote>
Needs wording for the semantics, the idea is agreed upon.
</blockquote>

<p><i>[
Post Summit Daniel updated wording to reflect new "swap rules".
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
In the class definition of <tt>basic_regex</tt>, just below 28.9 [re.regex]/3,
perform the following changes:
</p>

<ol type="a">
<li>
<p>
Just after <tt>basic_regex(const basic_regex&amp;);</tt> insert:
</p>

<blockquote><pre>basic_regex(basic_regex&amp;&amp;);
</pre></blockquote>
</li>
<li>
<p>
Just after <tt>basic_regex&amp; operator=(const basic_regex&amp;);</tt> insert:
</p>
<blockquote><pre>basic_regex&amp; operator=(basic_regex&amp;&amp;);
</pre></blockquote>
</li>
<li>
<p>
Just after <tt>basic_regex&amp; assign(const basic_regex&amp; that);</tt> insert:
</p>
<blockquote><pre>basic_regex&amp; assign(basic_regex&amp;&amp; that);
</pre></blockquote>
</li>
<li>
<p>
In 28.9.2 [re.regex.construct], just after p.11 add the following
new member definition:
</p>
<blockquote><pre>basic_regex(basic_regex&amp;&amp; e);
</pre>
<blockquote>
<p>
<i>Effects:</i> Move-constructs a <tt>basic_regex</tt> instance from <tt>e</tt>.
</p>
<p>
<i>Postconditions:</i> <tt>flags()</tt> and <tt>mark_count()</tt> return <tt>e.flags()</tt> and
<tt>e.mark_count()</tt>, respectively,
that <tt>e</tt> had before construction, leaving
<tt>e</tt> in a valid state with an unspecified value.
</p>
<p>
<i>Throws:</i> nothing.
</p>
</blockquote>
</blockquote>
</li>
<li>
<p>
Also in 28.9.2 [re.regex.construct], just after p.18 add the
following new member definition:
</p>

<blockquote><pre>basic_regex&amp; operator=(basic_regex&amp;&amp; e);
</pre>
<blockquote>
<i>Effects:</i> Returns the result of <tt>assign(std::move(e))</tt>.
</blockquote>
</blockquote>
</li>
<li>
<p>
In 28.9.3 [re.regex.assign], just after p. 2 add the following new
member definition:
</p>
<blockquote><pre>basic_regex&amp; assign(basic_regex&amp;&amp; rhs);
</pre>
<blockquote>
<p>
<i>Effects:</i> Move-assigns a <tt>basic_regex</tt> instance from <tt>rhs</tt> and returns <tt>*this</tt>.
</p>
<p>
<i>Postconditions:</i> <tt>flags()</tt> and <tt>mark_count()</tt> return <tt>rhs.flags()</tt>
and <tt>rhs.mark_count()</tt>, respectively, that
<tt>rhs</tt> had before assignment, leaving <tt>rhs</tt>
in a valid state with an unspecified value.
</p>
<p>
<i>Throws:</i> nothing.
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="726"></a>726. Missing <tt>regex_replace()</tt> overloads</h3>
<p><b>Section:</b> 28.12.4 [re.alg.replace] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2007-09-22  <b>Last modified:</b> 2008-06-18</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#re.alg.replace">active issues</a> in [re.alg.replace].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#re.alg.replace">issues</a> in [re.alg.replace].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Two overloads of <tt>regex_replace()</tt> are currently provided:
</p>

<blockquote><pre>template &lt;class OutputIterator, class BidirectionalIterator, 
    class traits, class charT&gt; 
  OutputIterator 
  regex_replace(OutputIterator out, 
                BidirectionalIterator first, BidirectionalIterator last, 
                const basic_regex&lt;charT, traits&gt;&amp; e, 
                const basic_string&lt;charT&gt;&amp; fmt, 
                regex_constants::match_flag_type flags = 
                  regex_constants::match_default);
 
template &lt;class traits, class charT&gt; 
  basic_string&lt;charT&gt; 
  regex_replace(const basic_string&lt;charT&gt;&amp; s, 
                const basic_regex&lt;charT, traits&gt;&amp; e, 
                const basic_string&lt;charT&gt;&amp; fmt, 
                regex_constants::match_flag_type flags = 
                  regex_constants::match_default);
</pre></blockquote>

<ol>
<li>Overloads taking <tt>const charT *</tt> are provided for <tt>regex_match()</tt> and
<tt>regex_search()</tt>, but not <tt>regex_replace()</tt>.  This is inconsistent.</li>
<li>
<p>The absence of <tt>const charT *</tt> overloads prevents ordinary-looking code from compiling, such as:</p>

<blockquote><pre>const string s("kitten");
const regex r("en");
cout &lt;&lt; regex_replace(s, r, "y") &lt;&lt; endl;
</pre></blockquote>

<p>
The compiler error message will be something like "could not deduce
template argument for 'const std::basic_string&lt;_Elem&gt; &amp;' from 'const
char[1]'".
</p>

<p>
Users expect that anything taking a <tt>basic_string&lt;charT&gt;</tt> can also take a
<tt>const charT *</tt>.  In their own code, when they write a function taking
<tt>std::string</tt> (or <tt>std::wstring</tt>), they can pass a <tt>const char *</tt> (or <tt>const
wchar_t *</tt>), thanks to <tt>basic_string</tt>'s implicit constructor.  Because the
regex algorithms are templated on <tt>charT</tt>, they can't rely on
<tt>basic_string</tt>'s implicit constructor (as the compiler error message
indicates, template argument deduction fails first).
</p>

<p>
If a user figures out what the compiler error message means, workarounds
are available - but they are all verbose.  Explicit template arguments
could be given to <tt>regex_replace()</tt>, allowing <tt>basic_string</tt>'s implicit
constructor to be invoked - but <tt>charT</tt> is the last template argument, not
the first, so this would be extremely verbose.  Therefore, constructing
a <tt>basic_string</tt> from each C string is the simplest workaround.
</p>
</li>

<li>
There is an efficiency consideration: constructing <tt>basic_string</tt>s can
impose performance costs that could be avoided by a library
implementation taking C strings and dealing with them directly. 
(Currently, for replacement sources, C strings can be converted into
iterator pairs at the cost of verbosity, but for format strings, there
is no way to avoid constructing a <tt>basic_string</tt>.)
</li>
</ol>

<p><i>[
Sophia Antipolis:
]</i></p>


<blockquote>
We note that Boost already has these overloads. However, the proposed
wording is provided only for 28.12.4 [re.alg.replace]; wording is needed for the synopsis
as well. We also note that this has impact on <tt>match_results::format</tt>,
which may require further overloads.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Provide additional overloads for <tt>regex_replace()</tt>: one additional
overload of the iterator-based form (taking <tt>const charT* fmt</tt>), and three
additional overloads of the convenience form (one taking <tt>const charT*
str</tt>, another taking <tt>const charT* fmt</tt>, and the third taking both <tt>const
charT* str</tt> and <tt>const charT* fmt</tt>).  28.12.4 [re.alg.replace]:
</p>

<blockquote>
<pre>template &lt;class OutputIterator, class BidirectionalIterator, 
    class traits, class charT&gt; 
  OutputIterator 
  regex_replace(OutputIterator out, 
                BidirectionalIterator first, BidirectionalIterator last, 
                const basic_regex&lt;charT, traits&gt;&amp; e, 
                const basic_string&lt;charT&gt;&amp; fmt, 
                regex_constants::match_flag_type flags = 
                  regex_constants::match_default);

<ins>template &lt;class OutputIterator, class BidirectionalIterator, 
    class traits, class charT&gt; 
  OutputIterator 
  regex_replace(OutputIterator out, 
                BidirectionalIterator first, BidirectionalIterator last, 
                const basic_regex&lt;charT, traits&gt;&amp; e, 
                const charT* fmt, 
                regex_constants::match_flag_type flags = 
                  regex_constants::match_default);</ins>
</pre>
<p>...</p>
<pre>template &lt;class traits, class charT&gt; 
  basic_string&lt;charT&gt; 
  regex_replace(const basic_string&lt;charT&gt;&amp; s, 
                const basic_regex&lt;charT, traits&gt;&amp; e, 
                const basic_string&lt;charT&gt;&amp; fmt, 
                regex_constants::match_flag_type flags = 
                  regex_constants::match_default);

<ins>template &lt;class traits, class charT&gt; 
  basic_string&lt;charT&gt; 
  regex_replace(const basic_string&lt;charT&gt;&amp; s, 
                const basic_regex&lt;charT, traits&gt;&amp; e, 
                const charT* fmt, 
                regex_constants::match_flag_type flags = 
                  regex_constants::match_default);</ins>

<ins>template &lt;class traits, class charT&gt; 
  basic_string&lt;charT&gt; 
  regex_replace(const charT* s, 
                const basic_regex&lt;charT, traits&gt;&amp; e, 
                const basic_string&lt;charT&gt;&amp; fmt, 
                regex_constants::match_flag_type flags = 
                  regex_constants::match_default);</ins>

<ins>template &lt;class traits, class charT&gt; 
  basic_string&lt;charT&gt; 
  regex_replace(const charT* s, 
                const basic_regex&lt;charT, traits&gt;&amp; e, 
                const charT* fmt, 
                regex_constants::match_flag_type flags = 
                  regex_constants::match_default);</ins>
</pre>
</blockquote>






<hr>
<h3><a name="727"></a>727. <tt>regex_replace()</tt> doesn't accept <tt>basic_string</tt>s with custom traits and allocators</h3>
<p><b>Section:</b> 28.12.4 [re.alg.replace] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2007-09-22  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#re.alg.replace">active issues</a> in [re.alg.replace].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#re.alg.replace">issues</a> in [re.alg.replace].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>regex_match()</tt> and <tt>regex_search()</tt> take <tt>const basic_string&lt;charT, ST,
SA&gt;&amp;</tt>.  <tt>regex_replace()</tt> takes <tt>const basic_string&lt;charT&gt;&amp;</tt>.  This prevents
<tt>regex_replace()</tt> from accepting <tt>basic_string</tt>s with custom traits and
allocators.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Bill comments, "We need to look at the depth of this change."
</p>
<p>
Pete remarks that we are here dealing with a convenience function
that saves a user from calling the iterato-based overload.
</p>
<p>
Move to Open.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Overloads of <tt>regex_replace()</tt> taking <tt>basic_string</tt> should be additionally
templated on <tt>class ST, class SA</tt> and take <tt>const basic_string&lt;charT, ST,
SA&gt;&amp;</tt>.  Consistency with <tt>regex_match()</tt> and <tt>regex_search()</tt> would place
<tt>class ST, class SA</tt> as the first template arguments; compatibility with
existing code using TR1 and giving explicit template arguments to
<tt>regex_replace()</tt> would place <tt>class ST, class SA</tt> as the last template
arguments.
</p>





<hr>
<h3><a name="747"></a>747. We have 3 separate type traits to identify classes supporting no-throw operations</h3>
<p><b>Section:</b> 20.6.4.3 [meta.unary.prop] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2007-10-10  <b>Last modified:</b> 2008-03-11</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#meta.unary.prop">active issues</a> in [meta.unary.prop].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#meta.unary.prop">issues</a> in [meta.unary.prop].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
We have 3 separate type traits to identify classes supporting no-throw
operations, which are very useful when trying to provide exception safety
guarantees.  However, I'm not entirely clear on what the current wording
requires of a conforming implementation.  To quote from
<tt>has_nothrow_default_constructor</tt>:
</p>
<blockquote><p>
or <tt>T</tt> is a class type with a default constructor that is known not to throw
any exceptions
</p></blockquote>
<p>
What level of magic do we expect to deduce if this is known?
</p>
<p>
E.g.
</p>

<blockquote><pre>struct test{
 int x;
 test() : x() {}
};
</pre></blockquote>
<p>
Should I expect a conforming compiler to 
 <tt>assert( has_nothrow_constructor&lt;test&gt;::value )</tt>
</p>
<p>
Is this a QoI issue?
</p>
<p>
Should I expect to 'know' only if-and-only-if there is an inline definition
available?
</p>
<p>
Should I never expect that to be true, and insist that the user supplies an
empty throw spec if they want to assert the no-throw guarantee?
</p>
<p>
It would be helpful to maybe have a footnote explaining what is required,
but right now I don't know what to suggest putting in the footnote.
</p>
<p>
(agreement since is that trivial ops and explicit no-throws are required.
Open if QoI should be allowed to detect further)
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
This looks like a QoI issue.
In the case of trivial and nothrow it is known. Static analysis of the program is definitely into QoI.
Move to OPEN. Need to talk to Core about this.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="750"></a>750. The current definition for <tt>is_convertible</tt> requires that the type be
implicitly convertible, so explicit constructors are ignored.</h3>
<p><b>Section:</b> 20.6.5 [meta.rel] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2007-10-10  <b>Last modified:</b> 2008-03-11</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#meta.rel">active issues</a> in [meta.rel].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#meta.rel">issues</a> in [meta.rel].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
With the pending arrival of explicit conversion functions though, I'm
wondering if we want an additional trait, <tt>is_explictly_convertible</tt>?
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
Alisdair is considering preparing a paper listing a number of missing
type traits, and feels that it might be useful to handle them all
together rather than piecemeal. This would affect issue 719 and 750.
These two issues should move to OPEN pending AM paper on type traits.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="751"></a>751. change pass-by-reference members of <tt>vector&lt;bool&gt;</tt> to pass-by-value?</h3>
<p><b>Section:</b> 23.3.7 [vector.bool] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2007-10-10  <b>Last modified:</b> 2008-09-22</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#vector.bool">active issues</a> in [vector.bool].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#vector.bool">issues</a> in [vector.bool].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
A number of vector&lt;bool&gt; members take const bool&amp; as arguments.
Is there any chance we could change them to pass-by-value or would I 
be wasting everyone's time if wrote up an issue?
</p>

<p><i>[
post Bellevue:
]</i></p>


<blockquote>
<p>
As we understand it, the original requester (Martin Sebor) would like
for implementations to be permitted to pass-by-value. Alisdair suggests
that if this is to be resolved, it should be resolved more generally,
e.g. in other containers as well.
</p>
<p>
We note that this would break ABI. However, we also suspect that this
might be covered under the "as-if" rule in section 1.9.
</p>
<p>
Many in the group feel that for vector&lt;bool&gt;, this is a "don't care",
and that at this point in the process it's not worth the bandwidth.
</p>
<p>
Issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#679">679</a> -- which was in ready status pre-Bellevue and is
now in the working paper -- is related to this, though not a duplicate.
</p>
<p>
Moving to Open with a task for Alisdair to craft a informative note to
be put whereever appropriate in the WP. This note would clarify places
where pass-by-const-ref can be transformed to pass-by-value under the
as-if rule.
</p>
</blockquote>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
<p>
This is really a clause 17 issue, rather than something specific to vector&lt;bool&gt;.
</p>
<p>
Move to Open. Alisdair to provide a resolution. Alternately, Howard can
close this as NAD and then open a new issue to handle the general issue
(rather than the vector&lt;bool&gt; one).
</p>
<p>
Howard:  Haven't yet opened new issue.  Lacking wording for it.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="760"></a>760. The emplace issue</h3>
<p><b>Section:</b> 23.2 [container.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Paolo Carlini <b>Opened:</b> 2007-11-11  <b>Last modified:</b> 2008-06-02</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#container.requirements">active issues</a> in [container.requirements].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#container.requirements">issues</a> in [container.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In an emplace member function the function parameter pack may be bound
to a priori unlimited number of objects: some or all of them can be
elements of the container itself. Apparently, in order to conform to the
blanket statement 23.2 [container.requirements]/11, the implementation must check all of them for
that possibility. A possible solution can involve extending the
exception in 23.2 [container.requirements]/12 also to the emplace member. As a side note, the
<tt>push_back</tt> and <tt>push_front</tt> member functions are luckily not affected by
this problem, can be efficiently implemented anyway
</p>

<p><i>[
Related to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#767">767</a>
]</i></p>


<p><i>[
Bellevue:
]</i></p>


<blockquote>
<p>
The proposed addition (13) is partially redundant with the existing
paragraph 12. Why was the qualifier "rvalues" added to paragraph 12? Why
does it not cover subelements and pointers?
</p>
<p>
Resolution: Alan Talbot to rework language, then set state to Review.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add after 23.2 [container.requirements]/12:
</p>

<blockquote>
<p>
-12- Objects passed to member functions of a container as rvalue references shall not be elements of that container. No 
diagnostic required.
</p>
<p>
<ins>
-13- Objects bound to the function parameter pack of the <tt>emplace</tt> member function shall not be elements or
sub-objects of elements of the container. No diagnostic required.
</ins>
</p>

</blockquote>






<hr>
<h3><a name="765"></a>765. more on iterator validity</h3>
<p><b>Section:</b> 24.2 [iterator.concepts] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2007-12-14  <b>Last modified:</b> 2009-03-09</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#iterator.concepts">active issues</a> in [iterator.concepts].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#iterator.concepts">issues</a> in [iterator.concepts].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
       <p>

Issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#278">278</a>
defines the meaning of the term "invalid iterator" as one that may be
singular.

       </p>
       <p>

Consider the following code:

       </p>
       <pre>   std::deque&lt;int&gt; x, y;
   std::deque&lt;int&gt;::iterator i = x.end(), j = y.end();
   x.swap(y);
       </pre>
       <p>

Given that <code>swap()</code> is required not to invalidate iterators
and using the definition above, what should be the expected result of
comparing <code>i</code> and <code>j</code> to <code>x.end()</code>
and <code>y.end()</code>, respectively, after the <code>swap()</code>?

       </p>
       <p>

I.e., is the expression below required to evaluate
to <code>true</code>?

       </p>
       <pre>   i == y.end() &amp;&amp; j == x.end()
       </pre>
       <p>

(There are at least two implementations where the expression
returns <code>false</code>.)

       </p>
       <p>

More generally, is the definition introduced in issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#278">278</a> meant to
make any guarantees about whether iterators actually point to the same
elements or be associated with the same containers after a
non-invalidating operation as they did before?

       </p>
       <p>

Here's a motivating example intended to demonstrate the importance of
the question:

       </p>
       <pre>   Container x, y ({ 1, 2});   // pseudocode to initialize y with { 1, 2 }
   Container::iterator i = y.begin() + 1;
   Container::iterator j = y.end();
   std::swap(x, y);
   std::find(i, j, 3);
       </pre>
       <p>

<code>swap()</code> guarantees that <code>i</code> and <code>j</code>
continue to be valid. Unless the spec says that even though they are
valid they may no longer denote a valid range the code above must be
well-defined. Expert opinions on this differ as does the behavior of
popular implementations for some standard <code>Containers</code>.

       </p>
<p><i>[
San Francisco:
]</i></p>


<blockquote>
<p>Pablo: add a note to the last bullet of paragraph 11 of 23.1.1
clarifying that the end() iterator doesn't refer to an element and that
it can therefore be invalidated.
</p>
<p>
Proposed wording:
</p>
<blockquote>
[<i>Note:</i> The <tt>end()</tt> iterator does not refer to any element and can
therefore be invalidated. <i>-- end note</i>]
</blockquote>
<p>
Howard will add this proposed wording to the issue and then move it to Review.
</p>
</blockquote>

<p><i>[
Post Summit:
]</i></p>


<blockquote>
<p>
Lawrence: suggestion: "Note: The <tt>end()</tt> iterator does not refer to any element"
</p>
<p>
Walter: "Note: The <tt>end()</tt> iterator can nevertheless be invalidated,
because it does not refer to any element."
</p>
<p>
Nick: "The <tt>end()</tt> iterator does not refer to any element. It is therefore
subject to being invalidated."
</p>
<p>
Consensus: go with Nick
</p>
<p>
With that update, Recommend Tentatively Ready.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add to 23.2.1 [container.requirements.general], p11:
</p>

<blockquote>
<p>
Unless otherwise specified (see 23.1.4.1, 23.1.5.1, 23.2.2.3, and
23.2.6.4) all container types defined in this Clause meet the following
additional requirements:
</p>
<ul>
<li>...</li>
<li>
no <tt>swap()</tt> function invalidates any references, pointers, or
iterators referring to the elements of the containers being swapped.
<ins>[<i>Note:</i> The <tt>end()</tt> iterator does not refer to any element. It is therefore
subject to being invalidated. <i>-- end note</i>]</ins>
</li>
</ul>
</blockquote>





<hr>
<h3><a name="774"></a>774. Member swap undefined for most containers</h3>
<p><b>Section:</b> 23 [containers] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2008-01-14  <b>Last modified:</b> 2008-05-11</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#containers">active issues</a> in [containers].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#containers">issues</a> in [containers].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It appears most containers declare but do not define a member-swap
function.
</p>

<p>
This is unfortunate, as all overload the <tt>swap</tt> algorithm to call the
member-swap function!
(required for <tt>swappable</tt> guarantees [Table 37] and Container Requirements
[Table 87])
</p>

<p>
Note in particular that Table 87 gives semantics of <tt>a.swap(b)</tt> as <tt>swap(a,b)</tt>,
yet for all containers we define <tt>swap(a,b)</tt> to call <tt>a.swap(b)</tt> - a circular
definition.
</p>

<p>
A quick survey of clause 23 shows that the following containers provide a
definition for member-swap:
</p>

<blockquote><pre>array
queue
stack
vector
</pre></blockquote>

<p>
Whereas the following declare it, but do not define the semantics:
</p>

<blockquote><pre>deque
list
map
multimap
multiset
priority_queue
set
unordered_map
unordered_multi_map
unordered_multi_set
unordered_set
</pre></blockquote>

<p>
Suggested resolution:
</p>
<blockquote>
Provide a definition for each of the affected containers...
</blockquote>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
Move to Open and ask Alisdair to provide wording.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Wording provided in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2590.pdf">N2590</a>.
</p>





<hr>
<h3><a name="780"></a>780. <tt>std::merge()</tt> specification incorrect/insufficient</h3>
<p><b>Section:</b> 25.5.4 [alg.merge] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Review">Review</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2008-01-25  <b>Last modified:</b> 2009-05-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Review">Review</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Though issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#283">283</a> has fixed many open issues, it seems that some are still open:
</p>

<p>
Both 25.3.4 [lib.alg.merge] in 14882:2003 and 25.5.4 [alg.merge] in N2461
have no Requires element and the Effects element contains some requirements,
which is probably editorial. Worse is that:
</p>

<ul>
<li>
no assignment requirements are specified (neither implicit nor explicit).
</li>

<li>
the effects clause just speaks of "merges", which is badly worded
near to a circular definition.
</li>

<li>
p. 2 mentions a range <tt>[first, last)</tt>, which is not defined by the
function arguments or otherwise.
</li>

<li>
p. 2 says "according to the ordering defined by comp" which is both
incomplete (because
this excludes the first variant with &lt;) and redundant (because the
following subordinate
clause mentions comp again)
</li>
</ul>

<p><i>[
Post Summit Alisdair adds:
]</i></p>


<blockquote>
<p>
Suggest:
</p>
<blockquote>
(where <tt>last</tt> is equal to <tt>next(result, distance(first1, last1) +
distance(first2, last2))</tt>, such that resulting range will be sorted in
non-decreasing order; that is, for every iterator <tt>i</tt> in <tt>[result,last)</tt> other
than <tt>result</tt>, the condition <tt>*i &lt; *prev(i)</tt> or, respectively, <tt>comp(*i,
*prev(i))</tt> will be <tt>false</tt>.
</blockquote>

<p>
Note that this might still not be technically accurate in the case of
<tt>InputIterators</tt>, depending on other resolutions working their way through the
system (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1011">1011</a>).
</p>
</blockquote>

<p><i>[
Post Summit Daniel adds:
]</i></p>


<blockquote>
If we want to use <tt>prev</tt> and <tt>next</tt> here (Note: <tt>merge</tt>
is sufficiently satisfied with <tt>InputIterator</tt>) we should instead *add* more to
25 [algorithms]/6, but I can currently not propose any good wording for this.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Pete points out the existing wording in [algorithms]/4
that permits the use of + in algorithm specifications.
</p>
<p>
Alisdair points out that that wording may not apply to input iterators.
</p>
<p>
Move to Review.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
In 25.5.4 [alg.merge] replace p.1+ 2:
</p>

<blockquote>
<p>
<i>Effects:</i> <del>Merges</del> <ins>Copies all the elements of the</ins> two sorted ranges <tt>[first1,last1)</tt> and
<tt>[first2,last2)</tt> into the range
<del><tt>[result,result + (last1 - first1) + (last2 - first2))</tt></del>
<ins><tt>[result, last)</tt> (where <tt>last</tt> is equal to <tt>result + (last1
- first1) + (last2 - first2))</tt>, such that resulting range will be
sorted in non-decreasing order; that is, for every iterator <tt>i</tt> in
<tt>[result,last)</tt> other than <tt>result</tt>, the condition <tt>*i &lt; *(i - 1)</tt> or,
respectively, <tt>comp(*i, *(i - 1))</tt> will be false</ins>.
</p>

<p>
<ins><i>Requires:</i></ins> The resulting range shall not overlap with either of the original ranges. <del>The list will be sorted in non-decreasing 
order according to the ordering defined by <tt>comp</tt>; that is, for every iterator <tt>i</tt> in
<tt>[first,last)</tt> other than <tt>first</tt>, the condition <tt>*i &lt; *(i - 1)</tt> or
<tt>comp(*i, *(i - 1))</tt> will be false.</del>
</p>
</blockquote>

<p>
[N.B.: I attempted to reuse the wording style of <tt>inplace_merge</tt>,
therefore proposing to
insert ", respectively," between both predicate tests. This is no
strictly necessary as
other parts of <tt>&lt;algorithm&gt;</tt> show, just a matter of consistency]
</p>






<hr>
<h3><a name="785"></a>785. Random Number Requirements in TR1</h3>
<p><b>Section:</b> TR1 5.1.4.5 [tr.rand.eng.disc], TR1 5.1.4.6 [tr.rand.eng.xor] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> John Maddock <b>Opened:</b> 2008-01-15  <b>Last modified:</b> 2009-05-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Table 16 of TR1 requires that all Pseudo Random Number generators have a
</p>

<blockquote><pre>seed(integer-type s)
</pre></blockquote>

<p>
member function that is equivalent to:
</p>

<blockquote><pre>mygen = Generator(s)
</pre></blockquote>

<p>
But the generators <tt>xor_combine</tt> and <tt>discard_block</tt> have no such seed member, only the
</p>

<blockquote><pre>template &lt;class Gen&gt;
seed(Gen&amp;);
</pre></blockquote>

<p>
member, which will not accept an integer literal as an argument: something that appears to violate the intent of Table 16.
</p>

<p>
So... is this a bug in TR1?
</p>

<p>This is a real issue BTW, since the Boost implementation does adhere
to the requirements of Table 16, while at least one commercial
implementation does not and follows a strict adherence to sections
5.1.4.5 and 5.1.4.6 instead.
</p>

<p><i>[
Jens adds:
]</i></p>


<blockquote>
Both engines do have the necessary
constructor, therefore the omission of the <tt>seed()</tt> member
functions appears to be an oversight.
</blockquote>

<p><i>[
Post Summit Daniel adds:
]</i></p>


<blockquote>
Recommend NAD: <tt>xor_combine</tt> does no longer exist and <tt>discard_block[_engine]</tt>
has now the required seed overload accepting a <tt>result_type</tt>, which shall be an
unsigned integral type.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Move to NAD as recommended.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
NAD Recommended.
</p>





<hr>
<h3><a name="788"></a>788. ambiguity in [istream.iterator]</h3>
<p><b>Section:</b> 24.6.1 [istream.iterator] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2008-02-06  <b>Last modified:</b> 2009-03-14</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#istream.iterator">active issues</a> in [istream.iterator].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#istream.iterator">issues</a> in [istream.iterator].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 287</b></p>

<blockquote>
<p>
It is not clear what the initial state of an <tt>istream_iterator</tt> should be. Is
_value_ initialized by reading the stream, or default/value initialized? If
it is initialized by reading the stream, what happens if the initialization
is deferred until first dereference, when ideally the iterator value should
have been that of an end-of-stream iterator which is not safely
dereferencable?
</p>

<p>
Recommendation: Specify _value_ is initialized by reading the stream, or
the iterator takes on the end-of-stream value if the stream is empty.
</p>
</blockquote>

<p>
The description of how an istream_iterator object becomes an
end-of-stream iterator is a) ambiguous and b) out of date WRT
issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#468">468</a>:
</p>

<blockquote>
<tt>istream_iterator</tt> reads (using <tt>operator&gt;&gt;</tt>) successive elements from the
input stream for which it was constructed. After it is constructed, and
every time <tt>++</tt> is used, the iterator reads and stores a value of <tt>T</tt>. If
the end of stream is reached (<tt>operator void*()</tt> on the stream returns
<tt>false</tt>), the iterator becomes equal to the <i>end-of-stream</i> iterator value.
The constructor with no arguments <tt>istream_iterator()</tt> always constructs
an end of stream input iterator object, which is the only legitimate
iterator to be used for the end condition. The result of <tt>operator*</tt> on an
end of stream is not defined. For any other iterator value a <tt>const T&amp;</tt> is
returned. The result of <tt>operator-&gt;</tt> on an end of stream is not defined.
For any other iterator value a <tt>const T*</tt> is returned. It is impossible to
store things into istream iterators. The main peculiarity of the istream
iterators is the fact that <tt>++</tt> operators are not equality preserving,
that is, <tt>i == j</tt> does not guarantee at all that <tt>++i == ++j</tt>. Every time <tt>++</tt>
is used a new value is read.
</blockquote>

<p>
<tt>istream::operator void*()</tt> returns null if <tt>istream::fail()</tt> is <tt>true</tt>,
otherwise non-null. <tt>istream::fail()</tt> returns <tt>true</tt> if <tt>failbit</tt> or
<tt>badbit</tt> is set in <tt>rdstate()</tt>. Reaching the end of stream doesn't
necessarily imply that <tt>failbit</tt> or <tt>badbit</tt> is set (e.g., after
extracting an <tt>int</tt> from <tt>stringstream("123")</tt> the stream object will
have reached the end of stream but <tt>fail()</tt> is <tt>false</tt> and <tt>operator
void*()</tt> will return a non-null value).
</p>

<p>
Also I would prefer to be explicit about calling <tt>fail()</tt> here
(there is no <tt>operator void*()</tt> anymore.)
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Moved from Ready to Open for the purposes of using this issue to address NB UK 287.
Martin to handle.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 24.6.1 [istream.iterator]/1:
</p>

<blockquote>
<tt>istream_iterator</tt> reads (using <tt>operator&gt;&gt;</tt>) successive elements from the
input stream for which it was constructed. After it is constructed, and
every time <tt>++</tt> is used, the iterator reads and stores a value of <tt>T</tt>. If
<del>the end of stream is reached</del> <ins>the iterator fails to read and store a value of <tt>T</tt></ins>
(<tt><del>operator void*()</del> <ins>fail()</ins></tt> on the stream returns
<tt><del>false</del> <ins>true</ins></tt>), the iterator becomes equal to the <i>end-of-stream</i> iterator value.
The constructor with no arguments <tt>istream_iterator()</tt> always constructs
an end of stream input iterator object, which is the only legitimate
iterator to be used for the end condition. The result of <tt>operator*</tt> on an
end of stream is not defined. For any other iterator value a <tt>const T&amp;</tt> is
returned. The result of <tt>operator-&gt;</tt> on an end of stream is not defined.
For any other iterator value a <tt>const T*</tt> is returned. It is impossible to
store things into istream iterators. The main peculiarity of the istream
iterators is the fact that <tt>++</tt> operators are not equality preserving,
that is, <tt>i == j</tt> does not guarantee at all that <tt>++i == ++j</tt>. Every time <tt>++</tt>
is used a new value is read.
</blockquote>





<hr>
<h3><a name="801"></a>801. <tt>tuple</tt> and <tt>pair</tt> trivial members</h3>
<p><b>Section:</b> 20.5 [tuple] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Lawrence Crowl <b>Opened:</b> 2008-02-18  <b>Last modified:</b> 2009-05-30</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#tuple">issues</a> in [tuple].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Classes with trivial special member functions are inherently more
efficient than classes without such functions.  This efficiency is
particularly pronounced on modern ABIs that can pass small classes
in registers.  Examples include value classes such as complex numbers
and floating-point intervals.  Perhaps more important, though, are
classes that are simple collections, like <tt>pair</tt> and <tt>tuple</tt>.  When the
parameter types of these classes are trivial, the <tt>pair</tt>s and <tt>tuple</tt>s
themselves can be trivial, leading to substantial performance wins.
</p>
<p>
The current working draft make specification of trivial functions
(where possible) much easer through <tt>default</tt>ed and <tt>delete</tt>d functions.
As long as the semantics of defaulted and deleted functions match
the intended semantics, specification of defaulted and deleted
functions will yield more efficient programs.
</p>
<p>
There are at least two cases where specification of an explicitly
defaulted function may be desirable.
</p>
<p>
First, the <tt>std::pair</tt> template has a non-trivial default constructor,
which prevents static initialization of the pair even when the
types are statically initializable.  Changing the definition to
</p>

<blockquote><pre>pair() = default;
</pre></blockquote>

<p>
would enable such initialization.  Unfortunately, the change is
not semantically neutral in that the current definition effectively
forces value initialization whereas the change would not value
initialize in some contexts.
</p>

<p>
** Does the committee confirm that forced value initialization
was the intent?  If not, does the committee wish to change the
behavior of <tt>std::pair</tt> in C++0x?
</p>
<p>
Second, the same default constructor issue applies to <tt>std::tuple</tt>.
Furthermore, the <tt>tuple</tt> copy constructor is current non-trivial,
which effectively prevents passing it in registers.  To enable
passing <tt>tuples</tt> in registers, the copy constructor should be
make explicitly <tt>default</tt>ed.  The new declarations are:
</p>

<blockquote><pre>tuple() = default;
tuple(const tuple&amp;) = default;
</pre></blockquote>

<p>
This changes is not implementation neutral.  In particular, it
prevents implementations based on pointers to the parameter
types.  It does however, permit implementations using the
parameter types as bases.
</p>
<p>
** How does the committee wish to trade implementation
efficiency versus implementation flexibility?
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
<p>
General agreement; the first half of the issue is NAD.
</p>
<p>
Before voting on the second half, it was agreed that a "Strongly Favor"
vote meant support for trivial tuples (assuming usual requirements met),
even at the expense of other desired qualities. A "Weakly Favor" vote
meant support only if not at the expense of other desired qualities.
</p>
<p>
Concensus: Go forward, but not at expense of other desired qualities.
</p>
<p>
It was agreed to Alisdair should fold this work in with his other
pair/tuple action items, above, and that issue 801 should be "open", but
tabled until Alisdair's proposals are disposed of.
</p>
</blockquote>

<p><i>[
2009-05-27 Daniel adds:
]</i></p>


<blockquote>
This is partly solved by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1117">1117</a>.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="810"></a>810. Missing traits dependencies in operational semantics of extended manipulators</h3>
<p><b>Section:</b> 27.7.4 [ext.manip] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2008-03-01  <b>Last modified:</b> 2009-05-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#ext.manip">issues</a> in [ext.manip].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The recent draft (as well as the original proposal n2072) uses an
operational semantic
for <tt>get_money</tt> ([ext.manip]/4) and <tt>put_money</tt> ([ext.manip]/6), which uses
</p>

<blockquote><pre>istreambuf_iterator&lt;charT&gt;
</pre></blockquote>

<p>
and
</p>

<blockquote><pre>ostreambuf_iterator&lt;charT&gt;
</pre></blockquote>

<p>
resp, instead of the iterator instances, with explicitly provided
traits argument (The operational semantic defined by <tt>f</tt> is also traits
dependent). This is an obvious oversight because both <tt>*stream_buf</tt>
c'tors expect a <tt>basic_streambuf&lt;charT,traits&gt;</tt> as argument.
</p>
<p>
The same problem occurs within the <tt>get_time</tt> and <tt>put_time</tt> semantic 
where additional to the problem we
have an editorial issue in <tt>get_time</tt> (<tt>streambuf_iterator</tt> instead of
<tt>istreambuf_iterator</tt>).
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
This appears to be an issue of presentation.
</p>
<p>
We agree with the proposed resolution.
Move to Tentatively Ready.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
In 27.7.4 [ext.manip]/4 within function <tt>f</tt> replace the first line
</p>

<blockquote><pre>template &lt;class charT, class traits, class moneyT&gt; 
void f(basic_ios&lt;charT, traits&gt;&amp; str, moneyT&amp; mon, bool intl) { 
   typedef istreambuf_iterator&lt;charT<ins>, traits</ins>&gt; Iter;
   ...
</pre></blockquote>

<p>
In 27.7.4 [ext.manip]/5 remove the first template <tt>charT</tt> parameter:
</p>

<blockquote><pre>template &lt;<del>class charT, </del>class moneyT&gt; unspecified put_money(const moneyT&amp; mon, bool intl = false<ins>)</ins>;
</pre></blockquote>

<p>
In 27.7.4 [ext.manip]/6 within function <tt>f</tt> replace the first line
</p>

<blockquote><pre>template &lt;class charT, class traits, class moneyT&gt; 
void f(basic_ios&lt;charT, traits&gt;&amp; str, const moneyT&amp; mon, bool intl) { 
  typedef ostreambuf_iterator&lt;charT<ins>, traits</ins>&gt; Iter;
  ...
</pre></blockquote>

<p>
In 27.7.4 [ext.manip]/8 within function <tt>f</tt> replace the first line
</p>

<blockquote><pre>template &lt;class charT, class traits&gt; 
void f(basic_ios&lt;charT, traits&gt;&amp; str, struct tm *tmb, const charT *fmt) { 
  typedef <ins>i</ins>streambuf_iterator&lt;charT<ins>, traits</ins>&gt; Iter;
  ...
</pre></blockquote>

<p>
In 27.7.4 [ext.manip]/10 within function <tt>f</tt> replace the first line
</p>

<blockquote><pre>template &lt;class charT, class traits&gt; 
void f(basic_ios&lt;charT, traits&gt;&amp; str, const struct tm *tmb, const charT *fmt) { 
  typedef ostreambuf_iterator&lt;charT<ins>, traits</ins>&gt; Iter;
  ...
</pre></blockquote>

<p>
In 27.7 [iostream.format], Header <tt>&lt;iomanip&gt;</tt> synopsis change:
</p>

<blockquote><pre>template &lt;<del>class charT, </del>class moneyT&gt; T8 put_money(const moneyT&amp; mon, bool intl = false);
</pre></blockquote>





<hr>
<h3><a name="814"></a>814. <tt>vector&lt;bool&gt;::swap(reference, reference)</tt> not defined</h3>
<p><b>Section:</b> 23.3.7 [vector.bool] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2008-03-17  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#vector.bool">active issues</a> in [vector.bool].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#vector.bool">issues</a> in [vector.bool].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>vector&lt;bool&gt;::swap(reference, reference)</tt> has no definition.
</p>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
Move to Open. Alisdair to provide a resolution.
</blockquote>

<p><i>[
Post Summit Daniel provided wording.
]</i></p>


<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution.
Move to Tentatively Ready.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Just after 23.3.7 [vector.bool]/5 add the following prototype and description:
</p>

<blockquote>
<p>
<ins>static void swap(reference x, reference y);</ins>
</p>
<blockquote>
<p>
<ins>-6- <i>Effects:</i> Exchanges the contents of <tt>x</tt> and <tt>y</tt> as-if</ins> by:
</p>
<blockquote><pre><ins>
bool b = x;
x = y;
y = b;
</ins></pre></blockquote>
</blockquote>
</blockquote>





<hr>
<h3><a name="815"></a>815. <tt>std::function</tt> and <tt>reference_closure</tt> do not use perfect forwarding</h3>
<p><b>Section:</b> 20.7.16.2.4 [func.wrap.func.inv] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2008-03-16  <b>Last modified:</b> 2009-06-01</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>std::function</tt> and <tt>reference_closure</tt> should use "perfect forwarding" as
described in the rvalue core proposal.
</p>

<p><i>[
Sophia Antipolis:
]</i></p>


<blockquote>
According to Doug Gregor, as far as <tt>std::function</tt> is concerned, perfect
forwarding can not be obtained because of type erasure. Not everyone
agreed with this diagnosis of forwarding.
</blockquote>

<p><i>[
2009-05-01 Howard adds:
]</i></p>


<blockquote>
<p>
Sebastian Gesemann brought to my attention that the <tt>CopyConstructible</tt>
requirement on <tt>function</tt>'s <tt>ArgTypes...</tt> is an unnecessary
restriction.
</p>

<blockquote><pre>template&lt;Returnable R, <b>CopyConstructible</b>... ArgTypes&gt;
class function&lt;R(ArgTypes...)&gt;
...
</pre></blockquote>

<p>
On further investigation, this complaint seemed to be the same
issue as this one.  I believe the reason <tt>CopyConstructible</tt> was put
on <tt>ArgTypes</tt> in the first place was because of the nature of the
<i>invoke</i> member:
</p>

<blockquote><pre>template&lt;class R, class ...ArgTypes&gt;
R
function&lt;R(ArgTypes...)&gt;::operator()(ArgTypes... arg) const
{
    if (f_ == 0)
        throw bad_function_call();
    return (*f_)(arg...);
}
</pre></blockquote>

<p>
However now with rvalue-refs, "by value" no longer implies <tt>CopyConstructible</tt>
(as Sebastian correctly points out).  If rvalue arguments are supplied, <tt>MoveConstructible</tt>
is sufficient.  Furthermore, the constraint need not be applied in <tt>function</tt>
if I understand correctly.  Rather the client must apply the proper constraints
at the call site.  Therefore, at the very least, I recommend that <tt>CopyConstructible</tt>
be removed from the template class <tt>function</tt>.
</p>

<p>
Furthermore we need to mandate that the <i>invoker</i> is coded as:
</p>

<blockquote><pre>template&lt;class R, class ...ArgTypes&gt;
R
function&lt;R(ArgTypes...)&gt;::operator()(ArgTypes... arg) const
{
    if (f_ == 0)
        throw bad_function_call();
    return (*f_)(<b>std::forward&lt;ArgTypes&gt;(</b>arg<b>)</b>...);
}
</pre></blockquote>

<p>
Note that <tt>ArgTypes&amp;&amp;</tt> (the "perfect forwarding signature") is not 
appropriate here as this is not a deduced context for <tt>ArgTypes</tt>.  Instead
the client's arguments must implicitly convert to the non-deduced <tt>ArgType</tt>
type.  Catching these arguments by value makes sense to enable decay.
</p>

<p>
Next <tt>forward</tt> is used to move the <tt>ArgTypes</tt> as efficiently as
possible, and also with minimum requirements (not <tt>CopyConstructible</tt>)
to the type-erased functor.  For object types, this will be a <tt>move</tt>.  For
reference type <tt>ArgTypes</tt>, this will be a copy.  The end result <em>must</em> be
that the following is a valid program:
</p>

<blockquote><pre>#include &lt;functional&gt;
#include &lt;memory&gt;
#include &lt;cassert&gt;

std::unique_ptr&lt;int&gt;
f(std::unique_ptr&lt;int&gt; p, int&amp; i)
{
    ++i;
    return std::move(p);
}

int main()
{
    int i = 2;
    std::function&lt;std::unique_ptr&lt;int&gt;(std::unique_ptr&lt;int&gt;,
                                       int&amp;&gt; g(f);
    std::unique_ptr&lt;int&gt; p = g(std::unique_ptr&lt;int&gt;(new int(1)), i);
    assert(*p == 1);
    assert(i == 3);
}
</pre></blockquote>

<p><i>[
Tested in pre-concepts rvalue-ref-enabled compiler.
]</i></p>


<p>
In the example above, the first <tt>ArgType</tt> is <tt>unique_ptr&lt;int&gt;</tt>
and the second <tt>ArgType</tt> is <tt>int&amp;</tt>.  Both <em>must</em> work!
</p>

</blockquote>

<p><i>[
2009-05-27 Daniel adds:
]</i></p>


<blockquote>
<p>
in the 2009-05-01 comment of above mentioned issue Howard
</p>

<ol type="a">
<li>
Recommends to replace the <tt>CopyConstructible</tt> requirement by a
<tt>MoveConstructible</tt> requirement
</li>
<li>
Says: "Furthermore, the constraint need not be applied in <tt>function</tt> if I
understand correctly. Rather the client must apply the proper constraints
at the call site"
</li>
</ol>
<p>
I'm fine with (a), but I think comment (b) is incorrect, at least in the
sense I read these sentences. Let's look at Howard's example code:
</p>

<blockquote><pre>function&lt;R(ArgTypes...)&gt;::operator()(ArgTypes... arg) const
{
   if (f_ == 0)
       throw bad_function_call();
   return (*f_)(std::forward&lt;ArgTypes&gt;(arg)...);
}
</pre></blockquote>

<p>
In the constrained scope of this <tt>operator()</tt> overload the expression
"<tt>(*f_)(std::forward&lt;ArgTypes&gt;(arg)...)</tt>" must be valid. How can it
do so, if <tt>ArgTypes</tt> aren't at least <tt>MoveConstructible</tt>?
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="816"></a>816. Should <tt>bind()</tt>'s returned functor have a nofail copy ctor when <tt>bind()</tt> is nofail?</h3>
<p><b>Section:</b> 20.7.12.1.3 [func.bind.bind] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2008-02-08  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#func.bind.bind">active issues</a> in [func.bind.bind].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#func.bind.bind">issues</a> in [func.bind.bind].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Library Issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#527">527</a> notes that <tt>bind(f, t1, ..., tN)</tt>
should be nofail when <tt>f, t1, ..., tN</tt> have nofail copy ctors.
</p>
<p>
However, no guarantees are provided for the copy ctor of the functor
returned by <tt>bind()</tt>.  (It's guaranteed to have a copy ctor, which can
throw implementation-defined exceptions: <tt>bind()</tt> returns a forwarding
call wrapper, TR1 3.6.3/2.  A forwarding call wrapper is a call wrapper,
TR1 3.3/4.  Every call wrapper shall be CopyConstructible, TR1 3.3/4.
Everything without an exception-specification may throw
implementation-defined exceptions unless otherwise specified, C++03
17.4.4.8/3.)
</p>
<p>
Should the nofail guarantee requested by Library Issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#527">527</a> be extended
to cover both calling <tt>bind()</tt> and copying the returned functor?
</p>

<p><i>[
Howard adds:
]</i></p>


<blockquote>
<tt>tuple</tt> construction should probably have a similar guarantee.
</blockquote>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
Howard to provide wording.
</blockquote>

<p><i>[
Post Summit, Anthony provided wording.
]</i></p>


<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Part of all of this issue appears to be rendered moot
by the proposed resolution to issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#817">817</a> (q.v.).
We recommend the issues be considered simultaneously
(or possibly even merged)
to ensure there is no overlap.
Move to Open, and likewise for issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#817">817</a>.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Add a new sentence to the end of paragraphs 2 and 4 of 20.7.12.1.3 [func.bind.bind]:
</p>

<blockquote>
<p>
-2- <i>Returns:</i> A forwarding call wrapper <tt>g</tt> with a weak result type (20.6.2). The effect of <tt>g(u1, u2,
..., uM)</tt> shall be <tt><i>INVOKE</i>(f, v1, v2, ..., vN, Callable&lt;F cv,V1, V2, ..., VN&gt;::result_type)</tt>, where <i>cv</i>
represents the <i>cv</i>-qualifiers of <tt>g</tt> and the values and types of the bound arguments
<tt>v1, v2, ..., vN</tt> are determined as specified below.
<ins>The copy constructor and move constructor of the forwarding call wrapper shall throw an
exception if and only if the corresponding constructor of <tt>F</tt> or any of the types
in <tt>BoundArgs...</tt> throw an exception.</ins>
</p>
<p>...</p>
<p>
-4- <i>Returns:</i> A forwarding call wrapper <tt>g</tt> with a nested type <tt>result_type</tt> defined as a synonym
for <tt>R</tt>. The effect of <tt>g(u1, u2, ..., uM)</tt> shall be <tt><i>INVOKE</i>(f, v1, v2, ..., vN, R)</tt>, where the
values and types of the bound arguments <tt>v1, v2, ..., vN</tt> are determined as specified below.
<ins>The copy constructor and move constructor of the forwarding call wrapper shall throw an
exception if and only if the corresponding constructor of <tt>F</tt> or any of the types
in <tt>BoundArgs...</tt> throw an exception.</ins>
</p>

</blockquote>





<hr>
<h3><a name="817"></a>817. <tt>bind</tt> needs to be moved</h3>
<p><b>Section:</b> 20.7.12.1.3 [func.bind.bind] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2008-03-17  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#func.bind.bind">active issues</a> in [func.bind.bind].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#func.bind.bind">issues</a> in [func.bind.bind].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US 72, JP 38 and DE 21</b></p>

<p>
The functor returned by <tt>bind()</tt> should have a move constructor that
requires only move construction of its contained functor and bound arguments.
That way move-only functors can be passed to objects such as <tt>thread</tt>.
</p>
<p>
This issue is related to issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#816">816</a>.
</p>

<p>
US 72:
</p>

<blockquote>
<tt>bind</tt> should support move-only functors and bound arguments.
</blockquote>

<p>
JP 38:
</p>

<blockquote>
<p>
add the move requirement for bind's return type.
</p>
<p>
For example, assume following <tt>th1</tt> and <tt>th2</tt>,
</p>

<blockquote><pre>void f(vector&lt;int&gt; v) { }

vector&lt;int&gt; v{ ... };
thread th1([v]{ f(v); });
thread th2(bind(f, v));
</pre></blockquote>

<p>
When function object are set to thread, <tt>v</tt> is moved to <tt>th1</tt>'s lambda
expression in a Move Constructor of lambda expression because <tt>th1</tt>'s lambda
expression has a Move Constructor. But <tt>bind</tt> of <tt>th2</tt>'s
return type doesn't have the requirement of Move, so it may not
moved but copied.
</p>
<p>
Add the requirement of move to get rid of this useless copy.
</p>
<p>
And also, add the <tt>MoveConstructible</tt> as well as <tt>CopyConstructible</tt>.
</p>
</blockquote>

<p>
DE 21
</p>

<blockquote>
The specification for bind claims twice that "the values and types for
the bound arguments v1, v2, ..., vN are determined as specified below".
No such specification appears to exist.
</blockquote>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
Howard to provide wording.
</blockquote>

<p><i>[
Post Summit Alisdair and Howard provided wording.
]</i></p>


<blockquote>
<p>
Several issues are being combined in this resolution.  They are all touching the
same words so this is an attempt to keep one issue from stepping on another, and
a place to see the complete solution in one place.
</p>

<ol>
<li>
<tt>bind</tt> needs to be "moved".
</li>
<li>
20.7.12.1.3 [func.bind.bind]/p3, p6 and p7 were accidently removed from N2798.
</li>
<li>
Issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#929">929</a> argues for a way to pass by &amp;&amp; for
efficiency but retain the decaying behavior of pass by value for the
<tt>thread</tt> constructor.  That same solution is applicable here.
</li>
</ol>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We were going to recommend moving this issue to Tentatively Ready
until we noticed potential overlap with issue 816 (q.v.).
</p>
<p>
Move to Open,
and recommend both issues be considered together
(and possibly merged).
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 20.7 [function.objects] p2:
</p>

<blockquote><pre>template&lt;<del>CopyConstructible</del> <ins>MoveConstructible</ins> Fn, <del>CopyConstructible</del> <ins>MoveConstructible</ins>... Types&gt;
  <i>unspecified</i> bind(Fn<ins>&amp;&amp;</ins>, Types<ins>&amp;&amp;</ins>...);
template&lt;Returnable R, <del>CopyConstructible</del> <ins>MoveConstructible</ins> Fn, <del>CopyConstructible</del> <ins>MoveConstructible</ins>... Types&gt;
  <i>unspecified</i> bind(Fn<ins>&amp;&amp;</ins>, Types<ins>&amp;&amp;</ins>...);
</pre></blockquote>

<p>
Change 20.7.12.1.3 [func.bind.bind]:
</p>

<blockquote><pre>template&lt;<del>CopyConstructible</del> <ins>MoveConstructible</ins> F, <del>CopyConstructible</del> <ins>MoveConstructible</ins>... BoundArgs&gt;
  <i>unspecified</i> bind(F<ins>&amp;&amp;</ins> f, BoundArgs<ins>&amp;&amp;</ins>... bound_args);
</pre>

<blockquote>
<p>
<ins><i>Requires:</i> <i>unspecified</i> return type shall be <tt>MoveConstructible</tt>.</ins>
</p>
<p>
-1- <i>Requires:</i> <tt><i>INVOKE</i>(f, w1, w2, ..., wN)</tt> (20.6.2) shall be a valid expression for some values
<i>w1, w2, ..., wN</i>, where <tt>N == sizeof...(bound_args)</tt>.
</p>
<p>
-2- <i>Returns:</i> A forwarding call wrapper <tt>g</tt> with a weak result type (20.6.2). The effect of <tt>g(u1, u2,
..., uM)</tt> shall be <tt><i>INVOKE</i>(f, v1, v2, ..., vN, Callable&lt;F cv,V1, V2, ..., VN&gt;::result_type)</tt>, where <i>cv</i>
represents the <i>cv</i>-qualifiers of <tt>g</tt> and the values and types of the bound arguments
<tt>v1, v2, ..., vN</tt> are determined as specified below.
</p>
<p><ins>
<i>Throws:</i> Nothing unless the constructor of <tt>F</tt> or of one of the types in the <tt>BoundArgs...</tt> pack expansion
throws an exception.
</ins></p>
</blockquote>

<pre>template&lt;Returnable R, <del>CopyConstructible</del> <ins>MoveConstructible</ins> F, <del>CopyConstructible</del> <ins>MoveConstructible</ins>... BoundArgs&gt;
  <i>unspecified</i> bind(F<ins>&amp;&amp;</ins> f, BoundArgs<ins>&amp;&amp;</ins>... bound_args);
</pre>

<blockquote>
<p>
<ins><i>Requires:</i> <i>unspecified</i> return type shall be <tt>MoveConstructible</tt>.</ins>
</p>
<p>
-3- <i>Requires:</i> <tt><i>INVOKE</i>(f, w1, w2, ..., wN)</tt> shall be a valid expression for some values <i>w1, w2, ...,
wN</i>, where <tt>N == sizeof...(bound_args)</tt>.
</p>
<p>
-4- <i>Returns:</i> A forwarding call wrapper <tt>g</tt> with a nested type <tt>result_type</tt> defined as a synonym
for <tt>R</tt>. The effect of <tt>g(u1, u2, ..., uM)</tt> shall be <tt><i>INVOKE</i>(f, v1, v2, ..., vN, R)</tt>, where the
values and types of the bound arguments <tt>v1, v2, ..., vN</tt> are determined as specified below.
</p>
<p>
</p><p><ins>
<i>Throws:</i> Nothing unless the constructor of <tt>F</tt> or of one of the types in the <tt>BoundArgs...</tt> pack expansion
throws an exception.
</ins></p>

</blockquote>

<p><ins>
Let the values of <i>bound arguments</i> <tt>v1, v2, ..., vN</tt> and
their corresponding types <tt>V1, V2, ..., VN</tt> depend on the type of
the corresponding argument <tt>ti</tt> in <tt>bound_args</tt> in the
call to <tt>bind</tt> and the <i>cv</i>-qualifiers <i>cv</i> of the call
wrapper <tt>g</tt> as follows. Let <tt>Ti</tt> be an alias for the ith
element of the pack expansion <tt>decay&lt;BoundArgs&gt;::type...</tt>,
and let <tt>ti</tt> be an alias for the ith element in the function
parameter pack expansion <tt>bound_args...</tt>:
</ins></p>

<ul>
<li><ins>
if <tt>ti</tt> is of type <tt>reference_wrapper&lt;T&gt;</tt> the argument is
<tt>ti.get()</tt> and its type <tt>Vi</tt> is <tt>T&amp;</tt>;
</ins></li>
<li><ins>
if the value of <tt>std::is_bind_expression&lt;Ti&gt;::value</tt> is <tt>true</tt> the argument is <tt>ti(u1, u2, ..., uM)</tt> and
its type <tt>Vi</tt> is <tt>result_of&lt;Ti cv (U1&amp;, U2&amp;, ..., UM&amp;)&gt;::type</tt>;
</ins></li>
<li><ins>
if the value <tt>j</tt> of <tt>std::is_placeholder&lt;Ti&gt;::value</tt> is not zero the argument is <tt>std::forward&lt;Uj&gt;(uj)</tt> and
its type <tt>Vi</tt> is <tt>Uj&amp;&amp;</tt>;
</ins></li>
<li><ins>
otherwise the value is <tt>ti</tt> and its type <tt>Vi</tt> is <tt>Ti cv &amp;</tt>.
</ins></li>
</ul>

</blockquote>






<hr>
<h3><a name="819"></a>819. rethrow_if_nested</h3>
<p><b>Section:</b> 18.8.6 [except.nested] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2008-03-25  <b>Last modified:</b> 2008-09-17</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#except.nested">active issues</a> in [except.nested].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#except.nested">issues</a> in [except.nested].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Looking at the wording I submitted for <tt>rethrow_if_nested</tt>, I don't think I
got it quite right.
</p>

<p>
The current wording says:
</p>

<blockquote>
<pre>template &lt;class E&gt; void rethrow_if_nested(const E&amp; e);
</pre>
<blockquote>
<p>
<i>Effects:</i> Calls <tt>e.rethrow_nested()</tt> only if <tt>e</tt>
is publicly derived from <tt>nested_exception</tt>.
</p>
</blockquote>
</blockquote>

<p>
This is trying to be a bit subtle, by requiring <tt>e</tt> (not <tt>E</tt>) to be publicly
derived from <tt>nested_exception</tt> the idea is that a <tt>dynamic_cast</tt> would be
required to be sure.  Unfortunately, if <tt>e</tt> is dynamically but not statically
derived from <tt>nested_exception</tt>, <tt>e.rethrow_nested()</tt> is ill-formed.
</p>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
Alisdair was volunteered to provide wording.
</blockquote>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="822"></a>822. Object with explicit copy constructor no longer <tt>CopyConstructible</tt></h3>
<p><b>Section:</b> X [utility.arg.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> James Kanze <b>Opened:</b> 2008-04-01  <b>Last modified:</b> 2009-05-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#utility.arg.requirements">issues</a> in [utility.arg.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I just noticed that the following program is legal in C++03, but
is forbidden in the current draft:
</p>

<blockquote><pre>#include &lt;vector&gt;
#include &lt;iostream&gt;

class Toto
{
public:
    Toto() {}
    explicit Toto( Toto const&amp; ) {}
} ;

int
main()
{
    std::vector&lt; Toto &gt; v( 10 ) ;
    return 0 ;
}
</pre></blockquote>

<p>
Is this change intentional?  (And if so, what is the
justification?  I wouldn't call such code good, but I don't see
any reason to break it unless we get something else in return.)
</p>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
The subgroup that looked at this felt this was a good change, but it may
already be handled by incoming concepts (we're not sure).
</blockquote>

<b>
Original Proposed resolution:
</b>

<p>
In X [utility.arg.requirements] change Table 33: <tt>MoveConstructible</tt> requirements [moveconstructible]:
</p>

<blockquote>
<table border="1">
<tbody><tr>
<th>expression</th><th>post-condition</th>
</tr>
<tr>
<td><tt>T t<ins>(rv)</ins><del> = rv</del></tt></td><td><tt>t</tt> is equivalent to the value of <tt>rv</tt> before the construction</td>
</tr>
<tr>
<td colspan="2" align="center">...</td>
</tr>
</tbody></table>
</blockquote>

<p>
In X [utility.arg.requirements] change Table 34: <tt>CopyConstructible</tt> requirements [copyconstructible]:
</p>

<blockquote>
<table border="1">
<tbody><tr>
<th>expression</th><th>post-condition</th>
</tr>
<tr>
<td><tt>T t<ins>(u)</ins><del> = u</del></tt></td><td>the value of <tt>u</tt> is unchanged and is equivalent to <tt>t</tt></td>
</tr>
<tr>
<td colspan="2" align="center">...</td>
</tr>
</tbody></table>
</blockquote>

<p><i>[
Post Summit:
]</i></p>


<blockquote>
<p>
Alisdair: Proposed resolution kinda funky as these tables no longer
exist. Move from direct init to copy init. Clarify with Doug, recommends
NAD.
</p>
<p>
Walter: Suggest NAD via introduction of concepts.
</p>
<p>
Recommend close as NAD.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Recommend close as NAD.
</p>





<hr>
<h3><a name="825"></a>825. Missing rvalues reference stream insert/extract operators?</h3>
<p><b>Section:</b> 19.5.2.2 [syserr.errcode.overview], 20.8.13.2.8
[util.smartptr.shared.io], 22.4.8 [facets.examples], 20.3.6.3
[bitset.operators], 26.4.6 [complex.ops], 27.6 [stream.buffers], 28.10
[re.submatch] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">Tentatively NAD Editorial</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2008-04-10  <b>Last modified:</b> 2009-05-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20NAD%20Editorial">Tentatively NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Should the following use rvalues references to stream in insert/extract
operators?
</p>

<ul>
<li>19.5.2.2 [syserr.errcode.overview]</li>
<li>20.8.13.2.8 [util.smartptr.shared.io]</li>
<li>22.4.8 [facets.examples]</li>
<li>20.3.6.3 [bitset.operators]</li>
<li>26.4.6 [complex.ops]</li>
<li>Doubled signatures in 27.6 [stream.buffers] for character inserters
(ref 27.7.2.6.4 [ostream.inserters.character])
+ definition 27.7.2.6.4 [ostream.inserters.character]</li>
<li>28.10 [re.submatch]</li>
</ul>

<p><i>[
Sophia Antipolis
]</i></p>


<blockquote>
Agree with the idea in the issue, Alisdair to provide wording.
</blockquote>

<p><i>[
Daniel adds 2009-02-14:
]</i></p>


<blockquote>
The proposal given in the paper
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2831.html">N2831</a>
apparently resolves this issue.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
The cited paper is an earlier version of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2844.html">N2844</a>,
which changed the rvalue reference binding rules.
That paper includes generic templates
<tt>operator&lt;&lt;</tt> and <tt>operator&gt;&gt;</tt>
that adapt rvalue streams.
</p>
<p>
We therefore agree with Daniel's observation.
Move to NAD Editorial.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="827"></a>827. <tt>constexpr shared_ptr::shared_ptr()?</tt></h3>
<p><b>Section:</b> 20.8.13.2.1 [util.smartptr.shared.const] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Peter Dimov <b>Opened:</b> 2008-04-11  <b>Last modified:</b> 2009-05-30</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#util.smartptr.shared.const">active issues</a> in [util.smartptr.shared.const].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#util.smartptr.shared.const">issues</a> in [util.smartptr.shared.const].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Would anyone object to making the default constructor of <tt>shared_ptr</tt> (and
<tt>weak_ptr</tt> and <tt>enable_shared_from_this) constexpr</tt>? This would enable
static initialization for <tt>shared_ptr</tt> variables, eliminating another
unfair advantage of raw pointers.
</p>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
<p>
It's not clear to us that you can initialize a pointer with the literal
0 in a constant expression. We need to ask CWG to make sure this works.
Bjarne has been appointed to do this.
</p>
<p>
Core got back to us and assured as that <tt>nullptr</tt> would do the job
nicely here.
</p>
</blockquote>

<p><i>[
2009-05-01 Alisdair adds:
]</i></p>


<blockquote>
<p>
I don't believe that constexpr will buy anything in this case.
<tt>shared_ptr/weak_ptr/enable_shared_from_this</tt> cannot be literal types as they
have a non-trivial copy constructor.  As they do not produce literal types,
then the constexpr default constructor will <em>not</em> guarantee constant
initialization, and so not buy the hoped for optimization.
</p>
<p>
I recommend referring this back to Core to see if we can get static
initialization for types with constexpr constructors, even if they are not
literal types.  Otherwise this should be closed as NAD.
</p>
</blockquote>

<p><i>[
2009-05-26 Daniel adds:
]</i></p>


<blockquote>
If Alisdair's 2009-05-01 comment is correct, wouldn't that also make
<tt>constexpr mutex()</tt> useless, because this class has a non-trivial
destructor? (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#828">828</a>)

</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="828"></a>828. Static initialization for <tt>std::mutex</tt>?</h3>
<p><b>Section:</b> 30.4.1.1 [thread.mutex.class] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Review">Review</a>
 <b>Submitter:</b> Peter Dimov <b>Opened:</b> 2008-04-18  <b>Last modified:</b> 2009-05-30</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#thread.mutex.class">active issues</a> in [thread.mutex.class].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.mutex.class">issues</a> in [thread.mutex.class].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Review">Review</a> status.</p>
<p><b>Discussion:</b></p>
<p>
[Note: I'm assuming here that 3.6.2 [basic.start.init]/1 will be fixed.]
</p>
<p>
Currently <tt>std::mutex</tt> doesn't support static initialization. This is a
regression with respect to <tt>pthread_mutex_t</tt>, which does. I believe that
we should strive to eliminate such regressions in expressive power where
possible, both to ease migration and to not provide incentives to (or
force) people to forego the C++ primitives in favor of pthreads.
</p>

<p><i>[
Sophia Antipolis:
]</i></p>


<blockquote>
<p>
We believe this is implementable on POSIX, because the initializer-list
feature and the constexpr feature make this work. Double-check core
language about static initialization for this case. Ask core for a core
issue about order of destruction of statically-initialized objects wrt.
dynamically-initialized objects (should come afterwards). Check
non-POSIX systems for implementability.
</p>
<p>
If ubiquitous implementability cannot be assured, plan B is to introduce
another constructor, make this constexpr, which is
conditionally-supported. To avoid ambiguities, this new constructor needs
to have an additional parameter.
</p>
</blockquote>

<p><i>[
Post Summit:
]</i></p>


<blockquote>
<p>
Jens: constant initialization seems to be ok core-language wise
</p>
<p>
Consensus: Defer to threading experts, in particular a Microsoft platform expert.
</p>
<p>
Lawrence to send e-mail to Herb Sutter, Jonathan Caves, Anthony Wiliams,
Paul McKenney, Martin Tasker, Hans Boehm, Bill Plauger, Pete Becker,
Peter Dimov to alert them of this issue.
</p>
<p>
Lawrence: What about header file shared with C? The initialization
syntax is different in C and C++.
</p>
<p>
Recommend Keep in Review
</p>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Keep in Review status pending feedback from members of the Concurrency subgroup.
</blockquote>

<p><i>[
See related comments from Alisdiar and Daniel in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#827">827</a>.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
Change 30.4.1.1 [thread.mutex.class]:
</p>

<blockquote><pre>class mutex {
public:
  <ins>constexpr</ins> mutex();
  ...
</pre></blockquote>





<hr>
<h3><a name="830"></a>830. Incomplete list of char_traits specializations</h3>
<p><b>Section:</b> 21.2 [char.traits] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">Tentatively NAD Editorial</a>
 <b>Submitter:</b> Dietmar Khl <b>Opened:</b> 2008-04-23  <b>Last modified:</b> 2009-05-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#char.traits">issues</a> in [char.traits].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20NAD%20Editorial">Tentatively NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
  Paragraph 4 of 21.2 [char.traits] mentions that this
  section specifies two specializations (<code>char_traits&lt;char&gt;</code>
  and (<code>char_traits&lt;wchar_t&gt;</code>). However, there are actually
  four specializations provided, i.e. in addition to the two above also
  <code>char_traits&lt;char16_t&gt;</code> and <code>char_traits&lt;char32_t&gt;</code>).
  I guess this was just an oversight and there is nothing wrong with just
  fixing this.
</p>

<p><i>[
Alisdair adds:
]</i></p>

<blockquote>
<tt>char_traits&lt; char16/32_t &gt;</tt>
should also be added to <tt>&lt;ios_fwd&gt;</tt> in 27.3 [iostream.forward], and all the specializations
taking a <tt>char_traits</tt> parameter in that header.
</blockquote>

<p><i>[
Sophia Antipolis:
]</i></p>


<blockquote>
<p>
Idea of the issue is ok.
</p>
<p>
Alisdair to provide wording, once that wording arrives, move to review.
</p>

</blockquote>

<p><i>[
2009-05-04 Alisdair adds:
]</i></p>


<blockquote>
<p>
The main point of the issue was resolved editorially in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2723.pdf">N2723</a>,
so we are
close to NAD Editorial.
However, exploring the issue we found a second tweak was necessary for
<tt>&lt;iosfwd&gt;</tt> and that is still outstanding, so here are the words I am long
overdue delivering:
</p>

<p><i>[
Howard:  I've put Alisdair's words into the proposed wording section and
moved the issue to Review.
]</i></p>


</blockquote>

<p><i>[
Original proposed wording.
]</i></p>


<blockquote>

<p>
  Replace paragraph 4 of 21.2 [char.traits] by:
</p>
<blockquote>
<p>
  This subclause specifies a struct template, <code>char_traits&lt;charT&gt;</code>,
  and four explicit specializations of it, <code>char_traits&lt;char&gt;</code>,
  <code>char_traits&lt;char16_t&gt;</code>, <code>char_traits&lt;char32_t&gt;</code>, and
  <code>char_traits&lt;wchar_t&gt;</code>, all of which appear in the header
  &lt;string&gt; and satisfy the requirements below.
</p>
</blockquote>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree.  Move to NAD Editorial.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change Forward declarations 27.3 [iostream.forward]:
</p>

<blockquote>
<p>
<b>Header <tt>&lt;iosfwd&gt;</tt> synopsis</b>
</p>
<pre>namespace std {
   template&lt;class charT&gt; class char_traits;
   template&lt;&gt; class char_traits&lt;char&gt;;
   <ins>template&lt;&gt; class char_traits&lt;char16_t&gt;;</ins>
   <ins>template&lt;&gt; class char_traits&lt;char32_t&gt;;</ins>
   template&lt;&gt; class char_traits&lt;wchar_t&gt;;
...
}
</pre>
</blockquote>





<hr>
<h3><a name="833"></a>833. Freestanding implementations header list needs review for C++0x</h3>
<p><b>Section:</b> 17.6.1.3 [compliance] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Beman Dawes <b>Opened:</b> 2008-05-14  <b>Last modified:</b> 2009-03-11</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#compliance">active issues</a> in [compliance].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#compliance">issues</a> in [compliance].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Once the C++0x standard library is feature complete, the LWG needs to
review 17.6.1.3 [compliance] Freestanding implementations header list to
ensure it reflects LWG consensus.
</p>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
<p>
This is a placeholder defect to remind us to review the table once we've
stopped adding headers to the library.
</p>
<p>
Three new headers that need to be added to the list:
</p>
<blockquote><pre>&lt;initializer_list&gt; &lt;concept&gt; &lt;iterator_concepts&gt;
</pre></blockquote>
<p>
<tt>&lt;iterator_concepts&gt;</tt>, in particular, has lots of stuff
that isn't needed, so maybe the stuff that is needed should be broken
out into a separate header.
</p>
<p>
Robert: What about <tt>reference_closure</tt>? It's currently in
<tt>&lt;functional&gt;</tt>.
</p>
</blockquote>

<p><i>[
Post Summit Daniel adds:
]</i></p>


<blockquote>
<ol>
<li>
The comment regarding <tt>reference_closure</tt> seems moot since it was just
recently decided to remove that.
</li>
<li>
A reference to proposal
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2814.pdf">N2814</a>
("Fixing freestanding") should be added. This
paper e.g. proposes to add only <tt>&lt;initializer_list&gt;</tt> to the include list
of freestanding.
</li>
</ol>
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="834"></a>834. Unique_ptr::pointer requirements underspecified</h3>
<p><b>Section:</b> 20.8.12.2 [unique.ptr.single] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2008-05-14  <b>Last modified:</b> 2008-06-19</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#unique.ptr.single">active issues</a> in [unique.ptr.single].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#unique.ptr.single">issues</a> in [unique.ptr.single].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#673">673</a> (including recent updates by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#821">821</a>) proposes a useful
extension point for <tt>unique_ptr</tt> by granting support for an optional
<tt>deleter_type::pointer</tt> to act as pointer-like replacement for <tt>element_type*</tt>
(In the following: <tt>pointer</tt>).
</p>
<p>
Unfortunately no requirements are specified for the type <tt>pointer</tt> which has
impact on at least two key features of <tt>unique_ptr</tt>:
</p>

<ol>
<li>Operational fail-safety.</li>
<li>(Well-)Definedness of expressions.</li>
</ol>

<p>
<tt>Unique_ptr</tt> specification makes great efforts to require that essentially *all*
operations cannot throw and therefore adds proper wording to the affected
operations of the deleter as well. If user-provided <tt>pointer</tt>-emulating types
("smart pointers") will be allowed, either *all* throw-nothing clauses have to
be replaced by weaker "An exception is thrown only if <tt>pointer</tt>'s {op} throws
an exception"-clauses or it has to be said explicitly that all used
operations of
<tt>pointer</tt> are required *not* to throw. I understand the main focus of <tt>unique_ptr</tt>
to be as near as possible to the advantages of native pointers which cannot
fail and thus strongly favor the second choice. Also, the alternative position
would make it much harder to write safe and simple template code for
<tt>unique_ptr</tt>. Additionally, I assume that a general statement need to be given
that all of the expressions of <tt>pointer</tt> used to define semantics are required to
be well-formed and well-defined (also as back-end for <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#762">762</a>).
</p>

<p><i>[
Sophia Antipolis:
]</i></p>


<blockquote>
<p>
Howard: We maybe need a core concept <tt>PointerLike</tt>, but we don't need the
arithmetic (see <tt>shared_ptr</tt> vs. <tt>vector&lt;T&gt;::iterator</tt>.
</p>
<p>
Howard will go through and enumerate the individual requirements wrt. <tt>pointer</tt> for each member function.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add the following sentence just at the end of the newly proposed
20.8.12.2 [unique.ptr.single]/p. 3:
</p>

<blockquote>
<tt>unique_ptr&lt;T, D&gt;::pointer</tt>'s operations shall be well-formed, shall have well
defined behavior, and shall not throw exceptions.
</blockquote>





<hr>
<h3><a name="835"></a>835. tying two streams together (correction to DR 581)</h3>
<p><b>Section:</b> 27.5.4.2 [basic.ios.members] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Review">Review</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2008-05-17  <b>Last modified:</b> 2009-05-30</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#basic.ios.members">active issues</a> in [basic.ios.members].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#basic.ios.members">issues</a> in [basic.ios.members].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Review">Review</a> status.</p>
<p><b>Discussion:</b></p>
       <p>

The fix for
issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#581">581</a>,
now integrated into the working paper, overlooks a couple of minor
problems.

       </p>
       <p>

First, being an unformatted function once again, <code>flush()</code>
is required to create a sentry object whose constructor must, among
other things, flush the tied stream. When two streams are tied
together, either directly or through another intermediate stream
object, flushing one will also cause a call to <code>flush()</code> on
the other tied stream(s) and vice versa, ad infinitum. The program
below demonstrates the problem.

       </p>
       <p>

Second, as Bo Persson notes in his
comp.lang.c++.moderated <a href="http://groups.google.com/group/comp.lang.c++.moderated/tree/browse_frm/thread/f2187794e9cc036d/305df31dc583054a">post</a>,
for streams with the <code>unitbuf</code> flag set such
as <code>std::stderr</code>, the destructor of the sentry object will
again call <code>flush()</code>. This seems to create an infinite
recursion for <code>std::cerr &lt;&lt; std::flush;</code>

       </p>
       <blockquote>
           <pre>#include &lt;iostream&gt;

int main ()
{
   std::cout.tie (&amp;std::cerr);
   std::cerr.tie (&amp;std::cout);
   std::cout &lt;&lt; "cout\n";
   std::cerr &lt;&lt; "cerr\n";
} 
</pre>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution.
Move to Review.
</blockquote>

<p><i>[
2009-05-26 Daniel adds:
]</i></p>


<blockquote>
<p>
I think that the most recently suggested change in
27.7.2.4 [ostream::sentry] need some further word-smithing. As
written, it would make the behavior undefined, if under
conditions when <tt>pubsync()</tt> should be called, but when
in this scenario <tt>os.rdbuf()</tt> returns 0.
</p>
<p>
This case is explicitly handled in <tt>flush()</tt> and needs to be
taken care of. My suggested fix is:
</p>

<blockquote>
If <tt>((os.flags() &amp; ios_base::unitbuf) &amp;&amp; !uncaught_exception()</tt>
<ins><tt>&amp;&amp; os.rdbuf() != 0</tt></ins>) is true, calls <del><tt>os.flush()</tt></del>
<ins><tt>os.rdbuf()-&gt;pubsync()</tt></ins>.
</blockquote>

<p>
Two secondary questions are:
</p>

<ol>
<li>
Should <tt>pubsync()</tt> be invoked in any case or shouldn't a
base requirement for this trial be that <tt>os.good() == true</tt>
as required in the original <tt>flush()</tt> case?
</li>
<li>
Since <tt>uncaught_exception()</tt> is explicitly tested, shouldn't
a return value of -1 of <tt>pubsync()</tt> produce <tt>setstate(badbit)</tt>
(which may throw <tt>ios_base::failure</tt>)?
</li>
</ol>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>

I think an easy way to plug the first hole is to add a requires clause
to <code>ostream::tie(ostream *tiestr)</code> requiring the this
pointer not be equal to any pointer on the list starting
with <code>tiestr-&gt;tie()</code>
through <code>tiestr()-&gt;tie()-&gt;tie()</code> and so on. I am not
proposing that we require implementations to traverse this list,
although I think we could since the list is unlikely to be very long.

       </p>
       <p>

Add a <i>Requires</i> clause to 27.5.4.2 [basic.ios.members] withethe following
text:

       </p>
       <blockquote>

<i>Requires:</i> If <code>(tiestr != 0)</code> is
true, <code>tiestr</code> must not be reachable by traversing the
linked list of tied stream objects starting
from <code>tiestr-&gt;tie()</code>.

       </blockquote>
       <p>

In addition, to prevent the infinite recursion that Bo writes about in
his comp.lang.c++.moderated post, I propose to change
27.7.2.4 [ostream::sentry], p2 like so:

       </p>
       <blockquote>

If <code>((os.flags() &amp; ios_base::unitbuf) &amp;&amp;
!uncaught_exception())</code> is true,
calls <del>os.flush()</del> <ins><code>os.rdbuf()-&gt;pubsync()</code></ins>.

       </blockquote>
   



<hr>
<h3><a name="836"></a>836. 
       effects of <code>money_base::space</code> and
       <code>money_base::none</code> on <code>money_get</code>
   </h3>
<p><b>Section:</b> 22.4.6.1.2 [locale.money.get.virtuals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2008-05-17  <b>Last modified:</b> 2008-09-22</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#locale.money.get.virtuals">active issues</a> in [locale.money.get.virtuals].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.money.get.virtuals">issues</a> in [locale.money.get.virtuals].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#670">670</a></p>
<p><b>Discussion:</b></p>

       <p>

In paragraph 2, 22.4.6.1.2 [locale.money.get.virtuals] specifies the following:

       </p>
       <blockquote>

Where <code>space</code> or <code>none</code> appears in the format
pattern, except at the end, optional white space (as recognized
by <code>ct.is</code>) is consumed after any required space.

       </blockquote>
       <p>

This requirement can be (and has been) interpreted two mutually
exclusive ways by different readers. One possible interpretation
is that:

       </p>
       <blockquote>
           <ol>
               <li>

where <code>money_base::space</code> appears in the format, at least
one space is required, and

               </li>
               <li>

where <code>money_base::none</code> appears in the format, space is
allowed but not required.

               </li>
           </ol>
       </blockquote>
       <p>

The other is that:

       </p>
       <blockquote>

where either <code>money_base::space</code> or <code>money_base::none</code> appears in the format, white space is optional.

       </blockquote>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
Martin will revise the proposed resolution.
</blockquote>
   

   <p><b>Proposed resolution:</b></p>
       <p>

I propose to change the text to make it clear that the first
interpretation is intended, that is, to make following change to
22.4.6.1.2 [locale.money.get.virtuals], p2:

       </p>

       <blockquote>

When <code><ins>money_base::</ins>space</code>
or <code><ins>money_base::</ins>none</code> appears <ins>as the last
element </ins>in the format pattern, <del>except at the end, optional
white space (as recognized by <code>ct.is</code>) is consumed after
any required space.</del> <ins>no white space is consumed. Otherwise,
where <code>money_base::space</code> appears in any of the initial
elements of the format pattern, at least one white space character is
required. Where <code>money_base::none</code> appears in any of the
initial elements of the format pattern, white space is allowed but not
required. In either case, any required followed by all optional white
space (as recognized by <code>ct.is()</code>) is consumed.</ins>
If <code>(str.flags() &amp; str.showbase)</code> is <code>false</code>, ...

       </blockquote>
   



<hr>
<h3><a name="837"></a>837. 
   <code>basic_ios::copyfmt()</code> overly loosely specified
 </h3>
<p><b>Section:</b> 27.5.4.2 [basic.ios.members] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">Tentatively NAD Editorial</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2008-05-17  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#basic.ios.members">active issues</a> in [basic.ios.members].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#basic.ios.members">issues</a> in [basic.ios.members].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20NAD%20Editorial">Tentatively NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
   <p>

The <code>basic_ios::copyfmt()</code> member function is specified in 27.5.4.2 [basic.ios.members] to have the following effects:

   </p>
   <blockquote>

<i>Effects</i>: If <code>(this == &amp;rhs)</code> does
nothing. Otherwise assigns to the member objects of <code>*this</code>
the corresponding member objects of <code>rhs</code>, except that

     <ul>
       <li>

<code>rdstate()</code> and <code>rdbuf()</code> are left unchanged;

       </li>
       <li>

<code>exceptions()</code> is altered last by
calling <code>exceptions(rhs.except)</code>

       </li>
       <li>

the contents of arrays pointed at by <code>pword</code>
and <code>iword</code> are copied not the pointers themselves

       </li>
     </ul>
   </blockquote>
   <p>

Since the rest of the text doesn't specify what the member objects
of <code>basic_ios</code> are this seems a little too loose.

</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution.
Move to NAD Editorial.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>

I propose to tighten things up by adding a <i>Postcondition</i> clause
to the function like so:

   </p>
   <blockquote>
     <i>Postconditions:</i>

     <table border="1">
       <thead>
         <tr>
           <th colspan="2"><code>copyfmt()</code> postconditions</th>
         </tr>
         <tr>
           <th>Element</th>
           <th>Value</th>
         </tr>
       </thead>
       <tbody>
         <tr>
           <td><code>rdbuf()</code></td>
           <td><i>unchanged</i></td>
         </tr>
         <tr> 
           <td><code>tie()</code></td>
           <td><code>rhs.tie()</code></td>
         </tr>
         <tr> 
           <td><code>rdstate()</code></td>
           <td><i>unchanged</i></td>
         </tr>
         <tr> 
           <td><code>exceptions()</code></td>
           <td><code>rhs.exceptions()</code></td>
         </tr>
         <tr> 
           <td><code>flags()</code></td>
           <td><code>rhs.flags()</code></td>
         </tr>
         <tr> 
           <td><code>width()</code></td>
           <td><code>rhs.width()</code></td>
         </tr>
         <tr> 
           <td><code>precision()</code></td>
           <td><code>rhs.precision()</code></td>
         </tr>
         <tr> 
           <td><code>fill()</code></td>
           <td><code>rhs.fill()</code></td>
         </tr>
         <tr> 
           <td><code>getloc()</code></td>
           <td><code>rhs.getloc()</code></td>
         </tr>
       </tbody>
     </table>
   </blockquote>
   <p>

The format of the table follows Table 117 (as
of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2588.pdf">N2588</a>): <code>basic_ios::init()</code>
effects.

   </p>
   <p>

The intent of the new table is not to impose any new requirements or
change existing ones, just to be more explicit about what I believe is
already there.

   </p>
 



<hr>
<h3><a name="838"></a>838. 
   can an <i>end-of-stream</i> iterator become a <i>non-end-of-stream</i> one?
 </h3>
<p><b>Section:</b> 24.6.1 [istream.iterator] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2008-05-17  <b>Last modified:</b> 2008-10-27</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#istream.iterator">active issues</a> in [istream.iterator].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#istream.iterator">issues</a> in [istream.iterator].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
   <p>

From message c++std-lib-20003...

   </p>
   <p>

The description of <code>istream_iterator</code> in
24.6.1 [istream.iterator], p1 specifies that objects of the
class become the <i>end-of-stream</i> (EOS) iterators under the
following condition (see also issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#788">788</a> another problem
with this paragraph):

   </p>
   <blockquote>

If the end of stream is reached (<code>operator void*()</code> on the
stream returns <code>false</code>), the iterator becomes equal to
the <i>end-of-stream</i> iterator value.

   </blockquote>
   <p>

One possible implementation approach that has been used in practice is
for the iterator to set its <code>in_stream</code> pointer to 0 when
it reaches the end of the stream, just like the default ctor does on
initialization. The problem with this approach is that
the <i>Effects</i> clause for <code>operator++()</code> says the
iterator unconditionally extracts the next value from the stream by
evaluating <code>*in_stream &gt;&gt; value</code>, without checking
for <code>(in_stream == 0)</code>.

   </p>
   <p>

Conformance to the requirement outlined in the <i>Effects</i> clause
can easily be verified in programs by setting <code>eofbit</code>
or <code>failbit</code> in <code>exceptions()</code> of the associated
stream and attempting to iterate past the end of the stream: each
past-the-end access should trigger an exception. This suggests that
some other, more elaborate technique might be intended.

   </p>
   <p>

Another approach, one that allows <code>operator++()</code> to attempt
to extract the value even for EOS iterators (just as long
as <code>in_stream</code> is non-0) is for the iterator to maintain a
flag indicating whether it has reached the end of the stream. This
technique would satisfy the presumed requirement implied by
the <i>Effects</i> clause mentioned above, but it isn't supported by
the exposition-only members of the class (no such flag is shown). This
approach is also found in existing practice.

   </p>
   <p>

The inconsistency between existing implementations raises the question
of whether the intent of the specification is that a non-EOS iterator
that has reached the EOS become a non-EOS one again after the
stream's <code>eofbit</code> flag has been cleared? That is, are the
assertions in the program below expected to pass?

   </p>
   <blockquote>
     <pre>   sstream strm ("1 ");
   istream_iterator eos;
   istream_iterator it (strm);
   int i;
   i = *it++
   assert (it == eos);
   strm.clear ();
   strm &lt;&lt; "2 3 ";
   assert (it != eos);
   i = *++it;
   assert (3 == i);
     </pre>
   </blockquote>
   <p>

Or is it intended that once an iterator becomes EOS it stays EOS until
the end of its lifetime?

   </p>
 
 <p><i>[
San Francisco:
]</i></p>


<blockquote>
<p>
We like the direction of the proposed resolution. We're not sure about
the wording, and we need more time to reflect on it,
</p>
<p>
Move to Open. Detlef to rewrite the proposed resolution in such a way
that no reference is made to exposition only members of
<tt>istream_iterator</tt>.
</p>
</blockquote>


 <p><b>Proposed resolution:</b></p>
   <p>

The discussion of this issue on the reflector suggests that the intent
of the standard is for an <code>istreambuf_iterator</code> that has
reached the EOS to remain in the EOS state until the end of its
lifetime. Implementations that permit EOS iterators to return to a
non-EOS state may only do so as an extension, and only as a result of
calling <code>istream_iterator</code> member functions on EOS
iterators whose behavior is in this case undefined.

   </p>
   <p>

To this end we propose to change 24.6.1 [istream.iterator], p1,
as follows:

   </p>
   <blockquote>

The result of operator-&gt; on an end<ins>-</ins>of<ins>-</ins>stream
is not defined. For any other iterator value a <code>const T*</code>
is returned.<ins> Invoking <code>operator++()</code> on
an <i>end-of-stream</i> iterator is undefined.</ins> It is impossible
to store things into istream iterators...

   </blockquote>
   <p>

Add pre/postconditions to the member function descriptions of <code>istream_iterator</code> like so:

   </p>
   <blockquote>

<pre>istream_iterator();</pre>

<i>Effects</i>: Constructs the <i>end-of-stream</i> iterator.<br>
<ins><i>Postcondition</i>: <code>in_stream == 0</code>.</ins>

<pre>istream_iterator(istream_type &amp;s);</pre>

<i>Effects</i>: Initializes <code>in_stream</code> with &amp;s. value
may be initialized during construction or the first time it is
referenced.<br>
<ins><i>Postcondition</i>: <code>in_stream == &amp;s</code>.</ins>

<pre>istream_iterator(const istream_iterator &amp;x);</pre>

<i>Effects</i>: Constructs a copy of <code>x</code>.<br>
<ins><i>Postcondition</i>: <code>in_stream == x.in_stream</code>.</ins>

<pre>istream_iterator&amp; operator++();</pre>

<ins><i>Requires</i>: <code>in_stream != 0</code>.</ins><br>
<i>Effects</i>: <code>*in_stream &gt;&gt; value</code>.

<pre>istream_iterator&amp; operator++(int);</pre>

<ins><i>Requires</i>: <code>in_stream != 0</code>.</ins><br>
<i>Effects</i>:
   <blockquote><pre>istream_iterator tmp (*this);
*in_stream &gt;&gt; value;
return tmp;
     </pre>
     </blockquote>
   </blockquote>
 



<hr>
<h3><a name="839"></a>839. Maps and sets missing splice operation</h3>
<p><b>Section:</b> 23.4 [associative], 23.5 [unord] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alan Talbot <b>Opened:</b> 2008-05-18  <b>Last modified:</b> 2008-09-22</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#associative">active issues</a> in [associative].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#associative">issues</a> in [associative].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Splice is a very useful feature of <tt>list</tt>. This functionality is also very
useful for any other node based container, and I frequently wish it were
available for maps and sets. It seems like an omission that these
containers lack this capability. Although the complexity for a splice is
the same as for an insert, the actual time can be much less since the
objects need not be reallocated and copied. When the element objects are
heavy and the compare operations are fast (say a <tt>map&lt;int, huge_thingy&gt;</tt>)
this can be a big win.
</p>

<p>
<b>Suggested resolution:</b>
</p>

<p>
Add the following signatures to map, set, multimap, multiset, and the unordered associative containers:
</p>
<blockquote><pre> 
void splice(list&lt;T,Allocator&gt;&amp;&amp; x);
void splice(list&lt;T,Allocator&gt;&amp;&amp; x, const_iterator i);
void splice(list&lt;T,Allocator&gt;&amp;&amp; x, const_iterator first, const_iterator last);
</pre></blockquote>

<p>
Hint versions of these are also useful to the extent hint is useful.
(I'm looking for guidance about whether hints are in fact useful.)
</p>
 
<blockquote><pre> 
void splice(const_iterator position, list&lt;T,Allocator&gt;&amp;&amp; x);
void splice(const_iterator position, list&lt;T,Allocator&gt;&amp;&amp; x, const_iterator i);
void splice(const_iterator position, list&lt;T,Allocator&gt;&amp;&amp; x, const_iterator first, const_iterator last);
</pre></blockquote>

<p><i>[
Sophia Antipolis:
]</i></p>


<blockquote>
<p>
Don't try to <tt>splice "list"</tt> into the other containers, it should be container-type.
</p>
<p>
<tt>forward_list</tt> already has <tt>splice_after</tt>.
</p>
<p>
Would "<tt>splice</tt>" make sense for an <tt>unordered_map</tt>?
</p>
<p>
Jens, Robert: "<tt>splice</tt>" is not the right term, it implies maintaining ordering in <tt>list</tt>s.
</p>
<p>
Howard: <tt>adopt</tt>?
</p>
<p>
Jens: <tt>absorb</tt>?
</p>
<p>
Alan: <tt>subsume</tt>?
</p>
<p>
Robert: <tt>recycle</tt>?
</p>
<p>
Howard: <tt>transfer</tt>? (but no direction)
</p>
<p>
Jens: <tt>transfer_from</tt>. No.
</p>
<p>
Alisdair: Can we give a nothrow guarantee? If your <tt>compare()</tt> and <tt>hash()</tt> doesn't throw, yes.
</p>
<p>
Daniel: For <tt>unordered_map</tt>, we can't guarantee nothrow.
</p>
</blockquote>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
<p>
Martin: this would possibly outlaw an implementation technique that is
currently in use; caching nodes in containers.
</p>
<p>
Alan: if you cache in the allocator, rather than the individual
container, this proposal doesn't interfere with that.
</p>
<p>
Martin: I'm not opposed to this, but I'd like to see an implementation
that demonstrates that it works.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="847"></a>847. string exception safety guarantees</h3>
<p><b>Section:</b> 21.4.1 [string.require] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Herv Brnnimann <b>Opened:</b> 2008-06-05  <b>Last modified:</b> 2009-02-14</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#string.require">active issues</a> in [string.require].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#string.require">issues</a> in [string.require].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In March, on comp.lang.c++.moderated, I asked what were the
string exception safety guarantees are, because I cannot see
*any* in the working paper, and any implementation I know offers
the strong exception safety guarantee (string unchanged if a
member throws exception). The closest the current draft comes to
offering any guarantees is 21.4 [basic.string], para 3:
</p>

<blockquote>
The class template <tt>basic_string</tt> conforms to the requirements
for a Sequence Container (23.1.1), for a Reversible Container (23.1),
and for an Allocator-aware container (91). The iterators supported by
<tt>basic_string</tt> are random access iterators (24.1.5).
</blockquote>

<p>
However, the chapter 23 only says, on the topic of exceptions:  23.2 [container.requirements],
para 10:
</p>

<blockquote>
<p>
Unless otherwise specified (see 23.2.2.3 and 23.2.6.4) all container types defined in this clause meet the following 
additional requirements:
</p>

<ul>
<li>if an exception is thrown by...</li>
</ul>
</blockquote>

<p>
I take it  as saying that this paragraph has *no* implication on
<tt>std::basic_string</tt>, as <tt>basic_string</tt> isn't defined in Clause 23 and
this paragraph does not define a *requirement* of Sequence
nor Reversible Container, just of the models defined in Clause 23.
In addition, LWG Issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#718">718</a> proposes to remove 23.2 [container.requirements], para 3.
</p>

<p>
Finally, the fact that no operation on Traits should throw
exceptions has no bearing, except to suggest (since the only
other throws should be allocation, <tt>out_of_range</tt>, or <tt>length_error</tt>)
that the strong exception guarantee can be achieved.
</p>

<p>
The reaction in that group by Niels Dekker, Martin Sebor, and
Bo Persson, was all that this would be worth an LWG issue.
</p>

<p>
A related issue is that <tt>erase()</tt> does not throw.  This should be
stated somewhere (and again, I don't think that the 23.2 [container.requirements], para 1
applies here).
</p>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
Implementors will study this to confirm that it is actually possible.
</blockquote>

<p><i>[
Daniel adds 2009-02-14:
]</i></p>


<blockquote>
The proposed resolution of paper
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2815.html">N2815</a>
interacts with this issue (the paper does not refer to this issue).
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add a blanket statement in 21.4.1 [string.require]:
</p>

<blockquote>
<p>
- if any member function or operator of <tt>basic_string&lt;charT, traits, Allocator&gt;</tt>
throws, that function or operator has no effect.
</p>
<p>
- no <tt>erase()</tt> or <tt>pop_back()</tt> function throws.
</p>
</blockquote>

<p>
As far as I can tell, this is achieved by any implementation.  If I made a
mistake and it is not possible to offer this guarantee, then
either state all the functions for which this is possible
(certainly at least <tt>operator+=</tt>, <tt>append</tt>, <tt>assign</tt>, and <tt>insert</tt>),
or add paragraphs to Effects clauses wherever appropriate.
</p>





<hr>
<h3><a name="851"></a>851. simplified array construction</h3>
<p><b>Section:</b> 23.3.1 [array] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Benjamin Kosnik <b>Opened:</b> 2008-06-05  <b>Last modified:</b> 2009-06-10</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#array">active issues</a> in [array].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#array">issues</a> in [array].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
This is an issue that came up on the libstdc++ list, where a
discrepancy between "C" arrays and C++0x's <tt>std::array</tt> was pointed
out.
</p>

<p>
In "C," this array usage is possible:
</p>

<blockquote><pre>int ar[] = {1, 4, 6};
</pre></blockquote>

<p>
But for C++, 
</p>

<blockquote><pre>std::array&lt;int&gt; a = { 1, 4, 6 }; // error
</pre></blockquote>

<p>
Instead, the second parameter of the <tt>array</tt> template must be
explicit, like so:
</p>

<blockquote><pre>std::array&lt;int, 3&gt; a = { 1, 4, 6 };
</pre></blockquote>

<p>
Doug Gregor proposes the following solution, that assumes
generalized initializer lists.
</p>

<blockquote><pre>template&lt;typename T, typename... Args&gt;
inline array&lt;T, sizeof...(Args)&gt; 
make_array(Args&amp;&amp;... args) 
{ return { std::forward&lt;Args&gt;(args)... };  }
</pre></blockquote>

<p>
Then, the way to build an <tt>array</tt> from a list of unknown size is:
</p>

<blockquote><pre>auto a = make_array&lt;T&gt;(1, 4, 6);
</pre></blockquote>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
<p>
Benjamin: Move to Ready?
</p>
<p>
Bjarne: I'm not convinced this is useful enough to add, so I'd like us
to have time to reflect on it.
</p>
<p>
Alisdair: the constraints are wrong, they should be
</p>
<blockquote><pre>template&lt;ValueType T, ValueType... Args&gt;
requires Convertible&lt;Args, T&gt;...
array&lt;T, sizeof...(Args)&gt; make_array(Args&amp;&amp;... args);
</pre></blockquote>
<p>
Alidair: this would be useful if we had a constexpr version.
</p>
<p>
Bjarne: this is probably useful for arrays with a small number of
elements, but it's not clearly useful otherwise.
</p>
<p>
Consensus is to move to Open.
</p>
</blockquote>

<p><i>[
2009-06-07 Daniel adds:
]</i></p>


<blockquote>
<p>
I suggest a fix and a simplification of the current proposal: Recent
prototyping by
Howard showed, that a fix is required because narrowing conversion
8.5.4 [dcl.init.list]/6 b.3
would severely limit the possible distribution of argument types, e.g.
the expression
<tt>make_array&lt;double&gt;(1, 2.0)</tt> is ill-formed, because the narrowing
happens <em>inside</em> the
function body where no constant expressions exist anymore. Furthermore
given e.g.
</p>
<blockquote><pre>int f();
double g();
</pre></blockquote>
<p>
we probably want to support
</p>
<blockquote><pre>make_array&lt;double&gt;(f(), g());
</pre></blockquote>

<p>
as well. To make this feasible, the currently suggested expansion
</p>

<blockquote><pre>{ std::forward&lt;Args&gt;(args)... }
</pre></blockquote>

<p>
needs to be replaced by
</p>

<blockquote><pre>{ static_cast&lt;T&gt;(std::forward&lt;Args&gt;(args))... }
</pre></blockquote>

<p>
which is safe, because we already ensure convertibility via the
element-wise <tt>Convertible&lt;Args, T&gt;</tt> requirement. Some other fixes are
necessary: The <tt>ValueType</tt> requirement for the function <em>parameters</em>
is invalid, because all lvalue arguments will deduce to an lvalue-reference,
thereby no longer satisfying this requirement.
</p>

<p>
The suggested simplification is to provide a default-computed effective
type for the result array based on common_type and decay, in
unconstrained form:
</p>

<blockquote><pre>template&lt;typename... Args&gt;
array&lt;typename decay&lt;typename common_type&lt;Args...&gt;::type&gt;::type,
sizeof...(Args)&gt;
make_array(Args&amp;&amp;... args);
</pre></blockquote>

<p>
The approach used below is similar to that of <tt>make_pair</tt> and <tt>make_tuple</tt>
using a symbol <tt>C</tt> to represent the decayed common type [Note: Special
handling of <tt>reference_wrapper</tt> types is intentionally <em>not</em> provided, because
our target has so satisfy <tt>ValueType</tt>, thus under the revised proposal only
an all-<tt>reference_wrapper</tt>-arguments would be well-formed and an array of
<tt>reference_wrapper</tt> will be constructed]. I do currently not suggest to
add new concepts reflecting <tt>decay</tt> and <tt>common_type</tt>, but an implementor will
need something like this to succeed. Note that we use a similar fuzziness for
<tt>make_pair</tt> and <tt>make_tuple</tt> currently. This fuzziness is not related to
the currently
missing <tt>Constructible&lt;Vi, Ti&amp;&amp;&gt;</tt> requirement for those functions. The following
proposal fixes that miss for <tt>make_array</tt>. If the corresponding <tt>C</tt> type
deduction is
explicitly wanted for standardization, here the implementation
</p>

<blockquote><pre>auto concept DC&lt;typename... T&gt; {
  typename type = typename decay&lt;typename common_type&lt;T...&gt;::type&gt;::type;
}
</pre></blockquote>

<p>
where <tt>C</tt> is identical to <tt>DC&lt;Args...&gt;::type</tt> in the proposed resolution below.
</p>
<p>
I intentionally added no further type relation between type and the concept
template parameters, but instead added this requirement below to make
the specification as transparent as possible. As written this concept is
satisfied, if the corresponding associated type exists.
</p>

<p><b>Suggested Resolution:</b></p>

<ol>
<li>
<p>
Add to the array synopsis in 23.3 [sequences]:
</p>
<blockquote><pre><ins>
template&lt;ReferentType... Args&gt;
requires ValueType&lt;C&gt; &amp;&amp; Constructible&lt;C, Args&amp;&amp;&gt;...
array&lt;C, sizeof...(Args)&gt;
make_array(Args&amp;&amp;... args);
</ins>
</pre></blockquote>
</li>

<li>
<p>
Append after 23.3.1.7 [array.tuple] Tuple interface to class template array
the following new section:
</p>
<blockquote>
<p>
23.4.1.7 Array creation functions [array.creation]
</p>

<pre><ins>
template&lt;ReferentType... Args&gt;
requires ValueType&lt;C&gt; &amp;&amp; Constructible&lt;C, Args&amp;&amp;&gt;...
array&lt;C, sizeof...(Args)&gt;
make_array(Args&amp;&amp;... args);</ins>
</pre>

<blockquote>
<p><ins>
Let <tt>C</tt> be <tt>decay&lt;common_type&lt;Args...&gt;::type&gt;::type</tt>.
</ins></p>
<p>
<ins><i>Returns:</i> an <tt>array&lt;C, sizeof...(Args)&gt;</tt> initialized with
<tt>{ static_cast&lt;C&gt;(std::forward&lt;Args&gt;(args))... }</tt>.
</ins></p>
</blockquote>
</blockquote>

</li>

</ol>

</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add to the <tt>array</tt> synopsis in 23.3 [sequences]:
</p>

<blockquote><pre>template&lt;ValueType T, ValueType... Args&gt;
  requires Convertible&lt;Args, T&gt;...
  array&lt;T, sizeof...(Args)&gt; 
  make_array(Args&amp;&amp;... args);
</pre></blockquote>

<p>
Append after 23.3.1.7 [array.tuple] Tuple interface to class template <tt>array</tt> the
following new section.
</p>

<blockquote>
<p>
23.2.1.7 Convenience interface to class template <tt>array</tt> [array.tuple]
</p>

<pre>template&lt;ValueType T, ValueType... Args&gt;
  requires Convertible&lt;Args, T&gt;...
  array&lt;T, sizeof...(Args)&gt; 
  make_array(Args&amp;&amp;... args);
</pre>

<blockquote>
<p>
<i>Returns:</i> an <tt>array&lt;T, sizeof...(Args)&gt;</tt> initialized with <tt>{std::forward&lt;T&gt;(args)...}</tt>.
</p>
</blockquote>
</blockquote>





<hr>
<h3><a name="853"></a>853. <tt>to_string</tt> needs updating with <tt>zero</tt> and <tt>one</tt></h3>
<p><b>Section:</b> 20.3.6 [template.bitset] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2008-06-18  <b>Last modified:</b> 2009-05-10</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#template.bitset">active issues</a> in [template.bitset].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#template.bitset">issues</a> in [template.bitset].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#396">396</a> adds defaulted arguments to the <tt>to_string</tt> member, but neglects to update
the three newer <tt>to_string</tt> overloads.
</p>

<p><i>[
post San Francisco:
]</i></p>


<blockquote>
Daniel found problems with the wording and provided fixes.  Moved from Ready
to Review.
</blockquote>

<p><i>[
Post Summit:
]</i></p>


<blockquote>
<p>
Alisdair: suggest to not repeat the default arguments in B, C, D
(definition of to_string members)
</p>
<p>
Walter: This is not really a definition.
</p>
<p>
Consensus: Add note to the editor: Please apply editor's judgement
whether default arguments should be repeated for B, C, D changes.
</p>
<p>
Recommend Tentatively Ready.
</p>
</blockquote>

<p><i>[
2009-05-09:  See alternative solution in issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1113">1113</a>.
]</i></p>




<p><b>Proposed resolution:</b></p>
<ol type="A">
<li>
<p>replace in 20.3.6 [template.bitset]/1 (class <tt>bitset</tt>)
</p>
<blockquote><pre>template &lt;class charT, class traits&gt;
  basic_string&lt;charT, traits, allocator&lt;charT&gt; &gt;
  to_string(<ins>charT zero = charT('0'), charT one = charT('1')</ins>) const;
template &lt;class charT&gt;
  basic_string&lt;charT, char_traits&lt;charT&gt;, allocator&lt;charT&gt; &gt;
  to_string(<ins>charT zero = charT('0'), charT one = charT('1')</ins>) const;
basic_string&lt;char, char_traits&lt;char&gt;, allocator&lt;char&gt; &gt;
  to_string(<ins>char zero = '0', char one = '1'</ins>) const;
</pre></blockquote>
</li>
<li>
<p>
replace in 20.3.6.2 [bitset.members]/37
</p>
<blockquote><pre>template &lt;class charT, class traits&gt;
  basic_string&lt;charT, traits, allocator&lt;charT&gt; &gt;
  to_string(<ins>charT zero = charT('0'), charT one = charT('1')</ins>) const;
</pre>
<blockquote>
37 <i>Returns:</i> <tt>to_string&lt;charT, traits, allocator&lt;charT&gt; &gt;(<ins>zero, one</ins>)</tt>.
</blockquote>
</blockquote>
</li>
<li>
<p>
replace in 20.3.6.2 [bitset.members]/38
</p>

<blockquote><pre>template &lt;class charT&gt;
  basic_string&lt;charT, char_traits&lt;charT&gt;, allocator&lt;charT&gt; &gt;
  to_string(<ins>charT zero = charT('0'), charT one = charT('1')</ins>) const;
</pre>
<blockquote>
38 <i>Returns:</i> <tt>to_string&lt;charT, char_traits&lt;charT&gt;, allocator&lt;charT&gt; &gt;(<ins>zero, one</ins>)</tt>.
</blockquote>
</blockquote>
</li>

<li>
<p>
replace in 20.3.6.2 [bitset.members]/39
</p>

<blockquote><pre>basic_string&lt;char, char_traits&lt;char&gt;, allocator&lt;char&gt; &gt;
  to_string(<ins>char zero = '0', char one = '1'</ins>) const;
</pre>
<blockquote>
39 <i>Returns:</i> <tt>to_string&lt;char, char_traits&lt;char&gt;, allocator&lt;char&gt; &gt;(<ins>zero, one</ins>)</tt>.
</blockquote>
</blockquote>
</li>

</ol>






<hr>
<h3><a name="854"></a>854. <tt>default_delete</tt> converting constructor underspecified</h3>
<p><b>Section:</b> 20.8.12.1.1 [unique.ptr.dltr.dflt] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Review">Review</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2008-06-18  <b>Last modified:</b> 2009-05-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Review">Review</a> status.</p>
<p><b>Discussion:</b></p>
<p>
No relationship between <tt>U</tt> and <tt>T</tt> in the converting constructor for <tt>default_delete</tt> template.
</p>
<p>
Requirements: <tt>U*</tt> is convertible to <tt>T*</tt> and <tt>has_virtual_destructor&lt;T&gt;</tt>;
the latter should also become a concept.
</p>
<p>
Rules out cross-casting.
</p>
<p>
The requirements for <tt>unique_ptr</tt> conversions should be the same as those on the deleter.
</p>

<p><i>[
Howard adds 2008-11-26:
]</i></p>


<blockquote>
<p>
I believe we need to be careful to not outlaw the following use case, and
I believe the current proposed wording
(<tt>requires Convertible&lt;U*, T*&gt; &amp;&amp; HasVirtualDestructor&lt;T&gt;</tt>) does so:
</p>

<blockquote><pre>#include &lt;memory&gt;

int main()
{
    std::unique_ptr&lt;int&gt; p1(new int(1));
    std::unique_ptr&lt;const int&gt; p2(move(p1));
    int i = *p2;
<font color="#c80000">//    *p2 = i;  // should not compile</font>
}
</pre></blockquote>

<p>
I've removed "<tt>&amp;&amp; HasVirtualDestructor&lt;T&gt;</tt>" from the
<tt>requires</tt> clause in the proposed wording.
</p>

</blockquote>

<p><i>[
Post Summit:
]</i></p>


<blockquote>
<p>
Alisdair: This issue has to stay in review pending a paper constraining
<tt>unique_ptr</tt>.
</p>
<p>
Consensus: We agree with the resolution, but <tt>unique_ptr</tt> needs
to be constrained, too.
</p>
<p>
Recommend Keep in Review.
</p>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Keep in Review status for the reasons cited.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 20.8.12.1.1 [unique.ptr.dltr.dflt]:
</p>

<blockquote><pre>namespace std {
  template &lt;class T&gt; struct default_delete {
    default_delete();
    template &lt;class U&gt;
      <ins>requires Convertible&lt;U*, T*&gt;</ins>
      default_delete(const default_delete&lt;U&gt;&amp;);
    void operator()(T*) const;
  };
}
</pre></blockquote>

<p>
...
</p>

<blockquote><pre>template &lt;class U&gt;
  <ins>requires Convertible&lt;U*, T*&gt;</ins>
  default_delete(const default_delete&lt;U&gt;&amp; other);
</pre></blockquote>






<hr>
<h3><a name="857"></a>857. <tt>condition_variable::time_wait</tt> return <tt>bool</tt> error prone</h3>
<p><b>Section:</b> 30.5.1 [thread.condition.condvar] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Beman Dawes <b>Opened:</b> 2008-06-13  <b>Last modified:</b> 2009-06-14</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#thread.condition.condvar">active issues</a> in [thread.condition.condvar].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.condition.condvar">issues</a> in [thread.condition.condvar].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The meaning of the <tt>bool</tt> returned by <tt>condition_variable::timed_wait</tt> is so
obscure that even the class' designer can't deduce it correctly. Several
people have independently stumbled on this issue.
</p>
<p>
It might be simpler to change the return type to a scoped enum:
</p>
<blockquote><pre>enum class timeout { not_reached, reached };
</pre></blockquote>

<p>
That's the same cost as returning a <tt>bool</tt>, but not subject to mistakes. Your example below would be:
</p>

<blockquote><pre>if (cv.wait_until(lk, time_limit) == timeout::reached )
  throw time_out();
</pre></blockquote>

<p><i>[
Beman to supply exact wording.
]</i></p>


<p><i>[
San Francisco:
]</i></p>


<blockquote>
<p>
There is concern that the enumeration names are just as confusing, if
not more so, as the bool. You might have awoken because of a signal or a
spurious wakeup, for example.
</p>
<p>
Group feels that this is a defect that needs fixing.
</p>
<p>
Group prefers returning an enum over a void return.
</p>
<p>
Howard to provide wording.
</p>
</blockquote>

<p><i>[
2009-06-14 Beman provided wording.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
Change Condition variables 30.5 [thread.condition], Header
condition_variable synopsis, as indicated:
</p>

<blockquote><pre>namespace std {
  class condition_variable;
  class condition_variable_any;

  <ins>enum class cv_status { no_timeout, timeout };</ins>
}
</pre></blockquote>

<p>
Change Class condition_variable 30.5.1 [thread.condition.condvar] as indicated:
</p>

<blockquote><pre>class condition_variable { 
public:
  ...
  template &lt;class Clock, class Duration&gt;
    <del>bool</del> <ins>cv_status</ins> wait_until(unique_lock&lt;mutex&gt;&amp; lock,
                    const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time);
  template &lt;class Clock, class Duration, class Predicate&gt;
    bool wait_until(unique_lock&lt;mutex&gt;&amp; lock,
                    const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time,
                    Predicate pred);

  template &lt;class Rep, class Period&gt;
    <del>bool</del> <ins>cv_status</ins> wait_for(unique_lock&lt;mutex&gt;&amp; lock,
                  const chrono::duration&lt;Rep, Period&gt;&amp; rel_time);
  template &lt;class Rep, class Period, class Predicate&gt;
    bool wait_for(unique_lock&lt;mutex&gt;&amp; lock,
                  const chrono::duration&lt;Rep, Period&gt;&amp; rel_time,
                  Predicate pred);
  ...
};

...

template &lt;class Clock, class Duration&gt;
  <del>bool</del> <ins>cv_status</ins> wait_until(unique_lock&lt;mutex&gt;&amp; lock,
                  const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time);
</pre>
<blockquote>
<p>
-15- <i>Precondition:</i> <tt>lock</tt> is locked by the calling thread, and either
</p>
<ul>
<li>
no other thread is waiting on this <tt>condition_variable</tt> object or
</li>
<li>
<tt>lock.mutex()</tt> returns the same value for each of the <tt>lock</tt>
arguments supplied by all concurrently waiting threads (via <tt>wait</tt>,
<tt>wait_for</tt> or <tt>wait_until</tt>.).
</li>
</ul>

<p>
-16- <i>Effects:</i>
</p>

<ul>
<li>
Atomically calls <tt>lock.unlock()</tt> and blocks on <tt>*this</tt>.
</li>
<li>
When unblocked, calls <tt>lock.lock()</tt> (possibly blocking on the lock) and returns.
</li>
<li>
The function will unblock when signaled by a call to <tt>notify_one()</tt>,
a call to <tt>notify_all()</tt>, <del>by 
the current time exceeding <tt>abs_time</tt></del> <ins>if <tt>Clock::now() &gt;= abs_time</tt></ins>,
or spuriously.
</li>
<li>
If the function exits via an exception, <tt>lock.unlock()</tt> shall be called prior
to exiting the function scope.
</li>
</ul>

<p>
-17- <i>Postcondition:</i> <tt>lock</tt> is locked by the calling thread.
</p>

<p>
-18- <i>Returns:</i> <del><tt>Clock::now() &lt; abs_time</tt></del>
<ins><tt>cv_status::timeout</tt> if the function unblocked because <tt>abs_time</tt>
was reached, otherwise <tt>cv_status::no_timeout</tt></ins>.
</p>

<p>
-19- <i>Throws:</i> <tt>std::system_error</tt> when the effects or postcondition
cannot be achieved.
</p>

<p>
-20- <i>Error conditions:</i>
</p>

<ul>
<li>
<tt>operation_not_permitted</tt> &#8212; if the thread does not own the lock.
</li>
<li>
equivalent error condition from <tt>lock.lock()</tt> or <tt>lock.unlock()</tt>.
</li>
</ul>
</blockquote>

<pre>template &lt;class Rep, class Period&gt;
  <del>bool</del> <ins>cv_status</ins> wait_for(unique_lock&lt;mutex&gt;&amp; lock,
                const chrono::duration&lt;Rep, Period&gt;&amp; rel_time);

</pre>
<blockquote>
<p>
-21- <i><del>Effects</del> <ins>Returns</ins>:</i>
</p>
<blockquote><pre>wait_until(lock, chrono::monotonic_clock::now() + rel_time)
</pre></blockquote>
<p>
<del>-22- <i>Returns:</i> <tt>false</tt> if the call is returning because the time
duration specified by <tt>rel_time</tt> has elapsed, 
otherwise <tt>true</tt>.</del>
</p>

<p><i>[
This part of the wording may conflict with <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#859">859</a> in detail, but does
not do so in spirit.  If both issues are accepted, there is a logical merge.
]</i></p>

</blockquote>

<pre>template &lt;class Clock, class Duration, class Predicate&gt; 
  bool wait_until(unique_lock&lt;mutex&gt;&amp; lock, 
                  const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time, 
                  Predicate pred);
</pre>

<blockquote>
<p>
-23- <i>Effects:</i>
</p>
<blockquote><pre>while (!pred()) 
  if (<del>!</del>wait_until(lock, abs_time) <ins>== cv_status::timeout</ins>) 
    return pred(); 
return true;
</pre></blockquote>

<p>
-24- <i>Returns:</i> <tt>pred()</tt>.
</p>

<p>
-25- [<i>Note:</i>
The returned value indicates whether the predicate evaluates to
<tt>true</tt> regardless of whether the timeout was triggered.
&#8212; <i>end note</i>].
</p>
</blockquote>
</blockquote>

<p>
Change Class condition_variable_any 30.5.2 [thread.condition.condvarany] as indicated:
</p>

<blockquote><pre>class condition_variable_any {
public:
  ...
  template &lt;class Lock, class Clock, class Duration&gt;
    <del>bool</del> <ins>cv_status</ins> wait_until(Lock&amp; lock,
                    const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time);
  template &lt;class Lock, class Clock, class Duration, class Predicate&gt;
    bool wait_until(Lock&amp; lock,
                    const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time,
                    Predicate pred);

  template &lt;class Lock, class Rep, class Period&gt;
    <del>bool</del> <ins>cv_status</ins> wait_for(Lock&amp; lock,
                  const chrono::duration&lt;Rep, Period&gt;&amp; rel_time);
  template &lt;class Lock, class Rep, class Period, class Predicate&gt;
    bool wait_for(Lock&amp; lock,
                  const chrono::duration&lt;Rep, Period&gt;&amp; rel_time,
                  Predicate pred);
  ...
};

...

template &lt;class Lock, class Clock, class Duration&gt;
  <del>bool</del> <ins>cv_status</ins> wait_until(Lock&amp; lock,
                  const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time);
</pre>

<blockquote>

<p>
-13- <i>Effects:</i>
</p>

<ul>
<li>
Atomically calls <tt>lock.unlock()</tt> and blocks on <tt>*this</tt>.
</li>
<li>
When unblocked, calls <tt>lock.lock()</tt> (possibly blocking on the lock) and returns.
</li>
<li>
The function will unblock when signaled by a call to <tt>notify_one()</tt>,
a call to <tt>notify_all()</tt>, <del>by 
the current time exceeding <tt>abs_time</tt></del> <ins>if <tt>Clock::now() &gt;= abs_time</tt></ins>,
or spuriously.
</li>
<li>
If the function exits via an exception, <tt>lock.unlock()</tt> shall be called prior
to exiting the function scope.
</li>
</ul>

<p>
-14- <i>Postcondition:</i> <tt>lock</tt> is locked by the calling thread.
</p>

<p>
-15- <i>Returns:</i> <del><tt>Clock::now() &lt; abs_time</tt></del>
<ins><tt>cv_status::timeout</tt> if the function unblocked because <tt>abs_time</tt>
was reached, otherwise <tt>cv_status::no_timeout</tt></ins>.
</p>

<p>
-16- <i>Throws:</i> <tt>std::system_error</tt> when the effects or postcondition
cannot be achieved.
</p>

<p>
-17- <i>Error conditions:</i>
</p>

<ul>
<li>
equivalent error condition from <tt>lock.lock()</tt> or <tt>lock.unlock()</tt>.
</li>
</ul>
</blockquote>

<pre>template &lt;class Lock, class Rep, class Period&gt;
  <del>bool</del> <ins>cv_status</ins> wait_for(Lock&amp; lock,
                const chrono::duration&lt;Rep, Period&gt;&amp; rel_time);

</pre>

<blockquote>
<p>
-18- <i><del>Effects</del> <ins>Returns</ins>:</i>
</p>
<blockquote><pre>wait_until(lock, chrono::monotonic_clock::now() + rel_time)
</pre></blockquote>

<p>
<del>-19- <i>Returns:</i> <tt>false</tt> if the call is returning because the time
duration specified by <tt>rel_time</tt> has elapsed, 
otherwise <tt>true</tt>.</del>
</p>

<p><i>[
This part of the wording may conflict with <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#859">859</a> in detail, but does
not do so in spirit.  If both issues are accepted, there is a logical merge.
]</i></p>


</blockquote>

<pre>template &lt;class Lock, class Clock, class Duration, class Predicate&gt; 
  bool wait_until(Lock&amp; lock, 
                  const chrono::time_point&lt;Clock, Duration&gt;&amp; <del>rel_time</del> <ins>abs_time</ins>, 
                  Predicate pred);
</pre>

<blockquote>
<p>
-20- <i>Effects:</i>
</p>
<blockquote><pre>while (!pred()) 
  if (<del>!</del>wait_until(lock, abs_time) <ins>== cv_status::timeout</ins>) 
    return pred(); 
return true;
</pre></blockquote>

<p>
-21- <i>Returns:</i> <tt>pred()</tt>.
</p>

<p>
-22- [<i>Note:</i>
The returned value indicates whether the predicate evaluates to
<tt>true</tt> regardless of whether the timeout was triggered.
&#8212; <i>end note</i>].
</p>
</blockquote>

</blockquote>






<hr>
<h3><a name="859"></a>859. Monotonic Clock is Conditionally Supported?</h3>
<p><b>Section:</b> 30.5 [thread.condition] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2008-06-23  <b>Last modified:</b> 2009-06-14</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>Related to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#958">958</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#959">959</a>.</p>

<p>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2661.html">N2661</a>
says that there is a class named <tt>monotonic_clock</tt>. It also says that this
name may be a synonym for <tt>system_clock</tt>, and that it's conditionally
supported. So the actual requirement is that it can be monotonic or not,
and you can tell by looking at <tt>is_monotonic</tt>, or it might not exist at
all (since it's conditionally supported). Okay, maybe too much
flexibility, but so be it.
</p>
<p>
A problem comes up in the threading specification, where several
variants of <tt>wait_for</tt> explicitly use <tt>monotonic_clock::now()</tt>. What is the
meaning of an effects clause that says
</p>

<blockquote><pre>wait_until(lock, chrono::monotonic_clock::now() + rel_time)
</pre></blockquote>

<p>
when <tt>monotonic_clock</tt> is not required to exist?
</p>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
<p>
Nick: maybe instead of saying that chrono::monotonic_clock is
conditionally supported, we could say that it's always there, but not
necessarily supported..
</p>
<p>
Beman: I'd prefer a typedef that identifies the best clock to use for
wait_for locks.
</p>
<p>
Tom: combine the two concepts; create a duration clock type, but keep
the is_monotonic test.
</p>
<p>
Howard: if we create a duration_clock type, is it a typedef or an
entirely true type?
</p>
<p>
There was broad preference for a typedef.
</p>
<p>
Move to Open. Howard to provide wording to add a typedef for
duration_clock and to replace all uses of monotonic_clock in function
calls and signatures with duration_clock.
</p>
</blockquote>

<p><i>[
Howard notes post-San Francisco:
]</i></p>


<blockquote>
<p>
After further thought I do not believe that creating a <tt>duration_clock typedef</tt>
is the best way to proceed.  An implementation may not need to use a
<tt>time_point</tt> to implement the <tt>wait_for</tt> functions.
</p>

<p>
For example, on POSIX systems <tt>sleep_for</tt> can be implemented in terms of
<tt>nanosleep</tt> which takes only a duration in terms of nanoseconds.  The current
working paper does not describe <tt>sleep_for</tt> in terms of <tt>sleep_until</tt>.
And paragraph 2 of 30.2.4 [thread.req.timing] has the words strongly encouraging
implementations to use monotonic clocks for <tt>sleep_for</tt>:
</p>

<blockquote>
2 The member functions whose names end in <tt>_for</tt> take an argument that
specifies a relative time. Implementations should use a monotonic clock to
measure time for these functions.
</blockquote>

<p>
I believe the approach taken in describing the effects of <tt>sleep_for</tt>
and <tt>try_lock_for</tt> is also appropriate for <tt>wait_for</tt>.  I.e. these
are not described in terms of their <tt>_until</tt> variants.
</p>

</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 30.5.1 [thread.condition.condvar], p21-22:
</p>

<blockquote>
<pre>template &lt;class Rep, class Period&gt; 
  bool wait_for(unique_lock&lt;mutex&gt;&amp; lock, 
                const chrono::duration&lt;Rep, Period&gt;&amp; rel_time);
</pre>
<blockquote>
<p><ins>
<i>Precondition:</i> <tt>lock</tt> is locked by the calling thread, and either
</ins></p>
<ul>
<li><ins>no other thread is waiting on this <tt>condition_variable</tt> object or</ins></li>
<li><ins><tt>lock.mutex()</tt> returns the same value for each of the <tt>lock</tt>
arguments supplied by all concurrently waiting threads (via <tt>wait</tt>,
<tt>wait_for</tt> or <tt>wait_until</tt>).</ins></li>
</ul>
<p>
21 <i>Effects:</i>
</p>
<blockquote><pre><del>wait_until(lock, chrono::monotonic_clock::now() + rel_time)</del>
</pre></blockquote>
<ul>
<li><ins>
Atomically calls <tt>lock.unlock()</tt> and blocks on <tt>*this</tt>.
</ins></li>

<li><ins>
When unblocked, calls <tt>lock.lock()</tt> (possibly blocking on the lock) and returns.
</ins></li>

<li><ins>
The function will unblock when signaled by a call to <tt>notify_one()</tt>, a call
to <tt>notify_all()</tt>, by 
the elapsed time <tt>rel_time</tt> passing (30.2.4 [thread.req.timing]),
or spuriously.
</ins></li>

<li><ins>
If the function exits via an exception, <tt>lock.unlock()</tt> shall be called 
prior to exiting the function scope.
</ins></li>
</ul>

<p><ins>
<i>Postcondition:</i> <tt>lock</tt> is locked by the calling thread.
</ins></p>


<p>
22 <i>Returns:</i> <tt>false</tt> if the call is returning because the time
duration specified by <tt>rel_time</tt> has elapsed, otherwise <tt>true</tt>.
</p>

<p><i>[
This part of the wording may conflict with <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#857">857</a> in detail, but does
not do so in spirit.  If both issues are accepted, there is a logical merge.
]</i></p>


<p><ins>
<i>Throws:</i> <tt>std::system_error</tt> when the effects or postcondition cannot be achieved.
</ins></p>

<p><ins>
<i>Error conditions:</i>
</ins></p>

<ul>
<li><ins>
<tt>operation_not_permitted</tt> -- if the thread does not own the lock.
</ins></li>
<li><ins>
equivalent error condition from <tt>lock.lock()</tt> or <tt>lock.unlock()</tt>.
</ins></li>
</ul>

</blockquote>
</blockquote>

<p>
Change 30.5.1 [thread.condition.condvar], p26-p29:
</p>

<blockquote>
<pre>template &lt;class Rep, class Period, class Predicate&gt; 
  bool wait_for(unique_lock&lt;mutex&gt;&amp; lock, 
                const chrono::duration&lt;Rep, Period&gt;&amp; rel_time, 
                Predicate pred);
</pre>
<blockquote>
<p><ins>
<i>Precondition:</i> <tt>lock</tt> is locked by the calling thread, and either
</ins></p>
<ul>
<li><ins>no other thread is waiting on this <tt>condition_variable</tt> object or</ins></li>
<li><ins><tt>lock.mutex()</tt> returns the same value for each of the <tt>lock</tt>
arguments supplied by all concurrently waiting threads (via <tt>wait</tt>,
<tt>wait_for</tt> or <tt>wait_until</tt>).</ins></li>
</ul>
<p>
<i>26 Effects:</i>
</p>
<blockquote><pre><del>wait_until(lock, chrono::monotonic_clock::now() + rel_time, std::move(pred))</del>
</pre>
<ul>
<li><ins>
Executes a loop:  Within the loop the function first evaluates <tt>pred()</tt>
and exits the loop if the result of <tt>pred()</tt> is <tt>true</tt>.
</ins></li>
<li><ins>
Atomically calls <tt>lock.unlock()</tt>
and blocks on <tt>*this</tt>.
</ins></li>
<li><ins>
When unblocked, calls <tt>lock.lock()</tt> (possibly blocking on the lock).
</ins></li>
<li><ins>
The function will unblock when signaled by a call to <tt>notify_one()</tt>, a
call to <tt>notify_all()</tt>, by the elapsed time <tt>rel_time</tt> passing (30.1.4
[thread.req.timing]), or spuriously.
</ins></li>
<li><ins>
If the function exits via an exception, <tt>lock.unlock()</tt> shall be called
prior to exiting the function scope.
</ins></li>
<li><ins>
The loop terminates when <tt>pred()</tt> returns <tt>true</tt> or when the time
duration specified by <tt>rel_time</tt> has elapsed.
</ins></li>
</ul>
</blockquote>

<p>
27 [<i>Note:</i> There is no blocking if <tt>pred()</tt> is initially <tt>true</tt>,
even if the timeout has already expired. <i>-- end note</i>]
</p>

<p><ins>
<i>Postcondition:</i> <tt>lock</tt> is locked by the calling thread.
</ins></p>

<p>
28 <i>Returns:</i> <tt>pred()</tt>
</p>

<p>
29 [<i>Note:</i> The returned value indicates whether the predicate evaluates to
<tt>true</tt> regardless of whether the timeout was triggered. <i>-- end note</i>]
</p>

<p><ins>
<i>Throws:</i> <tt>std::system_error</tt> when the effects or postcondition cannot be achieved.
</ins></p>

<p><ins>
<i>Error conditions:</i>
</ins></p>

<ul>
<li><ins>
<tt>operation_not_permitted</tt> -- if the thread does not own the lock.
</ins></li>
<li><ins>
equivalent error condition from <tt>lock.lock()</tt> or <tt>lock.unlock()</tt>.
</ins></li>
</ul>

</blockquote>
</blockquote>

<p>
Change 30.5.2 [thread.condition.condvarany], p18-19:
</p>

<blockquote>
<pre>template &lt;class Lock, class Rep, class Period&gt; 
  bool wait_for(Lock&amp; lock, const chrono::duration&lt;Rep, Period&gt;&amp; rel_time);
</pre>
<blockquote>
<p>
18 <i>Effects:</i>
</p>
<blockquote><pre><del>wait_until(lock, chrono::monotonic_clock::now() + rel_time)</del>
</pre></blockquote>

<ul>
<li><ins>
Atomically calls <tt>lock.unlock()</tt> and blocks on <tt>*this</tt>.
</ins></li>

<li><ins>
When unblocked, calls <tt>lock.lock()</tt> (possibly blocking on the lock) and returns.
</ins></li>

<li><ins>
The function will unblock when signaled by a call to <tt>notify_one()</tt>, a call to
<tt>notify_all()</tt>, by
the elapsed time <tt>rel_time</tt> passing (30.2.4 [thread.req.timing]),
or spuriously.
</ins></li>

<li><ins>
If the function exits via an exception, <tt>lock.unlock()</tt> shall be called
prior to exiting the function scope.
</ins></li>
</ul>

<p><ins>
<i>Postcondition:</i> <tt>lock</tt> is locked by the calling thread.
</ins></p>

<p>
19 <i>Returns:</i> <tt>false</tt> if the call is returning because the time duration
specified by <tt>rel_time</tt> has elapsed, otherwise <tt>true</tt>.
</p>

<p><ins>
<i>Throws:</i> <tt>std::system_error</tt> when the returned value, effects,
or postcondition cannot be achieved.
</ins></p>

<p><ins>
<i>Error conditions:</i>
</ins></p>

<ul>
<li><ins>
equivalent error condition from <tt>lock.lock()</tt> or <tt>lock.unlock()</tt>.
</ins></li>
</ul>
</blockquote>
</blockquote>

<p>
Change 30.5.2 [thread.condition.condvarany], p23-p26:
</p>

<blockquote>
<pre>template &lt;class Lock, class Rep, class Period, class Predicate&gt; 
  bool wait_for(Lock&amp; lock, const chrono::duration&lt;Rep, Period&gt;&amp; rel_time, Predicate pred);
</pre>
<blockquote>
<p><ins>
<i>Precondition:</i> <tt>lock</tt> is locked by the calling thread, and either
</ins></p>
<ul>
<li><ins>no other thread is waiting on this <tt>condition_variable</tt> object or</ins></li>
<li><ins><tt>lock.mutex()</tt> returns the same value for each of the <tt>lock</tt>
arguments supplied by all concurrently waiting threads (via <tt>wait</tt>,
<tt>wait_for</tt> or <tt>wait_until</tt>).</ins></li>
</ul>
<p>
<i>23 Effects:</i>
</p>
<blockquote><pre><del>wait_until(lock, chrono::monotonic_clock::now() + rel_time, std::move(pred))</del>
</pre>
<ul>
<li><ins>
Executes a loop:  Within the loop the function first evaluates <tt>pred()</tt>
and exits the loop if the result of <tt>pred()</tt> is <tt>true</tt>.
</ins></li>
<li><ins>
Atomically calls <tt>lock.unlock()</tt>
and blocks on <tt>*this</tt>.
</ins></li>
<li><ins>
When unblocked, calls <tt>lock.lock()</tt> (possibly blocking on the lock).
</ins></li>
<li><ins>
The function will unblock when signaled by a call to <tt>notify_one()</tt>, a
call to <tt>notify_all()</tt>, by the elapsed time <tt>rel_time</tt> passing (30.1.4
[thread.req.timing]), or spuriously.
</ins></li>
<li><ins>
If the function exits via an exception, <tt>lock.unlock()</tt> shall be called
prior to exiting the function scope.
</ins></li>
<li><ins>
The loop terminates when <tt>pred()</tt> returns <tt>true</tt> or when the time
duration specified by <tt>rel_time</tt> has elapsed.
</ins></li>
</ul>
</blockquote>

<p>
24 [<i>Note:</i> There is no blocking if <tt>pred()</tt> is initially <tt>true</tt>,
even if the timeout has already expired. <i>-- end note</i>]
</p>

<p><ins>
<i>Postcondition:</i> <tt>lock</tt> is locked by the calling thread.
</ins></p>

<p>
25 <i>Returns:</i> <tt>pred()</tt>
</p>

<p>
26 [<i>Note:</i> The returned value indicates whether the predicate evaluates to
<tt>true</tt> regardless of whether the timeout was triggered. <i>-- end note</i>]
</p>

<p><ins>
<i>Throws:</i> <tt>std::system_error</tt> when the effects or postcondition cannot be achieved.
</ins></p>

<p><ins>
<i>Error conditions:</i>
</ins></p>

<ul>
<li><ins>
<tt>operation_not_permitted</tt> -- if the thread does not own the lock.
</ins></li>
<li><ins>
equivalent error condition from <tt>lock.lock()</tt> or <tt>lock.unlock()</tt>.
</ins></li>
</ul>

</blockquote>
</blockquote>







<hr>
<h3><a name="860"></a>860. Floating-Point State</h3>
<p><b>Section:</b> 26 [numerics] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Lawrence Crowl <b>Opened:</b> 2008-06-23  <b>Last modified:</b> 2009-03-09</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#numerics">active issues</a> in [numerics].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#numerics">issues</a> in [numerics].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There are a number of functions that affect the floating point state.
These function need to be thread-safe, but I'm unsure of the right
approach in the standard, as we inherit them from C.
</p>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
<p>
Nick: I think we already say that these functions do not introduce data
races; see 17.6.5.6/20
</p>
<p>
Pete: there's more to it than not introducing data races; are these
states maintained per thread?
</p>
<p>
Howard: 21.5/14 says that strtok and strerror are not required to avoid
data races, and 20.9/2 says the same about asctime, gmtime, ctime, and
gmtime.
</p>
<p>
Nick: POSIX has a list of not-safe functions. All other functions are
implicitly thread safe.
</p>
<p>
Lawrence is to form a group between meetings to attack this issue. Nick
and Tom volunteered to work with Lawrence.
</p>
<p>
Move to Open.
</p>
</blockquote>

<p><i>[
Post Summit:
]</i></p>


<blockquote>
<p>
Hans: Sane oses seem ok. Sensible thing is implementable and makes sense.
</p>
<p>
Nick: Default wording seems to cover this? Hole in POSIX, these
functions need to be added to list of thread-unsafe functions.
</p>
<p>
Lawrence: Not sufficient, not "thread-safe" per our definition, but
think of state as a thread-local variable. Need something like "these
functions only affect state in the current thread."
</p>
<p>
Hans: Suggest the following wording: "The floating point environment is
maintained per-thread."
</p>
<p>
Walter: Any other examples of state being thread safe that are not
already covered elsewhere?
</p>
<p>
Have thread unsafe functions paper which needs to be updated. Should
just fold in 26.3 [cfenv] functions.
</p>
<p>
Recommend Open. Lawrence instead suggests leaving it open until we have
suitable wording that may or may not include the thread local
commentary.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="861"></a>861. Incomplete specification of EqualityComparable for std::forward_list</h3>
<p><b>Section:</b> 23.2 [container.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2008-06-24  <b>Last modified:</b> 2008-11-11</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#container.requirements">active issues</a> in [container.requirements].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#container.requirements">issues</a> in [container.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Table 89, Container requirements, defines <tt>operator==</tt> in terms of the container
member function <tt>size()</tt> and the algorithm <tt>std::equal</tt>:
</p>

<blockquote>
<tt>==</tt> is an equivalence relation. <tt>a.size() == b.size() &amp;&amp;
equal(a.begin(), a.end(), b.begin()</tt>
</blockquote>

<p>
The new container <tt>forward_list</tt> does not provide a <tt>size</tt> member function
by design but does provide <tt>operator==</tt> and <tt>operator!=</tt> without specifying it's semantic.
</p>
<p>
Other parts of the (sequence) container requirements do also depend on
<tt>size()</tt>, e.g. <tt>empty()</tt>
or <tt>clear()</tt>, but this issue explicitly attempts to solve the missing
<tt>EqualityComparable</tt> specification,
because of the special design choices of <tt>forward_list</tt>.
</p>
<p>
I propose to apply one of the following resolutions, which are described as:
</p>

<ol type="A">
<li>
Provide a definition, which is optimal for this special container without
previous size test. This choice prevents two <tt>O(N)</tt> calls of <tt>std::distance()</tt>
with the corresponding container ranges and instead uses a special
<tt>equals</tt> implementation which takes two container ranges instead of 1 1/2.
</li>
<li>
The simple fix where the usual test is adapted such that <tt>size()</tt> is replaced
by <tt>distance</tt> with corresponding performance disadvantages.
</li>
</ol>
<p>
Both proposal choices are discussed, the preferred choice of the author is
to apply (A).
</p>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
<p>
There's an Option C: change the requirements table to use distance().
</p>
<p>
LWG found Option C acceptable.
</p>
<p>
Martin will draft the wording for Option C.
</p>
</blockquote>

<p><i>[
post San Francisco:
]</i></p>


<blockquote>
Martin provided wording for Option C.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Common part:
</p>
<ul>
<li>
<p>
Just betwen 23.3.3.5 [forwardlist.ops] and 23.3.3.6 [forwardlist.spec]
add a new
section "forwardlist comparison operators" [forwardlist.compare] (and
also add the
new section number to 23.3.3 [forwardlist]/2 in front of "Comparison operators"):
</p>
<blockquote>
forwardlist comparison operators [forwardlist.compare]
</blockquote>
</li>
</ul>

<p>
Option (A):
</p>
<blockquote>
<ul>
<li>
<p>
Add to the new section [forwardlist.compare] the following paragraphs:
</p>

<blockquote>
<pre>template &lt;class T, class Allocator&gt;
bool operator==(const forward_list&lt;T,Allocator&gt;&amp; x, const forward_list&lt;T,Allocator&gt;&amp; y);
</pre>
<blockquote>
<p>
<i>Requires:</i> Type <tt>T</tt> is <tt>EqualityComparable</tt> ([equalitycomparable]).
</p>
<p>
<i>Returns:</i> <tt>true</tt> if
</p>
<ul>
<li>
<p>
for every iterator <tt>i</tt> in the range <tt>[x.begin(), E)</tt>, where <tt>E ==
x.begin() + M</tt> and <tt>M ==
   min(distance(x.begin(), x.end()), distance(y.begin(), y.end()))</tt>,
the following condition holds:
</p>
<blockquote><pre>*i == *(y.begin() + (i - x.begin())).
</pre></blockquote>
</li>
<li>
if <tt>i == E</tt> then <tt>i == x.end() &amp;&amp; (y.begin() + (i - x.begin())) == y.end()</tt>.
</li>
<li>
Otherwise, returns <tt>false</tt>.
</li>
</ul>
<p>
<i>Throws:</i> Nothing unless an exception is thrown by the equality comparison.
</p>
<p>
<i>Complexity:</i> At most <tt>M</tt> comparisons.
</p>
</blockquote>
<pre>template &lt;class T, class Allocator&gt;
bool operator!=(const forward_list&lt;T,Allocator&gt;&amp; x, const forward_list&lt;T,Allocator&gt;&amp; y);
</pre>
<blockquote>
<i>Returns:</i> <tt>!(x == y)</tt>.
</blockquote>
</blockquote>
</li>
</ul>
</blockquote>

<p>
Option (B):
</p>
<blockquote>
<ul>
<li>
<p>
Add to the new section [forwardlist.compare] the following paragraphs:
</p>
<blockquote>
<pre>template &lt;class T, class Allocator&gt;
bool operator==(const forward_list&lt;T,Allocator&gt;&amp; x, const forward_list&lt;T,Allocator&gt;&amp; y);
</pre>
<blockquote>
<p>
<i>Requires:</i> Type <tt>T</tt> is <tt>EqualityComparable</tt> ([equalitycomparable]).
</p>
<p>
<i>Returns:</i> <tt>distance(x.begin(), x.end()) == distance(y.begin(), y.end())
&amp;&amp; equal(x.begin(), x.end(), y.begin())</tt>.
</p>
</blockquote>
<pre>template &lt;class T, class Allocator&gt;
bool operator!=(const forward_list&lt;T,Allocator&gt;&amp; x, const forward_list&lt;T,Allocator&gt;&amp; y);
</pre>
<blockquote>
<i>Returns:</i> <tt>!(x == y)</tt>.
</blockquote>
</blockquote>
</li>

</ul>
</blockquote>

<p>
Option (C):
</p>
<blockquote>
<ul>
<li>
<p>
Change Table 91 - Container Requirements in 23.2.1 [container.requirements.general]
(<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2798.pdf">N2798</a>) like so:
</p>

<ol>
<li>
<p>
Change the text in the <b>Operational Semantics</b> column in
  the row for <tt>a == b</tt> as follows:
</p>
<blockquote>
<tt>==</tt> is an equivalence relation.
  <tt><ins>distance(a.begin(), a.end())</ins>
  <del>a.size()</del> ==
  <ins>distance(b.begin(), b.end())</ins> <del>b.size()</del> &amp;&amp;
  equal(a.begin(), a.end(), b.begin())</tt>
</blockquote>
</li>

<li>
<p>
Change the text in the <b>Operational Semantics</b> column in
  the row for <tt>a.max_size()</tt> as follows:
</p>
<blockquote>
<tt><ins>distance(a.begin(), a.end())</ins>
  <del>a.size()</del></tt> of the largest possible container
</blockquote>
</li>

<li>
<p>
Change the text in the <b>Operational Semantics</b> column in
  the row for <tt>a.empty()</tt> as follows:
</p>
<blockquote>
<tt><ins>a.begin() == a.end()</ins>
  <del>a.size() == 0</del></tt>
</blockquote>
</li>

<li>
<p>
In addition, for consistency, change the text in the
  <b>Operational Semantics</b> column in the row for <tt>a.size()</tt>
  as follows:
</p>
<blockquote>
<tt><ins>distance(a.begin(), a.end())</ins>
  <del>a.end() - a.begin()</del></tt>
</blockquote>
</li>
</ol>
</li>
</ul>
</blockquote>





<hr>
<h3><a name="862"></a>862. Impossible complexity for 'includes'</h3>
<p><b>Section:</b> 25.5.5.1 [includes] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">Tentatively NAD Editorial</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2008-07-02  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#includes">active issues</a> in [includes].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#includes">issues</a> in [includes].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20NAD%20Editorial">Tentatively NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 25.5.5.1 [includes] the complexity is "at most -1 comparisons" if passed
two empty ranges.  I don't know how to perform a negative number of
comparisions!
</p>

<p>
This same issue also applies to:
</p>

<ul>
<li><tt>set_union</tt></li>
<li><tt>set_intersection</tt></li>
<li><tt>set_difference</tt></li>
<li><tt>set_symmetric_difference</tt></li>
<li><tt>merge</tt></li>
</ul>

<p><i>[
2009-03-30 Beman adds:
]</i></p>


<blockquote>
Suggest NAD. The complexity of empty ranges is -1 in other places in the
standard. See 25.5.4 [alg.merge] <tt>merge</tt> and
<tt>inplace_merge</tt>, and <tt>forward_list</tt> merge, for example.
The time and effort to find and fix all places in the standard where
empty range[s] result in negative complexity isn't worth the very
limited benefit.
</blockquote>

<p><i>[
2009-05-09 Alisdair adds:
]</i></p>


<blockquote>
<p>
I'm not happy with NAD if we can find a simple solution.
</p>
<p>
How about adding a rider somewhere in clause 17 suggesting that complexities
that specify a negative number of operations are treated as specifying zero
operations?  That should generically solve the issue without looking for
further cases.
</p>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Pete to provide "straightforward" wording.
Move to NAD Editorial.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Recommend NAD.
</p>





<hr>
<h3><a name="863"></a>863. What is the state of a stream after close() succeeds</h3>
<p><b>Section:</b> 27.9.1 [fstreams] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Steve Clamage <b>Opened:</b> 2008-07-08  <b>Last modified:</b> 2009-05-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#fstreams">issues</a> in [fstreams].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Suppose writing to an <tt>[o]fstream</tt> fails and you later close the <tt>stream</tt>.
The <tt>overflow()</tt> function is called to flush the buffer (if it exists).
Then the file is unconditionally closed, as if by calling <tt>flcose</tt>.
</p>
<p>
If either <tt>overflow</tt> or <tt>fclose</tt> fails, <tt>close()</tt> reports failure, and clearly
the <tt>stream</tt> should be in a failed or bad state.
</p>
<p>
Suppose the buffer is empty or non-existent (so that <tt>overflow()</tt> does not
fail), and <tt>fclose</tt> succeeds. The <tt>close()</tt> function reports success, but
what is the state of the <tt>stream</tt>?
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Tom's impression is that the issue is about the <tt>failbit</tt>, etc.
</p>
<p>
Bill responds that the stream is now closed,
and any status bits remain unchanged.
</p>
<p>
See the description of <tt>close()</tt> in 27.9.1.17 [fstream.members].
</p>
<p>
We prefer not to add wording to say that nothing changes.
Move to NAD.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="865"></a>865. More algorithms that throw away information</h3>
<p><b>Section:</b> 25.4.6 [alg.fill], 25.4.7 [alg.generate] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2008-07-13  <b>Last modified:</b> 2009-05-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In regard to library defect <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#488">488</a> I found some more algorithms which
unnecessarily throw away information. These are typically algorithms,
which sequentially write into an <tt>OutputIterator</tt>, but do not return the
final value of this output iterator. These cases are:
</p>

<ol>
<li>
<pre>template&lt;class OutputIterator, class Size, class T&gt;
void fill_n(OutputIterator first, Size n, const T&amp; value);</pre></li>

<li>
<pre>template&lt;class OutputIterator, class Size, class Generator&gt;
void generate_n(OutputIterator first, Size n, Generator gen);</pre></li>
</ol>
<p>
In both cases the minimum requirements on the iterator are
<tt>OutputIterator</tt>, which means according to the requirements of
24.2.3 [output.iterators]/2 that only single-pass iterations are guaranteed.
So, if users of <tt>fill_n</tt> and <tt>generate_n</tt> have *only* an <tt>OutputIterator</tt>
available, they have no chance to continue pushing further values
into it, which seems to be a severe limitation to me.
</p>

<p><i>[
Post Summit Daniel "conceptualized" the wording.
]</i></p>


<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Alisdair likes the idea, but has concerns about the specific wording
about the returns clauses.
</p>
<p>
Alan notes this is a feature request.
</p>
<p>
Bill notes we have made similar changes to other algorithms.
</p>
<p>
Move to Open.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>
Replace the current declaration of <tt>fill_n</tt> in 25 [algorithms]/2, header
<tt>&lt;algorithm&gt;</tt> synopsis and in 25.4.6 [alg.fill] by
</p>

<blockquote><pre>template&lt;class Iter, IntegralLike Size, class T&gt;
  requires OutputIterator&lt;Iter, const T&amp;&gt;
  <del>void</del><ins>Iter</ins> fill_n(Iter first, Size n, const T&amp; value);
</pre></blockquote>

<p>
Just after the effects clause p.1 add a new returns clause saying:
</p>
<blockquote>
<i>Returns:</i> For <tt>fill_n</tt> and <tt>n &gt; Size(0)</tt>, returns <tt>first + n</tt>. Otherwise
returns <tt>first</tt> for <tt>fill_n</tt>.
</blockquote>
</li>
<li>
<p>
Replace the current declaration of <tt>generate_n</tt> in 25 [algorithms]/2, header
<tt>&lt;algorithm&gt;</tt> synopsis and in 25.4.7 [alg.generate] by
</p>
<blockquote><pre>template&lt;class Iter, IntegralLike Size, Callable Generator&gt;
  requires OutputIterator&lt;Iter, Generator::result_type&gt;
        &amp;&amp; CopyConstructible&lt;Generator&gt;
  <del>void</del><ins>Iter</ins> generate_n(Iter first, Size n, Generator gen);
</pre></blockquote>
<p>
Just after the effects clause p.1 add a new returns clause saying:
</p>
<blockquote>
<i>Returns:</i> For <tt>generate_n</tt> and <tt>n &gt; Size(0)</tt>, returns <tt>first + n</tt>.
Otherwise returns <tt>first</tt> for <tt>generate_n</tt>.
</blockquote>
</li>
</ol>





<hr>
<h3><a name="867"></a>867. Valarray and value-initialization</h3>
<p><b>Section:</b> 26.6.2.1 [valarray.cons] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">Tentatively NAD Editorial</a>
 <b>Submitter:</b> Alberto Ganesh Barbati <b>Opened:</b> 2008-07-20  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#valarray.cons">active issues</a> in [valarray.cons].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#valarray.cons">issues</a> in [valarray.cons].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20NAD%20Editorial">Tentatively NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
From 26.6.2.1 [valarray.cons], paragraph 2:
</p>

<blockquote><pre>explicit  valarray(size_t);
</pre>
<blockquote>
The array created by this constructor has a length equal to the value of the argument. The elements
of the array are constructed using the default constructor for the instantiating type <tt>T</tt>.
</blockquote>
</blockquote>

<p>
The problem is that the most obvious <tt>T</tt>s for <tt>valarray</tt> are <tt>float</tt>
and <tt>double</tt>, they don't have a default constructor. I guess the intent is to value-initialize
the elements, so I suggest replacing:
</p>

<blockquote>
The elements of the array are constructed using the default constructor for the instantiating type <tt>T</tt>.
</blockquote>
<p>
with
</p>
<blockquote>
The elements of the array are value-initialized.
</blockquote>

<p>
There is another reference to the default constructor of <tt>T</tt> in the non-normative note in paragraph 9.
That reference should also be replaced. (The normative wording in paragraph 8 refers to <tt>T()</tt>
and so it doesn't need changes).
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution.
Move to NAD Editorial.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 26.6.2.1 [valarray.cons], paragraph 2:
</p>

<blockquote>
<pre>explicit  valarray(size_t);
</pre>
<blockquote>
The array created by this constructor has a length equal to the value of the argument. The elements
of the array are <del>constructed using the default constructor for the instantiating type <tt>T</tt></del>
<ins>value-initialized (8.5 [dcl.init])</ins>.
</blockquote>
</blockquote>

<p>
Change 26.6.2.7 [valarray.members], paragraph 9:
</p>

<blockquote>
[<i>Example:</i> If the argument has the value -2, the first two elements of the result will be <del>constructed using the 
default constructor</del>
<ins>value-initialized (8.5 [dcl.init])</ins>;
the third element of the result will be assigned the value of the first element of the argument; etc. <i>-- end example</i>]
</blockquote>






<hr>
<h3><a name="868"></a>868. default construction and value-initialization</h3>
<p><b>Section:</b> 23 [containers] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alberto Ganesh Barbati <b>Opened:</b> 2008-07-22  <b>Last modified:</b> 2008-09-22</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#containers">active issues</a> in [containers].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#containers">issues</a> in [containers].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The term "default constructed" is often used in wording that predates
the introduction of the concept of value-initialization. In a few such
places the concept of value-initialization is more correct than the
current wording (for example when the type involved can be a built-in)
so a replacement is in order. Two of such places are already covered by
issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#867">867</a>. This issue deliberately addresses the hopefully
non-controversial changes in the attempt of being approved more quickly.
A few other occurrences (for example in <tt>std::tuple</tt>,
<tt>std::reverse_iterator</tt> and <tt>std::move_iterator</tt>) are left to separate
issues. For <tt>std::reverse_iterator</tt>, see also issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#408">408</a>. This issue is
related with issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#724">724</a>.
</p>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
<p>
The list provided in the proposed resolution is not complete. James
Dennett will review the library and provide a complete list and will
double-check the vocabulary.
</p>
<p>
This issue relates to Issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#886">886</a> tuple construction
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change X [utility.arg.requirements], paragraph 2:
</p>

<blockquote>
In general, a default constructor is not required. Certain container class member function signatures specify 
<del>the default constructor</del>
<ins><tt>T()</tt></ins>
as a default argument. <tt>T()</tt> shall be a well-defined expression (8.5 [dcl.init]) if one of
those signatures is called using  the default argument (8.3.6 [dcl.fct.default]).
</blockquote>

<p>
In all the following paragraphs in clause 23 [containers], replace "default constructed" with "value-initialized
(8.5 [dcl.init])":
</p>

<ul>
<li>23.3.2.1 [deque.cons] para 2</li>
<li>23.3.2.2 [deque.capacity] para 1</li>
<li>23.3.3.1 [forwardlist.cons] para 3</li>
<li>23.3.3.4 [forwardlist.modifiers] para 21</li>
<li>23.3.4.1 [list.cons] para 3</li>
<li>23.3.4.2 [list.capacity] para 1</li>
<li>23.3.6.1 [vector.cons] para 3</li>
<li>23.3.6.2 [vector.capacity] para 10</li>
</ul>





<hr>
<h3><a name="869"></a>869. Bucket (local) iterators and iterating past end</h3>
<p><b>Section:</b> 23.2.5 [unord.req] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Sohail Somani <b>Opened:</b> 2008-07-22  <b>Last modified:</b> 2009-03-09</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#unord.req">active issues</a> in [unord.req].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#unord.req">issues</a> in [unord.req].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Is there any language in the current draft specifying the behaviour of the following snippet?
</p>

<blockquote><pre>unordered_set&lt;int&gt; s;
unordered_set&lt;int&gt;::local_iterator it = s.end(0);

// Iterate past end - the unspecified part
it++;
</pre></blockquote>

<p>
I don't think there is anything about <tt>s.end(n)</tt> being considered an
iterator for the past-the-end value though (I think) it should be.
</p>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
We believe that this is not a substantive change, but the proposed
change to the wording is clearer than what we have now.
</blockquote>

<p><i>[
Post Summit:
]</i></p>


<blockquote>
Recommend Tentatively Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change Table 97 "Unordered associative container requirements" in 23.2.5 [unord.req]:
</p>

<blockquote>
<table border="1">
<caption>Table 97: Unordered associative container requirements</caption>
<tbody><tr>
<th>expression</th><th>return type</th><th>assertion/note pre/post-condition</th><th>complexity</th>
</tr>
<tr>
<td><tt>b.begin(n)</tt></td>
<td><tt>local_iterator</tt><br><tt>const_local_iterator</tt> for const <tt>b</tt>.</td>
<td>Pre: n shall be in the range [0,b.bucket_count()). <del>Note: [b.begin(n), b.end(n)) is a
valid range containing all of the elements in the n<sup>th</sup> bucket.</del>
<ins><tt>b.begin(n)</tt> returns an iterator referring to the first element in the bucket.
If the bucket is empty, then <tt>b.begin(n) == b.end(n)</tt>.</ins></td>
<td>Constant</td>
</tr>
<tr>
<td><tt>b.end(n)</tt></td>
<td><tt>local_iterator</tt><br><tt>const_local_iterator</tt> for const <tt>b</tt>.</td>
<td>Pre: n shall be in the range <tt>[0, b.bucket_count())</tt>.
<ins><tt>b.end(n)</tt> returns an iterator which is the past-the-end value for the bucket.</ins></td>
<td>Constant</td>
</tr>
</tbody></table>
</blockquote>






<hr>
<h3><a name="873"></a>873. signed integral type and unsigned integral type are not clearly defined</h3>
<p><b>Section:</b> 3.9.1 [basic.fundamental] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Travis Vitek <b>Opened:</b> 2008-06-30  <b>Last modified:</b> 2009-03-21</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
    <p>
      Neither the term "signed integral type" nor the term "unsigned
      integral type" is defined in the core language section of the
      standard, therefore the library section should avoid its use.  The
      terms <i>signed integer type</i> and <i>unsigned integer type</i> are
      indeed defined (in 3.9.1 [basic.fundamental]), thus the usages should be
      replaced accordingly.
    </p>

    <p>
      Note that the key issue here is that "signed" + "integral type" !=
      "signed integral type".
      
      The types <code>bool</code>, <code>char</code>, <code>char16_t</code>,
      <code>char32_t</code> and <code>wchar_t</code> are all listed as
      integral types, but are neither of <i>signed integer type</i> or
      <i>unsigned integer type</i>. According to 3.9 [basic.types] p7, a synonym for
      integral type is <i>integer type</i>.
      
      Given this, one may choose to assume that an <i>integral type</i> that
      can represent values less than zero is a <i>signed integral type</i>.
      Unfortunately this can cause ambiguities.
      
      As an example, if <code>T</code> is <code>unsigned char</code>, the
      expression <code>make_signed&lt;T&gt;::type</code>, is supposed to
      name a signed integral type. There are potentially two types that
      satisfy this requirement, namely <code>signed char</code> and
      <code>char</code> (assuming <code>CHAR_MIN &lt; 0</code>).
    </p>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
Plum, Sebor to review.
</blockquote>

<p><i>[
Post Summit Daniel adds:
]</i></p>


<blockquote>
The proposed resolution needs to be "conceptualized". Currently we have
in 14.10.4 [concept.support] only concept <tt>IntegralType</tt>
for all "integral types", thus indeed the current <tt>Container</tt>
concept and Iterator concepts are sufficiently satisfied with "integral
types". If the changes are applied, we might ask core for concept
<tt>BilateralIntegerType</tt> and add proper restrictions to the library
concepts.
</blockquote>

  

  <p><b>Proposed resolution:</b></p>
    <p>
      I propose to use the terms "signed integer type" and "unsigned integer
      type" in place of "signed integral type" and "unsigned integral type"
      to eliminate such ambiguities.
    </p>
    
    <p>
      The proposed change makes it absolutely clear that the difference
      between two pointers cannot be <tt>char</tt> or <tt>wchar_t</tt>,
      but could be any of the signed integer types.
      5.7 [expr.add] paragraph 6...
    </p>
    <blockquote>
      <p>
        </p><ol>
          <li>
            When two pointers to elements of the same array object are
            subtracted, the result is the difference of the subscripts of
            the two array elements. The type of the result is an
            implementation-defined <del>signed integral
            type</del><ins>signed integer type</ins>; this type shall be the
            same type that is defined as <code>std::ptrdiff_t</code> in the
            <code>&lt;cstdint&gt;</code> header (18.1)...
          </li>
        </ol>
      
    </blockquote>

    <p>
      The proposed change makes it clear that <tt>X::size_type</tt> and
      <tt>X::difference_type</tt> cannot be <tt>char</tt> or
      <tt>wchar_t</tt>, but could be one of the signed or unsigned integer
      types as appropriate.
      X [allocator.requirements] table 40...
    </p>
    <blockquote>
      Table 40: Allocator requirements
      <table border="1">
        <thead>
          <tr>
            <th>expression</th>
            <th>return type</th>
            <th>assertion/note/pre/post-condition</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><tt>X::size_type</tt></td>
            <td>
              <del>unsigned integral type</del>
              <ins>unsigned integer type</ins>
            </td>
            <td>a type that can represent the size of the largest object in
            the allocation model.</td>
          </tr>
          <tr>
            <td><tt>X::difference_type</tt></td>
            <td>
              <del>signed integral type</del>
              <ins>signed integer type</ins>
            </td>
            <td>a type that can represent the difference between any two
            pointers in the allocation model.</td>
          </tr>
        </tbody>
      </table>
    </blockquote>

    <p>
      The proposed change makes it clear that <tt>make_signed&lt;T&gt;::type</tt>
      must be one of the signed integer types as defined in 3.9.1. Ditto for
      <tt>make_unsigned&lt;T&gt;type</tt> and unsigned integer types.
      20.6.6.3 [meta.trans.sign] table 48...
    </p>
    <blockquote>
      Table 48: Sign modifications
      <table border="1">
        <thead>
          <tr>
            <th>Template</th>
            <th>Comments</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>
              <tt>template &lt;class T&gt; struct make_signed;</tt>
            </td>
            <td>
              If <code>T</code> names a (possibly cv-qualified) <del>signed
              integral type</del><ins>signed integer type</ins> (3.9.1) then
              the member typedef <code>type</code> shall name the type
              <code>T</code>; otherwise, if <code>T</code> names a (possibly
              cv-qualified) <del>unsigned integral type</del><ins>unsigned
              integer type</ins> then <code>type</code> shall name the
              corresponding <del>signed integral type</del><ins>signed
              integer type</ins>, with the same cv-qualifiers as
              <code>T</code>; otherwise, <code>type</code> shall name the
              <del>signed integral type</del><ins>signed integer type</ins>
              with the smallest rank (4.13) for which <code>sizeof(T) ==
              sizeof(type)</code>, with the same cv-qualifiers as
              <code>T</code>.

              <i>Requires:</i> <code>T</code> shall be a (possibly
              cv-qualified) integral type or enumeration but not a
              <code>bool</code> type.
            </td>
          </tr>
          <tr>
            <td>
              <tt>template &lt;class T&gt; struct make_unsigned;</tt>
            </td>
            <td>
              If <code>T</code> names a (possibly cv-qualified)
              <del>unsigned integral type</del><ins>unsigned integer
              type</ins> (3.9.1) then the member typedef <code>type</code>
              shall name the type <code>T</code>; otherwise, if
              <code>T</code> names a (possibly cv-qualified) <del>signed
              integral type</del><ins>signed integer type</ins> then
              <code>type</code> shall name the corresponding <del>unsigned
              integral type</del><ins>unsigned integer type</ins>, with the
              same cv-qualifiers as <code>T</code>; otherwise,
              <code>type</code> shall name the <del>unsigned integral
              type</del><ins>unsigned integer type</ins> with the smallest
              rank (4.13) for which <code>sizeof(T) == sizeof(type)</code>,
              with the same cv-qualifiers as <code>T</code>.

              <i>Requires:</i> <code>T</code> shall be a (possibly
              cv-qualified) integral type or enumeration but not a
              <code>bool</code> type.
            </td>
          </tr>
        </tbody>
      </table>
    </blockquote>


    <p>
      Note: I believe that the basefield values should probably be
      prefixed with <tt>ios_base::</tt> as they are in 22.4.2.2.2 [facet.num.put.virtuals]

      The listed virtuals are all overloaded on signed and unsigned integer
      types, the new wording just maintains consistency.

      22.4.2.1.2 [facet.num.get.virtuals] table 78...
    </p>
    <blockquote>
      Table 78: Integer Conversions
      <table border="1">
        <thead>
          <tr>
            <th>State</th>
            <th><tt>stdio</tt> equivalent</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><tt>basefield == oct</tt></td>
            <td><tt>%o</tt></td>
          </tr>
          <tr>
            <td><tt>basefield == hex</tt></td>
            <td><tt>%X</tt></td>
          </tr>
          <tr>
            <td><tt>basefield == 0</tt></td>
            <td><tt>%i</tt></td>
          </tr>
          <tr>
            <td><del>signed integral type</del><ins>signed integer
            type</ins></td>
            <td><tt>%d</tt></td>
          </tr>
          <tr>
            <td><del>unsigned integral type</del><ins>unsigned integer
            type</ins></td>
            <td><tt>%u</tt></td>
          </tr>
        </tbody>
      </table>
    </blockquote>

    
    
    <p>
      Rationale is same as above.
      22.4.2.2.2 [facet.num.put.virtuals] table 80...
    </p>
    <blockquote>
      Table 80: Integer Conversions
      <table border="1">
        <thead>
          <tr>
            <th>State</th>
            <th><tt>stdio</tt> equivalent</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><tt>basefield == ios_base::oct</tt></td>
            <td><tt>%o</tt></td>
          </tr>
          <tr>
            <td><tt>(basefield == ios_base::hex) &amp;&amp;
            !uppercase</tt></td>
            <td><tt>%x</tt></td>
          </tr>
          <tr>
            <td><tt>(basefield == ios_base::hex)</tt></td>
            <td><tt>%X</tt></td>
          </tr>
          <tr>
            <td><tt>basefield == 0</tt></td>
            <td><tt>%i</tt></td>
          </tr>
          <tr>
            <td>for a <del>signed integral type</del><ins>signed integer
            type</ins></td>
            <td><tt>%d</tt></td>
          </tr>
          <tr>
            <td>for a <del>unsigned integral type</del><ins>unsigned integer
            type</ins></td>
            <td><tt>%u</tt></td>
          </tr>
        </tbody>
      </table>
    </blockquote>

    
    <p>
      23.2 [container.requirements] table 80...
    </p>
    <blockquote>
      Table 89: Container requirements
      <table border="1">
        <thead>
          <tr>
            <th>expression</th>
            <th>return type</th>
            <th>operational semantics</th>
            <th>assertion/note/pre/post-condition</th>
            <th>complexity</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><tt>X::difference_type</tt></td>
            <td><del>signed integral type</del><ins>signed integer type</ins></td>
            <td>&nbsp;</td>
            <td>is identical to the difference type of <tt>X::iterator</tt>
            and <tt>X::const_iterator</tt></td>
            <td>compile time</td>
          </tr>
          <tr>
            <td><tt>X::size_type</tt></td>
            <td><del>unsigned integral type</del><ins>unsigned integer type</ins></td>
            <td>&nbsp;</td>
            <td><tt>size_type</tt> can represent any non-negative value of
            <tt>difference_type</tt></td>
            <td>compile time</td>
          </tr>
        </tbody>
      </table>
    </blockquote>

    <p>
      24.2 [iterator.concepts] paragraph 1...
    </p>
    <blockquote>
      Iterators are a generalization of pointers that allow a C++ program to
      work with different data structures (containers) in a uniform manner.
      To be able to construct template algorithms that work correctly and
      efficiently on different types of data structures, the library
      formalizes not just the interfaces but also the semantics and
      complexity assumptions of iterators. All input iterators
      <code>i</code> support the expression <code>*i</code>, resulting in a
      value of some class, enumeration, or built-in type <code>T</code>,
      called the <i>value type</i> of the iterator. All output iterators
      support the expression <code>*i = o</code> where <code>o</code> is a
      value of some type that is in the set of types that are
      <i>writable</i> to the particular iterator type of <code>i</code>. All
      iterators <code>i</code> for which the expression <code>(*i).m</code>
      is well-defined, support the expression <code>i-&gt;m</code> with the
      same semantics as <code>(*i).m</code>. For every iterator type
      <code>X</code> for which equality is defined, there is a corresponding
      <del>signed integral type</del> <ins>signed integer type</ins> called
      the <i>difference type</i> of the iterator.
    </blockquote>
    
    <p>
      I'm a little unsure of this change. Previously this paragraph would
      allow instantiations of <tt>linear_congruential_engine</tt> on
      <tt>char</tt>, <tt>wchar_t</tt>, <tt>bool</tt>, and other types. The
      new wording prohibits this.
      26.5.3.1 [rand.eng.lcong] paragraph 2...
    </p>
    <blockquote>
      The template parameter <code>UIntType</code> shall denote an
      <del>unsigned integral type</del><ins>unsigned integer type</ins>
      large enough to store values as large as <code>m - 1</code>. If the
      template parameter <code>m</code> is 0, the modulus <code>m</code>
      used throughout this section 26.4.3.1 is
      <code>numeric_limits&lt;result_type&gt;::max()</code> plus 1.  [Note:
      The result need not be representable as a value of type
      <code>result_type</code>. --end note] Otherwise, the following
      relations shall hold: <code>a &lt; m</code> and <code>c &lt;
      m</code>.
    </blockquote>
    
    <p>
      Same rationale as the previous change.
      X [rand.adapt.xor] paragraph 6...
    </p>
    <blockquote>
      Both <code>Engine1::result_type</code> and
      <code>Engine2::result_type</code> shall denote (possibly different)
      <del>unsigned integral types</del><ins>unsigned integer types</ins>.
      The member <i>result_type</i> shall denote either the type
      <i>Engine1::result_type</i> or the type <i>Engine2::result_type</i>,
      whichever provides the most storage according to clause 3.9.1.
    </blockquote>
    
    <p>
      26.5.7.1 [rand.util.seedseq] paragraph 7...
    </p>
    <blockquote>
      <i>Requires:</i><code>RandomAccessIterator</code> shall meet the
      requirements of a random access iterator (24.1.5) such that
      <code>iterator_traits&lt;RandomAccessIterator&gt;::value_type</code>
      shall denote an <del>unsigned integral type</del><ins>unsigned integer
      type</ins> capable of accomodating 32-bit quantities.  
    </blockquote>

    <p>
      By making this change, integral types that happen to have a signed
      representation, but are not signed integer types, would no longer be
      required to use a two's complement representation. This may go against
      the original intent, and should be reviewed.
      29.6 [atomics.types.operations] paragraph 24...
    </p>
    <blockquote>
      <i>Remark:</i> For <del>signed integral types</del><ins>signed integer
      types</ins>, arithmetic is defined using two's complement
      representation. There are no undefined results. For address types, the
      result may be an undefined address, but the operations otherwise have
      no undefined behavior.
    </blockquote>
    
  




<hr>
<h3><a name="876"></a>876. <tt>basic_string</tt> access operations should give stronger guarantees</h3>
<p><b>Section:</b> 21.4 [basic.string] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2008-08-22  <b>Last modified:</b> 2008-09-18</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#basic.string">active issues</a> in [basic.string].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#basic.string">issues</a> in [basic.string].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
During the Sophia Antipolis meeting it was decided to split-off some
parts of the
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2647.html">n2647</a>
("Concurrency modifications for <tt>basic_string</tt>")
proposal into a separate issue, because these weren't actually
concurrency-related. The here proposed changes refer to the recent
update document
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2668.htm">n2668</a>
and attempt to take advantage of the
stricter structural requirements.
</p>
<p>
Indeed there exists some leeway for more guarantees that would be
very useful for programmers, especially if interaction with transactionary
or exception-unaware C API code is important. This would also allow
compilers to take advantage of more performance optimizations, because
more functions can have throw() specifications. This proposal uses the
form of "Throws: Nothing" clauses to reach the same effect, because
there already exists a different issue in progress to clean-up the current
existing "schizophrenia" of the standard in this regard.
</p>
<p>
Due to earlier support for copy-on-write, we find the following
unnecessary limitations for C++0x:
</p>

<ol>
<li>
Missing no-throw guarantees: <tt>data()</tt> and <tt>c_str()</tt> simply return
a pointer to their guts, which is a non-failure operation. This should
be spelled out. It is also noteworthy to mention that the same
guarantees should also be given by the size query functions,
because the combination of pointer to content and the length is
typically needed during interaction with low-level API.
</li>
<li>
Missing complexity guarantees: <tt>data()</tt> and <tt>c_str()</tt> simply return
a pointer to their guts, which is guaranteed O(1). This should be
spelled out.
</li>
<li>
Missing reading access to the terminating character: Only the
const overload of <tt>operator[]</tt> allows reading access to the terminator
char. For more intuitive usage of strings, reading access to this
position should be extended to the non-const case. In contrast
to C++03 this reading access should now be homogeneously
an lvalue access.
</li>
</ol>

<p>
The proposed resolution is split into a main part (A) and a
secondary part (B) (earlier called "Adjunct Adjunct Proposal").
(B) extends (A) by also making access to index position
size() of the at() overloads a no-throw operation. This was
separated, because this part is theoretically observable in
specifically designed test programs.
</p>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
<p>
We oppose part 1 of the issue but hope to address <tt>size()</tt> in
issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#877">877</a>.
</p>
<p>
We do not support part B. 4 of the issue because of the breaking API change.
</p>
<p>
We support part A. 2 of the issue.
</p>
<p>
On support part A. 3 of the issue:
</p>
<blockquote>
Pete's broader comment: now that we know that basic_string will be a
block of contiguous memory, we should just rewrite its specification
with that in mind. The expression of the specification will be simpler
and probably more correct as a result.
</blockquote>
</blockquote>


<p><b>Proposed resolution:</b></p>
<ol type="A">
<li>
<ol>
<li>
<p>In 21.4.4 [string.capacity], just after p. 1 add a new paragraph:
</p>
<blockquote>
<i>Throws:</i> Nothing.
</blockquote>

</li>
<li>
<p>
In 21.4.5 [string.access] <em>replace</em> p. 1 by the following <em>4</em> paragraghs:
</p>

<blockquote>
<p>
<i>Requires:</i> <tt>pos &#8804; size()</tt>.
</p>
<p>
<i>Returns:</i> If <tt>pos &lt; size()</tt>, returns <tt>*(begin() + pos)</tt>. Otherwise, returns
a reference to a <tt>charT()</tt> that shall not be modified.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
<p>
<i>Complexity:</i> Constant time.
</p>
</blockquote>

</li>
<li>
<p>
In 21.4.7.1 [string.accessors] replace the now <em>common</em> returns
clause of <tt>c_str()</tt> and <tt>data()</tt> by the following <em>three</em> paragraphs:
</p>
<blockquote>
<p>
<i>Returns:</i> A pointer <tt>p</tt> such that <tt>p+i == &amp;operator[](i)</tt> for each <tt>i</tt>
in <tt>[0, size()]</tt>.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
<p>
<i>Complexity:</i> Constant time.
</p>
</blockquote>
</li>
</ol>
</li>
<li>
<ol start="4">
<li>
<p>
In 21.4.5 [string.access] <em>replace</em> p.2 and p.3 by:
</p>
<blockquote>
<p>
<i>Requires:</i> <tt>pos &#8804; size()</tt>
</p>
<p>
<i>Throws:</i> <tt>out_of_range</tt> if <tt>pos &gt; size()</tt>.
</p>
</blockquote>
</li>
</ol>
</li>
</ol>






<hr>
<h3><a name="877"></a>877. to <tt>throw()</tt> or to <i>Throw:</i> Nothing.</h3>
<p><b>Section:</b> 17 [library] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2008-08-23  <b>Last modified:</b> 2008-09-18</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
       <p>

Recent changes to
the <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2691.pdf">working
draft</a> have introduced a gratuitous inconsistency with the C++ 2003
version of the specification with respect to exception guarantees
provided by standard functions. While the C++ 2003 standard
consistenly uses the empty exception specification, <tt>throw()</tt>,
to declare functions that are guaranteed not to throw exceptions, the
current working draft contains a number of "<i>Throws:</i> Nothing."
clause to specify essentially the same requirement. The difference
between the two approaches is that the former specifies the behavior
of programs that violate the requirement (<tt>std::unexpected()</tt>
is called) while the latter leaves the behavior undefined.

       </p>
       <p>

A survey of the working draft reveals that there are a total of 209
occurrences of <tt>throw()</tt> in the library portion of the spec,
the majority in clause 18, a couple (literally) in 19, a handful in
20, a bunch in 22, four in 24, one in 27, and about a dozen in D.9.

       </p>
       <p>

There are also 203 occurrences of "<i>Throws:</i> Nothing." scattered
throughout the spec.

       </p>
       <p>

While sometimes there are good reasons to use the "<i>Throws:</i>
Nothing."  approach rather than making use of <tt>throw()</tt>, these
reasons do not apply in most of the cases where this new clause has
been introduced and the empty exception specification would be a
better approach.

       </p>
       <p>

First, functions declared with the empty exception specification
permit compilers to generate better code for calls to such
functions. In some cases, the compiler might even be able to eliminate
whole chunks of user-written code when instantiating a generic
template on a type whose operations invoked from the template
specialization are known not to throw. The prototypical example are
the <tt>std::uninitialized_copy()</tt>
and <tt>std::uninitialized_fill()</tt> algorithms where the
entire <tt>catch(...)</tt> block can be optimized away.

       </p>
       <p>

For example, given the following definition of
the <tt>std::uninitialized_copy</tt> function template and a
user-defined type <tt>SomeType</tt>:

       </p>
       <blockquote>
           <pre>template &lt;class InputIterator, class ForwardIterator&gt;
ForwardIterator
uninitialized_copy (InputIterator first, InputIterator last, ForwardIterator res)
{
   typedef iterator_traits&lt;ForwardIterator&gt;::value_type ValueType;

   ForwardIterator start = res;

   try {
       for (; first != last; ++first, ++res)
           ::new (&amp;*res) ValueType (*first);
   }
   catch (...) {
       for (; start != res; --start)
           (&amp;*start)-&gt;~ValueType ();
       throw;
   }
   return res;
}

struct SomeType {
   SomeType (const SomeType&amp;) <ins>throw ()</ins>;
}</pre>
       </blockquote>
       <p>

compilers are able to emit the following efficient specialization
of <tt>std::uninitialized_copy&lt;const SomeType*, SomeType*&gt;</tt>
(note that the <tt>catch</tt> block has been optimized away):

       </p>
       <blockquote>
           <pre>template &lt;&gt; SomeType*
uninitialized_copy (const SomeType *first, const SomeType *last, SomeType *res)
{
   for (; first != last; ++first, ++res)
       ::new (res) SomeType (*first);

   return res;
}</pre>
       </blockquote>
       <p>

Another general example is default constructors which, when decorated
with <tt>throw()</tt>, allow the compiler to eliminate the
implicit <tt>try</tt> and <tt>catch</tt> blocks that it otherwise must
emit around each the invocation of the constructor
in <i>new-expressions</i>.

       </p>
       <p>

For example, given the following definitions of
class <tt>MayThrow</tt> and <tt>WontThrow</tt> and the two
statements below:

       </p>
       <blockquote>
           <pre>struct MayThrow {
   MayThrow ();
};

struct WontThrow {
   WontThrow () <ins>throw ()</ins>;
};

MayThrow  *a = new MayThrow [N];
WontThrow *b = new WontThrow [N];</pre>

       </blockquote>
       <p>

the compiler generates the following code for the first statement:

       </p>
       <blockquote>
           <pre>MayThrow *a;
{
   MayThrow *first = operator new[] (N * sizeof (*a));
   MayThrow *last  = first + N;
   MayThrow *next  = first;
   try {
       for ( ; next != last; ++next)
           new (next) MayThrow;
   }
   catch (...) {
       for ( ; first != first; --next)
           next-&gt;~MayThrow ();
       operator delete[] (first);
       throw;
   }
   a = first;
}</pre>
       </blockquote>
       <p>

but it is can generate much more compact code for the second statement:

       </p>
       <blockquote>
           <pre>WontThrow *b    = operator new[] (N * sizeof (*b));
WontThrow *last = b + N;
for (WontThrow *next = b; next != last; ++next)
   new (next) WontThrow;
</pre>
       </blockquote>
       <p>

Second, in order for users to get the maximum benefit out of the new
<tt>std::has_nothrow_xxx</tt> traits when using standard library types
it will be important for implementations to decorate all non throwing
copy constructors and assignment operators with <tt>throw()</tt>. Note
that while an optimizer may be able to tell whether a function without
an explicit exception specification can throw or not based on its
definition, it can only do so when it can see the source code of the
definition. When it can't it must assume that the function may
throw. To prevent violating the One Definition Rule,
the <tt>std::has_nothrow_xxx</tt> trait must return the most
pessimistic guess across all translation units in the program, meaning
that <tt>std::has_nothrow_xxx&lt;T&gt;::value</tt> must evaluate to
<tt>false</tt> for any <tt>T</tt> whose <tt>xxx</tt>
(where <tt>xxx</tt> is default or copy ctor, or assignment operator)
is defined out-of-line.

       </p>
       <p>

<b>Counterarguments:</b>

       </p>
       <p>

During the discussion of this issue
on <a href="mailto:c++std-lib@accu.org">c++std-lib@accu.org</a>
(starting with post <tt>c++std-lib-21950</tt>) the following arguments
in favor of the "<i>Throws:</i> Nothing." style have been made.

       </p>
       <p>
         </p><ol>
           <li>

Decorating functions that cannot throw with the empty exception
specification can cause the compiler to generate suboptimal code for
the implementation of the function when it calls other functions that
aren't known to the compiler not to throw (i.e., that aren't decorated
with <tt>throw()</tt> even if they don't actually throw). This is a
common situation when the called function is a C or POSIX function.

           </li>
           <li>

Alternate, proprietary mechanisms exist (such as
GCC <a href="http://gcc.gnu.org/onlinedocs/gcc-4.3.0/gcc/Function-Attributes.html#index-g_t_0040code_007bnothrow_007d-function-attribute-2160"><tt>__attribute__((nothrow))</tt></a>
or Visual
C++ <a href="http://msdn.microsoft.com/en-us/library/49147z04%28VS.80%29.aspx"><tt>__declspec(nothrow)</tt></a>)
that let implementers mark up non-throwing functions, often without
the penalty mentioned in (1) above. The C++ standard shouldn't
preclude the use of these potentially more efficient mechanisms.

           </li>
           <li>

There are functions, especially function templates, that invoke
user-defined functions that may or may not be
declared <tt>throw()</tt>. Declaring such functions with the empty
exception specification will cause compilers to generate suboptimal
code when the user-defined function isn't also declared not to throw.

           </li>
        </ol>
       
       <p>

The answer to point (1) above is that implementers can (and some have)
declare functions with <tt>throw()</tt> to indicate to the compiler
that calls to the function can safely be assumed not to throw in order
to allow it to generate efficient code at the call site without also
having to define the functions the same way and causing the compiler
to generate suboptimal code for the function definition. That is, the
function is declared with <tt>throw()</tt> in a header but it's
defined without it in the source file. The <tt>throw()</tt>
declaration is suppressed when compiling the definition to avoid
compiler errors. This technique, while strictly speaking no permitted
by the language, is safe and has been employed in practice. For
example, the GNU C library takes this approach. Microsoft Visual C++
takes a similar approach by simply assuming that no function with C
language linkage can throw an exception unless it's explicitly
declared to do so using the language extension <tt>throw(...)</tt>.

       </p>
       <p>

Our answer to point (2) above is that there is no existing practice
where C++ Standard Library implementers have opted to make use of the
proprietary mechanisms to declare functions that don't throw. The
language provides a mechanism specifically designed for this
purpose. Avoiding its use in the specification itself in favor of
proprietary mechanisms defeats the purpose of the feature. In
addition, making use of the empty exception specification
inconsistently, in some areas of the standard, while conspicuously
avoiding it and making use of the "<i>Throws:</i> Nothing." form in
others is confusing to users.

       </p>
       <p>

The answer to point (3) is simply to exercise caution when declaring
functions and especially function templates with the empty exception
specification. Functions that required not to throw but that may call
back into user code are poor candidates for the empty exception
specification and should instead be specified using "<i>Throws:</i>
Nothing." clause.

      </p>
   
   <p><b>Proposed resolution:</b></p>
       <p>

We propose two possible solutions. Our recommendation is to adopt
Option 1 below.

       </p>
       <p>

<b>Option 1:</b>

       </p>
       <p>

Except for functions or function templates that make calls back to
user-defined functions that may not be declared <tt>throw()</tt>
replace all occurrences of the "<i>Throws:</i> Nothing." clause with
the empty exception specification. Functions that are required not to
throw but that make calls back to user code should be specified to
"<i>Throw:</i> Nothing."

       </p>
       <p>

<b>Option 2:</b>

       </p>
       <p>

For consistency, replace all occurrences of the empty exception
specification with a "<i>Throws:</i> Nothing." clause.

       </p>
   



<hr>
<h3><a name="878"></a>878. <tt>forward_list</tt> preconditions</h3>
<p><b>Section:</b> 23.3.3 [forwardlist] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2008-08-23  <b>Last modified:</b> 2009-05-10</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
       <p>

<tt>forward_list</tt> member functions that take
a <tt>forward_list::iterator</tt> (denoted <tt>position</tt> in the
function signatures) argument have the following precondition:

       </p>
       <blockquote>

<i>Requires:</i> <tt>position</tt> is dereferenceable or equal
to <tt>before_begin()</tt>.

       </blockquote>
       <p>

I believe what's actually intended is this:

       </p>
       <blockquote>

<i>Requires:</i> <tt>position</tt> is in the range
[<tt>before_begin()</tt>, <tt>end()</tt>).

       </blockquote>
       <p>

That is, when it's dereferenceable, <tt>position</tt> must point
into <tt>*this</tt>, not just any <tt>forward_list</tt> object.

       </p>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
Robert suggested alternate proposed wording which had large support.
</blockquote>

<p><i>[
Post Summit:
]</i></p>


<blockquote>
<p>
Walter: "position is before_begin() or a dereferenceable": add "is" after the "or"
</p>
<p>
With that minor update, Recommend Tentatively Ready.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
       <p>

Change the <i>Requires</i> clauses
 [forwardlist] , p21, p24, p26, p29, and,
23.3.3.5 [forwardlist.ops], p39, p43, p47
as follows:

       </p>
       <blockquote>

<i>Requires:</i> <tt>position</tt> is <ins><tt>before_begin()</tt> or is a</ins>
dereferenceable
<ins>iterator in the range <tt>[begin(), end())</tt></ins>
<del>or equal to <tt>before_begin()</tt></del>. ...

       </blockquote>
   



<hr>
<h3><a name="879"></a>879. Atomic load const qualification</h3>
<p><b>Section:</b> 29 [atomics] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Review">Review</a>
 <b>Submitter:</b> Alexander Chemeris <b>Opened:</b> 2008-08-24  <b>Last modified:</b> 2009-03-22</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#atomics">active issues</a> in [atomics].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#atomics">issues</a> in [atomics].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Review">Review</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <tt>atomic_address</tt> type and <tt>atomic&lt;T*&gt;</tt> specialization provide atomic
updates to pointers.  However, the current specification requires
that the types pointer be to non-const objects.  This restriction
is unnecessary and unintended.
</p>

<p><i>[
Summit:
]</i></p>

<blockquote>
Move to review.  Lawrence will first check with Peter whether the
current examples are sufficient, or whether they need to be expanded to
include all cases.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Add const qualification to the pointer values of the <tt>atomic_address</tt>
and <tt>atomic&lt;T*&gt;</tt> specializations.  E.g.
</p>

<blockquote><pre>typedef struct atomic_address {
   void store(<ins>const</ins> void*, memory_order = memory_order_seq_cst) volatile;
   void* exchange( <ins>const</ins> void*, memory_order = memory_order_seq_cst) volatile;
   bool compare_exchange( <ins>const</ins> void*&amp;, <ins>const</ins> void*,
                          memory_order, memory_order) volatile;
   bool compare_exchange( <ins>const</ins> void*&amp;, <ins>const</ins> void*,
                          memory_order = memory_order_seq_cst ) volatile;
   void* operator=(<ins>const</ins> void*) volatile;
} atomic_address;

void atomic_store(volatile atomic_address*, <ins>const</ins> void*);
void atomic_store_explicit(volatile atomic_address*, <ins>const</ins> void*,
                          memory_order);
void* atomic_exchange(volatile atomic_address*<ins>, const void*</ins>);
void* atomic_exchange_explicit(volatile atomic_address*, <ins>const</ins> void*,
                              memory_order);
bool atomic_compare_exchange(volatile atomic_address*,
                            <ins>const</ins> void**, <ins>const</ins> void*);
bool atomic_compare_exchange_explicit(volatile atomic_address*,
                                     <ins>const</ins> void**, <ins>const</ins> void*,
                                     memory_order, memory_order);
</pre></blockquote>





<hr>
<h3><a name="880"></a>880. Missing atomic exchange parameter</h3>
<p><b>Section:</b> 29 [atomics] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Lawrence Crowl <b>Opened:</b> 2008-08-24  <b>Last modified:</b> 2009-03-22</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#atomics">active issues</a> in [atomics].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#atomics">issues</a> in [atomics].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#942">942</a></p>
<p><b>Discussion:</b></p>
<p>
The <tt>atomic_exchange</tt> and <tt>atomic_exchange_explicit</tt> functions seem to
be inconsistently missing parameters.
</p>

<p><i>[
Post Summit:
]</i></p>


<blockquote>
<p>
Lawrence: Need to write up a list for Pete with details.
</p>
<p>
Detlef: Should not be New, we already talked about in Concurrency group.
</p>
<p>
Recommend Open.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Add the appropriate parameters.  For example,
</p>

<blockquote><pre>bool atomic_exchange(volatile atomic_bool*<ins>, bool</ins>);
bool atomic_exchange_explicit(volatile atomic_bool*, bool<ins>, memory_order</ins>);
</pre></blockquote>





<hr>
<h3><a name="881"></a>881. shared_ptr conversion issue</h3>
<p><b>Section:</b> 20.8.13.2.1 [util.smartptr.shared.const] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Peter Dimov <b>Opened:</b> 2008-08-30  <b>Last modified:</b> 2008-09-18</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#util.smartptr.shared.const">active issues</a> in [util.smartptr.shared.const].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#util.smartptr.shared.const">issues</a> in [util.smartptr.shared.const].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
We've changed <tt>shared_ptr&lt;Y&gt;</tt> to not convert to <tt>shared_ptr&lt;T&gt;</tt> when <tt>Y*</tt>
doesn't convert to <tt>T*</tt> by resolving issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#687">687</a>. This only fixed the
converting copy constructor though.
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2351.htm">N2351</a>
later added move support, and
the converting move constructor is not constrained.
</p>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
We might be able to move this to NAD, Editorial once shared_ptr is
conceptualized, but we want to revisit this issue to make sure.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
We need to change the Requires clause of the move constructor:
</p>

<blockquote><pre>shared_ptr(shared_ptr&amp;&amp; r); 
template&lt;class Y&gt; shared_ptr(shared_ptr&lt;Y&gt;&amp;&amp; r); 
</pre>
<blockquote>
<i>Requires:</i> <del>For the second constructor <tt>Y*</tt> shall be
convertible to <tt>T*</tt>.</del>
<ins>
The second constructor shall not participate in overload resolution
unless <tt>Y*</tt> is convertible to <tt>T*</tt>.
</ins>
</blockquote>
</blockquote>

<p>
in order to actually make the example in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#687">687</a> compile
(it now resolves to the move constructor).
</p>






<hr>
<h3><a name="883"></a>883. swap circular definition</h3>
<p><b>Section:</b> 23 [containers] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2008-09-10  <b>Last modified:</b> 2009-03-11</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#containers">active issues</a> in [containers].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#containers">issues</a> in [containers].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Note in particular that Table 90 "Container Requirements" gives
semantics of <tt>a.swap(b)</tt> as <tt>swap(a,b)</tt>, yet for all
containers we define <tt>swap(a,b)</tt> to call <tt>a.swap(b)</tt> - a
circular definition.
</p>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
Robert to propose a resolution along the lines of "Postcondition: "a =
b, b = a" This will be a little tricky for the hash containers, since
they don't have <tt>operator==</tt>.
</blockquote>

<p><i>[
Post Summit Anthony Williams provided proposed wording.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
In table 80 in section 23.2.1 [container.requirements.general],
replace the postcondition of <tt>a.swap(b)</tt> with the following:
</p>

<blockquote>
<table border="1">
<caption>Table 80 -- Container requirements</caption>
<tbody><tr>
<th>Expression</th>
<th>Return type</th>
<th>Operational semantics</th>
<th>Assertion/note pre-/post-conidtion</th>
<th>Complexity</th>
</tr>
<tr>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
<tr>
<td><tt>a.swap(b);</tt></td>
<td><tt>void</tt></td>
<td>&nbsp;</td>
<td><del><tt>swap(a,b)</tt></del>
<ins>Exchange the contents of <tt>a</tt> and <tt>b</tt> as-if<br>
<tt>X u=std::move(a);<br>
a=std::move(b);<br>
b=std::move(u);</tt></ins></td>
<td>(Note A)</td>
</tr>
</tbody></table>
</blockquote>

<p>
Remove the reference to swap from the paragraph following the table.
</p>

<blockquote>
Notes: the algorithms <del><tt>swap()</tt>, </del><tt>equal()</tt> and
<tt>lexicographical_compare()</tt> are defined in Clause 25. ...
</blockquote>





<hr>
<h3><a name="884"></a>884. shared_ptr swap</h3>
<p><b>Section:</b> 20.8.13.2.4 [util.smartptr.shared.mod] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">Tentatively NAD Editorial</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2008-09-15  <b>Last modified:</b> 2009-05-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20NAD%20Editorial">Tentatively NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<blockquote><pre>#include &lt;memory&gt;
#include &lt;cassert&gt;

struct A { };
struct B : A { };

int main()
{
    std::shared_ptr&lt;A&gt; pa(new A);
    std::shared_ptr&lt;B&gt; pb(new B);
    std::swap&lt;A&gt;(pa, pb);  // N.B. no argument deduction
    assert( pa.get() == pb.get() );
    return 0;
}
</pre></blockquote>

<p>
Is this behaviour correct (I believe it is) and if so, is it
unavoidable, or not worth worrying about?
</p>

<p>
This calls the lvalue/rvalue swap overload for <tt>shared_ptr</tt>:
</p>

<blockquote><pre>template&lt;class T&gt; void swap( shared_ptr&lt;T&gt; &amp; a, shared_ptr&lt;T&gt; &amp;&amp; b );
</pre></blockquote>

<p>
silently converting the second argument from <tt>shared_ptr&lt;B&gt;</tt> to
<tt>shared_ptr&lt;A&gt;</tt> and binding the rvalue ref to the produced temporary.
</p>

<p>
This is not, in my opinion, a <tt>shared_ptr</tt> problem; it is a general issue
with the rvalue swap overloads. Do we want to prevent this code from
compiling? If so, how?
</p>

<p>
Perhaps we should limit rvalue args to swap to those types that would
benefit from the "swap trick".  Or, since we now have <tt>shrink_to_fit()</tt>, just
eliminate the rvalue swap overloads altogether.  The original motivation
was:
</p>

<blockquote><pre>vector&lt;A&gt; v = ...;
...
swap(v, vector&lt;A&gt;(v));
</pre></blockquote>

<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1690.html#Improved%20swap%20Interface">N1690</a>.

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution.
Move to NAD Editorial.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Recommend NAD Editorial, fixed by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2844.html">N2844</a>.
</p>





<hr>
<h3><a name="885"></a>885. pair assignment</h3>
<p><b>Section:</b> 20.3.3 [pairs] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2008-09-15  <b>Last modified:</b> 2009-05-25</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#pairs">active issues</a> in [pairs].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#pairs">issues</a> in [pairs].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<blockquote><pre>20.2.3 pairs
Missing assignemnt operator:
template&lt;class U , class V&gt;
  requires CopyAssignable&lt;T1, U&gt; &amp;&amp; CopyAssignable&lt;T2, V&gt;
    pair&amp; operator=(pair&lt;U , V&gt; const &amp; p );
</pre></blockquote>

<p>
Well, that's interesting. This assignment operator isn't in the
current working paper, either. Perhaps we deemed it acceptable to
build a temporary of type <tt>pair</tt> from <tt>pair&lt;U, V&gt;</tt>, then move-assign
from that temporary?
</p>
<p>
It sounds more like an issue waiting to be opened, unless you want to plug
it now.  As written we risk moving from lvalues.
</p>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
<p>
Would be NAD if better ctors fixed it.
</p>
<p>
Related to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#811">811</a>.
</p>
</blockquote>

<p><i>[
post San Francisco:
]</i></p>


<blockquote>
Possibly NAD Editorial, solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2770.pdf">N2770</a>.
</blockquote>

<p><i>[
2009-05-25 Alisdair adds:
]</i></p>


<blockquote>
Issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#885">885</a> was something I reported while reviewing the library concepts
documents ahead of San Francisco.  The missing operator was added as part of
the paper adopted at that meeting
(<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2770.pdf">N2770</a>)
and I can confirm this operator is
present in the current working paper.  I recommend NAD.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="886"></a>886. tuple construction</h3>
<p><b>Section:</b> 20.5.2.1 [tuple.cnstr] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2008-09-15  <b>Last modified:</b> 2009-05-05</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#tuple.cnstr">active issues</a> in [tuple.cnstr].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#tuple.cnstr">issues</a> in [tuple.cnstr].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
20.5.2.1 [tuple.cnstr]:
</p>
<blockquote>
<i>Effects:</i> Default initializes each element.
</blockquote>

<p>
Could be clarified to state each "non-trivial" element.  Otherwise
we have a conflict with Core deinfition of default initialization -
trivial types do not get initialized (rather than initialization
having no effect)
</p>

<p>
I'm going to punt on this one, because it's not an issue that's
related to concepts. I suggest bringing it to Howard's attention on
the reflector.
</p>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
<p>
Text in draft doesn't mean anything, changing to "non-trivial" makes it
meaningful.
</p>
<p>
We prefer "value initializes". Present implementations use
value-initialization. Users who don't want value initialization have
alternatives.
</p>
<p>
Request resolution text from Alisdair.
</p>

<p>
This issue relates to Issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#868">868</a> default construction and value-initialization.
</p>
</blockquote>

<p><i>[
2009-05-04 Alisdair provided wording and adds:
]</i></p>


<blockquote>
<p>
Note: This <em>IS</em> a change of semantic from TR1, although one the room agreed
with during the discussion.  To preserve TR1 semantics, this would have been
worded:
</p>
<blockquote><pre>requires DefaultConstructible&lt;Types&gt;... tuple();
</pre>
<blockquote>
-2-   <i>Effects:</i> Default-initializes each non-trivial element.
</blockquote>
</blockquote>


</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change p2 in Construction 20.5.2.1 [tuple.cnstr]:
</p>

<blockquote><pre>requires DefaultConstructible&lt;Types&gt;... tuple();
</pre>
<blockquote>
<p>
-2- <i>Effects:</i> <del>Default</del> <ins>Value-</ins>initializes each element.
</p>
</blockquote>
</blockquote>






<hr>
<h3><a name="887"></a>887. issue with condition::wait_...</h3>
<p><b>Section:</b> 30.5.1 [thread.condition.condvar] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Lawrence Crowl <b>Opened:</b> 2008-09-15  <b>Last modified:</b> 2009-03-09</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#thread.condition.condvar">active issues</a> in [thread.condition.condvar].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.condition.condvar">issues</a> in [thread.condition.condvar].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The Posix/C++ working group has identified an inconsistency between
Posix and the C++ working draft in that Posix requires the clock to be
identified at creation, whereas C++ permits identifying the clock at the
call to wait.  The latter cannot be implemented with the former.
</p>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
<p>
Howard recommends NAD with the following explanation:
</p>

<p>
The intent of the current wording is for the <tt>condtion_variable::wait_until</tt>
be able to handle user-defined clocks as well as clocks the system knows about.
This can be done by providing overloads for the known clocks, and another
overload for unknown clocks which synchs to a known clock before waiting.
For example:
</p>

<blockquote><pre>template &lt;class Duration&gt;
bool
condition_variable::wait_until(unique_lock&lt;mutex&gt;&amp; lock,
                               const chrono::time_point&lt;chrono::system_clock, Duration&gt;&amp; abs_time)
{
    using namespace chrono;
    nanoseconds d = __round_up&lt;nanoseconds&gt;(abs_time.time_since_epoch());
    __do_timed_wait(lock.mutex()-&gt;native_handle(), time_point&lt;system_clock, nanoseconds&gt;(d));
    return system_clock::now() &lt; abs_time;
}

template &lt;class Clock, class Duration&gt;
bool
condition_variable::wait_until(unique_lock&lt;mutex&gt;&amp; lock,
                               const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time)
{
    using namespace chrono;
    typename Clock::time_point  c_entry = Clock::now();
    system_clock::time_point    s_entry = system_clock::now();
    nanoseconds dn = __round_up&lt;nanoseconds&gt;(abs_time.time_since_epoch() -
                                              c_entry.time_since_epoch());
    __do_timed_wait(lock.mutex()-&gt;native_handle(), s_entry + dn);
    return Clock::now() &lt; abs_time;
}
</pre></blockquote>

<p>
In the above example, <tt>system_clock</tt> is the only clock which the underlying
condition variable knows how to deal with.  One overload just passes that clock
through.  The second overload (approximately) converts the unknown clock into
a <tt>system_clock  time_point</tt> prior to passing it down to the native
condition variable.
</p>

<p>
On Posix systems vendors are free to add implementation defined constructors which
take a clock.  That clock can be stored in the condition_variable, and converted
to (or not as necessary) as shown above.
</p>

<p>
If an implementation defined constructor takes a clock (for example), then part
of the semantics for that implementation defined ctor might include that a
<tt>wait_until</tt> using a clock other than the one constructed with results
in an error (exceptional condition) instead of a conversion to the stored clock.
Such a design is up to the vendor as once an implementation defined ctor is used,
the vendor is free to specifiy the behavior of waits and/or notifies however
he pleases (when the cv is constructed in an implementation defined manner).
</p>
</blockquote>

<p><i>[
Post Summit:
]</i></p>


<blockquote>
<p>
"POSIX people will review the proposed NAD resolution at their upcoming NY
meeting.
</p>

<p>
See the minutes at: <a href="http://wiki.dinkumware.com/twiki/bin/view/Posix/POSIX-CppBindingWorkingGroupNewYork2009">http://wiki.dinkumware.com/twiki/bin/view/Posix/POSIX-CppBindingWorkingGroupNewYork2009</a>.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="888"></a>888. this_thread::yield too strong</h3>
<p><b>Section:</b> 30.3.2 [thread.thread.this] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Lawrence Crowl <b>Opened:</b> 2008-09-15  <b>Last modified:</b> 2009-03-09</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I never thought I'd say this, but <tt>this_thread::yield</tt> seems to be too
strong in specification.  The issue is that some systems distinguish
between yielding to another thread in the same process and yielding
to another process.  Given that the C++ standard only talks about
a single program, one can infer that the specification allows yielding
only to another thread within the same program.  Posix has no
facility for that behavior.  Can you please file an issue to weaken
the wording.  Perhaps "Offers the operating system the opportunity
to reschedule."
</p>

<p><i>[
Post Summit:
]</i></p>


<blockquote>
Recommend move to Tentatively Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 30.3.2 [thread.thread.this]/3:
</p>

<blockquote>
<pre>void this_thread::yield();
</pre>
<blockquote>
<i>Effects:</i> Offers the <del>operating system</del> <ins>implementation</ins>
the opportunity to <ins>re</ins>schedule.
<del>another thread.</del>
</blockquote>
</blockquote>





<hr>
<h3><a name="889"></a>889. thread::id comparisons</h3>
<p><b>Section:</b> 30.3.1.1 [thread.thread.id] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Lawrence Crowl <b>Opened:</b> 2008-09-15  <b>Last modified:</b> 2009-05-24</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.thread.id">issues</a> in [thread.thread.id].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 324</b></p>

<p>
The <tt>thread::id</tt> type supports the full set of comparison operators.  This
is substantially more than is required for the associative containers that
justified them.  Please place an issue against the threads library.
</p>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
<p>
Would depend on proposed extension to POSIX, or non-standard extension.
What about hash? POSIX discussing op. POSIX not known to be considering
support needed for hash, op.
</p>
<p>
Group expresses support for putting ids in both unordered and ordered containers.
</p>
</blockquote>

<p><i>[
post San Francisco:
]</i></p>


<blockquote>
<p>
Howard:  It turns out the current working paper
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2723.pdf">N2723</a>
<i>already has</i> <tt>hash&lt;thread::id&gt;</tt>
(20.7 [function.objects], 20.7.17 [unord.hash]).  We simply
overlooked it in the meeting.  It is a good thing we voted in favor of it
(again). :-)
</p>
<p>
Recommend NAD.
</p>

</blockquote>

<p><i>[
Post Summit:
]</i></p>


<blockquote>
Recommend to close as NAD. For POSIX, see if we need to add a function to
convert <tt>pthread_t</tt> to integer.
</blockquote>

<p><i>[
Post Summit, Alisdair adds:
]</i></p>


<blockquote>
<p>
The recommendation for LWG-889/UK-324 is NAD, already specified.
</p>
<p>
It is not clear to me that the specification is complete.
</p>
<p>
In particular, the synopsis of <tt>&lt;functional&gt;</tt> in 20.7 [function.objects] does not mention <tt>hash&lt; thread::id
&gt;</tt> nor <tt>hash&lt; error_code &gt;</tt>, although their
existence is implied by 20.7.17 [unord.hash], p1.
</p>
<p>
I am fairly uncomfortable putting the declaration for the
<tt>thread_id</tt> specialization into <tt>&lt;functional&gt;</tt> as
<tt>id</tt> is a nested class inside <tt>std::thread</tt>, so it implies
that <tt>&lt;functional&gt;</tt> would require the definition of the
<tt>thread</tt> class template in order to forward declared
<tt>thread::id</tt> and form this specialization.
</p>
<p>
It seems better to me that the dependency goes the other way around
(<tt>&lt;thread&gt;</tt> will more typically make use of
<tt>&lt;functional&gt;</tt> than vice-versa) and the
<tt>hash&lt;thread::id&gt;</tt> specialization be declared in the
<tt>&lt;thread&gt;</tt> header.
</p>
<p>
I think <tt>hash&lt;error_code&gt;</tt> could go into either
<tt>&lt;system_error&gt;</tt> or <tt>&lt;functional&gt;</tt> and have no
immediate preference either way.  However, it should clearly appear in
the synopsis of one of these two.
</p>
<p>
Recommend moving 889 back to open, and tying in a reference to UK-324.
</p>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Howard observes that <tt>thread::id</tt> need not be a nested class;
it could be a <tt>typedef</tt> for a more visible type.
</blockquote>

<p><i>[
2009-05-24 Alisdair adds:
]</i></p>

<blockquote>
I do not believe this is correct.  <tt>thread::id</tt> is explicitly documents as a
nested class, rather than as an unspecified typedef analogous to an
iterator.  If the intent is that this is not implemented as a nested class
(under the as-if freedoms) then this is a novel form of standardese.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Move to NAD.
</p>





<hr>
<h3><a name="890"></a>890. Improving <tt>&lt;system_error&gt;</tt> initialization</h3>
<p><b>Section:</b> 19.5.1 [syserr.errcat] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Beman Dawes <b>Opened:</b> 2008-09-14  <b>Last modified:</b> 2009-03-09</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <tt>static const error_category</tt> objects <tt>generic_category</tt> and
<tt>system_category</tt> in header <tt>&lt;system_error&gt;</tt> are currently declared:
</p>

<blockquote><pre>const error_category&amp; get_generic_category();
const error_category&amp; get_system_category();

static const error_category&amp; generic_category = get_generic_category();
static const error_category&amp; system_category = get_system_category();
</pre></blockquote>

<p>
This formulation has several problems:
</p>

<ul>
<li>
Implementation details are exposed, since initialization is specified in
the interface. This over-constrains implementations without offsetting
user benefits. The form of initialization specified may be less than
maximally efficient on some platforms.
</li>
<li>
Use of the objects is more expensive in terms of number of machine level
instructions. See <i>Implementation experience</i> below.
</li>
<li>
Depending on the compiler, some cost may be incurred by each translation unit
that includes the header, even if the objects are not used. This is a
common scenario in user code, since the header is included by other
standard library headers. It should be mentioned that at least one
compilers is able to optimize this cost away, however.
</li>
</ul>

<p>
IO streams uses a somewhat different formulation for iostream_category, but 
still suffer much the same problems.
</p>

<p>
The original plan was to eliminate these problems by applying the C++0x
<tt>constexpr</tt> feature. See LWG issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#832">832</a>. However, that approach turned out
to be unimplementable, since it would require a <tt>constexpr</tt> object of a
class with virtual functions, and that is not allowed by the core
language.
</p>

<p>
The proposed resolution was developed as an alternative. It mitigates the above 
problems by removing initialization from the visible interface, allowing 
implementations flexibility.
</p>

<p>
<b>Implementation experience:</b>
</p>

<p>
Prototype implementations of the current WP interface and proposed
resolution interface were tested with recent Codegear, GCC, Intel, and Microsoft 
compilers on Windows. The code generated by the Microsoft compiler was studied 
at length; the WP and proposal versions generated very similar code. For both versions 
the compiler did make use of static
initialization; apparently the compiler applied an implicit <tt>constexpr</tt>
where useful, even in cases where <tt>constexpr</tt> would not be permitted by
the language!
</p>

<p>
<b>Acknowledgements:</b>
</p>

<p>
Martin Sebor, Chris Kohlhoff, and John Lakos provided useful ideas and comments on initialization issues.
</p>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
<p>
Martin: prefers not to create more file-scope static objects, and would
like to see <tt>get_*</tt> functions instead.
</p>
</blockquote>


<p><i>[Pre-Summit:]</i></p>

<blockquote>


<p>
Beman: The proposed resolution has been reworked to remove the file-scope 
static objects, per Martin's suggestions. The <tt>get_</tt> prefix has been 
eliminated from the function names as no longer necessary and to conform with 
standard library naming practice.
</p>

</blockquote>

<p><i>[
Post Summit:
]</i></p>


<blockquote>
Agreement that this is wise and essential, text provided works and has
been implemented. Seems to be widespread consensus. Move to Tentative Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>

<p>Change 17.6.4.12 [value.error.codes] Value of error codes as indicated:</p>
<blockquote>
 <p>Certain functions in the C++ standard library report errors via a 
 <tt>std::error_code</tt> (19.4.2.2) object. That object's <tt>category()</tt> member shall 
 return <del>a reference to</del> <code>std::system_category</code><tt><ins><code>()</code></ins></tt> for errors originating from the 
 operating system, or a reference to an implementation-defined error_category 
 object for errors originating elsewhere. The implementation shall define the 
 possible values of value() for each of these error categories. [<i>Example:</i> For 
 operating systems that are based on POSIX, implementations are encouraged to 
 define the <code>std::system_category</code><tt><ins><code>()</code></ins></tt> values as identical to the POSIX <tt>errno</tt> values, 
 with additional values as defined by the operating system's documentation. 
 Implementations for operating systems that are not based on POSIX are 
 encouraged to define values identical to the operating system's values. For 
 errors that do not originate from the operating system, the implementation may 
 provide enums for the associated values --<i>end example</i>]</p>
</blockquote>

<p>
Change 19.5.1.1 [syserr.errcat.overview] Class <tt>error_category</tt> overview
<tt>error_category</tt> synopsis as indicated:
</p>

<blockquote>
<pre>const error_category&amp; <del>get_</del>generic_category();
const error_category&amp; <del>get_</del>system_category();

<del>static storage-class-specifier const error_category&amp; generic_category = get_generic_category();
static storage-class-specifier const error_category&amp; system_category = get_system_category();</del>
</pre>
</blockquote>

<p>
Change 19.5.1.5 [syserr.errcat.objects] Error category objects as indicated:
</p>

<blockquote>
<pre>const error_category&amp; <del>get_</del>generic_category();
</pre>

<blockquote>

<p>
<i>Returns:</i> A reference to an object of a type derived from class <tt>error_category</tt>.
</p>

<p>
<i>Remarks:</i> The object's <tt>default_error_condition</tt> and <tt>equivalent</tt> virtual
functions shall behave as specified for the class <tt>error_category</tt>. The
object's <tt>name</tt> virtual function shall return a pointer to the string
<tt>"GENERIC"</tt>.
</p>
</blockquote>

<pre>const error_category&amp; <del>get_</del>system_category();
</pre>

<blockquote>
<p>
<i>Returns:</i> A reference to an object of a type derived from class <tt>error_category</tt>.
</p>

<p>
<i>Remarks:</i> The object's <tt>equivalent</tt> virtual functions shall behave as
specified for class <tt>error_category</tt>. The object's <tt>name</tt> virtual function
shall return a pointer to the string <tt>"system"</tt>. The object's
<tt>default_error_condition</tt> virtual function shall behave as follows:
</p>
<blockquote>
If the argument <tt>ev</tt> corresponds to a POSIX <tt>errno</tt> value <tt>posv</tt>, the function
shall return <tt>error_condition(posv, generic_category<ins>()</ins>)</tt>. Otherwise, the
function shall return <tt>error_condition(ev, system_category<ins>()</ins>)</tt>. What
constitutes correspondence for any given operating system is
unspecified. [<i>Note:</i> The number of potential system error codes is large
and unbounded, and some may not correspond to any POSIX <tt>errno</tt> value.
Thus implementations are given latitude in determining correspondence.
<i>-- end note</i>]
</blockquote>
</blockquote>

</blockquote>

<p>Change 19.5.2.3 [syserr.errcode.constructors] Class error_code constructors 
as indicated:</p>
<blockquote>
 <pre>error_code();</pre>
 <blockquote>
 <p><i>Effects:</i> Constructs an object of type error_code.</p>
 <p><i>Postconditions:</i> <code>val_ == 0 </code>and <code>cat_ == &amp;system_category</code><tt><ins>()</ins></tt>.</p>
 </blockquote>
</blockquote>
<p>Change 19.5.2.4 [syserr.errcode.modifiers] Class error_code modifiers as 
indicated:</p>
<blockquote>
 <pre>void clear();</pre>
 <blockquote>
 <p>Postconditions: <code>value() == 0</code> and <code>category() == 
 system_category</code><tt><ins>()</ins></tt>.</p>
 </blockquote>
</blockquote>
<p>Change 19.5.2.6 [syserr.errcode.nonmembers] Class error_code non-member 
functions as indicated:</p>
<blockquote>
 <pre>error_code make_error_code(errc e);</pre>
 <blockquote>
 <p><i>Returns:</i> <code>error_code(static_cast&lt;int&gt;(e), generic_category</code><tt><ins>()</ins></tt><code>)</code>.</p>
 </blockquote>
</blockquote>
<p>Change 19.5.3.3 [syserr.errcondition.constructors] Class error_condition 
constructors as indicated:</p>
<blockquote>
 <pre>error_condition();</pre>
 <blockquote>
 <p><i>Effects:</i> Constructs an object of type <code>error_condition</code>.</p>
 <p><i>Postconditions:</i> <code>val_ == 0</code> and <code>cat_ == &amp;generic_category</code><tt><ins>()</ins></tt>.</p>
 </blockquote>
</blockquote>
<p>Change 19.5.3.4 [syserr.errcondition.modifiers] Class error_condition 
modifiers as indicated:</p>
<blockquote>
 <pre>void clear();</pre>
 <blockquote>
 <p><i>Postconditions:</i> <code>value() == 0</code> and <code>category() == 
 generic_category</code><tt><ins>()</ins></tt>.</p>
 </blockquote>
</blockquote>
<p>Change 19.5.3.6 [syserr.errcondition.nonmembers] Class error_condition 
non-member functions as indicated:</p>
<blockquote>
 <pre>error_condition make_error_condition(errc e);</pre>
 <blockquote>
 <p><i>Returns:</i> <tt>error_condition(static_cast&lt;int&gt;(e), generic_category<ins>()</ins>)</tt>.</p>
 </blockquote>
</blockquote>
 <p>Change 27.5 [iostreams.base] Iostreams base classes, Header &lt;ios&gt; 
 synopsis as indicated:</p>
<blockquote>
 <pre>concept_map ErrorCodeEnum&lt;io_errc&gt; { };
error_code make_error_code(io_errc e);
error_condition make_error_condition(io_errc e);
<del>storage-class-specifier</del> const error_category&amp; iostream_category<ins>()</ins>;</pre>
</blockquote>
<p>Change 27.5.2.1.1 [ios::failure] Class ios_base::failure, paragraph 2 as 
indicated:</p>
<blockquote>
<p>When throwing ios_base::failure exceptions, implementations should provide 
values of ec that identify the specific reason for the failure. [ Note: Errors 
arising from the operating system would typically be reported as <tt>
system_category</tt><tt><ins>()</ins></tt> errors with an error value of the 
error number reported by the operating system. Errors arising from within the 
stream library would typically be reported as <tt>error_code(io_errc::stream, 
iostream_category<ins>()</ins>)</tt>. --end note ]</p>
</blockquote>
<p>Change 27.5.5.5 [error.reporting] Error reporting as indicated:</p>
<blockquote>
 <pre>error_code make_error_code(io_errc e);</pre>
 <blockquote>
 <p><i>Returns:</i> <code>error_code(static_cast&lt;int&gt;(e), iostream_category</code><ins>()</ins><code>)</code>.</p>
 </blockquote>
 <pre>error_condition make_error_condition(io_errc e);</pre>
 <blockquote>
 <p><i>Returns:</i> <code>error_condition(static_cast&lt;int&gt;(e), 
 iostream_category</code><ins>()</ins><code>)</code>.</p>
 </blockquote>
 <pre><del>storage-class-specifier</del> const error_category&amp; iostream_category<ins>()</ins>;</pre>
 <blockquote>
 <del><p>The implementation shall initialize iostream_category. Its storage-class-specifier 
 may be static or extern. It is unspecified whether initialization is static 
 or dynamic (3.6.2). If initialization is dynamic, it shall occur before 
 completion of the dynamic initialization of the first translation unit 
 dynamically initialized that includes header &lt;system_error&gt;.</p></del>
<p>
<ins><i>Returns:</i> A reference to an object of a type derived from class <tt>error_category</tt>.</ins>
</p>
<p><i>Remarks:</i> The object's default_error_condition and equivalent virtual functions shall 
behave as specified for the class error_category. The object's name virtual 
function shall return a pointer to the string "iostream".</p>
 </blockquote>
</blockquote>







<hr>
<h3><a name="891"></a>891. std::thread, std::call_once issue</h3>
<p><b>Section:</b> 30.3.1.2 [thread.thread.constr], 30.4.5.2 [thread.once.callonce] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Peter Dimov <b>Opened:</b> 2008-09-15  <b>Last modified:</b> 2009-03-22</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#thread.thread.constr">active issues</a> in [thread.thread.constr].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.thread.constr">issues</a> in [thread.thread.constr].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I notice that the vararg overloads of <tt>std::thread</tt> and <tt>std::call_once</tt>
(N2723 30.3.1.2 [thread.thread.constr] and 30.4.5.2 [thread.once.callonce]) are no longer specified in terms of
<tt>std::bind</tt>; instead, some of the <tt>std::bind</tt> wording has been inlined into
the specification.
</p>
<p>
There are two problems with this.
</p>
<p>
First, the specification (and implementation) in terms of <tt>std::bind</tt> allows, for example:
</p>

<blockquote><pre>std::thread th( f, 1, std::bind( g ) );
</pre></blockquote>

<p>
which executes <tt>f( 1, g() )</tt> in a thread. This can be useful. The
"inlined" formulation changes it to execute <tt>f( 1, bind(g) )</tt> in a thread.
</p>
<p>
Second, assuming that we don't want the above, the specification has copied the wording
</p>

<blockquote>
<tt>INVOKE(func, w1, w2, ..., wN)</tt> (20.6.2) shall be a valid
expression for some values <tt>w1, w2, ..., wN</tt>
</blockquote>

<p>
but this is not needed since we know that our argument list is args; it should simply be
</p>

<blockquote>
<tt>INVOKE(func, args...)</tt> (20.6.2) shall be a valid expression
</blockquote>

<p><i>[
Summit:
]</i></p>


<blockquote>
Move to open.
</blockquote>

<p><i>[
Post Summit Anthony provided proposed wording.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
Change paragraph 4 of 30.3.1.2 [thread.thread.constr] to:
</p>

<blockquote>
<pre>template &lt;class F&gt; explicit thread(F f);
template &lt;class F, class ...Args&gt; thread(F&amp;&amp; f, Args&amp;&amp;... args);
</pre>
<blockquote>
-4- <i>Requires:</i> <tt>F</tt> and each <tt>Ti</tt> in <tt>Args</tt>
shall be <tt>CopyConstructible</tt> if an lvalue and otherwise
<tt>MoveConstructible</tt>. <tt><i>INVOKE</i>(f, <del>w1, w2, ..., wN</del> <ins>args...</ins>)</tt>
(20.6.2) shall be a valid expression<del> for some values <i>w1, w2, ...,
wN</i>, where <tt>N == sizeof...(Args)</tt></del>.
</blockquote>
</blockquote>

<p>
Change paragraph 1 of 30.4.5.2 [thread.once.callonce] to:
</p>

<blockquote><pre>template&lt;class Callable, class ...Args&gt; 
  void call_once(once_flag&amp; flag, Callable func, Args&amp;&amp;... args);
</pre>
<blockquote>
-1- <i>Requires:</i> The template parameters <tt>Callable&gt;</tt> and each
<tt>Ti</tt> in <tt>Args</tt> shall be <tt>CopyConstructible</tt> if an
lvalue and otherwise <tt>MoveConstructible</tt>. <tt><i>INVOKE</i>(func,
<del>w1, w2, ..., wN</del> <ins>args...</ins>)</tt> (20.6.2) shall be a
valid expression<del> for some values <i>w1, w2, ..., wN</i>, where
<tt>N == sizeof...(Args)</tt></del>.
</blockquote>
</blockquote>





<hr>
<h3><a name="893"></a>893. std::mutex issue</h3>
<p><b>Section:</b> 30.4.1.1 [thread.mutex.class] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Peter Dimov <b>Opened:</b> 2008-09-15  <b>Last modified:</b> 2009-03-22</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#thread.mutex.class">active issues</a> in [thread.mutex.class].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.mutex.class">issues</a> in [thread.mutex.class].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#905">905</a></p>
<p><b>Discussion:</b></p>
<p>
30.4.1.1 [thread.mutex.class]/27 (in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2723.pdf">N2723</a>)
says that the behavior is undefined if:
</p>
<ul>
<li>a thread that owns a <tt>mutex</tt> object calls <tt>lock()</tt> or
<tt>try_lock()</tt> on that object</li>
</ul>
<p>
I don't believe that this is right. Calling <tt>lock()</tt> or <tt>try_lock()</tt> on a
locked <tt>mutex</tt> is well defined in the general case. <tt>try_lock()</tt> is required
to fail and return <tt>false</tt>. <tt>lock()</tt> is required to either throw an
exception (and is allowed to do so if it detects deadlock) or to block
until the <tt>mutex</tt> is free. These general requirements apply regardless of
the current owner of the <tt>mutex</tt>; they should apply even if it's owned by
the current thread.
</p>
<p>
Making double <tt>lock()</tt> undefined behavior probably can be justified (even
though I'd still disagree with the justification), but <tt>try_lock()</tt> on a
locked <tt>mutex</tt> must fail.
</p>

<p><i>[
Summit:
]</i></p>

<blockquote>
<p>
Move to open. Proposed resolution:
</p>
<ul>
<li>
In 30.4.1 [thread.mutex.requirements] paragraph 12, change the error
condition for <tt>resource_deadlock_would_occur</tt> to: "if the implementation
detects that a deadlock would occur"
</li>
<li>
Strike 30.4.1.1 [thread.mutex.class] paragraph 3 bullet 2 "a thread that owns a mutex object
calls <tt>lock()</tt> or <tt>try_lock()</tt> on that object, or"
</li>
</ul>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
In 30.4.1 [thread.mutex.requirements] paragraph 12 change:
</p>

<blockquote>
<ul>
<li>...</li>
<li>
<tt>resource_deadlock_would_occur</tt> -- if the <del>current thread already owns the mutex and is able 
to detect it</del> <ins>implementation detects that a deadlock would occur</ins>.
</li>
<li>...</li>
</ul>
</blockquote>

<p>
Strike 30.4.1.1 [thread.mutex.class] paragraph 3 bullet 2:
</p>
<blockquote>
<p>
-3- The behavior of a program is undefined if:
</p>
<ul>
<li>...</li>
<li>
<del>a thread that owns a <tt>mutex</tt> object calls <tt>lock()</tt> or <tt>try_lock()</tt> on that object, or</del>
</li>
<li>...</li>
</ul>
</blockquote>







<hr>
<h3><a name="895"></a>895. "Requires:" on std::string::at et al</h3>
<p><b>Section:</b> 17.5.1.4 [structure.specifications] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> James Dennett <b>Opened:</b> 2008-09-16  <b>Last modified:</b> 2009-03-11</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#structure.specifications">active issues</a> in [structure.specifications].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#structure.specifications">issues</a> in [structure.specifications].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Per discussion, we need an issue open to cover looking at "Requires"
clauses which are not constraints on user code, such as that on
<tt>std::basic_string::at</tt>.
</p>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="896"></a>896. Library thread safety issue</h3>
<p><b>Section:</b> 20.8.13.2 [util.smartptr.shared] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Hans Boehm <b>Opened:</b> 2008-09-16  <b>Last modified:</b> 2008-09-25</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#util.smartptr.shared">active issues</a> in [util.smartptr.shared].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#util.smartptr.shared">issues</a> in [util.smartptr.shared].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It is unclear whether <tt>shared_ptr</tt> is thread-safe in the sense that
multiple threads may simultaneously copy a <tt>shared_ptr</tt>.  However this
is a critical piece of information for the client, and it has significant
impact on usability for many applications.  (Detlef Vollman thinks it
is currently clear that it is not thread-safe.  Hans Boehm thinks
it currently requires thread safety, since the <tt>use_count</tt> is not an
explicit field, and constructors and assignment take a const reference
to an existing <tt>shared_ptr</tt>.)
</p>

<p>
Pro thread-safety:
</p>
<p>
Many multi-threaded usages are impossible.  A thread-safe version can
be used to destroy an object when the last thread drops it, something
that is often required, and for which we have no other easy mechanism.
</p>
<p>
Against thread-safety:
</p>
<p>
The thread-safe version is well-known to be far more expensive, even
if used by a single thread.  Many applications, including all single-threaded
ones, do not care.
</p>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
<p>
Beman: this is a complicated issue, and would like to move this to Open
and await comment from Peter Dimov; we need very careful and complete
rationale for any decision we make; let's go slow
</p>
<p>
Detlef: I think that <tt>shared_ptr</tt> should not be thread-safe.
</p>
<p>
Hans: When you create a thread with a lambda, it in some cases makes it
very difficult for the lambda to reference anything in the heap. It's
currently ambiguous as to whether you can use a <tt>shared_ptr</tt> to get at an
object.
</p>
<p>
Leave in Open. Detlef will submit an alternative proposed resolution
that makes <tt>shared_ptr</tt> explicitly unsafe.
</p>
<p>
A third option is to support both threadsafe and non-safe share_ptrs,
and to let the programmer decide which behavior they want.
</p>

<p>
Beman:  Peter, do you support the PR?
</p>

<p>
Peter:
</p>
<blockquote>
<p>
Yes, I support the proposed resolution, and I certainly oppose any
attempts to <tt>make shared_ptr</tt> thread-unsafe.
</p>
<p>
I'd mildly prefer if
</p>
<blockquote>
[<i>Note:</i> This is true in spite of that fact that such functions often
modify <tt>use_count()</tt> <i>--end note</i>]
</blockquote>
<p>
is changed to
</p>
<blockquote>
[<i>Note:</i> This is true in spite of that fact that such functions often
cause a change in <tt>use_count()</tt> <i>--end note</i>]
</blockquote>
<p>
(or something along these lines) to emphasise that <tt>use_count()</tt> is not,
conceptually, a variable, but a return value.
</p>
</blockquote>

</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Make it explicitly thread-safe, in this weak sense, as I believe was intended:
</p>
<p>
Insert in 20.8.13.2 [util.smartptr.shared], before p5:
</p>
<blockquote>
<p>
For purposes of determining the presence of a data race,
member functions do not modify <tt>const shared_ptr</tt> and
const <tt>weak_ptr</tt> arguments, nor any objects they
refer to.  [<i>Note:</i> This is true in spite of that fact that such functions often
cause a change in <tt>use_count()</tt> <i>--end note</i>]
</p>
</blockquote>
<p>
On looking at the text, I'm not sure we need a similar disclaimer
anywhere else, since nothing else has the problem with the modified
<tt>use_count()</tt>.  I think Howard arrived at a similar conclusion.
</p>





<hr>
<h3><a name="897"></a>897. Forward_list issues... Part 2</h3>
<p><b>Section:</b> 23.3.3.4 [forwardlist.modifiers] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Review">Review</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2008-09-22  <b>Last modified:</b> 2009-05-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Review">Review</a> status.</p>
<p><b>Discussion:</b></p>
<p>
This issue was split off from <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#892">892</a> at the request of the LWG.
</p>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
<p>
This issue is more complicated than it looks.
</p>
<p>
paragraph 47: replace each <tt>(first, last) with (first, last]</tt>
</p>
<p>
add a statement after paragraph 48 that complexity is O(1)
</p>
<p>
remove the complexity statement from the first overload of splice_after
</p>
<p>
We may have the same problems with other modifiers, like erase_after.
Should it require that all iterators in the range (position, last] be
dereferenceable?
</p>
</blockquote>

<p>
There are actually 3 issues here:
</p>

<ol>
<li>
<p>
What value should <tt>erase_after</tt> return?  With <tt>list</tt>, code often
looks like:
</p>
<blockquote><pre>for (auto i = l.begin(); i != l.end();)
{
    // inspect *i and decide if you want to erase it
    // ...
    if (I want to erase *i)
        i = l.erase(i);
    else
        ++i;
}
</pre></blockquote>
<p>
I.e. the iterator returned from <tt>erase</tt> is useful for setting up the
logic for operating on the next element.  For <tt>forward_list</tt> this might
look something like:
</p>
<blockquote><pre>auto i = fl.before_begin();
auto ip1 = i;
for (++ip1; ip1 != fl.end(); ++ip1)
{
    // inspect *(i+1) and decide if you want to erase it
    // ...
    if (I want to erase *(i+1))
        i = fl.erase_after(i);
    else
        ++i;
    ip1 = i;
}
</pre></blockquote>
<p>
In the above example code, it is convenient if <tt>erase_after</tt> returns
the element <i>prior</i> to the erased element (range) instead of the element
<i>after</i> the erase element (range).
</p>
<p>
Existing practice:
</p>
<ul>
<li>SGI slist returns an iterator referencing the element <i>after</i> the erased range.</li>
<li>CodeWarrior slist returns an iterator referencing the element <i>before</i> the erased range.</li>
</ul>
<p>
There is not a strong technical argument for either solution over the other.
</p>
</li>

<li>
<p>
With all other containers, operations always work on the range
<tt>[first, last)</tt> and/or <i>prior to</i> the given <tt>position</tt>.
</p>
<p>
With <tt>forward_list</tt>, operations sometimes work on the range
<tt>(first, last]</tt> and/or <i>after</i> the given <tt>position</tt>.
</p>
<p>
This is simply due to the fact that in order to operate on
<tt>*first</tt> (with <tt>forward_list</tt>) one needs access to
<tt>*(first-1)</tt>.  And that's not practical with
<tt>forward_list</tt>.  So the operating range needs to start with <tt>(first</tt>,
not <tt>[first</tt> (as the current working paper says). 
</p>
<p>
Additionally, if one is interested in  splicing the range <tt>(first, last)</tt>,
then (with <tt>forward_list</tt>), one needs practical (constant time) access to
<tt>*(last-1)</tt> so that one can set the <i>next</i> field in this node to
the proper value.  As this is not possible with <tt>forward_list</tt>, one must
specify the last element of interest instead of one past the last element of
interest.  The syntax for doing this is to pass <tt>(first, last]</tt> instead
of <tt>(first, last)</tt>.
</p>
<p>
With <tt>erase_after</tt> we have a choice of either erasing the range
<tt>(first, last]</tt> <em>or</em> <tt>(first, last)</tt>.  Choosing the latter
enables:
</p>
<blockquote><pre>x.erase_after(pos, x.end());
</pre></blockquote>

<p>
With the former, the above statement is inconvenient or expensive due to the lack
of constant time access to <tt>x.end()-1</tt>.  However we could introduce:
</p>

<blockquote><pre>iterator erase_to_end(const_iterator position);
</pre></blockquote>

<p>
to compensate.
</p>

<p>
The advantage of the former (<tt>(first, last]</tt>) for <tt>erase_after</tt>
is a consistency with <tt>splice_after</tt> which uses <tt>(first, last]</tt>
as the specified range.  But this either requires the addition of <tt>erase_to_end</tt>
or giving up such functionality.
</p>

</li>

<li>
As stated in the discussion of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#892">892</a>, and reienforced by point 2 above,
a <tt>splice_after</tt> should work on the source range <tt>(first, last]</tt>
if the operation is to be <i>&#927;</i>(1).  When splicing an entire list <tt>x</tt> the
algorithm needs <tt>(x.before_begin(), x.end()-1]</tt>.  Unfortunately <tt>x.end()-1</tt>
is not available in constant time unless we specify that it must be.  In order to
make <tt>x.end()-1</tt> available in constant time, the implementation would have
to dedicate a pointer to it.  I believe the design of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2543.htm">N2543</a>
intended a nominal overhead of <tt>foward_list</tt> of 1 pointer.  Thus splicing
one <i>entire</i> <tt>forward_list</tt> into another can not be <i>&#927;</i>(1).
</li>
</ol>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We agree with the proposed resolution.
</p>
<p>
Move to Review.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Wording below assumes issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#878">878</a> is accepted, but this issue is
independent of that issue.
</p>

<p>
Change 23.3.3.4 [forwardlist.modifiers]:
</p>

<blockquote>
<pre>iterator erase_after(const_iterator position);
</pre>
<blockquote>
<p>
<i>Requires:</i> The iterator following <tt>position</tt> is dereferenceable.
</p>
<p>
<i>Effects:</i> Erases the element pointed to by the iterator following <tt>position</tt>.
</p>
<p>
<i>Returns:</i> <del>An iterator pointing to the element following the one that was erased, or <tt>end()</tt> if no such 
element exists</del>
<ins>An iterator equal to <tt>position</tt></ins>.
</p>
</blockquote>


<pre>iterator erase_after(const_iterator position, <ins>const_</ins>iterator last);
</pre>
<blockquote>
<p>
<i>Requires:</i> All iterators in the range
<tt><del>[</del><ins>(</ins>position,last)</tt>
are dereferenceable.
</p>
<p>
<i>Effects:</i> Erases the elements in the range
<tt><del>[</del><ins>(</ins>position,last)</tt>.
</p>
<p>
<i>Returns:</i>  <ins>An iterator equal to <tt>position</tt></ins> <del><tt>last</tt></del>
</p>
</blockquote>
</blockquote>

<p>
Change 23.3.3.5 [forwardlist.ops]:
</p>

<blockquote>
<pre>void splice_after(const_iterator position, forward_list&lt;T,Allocator&gt;&amp;&amp; x);
</pre>
<blockquote>
<p>
<i>Requires:</i> <tt>position</tt> is <tt>before_begin()</tt> or a
dereferenceable iterator in the range <tt>[begin(), end))</tt>. <tt>&amp;x != this</tt>.
</p>
<p>
<i>Effects:</i> Inserts the contents of <tt>x</tt> after <tt>position</tt>, and
<tt>x</tt> becomes empty. Pointers and references to 
the moved elements of <tt>x</tt> now refer to those same elements but as members of <tt>*this</tt>.
Iterators referring to the moved elements will continue to refer to their elements,
but they now behave as iterators into <tt>*this</tt>, not into <tt>x</tt>. 
</p>
<p>
<i>Throws:</i> Nothing. 
</p>
<p>
<i>Complexity:</i> <del><i>&#927;</i>(1)</del> <ins><i>&#927;</i>(<tt>distance(x.begin(), x.end())</tt>)</ins>
</p>
</blockquote>

<p>...</p>

<pre>void splice_after(const_iterator position, forward_list&lt;T,Allocator&gt;&amp;&amp; x, 
                  const_iterator first, const_iterator last);
</pre>
<blockquote>
<p>
<i>Requires:</i> <tt>position</tt> is <tt>before_begin()</tt> or a
dereferenceable iterator in the range <tt>[begin(), end))</tt>.
<tt>(first,last<ins>]</ins><del>)</del></tt> is a valid range in
<tt>x</tt>, and all iterators in the range
<tt>(first,last<ins>]</ins><del>)</del></tt> are dereferenceable.
<tt>position</tt> is not an iterator in the range <tt>(first,last<ins>]</ins><del>)</del></tt>.
</p>
<p>
<i>Effects:</i> Inserts elements in the range <tt>(first,last<ins>]</ins><del>)</del></tt>
after <tt>position</tt> and removes the elements from <tt>x</tt>.
Pointers and references to the moved elements of <tt>x</tt> now refer to
those same elements but as members of <tt>*this</tt>. Iterators
referring to the moved elements will continue to refer to their
elements, but they now behave as iterators into <tt>*this</tt>, not into
<tt>x</tt>.
</p>
<p>
<ins><i>Complexity:</i> <i>&#927;</i>(1).</ins>
</p>
</blockquote>

</blockquote>






<hr>
<h3><a name="898"></a>898. Small contradiction in n2723 to forward to committee</h3>
<p><b>Section:</b> 23.3.3.5 [forwardlist.ops] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Arch Robison <b>Opened:</b> 2008-09-08  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#forwardlist.ops">active issues</a> in [forwardlist.ops].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#forwardlist.ops">issues</a> in [forwardlist.ops].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I ran across a small contradiction in working draft n2723. 
</p>
<blockquote>
<p>
23.3.3 [forwardlist]p2: A <tt>forward_list</tt> satisfies all of the
requirements of a container (table 90), except that the <tt>size()</tt> member
function is not provided.
</p>
<p>
23.3.3.5 [forwardlist.ops]p57: <i>Complexity:</i> At most <tt>size() + x.size() - 1</tt>
comparisons.
</p>
</blockquote>
<p>
Presumably 23.3.3.5 [forwardlist.ops]p57 needs to be rephrased to not use
<tt>size()</tt>, or note that it is used there only for sake of notational convenience. 
</p>

<p><i>[
2009-03-29 Beman provided proposed wording.
]</i></p>


<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We agree with the proposed resolution.
</p>
<p>
Move to Tentatively Ready.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p><i>Change 23.3.3.5 [forwardlist.ops],
forward_list operations, paragraph 19, merge complexity as indicated:
</i></p>
<blockquote><i>Complexity:</i> At most <tt><del>size() + x.size()</del>
<ins>distance(begin(), end()) + distance(x.begin(), x.end())</ins> - 1</tt>
comparisons.
</blockquote>





<hr>
<h3><a name="899"></a>899. Adjusting <tt>shared_ptr</tt> for <tt>nullptr_t</tt></h3>
<p><b>Section:</b> 20.8.13.2.2 [util.smartptr.shared.dest] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Peter Dimov <b>Opened:</b> 2008-09-18  <b>Last modified:</b> 2009-05-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#util.smartptr.shared.dest">issues</a> in [util.smartptr.shared.dest].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
James Dennett, message c++std-lib-22442:
</p>
<blockquote>
The wording below addresses one case of this, but opening an
issue to address the need to sanity check uses of the term "pointer"
in 20.8.13.2 [util.smartptr.shared] would be a good thing.
</blockquote>
<p>
There's one more reference, in <tt>~shared_ptr;</tt> we can apply your suggested change to it, too. That is:
</p>
<p>
Change 20.8.13.2.2 [util.smartptr.shared.dest]/1 second bullet from:
</p>
<blockquote>
Otherwise, if *this owns a pointer p and a deleter d, d(p) is called.
</blockquote>
<p>
to:
</p>
<blockquote>
Otherwise, if *this owns an object p and a deleter d, d(p) is called.
</blockquote>

<p><i>[
Post Summit:
]</i></p>


<blockquote>
Recommend Review.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Peter Dimov notes the analogous change has already been made
to "the new nullptr_t taking constructors
in 20.8.13.2.1 [util.smartptr.shared.const] p9-13."
</p>
<p>
We agree with the proposed resolution.
Move to Tentatively Ready.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 20.8.13.2.2 [util.smartptr.shared.dest]/1 second bullet:
</p>
<blockquote>
<ul>
<li>...</li>
<li>
Otherwise, if <tt>*this</tt> <i>owns</i> <del>a pointer</del>
<ins>an object</ins> <tt>p</tt> and a
deleter <tt>d</tt>, <tt>d(p)</tt> is called.
</li>
</ul>
</blockquote>





<hr>
<h3><a name="900"></a>900. stream move-assignment</h3>
<p><b>Section:</b> 27.9.1.8 [ifstream.assign] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Niels Dekker <b>Opened:</b> 2008-09-20  <b>Last modified:</b> 2009-05-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It
appears that we have an issue similar to issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#675">675</a> regarding the move-assignment of
stream types. For example, when assigning to an <tt>std::ifstream</tt>,
<tt>ifstream1</tt>, it seems preferable to close the file originally held by
<tt>ifstream1</tt>:
</p>

<blockquote><pre>ifstream1 = std::move(ifstream2); 
</pre></blockquote>

<p>
The current Draft
(<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2723.pdf">N2723</a>)
specifies that the move-assignment of
stream types like <tt>ifstream</tt> has the same effect as a swap:
</p>

<blockquote>
<p>
Assign and swap 27.9.1.8 [ifstream.assign]
</p>
<pre>basic_ifstream&amp; operator=(basic_ifstream&amp;&amp; rhs); 
</pre>
<blockquote>
<i>Effects:</i> <tt>swap(rhs)</tt>.
</blockquote>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Howard agrees with the analysis and the direction proposed.
</p>
<p>
Move to Open pending specific wording to be supplied by Howard.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="901"></a>901. insert iterators can move from lvalues</h3>
<p><b>Section:</b> 24.7.5 [insert.iterator] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2008-09-24  <b>Last modified:</b> 2009-05-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses UK 282</b></p>

<p>
The requires clause on the <tt>const T &amp;</tt> overloads in
<tt>back_insert_iterator/front_insert_iterator/insert_iterator</tt> mean that the
assignment operator will implicitly move from lvalues of a move-only type.
</p>
<p>
Suggested resolutions are:
</p>
<ol type="a">
<li>
Add another overload with a negative constraint on copy-constructible
and flag it "= delete".
</li>
<li>
Drop the copy-constructible overload entirely and rely on perfect
forwarding to catch move issues one level deeper.
</li>
<li>
This is a fundamental problem in move-syntax that relies on the
presence of two overloads, and we need to look more deeply into this
area as a whole - do not solve this issue in isolation.
</li>
</ol>

<p><i>[
Post Summit, Alisdair adds:
]</i></p>


<blockquote>
<p>
Both comment and issue have been resolved by the adoption of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2844.html">N2844</a>
(rvalue references safety fix) at the last meeting.
</p>

<p>
Suggest resolve as NAD Editorial with a reference to the paper.
</p>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree that this has been resolved in the latest Working Draft.
Move to NAD.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Recommend NAD, addressed by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2844.html">N2844</a>.
</p>





<hr>
<h3><a name="902"></a>902. Regular is the wrong concept to constrain numeric_limits</h3>
<p><b>Section:</b> 18.3.1 [limits] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2008-09-24  <b>Last modified:</b> 2009-03-11</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#limits">issues</a> in [limits].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses FR 32 and DE 16</b></p>

<p>
<tt>numeric_limits</tt> has functions specifically designed to return NaNs, which
break the model of <tt>Regular</tt> (via its axioms.)  While floating point types
will be acceptible in many algorithms taking <tt>Regular</tt> values, it is not
appopriate for this specific API and we need a less refined constraint.
</p>

<p>FR 32:</p>

<blockquote>
The definition of <tt>numeric_limits&lt;&gt;</tt> as requiring a regular
type is both conceptually wrong and operationally illogical. As we
pointed before, this mistake needs to be corrected. For example, the
template can be left unconstrained. In fact this reflects a much more
general problem with concept_maps/axioms and their interpretations. It
appears that the current text heavily leans toward experimental academic
type theory.
</blockquote>

<p>DE 16:</p>

<blockquote>
The class template <tt>numeric_limits</tt> should not specify the Regular concept
requirement for its template parameter, because it contains functions
returning NaN values for floating-point types; these values violate the
semantics of EqualityComparable.
</blockquote>

<p><i>[
Summit:
]</i></p>


<blockquote>
Move to Open.  Alisdair and Gaby will work on a solution, along with the new
treatment of axioms in clause 14.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="903"></a>903. <tt>back_insert_iterator</tt> issue</h3>
<p><b>Section:</b> 24.7.1 [back.insert.iterator] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Dave Abrahams <b>Opened:</b> 2008-09-19  <b>Last modified:</b> 2009-05-30</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I just noticed this; don't know how far the problem(?) extends or
whether it's new or existing: <tt>back_insert_iterator</tt>'s <tt>operator*</tt> is not
<tt>const</tt>, so you can't dereference a <tt>const</tt> one.
</p>

<p><i>[
Post Summit Daniel adds:
]</i></p>


<blockquote>
<p>
If done, this change should be applied for <tt>front_insert_iterator</tt>,
<tt>insert_iterator</tt>, <tt>ostream_iterator</tt>, and <tt>ostreambuf_iterator</tt> as well.
</p>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Alisdair notes that these all are output iterators.
Howard points out that <tt>++*i</tt>
would no longer work if we made this change.
</p>
<p>
Move to NAD.
</p>
</blockquote>

<p><i>[
2009-05-25 Daniel adds:
]</i></p>


<ol>
<li>
If <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1009">1009</a> is accepted, <tt>OutputIterator</tt> does no longer support post increment.
</li>
<li>
To support backward compatibility a second overload of <tt>operator*</tt>
can be added.
Note that the <tt>HasDereference</tt> concept (and the <tt>HasDereference</tt> part of concept
<tt>Iterator</tt>) was specifically refactored to cope with optional const
qualification and
to properly reflect the dual nature of built-in <tt>operator*</tt> as of
13.5.8 [over.literal]/6.
</li>
</ol>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="904"></a>904. result_of argument types</h3>
<p><b>Section:</b> 20.7.4 [func.ret] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2008-09-10  <b>Last modified:</b> 2009-03-09</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The WP and TR1 have the same text regarding the argument types of a
<tt>result_of</tt> expression:
</p>
<blockquote>
The values <tt>ti</tt> are lvalues when the corresponding type <tt>Ti</tt> is a
reference type, and rvalues otherwise.
</blockquote>
<p>
I read this to mean that this compiles:
</p>
<blockquote><pre>typedef int (*func)(int&amp;);
result_of&lt;func(int&amp;&amp;)&gt;::type i = 0;
</pre></blockquote>
<p>
even though this doesn't:
</p>
<blockquote><pre>int f(int&amp;);
f( std::move(0) );
</pre></blockquote>
<p>
Should the text be updated to say "when <tt>Ti</tt> is an lvalue-reference
type" or am I missing something?
</p>
<p>
I later came up with this self-contained example which won't compile,
but I think it should:
</p>
<blockquote><pre>struct X {
  void operator()(int&amp;);
  int operator()(int&amp;&amp;);
} x;

std::result_of&lt; X(int&amp;&amp;) &gt;::type i = x(std::move(0));
</pre></blockquote>

<p><i>[
Post Summit:
]</i></p>


<blockquote>
Recommend Tentatively Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 20.7.4 [func.ret], p1:
</p>

<blockquote>
... The values <tt>ti</tt> are lvalues 
when the corresponding type <tt>Ti</tt> is a<ins>n</ins> <ins>lvalue-</ins>reference type,
and rvalues otherwise. 
</blockquote>





<hr>
<h3><a name="906"></a>906. <tt>ObjectType</tt> is the wrong concept to constrain <tt>initializer_list</tt></h3>
<p><b>Section:</b> 18.9 [support.initlist] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2008-09-26  <b>Last modified:</b> 2009-05-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The currently proposed constraint on <tt>initializer_list</tt>'s element type
<tt>E</tt> is that is has to meet <tt>ObjectType</tt>. This is an underspecification,
because both core language and library part of <tt>initializer_list</tt>
make clear, that it references an implicitly allocated array:
</p>
<p>
8.5.4 [dcl.init.list]/4:
</p>
<blockquote>
When an initializer list is implicitly converted to a
<tt>std::initializer_list&lt;E&gt;</tt>, the object passed is constructed as if the
implementation allocated an array of N elements of type <tt>E</tt>, where
N is the number of elements in the initializer list.[..]
</blockquote>

<p>
18.9 [support.initlist]/2.
</p>

<blockquote>
An object of type <tt>initializer_list&lt;E&gt;</tt> provides access to an array of
objects of type <tt>const E</tt>.[..]
</blockquote>

<p>
Therefore, <tt>E</tt> needs to fulfill concept <tt>ValueType</tt> (thus excluding
abstract class types). This stricter requirement should be added
to prevent deep instantiation errors known from the bad old times,
as shown in the following example:
</p>

<blockquote><pre>// Header A: (Should concept-check even in stand-alone modus)

template &lt;DefaultConstructible T&gt;
requires MoveConstructible&lt;T&gt;
void generate_and_do_3(T a) {
  std::initializer_list&lt;T&gt; list{T(), std::move(a), T()};
  ...
}

void do_more();
void do_more_or_less();

template &lt;DefaultConstructible T&gt;
requires MoveConstructible&lt;T&gt;
void more_generate_3() {
  do_more();
  generate_and_do_3(T());
}

template &lt;DefaultConstructible T&gt;
requires MoveConstructible&lt;T&gt;
void something_and_generate_3() {
  do_more_or_less();
  more_generate_3();
}

// Test.cpp

#include "A.h"

class Abstract {
public:
  virtual ~Abstract();
  virtual void foo() = 0; // abstract type
  Abstract(Abstract&amp;&amp;){} // MoveConstructible
  Abstract(){} // DefaultConstructible
};

int main() {
  // The restricted template *accepts* the argument, but
  // causes a deep instantiation error in the internal function
  // generate_and_do_3:
  something_and_generate_3&lt;Abstract&gt;();
}
</pre></blockquote>

<p>
The proposed stricter constraint does not minimize the aim to
support more general containers for which <tt>ObjectType</tt> would be
sufficient. If such an extended container (lets assume it's still a
class template) provides a constructor that accepts an <tt>initializer_list</tt>
only <em>this</em> constructor would need to be restricted on <tt>ValueType</tt>:
</p>

<blockquote><pre>template&lt;ObjectType T&gt;
class ExtContainer {
public:
  requires ValueType&lt;T&gt;
  ExtContainer(std::initializer_list&lt;T&gt;);
  ...
};
</pre></blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Move to Tentatively Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>
<ol>
<li>
In 18.9 [support.initlist]/p.1 replace in "header <tt>&lt;initializer_list&gt;</tt> synopsis"
the constraint "<tt>ObjectType</tt>" in the template parameter list by the
constraint "<tt>ValueType</tt>".
</li>
</ol>






<hr>
<h3><a name="907"></a>907. Bitset's immutable element retrieval is inconsistently defined</h3>
<p><b>Section:</b> 20.3.6.2 [bitset.members] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2008-09-26  <b>Last modified:</b> 2009-05-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#bitset.members">issues</a> in [bitset.members].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The current standard 14882::2003(E) as well as the current draft
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2723.pdf">N2723</a>
have in common a contradiction of the operational semantics
of member function test 20.3.6.2 [bitset.members]/56-58 and the immutable
member <tt>operator[]</tt> overload 20.3.6.2 [bitset.members]/64-66 (all references
are defined in terms of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2723.pdf">N2723</a>):
</p>

<ol>
<li><pre>bool test(size_t pos) const;
</pre>
<blockquote>
<p>
<i>Requires:</i> <tt>pos</tt> is valid
</p>
<p>
<i>Throws:</i> <tt>out_of_range</tt> if <tt>pos</tt> does not correspond
to a valid bit position.
</p>
<p>
<i>Returns:</i> <tt>true</tt> if the bit at position <tt>pos</tt> in <tt>*this</tt>
has the value one.
</p>
</blockquote>
</li>
<li><pre>constexpr bool operator[](size_t pos) const;
</pre>
<blockquote>
<p>
<i>Requires:</i> <tt>pos</tt> shall be valid.
</p>
<p>
<i>Throws:</i> nothing.
</p>
<p>
<i>Returns:</i> <tt>test(pos)</tt>.
</p>
</blockquote>
</li>
</ol>

<p>
Three interpretations:
</p>

<ol type="A">
<li>
The <tt>operator[]</tt> overload is indeed allowed to throw an exception
(via <tt>test()</tt>, if <tt>pos</tt> corresponds to an invalid bit position) which does
not leave the call frame. In this case this function cannot be a
<tt>constexpr</tt> function, because <tt>test()</tt> is not, due to
5.19 [expr.const]/2, last bullet.
</li>
<li>
The intend was not to throw an exception in <tt>test</tt> in case of an
invalid bit position. There is only little evidence for this interpretation.
</li>
<li>
The intend was that <tt>operator[]</tt> should not throw any exception,
but that <tt>test</tt> has the contract to do so, if the provided bit position
is invalid.
</li>
</ol>

<p>
The problem became worse, because issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#720">720</a>
recently voted into WP argued that member <tt>test</tt> logically must be
a <tt>constexpr</tt> function, because it was used to define the semantics
of another <tt>constexpr</tt> function (the <tt>operator[]</tt> overload).
</p>

<p>
Three alternatives are proposed, corresponding to the three bullets
(A), (B), and (C), the author suggests to follow proposal (C).
</p>

<b>
Proposed alternatives:
</b>

<ol type="A">
<li>
<p>
Remove the <tt>constexpr</tt> specifier in front of <tt>operator[]</tt> overload and
undo that of member <tt>test</tt> (assuming <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#720">720</a> is accepted) in both the
class declaration 20.3.6 [template.bitset]/1 and in the member description
before 20.3.6.2 [bitset.members]/56 and before /64 to read:
</p>
<blockquote><pre><del>constexpr</del> bool test(size_t pos) const;
..
<del>constexpr</del> bool operator[](size_t pos) const;
</pre></blockquote>

<p>
Change the throws clause of p. 65 to read:
</p>

<blockquote>
<i>Throws:</i> <del>nothing</del>
<ins><tt>out_of_range</tt> if <tt>pos</tt> does not correspond to a valid bit
position</ins>.
</blockquote>
</li>
<li>
<p>
Replace the throws clause p. 57 to read:
</p>

<blockquote>
<i>Throws:</i> <del><tt>out_of_range</tt> if <tt>pos</tt> does not correspond to a valid bit
position</del> <ins>nothing</ins>.
</blockquote>
</li>
<li>
<p>
Undo the addition of the <tt>constexpr</tt> specifier to the <tt>test</tt> member
function in both class declaration 20.3.6 [template.bitset]/1 and in the
member description before 20.3.6.2 [bitset.members]/56, assuming that <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#720">720</a>
was applied.
</p>

<blockquote><pre><del>constexpr</del> bool test(size_t pos) const;
</pre></blockquote>

<p>
Change the returns clause p. 66 to read:
</p>

<blockquote>
<i>Returns:</i> <del><tt>test(pos)</tt></del> <ins><tt>true</tt> if the bit at position <tt>pos</tt> in <tt>*this</tt>
has the value one, otherwise <tt>false</tt></ins>.
</blockquote>
</li>
</ol>

<p><i>[
Post Summit:
]</i></p>


<blockquote>
<p>
Lawrence: proposed resolutions A, B, C are mutually exclusive.
</p>
<p>
Recommend Review with option C.
</p>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution.
Move to Tentatively Ready.
</blockquote>


<p><b>Proposed resolution:</b></p>

<ol ,="" start="3" type="A">
<li>
<p>
Undo the addition of the <tt>constexpr</tt> specifier to the <tt>test</tt> member
function in both class declaration 20.3.6 [template.bitset]/1 and in the
member description before 20.3.6.2 [bitset.members]/56, assuming that <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#720">720</a>
was applied.
</p>

<blockquote><pre><del>constexpr</del> bool test(size_t pos) const;
</pre></blockquote>

<p>
Change the returns clause p. 66 to read:
</p>

<blockquote>
<i>Returns:</i> <del><tt>test(pos)</tt></del> <ins><tt>true</tt> if the bit at position <tt>pos</tt> in <tt>*this</tt>
has the value one, otherwise <tt>false</tt></ins>.
</blockquote>
</li>
</ol>






<hr>
<h3><a name="908"></a>908. Deleted assignment operators for atomic types must be volatile</h3>
<p><b>Section:</b> 29.5 [atomics.types] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Anthony Williams <b>Opened:</b> 2008-09-26  <b>Last modified:</b> 2009-03-22</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#atomics.types">issues</a> in [atomics.types].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses US 90</b></p>

<p>
The deleted copy-assignment operators for the atomic types are not
marked as volatile in N2723, whereas the assignment operators from the
associated non-atomic types are. e.g.
</p>
<blockquote><pre>atomic_bool&amp; operator=(atomic_bool const&amp;) = delete;
atomic_bool&amp; operator=(bool) volatile;
</pre></blockquote>

<p>
This leads to ambiguity when assigning a non-atomic value to a
non-volatile instance of an atomic type:
</p>
<blockquote><pre>atomic_bool b;
b=false;
</pre></blockquote>

<p>
Both assignment operators require a standard conversions: the
copy-assignment operator can use the implicit <tt>atomic_bool(bool)</tt>
conversion constructor to convert <tt>false</tt> to an instance of
<tt>atomic_bool</tt>, or <tt>b</tt> can undergo a qualification conversion in order to
use the assignment from a plain <tt>bool</tt>.
</p>

<p>
This is only a problem once issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#845">845</a> is applied.
</p>

<p><i>[
Summit:
]</i></p>

<blockquote>
Move to open. Assign to Lawrence. Related to US 90 comment.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Add volatile qualification to the deleted copy-assignment operator of
all the atomic types:
</p>

<blockquote><pre>atomic_bool&amp; operator=(atomic_bool const&amp;) <ins>volatile</ins> = delete;
atomic_itype&amp; operator=(atomic_itype const&amp;) <ins>volatile</ins> = delete;
</pre></blockquote>

<p>
etc.
</p>
<p>
This will mean that the deleted copy-assignment operator will require
<i>two</i> conversions in the above example, and thus be a worse match than
the assignment from plain <tt>bool</tt>.
</p>





<hr>
<h3><a name="909"></a>909. <tt>regex_token_iterator</tt> should use <tt>initializer_list</tt></h3>
<p><b>Section:</b> 28.13.2 [re.tokiter] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2008-09-26  <b>Last modified:</b> 2009-05-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#re.tokiter">issues</a> in [re.tokiter].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 319</b></p>
<p>
Construction of a <tt>regex_token_iterator</tt> (28.13.2 [re.tokiter]/6+) usually
requires the provision of a sequence of integer values, which
can currently be done via a <tt>std::vector&lt;int&gt;</tt> or
a C array of <tt>int</tt>. Since the introduction of <tt>initializer_list</tt> in the
standard it seems much more reasonable to provide a
corresponding constructor that accepts an <tt>initializer_list&lt;int&gt;</tt>
instead. This could be done as a pure addition or one could
even consider replacement. The author suggests the
replacement strategy (A), but provides an alternative additive
proposal (B) as a fall-back, because of the handiness of this
range type:
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We strongly recommend alternative B of the proposed resolution
in order that existing code not be broken.
With that understanding, move to Tentatively Ready.
</blockquote>

<p><b>Original proposed wording:</b></p>

<ol type="A">
<li><br>
<ol>
<li>
<p>
In 28.13.2 [re.tokiter]/6 and the list 28.13.2.1 [re.tokiter.cnstr]/10-11 change the
constructor declaration:
</p>

<blockquote><pre><del>template &lt;std::size_t N&gt;</del>
regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b,
                     const regex_type&amp; re,
                     <del>const int (&amp;submatches)[N]</del> <ins>initializer_list&lt;int&gt; submatches</ins>,
                     regex_constants::match_flag_type m =
                       regex_constants::match_default);
</pre></blockquote>
</li>

<li>
<p>
In 28.13.2.1 [re.tokiter.cnstr]/12 change the last sentence
</p>

<blockquote>
The third constructor initializes the member <tt>subs</tt> to hold
a copy of the sequence of integer values pointed to by the
iterator range <tt>[<del>&amp;</del>submatches<ins>.begin()</ins>,
<del>&amp;</del>submatches<ins>.end()</ins> <del>+ N</del>)</tt>.
</blockquote>
</li>
</ol>
</li>

<li><br>
<ol>
<li>
<p>
In 28.13.2 [re.tokiter]/6 and the list 28.13.2.1 [re.tokiter.cnstr]/10-11 <em>insert</em> the
following constructor declaration between the already existing ones
accepting a <tt>std::vector</tt> and a C array of <tt>int</tt>, resp.:
</p>

<blockquote><pre>regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b,
                     const regex_type&amp; re,
                     initializer_list&lt;int&gt; submatches,
                     regex_constants::match_flag_type m =
                       regex_constants::match_default);
</pre></blockquote>
</li>
<li>
<p>
In 28.13.2.1 [re.tokiter.cnstr]/12 change the last sentence
</p>

<blockquote>
The third <ins>and fourth</ins> constructor initialize<del>s</del> the member <tt>subs</tt>
to hold a copy of the sequence of integer values pointed to
by the iterator range <tt>[&amp;submatches,&amp;submatches + N)</tt>
<ins>and <tt>[submatches.begin(),submatches.end())</tt>, respectively</ins>.
</blockquote>
</li>
</ol>
</li>

</ol>



<p><b>Proposed resolution:</b></p>

<ol start="2" type="A">

<li><br>
<ol>
<li>
<p>
In 28.13.2 [re.tokiter]/6 and the list 28.13.2.1 [re.tokiter.cnstr]/10-11 <em>insert</em> the
following constructor declaration between the already existing ones
accepting a <tt>std::vector</tt> and a C array of <tt>int</tt>, resp.:
</p>

<blockquote><pre>regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b,
                     const regex_type&amp; re,
                     initializer_list&lt;int&gt; submatches,
                     regex_constants::match_flag_type m =
                       regex_constants::match_default);
</pre></blockquote>
</li>
<li>
<p>
In 28.13.2.1 [re.tokiter.cnstr]/12 change the last sentence
</p>

<blockquote>
The third <ins>and fourth</ins> constructor initialize<del>s</del> the member <tt>subs</tt>
to hold a copy of the sequence of integer values pointed to
by the iterator range <tt>[&amp;submatches,&amp;submatches + N)</tt>
<ins>and <tt>[submatches.begin(),submatches.end())</tt>, respectively</ins>.
</blockquote>
</li>
</ol>
</li>

</ol>






<hr>
<h3><a name="910"></a>910. Effects of MoveAssignable</h3>
<p><b>Section:</b> 20.2.9 [concept.copymove] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Alberto Ganesh Barbati <b>Opened:</b> 2008-09-29  <b>Last modified:</b> 2009-05-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses UK 150</b></p>

<p>
The description of the effect of <tt>operator=</tt> in the <tt>MoveAssignable</tt>
concept, given in paragraph 7 is:
</p>

<blockquote><pre>result_type  T::operator=(T&amp;&amp;  rv);  // inherited from HasAssign&lt;T, T&amp;&amp;&gt;
</pre>

<blockquote>
<i>Postconditions:</i> the constructed <tt>T</tt> object is equivalent to the value of
<tt>rv</tt> before the assignment. [<i>Note:</i> there is no
requirement on the value of <tt>rv</tt> after the assignment.  <i>--end note</i>]
</blockquote>
</blockquote>

<p>
The sentence contains a typo (what is the "constructed <tt>T</tt> object"?)
probably due to a cut&amp;paste from <tt>MoveConstructible</tt>. Moreover, the
discussion of LWG issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#675">675</a> shows that the postcondition is too generic
and might not reflect the user expectations. An implementation of the
move assignment that just calls <tt>swap()</tt> would always fulfill the
postcondition as stated, but might have surprising side-effects in case
the source rvalue refers to an object that is not going to be
immediately destroyed. See LWG issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#900">900</a> for another example. Due to
the sometimes intangible nature of the "user expectation", it seems
difficult to have precise normative wording that could cover all cases
without introducing unnecessary restrictions. However a non-normative
clarification could be a very helpful warning sign that swapping is not
always the correct thing to do.
</p>

<p><i>[
2009-05-09 Alisdair adds:
]</i></p>


<blockquote>
<p>
Issue 910 is exactly the reason BSI advanced the Editorial comment UK-150.
</p>
<p>
The post-conditions after assignment are at a minimum that the object
referenced by rv must be safely destructible, and the transaction should not
leak resources.  Ideally it should be possible to simply assign rv a new
valid state after the call without invoking undefined behaviour, but any
other use of the referenced object would depend upon additional guarantees
made by that type.
</p>
</blockquote>

<p><i>[
2009-05-09 Howard adds:
]</i></p>


<blockquote>
<p>
The intent of the rvalue reference work is that the moved from <tt>rv</tt> is
a valid object.  Not one in a singular state.  If, for example, the moved from
object is a <tt>vector</tt>, one should be able to do anything on that moved-from
<tt>vector</tt> that you can do with any other <tt>vector</tt>.  However you would
first have to query it to find out what its current state is.  E.g. it might have <tt>capacity</tt>,
it might not.  It might have a non-zero <tt>size</tt>, it might not.  But regardless,
you can <tt>push_back</tt> on to it if you want.
</p>

<p>
That being said, most standard code is now conceptized.  That is, the concepts
list the only operations that can be done with templated types - whether or not
the values have been moved from.
</p>

<p>
Here is user-written code which must be allowed to be legal:
</p>
<blockquote><pre>#include &lt;vector&gt;
#include &lt;cstdio&gt;

template &lt;class Allocator&gt;
void
inspect(std::vector&lt;double, Allocator&gt;&amp;&amp; v)
{
    std::vector&lt;double, Allocator&gt; result(move(v));
    std::printf("moved from vector has %u size and %u capacity\n", v.size(), v.capacity());
    std::printf("The contents of the vector are:\n");
    typedef typename std::vector&lt;double, Allocator&gt;::iterator I;
    for (I i = v.begin(), e = v.end(); i != e; ++i)
        printf("%f\n", *i);
}

int main()
{
    std::vector&lt;double&gt; v1(100, 5.5);
    inspect(move(v1));
}
</pre></blockquote>

<p>
The above program does not treat the moved-from <tt>vector</tt> as singular.  It
only treats it as a <tt>vector</tt> with an unknown value.
</p>
<p>
I believe the current proposed wording is consistent with my view on this.
</p>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree that the proposed resolution
is an improvement over the current wording.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
In 20.2.9 [concept.copymove], replace the postcondition in paragraph 7 with:
</p>

<blockquote>
<i>Postconditions:</i> <tt>*this</tt> is equivalent to the value of <tt>rv</tt> before the
assignment. [<i>Note:</i> there is no requirement on the value of <tt>rv</tt> after the
assignment, but the
effect should be unsurprising to the user even in case <tt>rv</tt> is not
immediately destroyed. This may require that resources previously owned
by <tt>*this</tt> are released instead of transferred to <tt>rv</tt>. <i>-- end note</i>]
</blockquote>





<hr>
<h3><a name="911"></a>911. I/O streams and <tt>move/swap</tt> semantic</h3>
<p><b>Section:</b> 27.7.1 [input.streams], 27.7.2 [output.streams] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alberto Ganesh Barbati <b>Opened:</b> 2008-09-29  <b>Last modified:</b> 2009-05-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Class template <tt>basic_istream</tt>, <tt>basic_ostream</tt> and <tt>basic_iostream</tt>
implements public move constructors, move assignment operators and <tt>swap</tt>
method and free functions. This might induce both the user and the
compiler to think that those types are <tt>MoveConstructible</tt>, <tt>MoveAssignable</tt>
and <tt>Swappable</tt>. However, those class templates fail to fulfill the user
expectations. For example:
</p>

<blockquote><pre>std::ostream os(std::ofstream("file.txt"));
assert(os.rdbuf() == 0); // buffer object is not moved to os, file.txt has been closed

std::vector&lt;std::ostream&gt; v;
v.push_back(std::ofstream("file.txt"));
v.reserve(100); // causes reallocation
assert(v[0].rdbuf() == 0); // file.txt has been closed!

std::ostream&amp;&amp; os1 = std::ofstream("file1.txt");
os1 = std::ofstream("file2.txt");
os1 &lt;&lt; "hello, world"; // still writes to file1.txt, not to file2.txt!

std::ostream&amp;&amp; os1 = std::ofstream("file1.txt");
std::ostream&amp;&amp; os2 = std::ofstream("file2.txt");
std::swap(os1, os2);
os1 &lt;&lt; "hello, world"; // writes to file1.txt, not to file2.txt!
</pre></blockquote>

<p>
This is because the move constructor, the move assignment operator and
<tt>swap</tt> are all implemented through calls to <tt>std::basic_ios</tt> member
functions <tt>move()</tt> and <tt>swap()</tt> that do not move nor swap the controlled
stream buffers. That can't happen because the stream buffers may have
different types.
</p>

<p>
Notice that for <tt>basic_streambuf</tt>, the member function <tt>swap()</tt> is
protected. I believe that is correct and all of <tt>basic_istream</tt>,
<tt>basic_ostream</tt>, <tt>basic_iostream</tt> should do the same as the move ctor, move
assignment operator and swap member function are needed by the derived
<tt>fstream</tt>s and <tt>stringstream</tt>s template. The free swap functions for
<tt>basic_(i|o|io)stream</tt> templates should be removed for the same reason.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We note that the rvalue swap functions have already been removed.
</p>
<p>
Bill is unsure about making the affected functions protected;
he believes they may need to be public.
</p>
<p>
We are also unsure about removing the lvalue swap functions as proposed.
</p>
<p>
Move to Open.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
27.7.1.1 [istream]: make the following member functions protected:
</p>

<blockquote><pre>basic_istream(basic_istream&amp;&amp;  rhs);
basic_istream&amp;  operator=(basic_istream&amp;&amp;  rhs);
void  swap(basic_istream&amp;&amp;  rhs);
</pre></blockquote>

<p>
Ditto: remove the three swap free functions signatures
</p>

<blockquote><pre><del>// swap: 
template &lt;class charT, class traits&gt; 
  void swap(basic_istream&lt;charT, traits&gt;&amp; x, basic_istream&lt;charT, traits&gt;&amp; y); 
template &lt;class charT, class traits&gt; 
  void swap(basic_istream&lt;charT, traits&gt;&amp;&amp; x, basic_istream&lt;charT, traits&gt;&amp; y); 
template &lt;class charT, class traits&gt; 
  void swap(basic_istream&lt;charT, traits&gt;&amp; x, basic_istream&lt;charT, traits&gt;&amp;&amp; y);</del>
</pre></blockquote>

<p>
27.7.1.1.2 [istream.assign]: remove paragraph 4
</p>

<blockquote><pre><del>template &lt;class charT, class traits&gt; 
  void swap(basic_istream&lt;charT, traits&gt;&amp; x, basic_istream&lt;charT, traits&gt;&amp; y); 
template &lt;class charT, class traits&gt; 
  void swap(basic_istream&lt;charT, traits&gt;&amp;&amp; x, basic_istream&lt;charT, traits&gt;&amp; y); 
template &lt;class charT, class traits&gt; 
  void swap(basic_istream&lt;charT, traits&gt;&amp; x, basic_istream&lt;charT, traits&gt;&amp;&amp; y);</del>
</pre>
<blockquote>
<del><i>Effects:</i> <tt>x.swap(y)</tt>.</del>
</blockquote>
</blockquote>

<p>
27.7.1.5 [iostreamclass]: make the following member function protected:
</p>

<blockquote><pre>basic_iostream(basic_iostream&amp;&amp;  rhs);
basic_iostream&amp;  operator=(basic_iostream&amp;&amp;  rhs);
void  swap(basic_iostream&amp;&amp;  rhs);
</pre></blockquote>

<p>
Ditto: remove the three swap free functions signatures
</p>

<blockquote><pre><del>template &lt;class charT, class traits&gt; 
  void swap(basic_iostream&lt;charT, traits&gt;&amp; x, basic_iostream&lt;charT, traits&gt;&amp; y); 
template &lt;class charT, class traits&gt; 
  void swap(basic_iostream&lt;charT, traits&gt;&amp;&amp; x, basic_iostream&lt;charT, traits&gt;&amp; y); 
template &lt;class charT, class traits&gt; 
  void swap(basic_iostream&lt;charT, traits&gt;&amp; x, basic_iostream&lt;charT, traits&gt;&amp;&amp; y);</del>
</pre></blockquote>

<p>
27.7.1.5.3 [iostream.assign]: remove paragraph 3
</p>

<blockquote><pre><del>template &lt;class charT, class traits&gt; 
  void swap(basic_iostream&lt;charT, traits&gt;&amp; x, basic_iostream&lt;charT, traits&gt;&amp; y); 
template &lt;class charT, class traits&gt; 
  void swap(basic_iostream&lt;charT, traits&gt;&amp;&amp; x, basic_iostream&lt;charT, traits&gt;&amp; y); 
template &lt;class charT, class traits&gt; 
  void swap(basic_iostream&lt;charT, traits&gt;&amp; x, basic_iostream&lt;charT, traits&gt;&amp;&amp; y);</del>
</pre>
<blockquote>
<del><i>Effects:</i> <tt>x.swap(y)</tt>.</del>
</blockquote>
</blockquote>

<p>
27.7.2.1 [ostream]: make the following member function protected:
</p>

<blockquote><pre>basic_ostream(basic_ostream&amp;&amp;  rhs);
basic_ostream&amp;  operator=(basic_ostream&amp;&amp;  rhs);
void  swap(basic_ostream&amp;&amp;  rhs);
</pre></blockquote>

<p>
Ditto: remove the three swap free functions signatures
</p>

<blockquote><pre><del>// swap: 
template &lt;class charT, class traits&gt; 
  void swap(basic_ostream&lt;charT, traits&gt;&amp; x, basic_ostream&lt;charT, traits&gt;&amp; y);
template &lt;class charT, class traits&gt; 
  void swap(basic_ostream&lt;charT, traits&gt;&amp;&amp; x, basic_ostream&lt;charT, traits&gt;&amp; y); 
template &lt;class charT, class traits&gt; 
  void swap(basic_ostream&lt;charT, traits&gt;&amp; x, basic_ostream&lt;charT, traits&gt;&amp;&amp; y);</del>
</pre></blockquote>

<p>
27.7.2.3 [ostream.assign]: remove paragraph 13 (The paragraphs seems to
be misnumbered in the whole section 27.7.2 [output.streams] in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2723.pdf">N2723</a>.
The paragraph to
remove is the one that describes the three <tt>swap</tt> free functions).
</p>

<blockquote><pre><del>template &lt;class charT, class traits&gt; 
  void swap(basic_ostream&lt;charT, traits&gt;&amp; x, basic_ostream&lt;charT, traits&gt;&amp; y); 
template &lt;class charT, class traits&gt; 
  void swap(basic_ostream&lt;charT, traits&gt;&amp;&amp; x, basic_ostream&lt;charT, traits&gt;&amp; y); 
template &lt;class charT, class traits&gt; 
  void swap(basic_ostream&lt;charT, traits&gt;&amp; x, basic_ostream&lt;charT, traits&gt;&amp;&amp; y);</del>
</pre>
<blockquote>
<del><i>Effects:</i> <tt>x.swap(y)</tt>.</del>
</blockquote>
</blockquote>






<hr>
<h3><a name="912"></a>912. Array swap needs to be conceptualized</h3>
<p><b>Section:</b> 25.4.3 [alg.swap] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2008-10-01  <b>Last modified:</b> 2009-05-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.swap">issues</a> in [alg.swap].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
With the adaption of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#809">809</a>
we have a new algorithm <tt>swap</tt> for C-arrays, which needs to be conceptualized.
</p>

<p><i>[
Post Summit Daniel adds:
]</i></p>


<blockquote>
Recommend as NAD Editorial: The changes have already been applied to the WP
<a href="" ref="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2800.pdf">N2800</a>.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Move to NAD; the changes have already been made.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Replace in 25.4.3 [alg.swap] before p. 3 until p. 4 by
</p>

<blockquote><pre>template &lt;<del>class</del> <ins>ValueType</ins> T, size_t N&gt;
<ins>requires Swappable&lt;T&gt;</ins>
void swap(T (&amp;a)[N], T (&amp;b)[N]);
</pre>
<blockquote>
<p>
<del><i>Requires:</i> <tt>T</tt> shall be <tt>Swappable</tt>.</del>
</p>
<p>
<i>Effects:</i> <tt>swap_ranges(a, a + N, b);</tt>
</p>
</blockquote>
</blockquote>






<hr>
<h3><a name="913"></a>913. Superfluous requirements for replace algorithms</h3>
<p><b>Section:</b> 25.4.5 [alg.replace] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2008-10-03  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#alg.replace">active issues</a> in [alg.replace].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.replace">issues</a> in [alg.replace].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
(A) 25.4.5 [alg.replace]/1:
</p>

<blockquote>
<i>Requires:</i> The expression <tt>*first = new_value</tt> shall be valid.
</blockquote>

<p>
(B) 25.4.5 [alg.replace]/4:
</p>

<blockquote>
<i>Requires:</i> The results of the expressions <tt>*first</tt> and <tt>new_value</tt> shall
be writable to the result output iterator.[..]
</blockquote>

<p>
Since conceptualization, the quoted content of these clauses is covered
by the existing requirements
</p>

<p>
(A) <tt>OutputIterator&lt;Iter, const T&amp;&gt;</tt>
</p>

<p>
and
</p>

<p>
(B) <tt>OutputIterator&lt;OutIter, InIter::reference&gt; &amp;&amp; OutputIterator&lt;OutIter, const T&amp;&gt;</tt>
</p>

<p>
resp, and thus should be removed.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We agree with the proposed resolution.
</p>
<p>
Move to Tentatively Ready.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<ol type="A">
<li>
<p>
Remove 25.4.5 [alg.replace]/1.
</p>
<blockquote><pre>template&lt;ForwardIterator Iter, class T&gt; 
  requires OutputIterator&lt;Iter, Iter::reference&gt; 
        &amp;&amp; OutputIterator&lt;Iter, const T&amp;&gt; 
        &amp;&amp; HasEqualTo&lt;Iter::value_type, T&gt; 
  void replace(Iter first, Iter last, 
               const T&amp; old_value, const T&amp; new_value); 

template&lt;ForwardIterator Iter, Predicate&lt;auto, Iter::value_type&gt; Pred, class T&gt; 
  requires OutputIterator&lt;Iter, Iter::reference&gt; 
        &amp;&amp; OutputIterator&lt;Iter, const T&amp;&gt; 
        &amp;&amp; CopyConstructible&lt;Pred&gt; 
  void replace_if(Iter first, Iter last, 
                  Pred pred, const T&amp; new_value);
</pre>
<blockquote>
<del>1 <i>Requires:</i> The expression <tt>*first = new_value</tt> shall be valid.</del>
</blockquote>
</blockquote>
</li>
<li>
<p>
25.4.5 [alg.replace]/4: Remove the sentence "The results of the
expressions <tt>*first</tt> and
<tt>new_value</tt> shall be writable to the result output iterator.".
</p>
<blockquote><pre>template&lt;InputIterator InIter, typename OutIter, class T&gt; 
  requires OutputIterator&lt;OutIter, InIter::reference&gt; 
        &amp;&amp; OutputIterator&lt;OutIter, const T&amp;&gt; 
        &amp;&amp; HasEqualTo&lt;InIter::value_type, T&gt; 
  OutIter replace_copy(InIter first, InIter last, 
                       OutIter result, 
                       const T&amp; old_value, const T&amp; new_value);

template&lt;InputIterator InIter, typename OutIter,
         Predicate&lt;auto, InIter::value_type&gt; Pred, class T&gt; 
  requires OutputIterator&lt;OutIter, InIter::reference&gt; 
        &amp;&amp; OutputIterator&lt;OutIter, const T&amp;&gt; 
        &amp;&amp; CopyConstructible&lt;Pred&gt; 
  OutIter replace_copy_if(InIter first, InIter last, 
                          OutIter result, 
                          Pred pred, const T&amp; new_value);
</pre>
<blockquote>
4 <i>Requires:</i> <del>The results of the expressions <tt>*first</tt> and
<tt>new_value</tt> shall be writable to the <tt>result</tt> output
iterator.</del> The ranges <tt>[first,last)</tt> and <tt>[result,result +
(last - first))</tt> shall not overlap.
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="914"></a>914. Superfluous requirement for unique</h3>
<p><b>Section:</b> 25.4.9 [alg.unique] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2008-10-03  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#alg.unique">active issues</a> in [alg.unique].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.unique">issues</a> in [alg.unique].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
25.4.9 [alg.unique]/2: "Requires: The comparison function shall be an
equivalence relation."
</p>

<p>
The essence of this is already covered by the given requirement
</p>

<blockquote><pre>EquivalenceRelation&lt;auto, Iter::value_type&gt; Pred
</pre></blockquote>

<p>
and should thus be removed.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution.
Move to Tentatively Ready.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Remove 25.4.9 [alg.unique]/2
</p>

<blockquote><pre>template&lt;ForwardIterator Iter&gt;
  requires OutputIterator&lt;Iter, Iter::reference&gt;
        &amp;&amp; EqualityComparable&lt;Iter::value_type&gt;
  Iter unique(Iter first, Iter last);

template&lt;ForwardIterator Iter, EquivalenceRelation&lt;auto, Iter::value_type&gt; Pred&gt;
  requires OutputIterator&lt;Iter, RvalueOf&lt;Iter::reference&gt;::type&gt;
        &amp;&amp; CopyConstructible&lt;Pred&gt;
  Iter unique(Iter first, Iter last,
               Pred pred);
</pre>
<blockquote>
<p>
1 <i>Effects:</i> ...
</p>
<p>
<del>2 <i>Requires:</i> The comparison function shall be an equivalence relation.</del>
</p>
</blockquote>
</blockquote>





<hr>
<h3><a name="915"></a>915. <tt>minmax</tt> with <tt>initializer_list</tt> should return
<tt>pair</tt> of <tt>T</tt>, not <tt>pair</tt> of <tt>const T&amp;</tt></h3>
<p><b>Section:</b> 25.5.7 [alg.min.max] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2008-10-04  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#alg.min.max">active issues</a> in [alg.min.max].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.min.max">issues</a> in [alg.min.max].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It seems that the proposed changes for
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2772.pdf">N2772</a>
were not clear enough in
this point:
</p>

<blockquote>
25.5.7 [alg.min.max], before p.23 + p.24 + before p. 27 + p. 28 say that the return
type of the <tt>minmax</tt> overloads with an <tt>initializer_list</tt> is
<tt>pair&lt;const T&amp;, const T&amp;&gt;</tt>,
which is inconsistent with the decision for the other <tt>min/max</tt> overloads which take
a <tt>initializer_list</tt> as argument and return a <tt>T</tt>, not a <tt>const T&amp;</tt>.
Doing otherwise for <tt>minmax</tt> would easily lead to unexpected life-time
problems by using <tt>minmax</tt> instead of <tt>min</tt> and <tt>max</tt> separately.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution.
Move to Tentatively Ready.
</blockquote>


<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>
In 25 [algorithms]/2, header <tt>&lt;algorithm&gt;</tt> synopsis change as indicated:
</p>

<blockquote><pre>template&lt;<del>class</del><ins>LessThanComparable</ins> T&gt;
<ins>requires CopyConstructible&lt;T&gt;</ins>
pair&lt;<del>const </del>T<del>&amp;</del>, <del>const </del>T<del>&amp;</del>&gt;
minmax(initializer_list&lt;T&gt; t);

template&lt;class T, <del>class</del><ins>StrictWeakOrder&lt;auto, T&gt;</ins> Compare&gt;
<ins>requires CopyConstructible&lt;T&gt;</ins>
pair&lt;<del>const </del>T<del>&amp;</del>, <del>const </del>T<del>&amp;</del>&gt;
minmax(initializer_list&lt;T&gt; t, Compare comp);
</pre></blockquote>
</li>
<li>
<p>
In 25.5.7 [alg.min.max] change as indicated (Begin: Just before p.20):
</p>
<blockquote><pre>template&lt;<del>class</del><ins>LessThanComparable</ins> T&gt;
  <ins>requires CopyConstructible&lt;T&gt;</ins>
  pair&lt;<del>const </del>T<del>&amp;</del>, <del>const </del>T<del>&amp;</del>&gt;
  minmax(initializer_list&lt;T&gt; t);
</pre>
<blockquote>
<p>
<del>-20- <i>Requires:</i> <tt>T</tt> is <tt>LessThanComparable</tt> and
<tt>CopyConstructible</tt>.</del>
</p>
<p>
-21- <i>Returns:</i> <tt>pair&lt;<del>const </del>T<del>&amp;</del>, <del>const
</del>T<del>&amp;</del>&gt;(x, y)</tt> where <tt>x</tt> is the
smallest value and <tt>y</tt> the largest value in the <tt>initializer_list</tt>.
</p>
</blockquote>

<p>[..]</p>
<pre>template&lt;class T, <del>class</del><ins>StrictWeakOrder&lt;auto, T&gt;</ins> Compare&gt;
  <ins>requires CopyConstructible&lt;T&gt;</ins>
  pair&lt;<del>const </del>T<del>&amp;</del>, <del>const </del>T<del>&amp;</del>&gt;
  minmax(initializer_list&lt;T&gt; t, Compare comp);
</pre>

<blockquote>
<p>
<del>-24- <i>Requires:</i> type <tt>T</tt> is <tt>LessThanComparable</tt> and <tt>CopyConstructible</tt>.</del>
</p>
<p>
-25- <i>Returns:</i> <tt>pair&lt;<del>const </del>T<del>&amp;</del>, <del>const
</del>T<del>&amp;</del>&gt;(x, y)</tt> where <tt>x</tt> is the
smallest value and <tt>y</tt> largest value in the <tt>initializer_list</tt>.
</p>
</blockquote>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="916"></a>916. Redundant move-assignment operator of <tt>pair</tt> should be removed</h3>
<p><b>Section:</b> 20.3.3 [pairs] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2008-10-04  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#pairs">active issues</a> in [pairs].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#pairs">issues</a> in [pairs].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>see also <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#917">917</a>.</b></p>

<p>
The current WP provides the following assignment operators for <tt>pair</tt>
in 20.3.3 [pairs]/1:
</p>

<ol>
<li>
<pre>template&lt;class U , class V&gt;
requires HasAssign&lt;T1, const U&amp;&gt; &amp;&amp; HasAssign&lt;T2, const V&amp;&gt;
pair&amp; operator=(const pair&lt;U , V&gt;&amp; p);
</pre>
</li>
<li>
<pre>requires MoveAssignable&lt;T1&gt; &amp;&amp; MoveAssignable&lt;T2&gt; pair&amp; operator=(pair&amp;&amp; p );
</pre>
</li>
<li>
<pre>template&lt;class U , class V&gt;
requires HasAssign&lt;T1, RvalueOf&lt;U&gt;::type&gt; &amp;&amp; HasAssign&lt;T2, RvalueOf&lt;V&gt;::type&gt;
pair&amp; operator=(pair&lt;U , V&gt;&amp;&amp; p);
</pre>
</li>
</ol>

<p>
It seems that the functionality of (2) is completely covered by (3), therefore
(2) should be removed.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Bill believes the extra assignment operators are necessary for resolving
ambiguities, but that does not mean it needs to be part of the specification.
</p>
<p>
Move to Open.
We recommend this be looked at in the context of the ongoing work
related to the pair templates.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<ol type="A">
<li>
<p>
In 20.3.3 [pairs] p. 1, class <tt>pair</tt> and just before p. 13 remove the declaration:
</p>

<blockquote><pre>requires MoveAssignable&lt;T1&gt; &amp;&amp; MoveAssignable&lt;T2&gt; pair&amp; operator=(pair&amp;&amp; p );
</pre></blockquote>
</li>

<li>
Remove p.13+p.14
</li>

</ol>





<hr>
<h3><a name="917"></a>917. Redundant move-assignment operator of <tt>tuple</tt> should be removed</h3>
<p><b>Section:</b> 20.5.2.1 [tuple.cnstr] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2008-10-04  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#tuple.cnstr">active issues</a> in [tuple.cnstr].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#tuple.cnstr">issues</a> in [tuple.cnstr].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>see also <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#916">916</a>.</b></p>
<p>
N2770 (and thus now the WP) removed the
non-template move-assignment operator from tuple's class definition,
but the latter individual member description does still provide this
operator. Is this (a) an oversight and can it (b) be solved as part of an
editorial process?
</p>

<p><i>[
Post Summit Daniel provided wording.
]</i></p>


<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We believe that the proposed resolution's part 1 is editorial.
</p>
<p>
Regarding part 2, we either remove the specification as proposed,
or else add back the declaration to which the specification refers.
Alisdair and Bill prefer the latter.
It is not immediately obvious whether the function is intended to be present.
</p>
<p>
We recommend that the Project Editor restore the missing declaration
and that we keep part 2 of the issue alive.
</p>
<p>
Move to Open.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>
In 20.5.2 [tuple.tuple], class <tt>tuple</tt> just before member <tt>swap</tt> please
change as indicated:
</p>
<p><i>[
This fixes an editorial loss between N2798 to N2800
]</i></p>

<blockquote><pre>template &lt;class... UTypes&gt;
requires HasAssign&lt;Types, const UTypes&amp;&gt;...
<ins>tuple&amp; operator=(const pair&lt;UTypes...&gt;&amp;);</ins>

template &lt;class... UTypes&gt;
requires HasAssign&lt;Types, RvalueOf&lt;UTypes&gt;::type&gt;...
<ins>tuple&amp; operator=(pair&lt;UTypes...&gt;&amp;&amp;);</ins>
</pre></blockquote>
</li>
<li>
<p>
In 20.5.2.1 [tuple.cnstr], starting just before p. 11 please remove
as indicated:
</p>

<blockquote><pre><del>requires MoveAssignable&lt;Types&gt;... tuple&amp; operator=(tuple&amp;&amp; u);</del>
</pre>
<blockquote>
<p>
<del>-11- <i>Effects:</i> Move-assigns each element of <tt>u</tt> to the corresponding
element of <tt>*this</tt>.</del>
</p>
<p>
<del>-12- <i>Returns:</i> <tt>*this</tt>.</del>
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="918"></a>918. Swap for tuple needs to be conceptualized</h3>
<p><b>Section:</b> 20.5.2.6 [tuple.swap] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2008-10-04  <b>Last modified:</b> 2009-05-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#522">522</a> was accepted after <tt>tuple</tt> had been conceptualized,
therefore this step needs to be completed.
</p>

<p><i>[
Post Summit Daniel adds
]</i></p>


<blockquote>
This is now NAD Editorial (addressed by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2844.html">N2844</a>)
except for item 3 in the proposed wording.
</blockquote>

<p><i>[
2009-05-01 Daniel adds:
]</i></p>


<blockquote>
As of the recent WP
(<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2857.pdf">N2857</a>),
this issue is now completely covered by editorial
changes (including the third bullet), therefore I unconditionally recommend
NAD.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We observed that all the proposed changes have already been applied to the
Working Draft, rendering this issue moot.
</p>
<p>
Move to NAD.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>
In both 20.5.1 [tuple.general]/2 and 20.5.2.7 [tuple.special] change
</p>

<blockquote><pre>template &lt;<del>class</del> <ins>Swappable</ins>... Types&gt;
void swap(tuple&lt;Types...&gt;&amp; x, tuple&lt;Types...&gt;&amp; y);
</pre></blockquote>

</li>

<li>
<p>
In 20.5.2 [tuple.tuple], class <tt>tuple</tt> definition and in
20.5.2.6 [tuple.swap], change
</p>

<blockquote><pre><ins>requires Swappable&lt;Types&gt;...</ins>void swap(tuple&amp;);
</pre></blockquote>

</li>

<li>
<p>
In 20.5.2.6 [tuple.swap] remove the current requires-clause, which says:
</p>

<blockquote>
<del><i>Requires:</i> Each type in <tt>Types</tt> shall be <tt>Swappable</tt></del>
</blockquote>
</li>

</ol>






<hr>
<h3><a name="919"></a>919. (forward_)list specialized remove algorithms are over constrained</h3>
<p><b>Section:</b> 23.3.3.5 [forwardlist.ops], 23.3.4.4 [list.ops] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Review">Review</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2008-10-06  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#forwardlist.ops">active issues</a> in [forwardlist.ops].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#forwardlist.ops">issues</a> in [forwardlist.ops].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Review">Review</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The signatures of <tt>forwardlist::remove</tt> and <tt>list::remove</tt>
defined in 23.3.3.5 [forwardlist.ops] before 11 + 23.3.4.4 [list.ops] before 15:
</p>

<blockquote><pre>requires EqualityComparable&lt;T&gt; void remove(const T&amp; value);
</pre></blockquote>

<p>
are asymmetric to their predicate variants (which only require
<tt>Predicate</tt>, <em>not</em> <tt>EquivalenceRelation</tt>) and with the free algorithm
remove (which only require <tt>HasEqualTo</tt>). Also, nothing in the
pre-concept WP
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2723.pdf">N2723</a>
implies that <tt>EqualityComparable</tt> should
be the intended requirement.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We agree with the proposed resolution,
but would like additional input from concepts experts.
</p>
<p>
Move to Review.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<ol type="A">
<li>
<p>
Replace in 23.3.3.5 [forwardlist.ops] before 11 and in 23.3.4.4 [list.ops] before 15
</p>

<blockquote><pre>requires <del>EqualityComparable&lt;T&gt;</del> <ins>HasEqualTo&lt;T, T&gt;</ins> void remove(const T&amp; value);
</pre></blockquote>
</li>
</ol>






<hr>
<h3><a name="920"></a>920. Ref-qualification support in the library</h3>
<p><b>Section:</b> 20.7.15 [func.memfn] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Bronek Kozicki <b>Opened:</b> 2008-10-06  <b>Last modified:</b> 2009-05-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Daniel Krgler wrote:
</p>

<blockquote>
<p>
Shouldn't above list be completed for &amp;- and &amp;&amp;-qualified
member functions This would cause to add:
</p>
<blockquote><pre>template&lt;Returnable R, class T, CopyConstructible... Args&gt;
unspecified mem_fn(R (T::* pm)(Args...) &amp;);
template&lt;Returnable R, class T, CopyConstructible... Args&gt;
unspecified mem_fn(R (T::* pm)(Args...) const &amp;);
template&lt;Returnable R, class T, CopyConstructible... Args&gt;
unspecified mem_fn(R (T::* pm)(Args...) volatile &amp;);
template&lt;Returnable R, class T, CopyConstructible... Args&gt;
unspecified mem_fn(R (T::* pm)(Args...) const volatile &amp;);
template&lt;Returnable R, class T, CopyConstructible... Args&gt;
unspecified mem_fn(R (T::* pm)(Args...) &amp;&amp;);
template&lt;Returnable R, class T, CopyConstructible... Args&gt;
unspecified mem_fn(R (T::* pm)(Args...) const &amp;&amp;);
template&lt;Returnable R, class T, CopyConstructible... Args&gt;
unspecified mem_fn(R (T::* pm)(Args...) volatile &amp;&amp;);
template&lt;Returnable R, class T, CopyConstructible... Args&gt;
unspecified mem_fn(R (T::* pm)(Args...) const volatile &amp;&amp;);
</pre></blockquote>

</blockquote>

<p>
yes, absolutely. Thanks for spotting this. Without this change <tt>mem_fn</tt>
cannot be initialized from pointer to ref-qualified member function. I
believe semantics of such function pointer is well defined.
</p>

<p><i>[
Post Summit Daniel provided wording.
]</i></p>


<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We need to think about whether we really want to go down the proposed path
of combinatorial explosion.
Perhaps a Note would suffice.
</p>
<p>
We would really like to have an implementation before proceeding.
</p>
<p>
Move to Open, and recommend this be deferred until after the next
Committee Draft has been issued.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>
In 20.7 [function.objects]/2, header <tt>&lt;functional&gt;</tt> synopsis, just after
the section "// 20.6.15, member function adaptors::" add the following
declarations to the existing list:
</p>
<blockquote><pre>template&lt;Returnable R, class T, CopyConstructible... Args&gt;
  <i>unspecified</i> mem_fn(R (T::* pm)(Args...) &amp;);
template&lt;Returnable R, class T, CopyConstructible... Args&gt;
  <i>unspecified</i> mem_fn(R (T::* pm)(Args...) const &amp;);
template&lt;Returnable R, class T, CopyConstructible... Args&gt;
  <i>unspecified</i> mem_fn(R (T::* pm)(Args...) volatile &amp;);
template&lt;Returnable R, class T, CopyConstructible... Args&gt;
  <i>unspecified</i> mem_fn(R (T::* pm)(Args...) const volatile &amp;);
template&lt;Returnable R, class T, CopyConstructible... Args&gt;
  <i>unspecified</i> mem_fn(R (T::* pm)(Args...) &amp;&amp;);
template&lt;Returnable R, class T, CopyConstructible... Args&gt;
  <i>unspecified</i> mem_fn(R (T::* pm)(Args...) const &amp;&amp;);
template&lt;Returnable R, class T, CopyConstructible... Args&gt;
  <i>unspecified</i> mem_fn(R (T::* pm)(Args...) volatile &amp;&amp;);
template&lt;Returnable R, class T, CopyConstructible... Args&gt;
  <i>unspecified</i> mem_fn(R (T::* pm)(Args...) const volatile &amp;&amp;);
</pre></blockquote>
</li>
<li>
<p>
In 20.7.15 [func.memfn] add the following declarations to the existing
list:
</p>
<blockquote><pre>template&lt;Returnable R, class T, CopyConstructible... Args&gt;
  <i>unspecified</i> mem_fn(R (T::* pm)(Args...) &amp;);
template&lt;Returnable R, class T, CopyConstructible... Args&gt;
  <i>unspecified</i> mem_fn(R (T::* pm)(Args...) const &amp;);
template&lt;Returnable R, class T, CopyConstructible... Args&gt;
  <i>unspecified</i> mem_fn(R (T::* pm)(Args...) volatile &amp;);
template&lt;Returnable R, class T, CopyConstructible... Args&gt;
  <i>unspecified</i> mem_fn(R (T::* pm)(Args...) const volatile &amp;);
template&lt;Returnable R, class T, CopyConstructible... Args&gt;
  <i>unspecified</i> mem_fn(R (T::* pm)(Args...) &amp;&amp;);
template&lt;Returnable R, class T, CopyConstructible... Args&gt;
  <i>unspecified</i> mem_fn(R (T::* pm)(Args...) const &amp;&amp;);
template&lt;Returnable R, class T, CopyConstructible... Args&gt;
  <i>unspecified</i> mem_fn(R (T::* pm)(Args...) volatile &amp;&amp;);
template&lt;Returnable R, class T, CopyConstructible... Args&gt;
  <i>unspecified</i> mem_fn(R (T::* pm)(Args...) const volatile &amp;&amp;);
</pre></blockquote>
</li>
</ol>
<p>
The following text, most notably p.2 and p.3 which discuss influence
of the cv-qualification on the definition of the base class's first template
parameter remains unchanged.
</p>





<hr>
<h3><a name="921"></a>921. Rational Arithmetic should use template aliases</h3>
<p><b>Section:</b> 20.4.1 [ratio.ratio] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Review">Review</a>
 <b>Submitter:</b> Pablo Halpern <b>Opened:</b> 2008-10-07  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#ratio.ratio">active issues</a> in [ratio.ratio].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#ratio.ratio">issues</a> in [ratio.ratio].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Review">Review</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The compile-time functions that operate on <tt>ratio&lt;N,D&gt;</tt> require the
cumbersome and error-prone "evaluation" of a <tt>type</tt> member using a
meta-programming style that predates the invention of template aliases.
Thus, multiplying three ratios <tt>a</tt>, <tt>b</tt>, and <tt>c</tt> requires the expression:
</p>

<blockquote><pre>ratio_multiply&lt;a, ratio_multiply&lt;b, c&gt;::type&gt;::type
</pre></blockquote>

<p>
The simpler expression:
</p>

<blockquote><pre>ratio_multiply&lt;a, ratio_multiply&lt;b, c&gt;&gt;
</pre></blockquote>

<p>
Could be used by if template aliases were employed in the definitions.
</p>

<p><i>[
Post Summit:
]</i></p>


<blockquote>
<p>
Jens: not a complete proposed resolution: "would need to make similar change"
</p>
<p>
Consensus: We agree with the direction of the issue.
</p>
<p>
Recommend Open.
</p>
</blockquote>

<p><i>[
2009-05-11 Daniel adds:
]</i></p>


<blockquote>
<p>
Personally I'm <em>not</em> in favor for the addition of:
</p>
<blockquote><pre>typedef ratio type;
</pre></blockquote>
<p>
For a reader of the
standard it's usage or purpose is unclear. I haven't seen similar examples
of attempts to satisfy non-feature complete compilers.
</p>
</blockquote>

<p><i>[
2009-05-11 Pablo adds:
]</i></p>


<blockquote>
<p>
The addition of type to the <tt>ratio</tt> template allows the previous style
(i.e., in the prototype implementations) to remain valid and permits the
use of transitional library implementations for C++03 compilers.  I do
not feel strongly about its inclusion, however, and leave it up to the
reviewers to decide.
</p>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Bill asks for additional discussion in the issue
that spells out more details of the implementation.
Howard points us to issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#948">948</a>
which has at least most of the requested details.
Tom is strongly in favor of overflow-checking at compile time.
Pete points out that there is no change of functionality implied.
We agree with the proposed resolution,
but recommend moving the issue to Review
to allow time to improve the discussion if needed.
</blockquote>


<p><b>Proposed resolution:</b></p>

 
 <ol start="0">
<li>
<p>
In 20.4 [ratio]/3 change as indicated:
</p>

<blockquote><pre>// ratio arithmetic
template &lt;class R1, class R2&gt; <del>struct</del><ins>using</ins> ratio_add<ins> = <em>see below</em></ins>;
template &lt;class R1, class R2&gt; <del>struct</del><ins>using</ins> ratio_subtract<ins> = <em>see below</em></ins>;
template &lt;class R1, class R2&gt; <del>struct</del><ins>using</ins> ratio_multiply<ins> = <em>see below</em></ins>;
template &lt;class R1, class R2&gt; <del>struct</del><ins>using</ins> ratio_divide<ins> = <em>see below</em></ins>;
</pre></blockquote>
</li>
<li>
<p>
In 20.4.1 [ratio.ratio], change as indicated:
</p>
<blockquote><pre>namespace std {
  template &lt;intmax_t N, intmax_t D = 1&gt;
  class ratio {
  public:
    <ins>typedef ratio type;</ins>
    static const intmax_t num;
    static const intmax_t den;
  };
}
</pre></blockquote>
</li>
<li>
<p>
In 20.4.2 [ratio.arithmetic] change as indicated:
</p>

<blockquote><pre>template &lt;class R1, class R2&gt; <del>struct</del><ins>using</ins> ratio_add<ins> = <em>see below</em></ins><del>{
  typedef <em>see below</em> type;
}</del>;
</pre>

<blockquote>
<p>
1 The <del>nested typedef</del> type <tt><ins>ratio_add&lt;R1, R2&gt;</ins></tt>
shall be a synonym for <tt>ratio&lt;T1, T2&gt;</tt>
where <tt>T1</tt> has the value <tt>R1::num * R2::den + R2::num * R1::den</tt> and <tt>T2</tt>
has the value <tt>R1::den * R2::den</tt>.
</p>
</blockquote>
</blockquote>
<blockquote><pre>template &lt;class R1, class R2&gt; <del>struct</del><ins>using</ins> ratio_subtract<ins> = <em>see below</em></ins><del>{
  typedef <em>see below</em> type;
}</del>;
</pre>
<blockquote>
<p>
2 The <del>nested typedef</del> type <tt><ins>ratio_subtract&lt;R1, R2&gt;</ins></tt>
shall be a synonym for <tt>ratio&lt;T1, T2&gt;</tt>
where <tt>T1</tt> has the value <tt>R1::num * R2::den - R2::num * R1::den</tt> and <tt>T2</tt>
has the value <tt>R1::den * R2::den</tt>.
</p>
</blockquote>
</blockquote>
<blockquote><pre>template &lt;class R1, class R2&gt; <del>struct</del><ins>using</ins> ratio_multiply<ins> = <em>see below</em></ins><del>{
  typedef <em>see below</em> type;
}</del>;
</pre>
<blockquote>
<p>
3 The <del>nested typedef</del> type <tt><ins>ratio_multiply&lt;R1, R2&gt;</ins></tt>
shall be a synonym for <tt>ratio&lt;T1, T2&gt;</tt>
where <tt>T1</tt> has the value <tt>R1::num * R2::num</tt> and <tt>T2</tt> has the value <tt>R1::den * R2::den</tt>.
</p>
</blockquote>
</blockquote>
<blockquote><pre>template &lt;class R1, class R2&gt; <del>struct</del><ins>using</ins> ratio_divide<ins> = <em>see below</em></ins><del>{
  typedef <em>see below</em> type;
}</del>;
</pre>
<blockquote>
<p>
4 The <del>nested typedef</del> type <tt><ins>ratio_divide&lt;R1, R2&gt;</ins></tt>
shall be a synonym for <tt>ratio&lt;T1, T2&gt;</tt>
where <tt>T1</tt> has the value <tt>R1::num * R2::den</tt> and <tt>T2</tt> has the value <tt>R1::den * R2::num</tt>.
</p>
</blockquote>
</blockquote>
</li>
<li>
<p>
In 20.9.3.1 [time.duration.cons]/4 change as indicated:
</p>
<blockquote>
<p>
<i>Requires:</i> <tt>treat_as_floating_point&lt;rep&gt;::value</tt> shall be true or
<tt>ratio_divide&lt;Period2, period&gt;::<del>type::</del>den</tt> shall be 1.[..]
</p>
</blockquote>
</li>
<li>
<p>
In 20.9.3.7 [time.duration.cast]/2 change as indicated:
</p>
<blockquote>
<p>
<i>Returns:</i> Let CF be <tt>ratio_divide&lt;Period, typename
ToDuration::period&gt;<del>::type</del></tt>, and [..]
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="922"></a>922. [func.bind.place] Number of placeholders</h3>
<p><b>Section:</b> B [implimits] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Sohail Somani <b>Opened:</b> 2008-10-11  <b>Last modified:</b> 2009-03-13</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses DE 24</b></p>

<p>
With respect to the section 20.7.12.1.4 [func.bind.place]:
</p>
<p>
TR1 dropped some suggested implementation quantities for the number of
placeholders. The purpose of this defect is to put these back for C++0x.
</p>

<p><i>[
Post Summit:
]</i></p>


<blockquote>
<p>
see DE 24
</p>
<p>
Recommend applying the proposed resolution from DE 24, with that
Tentatively Ready.
</p>
</blockquote>

<b>Original proposed resolution:</b>

<p>
Add 20.7.12.1.4 [func.bind.place]/2:
</p>

<blockquote>
While the exact number of placeholders (<tt>_M</tt>) is implementation defined,
this number shall be at least 10.
</blockquote>



<p><b>Proposed resolution:</b></p>

<p>
Add to B [implimits]:
</p>

<ul>
<li>
Number of placeholders (20.7.12.1.4 [func.bind.place]) [10].
</li>
</ul>






<hr>
<h3><a name="923"></a>923. atomics with floating-point </h3>
<p><b>Section:</b> 29 [atomics] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Herb Sutter <b>Opened:</b> 2008-10-17  <b>Last modified:</b> 2009-05-01</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#atomics">active issues</a> in [atomics].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#atomics">issues</a> in [atomics].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Right now, C++0x doesn't have <tt>atomic&lt;float&gt;</tt>. We're thinking of adding
the words to support it for TR2 (note: that would be slightly
post-C++0x). If we need it, we could probably add the words.
</p>
<p>
<b>Proposed resolutions:</b> Using <tt>atomic&lt;FP&gt;::compare_exchange</tt> (weak or
strong) should be either:
</p>

<ol>
<li>
ill-formed, or
</li>
<li>
well-defined.
</li>
</ol>

<p>
I propose Option 1 for C++0x for expediency. If someone wants to argue
for Option 2, they need to say what exactly they want <tt>compare_exchange</tt>
to mean in this case (IIRC, C++0x doesn't even assume IEEE 754).
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Move to open. Blocked until concepts for atomics are addressed.
</blockquote>

<p><i>[
Post Summit Anthony adds:
]</i></p>


<blockquote>
<p>
Recommend NAD. C++0x does have <tt>std::atomic&lt;float&gt;</tt>, and both
<tt>compare_exchange_weak</tt> and <tt>compare_exchange_strong</tt> are well-defined in
this case. Maybe change the note in 29.6 [atomics.types.operations] paragraph 20 to:
</p>

<blockquote>
<p>
[<i>Note:</i> The effect of the compare-and-exchange operations is
</p>
<blockquote><pre>if (!memcmp(object,expected,sizeof(*object)))
    *object = desired;
else
    *expected = *object;
</pre></blockquote>

<p>
This may result in failed comparisons for values that compare equal if
the underlying type has padding bits or alternate representations of
the same value. <i>-- end note</i>]
</p>
</blockquote>

</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change the note in 29.6 [atomics.types.operations] paragraph 20 to:
</p>

<blockquote>
<p>
[<i>Note:</i> The effect of the compare-and-exchange operations is
</p>
<blockquote><pre>if (<del>*object == *expected</del> <ins>!memcmp(object,expected,sizeof(*object))</ins>)
    *object = desired;
else
    *expected = *object;
</pre></blockquote>

<p><ins>
This may result in failed comparisons for values that compare equal if
the underlying type has padding bits or alternate representations of
the same value.</ins> <i>-- end note</i>]
</p>
</blockquote>






<hr>
<h3><a name="924"></a>924. structs with internal padding</h3>
<p><b>Section:</b> 29 [atomics] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Herb Sutter <b>Opened:</b> 2008-10-17  <b>Last modified:</b> 2009-03-22</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#atomics">active issues</a> in [atomics].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#atomics">issues</a> in [atomics].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Right now, the <tt>compare_exchange_weak</tt> loop should rapidly converge on the
padding contents. But <tt>compare_exchange_strong</tt> will require a bit more
compiler work to ignore padding for comparison purposes.
</p>
<p>
Note that this isn't a problem for structs with no padding, and we do
already have one portable way to ensure that there is no padding that
covers the key use cases: Have elements be the same type. I suspect that
the greatest need is for a structure of two pointers, which has no
padding problem. I suspect the second need is a structure of a pointer
and some form of an integer. If that integer is <tt>intptr_t</tt>, there will be
no padding.
</p>
<p>
Related but separable issue: For unused bitfields, or other unused
fields for that matter, we should probably say it's the programmer's
responsibility to set them to zero or otherwise ensure they'll be
ignored by <tt>memcmp</tt>.
</p>

<p>
<b>Proposed resolutions:</b> Using
<tt>atomic&lt;struct-with-padding&gt;::compare_exchange_strong</tt> should be either:
</p>

<ol>
<li>
ill-formed, or
</li>
<li>
well-defined.
</li>
</ol>

<p>
I propose Option 1 for C++0x for expediency, though I'm not sure how to
say it. I would be happy with Option 2, which I believe would mean that
<tt>compare_exchange_strong</tt> would be implemented to avoid comparing padding
bytes, or something equivalent such as always zeroing out padding when
loading/storing/comparing. (Either implementation might require compiler
support.)
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Move to open. Blocked until concepts for atomics are addressed.
</blockquote>

<p><i>[
Post Summit Anthony adds:
]</i></p>


<blockquote>
The resoultion of LWG <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#923">923</a> should resolve this issue as well.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="925"></a>925. <tt>shared_ptr</tt>'s explicit conversion from <tt>unique_ptr</tt></h3>
<p><b>Section:</b> 20.8.13.2.1 [util.smartptr.shared.const] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Rodolfo Lima <b>Opened:</b> 2008-10-12  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#util.smartptr.shared.const">active issues</a> in [util.smartptr.shared.const].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#util.smartptr.shared.const">issues</a> in [util.smartptr.shared.const].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The current working draft
(<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2798.pdf">N2798</a>),
section 20.8.13.2.1 [util.smartptr.shared.const] declares
<tt>shared_ptr</tt>'s constructor that takes a rvalue reference to <tt>unique_ptr</tt> and
<tt>auto_ptr</tt> as being explicit, affecting several valid smart pointer use
cases that would take advantage of this conversion being implicit, for
example:
</p>

<blockquote><pre>class A;
std::unique_ptr&lt;A&gt; create();
void process(std::shared_ptr&lt;A&gt; obj);

int main()
{
   process(create());                  // use case #1
   std::unique_ptr&lt;A&gt; uobj = create();
   process(std::move(uobj));           // use case #2
   return 0;
}
</pre></blockquote>

<p>
If <tt>unique_ptr</tt> to <tt>shared_ptr</tt> conversions are explicit, the above lines
should be written:
</p>

<blockquote><pre>process(std::shared_ptr&lt;A&gt;(create()));        // use case #1
process(std::shared_ptr&lt;A&gt;(std::move(uobj))); // use case #2
</pre></blockquote>

<p>
The extra cast required doesn't seems to give any benefits to the user,
nor protects him of any unintended conversions, this being the raison
d'etre of explicit constructors.
</p>

<p>
It seems that this constructor was made explicit to mimic the conversion
from <tt>auto_ptr</tt> in pre-rvalue reference days, which accepts both lvalue and
rvalue references. Although this decision was valid back then, C++0x
allows the user to express in a clear and non verbose manner when he wants
move semantics to be employed, be it implicitly (use case 1) or explicitly
(use case 2).
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Howard and Alisdair like the motivating use cases
and the proposed resolution.
</p>
<p>
Move to Tentatively Ready.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
In both 20.8.13.2 [util.smartptr.shared] paragraph 1 and 
20.8.13.2.1 [util.smartptr.shared.const] change:
</p>

<blockquote><pre>template &lt;class Y&gt; <del>explicit</del> shared_ptr(auto_ptr&lt;Y&gt; &amp;&amp;r);
template &lt;class Y, class D&gt; <del>explicit</del> shared_ptr(unique_ptr&lt;Y, D&gt; &amp;&amp;r);
</pre></blockquote>






<hr>
<h3><a name="926"></a>926. Sequentially consistent fences, relaxed operations and modification order</h3>
<p><b>Section:</b> 29.3 [atomics.order] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Anthony Williams <b>Opened:</b> 2008-10-19  <b>Last modified:</b> 2009-03-22</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#atomics.order">issues</a> in [atomics.order].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses UK 313</b></p>

<p>
There was an interesting issue raised over on comp.programming.threads
today regarding the following example
</p>

<blockquote><pre>// Thread 1:
x.store(1, memory_order_relaxed);           // SX
atomic_thread_fence(memory_order_seq_cst);  // F1
y.store(1, memory_order_relaxed);           // SY1
atomic_thread_fence(memory_order_seq_cst);  // F2
r1 = y.load(memory_order_relaxed);          // RY

// Thread 2:
y.store(0, memory_order_relaxed);          // SY2
atomic_thread_fence(memory_order_seq_cst); // F3
r2 = x.load(memory_order_relaxed);         // RX
</pre></blockquote>

<p>
is the outcome <tt>r1 == 0</tt> and <tt>r2 == 0</tt> possible?
</p>
<p>
I think the intent is that this is not possible, but I am not sure the
wording guarantees that. Here is my analysis:
</p>
<p>
Since all the fences are SC, there must be a total order between them.
<tt>F1</tt> must be before <tt>F2</tt> in that order since they are in
the same thread. Therefore <tt>F3</tt> is either before <tt>F1</tt>,
between <tt>F1</tt> and <tt>F2</tt> or after <tt>F2</tt>.
</p>
<p>
If <tt>F3</tt> is <em>after</em> <tt>F2</tt>, then we can apply 29.3 [atomics.order]p5 from
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2798.pdf">N2798</a>:
</p>

<blockquote>
For atomic operations <tt>A</tt> and <tt>B</tt> on an atomic object
<tt>M</tt>, where <tt>A</tt> modifies <tt>M</tt> and <tt>B</tt> takes
its value, if there are <tt>memory_order_seq_cst</tt> fences <tt>X</tt>
and <tt>Y</tt> such that <tt>A</tt> is sequenced before <tt>X</tt>,
<tt>Y</tt> is sequenced before <tt>B</tt>, and <tt>X</tt> precedes
<tt>Y</tt> in <tt>S</tt>, then <tt>B</tt> observes either the effects of
<tt>A</tt> or a later modification of <tt>M</tt> in its modification
order.
</blockquote>

<p>
In this case, <tt>A</tt> is <tt>SX</tt>, <tt>B</tt> is <tt>RX</tt>, the
fence <tt>X</tt> is <tt>F2</tt> and the fence <tt>Y</tt> is <tt>F3</tt>,
so <tt>RX</tt> must see 1.
</p>
<p>
If <tt>F3</tt> is <em>before</em> <tt>F2</tt>, this doesn't apply, but
<tt>F3</tt> can therefore be before or after <tt>F1</tt>.
</p>
<p>
If <tt>F3</tt> is <em>after</em> <tt>F1</tt>, the same logic applies, but this
time the fence <tt>X</tt> is <tt>F1</tt>. Therefore again, <tt>RX</tt>
must see 1.
</p>
<p>
Finally we have the case that <tt>F3</tt> is <em>before</em> <tt>F1</tt>
in the SC ordering. There are now no guarantees about <tt>RX</tt>, and
<tt>RX</tt> can see <tt>r2==0</tt>.
</p>
<p>
We can apply 29.3 [atomics.order]p5 again. This time,
<tt>A</tt> is <tt>SY2</tt>, <tt>B</tt> is <tt>RY</tt>, <tt>X</tt> is
<tt>F3</tt> and <tt>Y</tt> is <tt>F1</tt>. Thus <tt>RY</tt> must observe
the effects of <tt>SY2</tt> or a later modification of <tt>y</tt> in its
modification order.
</p>
<p>
Since <tt>SY1</tt> is sequenced before <tt>RY</tt>, <tt>RY</tt> must
observe the effects of <tt>SY1</tt> or a later modification of
<tt>y</tt> in its modification order.
</p>
<p>
In order to ensure that <tt>RY</tt> sees <tt>(r1==1)</tt>, we must see
that <tt>SY1</tt> is later in the modification order of <tt>y</tt> than
<tt>SY2</tt>.
</p>
<p>
We're now skating on thin ice. Conceptually, <tt>SY2</tt> happens-before
<tt>F3</tt>, <tt>F3</tt> is SC-ordered before <tt>F1</tt>, <tt>F1</tt>
happens-before <tt>SY1</tt>, so <tt>SY1</tt> is later in the
modification order <tt>M</tt> of <tt>y</tt>, and <tt>RY</tt> must see
the result of <tt>SY1</tt> (<tt>r1==1</tt>). However, I don't think the
words are clear on that.
</p>

<p><i>[
Post Summit Hans adds:
]</i></p>


<blockquote>
<p>
In my (Hans') view, our definition of fences will always be weaker than
what particular hardware will guarantee.  <tt>Memory_order_seq_cst</tt> fences
inherently don't guarantee sequential consistency anyway, for good
reasons (e.g. because they can't enforce a total order on stores).
 Hence I don't think the issue demonstrates a gross failure to achieve
what we intended to achieve.  The example in question is a bit esoteric.
 Hence, in my view, living with the status quo certainly wouldn't be a
disaster either.
</p>
<p>
In any case, we should probably add text along the lines of the
following between p5 and p6 in 29.3 [atomics.order]:
</p>
<blockquote>
[Note: <tt>Memory_order_seq_cst</tt> only ensures sequential consistency for a
data-race-free program that uses exclusively <tt>memory_order_seq_cst</tt>
operations.  Any use of weaker ordering will invalidate this guarantee
unless extreme care is used.  In particular, <tt>memory_order_seq_cst</tt> fences
only ensure a total order for the fences themselves.  They cannot, in
general, be used to restore sequential consistency for atomic operations
with weaker ordering specifications.]
</blockquote>

<p>
Also see thread beginning at c++std-lib-23271.
</p>

</blockquote>

<p><i>[
Herve's correction:
]</i></p>

<blockquote>
<p>
Minor point, and sorry for the knee jerk reaction: I admit to having
no knowledge of Memory_order_seq_cst, but my former boss (John Lakos)
has ingrained an automatic introspection on the use of "only".   I
think you meant:
</p>

<blockquote>
[Note: <tt>Memory_order_seq_cst</tt> ensures sequential consistency only
for . . . .  In particular, <tt>memory_order_seq_cst</tt> fences ensure a
total order only for . . .
</blockquote>
<p>
Unless, of course, <tt>Memory_order_seq_cst</tt> really do nothing but ensure
sequential consistency for a data-race-free program that uses
exclusively <tt>memory_order_seq_cst</tt> operations.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add a new paragraph after 29.3 [atomics.order]p5 that says
</p>

<blockquote>
For atomic operations <tt>A</tt> and <tt>B</tt> on an atomic object
<tt>M</tt>, where <tt>A</tt> and <tt>B</tt> modify <tt>M</tt>, if there
are <tt>memory_order_seq_cst</tt> fences <tt>X</tt> and <tt>Y</tt> such
that <tt>A</tt> is sequenced before <tt>X</tt>, <tt>Y</tt> is sequenced
before <tt>B</tt>, and <tt>X</tt> precedes <tt>Y</tt> in <tt>S</tt>,
then <tt>B</tt> occurs later than <tt>A</tt> in the modifiction order of
<tt>M</tt>.
</blockquote>





<hr>
<h3><a name="927"></a>927. <tt>Dereferenceable</tt>  should be <tt>HasDereference</tt></h3>
<p><b>Section:</b> 20.8.2.2 [allocator.concepts] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">Tentatively NAD Editorial</a>
 <b>Submitter:</b> Pablo Halpern <b>Opened:</b> 2008-10-23  <b>Last modified:</b> 2009-05-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20NAD%20Editorial">Tentatively NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
20.8.2.2 [allocator.concepts] contains a reference to a concept named
<tt>Dereferenceable</tt>. No such concept exists.
</p>

<p><i>[
Daniel adds 2009-02-14:
]</i></p>


<blockquote>
The proposal given in the paper
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2829.pdf">N2829</a>
would automatically resolve this issue.
</blockquote>


<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
This particular set of changes has already been made.
There are two related changes later on (and possibly also an earlier Example);
these can be handled editorially.
</p>
<p>
Move to NAD Editorial.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change all uses of the concept <tt>Dereferenceable</tt> to
<tt>HasDereference</tt> in 20.8.2.2 [allocator.concepts].
</p>





<hr>
<h3><a name="928"></a>928. Wrong concepts used for <tt>tuple</tt>'s comparison operators</h3>
<p><b>Section:</b> 20.5.2.5 [tuple.rel] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Joe Gottman <b>Opened:</b> 2008-10-28  <b>Last modified:</b> 2009-03-09</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#tuple.rel">issues</a> in [tuple.rel].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In the latest working draft for C++0x, <tt>tuple</tt>'s <tt>operator==</tt> and <tt>operator&lt;</tt>
are declared as 
</p>

<blockquote><pre>template&lt;class... TTypes, class... UTypes&gt; 
  requires EqualityComparable&lt;TTypes, UTypes&gt;... 
  bool operator==(const tuple&lt;TTypes...&gt;&amp; t, const tuple&lt;UTypes...&gt;&amp; u);
</pre></blockquote>

<p>
and
</p>

<blockquote><pre>template&lt;class... TTypes, class... UTypes&gt; 
  requires LessThanComparable&lt;TTypes, UTypes&gt;... 
  bool operator&lt;(const tuple&lt;TTypes...&gt;&amp; t, const tuple&lt;UTypes...&gt;&amp; u);
</pre></blockquote>

<p>
But the concepts <tt>EqualityComparable</tt> and <tt>LessThanComparable</tt> only take one 
parameter, not two.  Also, even if <tt>LessThanComparable</tt> could take two 
parameters, the definition of <tt>tuple::operator&lt;()</tt> should also require 
</p>

<blockquote><pre>LessThanComparable&lt;UTypes, TTypes&gt;... // (note the order) 
</pre></blockquote>

<p>
since the algorithm for <tt>tuple::operator&lt;</tt> is the following (pseudo-code)
</p>

<blockquote><pre>for (size_t N = 0; N &lt; sizeof...(TTypes); ++N) { 
    if (get&lt;N&gt;(t) &lt; get&lt;N&gt;(u) return true; 
    else if ((get&lt;N&gt;(u) &lt; get&lt;N&gt;(t)) return false; 
} 

return false; 
</pre></blockquote>

<p>
Similar problems hold for <tt>tuples</tt>'s other comparison operators.
</p>

<p><i>[
Post Summit:
]</i></p>


<blockquote>
Recommend Tentatively Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
In 20.5.1 [tuple.general] and 20.5.2.5 [tuple.rel] change:
</p>

<blockquote><pre>template&lt;class... TTypes, class... UTypes&gt;
  requires <del>EqualityComparable</del><ins>HasEqualTo</ins>&lt;TTypes, UTypes&gt;...
  bool operator==(const tuple&lt;TTypes...&gt;&amp;, const tuple&lt;UTypes...&gt;&amp;);

template&lt;class... TTypes, class... UTypes&gt;
  requires <del>LessThanComparable</del><ins>HasLess</ins>&lt;TTypes, UTypes&gt;... <ins>&amp;&amp; HasLess&lt;UTypes, TTypes&gt;...</ins>
  bool operator&lt;(const tuple&lt;TTypes...&gt;&amp;, const tuple&lt;UTypes...&gt;&amp;);

template&lt;class... TTypes, class... UTypes&gt;
  requires <del>EqualityComparable</del><ins>HasEqualTo</ins>&lt;TTypes, UTypes&gt;...
  bool operator!=(const tuple&lt;TTypes...&gt;&amp;, const tuple&lt;UTypes...&gt;&amp;);

template&lt;class... TTypes, class... UTypes&gt;
  requires <del>LessThanComparable</del><ins>HasLess</ins>&lt;<del>U</del><ins>T</ins>Types, <del>T</del><ins>U</ins>Types&gt;... <ins>&amp;&amp; HasLess&lt;UTypes, TTypes&gt;...</ins>
  bool operator&gt;(const tuple&lt;TTypes...&gt;&amp;, const tuple&lt;UTypes...&gt;&amp;);

template&lt;class... TTypes, class... UTypes&gt;
  requires <del>LessThanComparable</del><ins>HasLess</ins>&lt;<del>U</del><ins>T</ins>Types, <del>T</del><ins>U</ins>Types&gt;... <ins>&amp;&amp; HasLess&lt;UTypes, TTypes&gt;...</ins>
  bool operator&lt;=(const tuple&lt;TTypes...&gt;&amp;, const tuple&lt;UTypes...&gt;&amp;);

template&lt;class... TTypes, class... UTypes&gt;
  requires <del>LessThanComparable</del><ins>HasLess</ins>&lt;TTypes, UTypes&gt;... <ins>&amp;&amp; HasLess&lt;UTypes, TTypes&gt;...</ins>
  bool operator&gt;=(const tuple&lt;TTypes...&gt;&amp;, const tuple&lt;UTypes...&gt;&amp;);
</pre></blockquote>





<hr>
<h3><a name="929"></a>929. Thread constructor</h3>
<p><b>Section:</b> 30.3.1.2 [thread.thread.constr] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Review">Review</a>
 <b>Submitter:</b> Anthony Williams <b>Opened:</b> 2008-10-23  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#thread.thread.constr">active issues</a> in [thread.thread.constr].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.thread.constr">issues</a> in [thread.thread.constr].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Review">Review</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 323</b></p>

<p>
The <tt>thread</tt> constructor for starting a new thread with a function and
arguments is overly constrained by the signature requiring rvalue
references for <tt>func</tt> and <tt>args</tt> and the <tt>CopyConstructible</tt> requirements
for the elements of <tt>args</tt>. The use of an rvalue reference for the
function restricts the potential use of a plain function name, since
the type of the bound parameter will be deduced to be a function
reference and decay to pointer-to-function will not happen. This
therefore complicates the implementation in order to handle a simple
case. Furthermore, the use of rvalue references for args prevents the
array to pointer decay. Since arrays are not <tt>CopyConstructible</tt> or even
<tt>MoveConstructible</tt>, this essentially prevents the passing of arrays as
parameters. In particular it prevents the passing of string literals.
Consequently a simple case such as
</p>

<blockquote><pre>void f(const char*);
std::thread t(f,"hello");
</pre></blockquote>

<p>
is ill-formed since the type of the string literal is <tt>const char[6]</tt>.
</p>

<p>
By changing the signature to take all parameters by value we can
eliminate the <tt>CopyConstructible</tt> requirement and permit the use of
arrays, as the parameter passing semantics will cause the necessary
array-to-pointer decay. They will also cause the function name to
decay to a pointer to function and allow the implementation to handle
functions and function objects identically.
</p>

<p>
The new signature of the <tt>thread</tt> constructor for a function and
arguments is thus:
</p>

<blockquote><pre>template&lt;typename F,typename... Args&gt;
thread(F,Args... args);
</pre></blockquote>

<p>
Since the parameter pack <tt>Args</tt> can be empty, the single-parameter
constructor that takes just a function by value is now redundant.
</p>

<p><i>[
Howard adds:
]</i></p>


<blockquote>
<p>
I agree with everything Anthony says in this issue.  However I believe we
can optimize in such a way as to get the pass-by-value behavior with the
pass-by-rvalue-ref performance.  The performance difference is that the latter
removes a <tt>move</tt> when passing in an lvalue.
</p>

<p>
This circumstance is very analogous to <tt>make_pair</tt> (20.3.3 [pairs])
where we started with passing by const reference, changed to pass by value to
get pointer decay, and then changed to pass by rvalue reference, but modified with
<tt>decay&lt;T&gt;</tt> to retain the pass-by-value behavior.  If we were to
apply the same solution here it would look like:
</p>

<blockquote><pre><del>template &lt;class F&gt; explicit thread(F f);</del>
template &lt;class F, class ...Args&gt; thread(F&amp;&amp; f, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-4- <i>Requires:</i> <tt>F</tt> and each <tt>Ti</tt> in <tt>Args</tt> shall be <del><tt>CopyConstructible</tt>
if an lvalue and otherwise</del> <tt>MoveConstructible</tt>.
<tt><i>INVOKE</i>(f, w1, w2, ..., wN)</tt> (20.7.2 [func.require]) shall be a valid expression for
some values <tt>w1, w2, ... , wN,</tt> where <tt>N == sizeof...(Args)</tt>.
</p>
<p>
-5- <i>Effects:</i> Constructs an object of type <tt>thread</tt>
<del>and executes <tt><i>INVOKE</i>(f, t1, t2, ..., tN)</tt> in a new
thread of execution, where <tt>t1, t2, ..., tN</tt> are the values in <tt>args...</tt></del>.
<ins>Constructs
the following objects in memory which is accessible to a new thread of execution
as if:</ins>
</p>
<blockquote><pre><ins>typename decay&lt;F&gt;::type g(std::forward&lt;F&gt;(f));</ins>
<ins>tuple&lt;typename decay&lt;Args&gt;::type...&gt; w(std::forward&lt;Args&gt;(args)...);</ins>
</pre></blockquote>
<p>
<ins>The new thread of
execution executes <tt><i>INVOKE</i>(g, wi...)</tt> where the <tt>wi...</tt> refers
to the elements stored in the <tt>tuple w</tt>.</ins>
Any return value from <tt>g</tt> is ignored.
<del>If <tt>f</tt> terminates with an uncaught exception, <tt>std::terminate()</tt> shall be called.</del>
<ins>If the evaluation of <tt><i>INVOKE</i>(g,  wi...)</tt> terminates
with an uncaught exception, <tt>std::terminate()</tt> shall be called [<i>Note:</i>
<tt>std::terminate()</tt> could be called before entering <tt>g</tt>. -- <i>end note</i>]. Any
exception thrown before the evaluation of <tt><i>INVOKE</i></tt> has started shall be
catchable in the calling thread.</ins>
</p>
</blockquote>
</blockquote>

<p>
Text referring to when <tt>terminate()</tt> is called was contributed by Ganesh.
</p>

</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution,
but would like the final sentence to be reworded
since "catchable" is not a term of art (and is used nowhere else).
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Modify the class definition of <tt>std::thread</tt> in 30.3.1 [thread.thread.class] to remove the
following signature:
</p>

<blockquote><pre><del>template&lt;class F&gt; explicit thread(F f);</del>
template&lt;class F, class ... Args&gt; <ins>explicit</ins> thread(F&amp;&amp; f, Args&amp;&amp; ... args);
</pre></blockquote>

<p>
Modify 30.3.1.2 [thread.thread.constr] to replace the constructors prior to paragraph 4 with
the single constructor as above. Replace paragraph 4 - 6 with the
following:
</p>

<blockquote>
<p>
-4- <i>Requires:</i> <tt>F</tt> and each <tt>Ti</tt> in <tt>Args</tt> shall be <del><tt>CopyConstructible</tt>
if an lvalue and otherwise</del> <tt>MoveConstructible</tt>.
<tt><i>INVOKE</i>(f, w1, w2, ..., wN)</tt> (20.7.2 [func.require]) shall be a valid expression for
some values <tt>w1, w2, ... , wN,</tt> where <tt>N == sizeof...(Args)</tt>.
</p>
<p>
-5- <i>Effects:</i> Constructs an object of type <tt>thread</tt>
<del>and executes <tt><i>INVOKE</i>(f, t1, t2, ..., tN)</tt> in a new
thread of execution, where <tt>t1, t2, ..., tN</tt> are the values in <tt>args...</tt></del>.
<ins>Constructs
the following objects:</ins>
</p>
<blockquote><pre><ins>typename decay&lt;F&gt;::type g(std::forward&lt;F&gt;(f));</ins>
<ins>tuple&lt;typename decay&lt;Args&gt;::type...&gt; w(std::forward&lt;Args&gt;(args)...);</ins>
</pre></blockquote>
<p>
<ins>and executes <tt><i>INVOKE</i>(g, wi...)</tt> in a new thread of execution.
These objects shall be destroyed when the new thread of execution completes.</ins>
Any return value from <tt>g</tt> is ignored.
<del>If <tt>f</tt> terminates with an uncaught exception, <tt>std::terminate()</tt> shall be called.</del>
<ins>If the evaluation of <tt><i>INVOKE</i>(g,  wi...)</tt> terminates
with an uncaught exception, <tt>std::terminate()</tt> shall be called [<i>Note:</i>
<tt>std::terminate()</tt> could be called before entering <tt>g</tt>. -- <i>end note</i>]. Any
exception thrown before the evaluation of <tt><i>INVOKE</i></tt> has started shall be
catchable in the calling thread.</ins>
</p>
<p>
-6- <i>Synchronization:</i> The invocation of the constructor <i>happens before</i> the
invocation of <del><tt>f</tt></del> <ins><tt>g</tt></ins>.
</p>
</blockquote>






<hr>
<h3><a name="930"></a>930. Access to std::array data as built-in array type</h3>
<p><b>Section:</b> 23.3.1 [array] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Niels Dekker <b>Opened:</b> 2008-11-17  <b>Last modified:</b> 2009-06-01</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#array">active issues</a> in [array].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#array">issues</a> in [array].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
The Working Draft (N2798) allows access to the elements of
<tt>std::array</tt> by its <tt>data()</tt> member function:
</p>

<blockquote>

<h5>23.2.1.4 array::data [array.data]</h5>
<pre> T *data();
 const T *data() const;
</pre>
<ol><li>
 Returns: elems.
</li></ol>
</blockquote>

<p>
Unfortunately, the result of <tt>std::array::data()</tt> cannot be bound
to a reference to a built-in array of the type of <tt>array::elems</tt>.
And <tt>std::array</tt> provides no other way to get a reference to
<tt>array::elems</tt>. 
This hampers the use of <tt>std::array</tt>, for example when trying to
pass its data to a C style API function:
</p>

<pre> // Some C style API function. 
 void set_path( char (*)[MAX_PATH] );

 std::array&lt;char,MAX_PATH&gt; path;
 set_path( path.data() );  // error
 set_path( &amp;(path.data()) );  // error
</pre>

 <p>
Another example, trying to pass the array data to an instance of another
C++ class:
</p>

<pre> // Represents a 3-D point in space.
 class three_d_point {
 public:
   explicit three_d_point(const double (&amp;)[3]); 
 };

 const std::array&lt;double,3&gt; coordinates = { 0, 1, 2 };
 three_d_point point1( coordinates.data() );  // error.
 three_d_point point2( *(coordinates.data()) );  // error.
</pre>

<p>
A user might be tempted to use <tt>std::array::elems</tt> instead, but
doing so isn't recommended, because <tt>std::array::elems</tt> is "for
exposition only".  Note that Boost.Array users might already use
<tt>boost::array::elems</tt>, as its documentation doesn't explicitly
state that <tt>boost::array::elems</tt> is for exposition only:
http://www.boost.org/doc/libs/1_36_0/doc/html/boost/array.html
</p>
<p>
I can think of three options to solve this issue:
</p>
<ol><li>
Remove the words "exposition only" from the definition of
<tt>std::array::elems</tt>, as well as the note saying that "elems is
shown for exposition only."
</li><li>
Change the signature of <tt>std::array::data()</tt>, so that it would
return a reference to the built-in array, instead of a pointer to its
first element.
</li><li>
Add extra member functions, returning a reference to the built-in array.
</li></ol>
<p>
Lawrence Crowl wrote me that it might be better to leave
<tt>std::array::elems</tt> "for exposition only", to allow alternate
representations to allocate the array data dynamically.  This might be
of interest to the embedded community, having to deal with very limited
stack sizes.
</p>
<p>
The second option, changing the return type of
<tt>std::array::data()</tt>, would break backward compatible to current
Boost and TR1 implementations, as well as to the other contiguous
container (<tt>vector</tt> and <tt>string</tt>) in a very subtle way.
For example, the following call to <tt>std::swap</tt> currently swap two
locally declared pointers <tt>(data1, data2)</tt>, for any container
type <tt>T</tt> that has a <tt>data()</tt> member function. When
<tt>std::array::data()</tt> is changed to return a reference, the
<tt>std::swap</tt> call may swap the container elements instead.
</p>

<pre> template &lt;typename T&gt;
 void func(T&amp; container1, T&amp; container2)
 {
   // Are data1 and data2 pointers or references?
   auto data1 = container1.data();
   auto data2 = container2.data();

   // Will this swap two local pointers, or all container elements?
   std::swap(data1, data2);
 }
</pre>

<p>
The following concept is currently satisfied by all contiguous
containers, but it no longer is for <tt>std::array</tt>, when
<tt>array::data()</tt>
is changed to return a reference (tested on ConceptGCC Alpha 7):
</p>

<pre> auto concept ContiguousContainerConcept&lt;typename T&gt;
 {
   typename value_type = typename T::value_type;
   const value_type * T::data() const;
 }
</pre>

<p>
Still it's worth considering having <tt>std::array::data()</tt> return a
reference, because it might be the most intuitive option, from a user's
point of view.  Nicolai Josuttis (who wrote <tt>boost::array</tt>)
mailed me that he very much prefers this option.
</p>
<p>
Note that for this option, the definition of <tt>data()</tt> would also
need to be revised for zero-sized arrays, as its return type cannot be a
reference to a zero-sized built-in array.  Regarding zero-sized array,
<tt>data()</tt> could throw an exception.  Or there could be a partial
specialization of <tt>std::array</tt> where <tt>data()</tt> returns
<tt>T*</tt> or gets removed.
</p>
<p>
Personally I prefer the third option, adding a new member function to
<tt>std::array</tt>, overloaded for const and non-const access,
returning a reference to the built-in array, to avoid those compatible
issues. I'd propose naming the function <tt>std::array::c_array()</tt>,
which sounds intuitive to me. Note that <tt>boost::array</tt> already
has a <tt>c_array()</tt> member, returning a pointer, but Nicolai told
me that this one is only there for historical reasons. (Otherwise a name
like <tt>std::array::native_array()</tt> or
<tt>std::array::builtin_array()</tt> would also be fine with me.) 
According to my proposed resolution, a zero-sized <tt>std::array</tt> does not need
to have <tt>c_array()</tt>, while it is still required to have
<tt>data()</tt> functions.
</p>

<p><i>[
Post Summit:
]</i></p>


<blockquote>

<p>
Alisdair: Don't like p4 suggesting implementation-defined behaviour.
</p>
<p>
Walter: What about an explicit conversion operator, instead of adding
the new member function?
</p>
<p>
Alisdair: Noodling about:
</p>
<blockquote><pre>template&lt;size_t N, ValueType T&gt;
struct array
{
  T elems[N];

// fantasy code starts here

// crazy decltype version for grins only
//requires True&lt;(N&gt;0)&gt;
//explict operator decltype(elems) &amp; () { return elems; }

// conversion to lvalue ref
requires True&lt;(N&gt;0)&gt;
explict operator T(&amp;)[N] () &amp; { return elems; }

// conversion to const lvalue ref
requires True&lt;(N&gt;0)&gt;
explict operator const T(&amp;)[N] () const &amp; { return elems; }

// conversion to rvalue ref using ref qualifiers
requires True&lt;(N&gt;0)&gt;
explict operator T(&amp;&amp;)[N] () &amp;&amp; { return elems; }

// fantasy code ends here

explicit operator bool() { return true; }
};
</pre></blockquote>

<p>
This seems legal but odd. Jason Merrill says currently a CWG issue 613
on the non-static data member that fixes the error that current G++
gives for the non-explicit, non-conceptualized version of this. Verdict
from human compiler: seems legal.
</p>
<p>
Some grumbling about zero-sized arrays being allowed and supported.
</p>
<p>
Walter: Would this address the issue? Are we inclined to go this route?
</p>
<p>
Alan: What would usage look like?
</p>
<blockquote><pre>// 3-d point in space
struct three_d_point
{
  explicit three_d_point(const double (&amp;)[3]);
};

void sink(double*);

const std::array&lt;double, 3&gt; coordinates = { 0, 1, 2 };
three_d_point point1( coordinates.data() ); //error
three_d_point point2( *(coordinates.data()) ); // error
three_d_point point3( coordinates ); // yay!

sink(cooridinates); // error, no conversion
</pre></blockquote>

<p>
Recommended Open with new wording. Take the required clause and add the
explicit conversion operators, not have a <tt>typedef</tt>. At issue still is use
<tt>decltype</tt> or use <tt>T[N]</tt>. In favour of using <tt>T[N]</tt>, even though use of
<tt>decltype</tt> is specially clever.
</p>

</blockquote>

<p><i>[
Post Summit, further discussion in the thread starting with c++std-lib-23215.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
Add to the template definition of array, 23.3.1 [array]/3:
</p>

<blockquote>
<pre><ins>
typedef T c_array_type[N];
c_array_type &amp; c_array() &amp;;
c_array_type &amp;&amp; c_array() &amp;&amp;;
const c_array_type &amp; c_array() const &amp;;
</ins>
</pre>
</blockquote>

<p>
Add the following subsection to 23.3.1 [array], after 23.3.1.4 [array.data]:
</p>

<blockquote>
<h5><ins>23.2.1.5 array::c_array [array.c_array]</ins></h5>
    <pre><ins>
c_array_type &amp; c_array() &amp;;
c_array_type &amp;&amp; c_array() &amp;&amp;;
const c_array_type &amp; c_array() const &amp;;
</ins></pre>
<blockquote>
<p>
<ins><i>Returns:</i> <tt>elems</tt>.</ins>
</p>
</blockquote>

</blockquote>

<p>
Add to Zero sized arrays 23.3.1.6 [array.zero]:
</p>

<blockquote>
4. The presence of <tt>c_array_type</tt> and <tt>c_array()</tt> and
their semantics are implementation defined, for a zero-sized array.
</blockquote>





<hr>
<h3><a name="931"></a>931. type trait <tt>extent&lt;T, I&gt;</tt></h3>
<p><b>Section:</b> 20.6.4.3 [meta.unary.prop] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Yechezkel Mett <b>Opened:</b> 2008-11-04  <b>Last modified:</b> 2009-03-09</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#meta.unary.prop">active issues</a> in [meta.unary.prop].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#meta.unary.prop">issues</a> in [meta.unary.prop].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The draft (N2798) says in 20.6.4.3 [meta.unary.prop] Table 44: 
</p>
<blockquote>
<table border="1">
<caption>Table 44 -- Type property queries</caption>
<tbody><tr><th>Template</th><th>Value</th></tr>
<tr>
<td>
<tt>template &lt;class T, unsigned I = 0&gt; struct extent;</tt>
</td>
<td>
If <tt>T</tt> is not an array type (8.3.4), or if it has rank less than
<tt>I</tt>, or if <tt>I</tt> is 0
and <tt>T</tt> has type "array of unknown bound of <tt>U</tt>", then 0; otherwise, the
size of the <tt>I</tt>'th dimension of <tt>T</tt>
</td>
</tr>
</tbody></table>
</blockquote>

<p>
Firstly it isn't clear from the wording if <tt>I</tt> is 0-based or 1-based 
("the <tt>I</tt>'th dimension" sort of implies 1-based). From the following 
example it is clear that the intent is 0-based, in which case it 
should say "or if it has rank less than or equal to <tt>I</tt>".
</p>
<p>
Sanity check:
</p>
<p>
The example says <tt>assert((extent&lt;int[2], 1&gt;::value) == 0);</tt>
</p>
<p>
Here the rank is 1 and <tt>I</tt> is 1, but the desired result is 0.
</p>

<p><i>[
Post Summit:
]</i></p>


<blockquote>
<p>
Do not use "size" or "value", use "bound". Also, move the
cross-reference to 8.3.4 to just after "bound".
</p>
<p>
Recommend Tentatively Ready.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
In Table 44 of 20.6.4.3 [meta.unary.prop], third row, column "Value",
change the cell content:
</p>

<blockquote>
<table border="1">
<caption>Table 44 -- Type property queries</caption>
<tbody><tr><th>Template</th><th>Value</th></tr>
<tr>
<td>
<tt>template &lt;class T, unsigned I = 0&gt; struct extent;</tt>
</td>
<td>
If <tt>T</tt> is not an array type <del>(8.3.4)</del>, or if it has rank less than
<ins> or equal to</ins> <tt>I</tt>, or if <tt>I</tt> is 0
and <tt>T</tt> has type "array of unknown bound of <tt>U</tt>", then 0; otherwise, the
<del>size</del> <ins>bound (8.3.4)</ins> of the <tt>I</tt>'th dimension of <tt>T</tt><ins>,
where indexing of <tt>I</tt> is zero-based.</ins>
</td>
</tr>
</tbody></table>
</blockquote>

<p><i>[
Wording supplied by Daniel.
]</i></p>







<hr>
<h3><a name="932"></a>932. <tt>unique_ptr(pointer p)</tt> for pointer deleter types</h3>
<p><b>Section:</b> 20.8.12.2.1 [unique.ptr.single.ctor] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2008-11-26  <b>Last modified:</b> 2009-03-12</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#unique.ptr.single.ctor">active issues</a> in [unique.ptr.single.ctor].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#unique.ptr.single.ctor">issues</a> in [unique.ptr.single.ctor].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses US 79</b></p>

<p>
20.8.12.2.1 [unique.ptr.single.ctor]/5 no longer requires for <tt>D</tt>
not to be a pointer type.  I believe this restriction was accidently removed
when we relaxed the completeness reuqirements on <tt>T</tt>. The restriction
needs to be put back in.  Otherwise we have a run time failure that could
have been caught at compile time:
</p>

<blockquote><pre>{
unique_ptr&lt;int, void(*)(void*)&gt; p1(malloc(sizeof(int)));  <font color="#c80000">// should not compile</font>
}  <font color="#c80000">// p1.~unique_ptr() dereferences a null function pointer</font>
unique_ptr&lt;int, void(*)(void*)&gt; p2(malloc(sizeof(int)), free);  <font color="#c80000">// ok</font>
</pre></blockquote>

<p><i>[
Post Summit:
]</i></p>


<blockquote>
Recommend Tentatively Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 20.8.12.2.1 [unique.ptr.single.ctor]/5:
</p>

<blockquote><pre>unique_ptr(pointer p);
</pre>
<blockquote>
<i>Requires:</i> <ins><tt>D</tt> shall not be a pointer type (diagnostic required).</ins>
<tt>D</tt> shall be default constructible, and that construction shall not throw an exception.
</blockquote>
</blockquote>





<hr>
<h3><a name="933"></a>933. Unique_ptr defect</h3>
<p><b>Section:</b> 20.8.12.2.5 [unique.ptr.single.modifiers] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2008-11-27  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#unique.ptr.single.modifiers">active issues</a> in [unique.ptr.single.modifiers].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#unique.ptr.single.modifiers">issues</a> in [unique.ptr.single.modifiers].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
If we are supporting stateful deleters, we need an overload for
<tt>reset</tt> that
takes a deleter as well.
</p>

<blockquote><pre>void reset( pointer p, deleter_type d);
</pre></blockquote>

<p>
We probably need two overloads to support move-only deleters, and
this
sounds uncomfortably like the two constructors I have been ignoring
for
now...
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Howard comments that we have the functionality via move-assigment.
</p>
<p>
Move to Open.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="934"></a>934. <tt>duration</tt> is missing <tt>operator%</tt></h3>
<p><b>Section:</b> 20.9.3 [time.duration] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Terry Golubiewski <b>Opened:</b> 2008-11-30  <b>Last modified:</b> 2009-05-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses US 81</b></p>

<p>
<tt>duration</tt> is missing <tt>operator%</tt>.  This operator is convenient
for computing where in a time frame a given <tt>duration</tt> lies.  A
motivating example is converting a <tt>duration</tt> into a "broken-down"
time duration such as hours::minutes::seconds:
</p>

<blockquote><pre>class ClockTime
{
    typedef std::chrono::hours hours;
    typedef std::chrono::minutes minutes;
    typedef std::chrono::seconds seconds;
public:
    hours hours_;
    minutes minutes_;
    seconds seconds_;

    template &lt;class Rep, class Period&gt;
      explicit ClockTime(const std::chrono::duration&lt;Rep, Period&gt;&amp; d)
        : hours_  (std::chrono::duration_cast&lt;hours&gt;  (d)),
          minutes_(std::chrono::duration_cast&lt;minutes&gt;(d % hours(1))),
          seconds_(std::chrono::duration_cast&lt;seconds&gt;(d % minutes(1)))
          {}
};
</pre></blockquote>

<p><i>[
Summit:
]</i></p>


<blockquote>
Agree except that there is a typo in the proposed resolution. The member
operators should be operator%=.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution.
Move to Tentatively Ready.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Add to the synopsis in 20.9 [time]:
</p>

<blockquote><pre>template &lt;class Rep1, class Period, class Rep2&gt;
  duration&lt;typename common_type&lt;Rep1, Rep2&gt;::type, Period&gt;
  operator%(const duration&lt;Rep1, Period&gt;&amp; d, const Rep2&amp; s);
template &lt;class Rep1, class Period1, class Rep2, class Period2&gt;
  typename common_type&lt;duration&lt;Rep1, Period1&gt;, duration&lt;Rep2, Period2&gt;&gt;::type
  operator%(const duration&lt;Rep1, Period1&gt;&amp; lhs, const duration&lt;Rep2, Period2&gt;&amp; rhs);
</pre></blockquote>

<p>
Add to the synopsis of <tt>duration</tt> in 20.9.3 [time.duration]:
</p>

<blockquote><pre>template &lt;class Rep, class Period = ratio&lt;1&gt;&gt;
class duration {
public:
  ...
  <ins>duration&amp; operator%=(const rep&amp; rhs);</ins>
  <ins>duration&amp; operator%=(const duration&amp; d);</ins>
  ...
};
</pre></blockquote>

<p>
Add to 20.9.3.3 [time.duration.arithmetic]:
</p>

<blockquote>
<pre>duration&amp; operator%=(const rep&amp; rhs);
</pre>
<blockquote>
<p>
<i>Effects:</i> <tt>rep_ %= rhs</tt>.
</p>
<p>
<i>Returns:</i> <tt>*this</tt>.
</p>
</blockquote>

<pre>duration&amp; operator%=(const duration&amp; d);
</pre>
<blockquote>
<p>
<i>Effects:</i> <tt>rep_ %= d.count()</tt>.
</p>
<p>
<i>Returns:</i> <tt>*this</tt>.
</p>
</blockquote>
</blockquote>

<p>
Add to 20.9.3.5 [time.duration.nonmember]:
</p>

<blockquote>

<pre>template &lt;class Rep1, class Period, class Rep2&gt;
  duration&lt;typename common_type&lt;Rep1, Rep2&gt;::type, Period&gt;
  operator%(const duration&lt;Rep1, Period&gt;&amp; d, const Rep2&amp; s);
</pre>
<blockquote>
<p>
<i>Requires:</i> <tt>Rep2</tt> shall be implicitly convertible to <tt>CR(Rep1, Rep2)</tt> and
<tt>Rep2</tt> shall not be an instantiation of <tt>duration</tt>. Diagnostic required.
</p>
<p>
<i>Returns:</i> <tt>duration&lt;CR, Period&gt;(d) %= s</tt>.
</p>
</blockquote>

<pre>template &lt;class Rep1, class Period1, class Rep2, class Period2&gt;
  typename common_type&lt;duration&lt;Rep1, Period1&gt;, duration&lt;Rep2, Period2&gt;&gt;::type
  operator%(const duration&lt;Rep1, Period1&gt;&amp; lhs, const duration&lt;Rep2, Period2&gt;&amp; rhs);
</pre>
<blockquote>
<p>
<i>Returns:</i> <tt>common_type&lt;duration&lt;Rep1, Period1&gt;, duration&lt;Rep2, Period2&gt;&gt;::type(lhs) %= rhs</tt>.
</p>
</blockquote>

</blockquote>






<hr>
<h3><a name="935"></a>935. clock error handling needs to be specified</h3>
<p><b>Section:</b> 20.9.5 [time.clock] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Beman Dawes <b>Opened:</b> 2008-11-24  <b>Last modified:</b> 2009-05-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Each of the three clocks specified in Clocks 20.9.5 [time.clock]
provides the member function:
</p>

<blockquote><pre>static time_point now();
</pre></blockquote>

<p>
The semantics specified by Clock requirements 20.9.1 [time.clock.req]
make no mention of error handling. Thus the function may throw <tt>bad_alloc</tt>
or an implementation-defined exception (17.6.4.10 [res.on.exception.handling]
paragraph 4).
</p>

<p>
Some implementations of these functions on POSIX, Windows, and
presumably on other operating systems, may fail in ways only detectable
at runtime. Some failures on Windows are due to supporting chipset
errata and can even occur after successful calls to a clock's <tt>now()</tt>
function.
</p>

<p>
These functions are used in cases where exceptions are not appropriate
or where the specifics of the exception or cause of error need to be
available to the user. See
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2828.html">N2828</a>,
<i>Library Support for hybrid error
handling (Rev 1)</i>, for more specific discussion of use cases. Thus some change in
the interface of now is required.
</p>

<p>
The proposed resolution has been implemented in the Boost version of the
chrono library. No problems were encountered.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We recommend this issue be deferred until the next Committee Draft
has been issued and the prerequisite paper has been accepted.
</p>
<p>
Move to Open.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Accept the proposed wording of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2828.html">N2828</a>,
<i>Library Support for hybrid error handling (Rev 1)</i>.
</p>

<p>
Change Clock requirements 20.9.1 [time.clock.req] as indicated:
</p>

<blockquote>
<p>
-2- In Table 55 <tt>C1</tt> and <tt>C2</tt> denote clock types. <tt>t1</tt> and
<tt>t2</tt> are values returned by <tt>C1::now()</tt> where the call 
returning <tt>t1</tt> happens before (1.10) the call returning <tt>t2</tt> and
both of these calls happen before <tt>C1::time_point::max()</tt>.
<ins><tt>ec</tt> denotes an object of type <tt>error_code</tt> 
(19.5.2.2 [syserr.errcode.overview]).</ins>
</p>

<table border="1">
<caption>Table 55 -- Clock requirements</caption>
<tbody><tr>
<th>Expression</th><th>Return type</th><th>Operational semantics</th>
</tr>

<tr>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>

<tr>
<td><tt>C1::now()</tt></td>
<td><tt>C1::time_point</tt></td>
<td>Returns a <tt>time_point</tt> object representing the current point in time.
</td>
</tr>

<tr>
<td><tt><ins>C1::now(ec)</ins></tt></td>
<td><tt><ins>C1::time_point</ins></tt></td>
<td><ins>Returns a <tt>time_point</tt> object representing the current point in time.</ins>
</td>
</tr>
</tbody></table>
</blockquote>

<p>
Change Class system_clock 20.9.5.1 [time.clock.system] as indicated:
</p>

<blockquote><pre>static time_point now(<ins>error_code&amp; ec=throws()</ins>);
</pre></blockquote>

<p>
Change Class monotonic_clock 20.9.5.2 [time.clock.monotonic] as indicated:
</p>

<blockquote><pre>static time_point now(<ins>error_code&amp; ec=throws()</ins>);
</pre></blockquote>

<p>
Change Class high_resolution_clock 20.9.5.3 [time.clock.hires] as indicated:
</p>

<blockquote><pre>static time_point now(<ins>error_code&amp; ec=throws()</ins>);
</pre></blockquote>






<hr>
<h3><a name="936"></a>936. Mutex type overspecified</h3>
<p><b>Section:</b> 30.4.1 [thread.mutex.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2008-12-05  <b>Last modified:</b> 2009-03-22</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#thread.mutex.requirements">active issues</a> in [thread.mutex.requirements].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.mutex.requirements">issues</a> in [thread.mutex.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
30.4.1 [thread.mutex.requirements] describes the requirements for a type to be
a "Mutex type". A Mutex type can be used as the template argument for
the <tt>Lock</tt> type that's passed to <tt>condition_variable_any::wait</tt> (although
<tt>Lock</tt> seems like the wrong name here, since <tt>Lock</tt> is given a different
formal meaning in 30.4.3 [thread.lock]) and, although the WD doesn't quite say
so, as the template argument for <tt>lock_guard</tt> and <tt>unique_lock</tt>.
</p>

<p>
The requirements for a Mutex type include:
</p>

<ul>
<li>
<tt>m.lock()</tt> shall be well-formed and have [described] semantics, including a return type of <tt>void</tt>.
</li>
<li>
<tt>m.try_lock()</tt> shall be well-formed and have [described] semantics, including a return type of <tt>bool</tt>.
</li>
<li>
<tt>m.unlock()</tt> shall be well-formed and have [described] semantics, including a return type of <tt>void</tt>.
</li>
</ul>

<p>
Also, a Mutex type "shall not be copyable nor movable".
</p>

<p>
The latter requirement seems completely irrelevant, and the three
requirements on return types are tighter than they need to be. For
example, there's no reason that <tt>lock_guard</tt> can't be instantiated with a
type that's copyable. The rule is, in fact, that <tt>lock_guard</tt>, etc. won't
try to copy objects of that type. That's a constraint on locks, not on
mutexes. Similarly, the requirements for <tt>void</tt> return types are
unnecessary; the rule is, in fact, that <tt>lock_guard</tt>, etc. won't use any
returned value. And with the return type of <tt>bool</tt>, the requirement should
be that the return type is convertible to <tt>bool</tt>.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
<p>
Move to open. Related to conceptualization and should probably be tackled as part of that.
</p>
<ul>
<li>
The intention is not only to place a constraint on what types such as
<tt>lock_guard</tt> may do with mutex types, but on what any code, including user
code, may do with mutex types. Thus the constraints as they are apply to
the mutex types themselves, not the current users of mutex types in the
standard.
</li>
<li>
This is a low priority issue; the wording as it is may be overly
restrictive but this may not be a real issue.
</li>
</ul>
</blockquote>

<p><i>[
Post Summit Anthony adds:
]</i></p>


<blockquote>
<p>
Section 30.4.1 [thread.mutex.requirements] conflates the
requirements on a generic Mutex type (including user-supplied mutexes)
with the requirements placed on the standard-supplied mutex types in an
attempt to group everything together and save space.
</p>
<p>
When applying concepts to chapter 30, I suggest that the concepts
<tt>Lockable</tt> and <tt>TimedLockable</tt> embody the requirements for
*use* of a mutex type as required by
<tt>unique_lock/lock_guard/condition_variable_any</tt>. These should be
relaxed as Pete describes in the issue. The existing words in 30.4.1 [thread.mutex.requirements] are requirements on all of
<tt>std::mutex</tt>, <tt>std::timed_mutex</tt>,
<tt>std::recursive_mutex</tt> and <tt>std::recursive_timed_mutex</tt>,
and should be rephrased as such.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="938"></a>938. <tt>default_delete&lt;T[]&gt;::operator()</tt> should only accept <tt>T*</tt></h3>
<p><b>Section:</b> 20.8.12.1.2 [unique.ptr.dltr.dflt1] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2008-12-07  <b>Last modified:</b> 2009-05-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Consider:
</p>

<blockquote><pre>derived* p = new derived[3];
std::default_delete&lt;base[]&gt; d;
d(p);  <font color="#c80000">// should fail</font>
</pre></blockquote>

<p>
Currently the marked line is a run time failure.  We can make it a compile
time failure by "poisoning" <tt>op(U*)</tt>.
</p>

<p><i>[
Post Summit:
]</i></p>


<blockquote>
Recommend Review.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution.
Move to Tentatively Ready.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Add to 20.8.12.1.2 [unique.ptr.dltr.dflt1]:
</p>

<blockquote><pre>namespace std {
  template &lt;class T&gt; struct default_delete&lt;T[]&gt; {
    void operator()(T*) const;
  <ins>template &lt;class U&gt; void operator()(U*) const = delete;</ins>
};
}
</pre></blockquote>





<hr>
<h3><a name="939"></a>939. Problem with <tt>std::identity</tt> and reference-to-temporaries</h3>
<p><b>Section:</b> 20.7.6 [identity.operation] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Review">Review</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2008-12-11  <b>Last modified:</b> 2009-06-02</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Review">Review</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>std::identity</tt> takes an argument of type <tt>T const &amp;</tt>
and returns a result of <tt>T const &amp;</tt>.
</p>
<p>
Unfortunately, this signature will accept a value of type other than <tt>T</tt> that
is convertible-to-<tt>T</tt>, and then return a reference to the dead temporary.  The
constraint in the concepts version simply protects against returning
reference-to-<tt>void</tt>.
</p>
<p>
Solutions:
</p>
<blockquote>
<p>
i/  Return-by-value, potentially slicing bases and rejecting non-copyable
types
</p>
<p>
ii/ Provide an additional overload:
</p>
<blockquote><pre>template&lt; typename T &gt;
template operator( U &amp; ) = delete;
</pre></blockquote>
<p>
This seems closer on intent, but moves beyond the original motivation for
the operator, which is compatibility with existing (non-standard)
implementations.
</p>
<p>
iii/ Remove the <tt>operator()</tt> overload.  This restores the original definition
of the <tt>identity</tt>, although now effectively a type_trait rather than part of
the perfect forwarding protocol.
</p>
<p>
iv/ Remove <tt>std::identity</tt> completely; its original reason to exist is
replaced with the <tt>IdentityOf</tt> concept.
</p>
</blockquote>
<p>
My own preference is somewhere between (ii) and (iii) - although I stumbled
over the issue with a specific application hoping for resolution (i)!
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We dislike options i and iii, and option ii seems like overkill.
If we remove it (option iv), implementers can still provide it under a
different name.
</p>
<p>
Move to Open pending wording (from Alisdair) for option iv.
</p>
</blockquote>

<p><i>[
2009-05-23 Alisdair provided wording for option iv.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
Strike 20.2.1 [concept.transform] p3:
</p>

<blockquote>
<del>-4- <i>Note:</i> concept form of the identity type metafunction (20.7.6).</del>
</blockquote>

<p>
Strike from 20.7 [function.objects] p2:
</p>

<blockquote><pre><del>// 20.7.6, identity operation:</del>
<del>template &lt;IdentityOf T&gt; struct identity;</del>
</pre></blockquote>

<p>
Remove 20.7.6 [identity.operation] (whole subclause):
</p>

<blockquote>
<pre><del>template &lt;IdentityOf T&gt; struct identity {
  typedef T type;

  requires ReferentType&lt;T&gt;
     const T&amp; operator()(const T&amp; x) const;
};</del>

<del>requires ReferentType&lt;T&gt;
  const T&amp; operator()(const T&amp; x) const;</del>
</pre>
<blockquote>
<del>-1-  <i>Returns:</i> <tt>x</tt></del>
</blockquote>
</blockquote>






<hr>
<h3><a name="940"></a>940. <tt>std::distance</tt></h3>
<p><b>Section:</b> 24.4 [iterator.operations] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Thomas <b>Opened:</b> 2008-12-14  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#iterator.operations">active issues</a> in [iterator.operations].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#iterator.operations">issues</a> in [iterator.operations].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 270</b></p>

<p>
Regarding the <tt>std::distance</tt> - function, 24.4 [iterator.operations]
/ 4 says:
</p>
<blockquote>
Returns the
number of increments or decrements needed to get from first to last.
</blockquote>
<p>
This sentence is completely silent about the sign of the return value.
24.4 [iterator.operations] / 1 gives more information about the
underlying operations, but
again no inferences about the sign can be made.
Strictly speaking, that is taking that sentence literally, I think this
sentence even implies a positive return value in all cases, as the
number of increments or decrements is clearly a ratio scale variable,
with a natural zero bound.
</p>
<p>
Practically speaking, my implementations did what common sense and
knowledge based on pointer arithmetic forecasts, namely a positive sign
for increments (that is, going from <tt>first</tt> to <tt>last</tt> by <tt>operator++</tt>), and a
negative sign for decrements (going from <tt>first</tt> to <tt>last</tt> by <tt>operator--</tt>).
</p>
<p>
Here are my two questions:
</p>
<p>
First, is that paragraph supposed to be interpreted in the way what I
called 'common sense', that is negative sign for decrements ? I am
fairly sure that's the supposed behavior, but a double-check here in
this group can't hurt.
</p>
<p>
Second, is the present wording (2003 standard version - no idea about
the draft for the upcoming standard) worth an edit to make it a bit more
sensible, to mention the sign of the return value explicitly ?
</p>

<p><i>[
Daniel adds:
]</i></p>


<blockquote>
<p>
My first thought was that resolution <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#204">204</a> would already cover the
issue report, but it seems that current normative wording is in
contradiction to that resolution:
</p>

<p>
Referring to
<a href="" ref="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2798.pdf">N2798</a>,
24.4 [iterator.operations]/ p.4 says:
</p>

<blockquote>
<i>Effects:</i> Returns the number of increments or decrements needed to get
from <tt>first</tt> to <tt>last</tt>.
</blockquote>

<p>
IMO the part " or decrements" is in contradiction to p. 5 which says
</p>

<blockquote>
<i>Requires:</i> <tt>last</tt> shall be reachable from <tt>first</tt>.
</blockquote>

<p>
because "reachable" is defined in 24.2 [iterator.concepts]/7 as
</p>

<blockquote>
An iterator <tt>j</tt> is called reachable from an iterator <tt>i</tt> if and only if
there is a finite
sequence of applications of the expression <tt>++i</tt> that makes <tt>i == j</tt>.[..]
</blockquote>

<p>
Here is wording that would be consistent with this definition of "reachable":
</p>

<p>
Change 24.4 [iterator.operations] p4 as follows:
</p>

<blockquote>
<i>Effects:</i> Returns the number of increments <del>or decrements</del>
needed to get from <tt>first</tt> to <tt>last</tt>.
</blockquote>

</blockquote>

<p>
Thomas adds more discussion and an alternative view point
<a href="http://groups.google.com/group/comp.std.c++/browse_thread/thread/e8e46dcda0a5d797#">here</a>.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
The proposed wording below was verbally agreed to.  Howard provided.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Pete reports that a recent similar change has been made
for the <tt>advance()</tt> function.
</p>
<p>
We agree with the proposed resolution.
Move to Tentatively Ready.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 24.4 [iterator.operations]:
</p>

<blockquote>
<pre>template &lt;InputIterator Iter&gt;
  Iter::difference_type
  distance(Iter first, Iter last);
<del>template &lt;RandomAccessIterator Iter&gt;
  Iter::difference_type distance(Iter first, Iter last);</del>
</pre>

<blockquote>
<p>
-4- <i>Effects:</i> Returns the number of increments <del>or decrements</del>
needed to get from <tt>first</tt> to <tt>last</tt>.
</p>
<p>
-5- <i>Requires:</i> <tt>last</tt> shall be reachable from <tt>first</tt>.
</p>
</blockquote>

<pre><ins>template &lt;RandomAccessIterator Iter&gt;
  Iter::difference_type distance(Iter first, Iter last);</ins>
</pre>

<blockquote>
<p>
<ins>-6- <i>Effects:</i> Returns the number of increments or decrements
needed to get from <tt>first</tt> to <tt>last</tt>.</ins>
</p>
<p>
<ins>-7- <i>Requires:</i> <tt>last</tt> shall be reachable from <tt>first</tt>
or <tt>first</tt> shall be reachable from <tt>last</tt>.</ins>
</p>
</blockquote>


</blockquote>






<hr>
<h3><a name="941"></a>941. Ref-qualifiers for assignment operators</h3>
<p><b>Section:</b> 17 [library] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Niels Dekker <b>Opened:</b> 2008-12-18  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The assignment and equality operators <tt>=</tt> and <tt>==</tt> are easily confused, just
because of their visual similarity, and in this case a simple typo can cause
a serious bug. When the left side of an <tt>operator=</tt> is an rvalue, it's
highly unlikely that the assignment was intended by the programmer:
</p>
<blockquote><pre>if ( func() = value )  // Typical typo: == intended!
</pre></blockquote>
<p>
Built-in types don't support assignment to an rvalue, but unfortunately,
a lot of types provided by the Standard Library do.
</p>
<p>
Fortunately the language now offers a syntax to prevent a certain member
function from having an rvalue as <tt>*this</tt>: by adding a ref-qualifier (<tt>&amp;</tt>)
to the member function declaration.  Assignment operators are explicitly
mentioned as a use case of ref-qualifiers, in "Extending Move Semantics
To <tt>*this</tt> (Revision 1)",
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1821.htm">N1821</a> by Daveed
Vandevoorde and Bronek Kozicki
</p>
<p>
Hereby I would like to propose adding ref-qualifiers to all appropriate
assignment operators in the library.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Move to Open.
We recommend this be deferred until after the next Committee Draft.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
A proposed resolution is provided by the paper on this subject,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2819.html">N2819</a>,
<i>Ref-qualifiers for assignment operators of the Standard Library</i>
</p>





<hr>
<h3><a name="943"></a>943. <tt>ssize_t</tt> undefined</h3>
<p><b>Section:</b> 29.5.2 [atomics.types.address] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Holger Grund <b>Opened:</b> 2008-12-19  <b>Last modified:</b> 2009-05-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There is a row in "Table 122 - Atomics for standard typedef types"
in 29.5.1 [atomics.types.integral] with <tt>atomic_ssize_t</tt>
and <tt>ssize_t</tt>. Unless, I'm missing something <tt>ssize_t</tt>
is not defined by the standard.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Move to review. Proposed resolution: Remove the typedef. Note: ssize_t
is a POSIX type.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution.
Move to Tentatively Ready.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Remove the row containing <tt>ssize_t</tt> from Table 119
"Atomics for standard typedef types" in 29.5.2 [atomics.types.address].
</p>





<hr>
<h3><a name="944"></a>944. <tt>atomic&lt;bool&gt;</tt> derive from <tt>atomic_bool</tt>?</h3>
<p><b>Section:</b> 29.5.3 [atomics.types.generic] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Holger Grund <b>Opened:</b> 2008-12-19  <b>Last modified:</b> 2009-03-22</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#atomics.types.generic">issues</a> in [atomics.types.generic].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I think it's fairly obvious that <tt>atomic&lt;bool&gt;</tt> is supposed to be derived
from <tt>atomic_bool</tt> (and otherwise follow the <tt>atomic&lt;integral&gt;</tt> interface),
though I think the current wording doesn't support this. I raised this
point along with <tt>atomic&lt;floating-point&gt;</tt> privately with Herb and I seem
to recall it came up in the resulting discussion on this list. However,
I don't see anything on the current libs issue list mentioning this
problem.
</p>

<p>
29.5.3 [atomics.types.generic]/3 reads
</p>

<blockquote>
There are full specializations over the integral types on the atomic
class template. For each integral type integral in the second column of
table 121 or table 122, the specialization <tt>atomic&lt;integral&gt;</tt> shall be
publicly derived from the corresponding atomic integral type in the
first column of the table. These specializations shall have trivial
default constructors and trivial destructors.
</blockquote>

<p>
Table 121 does not include (<tt>atomic_bool</tt>, <tt>bool</tt>),
so that this should probably be mentioned explicitly in the quoted paragraph.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Move to open. Lawrence will draft a proposed resolution. Also, ask
Howard to fix the title.
</blockquote>

<p><i>[
Post Summit Anthony provided proposed wording.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
Replace paragraph 3 in 29.5.3 [atomics.types.generic] with
</p>

<blockquote>
-3- There are full specializations over the integral types on the <tt>atomic</tt>
class template. For each integral type <tt>integral</tt> in the second column of
table 121 or table 122, the specialization <tt>atomic&lt;integral&gt;</tt> shall be
publicly derived from the corresponding atomic integral type in the first
column of the table.
<ins>In addition, the specialization <tt>atomic&lt;bool&gt;</tt>
shall be publicly derived from <tt>atomic_bool</tt>.</ins>
These specializations shall have trivial default
constructors and trivial destructors.
</blockquote>





<hr>
<h3><a name="945"></a>945. <tt>system_clock::rep</tt> not specified</h3>
<p><b>Section:</b> 20.9.5.1 [time.clock.system] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">Tentatively NAD Editorial</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2008-12-19  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#time.clock.system">active issues</a> in [time.clock.system].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#time.clock.system">issues</a> in [time.clock.system].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20NAD%20Editorial">Tentatively NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 20.9.5.1 [time.clock.system], the declaration of <tt>system_clock::rep</tt> says "see
below", but there is nothing below that describes it.
</p>

<p><i>[
Howard adds:
]</i></p>


<blockquote>
<p>
This note refers to:
</p>

<blockquote>
-2- <tt>system_clock::duration::min() &lt; system_clock::duration::zero()</tt> shall be <tt>true</tt>.
</blockquote>

<p>
I.e. this is standardeze for "<tt>system_clock::rep</tt> is signed".
Perhaps an editorial note along the lines of:
</p>

<blockquote>
-2- <tt>system_clock::duration::min() &lt; system_clock::duration::zero()</tt>
shall be <tt>true</tt>. <ins>[<i>Note:</i> <tt>system_clock::rep</tt> shall be signed. <i>-- end note</i>].</ins>
</blockquote>

<p>
?
</p>

</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the direction of the proposed resolution.
Move to NAD Editorial.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add a note to 20.9.5.1 [time.clock.system], p2:
</p>
<blockquote>
-2- <tt>system_clock::duration::min() &lt; system_clock::duration::zero()</tt>
shall be <tt>true</tt>. <ins>[<i>Note:</i> <tt>system_clock::rep</tt> shall be signed. <i>-- end note</i>].</ins>
</blockquote>





<hr>
<h3><a name="946"></a>946. <tt>duration_cast</tt> improperly specified</h3>
<p><b>Section:</b> 20.9.3.7 [time.duration.cast] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2008-12-20  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#time.duration.cast">active issues</a> in [time.duration.cast].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#time.duration.cast">issues</a> in [time.duration.cast].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
20.9.3.7 [time.duration.cast]/3:

<blockquote>
.... All intermediate computations shall be
carried out in the widest possible representation... .
</blockquote>

<p>
So ignoring
floating-point types for the moment, all this arithmetic has to be done
using the implementation's largest integral type, even if both arguments
use int for their representation. This seems excessive. And it's not at
all clear what this means if we don't ignore floating-point types.
</p>

<p>
This issue is related to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#952">952</a>.
</p>

<p><i>[
Howard adds:
]</i></p>


<blockquote>
<p>
The intent of this remark is that intermediate computations are carried out
using:
</p>

<blockquote><pre>common_type&lt;typename ToDuration::rep, Rep, intmax_t&gt;::type
</pre></blockquote>

<p>
The Remark was intended to be clarifying prose supporting the rather algorithmic description
of the previous paragraph.  I'm open to suggestions.  Perhaps the entire paragraph
3 (Remarks) would be better dropped?
</p>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We view this as a specific case of issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#952">952</a>,
and should be resolved when that issue is resolved.
</p>
<p>
Move to NAD.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="947"></a>947. duration arithmetic: contradictory requirements</h3>
<p><b>Section:</b> 20.9.3.5 [time.duration.nonmember] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2008-12-20  <b>Last modified:</b> 2009-05-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#time.duration.nonmember">issues</a> in [time.duration.nonmember].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 20.9.3.5 [time.duration.nonmember], paragraph 8 says that calling
<tt>dur / rep</tt>
when <tt>rep</tt> is an instantiation of <tt>duration</tt> requires a diagnostic.
That's followed by an <tt>operator/</tt> that takes two durations.
So <tt>dur1 / dur2</tt> is legal under the second version,
but requires a diagnostic under the first.
</p>

<p><i>[
Howard adds:
]</i></p>


<blockquote>
Please see the thread starting with c++std-lib-22980 for more information.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Move to Open, pending proposed wording (and preferably an implementation).
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="948"></a>948. <tt>ratio</tt> arithmetic tweak</h3>
<p><b>Section:</b> 20.4.2 [ratio.arithmetic] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2008-12-26  <b>Last modified:</b> 2009-03-09</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#ratio.arithmetic">active issues</a> in [ratio.arithmetic].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#ratio.arithmetic">issues</a> in [ratio.arithmetic].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2800.pdf">N2800</a>,
20.4.2 [ratio.arithmetic] lacks a paragraph from the proposal
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2661.htm">N2661</a>:
</p>

<blockquote>
<p><b>ratio arithmetic [ratio.arithmetic]</b></p>

<p>
... If the implementation is unable to form the indicated <tt>ratio</tt> due to
overflow, a diagnostic shall be issued.
</p>
</blockquote>

<p>
The lack of a diagnostic on compile-time overflow is a significant lack of
functionality.  This paragraph could be put back into the WP simply editorially.
However in forming this issue I realized that we can do better than that.  This
paragraph should also allow alternative formulations which go to extra lengths
to avoid overflow when possible.  I.e. we should not mandate overflow when the
implementation can avoid it.
</p>

<p>
For example:
</p>

<blockquote>
<pre>template &lt;class R1, class R2&gt; struct ratio_multiply {
  typedef <i>see below</i>} type; 
</pre>

<blockquote>
The nested typedef type shall be a synonym for <tt>ratio&lt;T1, T2&gt;</tt> where
<tt>T1</tt> has the value <tt>R1::num * R2::num</tt> and <tt>T2</tt> has the
value <tt>R1::den * R2::den</tt>.
</blockquote>

</blockquote>

<p>
Consider the case where <tt>intmax_t</tt> is a 64 bit 2's complement signed integer,
and we have:
</p>

<blockquote><pre>typedef std::ratio&lt;0x7FFFFFFFFFFFFFFF, 0x7FFFFFFFFFFFFFF0&gt; R1;
typedef std::ratio&lt;8, 7&gt; R2;
typedef std::ratio_multiply&lt;R1, R2&gt;::type RT;
</pre></blockquote>

<p>
According to the present formulation the implementaiton will multiply
<tt>0x7FFFFFFFFFFFFFFF * 8</tt> which will result in an overflow and subsequently
require a diagnostic.
</p>

<p>
However if the implementation is first allowed to divde <tt>0x7FFFFFFFFFFFFFFF</tt>
by <tt>7</tt> obtaining <tt>0x1249249249249249 / 1</tt> and divide
<tt>8</tt> by <tt>0x7FFFFFFFFFFFFFF0</tt> obtaining <tt>1 / 0x0FFFFFFFFFFFFFFE</tt>,
then the exact result can then be computed without overflow:
</p>

<blockquote><pre>[0x7FFFFFFFFFFFFFFF/0x7FFFFFFFFFFFFFF0] * [8/7] = [0x1249249249249249/0x0FFFFFFFFFFFFFFE]
</pre></blockquote>

<p>
Example implmentation which accomplishes this:
</p>

<blockquote><pre>template &lt;class R1, class R2&gt;
struct ratio_multiply
{
private:
    typedef ratio&lt;R1::num, R2::den&gt; _R3;
    typedef ratio&lt;R2::num, R1::den&gt; _R4;
public:
    typedef ratio&lt;__ll_mul&lt;_R3::num, _R4::num&gt;::value,
                  __ll_mul&lt;_R3::den, _R4::den&gt;::value&gt; type;
};
</pre></blockquote>

<p><i>[
Post Summit:
]</i></p>


<blockquote>
Recommend Tentatively Ready.
</blockquote>




<p><b>Proposed resolution:</b></p>
<p>
Add a paragraph prior to p1 in 20.4.2 [ratio.arithmetic]:
</p>

<blockquote>
Implementations may use other algorithms to compute the indicated ratios to avoid overflow. 
If overflow occurs, a diagnostic shall be issued.
</blockquote>





<hr>
<h3><a name="949"></a>949. <tt>owner_less</tt></h3>
<p><b>Section:</b> 20.8.13.4 [util.smartptr.ownerless] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Thomas Plum <b>Opened:</b> 2008-12-30  <b>Last modified:</b> 2009-03-10</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
20.8.13.4 [util.smartptr.ownerless] (class template <tt>owner_less</tt>) says that 
<tt>operator()(x,y)</tt> shall return <tt>x.before(y)</tt>.
</p>
<p>
However, <tt>shared_ptr</tt> and <tt>weak_ptr</tt> have an <tt>owner_before()</tt> but not a
<tt>before()</tt>, and there's no base class to provide a missing <tt>before()</tt>.
</p>
<p>
Being that the class is named  <tt>owner_less</tt> , I'm guessing that
"<tt>before()</tt>" should be "<tt>owner_before()</tt>", right?
</p>

<p><i>[
Herve adds:
]</i></p>


<blockquote>
Agreed with the typo, it should be "shall return <tt>x.owner_before(y)</tt>".
</blockquote>

<p><i>[
Post Summit:
]</i></p>


<blockquote>
Recommend Tentatively Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 20.8.13.4 [util.smartptr.ownerless] p2:
</p>

<blockquote>
-2- <tt>operator()(x,y)</tt> shall return
<tt>x.<ins>owner_</ins>before(y)</tt>. [<i>Note:</i> ...
</blockquote>





<hr>
<h3><a name="950"></a>950. unique_ptr converting ctor shouldn't accept array form</h3>
<p><b>Section:</b> 20.8.12.2.1 [unique.ptr.single.ctor] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-01-07  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#unique.ptr.single.ctor">active issues</a> in [unique.ptr.single.ctor].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#unique.ptr.single.ctor">issues</a> in [unique.ptr.single.ctor].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>unique_ptr</tt>'s of array type should not convert to
<tt>unique_ptr</tt>'s which do not have an array type.
</p>

<blockquote><pre>struct Deleter
{
   void operator()(void*) {}
};

int main()
{
   unique_ptr&lt;int[], Deleter&gt; s;
   unique_ptr&lt;int, Deleter&gt; s2(std::move(s));  <font color="#c80000">// should not compile</font>
}
</pre></blockquote>

<p><i>[
Post Summit:
]</i></p>


<blockquote>
<p>
Walter: Does the "diagnostic required" apply to both arms of the "and"?
</p>
<p>
Tom Plum: suggest to break into several sentences
</p>
<p>
Walter: suggest "comma" before the "and" in both places
</p>
<p>
Recommend Review.
</p>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
The post-Summit comments have been applied to the proposed resolution.
We now agree with the proposed resolution.
Move to Tentatively Ready.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 20.8.12.2.1 [unique.ptr.single.ctor]:
</p>

<blockquote>
<pre>template &lt;class U, class E&gt; unique_ptr(unique_ptr&lt;U, E&gt;&amp;&amp; u);
</pre>
<blockquote>
<p>
-20- <i>Requires:</i> If <tt>D</tt> is not a reference type,
construction of the deleter <tt>D</tt> from an rvalue of type <tt>E</tt>
shall be well formed and shall not throw an exception. If <tt>D</tt> is
a reference type, then <tt>E</tt> shall be the same type as <tt>D</tt>
(diagnostic required). <tt>unique_ptr&lt;U, E&gt;::pointer</tt> shall be
implicitly convertible to <tt>pointer</tt> <ins>(diagnostic required). <tt>U</tt> shall not be
an array type (diagnostic required)</ins>. [<i>Note:</i> These requirements
imply that <tt>T</tt> and <tt>U</tt> are complete types. -- <i>end note</i>]
</p>
</blockquote>
</blockquote>

<p>
Change 20.8.12.2.3 [unique.ptr.single.asgn]:
</p>

<blockquote>
<pre>template &lt;class U, class E&gt; unique_ptr&amp; operator=(unique_ptr&lt;U, E&gt;&amp;&amp; u);
</pre>
<blockquote>
<p>
-6- <i>Requires:</i> Assignment of the deleter <tt>D</tt> from an rvalue
<tt>D</tt> shall not throw an exception. <tt>unique_ptr&lt;U,
E&gt;::pointer</tt> shall be implicitly convertible to <tt>pointer</tt>
<ins>(diagnostic required).  <tt>U</tt> shall not be an array type (diagnostic required)</ins>.
[<i>Note:</i> These requirements imply that <tt>T</tt> and <tt>U</tt>
are complete types. -- <i>end note</i>]
</p>
</blockquote>
</blockquote>






<hr>
<h3><a name="951"></a>951. Various threading bugs #1</h3>
<p><b>Section:</b> 20.9.2.1 [time.traits.is_fp] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2009-01-07  <b>Last modified:</b> 2009-05-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Related to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#953">953</a>.
</p>

<p>
20.9.2.1 [time.traits.is_fp] says that the type <tt>Rep</tt> "is
assumed to be ... a class emulating an integral type." What are the
requirements for such a type?
</p>
<p><i>[
2009-05-10 Howard adds:
]</i></p>


<blockquote>
<tt>IntegralLike</tt>.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
As with issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#953">953</a>,
we recommend this issue be addressed in the context of providing concepts for the entire <tt>thread</tt> header.
</p>
<p>
We look forward to proposed wording.
</p>
<p>
Move to Open.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="952"></a>952. Various threading bugs #2</h3>
<p><b>Section:</b> 20.9.3.7 [time.duration.cast] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">Tentatively NAD Editorial</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2009-01-07  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#time.duration.cast">active issues</a> in [time.duration.cast].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#time.duration.cast">issues</a> in [time.duration.cast].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20NAD%20Editorial">Tentatively NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
20.9.3.7 [time.duration.cast] specifies an implementation and imposes
requirements in text (and the implementation doesn't satisfy all of the
text requirements). Pick one.
</p>

<p>
This issue is related to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#946">946</a>.
</p>

<p><i>[
2009-05-10 Howard adds:
]</i></p>


<blockquote>
<p>
The <i>Remarks</i> paragraph is an English re-statement of the preceeding
<i>Returns</i> clause.  It was meant to be clarifying and motivating, not
confusing.  I'm not aware with how the <i>Remarks</i> contradicts the <i>Returns</i> clause
but I'm ok with simply removing the <i>Remarks</i>.
</p>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Pete suggests that this could be resolved
by rephrasing the Remarks to Notes.
</p>
<p>
Move to NAD Editorial.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="953"></a>953. Various threading bugs #3</h3>
<p><b>Section:</b> 20.9.1 [time.clock.req] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2009-01-07  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#time.clock.req">active issues</a> in [time.clock.req].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#time.clock.req">issues</a> in [time.clock.req].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Related to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#951">951</a>.
</p>

<p>
20.9.1 [time.clock.req] says that a clock's <tt>rep</tt> member is "an
arithmetic type or a class emulating an arithmetic type." What are the
requirements for such a type?
</p>

<p><i>[
2009-05-10 Howard adds:
]</i></p>


<blockquote>
This wording was aimed directly at the <tt>ArithmeticLike</tt> concept.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We recommend this issue be addressed in the context of providing concepts
for the entire <tt>thread</tt> header.
</p>
<p>
May resolve for now by specifying arithmetic types,
and in future change to <tt>ArithmeticLike</tt>.
However, Alisdair believes this is not feasible.
</p>
<p>
Bill disagrees.
</p>
<p>
We look forward to proposed wording.  Move to Open.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="954"></a>954. Various threading bugs #4</h3>
<p><b>Section:</b> 20.9.1 [time.clock.req] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2009-01-07  <b>Last modified:</b> 2009-05-30</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#time.clock.req">active issues</a> in [time.clock.req].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#time.clock.req">issues</a> in [time.clock.req].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Table 55 -- Clock Requirements (in 20.9.1 [time.clock.req])
</p>

<ol type="a">
<li>
the requirements for <tt>C1::time_point</tt> require <tt>C1</tt> and <tt>C2</tt>
to "refer to the same epoch", but "epoch" is not defined.
</li>
<li>
"Different clocks may share a <tt>time_point</tt> definition if it is
valid to compare their <tt>time_point</tt>s by comparing their
respective <tt>duration</tt>s." What does "valid" mean here? And, since
<tt>C1::rep</tt> is "**THE** representation type of the native
<tt>duration</tt> and <tt>time_point</tt>" (emphasis added), there
doesn't seem to be much room for some other representation.
</li>
<li>
<tt>C1::is_monotonic</tt> has type "<tt>const bool</tt>". The
"<tt>const</tt>" should be removed.
</li>
<li>
<tt>C1::period</tt> has type <tt>ratio</tt>. <tt>ratio</tt> isn't a type, 
it's a template. What is the required type?
</li>
</ol>

<p><i>[
2009-05-10 Howard adds:
]</i></p>


<ol type="a">
<li>
<p>
"epoch" is purposefully not defined beyond the common English
<a href="http://www.dictionary.net/epoch">definition</a>.  The C standard
also chose not to define epoch, though POSIX did.  I believe it is a strength
of the C standard that epoch is not defined.  When it is known that two <tt>time_point</tt>s
refer to the same epoch, then a definition of the epoch is not needed to compare
the two <tt>time_point</tt>s, or subtract them.
</p>
<p>
A <tt>time_point</tt> and a <tt>Clock</tt> implicitly refer to an (unspecified) epoch.
The <tt>time_point</tt> represents an offset (<tt>duration</tt>) from an epoch.
</p>
</li>
<li>
<p>
The sentence:
</p>
<blockquote>
Different clocks 
may share a <tt>time_point</tt>
definition if it is valid to 
compare their <tt>time_point</tt>s by 
comparing their respective 
<tt>duration</tt>s.
</blockquote>

<p>
is redundant and could be removed.  I believe the sentence which follows the above:
</p>

<blockquote>
<tt>C1</tt> and <tt>C2</tt> shall refer to the same epoch.
</blockquote>

<p>
is sufficient.  If two clocks share the same epoch, then by definition, comparing
their <tt>time_point</tt>s is valid.
</p>
</li>
<li>
<tt>is_monotonic</tt> is meant to never change (be <tt>const</tt>).  It is also
desired that this value be usable in compile-time computation and branching.
</li>
<li>
<p>
This should probably instead be worded:
</p>
<blockquote>
An instantiation of <tt>ratio</tt>.
</blockquote>
</li>
</ol>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Re (a): It is not clear to us whether "epoch" is a term of art.
</p>
<p>
Re (b), (c), and (d):  We agree with Howard's comments,
and would consider adding to (c) a <tt>static constexpr</tt> requirement.
</p>
<p>
Move to Open pending proposed wording.
</p>
</blockquote>

<p><i>[
2009-05-25 Daniel adds:
]</i></p>


<blockquote>
In regards to (d) I suggest to say "a specialization of ratio" instead of
"An instantiation of ratio". This seems to be the better matching standard
core language term for this kind of entity.
</blockquote>

<p><i>[
2009-05-25 Ganesh adds:
]</i></p>


<blockquote>
<p>
Regarding (a), I found this paper on the ISO website using the term "epoch" consistently with the current wording:
</p>

<p>
<a href="http://standards.iso.org/ittf/PubliclyAvailableStandards/C030811e_FILES/MAIN_C030811e/text/ISOIEC_18026E_TEMPORAL_CS.HTM">http://standards.iso.org/ittf/PubliclyAvailableStandards/C030811e_FILES/MAIN_C030811e/text/ISOIEC_18026E_TEMPORAL_CS.HTM</a>
</p>
<p>
which is part of ISO/IEC 18026 "Information technology -- Spatial Reference Model (SRM)".
</p>
</blockquote>




<p><b>Proposed resolution:</b></p>
<ol type="a">
<li>
<p>
Change 20.9.1 [time.clock.req] p1:
</p>
<blockquote>
-1- A clock is a bundle consisting of a native <tt>duration</tt>, a native <tt>time_point</tt>, and a function <tt>now()</tt> to get the 
current <tt>time_point</tt>.  <ins>The origin of the clock's <tt>time_point</tt> is referred to as the clock's <i>epoch</i> as defined in 
section 6.3 of ISO/IEC 18026.</ins>
A clock shall meet the requirements in Table 45.
</blockquote>
</li>
<li>
<p>
Remove the sentence from the <tt>time_point</tt> row of the table "Clock Requirements":
</p>
<table border="1">
<caption>Clock requirements</caption>
<tbody><tr>
<td>
<tt>C1::time_point</tt>
</td>
<td>
<tt>chrono::time_point&lt;C1&gt;</tt> or <tt>chrono::time_point&lt;C2, C1::duration&gt;</tt>
</td>
<td>
The native <tt>time_point</tt> type of the clock.
<del>Different clocks may share a <tt>time_point</tt> definition if it is valid to compare their <tt>time_point</tt>s by comparing their respective <tt>duration</tt>s.</del>
<tt>C1</tt> and <tt>C2</tt> shall refer to the same epoch.
</td>
</tr>
</tbody></table>
</li>
</ol>
<ol start="4" type="a">
<li>
<p>
Change the row starting with <tt>C1::period</tt> of the table "Clock Requirements":
</p>
<table border="1">
<caption>Clock requirements</caption>
<tbody><tr>
<td>
<tt>C1::period</tt>
</td>
<td>
<ins>a specialization of</ins> <tt>ratio</tt>
</td>
<td>
The tick period of the clock in seconds.
</td>
</tr>
</tbody></table>

</li>
</ol>





<hr>
<h3><a name="955"></a>955. Various threading bugs #5</h3>
<p><b>Section:</b> 20.9.1 [time.clock.req] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2009-01-07  <b>Last modified:</b> 2009-06-07</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#time.clock.req">active issues</a> in [time.clock.req].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#time.clock.req">issues</a> in [time.clock.req].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
20.9.1 [time.clock.req] requires that a clock type have a member
typedef named <tt>time_point</tt> that names an instantiation of the
template <tt>time_point</tt>, and a member named <tt>duration</tt> that
names an instantiation of the template <tt>duration</tt>. This mixing of
levels is confusing. The typedef names should be different from the
template names.
</p>

<p><i>[
Post Summit, Anthony provided proposed wording.
]</i></p>


<p><i>[
2009-05-04 Howard adds:
]</i></p>


<blockquote>
<p>
The reason that the typedef names were given the same name as the class templates
was so that clients would not have to stop and think about whether they were
using the clock's native <tt>time_point</tt> / <tt>duration</tt> or the class
template directly.  In this case, one person's confusion is another person's
encapsulation.  The detail that sometimes one is referring to the clock's
native types, and sometimes one is referring to an independent type is
<em>purposefully</em> "hidden" because it is supposed to be an unimportant
detail.  It can be confusing to have to remember when to type <tt>duration</tt>
and when to type <tt>duration_type</tt>, and there is no need to require the
client to remember something like that.
</p>

<p>
For example, here is code that I once wrote in testing out the usability of
this facility:
</p>

<blockquote><pre>template &lt;class Clock, class Duration&gt;
void do_until(const std::chrono::<b>time_point</b>&lt;Clock, Duration&gt;&amp; t)
{
    typename Clock::<b>time_point now</b> = Clock::now();
    if (t &gt; now)
    {
        typedef typename std::common_type
        &lt;
            Duration,
            typename std::chrono::system_clock::<b>duration</b>
        &gt;::type CD;
        typedef std::chrono::<b>duration</b>&lt;double, std::nano&gt; ID;

        CD d = t - now;
        ID us = duration_cast&lt;ID&gt;(d);
        if (us &lt; d)
            ++us;
        ...
    }
}
</pre></blockquote>

<p>
I see no rationale to require the client to append <tt>_type</tt> to <em>some</em>
of those declarations.  It seems overly burdensome on the author of <tt>do_until</tt>:
</p>

<blockquote><pre>template &lt;class Clock, class Duration&gt;
void do_until(const std::chrono::<b>time_point</b>&lt;Clock, Duration&gt;&amp; t)
{
    typename Clock::<b>time_point<font color="#c80000">_type</font></b> now = Clock::now();
    if (t &gt; now)
    {
        typedef typename std::common_type
        &lt;
            Duration,
            typename std::chrono::system_clock::<b>duration<font color="#c80000">_type</font></b>
        &gt;::type CD;
        typedef std::chrono::<b>duration</b>&lt;double, std::nano&gt; ID;

        CD d = t - now;
        ID us = duration_cast&lt;ID&gt;(d);
        if (us &lt; d)
            ++us;
        ...
    }
}
</pre></blockquote>

<p>
Additionally I'm fairly certain that this suggestion hasn't been implemented.
If it had, it would have been discovered that it is incomplete.  <tt>time_point</tt>
also has a nested type (purposefully) named <tt>duration</tt>.
</p>
<blockquote>
That is, the current proposed wording would put the WP into an inconsistent state.
</blockquote>
<p>
In contrast,
the current WP has been implemented and I've received very favorable feedback
from people using this interface in real-world code.
</p>

</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Bill agrees that distinct names should be used for distinct kinds of entities.
</p>
<p>
Walter would prefer not to suffix type names,
especially for such well-understood terms as "duration".
</p>
<p>
Howard reminds us that the proposed resolution is incomplete, per his comment
in the issue.
</p>
<p>
Move to Open.
</p>
</blockquote>

<p><i>[
2009-06-07 Howard adds:
]</i></p>


<blockquote>
<p>
Not meaning to be argumentative, but we have a decade of positive experience
with the precedent of using the same name for the nested type as an external
class representing an identical concept.
</p>

<blockquote><pre>template&lt;class Category, class T, class Distance = ptrdiff_t,
         class Pointer = T*, class Reference = T&amp;&gt;
struct <b>iterator</b>
{
    ...
};

template &lt;BidirectionalIterator Iter&gt;
class <b>reverse_iterator</b>
{
    ...
};

template &lt;ValueType T, Allocator Alloc = allocator&lt;T&gt; &gt;
    requires NothrowDestructible&lt;T&gt;
class list
{
public:
    typedef <i>implementation-defined</i>     <b>iterator</b>;
    ...
    typedef reverse_iterator&lt;iterator&gt; <b>reverse_iterator</b>;
    ...
};
</pre></blockquote>

<p>
I am aware of <em>zero</em> complaints regarding the use of <tt>iterator</tt>
and <tt>reverse_iterator</tt> as nested types of the containers despite these
names also having related meaning at namespace std scope.
</p>

<p>
Would we really be doing programmers a favor by renaming these nested types?
</p>

<blockquote><pre>template &lt;ValueType T, Allocator Alloc = allocator&lt;T&gt; &gt;
    requires NothrowDestructible&lt;T&gt;
class list
{
public:
    typedef <i>implementation-defined</i>     <b>iterator_type</b>;
    ...
    typedef reverse_iterator&lt;iterator&gt; <b>reverse_iterator_type</b>;
    ...
};
</pre></blockquote>

<p>
I submit that such design contributes to needless verbosity which ends up
reducing readability.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 20.9 [time]:
</p>

<blockquote><pre>...
template &lt;class Clock, class Duration = typename Clock::duration<ins>_type</ins>&gt; class time_point;
...
</pre></blockquote>

<p>
Change 20.9.1 [time.clock.req]:
</p>

<blockquote>
<table border="1">
<caption>Table 45 -- Clock requirements</caption>
<tbody><tr>
<th>Expression</th>
<th>Return type</th>
<th>Operational semantics</th>
</tr>
<tr>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
<tr>
<td><tt>C1::duration<ins>_type</ins></tt></td>
<td><tt>chrono::duration&lt;C1::rep, C1::period&gt;</tt></td>
<td>The native <tt>duration</tt> type of the clock.</td>
</tr>
<tr>
<td><tt>C1::time_point<ins>_type</ins></tt></td>
<td><tt>chrono::time_point&lt;C1&gt;</tt> or <tt>chrono::time_point&lt;C2, C1::duration<ins>_type</ins>&lt;</tt></td>
<td>The native <tt>time_point</tt> type of the clock.   Different clocks may  share a <tt>time_point<ins>_type</ins></tt>
definition if it is valid to 
compare their <tt>time_point<ins>_type</ins></tt>s by 
comparing their respective 
<tt>duration<ins>_type</ins></tt>s. <tt>C1</tt> and <tt>C2</tt> shall 
refer to the same epoch.</td>
</tr>
<tr>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
<tr>
<td><tt>C1::now()</tt></td>
<td><tt>C1::time_point<ins>_type</ins></tt></td>
<td>Returns a <tt>time_point<ins>_type</ins></tt> object 
representing the current point 
in time.
</td>
</tr>
</tbody></table>
</blockquote>

<p>
Change 20.9.5.1 [time.clock.system]:
</p>

<blockquote>
<p>
-1- Objects of class <tt>system_clock</tt> represent wall clock time from the system-wide realtime clock.
</p>

<blockquote><pre>class system_clock { 
public: 
  typedef <i>see below</i> rep; 
  typedef ratio&lt;<i>unspecified</i>, <i>unspecified</i>&gt; period; 
  typedef chrono::duration&lt;rep, period&gt; duration<ins>_type</ins>; 
  typedef chrono::time_point&lt;system_clock&gt; time_point<ins>_type</ins>; 
  static const bool is_monotonic = <i>unspecified</i> ; 

  static time_point<ins>_type</ins> now(); 

  // Map to C API 
  static time_t to_time_t (const time_point<ins>_type</ins>&amp; t); 
  static time_point<ins>_type</ins> from_time_t(time_t t); 
};
</pre></blockquote>

<p>
-2- <tt>system_clock::duration<ins>_type</ins>::min() &lt; system_clock::duration<ins>_type</ins>::zero()</tt> shall be <tt>true</tt>.
</p>

<pre>time_t to_time_t(const time_point<ins>_type</ins>&amp; t);
</pre>

<blockquote>
-3- <i>Returns:</i> A <tt>time_t</tt> object that represents the same
point in time as <tt>t</tt> when both values are truncated to the
coarser of the precisions of <tt>time_t</tt> and <tt>time_point<ins>_type</ins></tt>.
</blockquote>

<pre><tt>time_point<ins>_type</ins></tt> from_time_t(time_t t);
</pre>

<blockquote>
-4- <i>Returns:</i> A <tt>time_point<ins>_type</ins></tt> object that represents the same point
in time as <tt>t</tt> when both values are truncated to the coarser of the
precisions of <tt>time_t</tt> and <tt>time_point<ins>_type</ins></tt>.
</blockquote>
</blockquote>

<p>
Change 20.9.5.2 [time.clock.monotonic]:
</p>

<blockquote><pre>class monotonic_clock { 
public: 
  typedef <i>unspecified</i>                                rep; 
  typedef ratio&lt;<i>unspecified</i> , <i>unspecified</i>&gt;           period; 
  typedef chrono::duration&lt;rep, period&gt;              duration<ins>_type</ins>; 
  typedef chrono::time_point&lt;<i>unspecified</i> , duration<ins>_type</ins>&gt; time_point<ins>_type</ins>; 
  static const bool is_monotonic =                   true; 

  static time_point<ins>_type</ins> now();
};
</pre></blockquote>

<p>
Change 20.9.5.3 [time.clock.hires]:
</p>

<blockquote><pre>class high_resolution_clock { 
public: 
  typedef <i>unspecified</i>                                rep; 
  typedef ratio&lt;<i>unspecified</i> , <i>unspecified</i>&gt;           period; 
  typedef chrono::duration&lt;rep, period&gt;              duration<ins>_type</ins>; 
  typedef chrono::time_point&lt;<i>unspecified</i> , duration<ins>_type</ins>&gt; time_point<ins>_type</ins>; 
  static const bool is_monotonic =                   true; 

  static time_point<ins>_type</ins> now();
};
</pre></blockquote>






<hr>
<h3><a name="956"></a>956. Various threading bugs #6</h3>
<p><b>Section:</b> 20.9.1 [time.clock.req] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2009-01-07  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#time.clock.req">active issues</a> in [time.clock.req].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#time.clock.req">issues</a> in [time.clock.req].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
20.9.1 [time.clock.req] uses the word "native" in several places,
but doesn't define it. What is a "native <tt>duration</tt>"?
</p>

<p><i>[
2009-05-10 Howard adds:
]</i></p>


<blockquote>
The standard uses "native" in several places without defining it (e.g.
2.14.3 [lex.ccon]).  It is meant to mean "that which is defined
by the facility", or something along those lines.  In this case it refers
to the nested <tt>time_point</tt> and <tt>duration</tt> types of the clock.
Better wording is welcome.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Move to Open pending proposed wording from Pete.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="957"></a>957. Various threading bugs #7</h3>
<p><b>Section:</b> 20.9.5.1 [time.clock.system] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Review">Review</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2009-01-07  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#time.clock.system">active issues</a> in [time.clock.system].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#time.clock.system">issues</a> in [time.clock.system].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Review">Review</a> status.</p>
<p><b>Discussion:</b></p>
<p>
20.9.5.1 [time.clock.system]: <tt>to_time_t</tt> is overspecified. It
requires truncation, but should allow rounding. For example, suppose a
system has a clock that gives times in milliseconds, but <tt>time()</tt> rounds
those times to the nearest second. Then <tt>system_clock</tt> can't use any
resolution finer than one second, because if it did, truncating times
between half a second and a full second would produce the wrong <tt>time_t</tt>
value.
</p>

<p><i>[
Post Summit Anthony Williams provided proposed wording.
]</i></p>


<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Move to Review pending input from Howard. and other stakeholders.
</blockquote>

<p><i>[
2009-05-23 Howard adds:
]</i></p>


<blockquote>
I am in favor of the wording provided by Anthony.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
In 20.9.5.1 [time.clock.system] replace paragraphs 3 and 4 with:
</p>

<blockquote>
<pre>time_t to_time_t(const time_point&amp; t);
</pre>
<blockquote>
-3- <i>Returns:</i> A <tt>time_t</tt> object that represents the same
point in time as <tt>t</tt> when both values are <del>truncated</del>
<ins>restricted</ins> to the coarser of the precisions of
<tt>time_t</tt> and <tt>time_point</tt>. <ins> It is implementation
defined whether values are rounded or truncated to the required
precision.</ins>
</blockquote>

<pre>time_point from_time_t(time_t t);
</pre>
<blockquote>
-4- <i>Returns:</i> A <tt>time_point</tt> object that represents the
same point in time as <tt>t</tt> when both values are <del>truncated</del>
<ins>restricted</ins> to the
coarser of the precisions of <tt>time_t</tt> and <tt>time_point</tt>.
<ins>It is implementation defined whether values are
rounded or truncated to the required precision.</ins>
</blockquote>
</blockquote>





<hr>
<h3><a name="958"></a>958. Various threading bugs #8</h3>
<p><b>Section:</b> 30.5.1 [thread.condition.condvar] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2009-01-07  <b>Last modified:</b> 2009-03-22</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#thread.condition.condvar">active issues</a> in [thread.condition.condvar].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.condition.condvar">issues</a> in [thread.condition.condvar].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
30.5.1 [thread.condition.condvar]: the specification for <tt>wait_for</tt>
with no predicate has an effects clause that says it calls <tt>wait_until</tt>,
and a returns clause that sets out in words how to determine the return
value. Is this description of the return value subtly different from the
description of the value returned by <tt>wait_until</tt>? Or should the effects
clause and the returns clause be merged?
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Move to open. Associate with LWG <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#859">859</a> and any other monotonic-clock
related issues.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="959"></a>959. Various threading bugs #9</h3>
<p><b>Section:</b> 30.5.1 [thread.condition.condvar] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2009-01-07  <b>Last modified:</b> 2009-03-22</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#thread.condition.condvar">active issues</a> in [thread.condition.condvar].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.condition.condvar">issues</a> in [thread.condition.condvar].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
30.5.1 [thread.condition.condvar]: <tt>condition_variable::wait_for</tt>
is required to compute the absolute time by adding the duration value to
<tt>chrono::monotonic_clock::now()</tt>, but <tt>monotonic_clock</tt> is not required to
exist.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Move to open. Associate with LWG <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#859">859</a> and any other monotonic-clock
related issues.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="960"></a>960. Various threading bugs #10</h3>
<p><b>Section:</b> 30.4.1 [thread.mutex.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2009-01-07  <b>Last modified:</b> 2009-03-27</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#thread.mutex.requirements">active issues</a> in [thread.mutex.requirements].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.mutex.requirements">issues</a> in [thread.mutex.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
30.4.1 [thread.mutex.requirements]: paragraph 4 is entitled
"Error conditions", but according to 17.5.1.4 [structure.specifications], "Error
conditions:" specifies "the error conditions for error codes reported by
the function." It's not clear what this should mean when there is no
function in sight.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Move to open.
</blockquote>

<p><i>[
Beman provided proposed wording.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
Change 30.4.1 [thread.mutex.requirements] Mutex requirements,
paragraph 4 as indicated:
</p>

<blockquote>
<p>
-4- <del><i>Error conditions:</i></del>
<ins>The error conditions for error codes, if any, reported by member
functions of type Mutex shall be:</ins>
</p>
<ul>
<li>
<tt>not_enough_memory</tt> -- if there is not enough memory to construct
the mutex object.
</li>
<li>
<tt>resource_unavailable_try_again</tt> -- if any native handle type
manipulated is not available.
</li>
<li>
<tt>operation_not_permitted</tt> -- if the thread does not have the
necessary permission to change the state of the mutex object.
</li>
<li>
<tt>device_or_resource_busy</tt> -- if any native handle type
manipulated is already locked.
</li>
<li>
<tt>invalid_argument</tt> -- if any native handle type manipulated as
part of mutex construction is incorrect.
</li>
</ul>
</blockquote>





<hr>
<h3><a name="961"></a>961. Various threading bugs #11</h3>
<p><b>Section:</b> 30.4.1 [thread.mutex.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2009-01-07  <b>Last modified:</b> 2009-03-22</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#thread.mutex.requirements">active issues</a> in [thread.mutex.requirements].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.mutex.requirements">issues</a> in [thread.mutex.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
30.4.1 [thread.mutex.requirements] describes required member
functions of mutex types, and requires that they throw exceptions under
certain circumstances. This is overspecified. User-defined types can
abort on such errors without affecting the operation of templates
supplied by standard-library.
</p>

<p><i>[
Summit:
]</i></p>

<blockquote>
Move to open. Related to conceptualization and should probably be
tackled as part of that.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="962"></a>962. Various threading bugs #12</h3>
<p><b>Section:</b> 30.4.3.2.2 [thread.lock.unique.locking] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2009-01-07  <b>Last modified:</b> 2009-03-22</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
30.4.3.2.2 [thread.lock.unique.locking]:  <tt>unique_lock::lock</tt> is
required to throw an object of type <tt>std::system_error</tt> "when the
postcondition cannot be achieved." The postcondition is <tt>owns == true</tt>,
and this is trivial to achieve. Presumably, the requirement is intended
to mean something more than that.
</p>

<p><i>[
Summit:
]</i></p>

<blockquote>
Move to open.
</blockquote>

<p><i>[
Beman has volunteered to provide proposed wording.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="963"></a>963. Various threading bugs #13</h3>
<p><b>Section:</b> 30.3.1.5 [thread.thread.member] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2009-01-07  <b>Last modified:</b> 2009-03-22</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#thread.thread.member">active issues</a> in [thread.thread.member].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.thread.member">issues</a> in [thread.thread.member].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
30.3.1.5 [thread.thread.member]:  <tt>thread::detach</tt> is required to
throw an exception if the thread is "not a detachable thread".
"Detachable" is never defined.
</p>

<p><i>[
Howard adds:
]</i></p>


<blockquote>
Due to a mistake on my part, 3 proposed resolutions appeared at approximately
the same time.  They are all three noted below in the discussion.
</blockquote>

<p><i>[
Summit, proposed resolution:
]</i></p>


<blockquote>
<p>
In 30.3.1.5 [thread.thread.member] change:
</p>

<blockquote><pre>void detach();
</pre>
<blockquote>
<p>...</p>
<p>-14- <i>Error conditions:</i></p>
<ul>
<li><tt>no_such_process</tt> --  <ins>if the thread is</ins> not <del>a</del> valid<del> thread</del>.</li>
<li><tt>invalid_argument</tt> -- <ins>if the thread is</ins> not <del>a detachable</del> <ins>joinable</ins><del> thread</del>.</li>
</ul>
</blockquote>

</blockquote>

</blockquote>

<p><i>[
Post Summit, Jonathan Wakely adds:
]</i></p>


<blockquote>
<p>
A <tt>thread</tt> is detachable if it is joinable. As we've defined joinable,
we can just use that.
</p>
<p>
This corresponds to the pthreads specification, where pthread_detach
fails if the thread is not joinable:
</p>
<blockquote>
EINVAL: The  implementation  has  detected  that  the value specified by
thread does not refer to a joinable thread.
</blockquote>
<p>
Jonathan recommends this proposed wording:
</p>
<blockquote>
<p>
In 30.3.1.5 [thread.thread.member] change:
</p>

<blockquote><pre>void detach();
</pre>
<blockquote>
<p>...</p>
<p>-14- <i>Error conditions:</i></p>
<ul>
<li>...</li>
<li><tt>invalid_argument</tt> -- not a <del>detachable</del> <ins>joinable</ins> thread.</li>
</ul>
</blockquote>

</blockquote>
</blockquote>
</blockquote>

<p><i>[
Post Summit, Anthony Williams adds:
]</i></p>


<blockquote>
<p>
This is covered by the precondition that <tt>joinable()</tt> be <tt>true</tt>.
</p>
<p>
Anthony recommends this proposed wording:
</p>

<blockquote>
<p>
In 30.3.1.5 [thread.thread.member] change:
</p>

<blockquote><pre>void detach();
</pre>
<blockquote>
<p>...</p>
<p>-14- <i>Error conditions:</i></p>
<ul>
<li>...</li>
<li><del><tt>invalid_argument</tt> -- not a detachable thread.</del></li>
</ul>
</blockquote>

</blockquote>

</blockquote>

</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="964"></a>964. Various threading bugs #14</h3>
<p><b>Section:</b> 30.5.2 [thread.condition.condvarany] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2009-01-07  <b>Last modified:</b> 2009-03-22</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The requirements for the constructor for <tt>condition_variable</tt> has several
error conditions, but the requirements for the constructor for
<tt>condition_variable_any</tt> has none. Is this difference intentional?
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Move to open, pass to Howard. If this is intentional, a note may be
helpful. If the error conditions are to be copied from
<tt>condition_variable</tt>, this depends on LWG <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#965">965</a>.
</blockquote>

<p><i>[
Post Summit Howard adds:
]</i></p>


<blockquote>
The original intention 
(<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2447.htm#ConditionVariablesWording">N2447</a>)
was to let the OS return whatever errors it was going to return, and for
those to be translated into exceptions, for both
<tt>condition_variable</tt> and <tt>condition_variable_any</tt>.  I have not
received any complaints about specific error conditions from vendors on
non-POSIX platforms, but such complaints would not surprise me if they surfaced.
</blockquote>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="965"></a>965. Various threading bugs #15</h3>
<p><b>Section:</b> 30.5.1 [thread.condition.condvar] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2009-01-07  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#thread.condition.condvar">active issues</a> in [thread.condition.condvar].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.condition.condvar">issues</a> in [thread.condition.condvar].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
30.5.1 [thread.condition.condvar]: the constructor for
<tt>condition_variable</tt> throws an exception with error code
<tt>device_or_resource_busy</tt> "if attempting to initialize a
previously-initialized but as of yet undestroyed <tt>condition_variable</tt>."
How can this occur?
</p>

<p><i>[
Summit:
]</i></p>

<blockquote>
<p>
Move to review. Proposed resolution: strike the <tt>device_or_resource_busy</tt>
error condition from the constructor of <tt>condition_variable</tt>.
</p>
<ul>
<li>
This is a POSIX error that cannot occur in this interface because the
C++ interface does not separate declaration from initialization.
</li>
</ul>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution.
Move to Tentatively Ready.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 30.5.1 [thread.condition.condvar] p3:
</p>

<blockquote>
<ul>
<li>...</li>
<li>
<del><tt>device_or_resource_busy</tt> -- if attempting to initialize a
previously-initialized but as of yet undestroyed
<tt>condition_variable</tt>.</del>
</li>
</ul>
</blockquote>





<hr>
<h3><a name="966"></a>966. Various threading bugs #16</h3>
<p><b>Section:</b> 30.5.1 [thread.condition.condvar] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2009-01-07  <b>Last modified:</b> 2009-03-22</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#thread.condition.condvar">active issues</a> in [thread.condition.condvar].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.condition.condvar">issues</a> in [thread.condition.condvar].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
30.5.1 [thread.condition.condvar]: <tt>condition_variable::wait</tt> and
<tt>condition_variable::wait_until</tt> both have a postcondition that <tt>lock</tt> is
locked by the calling thread, and a throws clause that requires throwing
an exception if this postcondition cannot be achieved. How can the
implementation detect that this <tt>lock</tt> can never be obtained?
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Move to open. Requires wording. Agreed this is an issue, and the
specification should not require detecting deadlocks.
</blockquote>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="967"></a>967. Various threading bugs #17</h3>
<p><b>Section:</b> 30.3.1.2 [thread.thread.constr] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2009-01-07  <b>Last modified:</b> 2009-03-22</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#thread.thread.constr">active issues</a> in [thread.thread.constr].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.thread.constr">issues</a> in [thread.thread.constr].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
the error handling for the constructor for <tt>condition_variable</tt>
distinguishes lack of memory from lack of other resources, but the error
handling for the thread constructor does not. Is this difference
intentional?
</p>

<p><i>[
Beman has volunteered to provide proposed wording.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="968"></a>968. Various threading bugs #18</h3>
<p><b>Section:</b> 30.4.1 [thread.mutex.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2009-01-07  <b>Last modified:</b> 2009-03-22</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#thread.mutex.requirements">active issues</a> in [thread.mutex.requirements].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.mutex.requirements">issues</a> in [thread.mutex.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
30.4.1 [thread.mutex.requirements]: several functions are
required to throw exceptions "if the thread does not have the necessary
permission ...". "The necessary permission" is not defined.
</p>

<p><i>[
Summit:
]</i></p>

<blockquote>
Move to open.
</blockquote>


<p><i>[
Beman has volunteered to provide proposed wording.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="969"></a>969. What happened to Library Issue 475?</h3>
<p><b>Section:</b> 25.3.4 [alg.foreach] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">Tentatively NAD Editorial</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2009-01-12  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#alg.foreach">active issues</a> in [alg.foreach].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.foreach">issues</a> in [alg.foreach].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20NAD%20Editorial">Tentatively NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Library Issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#475">475</a> has CD1 status, but the non-normative note in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2723.pdf">N2723</a>
was removed in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2798.pdf">N2798</a>
(25.3.4 [alg.foreach] in both drafts).
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Move to NAD Editorial.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Restore the non-normative note. It might need to be expressed in terms of concepts.
</p>





<hr>
<h3><a name="970"></a>970. addressof overload unneeded</h3>
<p><b>Section:</b> 20.8.11.1 [object.addressof] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-01-16  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#object.addressof">active issues</a> in [object.addressof].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#object.addressof">issues</a> in [object.addressof].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
20.8.11.1 [object.addressof] specifies:
</p>

<blockquote><pre>template &lt;ObjectType T&gt; T* addressof(T&amp; r);
template &lt;ObjectType T&gt; T* addressof(T&amp;&amp; r);
</pre></blockquote>

<p>
The two signatures are ambiguous when the argument is an lvalue.  The
second signature seems not useful:  what does it mean to take the
address of an rvalue?
</p>

<p><i>[
Post Summit:
]</i></p>


<blockquote>
Recommend Review.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution.
Move to Tentatively Ready.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 20.8.11.1 [object.addressof]:
</p>

<blockquote><pre>template &lt;ObjectType T&gt; T* addressof(T&amp; r);
<del>template &lt;ObjectType T&gt; T* addressof(T&amp;&amp; r);</del>
</pre></blockquote>






<hr>
<h3><a name="971"></a>971. Spurious diagnostic conversion function</h3>
<p><b>Section:</b> 19.5.2.6 [syserr.errcode.nonmembers] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Beman Dawes <b>Opened:</b> 2009-01-19  <b>Last modified:</b> 2009-05-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Anthony Williams raised the question in c++std-lib-22987 "why is there
<tt>std::make_error_code(std::errc)</tt>? What purpose does this serve?"
</p>
<p>
The function <tt>make_error_code(errc e)</tt> is not required, since
<tt>make_error_condition(errc e)</tt> is the function that is needed for <tt>errc</tt>
conversions. <tt>make_error_code(errc e)</tt> appears to be a holdover from my
initial confusion over the distinction between POSIX and operating
systems that conform to the POSIX spec.
</p>

<p><i>[
Post Summit:
]</i></p>


<blockquote>
Recommend Review.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
The designer of the facility (Christopher Kohlhoff)
strongly disagrees that there is an issue here,
and especially disagrees with the proposed resolution.
Bill would prefer to be conservative and not apply this proposed resolution.
Move to Open, and recommend strong consideration for NAD status.
</blockquote>

<p><i>[
2009-05-21 Beman adds:
]</i></p>


<blockquote>
My mistake. Christopher and Bill are correct and the issue should be
NAD. The function is needed by users.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change System error support 19.5 [syserr], Header <tt>&lt;system_error&gt;</tt>
synopsis, as indicated:
</p>

<blockquote><pre><del>error_code make_error_code(errc e);</del>
error_condition make_error_condition(errc e);
</pre></blockquote>

<p>
Delete from Class error_code non-member functions
19.5.2.6 [syserr.errcode.nonmembers]:
</p>

<blockquote><pre><del>error_code make_error_code(errc e);</del>
</pre>
<blockquote>
<del><i>Returns:</i> <tt>error_code(static_cast&lt;int&gt;(e),
generic_category)</tt>.</del>
</blockquote>
</blockquote>






<hr>
<h3><a name="972"></a>972. The term "Assignable" undefined but still in use</h3>
<p><b>Section:</b> 17 [library] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">Tentatively NAD Editorial</a>
 <b>Submitter:</b> Niels Dekker <b>Opened:</b> 2009-01-07  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20NAD%20Editorial">Tentatively NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Previous versions of the Draft had a table, defining the Assignable 
requirement.  For example 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2134.pdf">N2134</a>
Table 79, "Assignable requirements". But I guess the term "Assignable" 
is outdated by now, because the current Committee Draft provides 
<tt>MoveAssignable</tt>, <tt>CopyAssignable</tt>, and <tt>TriviallyCopyAssignable</tt> concepts 
instead. And as far as I can see, it no longer has a definition of 
<tt>Assignable</tt>. (Please correct me if I'm wrong.) Still the word 
"Assignable" is used in eight places in the Draft, 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2800.pdf">N2800</a>.
</p>

<p>
Are all of those instances of "<tt>Assignable</tt>" to be replaced by "<tt>CopyAssignable</tt>"? 
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Move to NAD Editorial.
</blockquote>


<p><b>Proposed resolution:</b></p>

<p>
Change Exception Propagation 18.8.5 [propagation]:
</p>
<blockquote>
<tt>exception_ptr</tt> shall be <tt>DefaultConstructible</tt>, <tt>CopyConstructible</tt>,
<tt><ins>Copy</ins>Assignable</tt> and <tt>EqualityComparable</tt>.
</blockquote>

<p>
Change Class template reference_wrapper 20.7.5 [refwrap]:
</p>
<blockquote>
<tt>reference_wrapper&lt;T&gt;</tt> is a <tt>CopyConstructible</tt> and <tt><ins>Copy</ins>Assignable</tt> wrapper around a reference to an object of type <tt>T</tt>.
</blockquote>
<p>
Change Placeholders 20.7.12.1.4 [func.bind.place]:
</p>
<blockquote>
It is implementation defined whether placeholder types are <tt><ins>Copy</ins>Assignable</tt>. <tt><ins>Copy</ins>Assignable</tt> placeholders' copy assignment operators shall not throw exceptions.
</blockquote>
<p>
Change Class template shared_ptr 20.8.13.2 [util.smartptr.shared]:
</p>
<blockquote>
Specializations of <tt>shared_ptr</tt> shall be <tt>CopyConstructible</tt>, <tt><ins>Copy</ins>Assignable</tt>, and <tt>LessThanComparable</tt>...
</blockquote>
<p>
Change Class template weak_ptr 20.8.13.3 [util.smartptr.weak]:
</p>
<blockquote>
Specializations of <tt>weak_ptr</tt> shall be <tt>CopyConstructible</tt>, <tt><ins>Copy</ins>Assignable</tt>, and <tt>LessThanComparable</tt>...
</blockquote>
<p>
Change traits typedefs 21.2.2 [char.traits.typedefs] (note: including deletion of reference to 23.1!):
</p>
<blockquote>
<i>Requires:</i> <tt>state_type</tt> shall meet the requirements of <tt><ins>Copy</ins>Assignable</tt><del> (23.1)</del>, <tt>CopyConstructible</tt> (20.1.8), and <tt>DefaultConstructible</tt> types.
</blockquote>
<p>
Change Class seed_seq 26.5.7.1 [rand.util.seedseq] (note again: including deletion of reference to 23.1!):
</p>
<blockquote>
In addition to the requirements set forth below, instances of
<tt>seed_seq</tt> shall meet the requirements of <tt>CopyConstructible</tt> (20.1.8) and of <tt><ins>Copy</ins>Assignable</tt><del> (23.1)</del>.
</blockquote>

<p>
Note: The proposed resolution of this issue does not deal with the
instance of the term "Assignable" in D.9.1 [auto.ptr], as this is dealt
with more specifically by LWG <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#973">973</a>, "<tt>auto_ptr</tt> characteristics", submitted
by Maarten Hilferink.
</p>






<hr>
<h3><a name="973"></a>973. auto_ptr characteristics</h3>
<p><b>Section:</b> D.9.1 [auto.ptr] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">Tentatively NAD Editorial</a>
 <b>Submitter:</b> Maarten Hilferink <b>Opened:</b> 2009-01-21  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#auto.ptr">active issues</a> in [auto.ptr].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#auto.ptr">issues</a> in [auto.ptr].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20NAD%20Editorial">Tentatively NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I think that the Note of D.9.1 [auto.ptr], paragraph 3 needs a rewrite 
since "Assignable" is no longer defined as a concept. 
The relationship of <tt>auto_ptr</tt> with the new <tt>CopyAssignable</tt>, <tt>MoveAssignable</tt>,
 and <tt>MoveConstructible</tt> concepts should be clarified.
Furthermore, since the use of <tt>auto_ptr</tt> is depreciated anyway,
 we can also omit a description of its intended use.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the intent of the proposed resolution.
Move to NAD Editorial.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change D.9.1 [auto.ptr], paragraph 3:
</p>

<blockquote>
The <tt>auto_ptr</tt> provides a semantics of strict ownership. An
<tt>auto_ptr</tt> owns the ob ject it holds a pointer to. Copying an
<tt>auto_ptr</tt> copies the pointer and transfers ownership to the
destination. If more than one <tt>auto_ptr</tt> owns the same ob ject at
the same time the behavior of the program is undefined. [<i>Note:</i>
The uses of <tt>auto_ptr</tt> include providing temporary
exception-safety for dynamically allocated memory, passing ownership of
dynamically allocated memory to a function, and returning dynamically
allocated memory from a function.
<del><tt>auto_ptr</tt> does not meet the
<tt>CopyConstructible</tt> and <tt>Assignable</tt> requirements for
standard library container elements and thus instantiating a standard
library container with an <tt>auto_ptr</tt> results in undefined
behavior.</del>

<ins>Instances of <tt>auto_ptr</tt> shall
meet the <tt>MoveConstructible</tt> and <tt>MoveAssignable</tt>
requirements, but do not meet the <tt>CopyConstructible</tt> and
<tt>CopyAssignable</tt> requirements.</ins>
-- <i>end note</i>]
</blockquote>





<hr>
<h3><a name="974"></a>974. <tt>duration&lt;double&gt;</tt> should not implicitly convert to <tt>duration&lt;int&gt;</tt></h3>
<p><b>Section:</b> 20.9.3.1 [time.duration.cons] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-01-21  <b>Last modified:</b> 2009-05-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The following code should not compile because it involves implicit truncation
errors (against the design philosophy of the <tt>duration</tt> library).
</p>

<blockquote><pre>duration&lt;double&gt; d(3.5);
duration&lt;int&gt; i = d;  <font color="#c80000">// implicit truncation, should not compile</font>
</pre></blockquote>

<p>
This intent was codified in the example implementation which drove this proposal
but I failed to accurately translate the code into the specification in this
regard.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We agree with the proposed resolution.
</p>
<p>
Move to Tentatively Ready.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 20.9.3.1 [time.duration.cons], p4:
</p>

<blockquote>
<pre>template &lt;class Rep2, class Period2&gt; 
  duration(const duration&lt;Rep2, Period2&gt;&amp; d);
</pre>
<blockquote>
-4- <i>Requires:</i> <tt>treat_as_floating_point&lt;rep&gt;::value</tt>
shall be <tt>true</tt> or <ins>both</ins> <tt>ratio_divide&lt;Period2,
period&gt;::type::den</tt> shall be 1
<ins>and <tt>treat_as_floating_point&lt;Rep2&gt;::value</tt>
shall be <tt>false</tt></ins>.
Diagnostic required.
[<i>Note:</i> This requirement prevents implicit truncation error when
converting between integral-based <tt>duration</tt> types. Such a
construction could easily lead to confusion about the value of the
<tt>duration</tt>. -- <i>end note</i>]
</blockquote>
</blockquote>





<hr>
<h3><a name="975"></a>975. <tt>is_convertible</tt> cannot be instantiated for  non-convertible types</h3>
<p><b>Section:</b> 20.6.5 [meta.rel] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2009-01-25  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#meta.rel">active issues</a> in [meta.rel].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#meta.rel">issues</a> in [meta.rel].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>

<b>Addresses UK 206</b>

<p>
Related to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1114">1114</a>.
</p>

<p>
The current specification of <tt>std::is_convertible</tt> (reference is draft
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2798.pdf">N2798</a>)
is basically defined by 20.6.5 [meta.rel]/4:
</p>

<blockquote>
<p>
In order to instantiate the template <tt>is_convertible&lt;From,
To&gt;</tt>, the following code shall be well formed:
</p>

<blockquote><pre>template &lt;class T&gt;
  typename add_rvalue_reference&lt;T&gt;::type create();

To test() {
  return create&lt;From&gt;();
}
</pre></blockquote>

<p>
[<i>Note:</i> This requirement gives well defined results for reference
types, void types, array types, and function types. --<i>end note</i>]
</p>
</blockquote>

<p>
The first sentence can be interpreted, that e.g. the expression
</p>

<blockquote><pre>std::is_convertible&lt;double, int*&gt;::value
</pre></blockquote>

<p>
is ill-formed because <tt>std::is_convertible&lt;double, int*&gt;</tt> could not be
instantiated, or in more general terms: The wording requires that
<tt>std::is_convertible&lt;X, Y&gt;</tt> cannot be instantiated for otherwise valid
argument types <tt>X</tt> and <tt>Y</tt> if <tt>X</tt> is not convertible to <tt>Y</tt>.
</p>

<p>
This semantic is both unpractical and in contradiction to what the last type
traits paper
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2255.html">N2255</a>
proposed:
</p>

<blockquote>
<p>
If the following <tt>test</tt> function is well formed code <tt>b</tt>
is <tt>true</tt>, else it is <tt>false</tt>.
</p>

<blockquote><pre>template &lt;class T&gt;
  typename add_rvalue_reference&lt;T&gt;::type create();

To test() {
  return create&lt;From&gt;();
}
</pre></blockquote>

<p>
[<i>Note:</i> This definition gives well defined results for <tt>reference</tt>
types, <tt>void</tt> types, array types, and function types. --<i>end note</i>]
</p>
</blockquote>

<p><i>[
Post Summit:
]</i></p>


<blockquote>
<p>
Jens: Checking that code is well-formed and then returning true/false
sounds like speculative compilation. John Spicer would really dislike
this. Please find another wording suggesting speculative compilation.
</p>
<p>
Recommend Open.
</p>
</blockquote>

<p><i>[
Post Summit, Howard adds:
]</i></p>


<blockquote>
<p>
John finds the following wording clearer:
</p>
<blockquote>

<table border="1">
<tbody><tr>
<th>Template</th><th>Condition</th><th>Comments</th>
</tr>
<tr>
<td><tt>template &lt;class From, class To&gt;<br>struct is_convertible;</tt></td>
<td><i>see below</i></td>
<td><tt>From</tt> and <tt>To</tt> shall be complete types, arrays of unknown bound,
or (possibly cv-qualified) <tt>void</tt> types.</td>
</tr>
</tbody></table>

<p>
Given the following function prototype:
</p>

<blockquote><pre>template &lt;class T&gt;
  typename add_rvalue_reference&lt;T&gt;::type create();
</pre></blockquote>

<p>
<tt>is_convertible&lt;From, To&gt;::value</tt> shall be <tt>true</tt> if the
return expression in the following code would be well-formed, including
any implicit conversions to the return type of the function, else
<tt>is_convertible&lt;From, To&gt;::value</tt> shall be <tt>false</tt>.
</p>

<blockquote><pre>To test() {
  return create&lt;From&gt;();
}
</pre></blockquote>

</blockquote>

</blockquote>

<b>Original proposed wording:</b>

<p>
In 20.6.5 [meta.rel]/4 change:
</p>

<blockquote>
<del>In order to instantiate the template <tt>is_convertible&lt;From, To&gt;</tt>, the
following code shall be well formed</del> <ins>If the following code
is well formed <tt>is_convertible&lt;From, To&gt;::value</tt> is <tt>true</tt>, otherwise
<tt>false</tt></ins>:[..]
</blockquote>

<p><b>Revision 2</b></p>

<blockquote>

<p>
In 20.6.5 [meta.rel] change:
</p>

<blockquote>

<table border="1">
<tbody><tr>
<th>Template</th><th>Condition</th><th>Comments</th>
</tr>
<tr>
</tr><tr><td>...</td><td>...</td><td>...</td></tr>
<tr><td><tt>template &lt;class From, class To&gt;<br>struct is_convertible;</tt></td>
<td>
<del>The code set out below shall be well formed.</del>
<ins><i>see below</i></ins></td>
<td><tt>From</tt> and <tt>To</tt> shall be complete types, arrays of unknown bound,
or (possibly cv-qualified) <tt>void</tt> types.</td>
</tr>
</tbody></table>

<p>
-4- <del>In order to instantiate the template <tt>is_convertible&lt;From, To&gt;</tt>, the
following code shall be well formed:</del>
<ins>Given the following function prototype:</ins>
</p>

<blockquote><pre>template &lt;class T&gt; 
  typename add_rvalue_reference&lt;T&gt;::type create();
</pre></blockquote>

<p>
<ins><tt>is_convertible&lt;From, To&gt;::value</tt> inherits either directly or
indirectly from <tt>true_type</tt> if the
return expression in the following code would be well-formed, including
any implicit conversions to the return type of the function, else
<tt>is_convertible&lt;From, To&gt;::value</tt> inherits either directly or
indirectly from <tt>false_type</tt>.</ins>
</p>

<blockquote><pre>To test() { 
  return create&lt;From&gt;(); 
}
</pre></blockquote>

<p>
[<i>Note:</i> This requirement gives well defined results for reference types,
void types, array types, and function types. <i>-- end note</i>]
</p>

</blockquote>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution.
Move to Tentatively Ready.
</blockquote>


<p><b>Proposed resolution:</b></p>

<p>
In 20.6.5 [meta.rel] change:
</p>

<blockquote>

<table border="1">
<tbody><tr>
<th>Template</th><th>Condition</th><th>Comments</th>
</tr>
<tr>
</tr><tr><td>...</td><td>...</td><td>...</td></tr>
<tr><td><tt>template &lt;class From, class To&gt;<br>struct is_convertible;</tt></td>
<td>
<del>The code set out below shall be well formed.</del>
<ins><i>see below</i></ins></td>
<td><tt>From</tt> and <tt>To</tt> shall be complete types, arrays of unknown bound,
or (possibly cv-qualified) <tt>void</tt> types.</td>
</tr>
</tbody></table>

<p>
-4- <del>In order to instantiate the template <tt>is_convertible&lt;From, To&gt;</tt>, the
following code shall be well formed:</del>
<ins>Given the following function prototype:</ins>
</p>

<blockquote><pre>template &lt;class T&gt; 
  typename add_rvalue_reference&lt;T&gt;::type create();
</pre></blockquote>

<p>
<ins>the predicate condition for a template specialization
<tt>is_convertible&lt;From, To&gt;</tt> shall be satisfied, if and only
if the return expression in the following code would be well-formed,
including any implicit conversions to the return type of the
function.</ins>
</p>

<blockquote><pre>To test() { 
  return create&lt;From&gt;(); 
}
</pre></blockquote>

<p>
[<i>Note:</i> This requirement gives well defined results for reference types,
void types, array types, and function types. <i>&#8212; end note</i>]
</p>

</blockquote>





<hr>
<h3><a name="976"></a>976. Class template std::stack should be movable</h3>
<p><b>Section:</b> 23.3.5.3.1 [stack.defn] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2009-02-01  <b>Last modified:</b> 2009-05-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The synopsis given in 23.3.5.3.1 [stack.defn] does not show up
</p>

<blockquote><pre>requires MoveConstructible&lt;Cont&gt; stack(stack&amp;&amp;);
requires MoveAssignable&lt;Cont&gt; stack&amp; operator=(stack&amp;&amp;);
</pre></blockquote>

<p>
although the other container adaptors do provide corresponding
members.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We agree with the proposed resolution.
</p>
<p>
Move to Tentatively Ready.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
In the class stack synopsis of 23.3.5.3.1 [stack.defn] insert:
</p>

<blockquote><pre>template &lt;ObjectType T, StackLikeContainer Cont = deque&lt;T&gt; &gt; 
  requires SameType&lt;Cont::value_type, T&gt; 
        &amp;&amp; NothrowDestructible&lt;Cont&gt; 
class stack { 
public: 
   ...
   requires CopyConstructible&lt;Cont&gt; explicit stack(const Cont&amp;); 
   requires MoveConstructible&lt;Cont&gt; explicit stack(Cont&amp;&amp; = Cont()); 
   <ins>requires MoveConstructible&lt;Cont&gt; stack(stack&amp;&amp;);</ins>
   <ins>requires MoveAssignable&lt;Cont&gt; stack&amp; operator=(stack&amp;&amp;);</ins>
   template &lt;class Alloc&gt; 
     requires Constructible&lt;Cont, const Alloc&amp;&gt; 
     explicit stack(const Alloc&amp;);
   ...
};
</pre></blockquote>

<p>
[Remark: This change should be done in sync with the resolution of
paper
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2819.html">N2819</a>]
</p>






<hr>
<h3><a name="977"></a>977. insert iterators inefficient for expensive to move types</h3>
<p><b>Section:</b> 24.7 [insert.iterators] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-02-02  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#insert.iterators">active issues</a> in [insert.iterators].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#insert.iterators">issues</a> in [insert.iterators].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The new concepts for the insert iterators mandate an extra copy when
inserting an lvalue:
</p>

<blockquote><pre>requires CopyConstructible&lt;Cont::value_type&gt;
  back_insert_iterator&lt;Cont&gt;&amp; 
  operator=(const Cont::value_type&amp; value);
</pre>
<blockquote>
-1- <i>Effects:</i> <tt>push_back(*container, <b>Cont::value_type(</b>value<b>)</b>);</tt>
</blockquote>
</blockquote>

<p>
The reason is to convert <tt>value</tt> into an rvalue because the current
<tt>BackInsertionContainer</tt> concept only handles <tt>push_back</tt>-ing
rvalues:
</p>

<blockquote><pre>concept BackInsertionContainer&lt;typename C&gt; : Container&lt;C&gt; { 
  void push_back(C&amp;, value_type&amp;&amp;); 
}
</pre></blockquote>

<p>
Without the conversion of <tt>value</tt> to an rvalue, the assignment operator
fails to concept check.
</p>

<p>
A solution is to modify the <tt>BackInsertionContainer</tt> concept so that
the client can pass in the parameter type for <tt>push_back</tt> similar to
what is already done for the <tt>OutputIterator</tt> concept:
</p>

<blockquote><pre>concept BackInsertionContainer&lt;typename C, typename Value = C::value_type&amp;&amp;&gt;
  : Container&lt;C&gt; { 
     void push_back(C&amp;, Value); 
}
</pre></blockquote>

<p>
This allows the assignment operator to be adjusted appropriately:
</p>

<blockquote><pre>requires BackInsertionContainer&lt;Cont, Cont::value_type const&amp;&gt; &amp;&amp;
         CopyConstructible&lt;Cont::value_type&gt;
  back_insert_iterator&lt;Cont&gt;&amp; 
  operator=(const Cont::value_type&amp; value);
</pre>
<blockquote>
-1- <i>Effects:</i> <tt>push_back(*container, value);</tt>
</blockquote>
</blockquote>

<p><i>[
We may want to propagate this fix to other concepts such as <tt>StackLikeContainer</tt>.
]</i></p>


<p><i>[
Solution and wording collaborated on by Doug and Howard.
]</i></p>


<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Howard notes that "these operations behaved efficiently until concepts were added."
</p>
<p>
Alisdair is uncertain that the proposed resolution is syntactically correct.
</p>
<p>
Move to Open, and recommend the issue be deferred until after the next
Committee Draft is issued.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 23.2.6.1 [container.concepts.free]:
</p>

<blockquote>
<pre>concept FrontInsertionContainer&lt;typename C<ins>, typename Value = C::value_type&amp;&amp;</ins>&gt;
    : Container&lt;C&gt; { 
  void push_front(C&amp;, <del>value_type&amp;&amp;</del> <ins>Value</ins>); 

  axiom FrontInsertion(C c, <del>value_type</del> <ins>Value</ins> x) { 
    x == (push_front(c, x), front(c)); 
  } 
}
</pre>

<p>...</p>

<pre>concept BackInsertionContainer&lt;typename C<ins>, typename Value = C::value_type&amp;&amp;</ins>&gt;
    : Container&lt;C&gt; { 
  void push_back(C&amp;, <del>value_type&amp;&amp;</del> <ins>Value</ins>); 
}
</pre>

<p>...</p>

<pre>concept InsertionContainer&lt;typename C<ins>, typename Value = C::value_type&amp;&amp;</ins>&gt;
    : Container&lt;C&gt; { 
  iterator insert(C&amp;, const_iterator, <del>value_type&amp;&amp;</del> <ins>Value</ins>); 

  axiom Insertion(C c, const_iterator position, <del>value_type</del> <ins>Value</ins> v) { 
    v == *insert(c, position, v); 
  } 
}
</pre>

</blockquote>

<p>
Change 23.2.6.2 [container.concepts.member]:
</p>

<blockquote>
<pre>auto concept MemberFrontInsertionContainer&lt;typename C<ins>, typename Value = C::value_type&amp;&amp;</ins>&gt;
    : MemberContainer&lt;C&gt; { 
  void C::push_front(<del>value_type&amp;&amp;</del> <ins>Value</ins>); 

  axiom MemberFrontInsertion(C c, <del>value_type</del> <ins>Value</ins> x) { 
    x == (c.push_front(x), c.front()); 
  } 
}
</pre>

<p>...</p>

<pre>auto concept MemberBackInsertionContainer&lt;typename C<ins>, typename Value = C::value_type&amp;&amp;</ins>&gt;
    : MemberContainer&lt;C&gt; { 
  void C::push_back(<del>value_type&amp;&amp;</del> <ins>Value</ins>); 
}
</pre>

<p>...</p>

<pre>auto concept MemberInsertionContainer&lt;typename C<ins>, typename Value = C::value_type&amp;&amp;</ins>&gt;
    : MemberContainer&lt;C&gt; { 
  iterator C::insert(const_iterator, <del>value_type&amp;&amp;</del> <ins>Value</ins>); 

  axiom MemberInsertion(C c, const_iterator position, <del>value_type</del> <ins>Value</ins> v) { 
    v == *c.insert(position, v); 
  } 
}
</pre>
</blockquote>

<p>
Change 23.2.6.3 [container.concepts.maps]:
</p>

<blockquote>
<pre>template &lt;MemberFrontInsertionContainer C<ins>, typename Value = C::value_type&amp;&amp;</ins>&gt; 
concept_map FrontInsertionContainer&lt;C<ins>, Value</ins>&gt; { 
  typedef Container&lt;C&gt;::value_type value_type;

  void push_front(C&amp; c, <del>value_type&amp;&amp;</del> <ins>Value</ins> v) { c.push_front(static_cast&lt;<del>value_type&amp;&amp;</del> <ins>Value</ins>&gt;(v)); } 
}
</pre>

<p>...</p>

<pre>template &lt;MemberBackInsertionContainer C<ins>, typename Value = C::value_type&amp;&amp;</ins>&gt; 
concept_map BackInsertionContainer&lt;C<ins>, Value</ins>&gt; { 
  typedef Container&lt;C&gt;::value_type value_type;

  void push_back(C&amp; c, <del>value_type&amp;&amp;</del> <ins>Value</ins> v) { c.push_back(static_cast&lt;<del>value_type&amp;&amp;</del> <ins>Value</ins>&gt;(v)); } 
}
</pre>

<p>...</p>

<pre>template &lt;MemberInsertionContainer C<ins>, typename Value = C::value_type&amp;&amp;</ins>&gt; 
concept_map InsertionContainer&lt;C<ins>, Value</ins>&gt; { 
  typedef Container&lt;C&gt;::value_type value_type;
  Container&lt;C&gt;::iterator insert(C&amp; c, Container&lt;C&gt;::const_iterator i, <del>value_type&amp;&amp;</del> <ins>Value</ins> v) 
  { return c.insert(i, static_cast&lt;<del>value_type&amp;&amp;</del> <ins>Value</ins>&gt;(v)); } 
}
</pre>

</blockquote>

<p>
Change 24.7.1 [back.insert.iterator]:
</p>

<blockquote><pre>template &lt;BackInsertionContainer Cont&gt; 
class back_insert_iterator {
  ...
  requires <ins>BackInsertionContainer&lt;Cont, const Cont::value_type&amp;&gt;</ins>
           <del>CopyConstructible&lt;Cont::value_type&gt;</del>
    back_insert_iterator&lt;Cont&gt;&amp; 
      operator=(const Cont::value_type&amp; value);
  ...
</pre></blockquote>

<p>
Change 24.7.2.2 [back.insert.iter.op=]:
</p>

<blockquote>
<pre>requires <ins>BackInsertionContainer&lt;Cont, const Cont::value_type&amp;&gt;</ins>
         <del>CopyConstructible&lt;Cont::value_type&gt;</del>
  back_insert_iterator&lt;Cont&gt;&amp; 
    operator=(const Cont::value_type&amp; value);
</pre>
<blockquote>
-1- <i>Effects:</i> <tt>push_back(*container, <del>Cont::value_type(</del>value<del>)</del>);</tt>
</blockquote>
</blockquote>

<p>
Change 24.7.3 [front.insert.iterator]:
</p>

<blockquote><pre>template &lt;FrontInsertionContainer Cont&gt; 
class front_insert_iterator {
  ...
  requires <ins>FrontInsertionContainer&lt;Cont, const Cont::value_type&amp;&gt;</ins>
           <del>CopyConstructible&lt;Cont::value_type&gt;</del>
    front_insert_iterator&lt;Cont&gt;&amp; 
      operator=(const Cont::value_type&amp; value);
  ...
</pre></blockquote>

<p>
Change 24.7.4.2 [front.insert.iter.op=]:
</p>

<blockquote>
<pre>requires <ins>FrontInsertionContainer&lt;Cont, const Cont::value_type&amp;&gt;</ins>
         <del>CopyConstructible&lt;Cont::value_type&gt;</del>
  front_insert_iterator&lt;Cont&gt;&amp; 
    operator=(const Cont::value_type&amp; value);
</pre>
<blockquote>
-1- <i>Effects:</i> <tt>push_front(*container, <del>Cont::value_type(</del>value<del>)</del>);</tt>
</blockquote>
</blockquote>

<p>
Change 24.7.5 [insert.iterator]:
</p>

<blockquote><pre>template &lt;InsertionContainer Cont&gt; 
class insert_iterator {
  ...
  requires <ins>InsertionContainer&lt;Cont, const Cont::value_type&amp;&gt;</ins>
           <del>CopyConstructible&lt;Cont::value_type&gt;</del>
    insert_iterator&lt;Cont&gt;&amp; 
      operator=(const Cont::value_type&amp; value);
  ...
</pre></blockquote>

<p>
Change 24.7.6.2 [insert.iter.op=]:
</p>

<blockquote>
<pre>requires <ins>InsertionContainer&lt;Cont, const Cont::value_type&amp;&gt;</ins>
         <del>CopyConstructible&lt;Cont::value_type&gt;</del>
  insert_iterator&lt;Cont&gt;&amp; 
    operator=(const Cont::value_type&amp; value);
</pre>
<blockquote>
<p>
-1- <i>Effects:</i>
</p>
<blockquote><pre>iter = insert(*container, iter, <del>Cont::value_type(</del>value<del>)</del>); 
++iter;
</pre></blockquote>
</blockquote>
</blockquote>






<hr>
<h3><a name="978"></a>978. Hashing smart pointers</h3>
<p><b>Section:</b> 20.7.17 [unord.hash] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-02-02  <b>Last modified:</b> 2009-05-31</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#unord.hash">active issues</a> in [unord.hash].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#unord.hash">issues</a> in [unord.hash].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I don't see an open issue on supporting <tt>std::hash</tt> for smart pointers
(<tt>unique_ptr</tt> and <tt>shared_ptr</tt> at least).
</p>
<p>
It seems reasonable to at least expect support for the smart
pointers, especially as they support comparison for use in ordered
associative containers.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Howard points out that the client can always supply a custom hash function.
</p>
<p>
Alisdair replies that the smart pointer classes are highly likely
to be frequently used as hash keys.
</p>
<p>
Bill would prefer to be conservative.
</p>
<p>
Alisdair mentions that this issue may also be viewed as a subissue or
duplicate of issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1025">1025</a>.
</p>
<p>
Move to Open, and recommend the issue be deferred until after the next
Committee Draft is issued.
</p>
</blockquote>

<p><i>[
2009-05-31 Peter adds:
]</i></p>


<blockquote>
<blockquote>
Howard points out that the client can always supply a custom hash function.
</blockquote>
<p>
Not entirely true. The client cannot supply the function that hashes the
address of the control block (the equivalent of the old <tt>operator&lt;</tt>, now
proudly carrying the awkward name of '<tt>owner_before</tt>'). Only the
implementation can do that, not necessarily via specializing <tt>hash&lt;&gt;</tt>, of
course.
</p>
<p>
This hash function makes sense in certain situations for <tt>shared_ptr</tt>
(when one needs to switch from <tt>set/map</tt> using ownership ordering to
<tt>unordered_set/map</tt>) and is the only hash function that makes sense for
<tt>weak_ptr</tt>.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="979"></a>979. Bad example</h3>
<p><b>Section:</b> 24.5.3 [move.iterators] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">Tentatively NAD Editorial</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-02-03  <b>Last modified:</b> 2009-05-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20NAD%20Editorial">Tentatively NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
24.5.3 [move.iterators] has an incorrect example:
</p>

<blockquote>
<p>
-2- [<i>Example:</i>
</p>

<blockquote><pre>set&lt;string&gt; s; 
// populate the set s 
vector&lt;string&gt; v1(s.begin(), s.end());          // copies strings into v1 
vector&lt;string&gt; v2(make_move_iterator(s.begin()), 
                  make_move_iterator(s.end())); // moves strings into v2
</pre></blockquote>

<p>
<i>-- end example</i>]
</p>
</blockquote>

<p>
One can not move from a <tt>set</tt> because the iterators return <tt>const</tt>
references.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution. Move to NAD Editorial.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 24.5.3 [move.iterators]/2:
</p>

<blockquote>
<p>
-2- [<i>Example:</i>
</p>

<blockquote><pre><del>set</del><ins>list</ins>&lt;string&gt; s; 
// populate the <del>set</del><ins>list</ins> s 
vector&lt;string&gt; v1(s.begin(), s.end());          // copies strings into v1 
vector&lt;string&gt; v2(make_move_iterator(s.begin()), 
                  make_move_iterator(s.end())); // moves strings into v2
</pre></blockquote>

<p>
<i>-- end example</i>]
</p>
</blockquote>





<hr>
<h3><a name="981"></a>981. Unordered container requirements should add  <tt>initializer_list</tt> support</h3>
<p><b>Section:</b> 23.2.5 [unord.req] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2009-02-08  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#unord.req">active issues</a> in [unord.req].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#unord.req">issues</a> in [unord.req].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Refering to
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2800.pdf">N2800</a>
all container requirements tables (including those for
associative containers) provide useful member function overloads
accepting <tt>std::initializer_list</tt> as argument, the only exception is
Table 87. There seems to be no reason for not providing them, because 23.5 [unord]
is already <tt>initializer_list</tt>-aware. For the sake of 
library interface consistency and user-expectations corresponding 
overloads should be added to the table requirements of unordered 
containers as well.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We agree with the proposed resolution.
</p>
<p>
Move to Tentatively Ready.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>

<p>
In 23.2.5 [unord.req]/9 insert:
</p>

<blockquote>
... <tt>[q1, q2)</tt> is a valid range in <tt>a</tt>, <ins><tt>il</tt>
designates an object of type <tt>initializer_list&lt;value_type&gt;</tt>, </ins><tt>t</tt> is a value of type
<tt>X::value_type</tt>, ...
</blockquote>

<p>
In 23.2.5 [unord.req], Table 87 insert:
</p>

<blockquote>
<table border="1">
<caption>Table 87 - Unordered associative container requirements (in addition to container)</caption>
<tbody><tr>
<th>Expression</th> <th>Return type</th> <th>Assertion/note<br>pre-/post-condition</th> <th>Complexity</th>
</tr>
<tr>
<td><tt>X(i, j)<br>X a(i, j)</tt></td> <td><tt>X</tt></td> <td>...</td> <td>...</td>
</tr>
<tr>
<td><ins><tt>X(il)</tt></ins></td> <td><ins><tt>X</tt></ins></td> 
<td><ins>Same as <tt>X(il.begin(), il.end())</tt>.</ins></td> 
<td><ins>Same as <tt>X(il.begin(), il.end())</tt>.</ins></td>
</tr>
<tr>
<td>...</td> <td>...</td> <td>...</td> <td>...</td>
</tr>
<tr>
<td><tt>a = b</tt></td> <td><tt>X</tt></td> <td>...</td> <td>...</td>
</tr>
<tr>
<td><ins><tt>a = il</tt></ins></td> <td><ins><tt>X&amp;</tt></ins></td> 
<td><ins><tt>a = X(il); return *this;</tt></ins></td> 
<td><ins>Same as <tt>a = X(il)</tt>.</ins></td>
</tr>
<tr>
<td>...</td> <td>...</td> <td>...</td> <td>...</td>
</tr>
<tr>
<td><tt>a.insert(i, j)</tt></td> <td><tt>void</tt></td> <td>...</td> <td>...</td>
</tr>
<tr>
<td><ins><tt>a.insert(il)</tt></ins></td> <td><ins><tt>void</tt></ins></td> 
<td><ins>Same as <tt>a.insert(il.begin(), il.end())</tt>.</ins></td> 
<td><ins>Same as <tt>a.insert(il.begin(), il.end())</tt>.</ins></td>
</tr>
</tbody></table>
</blockquote>






<hr>
<h3><a name="982"></a>982. Wrong complexity for initializer_list assignment in  Table 85</h3>
<p><b>Section:</b> 23.2.4 [associative.reqmts] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2009-02-08  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#associative.reqmts">active issues</a> in [associative.reqmts].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#associative.reqmts">issues</a> in [associative.reqmts].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
According to
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2800.pdf">N2800</a>,
the associative container requirements table 85 says
    that assigning an <tt>initializer_list</tt> to such a container is of
    constant complexity, which is obviously wrong.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We agree with the proposed resolution.
</p>
<p>
Move to Tentatively Ready.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>

<p>
In 23.2.4 [associative.reqmts], Table 85 change:
</p>

<blockquote>
<table border="1">
<caption>Table 85 - Associative container requirements (in addition to container)</caption>
<tbody><tr>
<th>Expression</th> <th>Return type</th> <th>Assertion/note<br>pre-/post-condition</th> <th>Complexity</th>
</tr>
<tr>
<td><tt>a = il</tt></td> <td><tt>X&amp;</tt></td> <td><tt>a = X(il);<br>return *this;</tt></td> 
<td><del>constant</del><ins>Same as <tt>a = X(il)</tt>.</ins></td>
</tr>
</tbody></table>
</blockquote>






<hr>
<h3><a name="983"></a>983. <tt>unique_ptr</tt> reference deleters should not be moved from</h3>
<p><b>Section:</b> 20.8.12.2 [unique.ptr.single] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Review">Review</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-02-10  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#unique.ptr.single">active issues</a> in [unique.ptr.single].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#unique.ptr.single">issues</a> in [unique.ptr.single].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Review">Review</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Dave brought to my attention that when a <tt>unique_ptr</tt> has a non-const reference
type deleter, move constructing from it, even when the <tt>unique_ptr</tt> containing
the reference is an rvalue, could have surprising results:
</p>

<blockquote><pre>D d(some-state);
unique_ptr&lt;A, D&amp;&gt; p(new A, d);
unique_ptr&lt;A, D&gt; p2 = std::move(p);
<font color="#c80000">// has d's state changed here?</font>
</pre></blockquote>

<p>
I agree with him.  It is the <tt>unique_ptr</tt> that is the rvalue, not the
deleter.  When the deleter is a reference type, the <tt>unique_ptr</tt> should
respect the "lvalueness" of the deleter.
</p>

<p>
Thanks Dave.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Seems correct, but complicated enough that we recommend moving to Review.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 20.8.12.2.1 [unique.ptr.single.ctor], p20-21
</p>

<blockquote>
<pre>template &lt;class U, class E&gt; unique_ptr(unique_ptr&lt;U, E&gt;&amp;&amp; u);
</pre>

<blockquote>

<p>
-20- <i>Requires:</i> If <tt><del>D</del> <ins>E</ins></tt> is not a reference type,
construction of the deleter <tt>D</tt> from an rvalue of type <tt>E</tt>
shall be well formed and shall not throw an exception.
<ins>
Otherwise <tt>E</tt> is a reference type and construction of the deleter
<tt>D</tt> from an lvalue of type <tt>E</tt> shall be well formed and
shall not throw an exception.
</ins>
If <tt>D</tt> is
a reference type, then <tt>E</tt> shall be the same type as <tt>D</tt>
(diagnostic required). <tt>unique_ptr&lt;U, E&gt;::pointer</tt> shall be
implicitly convertible to <tt>pointer</tt>. [<tt>Note:</tt> These
requirements imply that <tt>T</tt> and <tt>U</tt> are complete types.
<i>-- end note</i>]
</p>

<p>
-21- <i>Effects:</i> Constructs a <tt>unique_ptr</tt> which owns the
pointer which <tt>u</tt> owns (if any). If the deleter
<ins><tt>E</tt></ins> is not a reference type, <del>it</del> <ins>this
deleter</ins> is move constructed from <tt>u</tt>'s deleter, otherwise
<del>the reference</del> <ins>this deleter</ins> is copy constructed
from <tt>u</tt>.'s deleter. After the construction, <tt>u</tt> no longer
owns a pointer. [<i>Note:</i> The deleter constructor can be implemented
with <tt>std::forward&lt;<del>D</del><ins>E</ins>&gt;</tt>. <i>-- end
note</i>]
</p>

</blockquote>
</blockquote>

<p>
Change 20.8.12.2.3 [unique.ptr.single.asgn], p1-3
</p>

<blockquote>
<pre>unique_ptr&amp; operator=(unique_ptr&amp;&amp; u);
</pre>
<blockquote>

<p>
-1- <i>Requires:</i> <ins>If the deleter <tt>D</tt> is not a reference type,</ins>
<del>A</del><ins>a</ins>ssignment of the deleter <tt>D</tt> from an rvalue <tt>D</tt> shall not throw an exception.
<ins>
Otherwise the deleter <tt>D</tt> is a reference type,
and assignment of the deleter <tt>D</tt> from an lvalue <tt>D</tt> shall not throw an exception.</ins>
</p>

<p>
-2- <i>Effects:</i> reset(u.release()) followed by
a<ins>n</ins> <del>move</del> assignment from <del><tt>u</tt>'s deleter to this deleter</del>
<ins><tt>std::forward&lt;D&gt;(u.get_deleter())</tt></ins>.
</p>

<p>
-3- <i>Postconditions:</i> This <tt>unique_ptr</tt> now owns the pointer
which <tt>u</tt> owned, and <tt>u</tt> no longer owns it. <del>[<i>Note:</i> If
<tt>D</tt> is a reference type, then the referenced lvalue deleters are
move assigned. <i>-- end note</i>]</del>
</p>
</blockquote>
</blockquote>

<p>
Change 20.8.12.2.3 [unique.ptr.single.asgn], p6-7
</p>

<blockquote>
<pre>template &lt;class U, class E&gt; unique_ptr&amp; operator=(unique_ptr&lt;U, E&gt;&amp;&amp; u);
</pre>
<blockquote>

<p>
<i>Requires:</i> <ins>If the deleter <tt>E</tt> is not a reference type,</ins>
<del>A</del><ins>a</ins>ssignment of the deleter <tt>D</tt> from an rvalue
<tt><del>D</del><ins>E</ins></tt> shall not throw an exception.
<ins>
Otherwise the deleter <tt>E</tt> is a reference type,
and assignment of the deleter <tt>D</tt> from an lvalue <tt>E</tt> shall not throw an exception.</ins>
<tt>unique_ptr&lt;U, E&gt;::pointer</tt> shall be implicitly convertible to <tt>pointer</tt>.
[<i>Note:</i> These requirements imply that <tt>T</tt> and <tt>U&gt;</tt>
are complete types. <i>-- end note</i>]
</p>

<p>
<i>Effects:</i> <tt>reset(u.release())</tt> followed by
a<ins>n</ins> <del>move</del> assignment from <del><tt>u</tt>'s deleter to this deleter</del>
<ins><tt>std::forward&lt;E&gt;(u.get_deleter())</tt></ins>.
<del>If either
<tt>D</tt> or <tt>E</tt> is a reference type, then the referenced lvalue
deleter participates in the move assignment.</del>
</p>

</blockquote>
</blockquote>






<hr>
<h3><a name="984"></a>984. Does <tt>&lt;cinttypes&gt;</tt> have macro guards?</h3>
<p><b>Section:</b> 27.9.2 [c.files] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-02-12  <b>Last modified:</b> 2009-05-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The C standard says about <tt>&lt;inttypes.h&gt;</tt>:
</p>

<blockquote>
C++ implementations should define these macros only when <tt>__STDC_FORMAT_MACROS</tt>is defined 
before <tt>&lt;inttypes.h&gt;</tt> is included.
</blockquote>

<p>
The C standard has a similar note about <tt>&lt;stdint.h&gt;</tt>.  For <tt>&lt;cstdint&gt;</tt>
we adopted a "thanks but no thanks" policy and documented that fact in
18.4.1 [cstdint.syn]:
</p>

<blockquote>
... [<i>Note:</i> The macros defined by <tt>&lt;stdint&gt;</tt> are
provided unconditionally. In particular, the symbols
<tt>__STDC_LIMIT_MACROS</tt> and <tt>__STDC_CONSTANT_MACROS</tt>
(mentioned in C99 footnotes 219, 220, and 222) play no role in C++.
<i>-- end note</i>]
</blockquote>

<p>
I recommend we put a similar note in 27.9.2 [c.files] regarding <tt>&lt;cinttypes&gt;</tt>.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution.
Move to Tentatively Ready.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Add to 27.9.2 [c.files]:
</p>

<blockquote>
Table 112 describes header <tt>&lt;cinttypes&gt;</tt>.
<ins>
[<i>Note:</i> The macros defined by <tt>&lt;cintypes&gt;</tt> are
provided unconditionally. In particular, the symbol
<tt>__STDC_FORMAT_MACROS</tt>
(mentioned in C99 footnote 182) plays no role in C++.
<i>-- end note</i>]
</ins>
</blockquote>





<hr>
<h3><a name="985"></a>985. Allowing throwing move</h3>
<p><b>Section:</b> 23.2.1 [container.requirements.general] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Rani Sharoni <b>Opened:</b> 2009-02-12  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#container.requirements.general">active issues</a> in [container.requirements.general].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#container.requirements.general">issues</a> in [container.requirements.general].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<b>Introduction</b>
</p>

<p>This proposal is meant to resolve potential regression of the
<a href="" ref="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2800.pdf">N2800</a>
draft, see
next section, and to relax the requirements for containers of types with
throwing move constructors.</p>

<p>The basic problem is that some containers operations, like <tt>push_back</tt>,
have a strong exception safety
guarantee (i.e. no side effects upon exception) that are not achievable when
throwing move constructors are used since there is no way to guarantee revert
after partial move. For such operations the implementation can at most provide
the basic guarantee (i.e. valid but unpredictable) as it does with multi
copying operations (e.g. range insert).</p>

<p>For example, <tt>vector&lt;T&gt;::push_back()</tt> (where <tt>T</tt> has a move
constructor) might resize the <tt>vector</tt> and move the objects to the new underlying
buffer. If move constructor throws it might
not be possible to recover the throwing object or to move the old objects back to
the original buffer.</p>

<p>The current draft is explicit by disallowing throwing move
for some operations (e.g. <tt>vector&lt;&gt;::reserve</tt>) and not clear about other
operations mentioned in 23.2.1 [container.requirements.general]/10
(e.g. single element <tt>insert</tt>): it guarantees strong exception
safety without explicitly disallowing a throwing move constructor.
</p>

<p>
<b>Regression</b>
</p>

<p>This section only refers to cases in which the contained object
is by itself a standard container.</p>

<p>Move constructors of standard containers are allowed to throw and therefore
existing operations are broken, compared with C++03, due to move optimization.
(In fact existing implementations like Dinkumware are actually throwing).</p>

<p>For example, <tt>vector&lt; list&lt;int&gt; &gt;::reserve</tt> yields
undefined behavior since <tt>list&lt;int&gt;</tt>'s move constructor is allowed to throw.
On the other hand, the same operation has strong exception safety guarantee in
C++03.</p>

<p>There are few options to solve this regression:</p>

<ol>
<li>
Disallow throwing move and throwing default constructor
</li>

<li>
Disallow throwing move but disallowing usage after move
</li>

<li>
Special casing
</li>

<li>
Disallow throwing move and making it optional
</li>

</ol>

<p>Option 1 is suggested by proposal
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2815.html">N2815</a>
but it might not be applicable for existing implementations for which
containers default constructors are throwing.</p>

<p>Option 2 limits the usage significantly and it's error prone
by allowing zombie objects that are nothing but destructible (e.g. no <tt>clear()</tt>
is allowed after move). It also potentially complicates the implementation by
introducing special state.</p>

<p>Option 3 is possible, for example, using default
construction and <tt>swap</tt> instead of move for standard containers case. The
implementation is also free to provide special hidden operation for non
throwing move without forcing the user the cope with the limitation of option-2
when using the public move.</p>

<p>Option 4 impact the efficiency in all use cases due to rare throwing move.</p>

<p>The proposed wording will imply option 1 or 3 though option 2 is also
achievable using more wording. I personally oppose to option 2 that has impact
on usability.</p>

<p>
<b>Relaxation for user types</b>
</p>

<p>Disallowing throwing move constructors in general seems very restrictive
since, for example, common implementation of move will be default construction
+ <tt>swap</tt> so move will throw if the
default constructor will throw. This is currently the case with the Dinkumware
implementation of node based containers (e.g. <tt>std::list</tt>)
though this section doesn't refer to standard types.</p>

<p>For throwing move constructors it seem that the implementation should have
no problems to provide the basic guarantee instead of the strong one. It's
better to allow throwing move constructors with basic guarantee than to
disallow it silently (compile and run), via undefined behavior.</p>

<p>There might still be cases in which the relaxation will break existing generic
code that assumes the strong guarantee but it's broken either way given a
throwing move constructor since this is not a preserving optimization. </p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Bjarne comments (referring to his draft paper):
"I believe that my suggestion simply solves that.
Thus, we don't need a throwing move."
</p>
<p>
Move to Open and recommend it be deferred until after the next
Committee Draft is issued.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>

<p>
23.2.1 [container.requirements.general]  paragraph 10 add footnote:
</p>

<blockquote>
<p>
-10- Unless otherwise specified (see 23.1.4.1, 23.1.5.1, 23.2.2.3, and
23.2.6.4) all container types defined in this Clause meet the following
additional requirements:
</p>
<ul>
<li>...</li>
</ul>

<p>
<ins>[<i>Note</i>: for compatibility with C++
2003, when "no effect" is required, standard containers should not use the
value_type's throwing move constructor when the contained object is by itself a
standard container. -- <i>end note</i>]</ins>
</p>

</blockquote>

<p>23.2.5.1 [unord.req.except] change paragraph 2 to say: </p>

<blockquote>
<p>
-2- For unordered associative containers, if an exception is
thrown by any operation other than the container's hash function from within an
<tt>insert()</tt> function inserting a single element, the <tt>insert()</tt>
function has no effect<ins> unless the exception is thrown by the contained
object move constructor</ins>.
</p>

<p>
-4- For unordered associative containers, if an exception is
thrown from within a <tt>rehash()</tt> function other than by the container's hash
function or comparison function, the <tt>rehash()</tt> function has no effect
<ins>unless the exception is thrown by the contained
object move constructor</ins>.</p>

</blockquote>

<p>
23.3.2.3 [deque.modifiers] change paragraph 2 to say:
</p>

<blockquote>
-2- <i>Remarks:</i> If an exception is thrown other than by
the copy constructor<ins>, move constructor</ins>
or assignment operator of <tt>T</tt>
there are no effects.
<ins>If an exception is thrown by <tt>push_back()</tt> or <tt>emplace_back()</tt>
function, that function has no effects unless the exception is thrown by
the move constructor of <tt>T</tt>.</ins>
</blockquote>

<p>
23.3.2.3 [deque.modifiers] change paragraph 6 to say:
</p>

<blockquote>
-6- <i>Throws:</i> Nothing unless an exception is thrown by the copy
constructor<ins>, move constructor</ins> or assignment operator of <tt>T</tt>.
</blockquote>

<p>
23.3.6.2 [vector.capacity] remove paragraph 2
</p>

<blockquote>
<del>-2- <i>Requires:</i> If <tt>value_type</tt> has a move constructor,
that constructor shall not throw any exceptions.</del>
</blockquote>

<p>
23.3.6.2 [vector.capacity] paragraph 3 change to say:
</p>

<blockquote>
-3- <i>Effects:</i> A directive that informs a <tt>vector</tt>
of a planned change in size, so
that it can manage the storage allocation accordingly. After <tt>reserve()</tt>,
<tt>capacity()</tt> is greater or equal to the argument of <tt>reserve</tt>
if reallocation happens; and equal
to the previous value of <tt>capacity()</tt>
otherwise. Reallocation happens at this point if and only if the current
capacity is less than the argument of <tt>reserve()</tt>.
If an exception is thrown, there are no effects<ins>
unless the exception is thrown by the contained object move constructor</ins>.
</blockquote>

<p>
23.3.6.2 [vector.capacity] paragraph 12 change to say:
</p>

<blockquote>
-12- <i>Requires:</i> <del>If <tt>value_type</tt> has a move constructor,
that constructor shall not throw any exceptions.</del>
<ins>If an exception is thrown, there are no effects unless the exception is thrown by
the contained object move constructor.</ins>
</blockquote>

<p>
23.3.6.4 [vector.modifiers] change paragraph 1 to say:
</p>

<blockquote>
-1- <del><i>Requires:</i> If <tt>value_type</tt> has a move constructor,
that constructor shall not throw any exceptions.</del>
<ins><i>Remarks:</i> If an exception is thrown by <tt>push_back()</tt>
or <tt>emplace_back()</tt> function, that function has no effect unless the
exception is thrown by the move constructor of <tt>T</tt>.</ins>
</blockquote>

<p>
23.3.6.4 [vector.modifiers] change paragraph 2 to say:
</p>

<blockquote>
-2- <i>Remarks:</i> Causes reallocation if the new size is greater than
the old capacity. If no reallocation happens, all the iterators and
references before the insertion point remain valid. If an exception is
thrown other than by the copy constructor<ins>, move constructor</ins>
or assignment operator of <tt>T</tt> or by any <tt>InputIterator</tt>
operation there are no effects.
</blockquote>

<p>
23.3.6.4 [vector.modifiers] change paragraph 6 to say:
</p>

<blockquote>
-6- <i>Throws:</i> Nothing unless an exception is thrown by the copy
constructor<ins>, move constructor</ins> or assignment operator of <tt>T</tt>.
</blockquote>






<hr>
<h3><a name="986"></a>986. Generic <tt>try_lock</tt> contradiction</h3>
<p><b>Section:</b> 30.4.4 [thread.lock.algorithm] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Chris Fairles <b>Opened:</b> 2009-02-14  <b>Last modified:</b> 2009-05-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 30.4.4 [thread.lock.algorithm], the generic <tt>try_lock</tt> effects (p2) say that a failed
<tt>try_lock</tt> is when it either returns <tt>false</tt> or throws an exception. In
the event a call to <tt>try_lock</tt> does fail, by either returning <tt>false</tt> or
throwing an exception, it states that <tt>unlock</tt> shall be called for all
prior arguments. Then the returns clause (p3) goes on to state
in a note that after returning, either all locks are locked or none
will be. So what happens if multiple locks fail on <tt>try_lock</tt>?
</p>

<p>
Example:
</p>

<blockquote><pre>#include &lt;mutex&gt;

int main() {
 std::mutex m0, m1, m2;
 std::unique_lock&lt;std::mutex&gt; l0(m0, std::defer_lock);
 std::unique_lock&lt;std::mutex&gt; l1(m1); //throws on try_lock
 std::unique_lock&lt;std::mutex&gt; l2(m2); //throws on try_lock

 int result = std::try_lock(l0, l1, l2);

 assert( !l0.owns_lock() );
 assert( l1.owns_lock() ); //??
 assert( l2.owns_lock() ); //??
}
</pre></blockquote>

<p>
The first lock's <tt>try_lock</tt> succeeded but, being a prior argument to a
lock whose <tt>try_lock</tt> failed, it gets unlocked as per the effects clause
of 30.4.4 [thread.lock.algorithm]. However, 2 locks remain locked in this case but the return
clause states that either all arguments shall be locked or none will
be. This seems to be a contradiction unless the intent is for
implementations to make an effort to unlock not only prior arguments,
but the one that failed and those that come after as well. Shouldn't
the note only apply to the arguments that were successfully locked?
</p>

<p>
Further discussion and possible resolutions in c++std-lib-23049.
</p>

<p><i>[
Summit:
]</i></p>

<blockquote>
Move to review. Agree with proposed resolution.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution.
Move to Tentatively Ready.
</blockquote>


<p><b>Proposed resolution:</b></p>

<p>
Change 30.4.4 [thread.lock.algorithm], p2:
</p>

<blockquote>
-2- <i>Effects:</i> Calls <tt>try_lock()</tt> for each argument in order
beginning with the first until all arguments have been processed or a
call to <tt>try_lock()</tt> fails, either by returning <tt>false</tt> or by throwing an
exception. If a call to <tt>try_lock()</tt> fails, <tt>unlock()</tt> shall be called for
all prior arguments<ins> and there shall be no further calls to <tt>try_lock()</tt></ins>.
</blockquote>

<p>
Delete the note from 30.4.4 [thread.lock.algorithm], p3
</p>

<blockquote>
-3- <i>Returns:</i> -1 if all calls to <tt>try_lock()</tt> returned <tt>true</tt>,
otherwise a 0-based index value that indicates 
the argument for which <tt>try_lock()</tt> returned <tt>false</tt>. <del>[<i>Note:</i>
On return, either all arguments will be 
locked or none will be locked. -- <i>end note</i>]</del>
</blockquote>





<hr>
<h3><a name="987"></a>987. <tt>reference_wrapper</tt> and function types</h3>
<p><b>Section:</b> 20.7.5 [refwrap] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Review">Review</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-02-18  <b>Last modified:</b> 2009-05-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#refwrap">issues</a> in [refwrap].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Review">Review</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The synopsis in 20.7.5 [refwrap] says:
</p>

<blockquote><pre>template &lt;<b>ObjectType</b> T&gt; class reference_wrapper
...
</pre></blockquote>

<p>
And then paragraph 3 says:
</p>

<blockquote>
<p>
The template instantiation <tt>reference_wrapper&lt;T&gt;</tt> shall be
derived from <tt>std::unary_function&lt;T1, R&gt;</tt> only if the type
<tt>T</tt> is any of the following:
</p>

<ul>
<li>
a <b>function type</b> or a pointer to function type taking one argument of
type <tt>T1</tt> and returning <tt>R</tt>
</li>
</ul>
</blockquote>

<p>
But function types are not <tt>ObjectType</tt>s.
</p>

<p>
Paragraph 4 contains the same contradiction.
</p>

<p><i>[
Post Summit:
]</i></p>


<blockquote>
<p>
Jens: restricted reference to ObjectType
</p>
<p>
Recommend Review.
</p>
</blockquote>

<p><i>[
Post Summit, Peter adds:
]</i></p>


<blockquote>
<p>
In <a href="https://svn.boost.org/trac/boost/ticket/1846">https://svn.boost.org/trac/boost/ticket/1846</a>
however Eric Niebler makes the very reasonable point that <tt>reference_wrapper&lt;F&gt;</tt>,
where <tt>F</tt> is a function type, represents a reference to a function,
a legitimate entity. So <tt>boost::ref</tt> was changed to allow it.
</p>
<p>
<a href="https://svn.boost.org/trac/boost/browser/trunk/libs/bind/test/ref_fn_test.cpp">https://svn.boost.org/trac/boost/browser/trunk/libs/bind/test/ref_fn_test.cpp</a>
</p>
<p>
Therefore, I believe an alternative proposed resolution for issue 987 could simply
allow <tt>reference_wrapper</tt> to be used with function types.
</p>
</blockquote>

<p><i>[
Post Summit, Howard adds:
]</i></p>


<blockquote>
<p>
I agree with Peter (and Eric).  I got this one wrong on my first try.  Here
is code that demonstrates how easy (and useful) it is to instantiate
<tt>reference_wrapper</tt> with a function type:
</p>

<blockquote><pre>#include &lt;functional&gt;

template &lt;class F&gt;
void test(F f);

void f() {}

int main()
{
    test(std::ref(f));
}
</pre></blockquote>

<p>
Output (link time error shows type of <tt>reference_wrapper</tt> instantiated
with function type):
</p>

<blockquote><pre>Undefined symbols:
  "void test&lt;std::reference_wrapper&lt;void ()()&gt; &gt;(std::reference_wrapper&lt;void ()()&gt;)",...
</pre></blockquote>

<p>
I've taken the liberty of changing the proposed wording to allow function types
and set to Open.  I'll also freely admit that I'm not positive <tt>ReferentType</tt>
is the correct concept.
</p>

</blockquote>



<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Howard observed that <tt>FunctionType</tt>,
a concept not (yet?) in the Working Paper,
is likely the correct constraint to be applied.
However, the proposed resolution provides an adequate approximation.
</p>
<p>
Move to Review.
</p>
</blockquote>

<p><i>[
2009-05-23 Alisdair adds:
]</i></p>


<blockquote>
<p>
By constraining to <tt>PointeeType</tt> we rule out the ability for <tt>T</tt> to be a
reference, and call in reference-collapsing.  I'm not sure if this is
correct and intended, but would like to be sure the case was considered.
</p>
<p>
Is dis-allowing reference types and the
implied reference collapsing the intended result?
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change the synopsis in 20.7 [function.objects]:
</p>

<blockquote><pre>// 20.6.5, reference_wrapper:
template &lt;<del>ObjectType</del> <ins>ReferentType</ins> T&gt;
  <ins>requires PointeeType&lt;T&gt;</ins>
  class reference_wrapper;

template &lt;<del>ObjectType</del> <ins>PointeeType</ins> T&gt;
  reference_wrapper&lt;T&gt; ref(T&amp;);

template &lt;<del>ObjectType</del> <ins>PointeeType</ins> T&gt;
  reference_wrapper&lt;const T&gt; cref(const T&amp;);

template &lt;<del>ObjectType</del> <ins>PointeeType</ins> T&gt;
  reference_wrapper&lt;T&gt; ref(reference_wrapper&lt;T&gt;);
template &lt;<del>ObjectType</del> <ins>PointeeType</ins> T&gt;
  reference_wrapper&lt;const T&gt; cref(reference_wrapper&lt;T&gt;);
</pre></blockquote>

<p>
Change the synopsis in 20.7.5 [refwrap]:
</p>

<blockquote><pre>template &lt;<del>ObjectType</del> <ins>ReferentType</ins> T&gt;
  <ins>requires PointeeType&lt;T&gt;</ins>
  class reference_wrapper
   ...
</pre></blockquote>

<p>
Change the prototypes in 20.7.5.5 [refwrap.helpers]:
</p>

<blockquote><pre>template &lt;<del>ObjectType</del> <ins>PointeeType</ins> T&gt;
  reference_wrapper&lt;T&gt; ref(T&amp;);
...
template &lt;<del>ObjectType</del> <ins>PointeeType</ins> T&gt;
  reference_wrapper&lt;const T&gt; cref(const T&amp;);
...
template &lt;<del>ObjectType</del> <ins>PointeeType</ins> T&gt;
  reference_wrapper&lt;T&gt; ref(reference_wrapper&lt;T&gt;);
...
template &lt;<del>ObjectType</del> <ins>PointeeType</ins> T&gt;
  reference_wrapper&lt;const T&gt; cref(reference_wrapper&lt;T&gt;);
</pre></blockquote>



<p><b>Rationale:</b></p>
<p>
a) The occurrence of <tt>T&amp;</tt> in the function signature auto-implies
<tt>std::ReferentType</tt>,
this is due to 14.11.1.2 [temp.req.impl]/4 bullet 4
</p>
<p>
b) The occurrence of the constrained template <tt>reference_wrapper&lt;T&gt;</tt> in
the remaining
signatures lets kick in 14.11.1.2 [temp.req.impl]/4 bullet 1 and adds *all* requirements of
this template. But we need to add at least *one* requirement (and it
was an arbitrary,
but natural decision to require <tt>std::PointeeType</tt> here) to *activate*
this. If we hadn't done
this, we were in unconstrained mode!
</p>





<hr>
<h3><a name="988"></a>988. <tt>Reflexivity</tt> meaningless?</h3>
<p><b>Section:</b> 20.2.6 [concept.comparison] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-02-24  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#concept.comparison">active issues</a> in [concept.comparison].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#concept.comparison">issues</a> in [concept.comparison].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
20.2.6 [concept.comparison] p2:
</p>
<p>
Due to the subtle meaning of <tt>==</tt> inside axioms, the <tt>Reflexivity</tt> axiom does
not do anything as written. It merely states that a value is substitutable
with itself, rather than asserting a property of the <tt>==</tt> operator.
</p>

<b>
Original proposed resolution:
</b>

<p>
Change the definition of <tt>Reflexivity</tt> in 20.2.6 [concept.comparison]:
</p>

<blockquote><pre>axiom Reflexivity(T a) { <ins>(</ins>a == a<ins>) == true</ins>; }
</pre></blockquote>

<p><i>[
Post Summit:
]</i></p>


<blockquote>
<p>
Alisdair: I was wrong.
</p>
<p>
Recommend NAD.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
NAD.
</p>





<hr>
<h3><a name="989"></a>989. late_check and library</h3>
<p><b>Section:</b> 17 [library] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-02-24  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The example in 6.9p2 shows how late_check blocks inhibit concept_map lookup
inside a constrained context, and so inhibit concept map adaption by users
to meet template requirements.
</p>
<p>
Do we need some text in clause 17 prohibitting use of late_check in library
template definitions unless otherwise documented?
</p>

<p><i>[
Doug adds:
]</i></p>


<blockquote>
We need something like this, but it should be a more general statement
about implementations respecting the concept maps provided by the
user. Use of late_check is one way in which implementations can
subvert the concept maps provided by the user, but there are other
ways as well ("pattern-based" overloading, tricks with "auto" concept
maps and defaulted associated type arguments).
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Move to Open, pending proposed wording from Alisdair and/or Doug for further review.
</blockquote>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="990"></a>990. <tt>monotonic_clock::is_monotonic</tt> must be <tt>true</tt></h3>
<p><b>Section:</b> 20.9.5.2 [time.clock.monotonic] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-03-09  <b>Last modified:</b> 2009-05-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There is some confusion over what the value of <tt>monotonic_clock::is_monotonic</tt>
when <tt>monotonic_clock</tt> is a  synonym for <tt>system_clock</tt>.  The
intent is that if <tt>monotonic_clock</tt> exists, then <tt>monotonic_clock::is_monotonic</tt>
is <tt>true</tt>.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We agree with the proposed resolution.
</p>
<p>
Move to Tentatively Ready.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 20.9.5.2 [time.clock.monotonic], p1:
</p>

<blockquote>
-1- Objects of class <tt>monotonic_clock</tt> represent clocks for which
values of <tt>time_point</tt> never decrease as physical time advances.
<tt>monotonic_clock</tt> may be a synonym for <tt>system_clock</tt>
<ins>if and only if <tt>system_clock::is_monotonic</tt> is
<tt>true</tt></ins>.
</blockquote>





<hr>
<h3><a name="991"></a>991. Response to JP 50</h3>
<p><b>Section:</b> 22.3.3.2.2 [conversions.string] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> P.J. Plauger <b>Opened:</b> 2009-03-03  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#conversions.string">active issues</a> in [conversions.string].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#conversions.string">issues</a> in [conversions.string].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Add custom allocator parameter to <tt>wstring_convert</tt>, since we cannot
allocate memory for strings from a custom allocator.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution.
Move to Tentatively Ready.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 22.3.3.2.2 [conversions.string]:
</p>

<blockquote><pre>template&lt;class Codecvt, class Elem = wchar_t<ins>,
         class Wide_alloc = std::allocator&lt;Elem&gt;,
         class Byte_alloc = std::allocator&lt;char&gt; </ins>&gt; class wstring_convert {
  public:
    typedef std::basic_string&lt;char<ins>, char_traits&lt;char&gt;, Byte_alloc</ins>&gt; byte_string;
    typedef std::basic_string&lt;Elem<ins>, char_traits&lt;Elem&gt;, Wide_alloc</ins>&gt; wide_string;
     ...
</pre></blockquote>

<p>
Change 22.3.3.2.2 [conversions.string], p3:
</p>

<blockquote>
-3- The class template describes an ob ject that controls conversions
between wide string ob jects of class
<tt>std::basic_string&lt;Elem<ins>, char_traits&lt;Elem&gt;, Wide_alloc</ins>&gt;</tt>
and byte string objects of class
<tt>std::basic_string&lt;char<ins>, char_traits&lt;char&gt;, Byte_alloc</ins>&gt;</tt>
<del>(also known as <tt>std::string</tt>)</del>.
</blockquote>






<hr>
<h3><a name="992"></a>992. Response to UK 169</h3>
<p><b>Section:</b> 17.6.1.1 [contents] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> P.J. Plauger <b>Opened:</b> 2009-03-03  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#contents">active issues</a> in [contents].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#contents">issues</a> in [contents].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
This phrasing contradicts later freedom to implement the C standard
library portions in the global namespace as well as std. (17.6.2.3p4)
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
The proposed wording seems to go too far.
Move back to Open.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 17.6.1.1 [contents], p2:
</p>

<blockquote>
-2- All library entities except <ins>those from the Standard C
library,</ins> macros, <tt>operator new</tt> and <tt>operator
delete</tt> are defined within the namespace <tt>std</tt> or namespaces
nested within namespace <tt>std</tt>.
</blockquote>






<hr>
<h3><a name="993"></a>993. Response to UK 188</h3>
<p><b>Section:</b> 18.5 [support.start.term] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> P.J. Plauger <b>Opened:</b> 2009-03-03  <b>Last modified:</b> 2009-05-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#support.start.term">issues</a> in [support.start.term].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The function <tt>_Exit</tt> does not appear to be defined in this standard.
Should it be added to the table of functions included-by-reference to
the C standard?
</p>

<p><i>[
2009-05-09 Alisdair fixed some minor issues in the wording.
]</i></p>


<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution.
Move to Tentatively Ready.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Add to 18.5 [support.start.term] Table 20 (Header
<tt>&lt;cstdlib&gt;</tt> synopsis) Functions:
</p>

<blockquote><pre>_Exit
</pre></blockquote>

<p>
Add before the description of <tt>abort(void)</tt>:
</p>

<blockquote><pre>void _Exit [[noreturn]] (int status)
</pre>

<blockquote>
<p>
The function <tt>_Exit(int status)</tt> has additional behavior in this
International Standard:
</p>
<ul>
<li>
The program is terminated without executing destructors for objects of
automatic, thread, or static storage duration and without calling the
functions passed to <tt>atexit()</tt> (3.6.3 [basic.start.term]).
</li>
</ul>
</blockquote>
</blockquote>






<hr>
<h3><a name="994"></a>994. Response to UK 193</h3>
<p><b>Section:</b> 18.6.2.2 [new.handler] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> P.J. Plauger <b>Opened:</b> 2009-03-03  <b>Last modified:</b> 2009-05-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>quick_exit</tt> has been added as a new valid way to terminate a program in a
well defined way
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution.
Move to Tentatively Ready.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 18.6.2.2 [new.handler], p2:
</p>

<blockquote>
<p>
-2- <i>Required behavior:</i> ...
</p>
<ul>
<li>...</li>
<li>
<del>call either <tt>abort()</tt> or <tt>exit();</tt></del>
<ins>terminate execution of the program without returning to the caller</ins>
</li>
</ul>
</blockquote>







<hr>
<h3><a name="995"></a>995. Operational Semantics Unclear</h3>
<p><b>Section:</b> 17.5.1.3 [structure.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> David Abrahams <b>Opened:</b> 2009-03-06  <b>Last modified:</b> 2009-05-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
As a practical matter there's disagreement on the meaning of <i>operational
semantics</i>.  If the text in 17.5.1.3 [structure.requirements]p4 isn't
clear, it should be clarified.  However, it's not clear whether the
disagreement is merely due to people not being aware of the text.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Agree with the recommended NAD resolution.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Recommend NAD.  The text in 17.5.1.3 [structure.requirements] is
perfectly clear.
</p>





<hr>
<h3><a name="996"></a>996. Move operation not well specified</h3>
<p><b>Section:</b> 17 [library] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> David Abrahams <b>Opened:</b> 2009-03-06  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There are lots of places in the standard where we talk about "the move
constructor" but where we mean "the move operation," i.e.  <tt>T( move( x ) )</tt>.
</p>
<p>
We also don't account for whether that operation modifies <tt>x</tt> or not, and
we need to.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Move to Open, pending proposed wording from Dave for further
review.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="997"></a>997. Response to UK 163</h3>
<p><b>Section:</b> 17.5.1.4 [structure.specifications] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Thomas Plum <b>Opened:</b> 2009-03-03  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#structure.specifications">active issues</a> in [structure.specifications].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#structure.specifications">issues</a> in [structure.specifications].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Many functions are defined as "Effects: Equivalent to a...", which seems
to also define the preconditions, effects, etc. But this is not made
clear.
</p>

<p>
After studying the occurrences of "Effects: Equivalent to", I agree with
the diagnosis but disagree with the solution.  In 21.4.2 [string.cons]
we find
</p>

<blockquote>
<p>
14 <i>Effects:</i> If <tt>InputIterator</tt> is an integral type, equivalent to
<tt>basic_string(static_cast&lt;size_type&gt;(begin), static_cast&lt;value_type&gt;(end), a)</tt>
</p>
<p>
15 Otherwise constructs a string from the values in the range <tt>[begin,
end)</tt>, as indicated in the Sequence Requirements table (see 23.1.3).
</p>
</blockquote>

<p>
This would be devishly difficult to re-write with an explicit
"Equivalent to:" clause.  Instead, I propose the following, which will
result in much less editorial re-work.
</p>

<p><i>[
2009-05-09 Alisdair adds:
]</i></p>


<blockquote>
This issue is related to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#492">492</a>.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution.
Move to Tentatively Ready.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Add a new paragraph after 17.5.1.4 [structure.specifications], p3:
</p>

<blockquote>
<p>
-3- Descriptions of function semantics contain the following elements (as appropriate):<sup>154</sup>
</p>

<ul>
<li>
<i>Requires:</i> the preconditions for calling the function
</li>
<li>
<i>Effects:</i> the actions performed by the function
</li>
<li>
<i>Postconditions:</i> the observable results established by the function
</li>
<li>
<i>Returns:</i> a description of the value(s) returned by the function
</li>
<li>
<i>Throws:</i> any exceptions thrown by the function, and the conditions that would cause the exception
</li>
<li>
<i>Complexity:</i> the time and/or space complexity of the function
</li>
<li>
<i>Remarks:</i> additional semantic constraints on the function
</li>
<li>
<i>Error conditions:</i> the error conditions for error codes reported by the function.
</li>
<li>
<i>Notes:</i> non-normative comments about the function
</li>
</ul>

<p><ins>
Whenever the <i>Effects</i> element specifies that the semantics of some
function <tt>F</tt> are <i>Equivalent to</i> some <i>code-sequence</i>, then
the various elements are interpreted as follows.  If <tt>F</tt>'s
semantics specifies a <i>Requires</i> element, then that requirement is
logically imposed prior to the <i>equivalent-to</i> semantics.  Then,
the semantics of the <i>code-sequence</i> are determined by the
<i>Requires</i>, <i>Effects</i>, <i>Postconditions</i>, <i>Returns</i>,
<i>Throws</i>, <i>Complexity</i>, <i>Remarks</i>, <i>Error
Conditions</i> and <i>Notes</i> specified for the (one or more) function
invocations contained in the <i>code-sequence</i>. The value returned from
<tt>F</tt> is specified by <tt>F</tt>'s <i>Returns</i> element, or
if <tt>F</tt> has no <i>Returns</i> element, a non-<tt>void</tt> return from <tt>F</tt> is specified 
by the <i>Returns</i> elements in <i>code-sequence</i>.  If
<tt>F</tt>'s semantics contains a <i>Throws</i> (or
<i>Postconditions</i>, or <i>Complexity</i>) element, then that
supersedes any occurrences of that element in the <i>code-sequence</i>.
</ins></p>
</blockquote>






<hr>
<h3><a name="998"></a>998. Smart pointer referencing its owner</h3>
<p><b>Section:</b> 20.8.12.2.5 [unique.ptr.single.modifiers] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Pavel Minaev <b>Opened:</b> 2009-02-26  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#unique.ptr.single.modifiers">active issues</a> in [unique.ptr.single.modifiers].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#unique.ptr.single.modifiers">issues</a> in [unique.ptr.single.modifiers].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Consider the following (simplified) implementation of 
<tt>std::auto_ptr&lt;T&gt;::reset()</tt>: 
</p>

<blockquote><pre>void reset(T* newptr = 0) { 
   if (this-&gt;ptr &amp;&amp; this-&gt;ptr != newptr) { 
     delete this-&gt;ptr; 
   } 
   this-&gt;ptr = newptr; 
} 
</pre></blockquote>

<p>
Now consider the following code which uses the above implementation: 
</p>

<blockquote><pre>struct foo { 
   std::auto_ptr&lt;foo&gt; ap; 
   foo() : ap(this) {} 
   void reset() { ap.reset(); } 
}; 
int main() { 
   (new foo)-&gt;reset(); 
} 
</pre></blockquote>

<p>
With the above implementation of auto_ptr, this results in U.B. at the 
point of auto_ptr::reset(). If this isn't obvious yet, let me explain 
how this goes step by step: 
</p>

<ol>
<li>
<tt>foo::reset()</tt> entered 
</li>
<li>
<tt>auto_ptr::reset()</tt> entered 
</li>
<li>
<tt>auto_ptr::reset()</tt> tries to delete <tt>foo</tt>
</li>
<li>
<tt>foo::~foo()</tt> entered, tries to destruct its members 
</li>
<li>
<tt>auto_ptr::~auto_ptr()</tt> executed - <tt>auto_ptr</tt> is no longer a valid object! 
</li>
<li>
<tt>foo::~foo()</tt> left 
</li>
<li>
<tt>auto_ptr::reset()</tt> sets its "ptr" field to 0 &lt;- U.B.! <tt>auto_ptr</tt>
is not a valid object here already! 
</li>
</ol>

<p><i>[
Thanks to Peter Dimov who recognized the connection to <tt>unique_ptr</tt> and
brought this to the attention of the LWG, and helped with the solution.
]</i></p>


<p><i>[
Howard adds:
]</i></p>


<blockquote>
To fix this behavior <tt>reset</tt> must be specified such that deleting the
pointer is the last action to be taken within <tt>reset</tt>.
</blockquote>

<p><i>[
Alisdair adds:
]</i></p>


<blockquote>
<p>
The example providing the rationale for LWG <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#998">998</a> is poor, as it relies on
broken semantics of having two object believing they are unique owners of a
single resource.  It should not be surprising that UB results from such
code, and I feel no need to go out of our way to support such behaviour.
</p>
<p>
If an example is presented that does not imply multiple ownership of a
unique resource, I would be much more ready to accept the proposed
resolution.
</p>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Howard summarizes:
</p>
<blockquote>
This issue has to do with circular ownership,
and affects <tt>auto_ptr</tt>, too (but we don't really care about that).
It is intended to spell out the order in which operations must be performed
so as to avoid the possibility
of undefined behavior in the self-referential case.
</blockquote>
<p>
Howard points to message c++std-lib-23175 for another example,
requested by Alisdair.
</p>
<p>
We agree with the issue and with the proposed resolution.
Move to Tentatively Ready.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 20.8.12.2.5 [unique.ptr.single.modifiers], p5 (<i>Effects</i> clause for <tt>reset</tt>), and p6:
</p>

<blockquote>
<p>
-5- <i>Effects:</i> <del>If <tt>get() == nullptr</tt> there are no effects. Otherwise <tt>get_deleter()(get())</tt>.</del>
<ins>Assigns <tt>p</tt> to the stored <tt>pointer</tt>, and then if the old value of the <tt>pointer</tt> is not
equal to <tt>nullptr</tt>, calls <tt>get_deleter()(</tt>the old value of the <tt>pointer)</tt>.
[<i>Note:</i> The order of these operations is significant because the call to <tt>get_deleter()</tt>
may destroy <tt>*this</tt>. <i>-- end note</i>]</ins>
</p>

<p>
-6- Postconditions: <tt>get() == p</tt>.
<ins>[<i>Note:</i> The postcondition does not hold if the call to
<tt>get_deleter()</tt> destroys <tt>*this</tt> since <tt>this-&gt;get()</tt> is no longer a valid
expression. <i>-- end note</i>]</ins>
</p>
</blockquote>





<hr>
<h3><a name="999"></a>999. Taking the address of a function</h3>
<p><b>Section:</b> 20.8.11.1 [object.addressof] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Peter Dimov <b>Opened:</b> 2009-03-09  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#object.addressof">active issues</a> in [object.addressof].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#object.addressof">issues</a> in [object.addressof].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The same fix (reference <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#987">987</a>) may be applied to <tt>addressof</tt>, which is also constrained to
<tt>ObjectType</tt>. (That was why <tt>boost::ref</tt> didn't work with functions - it
tried to apply <tt>boost::addressof</tt> and the <tt>reinterpret_cast&lt;char&amp;&gt;</tt>
implementation of <tt>addressof</tt> failed.)
</p>



<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We agree.
</p>
<p>
Move to Tentatively Ready.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change the synopsis in 20.8 [memory]:
</p>

<blockquote><pre>template &lt;<del>ObjectType</del> <ins>PointeeType</ins> T&gt;
  T* addressof(T&amp; r);
</pre></blockquote>

<p>
Change 20.8.11.1 [object.addressof]:
</p>

<blockquote><pre>template &lt;<del>ObjectType</del> <ins>PointeeType</ins> T&gt;
  T* addressof(T&amp; r);
</pre></blockquote>


<p><b>Rationale:</b></p>
<p>
a) The occurrence of <tt>T&amp;</tt> in the function signature auto-implies
<tt>std::ReferentType</tt>,
this is due to 14.11.1.2 [temp.req.impl]/4 bullet 4
</p>





<hr>
<h3><a name="1000"></a>1000. adjacent_find is over-constrained</h3>
<p><b>Section:</b> 25.3.8 [alg.adjacent.find] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Chris Jefferson <b>Opened:</b> 2009-03-09  <b>Last modified:</b> 2009-03-13</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.adjacent.find">issues</a> in [alg.adjacent.find].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<b>Addresses UK 296</b>
</p>

<p>
<tt>adjacent_find</tt> in C++03 allows an arbitrary predicate, but in C++0x
<tt>EqualityComparable/EquivalenceRelation</tt> is required. This forbids a
number of use cases, including:
</p>
<blockquote>
<table>
<tbody><tr>
<td valign="top">
<tt>adjacent_find(begin,&nbsp;end,&nbsp;less&lt;double&gt;)</tt>
</td>
<td>
Find the first
place where a range is not ordered in decreasing order - in use to check
for sorted ranges.
</td>
</tr>
<tr>
<td valign="top">
<tt>adjacent_find(begin,&nbsp;end,&nbsp;DistanceBiggerThan(6)&nbsp;)&nbsp;)</tt>
</td>
<td>
Find the first
place in a range where values differ by more than a given value - in use
to check an algorithm which produces points in space does not generate
points too far apart.
</td>
</tr>
</tbody></table>
</blockquote>

<p>
A number of books use predicate which are not equivalence relations in
examples, including "Thinking in C++" and "C++ Primer".
</p>

<p>
Adding the requirement that the predicate is an <tt>EquivalenceRelation</tt>
does not appear to open up any possibility for a more optimised algorithm.
</p>



<p><b>Proposed resolution:</b></p>
<p>
Change the definition of adjacent_find in the synopsis of 25 [algorithms]
and 25.3.8 [alg.adjacent.find] to:
</p>

<blockquote><pre>template&lt;ForwardIterator Iter&gt; 
  requires <del>EqualityComparable</del><ins>HasEqualTo</ins>&lt;Iter::value_type<ins>, Iter::value_type</ins>&gt;
  Iter adjacent_find(Iter first, Iter last);

template&lt;ForwardIterator Iter, <del>EquivalenceRelation</del><ins>Predicate</ins>&lt;auto, Iter::value_type<ins>, Iter::value_type</ins>&gt; Pred&gt; 
  requires CopyConstructible&lt;Pred&gt; 
  Iter adjacent_find(Iter first, Iter last, Pred pred);
</pre></blockquote>





<hr>
<h3><a name="1001"></a>1001. Pointers, concepts and headers</h3>
<p><b>Section:</b> 17 [library] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Review">Review</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-10  <b>Last modified:</b> 2009-06-16</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Review">Review</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 78</b></p>

<p>
Related to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1063">1063</a>.
</p>

<p>
This is effectively an extension of LWG issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#343">343</a>.
</p>
<p>
We know there is an increasing trend (encouraged by conformance testers and
some users) that each library header should supply no more than required to
satisfy the synopsis in the standard.  This is typically achieved by
breaking larger headers into smaller subsets, and judicious use of forward
declarations.
</p>
<p>
If we apply this policy to C++0x (per
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2800.pdf">N2800</a>)
it will be very surprising for
people using library algorithms over ranges defined by pointers that they
must <tt>#include &lt;iterator_concepts&gt;</tt> for their code to compile again.  That is
because pointers do not satisfy any of the iterator concepts without the
<tt>concept_map</tt> supplied in this header.
</p>
<p>
Therefore, I suggest we should require all library headers that make use of
iterator concepts are specifically required to <tt>#include &lt;iterator_concepts&gt;</tt>.
</p>
<p>
At a minimum, the list of headers would be: (assuming all are constrained by
concepts)
</p>
<blockquote><pre>algorithm
array
deque
forward_list
initializer_list
iterator
locale
list
map
memory          // if <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1029">1029</a> is adopted
memory_concepts
numeric
random
regex
set
string
tuple
unordered_map
unordered_set
utility
vector
</pre></blockquote>

<p><i>[
Ganesh adds:
]</i></p>


<blockquote>
<p>
The same problems exists for <tt>&lt;memory_concepts&gt;</tt> and
<tt>&lt;container_concepts&gt;</tt>.
</p>
<p>
In order to compile <tt>&lt;vector&gt;</tt> you just need the
definitions of the concepts in <tt>&lt;memory_concepts&gt;</tt>, the
concept maps defined there are not necessary. Yet, from the user point
of view, if the concept map template for <tt>AllocatableElement</tt> are
not in scope, <tt>&lt;vector&gt;</tt> is pretty useless. Same for
<tt>&lt;tuple&gt;</tt> and <tt>ConstructibleWithAllocator</tt>.
</p>
<p>
Similarly, <tt>&lt;queue&gt;</tt> is not very useful if the concept map
template for <tt>QueueLikeContainer</tt> is not in scope, although the
definition of concept alone is theoretically sufficient.
</p>
<p>
There's a pattern here: if a concept has concept maps "attached", they
should never be separated.
</p>
</blockquote>

<p><i>[
Beman provided the proposed resolution for the May 2009 mailing. He 
comments:
]</i></p>


<blockquote>

<p>Initially I tried to specify exactly what header should include what other 
headers. This was verbose, error prone, hard to maintain, and appeared to add 
little value compared to just stating the general rule.</p>

</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Pete believes the proposed wording overconstrains implementers.
Instead of specifying the mechanism,
he prefers a solution that spells out what needs to be declared,
rather than how those declarations are to be provided,
e.g.,
</p>
<blockquote>
A C++ header shall provide the names
that are required to be defined in that header.
</blockquote>
<p>
Bill suggests approaching the wording from a programmer's perspective.
We may want to consider promising that certain widely-used headers
(e.g., the concept headers) are included when needed by other headers.
He feels, however, there is nothing broken now,
although we may want to consider "something nicer."
</p>
<p>
Move to Open status.
</p>

</blockquote>

<p><i>[
2009-06-16 Beman updated the proposed resolution:
]</i></p>


<blockquote>
  <ul>
    <li>The mechanism is no longer specified, as requested in Batavia.</li>
    <li>The footnote has been removed since it specified mechanism and also did 
    not reflect existing practice.</li>
    <li>A sentence was added that makes it clear that the existing practice is 
    permitted.</li>
  </ul>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p><i>Change 17.6.4.2 [res.on.headers], Headers, paragraph 1, as indicated:</i></p>
<blockquote>
  <p> <ins>A C++ 
  header shall provide definitions for any names that appear in its synopsis (3.2 [basic.def.odr]).</ins> 
  A C++ header may include other C++ headers.<del><sup>[footnote]</sup></del> <ins>A C++ 
  header shown in its synopsis as including other C++ headers shall provide 
  definitions for the same names as if those other headers were included. A C++ header that uses a 
  concept (14.10 [concept]) shall provide the definition for that concept as if it included the C++ header 
  that defines that concept in its synopsis. The mechanism and ordering of such 
  definitions is unspecified.</ins></p>

  <p><ins>[<i>Example:</i> If C++ header <code>&lt;a&gt;</code> contains a concept 
  defined in C++ header <code>&lt;b&gt;</code>, and header <code>&lt;b&gt;</code> contains a 
  concept defined in C++ header <code>&lt;c&gt;</code>, then inclusion of <code>&lt;a&gt;</code> 
  is equivalent to inclusion of <code>&lt;a&gt;</code>, <code>&lt;b&gt;</code>, and <code>
  &lt;c&gt;</code>. <i>&#8212; end example</i>]</ins></p>

  <p><del><sup>[footnote]</sup> C++ headers must include a C++ header that contains 
  any needed definition (3.2).</del></p>
</blockquote>






<hr>
<h3><a name="1002"></a>1002. Response to UK 170</h3>
<p><b>Section:</b> 17.6.1.2 [headers] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11  <b>Last modified:</b> 2009-05-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#headers">issues</a> in [headers].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 170</b></p>

<p>
One of goals of C++0x is to make language easier to teach and for
'incidental' programmers. The fine-grained headers of the C++ library
are valuable in large scale systems for managing dependencies and
optimising build times, but overcomplicated for simple development and
tutorials. Add additional headers to support the whole library through a
single include statement.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We do not all agree that this is an issue,
but we agree that if it needs solving this is the right way to do it.
Move to Tentatively Ready.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Insert a new paragraph in 17.6.1.2 [headers] between p4 and p5
</p>
<blockquote>
An additional header <tt>&lt;std&gt;</tt> shall have the effect of
supplying the entire standard library.  [<i>Note:</i> for example, it
might be implemented as a file with an <tt>#include</tt> statement for each of the
headers listed in tables 13 and 14. <i>-- end note</i>]
</blockquote>





<hr>
<h3><a name="1003"></a>1003. Response to JP 23</h3>
<p><b>Section:</b> 17.6.1.3 [compliance] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Review">Review</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#compliance">active issues</a> in [compliance].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#compliance">issues</a> in [compliance].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Review">Review</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses JP 23</b></p>

<p>
There is a freestanding implementation including
<tt>&lt;type_traits&gt;</tt>, <tt>&lt;array&gt;</tt>,
<tt>&lt;ratio&gt;</tt>, lately added to Table 13, C++ library headers.
Programmers think them useful and hope that these headers are also added
to Table 15, C++ headers for freestanding implementations, that shows
the set of headers which a freestanding implementation shall include at
least.
</p>

<p><b>Original proposed resolution</b></p>

<p>
Add <tt>&lt;type_traits&gt;</tt>, <tt>&lt;array&gt;</tt>,
<tt>&lt;ratio&gt;</tt> to Table 15.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
<p>
 The <tt>&lt;array&gt;</tt> header has far too many dependencies to require for a
free-standing implementation.
</p>
<p>
The <tt>&lt;ratio&gt;</tt> header would be useful, has no dependencies, but is not
strictly necessary.
</p>
<p>
The <tt>&lt;type_traits&gt;</tt> header is fundamentally a core language facility with a
library interface, so should be supported.
</p>

<p>
(it is anticipated the resolution will come via an update to paper
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2814.pdf">N2814</a>)
(see also LWG <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#833">833</a>)
</p>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Leave in Review status pending a paper on freestanding implementations
by Martin Tasker.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Add <tt>&lt;type_traits&gt;</tt> to Table 15.
</p>






<hr>
<h3><a name="1004"></a>1004. Response to UK 179</h3>
<p><b>Section:</b> 17.6.3.8 [res.on.functions] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11  <b>Last modified:</b> 2009-05-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#res.on.functions">issues</a> in [res.on.functions].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 179</b></p>

<p>
According to the 4th bullet there is a problem if "if any replacement
function or handler function or destructor operation throws an
exception". There should be no problem throwing exceptions so long as
they are caught within the function.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
The phrasing "throws an exception" is commonly used elsewhere
to mean "throws or propagates an exception."
Move to Open pending a possible more general resolution.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change the 4th bullet of 17.6.3.8 [res.on.functions], p2:
</p>

<blockquote>
<ul>
<li>
if any replacement function or handler function or destructor operation
<del>throws</del> <ins>propagates</ins> an exception, unless specifically
allowed in the applicable <i>Required behavior:</i> paragraph.
</li>
</ul>
</blockquote>






<hr>
<h3><a name="1005"></a>1005. Response to JP 26</h3>
<p><b>Section:</b> 18.3.1.1 [numeric.limits] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Review">Review</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11  <b>Last modified:</b> 2009-05-25</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Review">Review</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses JP 26</b></p>

<p>
<tt>numeric_limits</tt> [partial specializations] does not use concept.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Alisdair will provide a soltion as part of treatment of axioms and LWG <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#902">902</a>.
</blockquote>

<p><i>[
Post Summit:
]</i></p>


<blockquote>
Alisdair recommends NAD as the partial specializations are already
constrained by requirements on the primary template.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
The Working Draft does not in general repeat a primary template's constraints
in any specializations.
Move to NAD.
</blockquote>

<p><i>[
2009-05-25 Howard adds:
]</i></p>


<blockquote>
A c++std-lib thread starting at c++std-lib-23880 has cast doubt that NAD is the
correct resolution of this issue.  Indeed the discussion also casts doubt that
the current proposed wording is the correct resolution as well.  Personally I'm
inclined to reset the status to Open.  However I'm reverting the status to 
that which it had prior to the Batavia recommendation.  I'm setting back to Review.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 18.3.1.1 [numeric.limits]:
</p>

<blockquote><pre>template&lt;<del>class</del> <ins>Regular</ins> T&gt; class numeric_limits&lt;const T&gt;;
template&lt;<del>class</del> <ins>Regular</ins> T&gt; class numeric_limits&lt;volatile T&gt;;
template&lt;<del>class</del> <ins>Regular</ins> T&gt; class numeric_limits&lt;const volatile T&gt;;
</pre></blockquote>






<hr>
<h3><a name="1006"></a>1006. Response to UK 190</h3>
<p><b>Section:</b> 18.6.1 [new.delete] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11  <b>Last modified:</b> 2009-05-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#new.delete">issues</a> in [new.delete].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 190</b></p>

<p>
It is not entirely clear how the current specification acts in the
presence of a garbage collected implementation.
</p>

<p><i>[
Summit:
]</i></p>

 
<blockquote>
Agreed.
</blockquote>

<p><i>[
2009-05-09 Alisdair adds:
]</i></p>


<blockquote>
Proposed wording is too strict for implementations that do not support
garbage collection.  Updated wording supplied.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We recommend advancing this to Tentatively Ready
with the understanding that it will not be moved for adoption
unless and until the proposed resolution to Core issue #853 is adopted.
</blockquote>


<p><b>Proposed resolution:</b></p>

<p>
(Editorial note: This wording ties into the proposed
resolution for Core #853)
</p>

<p>
Add paragraphs to 18.6.1.1 [new.delete.single]:
</p>

<blockquote><pre>void operator delete(void* ptr) throw();
<del>void operator delete(void* ptr, const std::nothrow_t&amp;) throw();</del>
</pre>

<p><i>[
The second signature deletion above is editorial.
]</i></p>


<blockquote>
<p><ins>
<i>Requires:</i> If an implementation has strict pointer safety
(3.7.4.3 [basic.stc.dynamic.safety]) then <tt>ptr</tt> shall
be a safely-derived pointer.
</ins></p>

<p>-10- ...</p>
</blockquote>

<pre>void operator delete(void* ptr, const std::nothrow_t&amp;) throw();
</pre>

<blockquote>
<p><ins>
<i>Requires:</i> If an implementation has strict pointer safety
(3.7.4.3 [basic.stc.dynamic.safety]) then <tt>ptr</tt> shall
be a safely-derived pointer.
</ins></p>

<p>-15- ...</p>
</blockquote>

</blockquote>

<p>
Add paragraphs to 18.6.1.2 [new.delete.array]:
</p>

<blockquote><pre>void operator delete[](void* ptr) throw();
<del>void operator delete[](void* ptr, const std::nothrow_t&amp;) throw();</del>
</pre>

<p><i>[
The second signature deletion above is editorial.
]</i></p>


<blockquote>
<p><ins>
<i>Requires:</i> If an implementation has strict pointer safety
(3.7.4.3 [basic.stc.dynamic.safety]) then <tt>ptr</tt> shall
be a safely-derived pointer.
</ins></p>

<p>-9- ...</p>
</blockquote>

<pre>void operator delete[](void* ptr, const std::nothrow_t&amp;) throw();
</pre>

<blockquote>
<p><ins>
<i>Requires:</i> If an implementation has strict pointer safety
(3.7.4.3 [basic.stc.dynamic.safety]) then <tt>ptr</tt> shall
be a safely-derived pointer.
</ins></p>

<p>-13- ...</p>
</blockquote>

</blockquote>


<p>
Add paragraphs to 18.6.1.3 [new.delete.placement]:
</p>

<blockquote><pre>void operator delete(void* ptr, void*) throw();
</pre>

<blockquote>
<p><ins>
<i>Requires:</i> If an implementation has strict pointer safety
(3.7.4.3 [basic.stc.dynamic.safety]) then <tt>ptr</tt> shall
be a safely-derived pointer.
</ins></p>

<p>-7- ...</p>
</blockquote>

<pre>void operator delete[](void* ptr, void*) throw();
</pre>

<blockquote>
<p><ins>
<i>Requires:</i> If an implementation has strict pointer safety
(3.7.4.3 [basic.stc.dynamic.safety]) then <tt>ptr</tt> shall
be a safely-derived pointer.
</ins></p>

<p>-9- ...</p>
</blockquote>

</blockquote>






<hr>
<h3><a name="1007"></a>1007. Response to JP 29</h3>
<p><b>Section:</b> 18.8.6 [except.nested] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11  <b>Last modified:</b> 2009-03-13</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#except.nested">active issues</a> in [except.nested].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#except.nested">issues</a> in [except.nested].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses JP 29</b></p>

<p>
<tt>throw_with_nested</tt> does not use concept.
</p>

<p><i>[
Summit:
]</i></p>

 
<blockquote>
Agreed.
</blockquote>



<p><b>Proposed resolution:</b></p>

<p>
Alisdair initially proposed wording in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2619.pdf">N2619</a>.
</p>
<p>
We are awaiting an updated paper based on feedback from the San Francisco
review.
</p>





<hr>
<h3><a name="1008"></a>1008. Response to JP 31</h3>
<p><b>Section:</b> 18.8.6 [except.nested] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11  <b>Last modified:</b> 2009-03-13</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#except.nested">active issues</a> in [except.nested].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#except.nested">issues</a> in [except.nested].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses JP 31</b></p>

<p>
It is difficult to understand in which case <tt>nested_exception</tt> is applied.
</p>

<p><i>[
Summit:
]</i></p>

 
<blockquote>
Alisdair will add an example in an update to
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2619.pdf">N2619</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1009"></a>1009. Response to UK 251</h3>
<p><b>Section:</b> 24.2.1 [iterator.iterators] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Review">Review</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11  <b>Last modified:</b> 2009-03-22</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Review">Review</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 251</b></p>

<p>
The post-increment operator is dangerous for a general InputIterator.
The multi-pass guarantees that make it meaningful are defined as part of
the ForwardIterator refinement. Any change will affect only constrained
templates that have not yet been written, so should not break existing
user iterators which remain free to add these operations. This change
will also affect the generalised OutputIterator, although there is no
percieved need for the post-increment operator in this case either.
</p>



<p><b>Proposed resolution:</b></p>
<p>
Change 24.2.1 [iterator.iterators]:
</p>

<blockquote><pre>concept Iterator&lt;typename X&gt; : Semiregular&lt;X&gt; { 
  MoveConstructible reference = typename X::reference; 
  <del>MoveConstructible postincrement_result;</del>

  <del>requires HasDereference&lt;postincrement_result&gt;;</del>

  reference operator*(X&amp;&amp;); 
  X&amp; operator++(X&amp;); 
  <del>postincrement_result operator++(X&amp;, int);</del>
}
</pre>

<p>...</p>
<pre><del>postincrement_result operator++(X&amp; r, int);</del>
</pre>

<blockquote>
<del>-3- <i>Effects:</i> equivalent to <tt>{ X tmp = r; ++r; return tmp; }</tt>.</del>
</blockquote>

</blockquote>

<p>
Change 24.2.2 [input.iterators]:
</p>

<blockquote>
<pre>concept InputIterator&lt;typename X&gt; : Iterator&lt;X&gt;, EqualityComparable&lt;X&gt; { 
  ObjectType value_type = typename X::value_type; 
  MoveConstructible pointer = typename X::pointer; 

  SignedIntegralLike difference_type = typename X::difference_type; 

  requires IntegralType&lt;difference_type&gt; 
        &amp;&amp; Convertible&lt;reference, const value_type &amp;&gt;; 
        &amp;&amp; Convertible&lt;pointer, const value_type*&gt;; 

  <del>requires Convertible&lt;HasDereference&lt;postincrement_result&gt;::result_type, const value_type&amp;&gt;;</del>

  pointer operator-&gt;(const X&amp;); 
}
</pre>
</blockquote>

<p>
Change 24.2.3 [output.iterators]:
</p>

<blockquote>
<pre>auto concept OutputIterator&lt;typename X, typename Value&gt; { 
  requires Iterator&lt;X&gt;; 

  typename reference = Iterator&lt;X&gt;::reference; 
  <del>typename postincrement_result = Iterator&lt;X&gt;::postincrement_result;</del>
  requires SameType&lt;reference, Iterator&lt;X&gt;::reference&gt; 
        <del>&amp;&amp; SameType&lt;postincrement_result, Iterator&lt;X&gt;::postincrement_result&gt;</del>
        <del>&amp;&amp; Convertible&lt;postincrement_result, const X&amp;&gt;</del>
        &amp;&amp; HasAssign&lt;reference, Value&gt; 
        <del>&amp;&amp; HasAssign&lt;HasDereference&lt;postincrement_result&gt;::result_type, Value&gt;</del>;
}
</pre>
</blockquote>

<p>
Change 24.2.4 [forward.iterators]:
</p>

<p><i>[
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1084">1084</a> which is attempting to change this same area in a compatible
way.
]</i></p>


<blockquote>
<pre>concept ForwardIterator&lt;typename X&gt; : InputIterator&lt;X&gt;, Regular&lt;X&gt; { 
  <del>requires Convertible&lt;postincrement_result, const X&amp;&gt;;</del>

  <ins>MoveConstructible postincrement_result;</ins>
  <ins>requires HasDereference&lt;postincrement_result&gt;
        &amp;&amp; Convertible&lt;HasDereference&lt;postincrement_result&gt;::result_type, const value_type&amp;&gt;;</ins>

  <ins>postincrement_result operator++(X&amp;, int);</ins>

  axiom MultiPass(X a, X b) { 
    if (a == b) *a == *b; 
    if (a == b) ++a == ++b; 
  } 
}
</pre>

<blockquote>
<p>-4- ...</p>
</blockquote>

<pre><ins>postincrement_result operator++(X&amp; r, int);</ins>
</pre>

<blockquote>
<p>
<ins>-5- <i>Effects:</i> equivalent to <tt>{ X tmp = r; ++r; return tmp; }</tt>.</ins>
</p>
</blockquote>

</blockquote>






<hr>
<h3><a name="1010"></a>1010. Response to UK 263</h3>
<p><b>Section:</b> 24.2.6 [random.access.iterators] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#random.access.iterators">active issues</a> in [random.access.iterators].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#random.access.iterators">issues</a> in [random.access.iterators].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 263</b></p>

<p>
This requirement on <tt>operator-=</tt> would be better expressed as a default
implementation in the concept, with a matching axiom.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
The proposed resolution should also remove
paragraph 5 and the declaration that precedes it.
Further, we should provide an axiom
that captures the desired semantics.
This may be a broader policy to be applied.
Move to Open.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 24.2.6 [random.access.iterators]:
</p>

<blockquote><pre>concept RandomAccessIterator&lt;typename X&gt; : BidirectionalIterator&lt;X&gt;, LessThanComparable&lt;X&gt; {
  ...
  X&amp; operator-=(X&amp; <ins>x</ins>, difference_type <ins>n</ins>)<ins> { return x += -n</ins>;<ins> }</ins>
  ...
}
</pre></blockquote>






<hr>
<h3><a name="1011"></a>1011. Response to UK 271</h3>
<p><b>Section:</b> 24.4 [iterator.operations] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#iterator.operations">active issues</a> in [iterator.operations].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#iterator.operations">issues</a> in [iterator.operations].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 271</b></p>

<p>
<tt>next/prev</tt> return an incremented iterator without changing the value of
the original iterator. However, even this may invalidate an
<tt>InputIterator</tt>. A <tt>ForwardIterator</tt> is required to guarantee the
'multipass' property.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution.
Move to Tentatively Ready.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change  [iterator.synopsis]:
</p>

<blockquote><pre>template &lt;<del>InputIterator</del> <ins>ForwardIterator</ins> Iter&gt; 
  Iter next(Iter x, 
    Iter::difference_type n = 1);
</pre></blockquote>

<p>
Change 24.4 [iterator.operations], p6:
</p>

<blockquote><pre>template &lt;<del>InputIterator</del> <ins>ForwardIterator</ins> Iter&gt; 
  Iter next(Iter x, 
    Iter::difference_type n = 1);
</pre></blockquote>






<hr>
<h3><a name="1012"></a>1012. Response to UK 277</h3>
<p><b>Section:</b> 24.5.1.2.1 [reverse.iter.cons] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11  <b>Last modified:</b> 2009-05-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 277</b></p>

<p>
The default constructor default-initializes current, rather than
value-initializes. This means that when Iterator corresponds to a
trivial type, the current member is left un-initialized, even when the
user explictly requests value intialization! At this point, it is not
safe to perform any operations on the reverse_iterator other than assign
it a new value or destroy it. Note that this does correspond to the
basic definition of a singular iterator.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Agree with option i.
</blockquote>

<p>
Related issue: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#408">408</a>
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We believe this should be revisited
in conjunction with issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#408">408</a>,
which nearly duplicates this issue.
Move to Open.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change  [reverse.iter.con]:
</p>

<blockquote><pre>reverse_iterator();
</pre>
<blockquote>
-1- <i>Effects:</i> <del>Default</del> <ins>Value</ins> initializes <tt>current</tt>. Iterator
operations applied to the resulting iterator have defined behavior if and
only if the corresponding operations are defined on a default constructed
iterator of type <tt>Iterator</tt>.
</blockquote>
</blockquote>

<p>
Change 24.5.3.2.1 [move.iter.op.const]:
</p>

<blockquote><pre>move_iterator();
</pre>
<blockquote>
-1- <i>Effects:</i> Constructs a <tt>move_iterator</tt>, <del>default</del> <ins>value</ins>
initializing <tt>current</tt>.
</blockquote>
</blockquote>






<hr>
<h3><a name="1013"></a>1013. Response to UK 305</h3>
<p><b>Section:</b> 25.5.7 [alg.min.max] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#alg.min.max">active issues</a> in [alg.min.max].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.min.max">issues</a> in [alg.min.max].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 305</b></p>

<p>
The negative requirement on <tt>IsSameType</tt> is a hold-over from an earlier
draught with a variadic template form of <tt>min/max</tt> algorith. It is no
longer necessary.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution.
Move to Tentatively Ready.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 25 [algorithms]:
</p>

<blockquote><pre>template&lt;class T, StrictWeakOrder&lt;auto, T&gt; Compare&gt;
  <del>requires !SameType&lt;T, Compare&gt; &amp;&amp; CopyConstructible&lt;Compare&gt;</del>
  const T&amp; min(const T&amp; a, const T&amp; b, Compare comp);
...
template&lt;class T, StrictWeakOrder&lt;auto, T&gt; Compare&gt;
  <del>requires !SameType&lt;T, Compare&gt; &amp;&amp; CopyConstructible&lt;Compare&gt;</del>
  const T&amp; max(const T&amp; a, const T&amp; b, Compare comp);
...
template&lt;class T, StrictWeakOrder&lt;auto, T&gt; Compare&gt;
  <del>requires !SameType&lt;T, Compare&gt; &amp;&amp; CopyConstructible&lt;Compare&gt;</del>
  pair&lt;const T&amp;, const T&amp;&gt; minmax(const T&amp; a, const T&amp; b, Compare comp);
</pre></blockquote>

<p>
Change 25.5.7 [alg.min.max], p1, p9 and p17:
</p>

<blockquote><pre>template&lt;class T, StrictWeakOrder&lt;auto, T&gt; Compare&gt;
  <del>requires !SameType&lt;T, Compare&gt; &amp;&amp; CopyConstructible&lt;Compare&gt;</del>
  const T&amp; min(const T&amp; a, const T&amp; b, Compare comp);
...
template&lt;class T, StrictWeakOrder&lt;auto, T&gt; Compare&gt;
  <del>requires !SameType&lt;T, Compare&gt; &amp;&amp; CopyConstructible&lt;Compare&gt;</del>
  const T&amp; max(const T&amp; a, const T&amp; b, Compare comp);
...
template&lt;class T, StrictWeakOrder&lt;auto, T&gt; Compare&gt;
  <del>requires !SameType&lt;T, Compare&gt; &amp;&amp; CopyConstructible&lt;Compare&gt;</del>
  pair&lt;const T&amp;, const T&amp;&gt; minmax(const T&amp; a, const T&amp; b, Compare comp);
</pre></blockquote>






<hr>
<h3><a name="1014"></a>1014. Response to UK 317 and JP 74</h3>
<p><b>Section:</b> 28.9.2 [re.regex.construct] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11  <b>Last modified:</b> 2009-05-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#re.regex.construct">issues</a> in [re.regex.construct].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 317 and JP 74</b></p>

<p>
UK 317:
</p>

<blockquote>
<tt>basic_string</tt> has both a constructor and an assignment operator that
accepts an initializer list, <tt>basic_regex</tt> should have the same.
</blockquote>

<p>
JP 74:
</p>

<blockquote>
<tt>basic_regx &amp; operator= (initializer_list&lt;T&gt;);</tt> is not defined.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
UK 317 asks for both assignment and constructor,
but the requested constructor is already present in the current Working Paper.
We agree with the proposed resolution.
Move to Tentatively Ready.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 28.9 [re.regex]:
</p>

<blockquote><pre>template &lt;class charT,
          class traits = regex_traits&lt;charT&gt; &gt;
class basic_regex {
  ...
  basic_regex&amp; operator=(const charT* ptr);
  <ins>basic_regex&amp; operator=(initializer_list&lt;charT&gt; il);</ins>
  template &lt;class ST, class SA&gt;
    basic_regex&amp; operator=(const basic_string&lt;charT, ST, SA&gt;&amp; p);
  ...
};
</pre></blockquote>

<p>
Add in  28.9.2 [re.regex.construct]:
</p>

<blockquote>
<blockquote>
-20- ...
</blockquote>
<pre>basic_regex&amp; operator=(initializer_list&lt;charT&gt; il);
</pre>
<blockquote>
-21- <i>Effects:</i> returns <tt>assign(il.begin(), il.end());</tt>
</blockquote>
</blockquote>






<hr>
<h3><a name="1015"></a>1015. Response to UK 199</h3>
<p><b>Section:</b> 20.2.1 [concept.transform] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#concept.transform">active issues</a> in [concept.transform].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#concept.transform">issues</a> in [concept.transform].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 199</b></p>

<p>
The requirement that programs do not supply <tt>concept_maps</tt> should
probably be users do not supply their own <tt>concept_map</tt>
specializations. The program will almost certainly supply
<tt>concept_maps</tt> - the standard itself supplies a specialization
for <tt>RvalueOf</tt> references. Note that the term <i>program</i> is
defined in 3.5 [basic.link]p1 and makes no account of the
standard library being treated differently to user written code.
</p>

<p><i>[
2009-05-09 Alisdair adds:
]</i></p>


<blockquote>
<p>
The same problem is present in the words added for the
<tt>LvalueReference/RvalueReference</tt> concepts last meeting.
</p>
<p>
With three subsections requiring the same constraint, I'm wondering if there
is a better way to organise this section.
Possible 20.2.1 -&gt; 20.2.3 belong in the fundamental concepts clause in
14.10.4 [concept.support]?  While they can be implemented purely as a
library feature without additional compiler support, they are pretty
fundamental and we want the same restriction on user-concept maps as is
mandated there.
</p>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the issue,
but believe the wording needs further improvement.
We want to investigate current definitions for nomenclature such as
"user" and "program."
Move to Open pending the recommended investigation.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 20.2.1 [concept.transform] p2:
</p>

<blockquote>
-2- A <del>program</del> <ins>user</ins> shall not provide concept maps for
any concept in 20.1.1.
</blockquote>

<p>
Change 20.2.2 [concept.true] p2:
</p>

<blockquote>
-2- <i>Requires:</i> a <del>program</del> <ins>user</ins> shall not
provide a concept map for the <tt>True</tt> concept.
</blockquote>

<p>
Change 20.2.3 [concept.classify] p2:
</p>

<blockquote>
-2- <i>Requires:</i> a <del>program</del><ins>user</ins> shall not provide concept
maps for any concept in this section.
</blockquote>






<hr>
<h3><a name="1016"></a>1016. Response to JP 33</h3>
<p><b>Section:</b> 20.2.6 [concept.comparison] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11  <b>Last modified:</b> 2009-03-12</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#concept.comparison">active issues</a> in [concept.comparison].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#concept.comparison">issues</a> in [concept.comparison].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses JP 33</b></p>

<p>
<tt>LessThanComparable</tt> and <tt>EqualityComparable</tt> don't correspond to NaN. 
</p>

<p><b>Original proposed resolution:</b></p>

<p>
Apply <tt>concept_map</tt> to these concepts at <tt>FloatingPointType</tt>.
</p>

<p><i>[
Post Summit, Alisdair adds:
]</i></p>


<blockquote>
<p>
I don't understand the proposed resolution - there is no such thing as a
'negative' concept_map, and these concepts are auto concepts that match
float/double etc. Also not clear how we are supposed to match values to
concepts.
</p>
<p>
Recommend NAD and treat as a subset of issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#902">902</a>.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Recommend NAD.
</p>





<hr>
<h3><a name="1017"></a>1017. Response to US 66</h3>
<p><b>Section:</b> 20.2.11 [concept.regular] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11  <b>Last modified:</b> 2009-03-12</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses US 66</b></p>

<p>
Application of the <tt>Regular</tt> concept to floating-point types appears to be
controversial (see long discussion on std-lib reflector). 
</p>

<p><b>Original proposed resolution:</b></p>

<p>
State that the <tt>Regular</tt> concept does not apply to floating-point types. 
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
<p>
Recommend that we handle the same as JP 33 / <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1016">1016</a>.
</p>
</blockquote>

<p><i>[
Post Summit, Alisdair adds:
]</i></p>


<blockquote>
<p>
Recommend Open, and review after resolution of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#902">902</a> and revised axiom
feature.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1018"></a>1018. Response to US 70</h3>
<p><b>Section:</b> 20.6 [meta] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11  <b>Last modified:</b> 2009-03-12</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#meta">active issues</a> in [meta].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#meta">issues</a> in [meta].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses US 70</b></p>

<p>
Specifications now expressed via narrative text are more accurately and
clearly expressed via executable code.
</p>
<p>
Wherever concepts are available that directly match this section's type
traits, express the traits in terms of the concepts instead of via
narrative text. Where the type traits do not quite match the
corresponding concepts, bring the two into alignment so as to avoid two
nearly-identical notions.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
<p>
We think that this is a good idea, but it requires a lot of work. If someone
submits a paper proposing specific changes, we would be happy to review it
at the next meeting.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1019"></a>1019. Response to UK 205</h3>
<p><b>Section:</b> 20.6.3 [meta.help] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#meta.help">active issues</a> in [meta.help].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#meta.help">issues</a> in [meta.help].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 205</b></p>

<p>
<tt>integral_constant</tt> objects should be usable in integral-constant-expressions.
The addition to the language of literal types and the enhanced rules for
constant expressions make this possible.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree that the <tt>static</tt> data member
ought be declared <tt>constexpr</tt>,
but do not see a need for the proposed <tt>operator value_type()</tt>.
(A use case would be helpful.)
Move to Open.
</blockquote>

<p><i>[
2009-05-23 Alisdair adds:
]</i></p>


<blockquote>
<p>
The motivating case in my mind is that we can then use
<tt>true_type</tt> and <tt>false_type</tt> as integral Boolean expressions, for example inside
a <tt>static_assert</tt> declaration.  In that sense it is purely a matter of style.
</p>
<p>
Note that Boost has applied the non-explicit conversion operator for many
years as it has valuable properties for extension into other metaprogramming
libraries, such as MPL.  If additional rationale is desired I will poll the
Boost lists for why this extension was originally applied.  I would argue
that explicit conversion is more appropriate for 0x though.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Add to the <tt>integral_constant</tt> struct definition in 20.6.3 [meta.help]:
</p>

<blockquote><pre>template &lt;class T, T v&gt;
struct integral_constant {
  static const<ins>expr</ins> T value = v;
  typedef T value_type;
  typedef integral_constant&lt;T,v&gt; type;
  <ins>constexpr operator value_type() { return value; }</ins>
};
</pre></blockquote>





<hr>
<h3><a name="1020"></a>1020. Response to UK 204</h3>
<p><b>Section:</b> 20.6.7 [meta.trans.other] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11  <b>Last modified:</b> 2009-03-12</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#meta.trans.other">active issues</a> in [meta.trans.other].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#meta.trans.other">issues</a> in [meta.trans.other].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 204</b></p>

<p>
It is not possible to create a variant union based on a parameter pack
expansion, e.g. to implement a classic discriminated union template. 
</p>

<p><b>Original proposed resolutuion:</b></p>

<p>
Restore <tt>aligned_union</tt> template that was removed by LWG issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#856">856</a>. 
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Agree. The need for <tt>aligned_union</tt> is compelling enough to reinstate.
</blockquote>

<p><i>[
Post Summit, Alisdair adds:
]</i></p>


<blockquote>
paper
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2843.html">N2843</a>
proposes an extension to the <tt>[[align]]</tt> attribute
that further diminishes the need for this template.  Recommend NAD.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1021"></a>1021. Response to UK 211</h3>
<p><b>Section:</b> 20.8.12.2.3 [unique.ptr.single.asgn] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11  <b>Last modified:</b> 2009-05-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 211</b></p>

<p>
The <tt>nullptr_t</tt> type was introduced to resolve the null pointer literal
problem. It should be used for the assignemnt operator, as with the
constructor and elsewhere through the library.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution.
Move to Tentatively Ready.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change the synopsis in 20.8.12.2 [unique.ptr.single]:
</p>

<blockquote><pre>unique_ptr&amp; operator=(<del><i>unspecified-pointer-type</i></del> <ins>nullptr_t</ins>);
</pre></blockquote>

<p>
Change 20.8.12.2.3 [unique.ptr.single.asgn]:
</p>

<blockquote><pre>unique_ptr&amp; operator=(<del><i>unspecified-pointer-type</i></del> <ins>nullptr_t</ins>);
</pre>
<blockquote>
<del>Assigns from the literal 0 or <tt>NULL</tt>. [<i>Note:</i> The
<i>unspecified-pointer-type</i> is often implemented as a pointer to a
private data member, avoiding many of the implicit conversion pitfalls.
<i>-- end note</i>]</del>
</blockquote>
</blockquote>





<hr>
<h3><a name="1023"></a>1023. Response to DE 22</h3>
<p><b>Section:</b> 20.7.16.2 [func.wrap.func] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">Tentatively NAD Editorial</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#func.wrap.func">active issues</a> in [func.wrap.func].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#func.wrap.func">issues</a> in [func.wrap.func].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20NAD%20Editorial">Tentatively NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses DE 22</b></p>

<p>Related to issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1114">1114</a>.</p>

<p>
The conditions for deriving from <tt>std::unary_function</tt> and
<tt>std::binary_function</tt> are unclear: The condition would also be satisfied if
<tt>ArgTypes</tt> were <tt>std::vector&lt;T1&gt;</tt>, because it (arguably)
"contains" <tt>T1</tt>.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Agree. <tt>std::reference_wrapper</tt> has the same structure, and we
suggest that <tt>std::function</tt> be presented in the same way as
<tt>std::reference_wrapper</tt>.
</blockquote>

<p><i>[
2009-05-09 Alisdair adds:
]</i></p>


<blockquote>
Phrasing should be "publicly and
unambiguously derived from" and probably back in reference_wrapper too.  Updated
wording supplied.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed wording.
Move to NAD Editorial.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
(no changes to <tt>&lt;functional&gt;</tt> synopsis required)
</p>

<p>
Change synopsis in Class template function 20.7.16.2 [func.wrap.func]:
</p>

<blockquote><pre>template&lt;Returnable R, CopyConstructible... ArgTypes&gt; 
class function&lt;R(ArgTypes...)&gt; 
  : public unary_function&lt;T1, R&gt;      // <del><i>iff</i> sizeof...(ArgTypes) == 1 <i>and</i></del> <ins><i>see below</i></ins>
                                      <del>// ArgTypes <i>contains</i> T1</del>
  : public binary_function&lt;T1, T2, R&gt; // <del><i>iff</i> sizeof...(ArgTypes) == 2 <i>and</i></del> <ins><i>see below</i></ins>
                                      <del>// ArgTypes <i>contains</i> T1 <i>and</i> T2</del>
{
   ...
</pre></blockquote>

<p>
Add new p1/p2 before 20.7.16.2.1 [func.wrap.func.con]:
</p>

<blockquote>
<p><ins>
The template instantiation <tt>function&lt;R(T1)&gt;</tt> shall be publicly and
unambiguously derived from 
<tt>std::unary_function&lt;T1,R&gt;</tt> if and only if the template type parameter
is a function type taking one argument of type <tt>T1</tt> and returning <tt>R</tt>.
</ins></p>

<p><ins>
The template instantiation <tt>function&lt;R(T1,T2)&gt;</tt> shall be publicly and
unambiguously derived from 
<tt>std::binary_function&lt;T1,T2,R&gt;</tt> if and only if the template type
parameter is a function type taking two arguments of type <tt>T1</tt> and <tt>T2</tt> and
returning <tt>R</tt>.
</ins></p>

<pre>explicit function();
</pre>
</blockquote>






<hr>
<h3><a name="1024"></a>1024. Response to JP 39</h3>
<p><b>Section:</b> 20.7.16.2 [func.wrap.func] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#func.wrap.func">active issues</a> in [func.wrap.func].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#func.wrap.func">issues</a> in [func.wrap.func].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses JP 39</b></p>

<p>
There are no requires corresponding to <tt>F</tt> of <tt>std::function</tt>.
</p>

<p><i>[
2009-05-01 Daniel adds:
]</i></p>


<blockquote>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1070">1070</a> removes the second constructor.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution.
Move to Tentatively Ready.
If issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1070">1070</a> is accepted,
the changes to the second constructor
in this issue are moot.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Correct as follows in 20.7.16.2 [func.wrap.func] (class definition)
</p>

<blockquote><pre> template&lt;class F, Allocator Alloc&gt;
   <ins>requires ConstructibleWithAllocator&lt;F, Alloc&gt;
     &amp;&amp; call=Callable&lt;F, ArgTypes...&gt;
     &amp;&amp; Convertible&lt;call::result_type, R&gt;</ins>
   function(allocator_arg_t, const Alloc&amp;, F);
 template&lt;class F, Allocator Alloc&gt;
   <ins>requires ConstructibleWithAllocator&lt;F,Alloc&gt;
     &amp;&amp; call=Callable&lt;F, ArgTypes...&gt;
     &amp;&amp; Convertible&lt;call::result_type, R&gt;</ins>
   function(allocator_arg_t, const Alloc&amp;, F&amp;&amp;);
</pre></blockquote>






<hr>
<h3><a name="1026"></a>1026. Response to UK 209</h3>
<p><b>Section:</b> 20.8 [memory] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11  <b>Last modified:</b> 2009-03-12</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#memory">active issues</a> in [memory].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#memory">issues</a> in [memory].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 209</b></p>

<p>
Smart pointers cannot be used in constrained templates.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
We look forward to a paper on this topic. We recommend no action until a
paper is available. We understand that a paper is forthcoming.
</blockquote>

<p><i>[
Peter Dimov adds:
]</i></p>


<blockquote>
<tt>shared_ptr&lt;T&gt;</tt> and <tt>weak_ptr&lt;T&gt;</tt> support all
types <tt>T</tt> for which <tt>T*</tt> is valid. In other words, a
possible (partial) resolution is to change class <tt>T</tt> to
<tt>PointeeType T</tt> for <tt>shared_ptr</tt>, <tt>weak_ptr</tt> and
possibly <tt>enable_shared_from_this</tt>.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1027"></a>1027. Response to UK 213</h3>
<p><b>Section:</b> 20.8.6 [default.allocator] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11  <b>Last modified:</b> 2009-03-13</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 213</b></p>

<p>
<tt>std::allocator</tt> should be constrained to simplify its use on constrained
contexts. This library component models allocation from free store via the
new operator so choose constraints to 
match. The Allocator concept allows for a wider variety of allocators that
users may choose to supply if their allocation model does not require
operator new, without impacting the 
requirements of this template. 
</p>

<p>
Suggested direction:
</p>
<p>
The primary allocator template should be constrained to require
<tt>ObjectType&lt;T&gt;</tt> and <tt>FreeStoreAllocatable&lt;T&gt;</tt>.
Further operations to be constrained as required.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Agree as stated. A future paper will address additional related issues.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1028"></a>1028. Response to UK 214</h3>
<p><b>Section:</b> 20.8.8 [storage.iterator] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11  <b>Last modified:</b> 2009-03-15</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 214</b></p>

<p>
<tt>raw_storage_iterator</tt> needs constraining as an iterator adaptor to be safely
used in constrained templates 
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
We look forward to a paper on this topic. We recommend no action until a
paper is available.
</blockquote>

<p><i>[
Post Summit Alisdair provided wording and rationale.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
20.8 [memory] p2
</p>
<p>
Update the synopsis for <tt>&lt;memory&gt;</tt>
</p>
<blockquote><pre>// 20.7.8, raw storage iterator:
template &lt;<del>class</del> <ins>ForwardIterator</ins> Out<del>put</del>Iter<del>ator</del>, <del>class</del> <ins>ObjectType</ins> T&gt; 
  <ins>requires OutputIterator&lt; OutIter, T &gt;</ins>
    class raw_storage_iterator;

<ins>template &lt;ForwardIterator OutIter, ObjectType T&gt; 
  requires OutputIterator&lt; OutIter, T &gt;
  concept_map Iterator&lt;raw_storage_iterator&lt; OutIter, T &gt; &gt; { }</ins>
</pre></blockquote>


<p>
20.8.8 [storage.iterator] p1
</p>
<p>
Replace class template definition with:
</p>
<blockquote><pre>namespace std { 
  template &lt;<del>class</del> <ins>ForwardIterator</ins> Out<del>put</del>Iter<del>ator</del>, <del>class</del> <ins>ObjectType</ins> T&gt; 
    <ins>requires OutputIterator&lt; OutIter, T &gt;</ins>
  class raw_storage_iterator 
    : public iterator&lt;output_iterator_tag,void,void,void,void&gt; { 
  public: 
    explicit raw_storage_iterator(Out<del>put</del>Iter<del>ator</del> x); 

    raw_storage_iterator<del>&lt;OutputIterator,T&gt;</del>&amp; operator*(); 
    raw_storage_iterator<del>&lt;OutputIterator,T&gt;</del>&amp; operator=(const T&amp; element); 
    raw_storage_iterator<del>&lt;OutputIterator,T&gt;</del>&amp; operator++(); 
    raw_storage_iterator<del>&lt;OutputIterator,T&gt;</del> operator++(int); 
  }; 

  <ins>template &lt;ForwardIterator OutIter, ObjectType T&gt; 
    requires OutputIterator&lt; OutIter, T &gt;
    concept_map Iterator&lt;raw_storage_iterator&lt; OutIter, T &gt; &gt; { }</ins>
}
</pre></blockquote>


<p><b>Rationale:</b></p>
<p>
<tt>raw_storage_iterator</tt> has to adapt a <tt>ForwardIterator</tt>,
rather than just an <tt>InputIterator</tt> for two reasons:
</p>

<ol type="i">
<li>
The initial iterator passed by value is expected to remain valid,
pointing to the initialized region of memory.
</li>
<li>
to avoid breaking the declaration of post-increment operator which would
require some kind of proxy formulation to support generalised InputIterators.
</li>
</ol>






<hr>
<h3><a name="1029"></a>1029. Response to UK 210</h3>
<p><b>Section:</b> 20.8.11 [specialized.algorithms] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11  <b>Last modified:</b> 2009-03-15</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#specialized.algorithms">issues</a> in [specialized.algorithms].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 210</b></p>

<p>Related to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#582">582</a></p>

<p>
Specialized algorithms for memory managenment need requirements to be
easily usable in constrained templates.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
We look forward to a paper on this topic. We recommend no action until a
paper is available.
</blockquote>

<p><i>[
Post Summit Alisdair provided wording.
]</i></p>


<p><i>[
Post Summit:
]</i></p>


<blockquote>
<p>
Daniel adds:
</p>

<blockquote>
<ol>
<li>
I suggest <tt>Size</tt> should require <tt>IntegralLike</tt> and not <tt>UnsignedIntegralLike</tt>,
because otherwise simple int-literals could not be provided as arguments
and it would conflict with other algorithms that only require <tt>IntegralLike</tt>.
</li>
<li>
<p>
The current for-loop-test relies on evaluation in boolean context which is
not provided by <tt>ArithmeticLike</tt> and it's refinements. I propose to change the
corresponding for-loop-headers to:
</p>
<ol type="a">
<li>
for <tt>uninitialized_copy_n</tt>: <tt>for ( ; n &gt; Size(0); ++result, ++first, --n) {</tt>
</li>
<li>
for <tt>uninitialized_fill_n</tt>: <tt>for (; n &gt; Size(0); ++first, --n) {</tt>
</li>
</ol>
</li>
</ol>
</blockquote>

<p>
Alisdair adds:
</p>
<blockquote>
For the record I agree with Daniel's suggestion.
</blockquote>

</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
20.8 [memory] p2
</p>
<p>
Update the synopsis for <tt>&lt;memory&gt;</tt>
</p>
<blockquote><pre>template &lt;<del>class</del> InputIterator <ins>InIter</ins>,
         <del>class ForwardIterator</del> <ins>OutputIterator&lt;auto, InIter::reference&gt; OutIter</ins>&gt; 
   <ins>requires ForwardIterator&lt;OutIter&gt;</ins>
   <del>ForwardIterator</del> <ins>OutIter</ins>
   uninitialized_copy(<del>InputIterator</del> <ins>InIter</ins> first, <del>InputIterator</del> <ins>InIter</ins> last, 
                      <del>ForwardIterator</del> <ins>OutIter</ins> result);

template &lt;<del>class</del> InputIterator <ins>InIter</ins>,
          <del>class</del> <ins>IntegralLike</ins> Size,
          <del>class ForwardIterator</del> <ins>OutputIterator&lt;auto, InIter::reference&gt; OutIter</ins>&gt; 
  <ins>requires ForwardIterator&lt;OutIter&gt;</ins>
  <del>ForwardIterator</del> <ins>OutIter</ins>
  uninitialized_copy_n(<del>InputIterator</del> <ins>InIter</ins> first, Size n, 
                       <del>ForwardIterator</del> <ins>OutIter</ins> result);

template &lt;<del>class</del> ForwardIterator <ins>Iter</ins>, <del>class</del> <ins>ObjectType</ins> T&gt;
  <ins>requires Constructible&lt; Iter::value_type, const T&amp; &gt;</ins>
  void uninitialized_fill(<del>ForwardIterator</del> <ins>Iter</ins> first, <del>ForwardIterator</del> <ins>Iter</ins> last, 
                          const T&amp; x);

template &lt;<del>class</del> ForwardIterator <ins>Iter</ins>, <del>class</del> <ins>IntegralLike</ins> Size, <del>class</del> <ins>ObjectType</ins> T&gt; 
  <ins>requires Constructible&lt; Iter::value_type, const T&amp; &gt;</ins>
  void
  uninitialized_fill_n(<del>ForwardIterator</del> <ins>Iter</ins> first, Size n, const T&amp; x);
</pre></blockquote>

<p>
Update as follows:
</p>

<p>
uninitialized_copy 20.8.11.2 [uninitialized.copy]
</p>

<blockquote><pre>template &lt;<del>class</del> InputIterator <ins>InIter</ins>,
         <del>class ForwardIterator</del> <ins>OutputIterator&lt;auto, InIter::reference&gt; OutIter</ins>&gt; 
   <ins>requires ForwardIterator&lt;OutIter&gt;</ins>
   <del>ForwardIterator</del> <ins>OutIter</ins>
   uninitialized_copy(<del>InputIterator</del> <ins>InIter</ins> first, <del>InputIterator</del> <ins>InIter</ins> last, 
                      <del>ForwardIterator</del> <ins>OutIter</ins> result);
</pre>

<blockquote>
<p>
-1- <i>Effects:</i>
</p>
<blockquote><pre>for (; first != last; ++result, ++first)  {
   new (static_cast&lt;void*&gt;(&amp;*result))
       <del>typename iterator_traits&lt;ForwardIterator&gt;</del> <ins>OutIter</ins>::value_type(*first);
}
</pre></blockquote>

<p>
-2- <i>Returns:</i> <tt>result</tt>
</p>

</blockquote>

<pre>template &lt;<del>class</del> InputIterator <ins>InIter</ins>,
          <del>class</del> <ins>IntegralLike</ins> Size,
          <del>class ForwardIterator</del> <ins>OutputIterator&lt;auto, InIter::reference&gt; OutIter</ins>&gt; 
  <ins>requires ForwardIterator&lt;OutIter&gt;</ins>
  <del>ForwardIterator</del> <ins>OutIter</ins>
  uninitialized_copy_n(<del>InputIterator</del> <ins>InIter</ins> first, Size n, 
                       <del>ForwardIterator</del> <ins>OutIter</ins> result);
</pre>

<blockquote>
<p>
-3- Effects:
</p>
<blockquote><pre>for ( ; n &gt; <ins>Size(</ins>0<ins>)</ins>; ++result, ++first, --n) {
   new (static_cast&lt;void*&gt;(&amp;*result))
       <del>typename iterator_traits&lt;ForwardIterator&gt;</del> <ins>OutIter</ins>::value_type(*first);
}
</pre></blockquote>
<p>
-4- <i>Returns:</i> result
</p>
</blockquote>

</blockquote>


<p>
uninitialized_fill 20.8.11.3 [uninitialized.fill]
</p>

<blockquote><pre>template &lt;<del>class</del> ForwardIterator <ins>Iter</ins>, <del>class</del> <ins>ObjectType</ins> T&gt;
  <ins>requires Constructible&lt; Iter::value_type, const T&amp; &gt;</ins>
  void uninitialized_fill(<del>ForwardIterator</del> <ins>Iter</ins> first, <del>ForwardIterator</del> <ins>Iter</ins> last, 
                          const T&amp; x);
</pre>

<blockquote>
<p>
-1- <i>Effects:</i>
</p>
<blockquote><pre>for (; first != last; ++first) {
   new ( static_cast&lt;void*&gt;( &amp;*first) ) 
       <del>typename iterator_traits&lt;ForwardIterator&gt;</del> <ins>Iter</ins>::value_type(x);
}
</pre></blockquote>
</blockquote>
</blockquote>


<p>
uninitialized_fill_n 20.8.11.4 [uninitialized.fill.n]
</p>

<blockquote><pre>template &lt;<del>class</del> ForwardIterator <ins>Iter</ins>, <del>class</del> <ins>IntegralLike</ins> Size, <del>class</del> <ins>ObjectType</ins> T&gt; 
  <ins>requires Constructible&lt; Iter::value_type, const T&amp; &gt;</ins>
  void
  uninitialized_fill_n(<del>ForwardIterator</del> <ins>Iter</ins> first, Size n, const T&amp; x);
</pre>

<blockquote>
<p>
-1- <i>Effects:</i>
</p>
<blockquote><pre>for (; n<del>--</del> <ins>&gt; Size(0)</ins>; ++first<ins>, --n</ins>) {
   new ( static_cast&lt;void*&gt;( &amp;*first) ) 
       <del>typename iterator_traits&lt;ForwardIterator&gt;</del> <ins>Iter</ins>::value_type(x);
}
</pre></blockquote>
</blockquote>
</blockquote>






<hr>
<h3><a name="1030"></a>1030. Response to JP 44</h3>
<p><b>Section:</b> 20.8.13.6 [util.smartptr.shared.atomic] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11  <b>Last modified:</b> 2009-03-12</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses JP 44</b></p>

<p>
The 1st parameter <tt>p</tt> and 2nd parameter <tt>v</tt> is now
<tt>shared_ptr&lt;T&gt;*</tt>.
</p>
<p>
It should be <tt>shared_ptr&lt;T&gt;&amp;</tt>, or if these are
<tt>shared_ptr&lt;T&gt;*</tt> then add the "<tt>p</tt> shall not be a
null pointer" at the requires.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Agree. All of the functions need a requirement that <tt>p</tt> (or
<tt>v</tt>) is a pointer to a valid object.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1031"></a>1031. Response to US 78</h3>
<p><b>Section:</b> 20.8.13.2 [util.smartptr.shared] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11  <b>Last modified:</b> 2009-03-12</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#util.smartptr.shared">active issues</a> in [util.smartptr.shared].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#util.smartptr.shared">issues</a> in [util.smartptr.shared].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses US 78</b></p>

<p>
There is presently no way to convert directly from a <tt>shared_ptr</tt> to a
<tt>unique_ptr</tt>. Add an interface that performs the conversion. 
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
We look forward to a paper on this topic. We recommend no action until a
paper is available. We believe that the shared pointer must use the default
deleter for the conversion to succeed.
</blockquote>

<p><i>[
Peter Dimov adds:
]</i></p>


<blockquote>
This is basically a request for <tt>shared_ptr&lt;&gt;::release</tt> in
disguise, with all the associated problems. Not a good idea.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1032"></a>1032. Response to JP 45</h3>
<p><b>Section:</b> 20.9 [time] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11  <b>Last modified:</b> 2009-03-12</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#time">issues</a> in [time].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses JP 45</b></p>

<p>
<tt>Rep</tt>, <tt>Period</tt>, <tt>Clock</tt> and <tt>Duration</tt>
don't correspond to concept.
</p>
<blockquote><pre>template &lt;class Rep, class Period = ratio&lt;1&gt;&gt; class duration; 
template &lt;class Clock, class Duration = typename Clock::duration&gt; class time_point; 
</pre></blockquote>
<p>
Make concept for <tt>Rep</tt>, <tt>Period</tt>, <tt>Clock</tt> and <tt>Duration</tt>.
Fix 20.9 [time] and <tt>wait_until</tt>
and <tt>wait_for</tt>'s template parameter at 30 [thread]. 
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
We agree that this section needs concepts. We look forward to a paper on
this topic. We recommend no action until a paper is available.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1033"></a>1033. <tt>thread::join()</tt> effects?</h3>
<p><b>Section:</b> 30.3.1.5 [thread.thread.member] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alberto Ganesh Barbati <b>Opened:</b> 2009-03-12  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#thread.thread.member">active issues</a> in [thread.thread.member].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.thread.member">issues</a> in [thread.thread.member].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
While looking at <tt>thread::join()</tt> I think I spotted a couple of
possible defects in the specifications. I could not find a previous
issue or NB comment about that, but I might have missed it.
</p>

<p>
The postconditions clause for <tt>thread::join()</tt> is:
</p>

<blockquote>
<i>Postconditions:</i> If <tt>join()</tt> throws an exception, the value
returned by <tt>get_id()</tt> is unchanged. Otherwise, <tt>get_id() == id()</tt>.
</blockquote>

<p>
and the throws clause is:
</p>

<blockquote>
<i>Throws:</i> <tt>std::system_error</tt> when the postconditions cannot be achieved.
</blockquote>

<p>
Now... how could the postconditions <em>not</em> be achieved?
It's just a matter of resetting the value of <tt>get_id()</tt> or leave it
unchanged! I bet we can always do that. Moreover, it's a chicken-and-egg
problem: in order to decide whether to throw or not I depend on the
postconditions, but the postconditions are different in the two cases.
</p>

<p>
I believe the throws clause should be:
</p>

<blockquote>
<i>Throws:</i> <tt>std::system_error</tt> when the effects or postconditions
cannot be achieved.
</blockquote>

<p>
as it is in <tt>detach()</tt>, or, even better, as the postcondition is
trivially satisfiable and to remove the circular dependency:
</p>


<blockquote>
<i>Throws:</i> <tt>std::system_error</tt> if the effects cannot be achieved.
</blockquote>

<p>
Problem is that... ehm... <tt>join()</tt> has no "Effects" clause. Is that intentional?
</p>

<p><i>[
See the thread starting at c++std-lib-23204 for more discussion.
]</i></p>


<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Pete believes there may be some more general language (in frontmatter)
that can address this and related issues such as <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#962">962</a>.
</p>
<p>
Move to Open.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1034"></a>1034. Response to UK 222</h3>
<p><b>Section:</b> 23.2.1 [container.requirements.general] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-12  <b>Last modified:</b> 2009-03-12</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#container.requirements.general">active issues</a> in [container.requirements.general].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#container.requirements.general">issues</a> in [container.requirements.general].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 222</b></p>

<p>
It is not clear what purpose the Requirement tables serve in the
Containers clause. Are they the definition of a library Container? Or
simply a conventient shorthand to factor common semantics into a single
place, simplifying the description of each subsequent container? This
becomes an issue for 'containers' like <tt>array</tt>, which does not meet the
default-construct-to-empty requirement, or <tt>forward_list</tt> which does not
support the size operation. Are these components no longer containers?
Does that mean the remaining requirements don't apply? Or are these
contradictions that need fixing, despite being a clear design decision?
</p>

<p>
Recommend:
</p>

<p>
Clarify all the tables in 23.2 [container.requirements] are
there as a convenience for documentation, rather than a strict set of
requirements. Containers should be allowed to relax specific
requirements if they call attention to them in their documentation. The
introductory text for <tt>array</tt> should be expanded to mention a
default constructed <tt>array</tt> is not empty, and
<tt>forward_list</tt> introduction should mention it does not provide
the required <tt>size</tt> operation as it cannot be implemented
efficiently.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Agree in principle.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1035"></a>1035. Response to UK 226</h3>
<p><b>Section:</b> 23.2.1 [container.requirements.general] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-12  <b>Last modified:</b> 2009-05-02</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#container.requirements.general">active issues</a> in [container.requirements.general].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#container.requirements.general">issues</a> in [container.requirements.general].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 226</b></p>

<p>
<tt>&lt;array&gt;</tt> must be added to this list. In particular it
doesn't satisfy: - no <tt>swap()</tt> function invalidates any
references, pointers, or iterators referring to the elements of the
containers being swapped. and probably doesn't satisfy: - no
<tt>swap()</tt> function throws an exception.
</p>
<p>
If <tt>&lt;array&gt;</tt> remains a container, this will have to also
reference <tt>array</tt>, which will then have to say which of these
points it satisfies.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Agree. The proposed resolution is incomplete. Further work required.
</blockquote>

<p><i>[
2009-05-01 Daniel adds:
]</i></p>


<blockquote>
Issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1099">1099</a> also suggests
adding move constructor to this.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1036"></a>1036. Response to UK 231</h3>
<p><b>Section:</b> 23.2.3 [sequence.reqmts] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-12  <b>Last modified:</b> 2009-03-12</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#sequence.reqmts">active issues</a> in [sequence.reqmts].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#sequence.reqmts">issues</a> in [sequence.reqmts].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 231</b></p>

<p>
p9-p11 are redundant now that Concepts define what it means to be an
Iterator and guide overload resolution accordingly. 
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Agree with issue and change to 23.2.3 [sequence.reqmts]. The
changes required to 21 [strings] will be part of the general
concept support for that clause.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Strike 23.2.3 [sequence.reqmts]p9-11. Make sure <tt>std::basic_string</tt>
has constraints similar to
<tt>std::vector</tt> to meet this old guarantee. 
</p>





<hr>
<h3><a name="1037"></a>1037. Response to UK 232</h3>
<p><b>Section:</b> 23.2.3 [sequence.reqmts] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-12  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#sequence.reqmts">active issues</a> in [sequence.reqmts].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#sequence.reqmts">issues</a> in [sequence.reqmts].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 232</b></p>

<p>
<tt>match_results</tt> may follow the requirements but is not listed a general
purpose library container.
</p>

<p>
Remove reference to <tt>match_results</tt> against <tt>a[n]</tt> operation.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Agree. <tt>operator[]</tt> is defined elsewhere.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution.
Move to Tentatively Ready.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
In 23.2.3 [sequence.reqmts] Table 84, remove reference to
<tt>match_results</tt> in the row describing the <tt>a[n]</tt> operation.
</p>





<hr>
<h3><a name="1038"></a>1038. Response to UK 233</h3>
<p><b>Section:</b> 23.2.3 [sequence.reqmts] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-12  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#sequence.reqmts">active issues</a> in [sequence.reqmts].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#sequence.reqmts">issues</a> in [sequence.reqmts].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 233</b></p>

<p>
Table 84 is missing references to several new container types.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Agree.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution.
Move to Tentatively Ready.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
In 23.2.3 [sequence.reqmts] Table 84, Add reference to listed
containers to the following rows:
</p>

<blockquote>
<table border="1">
<caption>Table 84 -- Optional sequence container operations</caption>
<tbody><tr>
<th>Expression</th>
<th>Return type</th>
<th>Operational semantics</th>
<th>Container</th>
</tr>
<tr>
<td><tt>a.front()</tt></td>
<td>...</td>
<td>...</td>
<td><tt>vector, list, deque, basic_string<ins>, array, forward_list</ins></tt></td>
</tr>
<tr>
<td><tt>a.back()</tt></td>
<td>...</td>
<td>...</td>
<td><tt>vector, list, deque, basic_string<ins>, array</ins></tt></td>
</tr>
<tr>
<td><tt>a.emplace_front(args)</tt></td>
<td>...</td>
<td>...</td>
<td><tt>list, deque<ins>, forward_list</ins></tt></td>
</tr>
<tr>
<td><tt>a.push_front(t)</tt></td>
<td>...</td>
<td>...</td>
<td><tt>list, deque<ins>, forward_list</ins></tt></td>
</tr>
<tr>
<td><tt>a.push_front(rv)</tt></td>
<td>...</td>
<td>...</td>
<td><tt>list, deque<ins>, forward_list</ins></tt></td>
</tr>
<tr>
<td><tt>a.pop_front()</tt></td>
<td>...</td>
<td>...</td>
<td><tt>list, deque<ins>, forward_list</ins></tt></td>
</tr>
<tr>
<td><tt>a[n]</tt></td>
<td>...</td>
<td>...</td>
<td><tt>vector, deque, basic_string<ins>, array</ins></tt></td>
</tr>
<tr>
<td><tt>a.at(n)</tt></td>
<td>...</td>
<td>...</td>
<td><tt>vector, deque<ins>, basic_string, array</ins></tt></td>
</tr>
</tbody></table>
</blockquote>





<hr>
<h3><a name="1039"></a>1039. Response to UK 234</h3>
<p><b>Section:</b> 23.2.3 [sequence.reqmts] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-12  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#sequence.reqmts">active issues</a> in [sequence.reqmts].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#sequence.reqmts">issues</a> in [sequence.reqmts].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 234</b></p>

<p>
The reference to <tt>iterator</tt> in semantics for <tt>back</tt> should
also allow for <tt>const_iterator</tt> when called on a const-qualified
container. This would be ugly to specify in the 03 standard, but is
quite easy with the addition of <tt>auto</tt> in this new standard.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Agree.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution.
Move to Tentatively Ready.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
In 23.2.3 [sequence.reqmts] Table 84, replace iterator with auto in semantics for back:
</p>

<blockquote>
<table border="1">
<caption>Table 84 -- Optional sequence container operations</caption>
<tbody><tr>
<th>Expression</th>
<th>Return type</th>
<th>Operational semantics</th>
<th>Container</th>
</tr>
<tr>
<td><tt>a.back()</tt></td>
<td><tt>reference; const_reference</tt> for constant <tt>a</tt></td>
<td><tt>{ <del>iterator</del> <ins>auto</ins> tmp = a.end();<br>--tmp;<br>return *tmp; }</tt></td>
<td><tt>vector, list, deque, basic_string</tt></td>
</tr>
</tbody></table>
</blockquote>





<hr>
<h3><a name="1040"></a>1040. Response to UK 238</h3>
<p><b>Section:</b> 23.2.4 [associative.reqmts] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-12  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#associative.reqmts">active issues</a> in [associative.reqmts].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#associative.reqmts">issues</a> in [associative.reqmts].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 238</b></p>

<p>
Leaving it unspecified whether or not <tt>iterator</tt> and <tt>const_iterator</tt> are the
same type is dangerous, as user code may or may not violate the One
Definition Rule by providing overloads for 
both types. It is probably too late to specify a single behaviour, but
implementors should document what to expect. Observing that problems can be
avoided by users restricting themselves to using <tt>const_iterator</tt>, add a note to that effect. 
</p>
<p>
Suggest Change 'unspecified' to 'implementation defined'.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Agree with issue. Agree with adding the note but not with changing the
normative text. We believe the note provides sufficient guidance.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution.
Move to Tentatively Ready.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
In 23.2.4 [associative.reqmts] p6, add:
</p>

<blockquote>
-6- <tt>iterator</tt> of an associative container meets the requirements
of the <tt>BidirectionalIterator</tt> concept. For associative
containers where the value type is the same as the key type, both
<tt>iterator</tt> and <tt>const_iterator</tt> are constant iterators. It
is unspecified whether or not <tt>iterator</tt> and
<tt>const_iterator</tt> are the same type.
<ins>[<i>Note:</i> <tt>iterator</tt> and <tt>const_iterator</tt> have identical semantics in
this case, and <tt>iterator</tt> is convertible to <tt>const_iterator</tt>. Users can avoid
violating the One Definition Rule by always using <tt>const_iterator</tt>
in their function parameter lists <i>-- end note</i>]</ins>
</blockquote>





<hr>
<h3><a name="1041"></a>1041. Response to UK 239</h3>
<p><b>Section:</b> 23.2.4 [associative.reqmts] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-12  <b>Last modified:</b> 2009-03-15</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#associative.reqmts">active issues</a> in [associative.reqmts].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#associative.reqmts">issues</a> in [associative.reqmts].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 239</b></p>

<p>
It is not possible to take a move-only key out of an unordered
container, such as (<tt>multi</tt>)<tt>set</tt> or
(<tt>multi</tt>)<tt>map</tt>, or the new unordered containers.
</p>

<p>
Add below <tt>a.erase(q)</tt>, <tt>a.extract(q)</tt>, with the following notation:
</p>
<p>
<tt>a.extract(q)&gt;</tt>, Return type <tt>pair&lt;key, iterator&gt;</tt>
Extracts the element pointed to by <tt>q</tt> and erases it from the
<tt>set</tt>. Returns a <tt>pair</tt> containing the value pointed to by
<tt>q</tt> and an <tt>iterator</tt> pointing to the element immediately
following <tt>q</tt> prior to the element being erased. If no such
element exists,returns <tt>a.end()</tt>.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
We look forward to a paper on this topic. We recommend no action until a
paper is available. The paper would need to address exception safety.
</blockquote>

<p><i>[
Post Summit Alisdair adds:
]</i></p>


<blockquote>
Would <tt>value_type</tt> be a better return type than <tt>key_type</tt>?
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
In 23.2.4 [associative.reqmts] Table 85, add:
</p>

<blockquote>
<table border="1">
<caption>Table 85 --  Associative container requirements (in addition to container)</caption>
<tbody><tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion/note<br>pre-/post-condition</th>
<th>Complexity</th>
</tr>
<tr><td><tt>a.erase(q)</tt></td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr><tr>
<td><ins><tt>a.extract(q)</tt></ins></td>
<td><ins><tt>pair&lt;key_type, iterator&gt;</tt></ins></td>
<td><ins>Extracts the element pointed to by <tt>q</tt> and erases it from the <tt>set</tt>. 
Returns a <tt>pair</tt> containing the value pointed to by <tt>q</tt> and an <tt>iterator</tt>
pointing to the element immediately following <tt>q</tt> prior to the element being
erased. If no such element 
exists, returns <tt>a.end()</tt>.</ins></td>
<td><ins>amortized constant</ins></td>
</tr>
</tbody></table>
</blockquote>

<p>
In 23.2.5 [unord.req] Table 87, add:
</p>

<blockquote>
<table border="1">
<caption>Table 87 -- Unordered associative container requirements (in addition to container)</caption>
<tbody><tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion/note<br>pre-/post-condition</th>
<th>Complexity</th>
</tr>
<tr><td><tt>a.erase(q)</tt></td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr><tr>
<td><ins><tt>a.extract(q)</tt></ins></td>
<td><ins><tt>pair&lt;key_type, iterator&gt;</tt></ins></td>
<td><ins>Extracts the element pointed to by <tt>q</tt> and erases it from the <tt>set</tt>. 
Returns a <tt>pair</tt> containing the value pointed to by <tt>q</tt> and an <tt>iterator</tt>
pointing to the element immediately following <tt>q</tt> prior to the element being
erased. If no such element 
exists, returns <tt>a.end()</tt>.</ins></td>
<td><ins>amortized constant</ins></td>
</tr>
</tbody></table>
</blockquote>





<hr>
<h3><a name="1042"></a>1042. Response to UK 244</h3>
<p><b>Section:</b> 23.3 [sequences] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-12  <b>Last modified:</b> 2009-03-14</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#sequences">issues</a> in [sequences].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 244</b></p>

<p>
The validity of the expression <tt>&amp;a[n] == &amp;a[0] + n</tt> is contingent on
<tt>operator&amp;</tt> doing the "right thing" (as captured by the <tt>CopyConstructible</tt>
requirements in table 30 in C++2003). However this constraint has been
lost in the Concepts of C++0x. This applies to <tt>vector</tt> and <tt>array</tt> (it
actually applies to <tt>string</tt> also, but that's a different chapter, so I'll
file a separate comment there and cross-reference).
</p>

<p>
Suggested solution:
</p>

<p>
Define a <tt>ContiguousStrorage</tt> and apply it to
<tt>vector</tt>, <tt>array</tt> and <tt>string</tt>.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Agree with the issue but not the details of the proposed solution. Walter to
provide wording for the new concept.
</blockquote>

<p><i>[
Post Summit Alisdair adds:
]</i></p>


<blockquote>
Another LWG subgroup wondered if this concept
should extend to <tt>complex&lt;T&gt;</tt>, and so not be built on the container concept at
all?
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add to <tt>&lt;container_concepts&gt;</tt> synopsis in 23.2.6 [container.concepts]
</p>

<blockquote><pre><ins>concept&lt; typename C &gt; ContiguousStorageContainer <i>see below</i>;</ins>
</pre></blockquote>

<p>
Add a new section to the end of 23.2.6 [container.concepts]
</p>

<blockquote>
<p>
23.1.6.x ContiguousStorageContainer concept [container.concepts.contiguous]
</p>

<pre>concept ContiguousStorageContainer&lt; typename C &gt;
  : Container&lt;C&gt;
{
  value_type* data(C&amp;);

  axiom Contiguity(C&amp; c, size_type i) {
    if( i &lt; size(c) ) {
         addressof( * (data(c) + i) )
      == addressof( * advance(data(c), i) );
    }
  }
}
</pre>

<p>
The <tt>ContiguousStorageContainer</tt> concept describes a container whose elements
are allocated in a single region of memory, and are stored sequentially
without intervening padding other than to meet alignment requirements.
For example, the elements may be stored in a
single array of suitable length.
</p>

<pre>value_type * data( C&amp; );
</pre>

<blockquote>
<i>Returns:</i> a pointer to the first element in the region of storage.
Result is unspecified for an empty container.
</blockquote>

</blockquote>

<p>
Change 23.3.1 [array] p1:
</p>

<blockquote>
-1- The header <tt>&lt;array&gt;</tt> defines a class template for
storing fixed-size sequences of objects. An <tt>array</tt> supports
random access iterators. An instance of <tt>array&lt;T, N&gt;</tt>
stores <tt>N</tt> elements of type <tt>T</tt>, so that <tt>size() ==
N</tt> is an invariant. The elements of an <tt>array</tt> are stored
contiguously, meaning that <del>if <tt>a</tt> is</del> an
<tt>array&lt;T, N&gt;</tt> <del>then it obeys the identity <tt>&amp;a[n]
== &amp;a[0] + n</tt> for all <tt>0 &lt;= n &lt; N</tt></del>
<ins>satisfies the concept <tt>ContiguousStorageContainer&lt; array&lt;T,
N&gt;&gt;</tt></ins>.
</blockquote>

<p>
Add to the synopsis in 23.3.1 [array]:
</p>

<blockquote><pre>    ...
    T * data(); 
    const T * data() const; 
  };

  <ins>template&lt; typename T, size_t N &gt;</ins>
    <ins>concept_map ContiguousStorageContainer&lt; array&lt;T, N&gt;&gt; {};</ins>
} 
</pre></blockquote>

<p>
Change 23.3.6 [vector] p1:
</p>

<blockquote>
A <tt>vector</tt> is a sequence container that supports random access
iterators. In addition, it supports (amortized) constant time insert and
erase operations at the end; insert and erase in the middle take linear
time. Storage management is handled automatically, though hints can be
given to improve efficiency. The elements of a vector are stored
contiguously, meaning that <del>if <tt>v</tt> is</del> a
<tt>vector&lt;T, Alloc&gt;</tt> <ins>(</ins>where <tt>T</tt> is some
type other than <tt>bool</tt><ins>)</ins><del>, then it obeys the
identity <tt>&amp;v[n] == &amp;v[0] + n</tt> for all <tt>0 &lt;= n &lt;
v.size()</tt></del> <ins>satisfies the concept <tt>ContiguousStorageContainer&lt;
vector&lt; T, Alloc&gt;&gt;</tt></ins>.
</blockquote>

<p>
Add at the end of the synopsis in 23.3.6 [vector] p2:
</p>

<blockquote><pre><ins>template&lt; typename T, typename A &gt;
  requires !SameType&lt; T, bool &gt;
  concept_map ContiguousStorageContainer&lt; vector&lt;T, A&gt;&gt; {};</ins>
</pre></blockquote>






<hr>
<h3><a name="1043"></a>1043. Response to US 91</h3>
<p><b>Section:</b> 29.6 [atomics.types.operations] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Review">Review</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-12  <b>Last modified:</b> 2009-05-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#atomics.types.operations">issues</a> in [atomics.types.operations].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Review">Review</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses US 91</b></p>

<p>
It is unclear whether or not a failed <tt>compare_exchange</tt> is a RMW operation
(as used in 1.10 [intro.multithread]).
</p>

<p>
Suggested solution:
</p>

<p>
Make failing <tt>compare_exchange</tt> operations <b>not</b> be RMW.
</p>

<p><i>[
Anthony Williams adds:
]</i></p>


<blockquote>
In 29.6 [atomics.types.operations] p18 it says that "These
operations are atomic read-modify-write operations" (final sentence).
This is overly restrictive on the implementations of
<tt>compare_exchange_weak</tt> and <tt>compare_exchange_strong</tt> on platforms without a
native CAS instruction.
</blockquote>


<p><i>[
Summit:
]</i></p>


<blockquote>
Group agrees with the resolution as proposed by Anthony Williams in the attached note.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We recommend the proposed resolution be reviewed
by members of the Concurrency Subgroup.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 29.6 [atomics.types.operations] p18:
</p>

<blockquote>
-18- <i>Effects:</i> Atomically, compares the value pointed to by
<tt>object</tt> or by <tt>this</tt> for equality with that in
<tt>expected</tt>, and if true, replaces the value pointed to by
<tt>object</tt> or by <tt>this</tt> with desired, and if false, updates
the value in <tt>expected</tt> with the value pointed to by
<tt>object</tt> or by <tt>this</tt>. Further, if the comparison is true,
memory is affected according to the value of <tt>success</tt>, and if the
comparison is false, memory is affected according to the value of
<tt>failure</tt>. When only one <tt>memory_order</tt> argument is
supplied, the value of <tt>success</tt> is <tt>order</tt>, and the value
of <tt>failure</tt> is <tt>order</tt> except that a value of
<tt>memory_order_acq_rel</tt> shall be replaced by the value
<tt>memory_order_acquire</tt> and a value of
<tt>memory_order_release</tt> shall be replaced by the value
<tt>memory_order_relaxed</tt>. <ins>If the comparison is <tt>true</tt>, </ins>
<del>T</del><ins>t</ins>hese operations are atomic
read-modify-write operations (1.10). 
<ins>If the comparison is <tt>false</tt>, these
operations are atomic load operations.</ins>
</blockquote>






<hr>
<h3><a name="1044"></a>1044. Response to UK 325</h3>
<p><b>Section:</b> 30.4 [thread.mutex] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-12  <b>Last modified:</b> 2009-05-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 325</b></p>

<p>
We believe constexpr literal values should be a more natural expression
of empty tag types than extern objects as it should improve the
compiler's ability to optimize the empty object away completely.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Move to review. The current specification is a "hack", and the proposed
specification is a better "hack".
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution.
Move to Tentatively Ready.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change the synopsis in 30.4 [thread.mutex]:
</p>

<blockquote><pre>struct defer_lock_t <ins>{}</ins>;
struct try_to_lock_t <ins>{}</ins>;
struct adopt_lock_t <ins>{}</ins>;

<del>extern</del> const<ins>expr</ins> defer_lock_t defer_lock <ins>{}</ins>;
<del>extern</del> const<ins>expr</ins> try_to_lock_t try_to_lock <ins>{}</ins>;
<del>extern</del> const<ins>expr</ins> adopt_lock_t adopt_lock <ins>{}</ins>;
</pre></blockquote>






<hr>
<h3><a name="1045"></a>1045. Response to UK 326</h3>
<p><b>Section:</b> 30.4.3.2.1 [thread.lock.unique.cons] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-12  <b>Last modified:</b> 2009-05-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 326</b></p>

<p>
The precondition that the mutex is not owned by this thread offers
introduces the risk of un-necessary undefined behaviour into the
program. The only time it matters whether the current thread owns the
mutex is in the lock operation, and that will happen subsequent to
construction in this case. The lock operation has the identical
pre-condition, so there is nothing gained by asserting that precondition
earlier and denying the program the right to get into a valid state
before calling lock.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Agree, move to review.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution.
Move to Tentatively Ready.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Strike 30.4.3.2.1 [thread.lock.unique.cons] p7:
</p>

<blockquote><pre>unique_lock(mutex_type&amp; m, defer_lock_t);
</pre>
<blockquote>
<del>-7- <i>Precondition:</i> If <tt>mutex_type</tt> is not a recursive mutex
the calling thread does not own the mutex.</del>
</blockquote>
</blockquote>






<hr>
<h3><a name="1046"></a>1046. Response to UK 329</h3>
<p><b>Section:</b> 30.6 [futures] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-12  <b>Last modified:</b> 2009-03-13</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 329</b></p>

<p>
<tt>future</tt>, <tt>promise</tt> and <tt>packaged_task</tt> provide a
framework for creating future values, but a simple function to tie all
three components together is missing. Note that we only need a *simple*
facility for C++0x. Advanced thread pools are to be left for TR2.
</p>

<p>
Simple Proposal:
</p>

<p>
Provide a simple function along the lines of: 
</p>
<blockquote><pre>template&lt; typename F, typename ... Args &gt;
  requires Callable&lt; F, Args... &gt;
    future&lt; Callable::result_type &gt; async( F&amp;&amp; f, Args &amp;&amp; ... ); 
</pre></blockquote>

<p>
Semantics are similar to creating a <tt>thread</tt> object with a <tt>packaged_task</tt>
invoking <tt>f</tt> with <tt>forward&lt;Args&gt;(args...)</tt>
but details are left unspecified to allow different scheduling and thread
spawning implementations. 
</p>
<p>
It is unspecified whether a task submitted to async is run on its own thread
or a thread previously used for another async task. If a call to <tt>async</tt>
succeeds, it shall be safe to wait for it from any thread. 
</p>
<p>
The state of <tt>thread_local</tt> variables shall be preserved during <tt>async</tt> calls. 
</p>
<p>
No two incomplete async tasks shall see the same value of
<tt>this_thread::get_id()</tt>. 
</p>
<p>
[<i>Note:</i> this effectively forces new tasks to be run on a new thread, or a
fixed-size pool with no queue. If the 
library is unable to spawn a new thread or there are no free worker threads
then the <tt>async</tt> call should fail. <i>--end note</i>] 
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
<p>
The concurrency subgroup has revisited this issue and decided that it
could be considered a defect according to the Kona compromise. A task
group was formed lead by Lawrence Crowl and Bjarne Stroustrup to write a
paper for Frankfort proposing a simple asynchronous launch facility
returning a <tt>future</tt>. It was agreed that the callable must be run on a
separate thread from the caller, but not necessarily a brand-new thread.
The proposal might or might not allow for an implementation that uses
fixed-size or unlimited thread pools.
</p>
<p>
Bjarne in c++std-lib-23121: I think that what we agreed was that to
avoid deadlock <tt>async()</tt> would almost certainly be specified to  launch in
a different thread from the thread that executed <tt>async()</tt>, but I don't
think it was a specific design constraint.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1047"></a>1047. Response to UK 334</h3>
<p><b>Section:</b> 30.6.4 [futures.unique_future] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Review">Review</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-12  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#futures.unique_future">active issues</a> in [futures.unique_future].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#futures.unique_future">issues</a> in [futures.unique_future].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Review">Review</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 334</b></p>

<p>
Behaviour of <tt>get()</tt> is undefined if calling <tt>get()</tt> while
not <tt>is_ready()</tt>. The intent is that <tt>get()</tt> is a blocking
call, and will wait for the future to become ready.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
<p>
Agree, move to Review.
</p>
</blockquote>

<p><i>[
2009-04-03 Thomas J. Gritzan adds:
]</i></p>


<blockquote>
<p>
This issue also applies to <tt>shared_future::get()</tt>.
</p>

<p>
Suggested wording:
</p>

<p>
Add a paragraph to  [futures.shared_future]:
</p>

<blockquote><pre>void shared_future&lt;void&gt;::get() const;
</pre>
<blockquote>
<i>Effects:</i> If <tt>is_ready()</tt> would return <tt>false</tt>, block on the asynchronous 
result associated with <tt>*this</tt>.
</blockquote>
</blockquote>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
It is not clear to us that this is an issue,
because the proposed resolution's Effects clause seems to duplicate
information already present in the Synchronization clause.
Keep in Review status.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Add a paragraph to 30.6.4 [futures.unique_future]:
</p>

<blockquote><pre>R&amp;&amp; unique_future::get(); 
R&amp; unique_future&lt;R&amp;&gt;::get(); 
void unique_future&lt;void&gt;::get();
</pre>
<blockquote>
<p><i>Note:</i>...</p>
<p>
<ins><i>Effects:</i> If <tt>is_ready()</tt> would return <tt>false</tt>,
block on the asynchronous result associated with <tt>*this</tt>.</ins>
</p>
<p>
<i>Synchronization:</i> if <tt>*this</tt> is associated with a
<tt>promise</tt> object, the completion of <tt>set_value()</tt> or
<tt>set_exception()</tt> to that <tt>promise</tt> happens before (1.10)
<tt>get()</tt> returns.
</p>
</blockquote>
</blockquote>





<hr>
<h3><a name="1048"></a>1048. Response to UK 335</h3>
<p><b>Section:</b> 30.6.4 [futures.unique_future] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-12  <b>Last modified:</b> 2009-03-13</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#futures.unique_future">active issues</a> in [futures.unique_future].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#futures.unique_future">issues</a> in [futures.unique_future].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 335</b></p>

<p>
<tt>std::unique_future</tt> is <tt>MoveConstructible</tt>, so you can transfer the
association with an asynchronous result from one instance to another.
However, there is no way to determine whether or not an instance has
been moved from, and therefore whether or not it is safe to wait for it.
</p>

<blockquote><pre>std::promise&lt;int&gt; p;
std::unique_future&lt;int&gt; uf(p.get_future());
std::unique_future&lt;int&gt; uf2(std::move(uf));
uf.wait(); <font color="#c80000">// oops, uf has no result to wait for. </font>
</pre></blockquote>

<p>
Suggest we add a <tt>waitable()</tt> function to <tt>unique_future</tt>
(and <tt>shared_future</tt>) akin to <tt>std::thread::joinable()</tt>,
which returns <tt>true</tt> if there is an associated result to wait for
(whether or not it is ready).
</p>

<p>
Then we can say:
</p>

<blockquote><pre>if(uf.waitable()) uf.wait();
</pre></blockquote>

<p><i>[
Summit:
]</i></p>


<blockquote>
<p>
Create an issue. Requires input from Howard. Probably NAD.
</p>
</blockquote>

<p><i>[
Post Summit, Howard thows in his two cents:
]</i></p>


<blockquote>
<p>
Here is a copy/paste of my last prototype of <tt>unique_future</tt> which was
several years ago.  At that time I was calling <tt>unique_future</tt> <tt>future</tt>:
</p>

<blockquote><pre>template &lt;class R&gt;
class future
{
public:
    typedef R result_type;
private:
    future(const future&amp;);// = delete;
    future&amp; operator=(const future&amp;);// = delete;

    template &lt;class R1, class F1&gt; friend class prommise;
public:
    future();
    ~future();

    future(future&amp;&amp; f);
    future&amp; operator=(future&amp;&amp; f);

    void swap(future&amp;&amp; f);

    <b>bool joinable() const;</b>
    bool is_normal() const;
    bool is_exceptional() const;
    bool is_ready() const;

    R get();

    void join();
    template &lt;class ElapsedTime&gt;
        bool timed_join(const ElapsedTime&amp;);
};
</pre></blockquote>

<p>
<tt>shared_future</tt> had a similar interface.  I intentionally reused
the <tt>thread</tt> interface where possible to lessen the learning
curve std::lib clients will be faced with.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1049"></a>1049. Response to UK 339</h3>
<p><b>Section:</b> 30.6.6 [futures.promise] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Review">Review</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-12  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#futures.promise">active issues</a> in [futures.promise].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#futures.promise">issues</a> in [futures.promise].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Review">Review</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 339</b></p>

<p>
Move assignment is goiing in the wrong direction, assigning from
<tt>*this</tt> to the passed rvalue, and then returning a reference to
an unusable <tt>*this</tt>.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
<p>
Agree, move to Review.
</p>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We recommend deferring this issue until after Detlef's paper (on futures)
has been issued.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Strike 30.6.6 [futures.promise] p6 and change p7:
</p>

<blockquote><pre>promise&amp; operator=(promise&amp;&amp; rhs);
</pre>
<blockquote>
<p>
<del>-6- <i>Effects:</i> move assigns its associated state to <tt>rhs</tt>.</del>
</p>
<p>
-7- <i>Postcondition:</i> <del><tt>*this</tt> has no associated
state.</del> <ins>associated state of <tt>*this</tt> is the same as the
associated state of <tt>rhs</tt> before the call. <tt>rhs</tt> has no
associated state.</ins>
</p>
</blockquote>
</blockquote>






<hr>
<h3><a name="1050"></a>1050. Response to UK 340</h3>
<p><b>Section:</b> 30.6.6 [futures.promise] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Review">Review</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-12  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#futures.promise">active issues</a> in [futures.promise].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#futures.promise">issues</a> in [futures.promise].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Review">Review</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 340</b></p>

<p>
There is an implied postcondition for <tt>get_future()</tt> that the state of the
<tt>promise</tt> is transferred into the <tt>future</tt> leaving the <tt>promise</tt> with no
associated state. It should be spelled out.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
<p>
Agree, move to Review.
</p>
</blockquote>

<p><i>[
2009-04-03 Thomas J. Gritzan adds:
]</i></p>


<blockquote>
<p>
<tt>promise::get_future()</tt> must not invalidate the state of the promise object. 
</p>
<p>
A promise is used like this: 
</p>
<blockquote><pre>promise&lt;int&gt; p; 
unique_future&lt;int&gt; f = p.get_future(); 
<font color="#c80000">// post 'p' to a thread that calculates a value </font>
<font color="#c80000">// use 'f' to retrieve the value. </font>
</pre></blockquote>
<p>
So <tt>get_future()</tt> must return an object that shares the same associated 
state with <tt>*this</tt>. 
</p>
<p>
But still, this function should throw an <tt>future_already_retrieved</tt> error 
when it is called twice. 
</p>
<p>
<tt>packaged_task::get_future()</tt> throws <tt>std::bad_function_call</tt> if its <tt>future</tt>
was already retrieved. It should throw 
<tt>future_error(future_already_retrieved)</tt>, too. 
</p>
<p>
Suggested resolution: 
</p>
<p>
Replace p12/p13 30.6.6 [futures.promise]: 
</p>
<blockquote>
<p>
-12- <i>Throws:</i> <tt>future_error</tt> if <del><tt>*this</tt> has no associated state</del>
<ins>the <tt>future</tt> has already been retrieved</ins>.
</p>
<p>
-13- <i>Error conditions:</i> <tt>future_already_retrieved</tt> if <del><tt>*this</tt>
has no associated state</del>
<ins>the <tt>future</tt> associated with 
the associated state has already been retrieved</ins>.
</p>
<p>
<ins><i>Postcondition:</i> The returned object and <tt>*this</tt> share the associated state.</ins>
</p>
</blockquote>
<p>
Replace p14 30.6.8 [futures.task]: 
</p>
<blockquote>
<p>
-14- <i>Throws:</i> <tt><del>std::bad_function_call</del> <ins>future_error</ins></tt> if the future <del>associated with
the task</del> has already been retrieved.
</p>

<p><ins>
<i>Error conditions:</i> <tt>future_already_retrieved</tt> if the <tt>future</tt> associated with 
the task has already been retrieved. 
</ins></p>
<p>
<ins><i>Postcondition:</i> The returned object and <tt>*this</tt> share the associated task.</ins>
</p>
</blockquote>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Keep in Review status
pending Detlef's forthcoming paper on futures.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Add after p13 30.6.6 [futures.promise]:
</p>

<blockquote><pre>unique_future&lt;R&gt; get_future();
</pre>
<blockquote>
<p>
-13- ...
</p>
<p>
<i>Postcondition:</i> <tt>*this</tt> has no associated state.
</p>
</blockquote>
</blockquote>






<hr>
<h3><a name="1051"></a>1051. Response to UK 279</h3>
<p><b>Section:</b> 24.5.1.2.12 [reverse.iter.opindex], 24.5.3.2.12 [move.iter.op.index] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-12  <b>Last modified:</b> 2009-03-21</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 279</b></p>

<p>
The reason the return type became unspecified is LWG issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#386">386</a>. This
reasoning no longer applies as there are at least two ways to get the right
return type with the new language facilities added since the previous
standard. 
</p>

<p>
Proposal: Specify the return type using either decltype or the Iter concept_map.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
<p>
Under discussion. This is a general question about all iterator
adapters.
</p>
</blockquote>

<p><i>[
Howard adds post Summit:
]</i></p>


<blockquote>
I am requesting test cases to demonstrate a position.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1052"></a>1052. Response to UK 281</h3>
<p><b>Section:</b> 24.5.1.2.5 [reverse.iter.opref] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-12  <b>Last modified:</b> 2009-03-13</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 281</b></p>

<p>
The current specification for return value for <tt>reverse_iterator::operator-&gt;</tt>
will always be a true pointer type, but <tt>reverse_iterator</tt> supports proxy
iterators where the pointer type may be some kind of 'smart pointer'.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
<p>
<tt>move_iterator</tt> avoids this problem by returning a value of the wrapped
Iterator type.
study group formed to come up with a suggested resolution.
</p>
<p>
<tt>move_iterator</tt> solution shown in proposed wording.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change synopsis in 24.5.1.1 [reverse.iterator]:
</p>

<blockquote><pre>template &lt;BidirectionalIterator Iter&gt; 
class reverse_iterator { 
  ...
  typedef Iter<del>::pointer</del> pointer; 
</pre></blockquote>

<p>
Change 24.5.1.2.5 [reverse.iter.opref]:
</p>

<blockquote><pre>pointer operator-&gt;() const;
</pre>
<blockquote>
<i>Returns:</i>
<blockquote><pre><del>&amp;(operator*());</del>
<ins>this-&gt;tmp = current;</ins>
<ins>--this-&gt;tmp;</ins>
<ins>return this-&gt;tmp;</ins>
</pre></blockquote>
</blockquote>
</blockquote>






<hr>
<h3><a name="1053"></a>1053. Response to UK 295</h3>
<p><b>Section:</b> 25 [algorithms] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-12  <b>Last modified:</b> 2009-03-13</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#algorithms">issues</a> in [algorithms].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 295</b></p>

<p>
There is a level of redundancy in the library specification for many
algorithms that can be eliminated with the combination of concepts and
default parameters for function templates. Eliminating redundancy simplified
specification and reduces the risk of introducing accidental
inconsistencies.
</p>
<p>
Proposed resolution: Adopt
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2743.pdf">N2743</a>.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
<p>
NAD, this change would break code that takes the address of an
algorithm.
</p>
</blockquote>

<p><i>[
Post Summit Alisdair adds:
]</i></p>


<blockquote>
<p>
Request 'Open'.  The issues in the paper go beyond just reducing
the number of signatures, but cover unifying the idea of the ordering
operation used by algorithms, containers and other library components.  At
least, it takes a first pass at the problem.
</p>

<p>
For me (personally) that was the more important part of the paper, and not
clearly addressed by the Summit resolution.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1054"></a>1054. <tt>forward</tt> broken</h3>
<p><b>Section:</b> 20.3.2 [forward] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-03-13  <b>Last modified:</b> 2009-05-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#forward">issues</a> in [forward].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
This is a placeholder issue to track the fact that we (well I) put the standard
into an inconsistent state by requesting that we accept
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2844.html">N2844</a>
except for the proposed changes to [forward].
</p>

<p>
There will exist in the post meeting mailing
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2835.html">N2835</a>
which in its current state reflects the state of affairs prior to the Summit
meeting.  I hope to update it in time for the post Summit mailing, but as I write
this issue I have not done so yet.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Move to Open, awaiting the promised paper.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1055"></a>1055. Response to UK 98</h3>
<p><b>Section:</b> 20.6.7 [meta.trans.other] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-12  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#meta.trans.other">active issues</a> in [meta.trans.other].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#meta.trans.other">issues</a> in [meta.trans.other].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 98</b></p>

<p>
It would be useful to be able to determine the underlying
type of an arbitrary enumeration type. This would allow
safe casting to an integral type (especially needed for
scoped enums, which do not promote), and would allow
use of <tt>numeric_limits</tt>. In general it makes generic
programming with enumerations easier.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Pete observes (and Tom concurs)
that the proposed resolution seems to require compiler support
for its implementation,
as it seems necessary to look at the range of values
of the enumerated type.
To a first approximation,
a library solution could give an answer based on the size of the type.
If the user has specialized <tt>numeric_limits</tt> for the enumerated type,
then the library might be able to do better,
but there is no such requirement.
Keep status as Open
and solicit input from CWG.
</blockquote>

<p><i>[
2009-05-23 Alisdair adds:
]</i></p>


<blockquote>
Just to confirm that the BSI originator of this comment assumed it did
indeed imply a compiler intrinsic.  Rather than request a Core extension, it
seemed in keeping with that the type traits interface provides a library API
to unspecified compiler features - where we require several other traits
(e.g. <tt>has_trivial_*</tt>) to get the 'right' answer now, unlike in TR1.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Add a new row to the table in 20.6.7 [meta.trans.other]:
</p>

<blockquote>
<table border="1">
<caption>Table 41 -- Other transformations</caption>
<tbody><tr>
<th>Template</th>
<th>Condition</th>
<th>Comments</th>
</tr>
<tr>
<td>
<tt>template&lt;&nbsp;class&nbsp;T&nbsp;&gt; struct enum_base;</tt>
</td>
<td>
<tt>T</tt> shall be an enumeration type (7.2 [dcl.enum])
</td>
<td>
The member typedef <tt>type</tt> shall name the underlying type
of the enum <tt>T</tt>.
</td>
</tr>
</tbody></table>
</blockquote>





<hr>
<h3><a name="1056"></a>1056. Must all Engines and Distributions be Streamable?</h3>
<p><b>Section:</b> 26.5 [rand] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-12  <b>Last modified:</b> 2009-05-31</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#rand">active issues</a> in [rand].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand">issues</a> in [rand].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Both the concepts <tt>RandomNumberEngine</tt> and <tt>RandomNumberDistribution</tt> have
requirements to be <tt>InputStreamable</tt> and <tt>OutputStreamable</tt>.
</p>
<p>
I have no problems leaving the WP in an inconsistent state on the best-faith
assumption these concepts will be provided later, however disagree with the
proposers that these constraints are not separable, orthogonal to the basic
concepts of generating random number distributions.
</p>
<p>
These constraints should be dropped, and applied to specific algorithms as
needed.
</p>
<p>
If a more refined concept (certainly deemed useful by the proposers) is
proposed there is no objection, but the basic concept should not require
persistence via streaming.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Move to Open.
</blockquote>

<p><i>[
2009-05-31 Alisdair adds:
]</i></p>


<blockquote>
<p>
Working on constraining the stream iterators, I have a few more observations
to make on the concepts proposed while constraining the random number
facility.
</p>
<p>
While I still believe the concerns are orthogonal, I don't believe the
existing constraints go far enough either!  The goal we want to achieve is
not that a <tt>RandomNumberEngine</tt> / <tt>RandomNumberDistribution</tt> supports the stream
operators, but that it is <tt>Serializable</tt>.  I.e. there is a relationship
between the insert and extract operations that guarantees to restore the
state of the original object.  This implies a coupling of the concepts
together in a broader concept (<tt>Serializable</tt>) with at least one axiom to
assert the semantics.
</p>
<p>
One problem is that <tt>istream</tt> and <tt>ostream</tt> may be fundamentally different
types, although we can hook a relation if we are prepared to drop down to
the <tt>char</tt> type and <tt>char_traits</tt> template parameters.  Doing so ties us to a
form of serialization that demands implementation via the std iostreams
framework, which seems overly prescriptive.  I believe the goal is generally
to support serialization without regard to how it is expressed - although
this is getting even more inventive in terms of concepts we do not have
today.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1057"></a>1057. <tt>RandomNumberEngineAdaptor</tt></h3>
<p><b>Section:</b> 26.5 [rand] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-12  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#rand">active issues</a> in [rand].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand">issues</a> in [rand].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
The <tt>RandomNumberEngineAdaptor</tt> concept breaks precedent in the
way the library has been specified by grouping requirements into a
concept that is never actually used in the library.
</p>
<p>
This is undoubtedly a very helpful device for documentation, but we are not
comfortable with the precedent - especially as we have rejected national
body comments on the same grounds.
</p>
<p>
Suggest either removing the concept, or providing an algorithm/type that
requires this concept in their definition (such as a factory function to
create new engines).
</p>
<p>
The preference is to create a single new algorithm and retain the value of
the existing documentation.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Walter points out that it is unlikely that any algorithm would ever
require this concept, but that the concept nonetheless is useful as
documentation, and (via concept maps) as a means of checking specific adapters.
</p>
<p>
Alisdair disagrees as to the concept's value as documentation.
</p>
<p>
Marc points out that the <tt>RandomNumberDistribution</tt>
is also a concept not used elsewhere in the Standard.
</p>
<p>
Pete agrees that a policy of not inventing concepts
that aren't used in the Standard is a good starting point,
but should not be used as a criterion for rejecting a concept.
</p>
<p>
Move to Open.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1058"></a>1058. New container issue</h3>
<p><b>Section:</b> 23.2.3 [sequence.reqmts] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">Tentatively NAD Editorial</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-12  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#sequence.reqmts">active issues</a> in [sequence.reqmts].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#sequence.reqmts">issues</a> in [sequence.reqmts].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20NAD%20Editorial">Tentatively NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Sequence containers 23.2.3 [sequence.reqmts]:
</p>

<p>
The return value of new calls added to table 83 are not specified.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We agree with the proposed resolution.
</p>
<p>
Move to NAD Editorial.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Add after p6 23.2.3 [sequence.reqmts]:
</p>

<blockquote>
<p>
-6- ...
</p>
<p><ins>
The iterator returned from <tt>a.insert(p,rv)</tt> points to the copy of <tt>rv</tt>
inserted into <tt>a</tt>.
</ins></p>
<p><ins>
The iterator returned from <tt>a.emplace(p, args)</tt> points to the new
element constructed from <tt>args</tt> inserted into <tt>a</tt>.
</ins></p>
</blockquote>





<hr>
<h3><a name="1059"></a>1059. Usage of no longer existing FunctionType concept</h3>
<p><b>Section:</b> 20.7.16.2 [func.wrap.func] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2009-03-13  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#func.wrap.func">active issues</a> in [func.wrap.func].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#func.wrap.func">issues</a> in [func.wrap.func].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Due to a deliberate core language decision, the earlier called
"foundation" concept <tt>std::FunctionType</tt> had been removed in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2773.pdf">N2773</a>
shortly
before the first "conceptualized" version of the WP
(<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2798.pdf">N2798</a>)
had been
prepared. This caused a break of the library, which already used this
concept in the adapted definition of <tt>std::function</tt>
(20.7 [function.objects]/2, header <tt>&lt;functional&gt;</tt> synopsis and
20.7.16.2 [func.wrap.func]).
</p>
<p>
A simple fix would be to either (a) make <tt>std::function</tt>'s primary template
unconstrained or to (b) add constraints based on existing (support) concepts.
A more advanced fix would (c) introduce a new library concept.
</p>
<p>
The big disadvantage of (a) is, that users can define templates which
cause compiler errors during instantiation time because of under-constrainedness
and would thus violate the basic advantage of constrained
code.
</p>
<p>
For (b), the ideal constraints for <tt>std::function</tt>'s template parameter would
be one which excludes everything else but the single provided partial
specialization that matches every "free function" type (i.e. any function
type w/o cv-qualifier-seq and w/o ref-qualifier).
Expressing such a type as as single requirement would be written as
</p>
<blockquote><pre>template&lt;typename T&gt;
requires ReferentType&lt;T&gt; // Eliminate cv void and function types with cv-qual-seq
                         //   or ref-qual (depending on core issue #749)
      &amp;&amp; PointeeType&lt;T&gt;  // Eliminate reference types
      &amp;&amp; !ObjectType&lt;T&gt;  // Eliminate object types
</pre></blockquote>
<p>
Just for completeness approach (c), which would make sense, if the
library has more reasons to constrain for free function types:
</p>
<blockquote><pre>auto concept FreeFunctionType&lt;typename T&gt;
  : ReferentType&lt;T&gt;, PointeeType&lt;T&gt;, MemberPointeeType&lt;T&gt;
{
  requires !ObjectType&lt;T&gt;;
}
</pre></blockquote>
<p>
I mention that approach because I expect that free function types belong
to the most natural type categories for every days coders. Potential
candidates in the library are <tt>addressof</tt> and class template <tt>packaged_task</tt>.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Alisdair would prefer to have a core-supported <tt>FunctionType</tt> concept
in order that any future changes be automatically correct
without need for a library solution to catch up;
he points to type traits as a precedent.
Further, he believes that a published concept can't in the future
be changed.
</p>
<p>
Bill feels this category of entity would change sufficiently slowly
that he would be willing to take the risk.
</p>
<p>
Of the discussed solutions, we tend toward option (c).
We like the idea of having a complete taxonomy of native types,
and perhaps erred in trimming the set.
</p>
<p>
We would like to have this issue reviewed by Core and would like
their feedback.  Move to Open.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>
Change in 20.7 [function.objects]/2, Header <tt>&lt;functional&gt;</tt> synopsis:
</p>
<blockquote><pre>// 20.6.16 polymorphic function wrappers:
class bad_function_call;
template&lt;<del>FunctionType</del><ins>ReferentType F</ins>&gt;
<ins>requires PointeeType&lt;F&gt; &amp;&amp; !ObjectType&lt;F&gt;</ins>
class function; // undefined
</pre></blockquote>
</li>
<li>
<p>
Change in 20.7.16.2 [func.wrap.func]:
</p>
<blockquote><pre>namespace std {
template&lt;<del>FunctionType</del><ins>ReferentType F</ins>&gt;
<ins>requires PointeeType&lt;F&gt; &amp;&amp; !ObjectType&lt;F&gt;</ins>
class function; // undefined
</pre></blockquote>
</li>
</ol>





<hr>
<h3><a name="1060"></a>1060. Embedded nulls in NTBS</h3>
<p><b>Section:</b> 17.5.2.1.4.1 [byte.strings] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">Tentatively NAD Editorial</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-13  <b>Last modified:</b> 2009-05-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20NAD%20Editorial">Tentatively NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Definition of null-terminated sequences allow for embedded nulls. This is
surprising, and probably not supportable with the intended use cases.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the issue, but believe this can be handled editorially.
Move to NAD Editorial.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1061"></a>1061. Bad indexing for tuple access to pair (Editorial?)</h3>
<p><b>Section:</b> 20.3.4 [pair.astuple] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">Tentatively NAD Editorial</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-13  <b>Last modified:</b> 2009-05-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20NAD%20Editorial">Tentatively NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p>
The definition of <tt>get</tt> implies that <tt>get</tt> must return the second element if
given a negative integer.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Move to NAD Editorial.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
20.3.4 [pair.astuple] p5:
</p>

<blockquote><pre>template&lt;<del>int</del> <ins>size_t</ins> I, class T1, class T2&gt; 
  requires True&lt;(I &lt; 2)&gt; 
  const P&amp; get(const pair&lt;T1, T2&gt;&amp;);
</pre>
</blockquote>






<hr>
<h3><a name="1062"></a>1062. Missing insert_iterator for stacks/queues</h3>
<p><b>Section:</b> 24.7 [insert.iterators] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-13  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#insert.iterators">active issues</a> in [insert.iterators].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#insert.iterators">issues</a> in [insert.iterators].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
It is odd that we have an iterator to insert into a <tt>vector</tt>, but not an
iterator to insert into a <tt>vector</tt> that is adapted as a <tt>stack</tt>. The standard
container adapters all have a common interface to <tt>push</tt> and <tt>pop</tt> so it should
be simple to create an iterator adapter to complete the library support.
</p>

<p>
We should provide an <tt>AdaptedContainer</tt> concept supporting <tt>push</tt> and <tt>pop</tt>
operations. Create a new insert iterator and factory function that inserts
values into the container by calling <tt>push</tt>.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Walter recommends NAD Future.
</p>
<p>
Move to Open, and recommend deferring the issue until after the next
Committee Draft is issued.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1063"></a>1063. 03 iterator compatibilty</h3>
<p><b>Section:</b> D.10.4 [iterator.backward] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-15  <b>Last modified:</b> 2009-05-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Which header must a user <tt>#include</tt> to obtain the library-supplied
<tt>concept_maps</tt> declared in this paragraph?
</p>

<p>
This is important information, as existing user code will break if this
header is not included, and we should make a point of mandating this header
is <tt>#include</tt>-d by library headers likely to make use of it, notably
<tt>&lt;algorithm&gt;</tt>.  See issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1001">1001</a> for more details.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the direction of the proposed resolution.
Move to Tentatively Ready.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p><i>Change D.10 [depr.lib.iterator.primitives], Iterator primitives, as
indicated:</i></p>

<blockquote>
  <p>To simplify the use of iterators and provide backward compatibility with
  previous C++ Standard Libraries,
  the library provides several classes and functions. <ins>Unless otherwise
  specified, these classes and functions shall be defined in header <tt>&lt;iterator&gt;</tt>.</ins></p>
</blockquote>
<p><i>Change D.10.4 [iterator.backward], Iterator backward compatibility, as
indicated:</i></p>
<blockquote>
  <p>The library provides concept maps that allow iterators specified with
  <tt>iterator_traits</tt> to interoperate with
  algorithms that require iterator concepts. <ins>These concept maps shall be
  defined in the same header that defines the iterator.</ins> [<i>Example:</i></p>
</blockquote>





<hr>
<h3><a name="1064"></a>1064. Response to UK 152</h3>
<p><b>Section:</b> 17.3.15 [defns.obj.state] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-03-15  <b>Last modified:</b> 2009-03-15</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 152</b></p>

<p>
Object state is using a definition of object (instance of a class) from
outside the standard, rather than the 'region of storage' definiton in
1.8 [intro.object]p1
</p>

<p><i>[
Summit:
]</i></p>

<blockquote>
We think we're removing this; See 20.7.18.1 [func.referenceclosure.cons].
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="1065"></a>1065. Response to UK 168</h3>
<p><b>Section:</b> 17.6.1.1 [contents] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-03-15  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#contents">active issues</a> in [contents].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#contents">issues</a> in [contents].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses UK 168</b></p>
<p>
We should make it clear (either by note or normatively) that namespace
<tt>std</tt> may contain inline namespaces, and that entities specified to be
defined in std may in fact be defined in one of these inline namespaces.
(If we're going to use them for versioning, eg when TR2 comes along,
we're going to need that.)
</p>

<p>
Replace "namespace std or namespaces nested within namespace std" with
"namespace std or namespaces nested within namespace std or inline
namespaces nested directly or indirectly within namespace std"
</p>

<p><i>[
Summit:
]</i></p>

<blockquote>
adopt UK words (some have reservations whether it is correct)
</blockquote>

<p><i>[
2009-05-09 Alisdair improves the wording.
]</i></p>


<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Bill believes there is strictly speaking no need to say that
because no portable test can detect the difference.
However he agrees that it doesn't hurt to say this.
</p>
<p>
Move to Tentatively Ready.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 17.6.1.1 [contents] p2:
</p>

<blockquote>
All library entities except macros, <tt>operator new</tt> and
<tt>operator delete</tt> are defined within the namespace <tt>std</tt> or
namespaces nested within namespace <tt>std</tt>.
<ins>It is unspecified whether names declared in a specific namespace
are declared directly in that namespace, or in an inline namespace inside
that namespace. [<i>Footnote:</i> This gives implementers freedom to support
multiple configurations of the library.]</ins>
</blockquote>





<hr>
<h3><a name="1066"></a>1066. Response to UK 189 and JP 27</h3>
<p><b>Section:</b> 18 [language.support] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-03-15  <b>Last modified:</b> 2009-05-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses UK 189 and JP 27</b></p>
<p>
The addition of the <tt>[[noreturn]]</tt> attribute to the language will be an
important aid for static analysis tools.
</p>

<p>
The following functions should be declared in C++ with the
<tt>[[noreturn]]</tt> attribute: <tt>abort</tt> <tt>exit</tt>
<tt>quick_exit</tt> <tt>terminate</tt> <tt>unexpected</tt>
<tt>rethrow_exception</tt> <tt>throw_with_nested</tt>.
</p>

<p><i>[
Summit:
]</i></p>

<blockquote>
Agreed.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution.
Move to Tentatively Ready.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 18.5 [support.start.term] p3:
</p>

<blockquote>
<p>-2- ...</p>
<pre><ins>void</ins> abort <ins>[[noreturn]]</ins> (void)
</pre>
<p>-3- ...</p>
<p>-6- ...</p>
<pre><ins>void</ins> exit<ins> [[noreturn]] </ins>(int status)
</pre>
<p>-7- ...</p>
<p>-11- ...</p>
<pre>void quick_exit<ins> [[noreturn]] </ins>(int status)
</pre>
<p>-12- ...</p>
</blockquote>

<p>
Change the <tt>&lt;exception&gt;</tt> synopsis in 18.8 [support.exception]:
</p>

<blockquote><pre>void unexpected<ins> [[noreturn]] </ins>();
...
void terminate<ins> [[noreturn]] </ins>();
...
void rethrow_exception<ins> [[noreturn]] </ins>(exception_ptr p);
...
template &lt;class T&gt; void throw_with_nested<ins> [[noreturn]] </ins>(T&amp;&amp; t); <del>// [[noreturn]]</del>
</pre></blockquote>

<p>
Change 18.8.2.4 [unexpected]:
</p>

<blockquote><pre>void unexpected<ins> [[noreturn]] </ins>();
</pre></blockquote>

<p>
Change 18.8.3.3 [terminate]:
</p>

<blockquote><pre>void terminate<ins> [[noreturn]] </ins>();
</pre></blockquote>

<p>
Change 18.8.5 [propagation]:
</p>

<blockquote><pre>void rethrow_exception<ins> [[noreturn]] </ins>(exception_ptr p);
</pre></blockquote>

<p>
In the synopsis of 18.8.6 [except.nested] and the definition area change:
</p>

<blockquote><pre>template &lt;class T&gt; void throw_with_nested<ins> [[noreturn]] </ins>(T&amp;&amp; t); <del>// [[noreturn]]</del>
</pre></blockquote>





<hr>
<h3><a name="1067"></a>1067. simplified wording for inner_product</h3>
<p><b>Section:</b> 26.7 [numeric.ops] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-17  <b>Last modified:</b> 2009-05-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>

<p>
One of the motivating examples for introducing requirements-aliases was to
simplify the wording of the <tt>inner_product</tt> requirements.  As the paper
adopting the feature and constrained wording for the library went through in
the same meeting, it was not possible to make the change at the time.  The
simpler form should be adopted now though.  Similarly, most the other
numerical algorithms can benefit from a minor cleanup.
</p>
<p>
Note that in each case, the second more generalised form of the algorithm
does not benefit, as there are already named constraints supplied by the
template type parameters.
</p>

<p><i>[
2009-05-02 Daniel adds:
]</i></p>


<blockquote>
<p>
one part of the suggested resolution suggests the removal of the
<tt>MoveConstructible&lt;T&gt;</tt> requirement from
<tt>inner_product</tt>. According to 26.7.2 [inner.product]
</p>

<blockquote>
Computes its result by initializing the accumulator <tt>acc</tt> with the
initial value <tt>init</tt>
</blockquote>

<p>
this step requires at least <tt>MoveConstructible</tt>.
</p>

<p>
Therefore I strongly suggest to take this removal back (Note also
that the corresponding overload with a functor argument still has
the same <tt>MoveConstructible&lt;T&gt;</tt> requirement).
</p>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We agree with the proposed resolution as amended by Daniel's suggestion
to restore <tt>MoveConstructible</tt>,
reflected in the updated proposed resolution below.
</p>
<p>
Move to Tentatively Ready.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change in 26.7 [numeric.ops] and  [accumulate]:
</p>

<blockquote><pre>template &lt;InputIterator Iter, MoveConstructible T&gt;
 requires <ins>add =</ins> HasPlus&lt;T, Iter::reference&gt;
       &amp;&amp; HasAssign&lt;T, <del>HasPlus&lt;T, Iter::reference&gt;</del> <ins>add</ins>::result_type&gt;
 T accumulate(Iter first, Iter last, T init);
</pre></blockquote>

<p>
Change in 26.7 [numeric.ops] and 26.7.2 [inner.product]:
</p>

<blockquote><pre>template &lt;InputIterator Iter1, InputIterator Iter2, MoveConstructible T&gt;
  requires <ins>mult =</ins> HasMultiply&lt;Iter1::reference, Iter2::reference&gt;
        &amp;&amp; <ins>add =</ins> HasPlus&lt;T, <del>HasMultiply&lt;Iter1::reference, Iter2::reference&gt;</del> <ins>mult</ins>::result_type&gt;
        &amp;&amp; HasAssign&lt; 
             T,
             <del>HasPlus&lt;T,
                     HasMultiply&lt;Iter1::reference, Iter2::reference&gt;::result_type&gt;</del> <ins>add</ins>::result_type&gt;
  T inner_product(Iter1 first1, Iter1 last1, Iter2 first2, T init);
</pre></blockquote>

<p>
Change in 26.7 [numeric.ops] and 26.7.3 [partial.sum]:
</p>

<blockquote><pre>template &lt;InputIterator InIter, OutputIterator&lt;auto, const InIter::value_type&amp;&gt; OutIter&gt;
  requires <ins>add =</ins> HasPlus&lt;InIter::value_type, InIter::reference&gt;
        &amp;&amp; HasAssign&lt;InIter::value_type,
                     <del>HasPlus&lt;InIter::value_type, InIter::reference&gt;</del> <ins>add</ins>::result_type&gt;
        &amp;&amp; Constructible&lt;InIter::value_type, InIter::reference&gt;
  OutIter partial_sum(InIter first, InIter last, OutIter result);
</pre></blockquote>

<p>
Change in 26.7 [numeric.ops] and 26.7.4 [adjacent.difference]:
</p>

<blockquote><pre>template &lt;InputIterator InIter, OutputIterator&lt;auto, const InIter::value_type&amp;&gt; OutIter&gt;
  requires <ins>sub =</ins> HasMinus&lt;InIter::value_type, InIter::value_type&gt;
        &amp;&amp; Constructible&lt;InIter::value_type, InIter::reference&gt;
        &amp;&amp; OutputIterator&lt;OutIter, <del>HasMinus&lt;InIter::value_type, InIter::value_type&gt;</del> <ins>sub</ins>::result_type&gt;
        &amp;&amp; MoveAssignable&lt;InIter::value_type&gt;
  OutIter adjacent_difference(InIter first, InIter last, OutIter result);
</pre></blockquote>






<hr>
<h3><a name="1068"></a>1068. class random_device should be movable</h3>
<p><b>Section:</b> 26.5.6 [rand.device] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-18  <b>Last modified:</b> 2009-05-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.device">issues</a> in [rand.device].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
class <tt>random_device</tt> should be movable.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Move to Open, and recommend this issue be deferred until after the next
Committee Draft is issued.
</blockquote>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1069"></a>1069. class seed_seq should support efficient move operations</h3>
<p><b>Section:</b> 26.5.7.1 [rand.util.seedseq] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-18  <b>Last modified:</b> 2009-05-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.util.seedseq">issues</a> in [rand.util.seedseq].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
class <tt>seed_seq</tt> should support efficient move operations.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Move to Open, and recommend this issue be deferred until after the next
Committee Draft is issued.
</blockquote>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1070"></a>1070. Ambiguous move overloads in function</h3>
<p><b>Section:</b> 20.7.16.2 [func.wrap.func] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-03-19  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#func.wrap.func">active issues</a> in [func.wrap.func].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#func.wrap.func">issues</a> in [func.wrap.func].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The synopsis in 20.7.16.2 [func.wrap.func] says:
</p>

<blockquote><pre>template&lt;Returnable R, CopyConstructible... ArgTypes&gt; 
class function&lt;R(ArgTypes...)&gt;
{
    ...
    template&lt;class F&gt; 
      requires CopyConstructible&lt;F&gt; &amp;&amp; Callable&lt;F, ArgTypes...&gt; 
            &amp;&amp; Convertible&lt;Callable&lt;F, ArgTypes...&gt;::result_type, R&gt; 
      function(F); 
    template&lt;class F&gt; 
      requires CopyConstructible&lt;F&gt; &amp;&amp; Callable&lt;F, ArgTypes...&gt; 
            &amp;&amp; Convertible&lt;Callable&lt;F, ArgTypes...&gt;::result_type, R&gt; 
      function(F&amp;&amp;);
    ...
    template&lt;class F, Allocator Alloc&gt; function(allocator_arg_t, const Alloc&amp;, F); 
    template&lt;class F, Allocator Alloc&gt; function(allocator_arg_t, const Alloc&amp;, F&amp;&amp;);
    ...
    template&lt;class F&gt; 
      requires CopyConstructible&lt;F&gt; &amp;&amp; Callable&lt;F, ArgTypes..&gt; 
            &amp;&amp; Convertible&lt;Callable&lt;F, ArgTypes...&gt;::result_type 
      function&amp; operator=(F); 
    template&lt;class F&gt; 
      requires CopyConstructible&lt;F&gt; &amp;&amp; Callable&lt;F, ArgTypes...&gt; 
            &amp;&amp; Convertible&lt;Callable&lt;F, ArgTypes...&gt;::result_type, R&gt; 
      function&amp; operator=(F&amp;&amp;);
    ...
};
</pre></blockquote>

<p>
Each of the 3 pairs above are ambiguous.  We need only one of each pair, and we
could do it with either one.  If we choose the <tt>F&amp;&amp;</tt> version we
need to bring <tt>decay</tt> into the definition to get the pass-by-value behavior.
In the proposed wording I've gotten lazy and just used the pass-by-value signature.
</p>

<p><i>[
2009-05-01 Daniel adds:
]</i></p>


<blockquote>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1024">1024</a> modifies the second removed constructor.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We briefly discussed whether we ought support moveable function objects,
but decided that should be a separate issue if someone cares to propose it.
</p>
<p>
Move to Tentatively Ready.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change the synopsis of 20.7.16.2 [func.wrap.func], and remove the associated definitions in
20.7.16.2.1 [func.wrap.func.con]:
</p>

<blockquote><pre>template&lt;Returnable R, CopyConstructible... ArgTypes&gt; 
class function&lt;R(ArgTypes...)&gt;
{
    ...
    template&lt;class F&gt; 
      requires CopyConstructible&lt;F&gt; &amp;&amp; Callable&lt;F, ArgTypes...&gt; 
            &amp;&amp; Convertible&lt;Callable&lt;F, ArgTypes...&gt;::result_type, R&gt; 
      function(F); 
    <del>template&lt;class F&gt; 
      requires CopyConstructible&lt;F&gt; &amp;&amp; Callable&lt;F, ArgTypes...&gt; 
            &amp;&amp; Convertible&lt;Callable&lt;F, ArgTypes...&gt;::result_type, R&gt; 
      function(F&amp;&amp;);</del>
    ...
    template&lt;class F, Allocator Alloc&gt; function(allocator_arg_t, const Alloc&amp;, F); 
    <del>template&lt;class F, Allocator Alloc&gt; function(allocator_arg_t, const Alloc&amp;, F&amp;&amp;);</del>
    ...
    template&lt;class F&gt; 
      requires CopyConstructible&lt;F&gt; &amp;&amp; Callable&lt;F, ArgTypes..&gt; 
            &amp;&amp; Convertible&lt;Callable&lt;F, ArgTypes...&gt;::result_type 
      function&amp; operator=(F); 
    <del>template&lt;class F&gt; 
      requires CopyConstructible&lt;F&gt; &amp;&amp; Callable&lt;F, ArgTypes...&gt; 
            &amp;&amp; Convertible&lt;Callable&lt;F, ArgTypes...&gt;::result_type, R&gt; 
      function&amp; operator=(F&amp;&amp;);</del>
    ...
};
</pre></blockquote>






<hr>
<h3><a name="1071"></a>1071. is_bind_expression should derive from integral_constant&lt;bool&gt;</h3>
<p><b>Section:</b> 20.7.12.1.1 [func.bind.isbind] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-19  <b>Last modified:</b> 2009-05-31</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Class template is_bind_expression 20.7.12.1.1 [func.bind.isbind]:
</p>

<blockquote><pre>namespace std {
  template&lt;class T&gt; struct is_bind_expression {
    static const bool value = see below;
  };
}
</pre></blockquote>
<p>
<tt>is_bind_expression</tt> should derive from <tt>std::integral_constant&lt;bool&gt;</tt> like
other similar trait types.
</p>

<p><i>[
Daniel adds:
]</i></p>

<blockquote>
We need the same thing for the trait <tt>is_placeholder</tt> as well.
</blockquote>
<p><i>[
2009-03-22 Daniel provided wording.
]</i></p>


<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We recommend this be deferred until after the next Committee Draft is issued.
</p>
<p>
Move to Open.
</p>
</blockquote>

<p><i>[
2009-05-31 Peter adds:
]</i></p>


<blockquote>
<p>
I am opposed to the proposed resolution and to the premise of the issue
in general. The traits's default definitions should NOT derive from
<tt>integral_constant</tt>, because this is harmful, as it misleads people into
thinking that <tt>is_bind_expression&lt;E&gt;</tt> always derives from
<tt>integral_constant</tt>, whereas it may not.
</p>
<p>
<tt>is_bind_expression</tt> and <tt>is_placeholder</tt> allow user
specializations, and in fact, this is their primary purpose. Such user
specializations may not derive from <tt>integral_constant</tt>, and the
places where <tt>is_bind_expression</tt> and <tt>is_placeholder</tt> are
used intentionally do not require such derivation.
</p>
<p>
The long-term approach here is to switch to
<tt>BindExpression&lt;E&gt;</tt> and <tt>Placeholder&lt;P&gt;</tt>
explicit concepts, of course, but until that happens, I say leave them
alone.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>
In 20.7.12.1.1 [func.bind.isbind] change as indicated:
</p>
<blockquote><pre>namespace std {
 template&lt;class T&gt; struct is_bind_expression <ins>: integral_constant&lt;bool, <i>see below</i>&gt; { };</ins><del>{
   static const bool value = <i>see below</i>;
 };</del>
}
</pre></blockquote>
</li>
<li>
<p>
In 20.7.12.1.1 [func.bind.isbind]/2 change as indicated:
</p>
<blockquote><pre><del>static const bool value;</del>
</pre>
<blockquote>
-2- <del><tt>true</tt> if <tt>T</tt> is a type returned from <tt>bind</tt>, <tt>false</tt> otherwise.</del>
  <ins>If <tt>T</tt> is a type returned from <tt>bind</tt>, <tt>is_bind_expression&lt;T&gt;</tt> shall
be publicly derived from
        <tt>integral_constant&lt;bool, true&gt;</tt>, otherwise it shall be
publicly derived from
          <tt>integral_constant&lt;bool, false&gt;</tt>.</ins>
</blockquote>
</blockquote>
</li>
<li>
<p>
In 20.7.12.1.2 [func.bind.isplace] change as indicated:
</p>
<blockquote><pre>namespace std {
 template&lt;class T&gt; struct is_placeholder <ins>: integral_constant&lt;int, <i>see below</i>&gt; { };</ins><del>{
   static const int value = <i>see below</i>;
 };</del>
}
</pre></blockquote>
</li>
<li>
<p>
In 20.7.12.1.2 [func.bind.isplace]/2 change as indicated:
</p>
<blockquote><pre><del>static const int value;</del>
</pre>
<blockquote>
-2- <del>value is <tt>J</tt> if <tt>T</tt> is the type of <tt>std::placeholders::_J</tt>, 0 otherwise.</del>
  <ins>If <tt>T</tt> is the type of <tt>std::placeholders::_J</tt>, <tt>is_placeholder&lt;T&gt;</tt>
shall be publicly
          derived from <tt>integral_constant&lt;int, J&gt;</tt> otherwise it shall
be publicly derived
          from <tt>integral_constant&lt;int, 0&gt;</tt>.</ins>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="1072"></a>1072. Is std::hash a constrained template or not?</h3>
<p><b>Section:</b> 20.7.17 [unord.hash] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-19  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#unord.hash">active issues</a> in [unord.hash].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#unord.hash">issues</a> in [unord.hash].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Is <tt>std::hash</tt> a constrained template or not?
</p>
<p>
According to Class template hash 20.7.17 [unord.hash], the definition is:
</p>

<blockquote><pre>template &lt;class T&gt;
struct hash : public std::unary_function&lt;T, std::size_t&gt; {
  std::size_t operator()(T val) const;
};
</pre></blockquote>

<p>
And so unconstrained.
</p>
<p>
According to the <tt>&lt;functional&gt;</tt> synopsis in p2 Function objects
20.7 [function.objects] the template is declared as:
</p>

<blockquote><pre>template &lt;ReferentType T&gt; struct hash;
</pre></blockquote>

<p>
which would make hash a constrained template.
</p>

<p><i>[
2009-03-22 Daniel provided wording.
]</i></p>


<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Alisdair is not certain that Daniel's proposed resolution is sufficient,
and recommends we leave the hash template unconstrained for now.
</p>
<p>
Recommend that the Project Editor make the constrained declaration consistent
with the definition in order to make the Working Paper internally consistent,
and that the issue then be revisited.
</p>
<p>
Move to Open.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>

<p>
[To the editor: This resolution is merge-compatible to the
resolution of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1078">1078</a>]
</p>

<ol>
<li>
<p>
In 20.7 [function.objects]/2, header <tt>&lt;functional&gt;</tt> synopsis, change as indicated:
</p>

<blockquote><pre>// 20.6.17, hash function base template:
template &lt;ReferentType T&gt; struct hash; <ins>// undefined</ins>
</pre></blockquote>
</li>
<li>
<p>
In 20.7.17 [unord.hash]/1 change as indicated:
</p>
<blockquote><pre>namespace std {
 <del>template &lt;class T&gt;
 struct hash : public std::unary_function&lt;T, std::size_t&gt; {
 std::size_t operator()(T val) const;
 };</del>
 <ins>template &lt;ReferentType T&gt; struct hash; // undefined</ins>
}
</pre></blockquote>
</li>
<li>
<p>
In 20.7.17 [unord.hash]/2 change as indicated:
</p>

<blockquote>
-2-  <ins>For all library-provided specializations, the template
instantiation <tt>hash&lt;T&gt;</tt>
  shall provide a public <tt>operator()</tt> with return type <tt>std::size_t</tt> to
satisfy the concept
  requirement <tt>Callable&lt;const hash&lt;T&gt;, const T&amp;&gt;</tt>. If <tt>T</tt> is an object
type or reference to
  object, <tt>hash&lt;T&gt;</tt> shall be publicly derived from
<tt>std::unary_function&lt;T, std::size_t&gt;</tt>.
  </ins> The return value of <tt>operator()</tt> is unspecified, except that
equal arguments
  shall yield the same result. <tt>operator()</tt> shall not throw exceptions.
</blockquote>
</li>
<li>
<p>
In 18.7 [support.rtti]/1, header <tt>&lt;typeinfo&gt;</tt> synopsis change as indicated:
</p>
<blockquote><pre>namespace std {
  class type_info;
  class type_index;
  template &lt;<del>class</del><ins>ReferentType</ins> T&gt; struct hash;
</pre></blockquote>
</li>
</ol>





<hr>
<h3><a name="1073"></a>1073. Declaration of <tt>allocator_arg</tt> should be <tt>constexpr</tt></h3>
<p><b>Section:</b> 20.8 [memory] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-19  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#memory">active issues</a> in [memory].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#memory">issues</a> in [memory].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Declaration of <tt>allocator_arg</tt> should be <tt>constexpr</tt> to ensure constant
initialization.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution.  Move to Tentatively Ready.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 20.8 [memory] p2:
</p>

<blockquote><pre>// 20.8.1, allocator argument tag
struct allocator_arg_t { };
const<ins>expr</ins> allocator_arg_t allocator_arg = allocator_arg_t();
</pre></blockquote>






<hr>
<h3><a name="1074"></a>1074. concept map broken by N2840</h3>
<p><b>Section:</b> 20.8.3 [allocator.element.concepts] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-19  <b>Last modified:</b> 2009-05-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p>
p7 Allocator-related element concepts 20.8.3 [allocator.element.concepts]
</p>

<p>
The changes to the <tt>AllocatableElement</tt> concept mean this <tt>concept_map</tt>
specialization no longer matches the original concept:
</p>

<blockquote><pre>template &lt;Allocator Alloc, class T, class ... Args&gt;
  requires HasConstructor&lt;T, Args...&gt;
    concept_map AllocatableElement&lt;Alloc, T, Args&amp;&amp;...&gt; {
      void construct_element(Alloc&amp; a, T* t, Args&amp;&amp;... args) {
        Alloc::rebind&lt;T&gt;(a).construct(t, forward(args)...);
      }
    }
</pre></blockquote>

<p><i>[
2009-03-23 Pablo adds:
]</i></p>


<blockquote>
Actually, this is incorrect,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2840.pdf">N2840</a>
says. "In section 
20.8.3 [allocator.element.concepts] paragraph 8, modify the definition of the
<tt>AllocatableElement</tt> concept and eliminate the related concept map:" but
then neglects to include the red-lined text of the concept map that was
to be eliminated. Pete also missed this, but I caught it he asked me to
review his edits.  Pete's updated WP removes the concept map entirely,
which was the original intent.  The issue is, therefore, moot.  Note, as
per my presentation of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2840.pdf">N2840</a>
in summit, <tt>construct()</tt> no longer has a
default implementation.  This regrettable fact was deemed (by David
Abrahams, Doug, and myself) to be preferable to the complexity of
providing a default implementation that would not under-constrain a more
restrictive allocator (like the scoped allocators).
</blockquote>

<p><i>[
2009-05-01 Daniel adds:
]</i></p>

<blockquote>
<p>
it seems to me that #1074 should be resolved as a NAD, because the
current WP has already removed the previous AllocatableElement concept map.
It introduced auto concept AllocatableElement instead, but as of
20.8.3 [allocator.element.concepts]/7 this guy contains now
</p>
<blockquote><pre>requires FreeStoreAllocatable&lt;T&gt;;
void Alloc::construct(T*, Args&amp;&amp;...);
</pre></blockquote>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
The affected code is no longer part of the Working Draft.
</p>
<p>
Move to NAD.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 20.8.3 [allocator.element.concepts]:
</p>

<blockquote><pre>template &lt;Allocator Alloc, class T, class ... Args&gt;
  requires HasConstructor&lt;T, Args...&gt;
    concept_map AllocatableElement&lt;Alloc, T, Args&amp;&amp;...&gt; {
      void construct_element(<del>Alloc&amp; a,</del> T* t, Args&amp;&amp;... args) {
        Alloc::rebind&lt;T&gt;(a).construct(t, forward(args)...);
      }
    }
</pre></blockquote>






<hr>
<h3><a name="1075"></a>1075. Response to US 65, US 74.1</h3>
<p><b>Section:</b> 20 [utilities], 23 [containers] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alan Talbot <b>Opened:</b> 2009-03-20  <b>Last modified:</b> 2009-06-10</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#utilities">issues</a> in [utilities].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US 65 and US 74.1</b></p>

<p>US 65:</p>

<blockquote>
Scoped allocators and allocator propagation traits add a small amount of
utility at the cost of a great deal of machinery. The machinery is user
visible, and it extends to library components that don't have any
obvious connection to allocators, including basic concepts and simple
components like <tt>pair</tt> and <tt>tuple</tt>.

<p>Suggested resolution:</p>

<p>
Sketch of proposed resolution: Eliminate scoped allocators, replace
allocator propagation traits with a simple uniform rule (e.g. always
propagate on copy and move), remove all mention of allocators from
components that don't explicitly allocate memory (e.g. pair), and adjust
container interfaces to reflect this simplification.
</p>
<p>
Components that I propose eliminating include HasAllocatorType,
is_scoped_allocator, allocator_propagation_map, scoped_allocator_adaptor,
and ConstructibleAsElement.
</p>
</blockquote>

<p>US 74.1:</p>

<blockquote>
<p>
Scoped allocators represent a poor trade-off for standardization, since
(1) scoped-allocator--aware containers can be implemented outside the
C++ standard library but used with its algorithms, (2) scoped
allocators only benefit a tiny proportion of the C++ community
(since few C++ programmers even use today's allocators), and (3) all C++
users, especially the vast majority of the C++ community that won't ever
use scoped allocators are forced to cope with the interface complexity
introduced by scoped allocators.
</p>
<p>
In essence, the larger community will suffer to support a very small
subset of the community who can already implement their own
data structures outside of the standard library. Therefore, scoped
allocators should be removed from the working paper.
</p>
<p>
Some evidence of the complexity introduced by scoped allocators:
</p>
<blockquote>
<p>
20.3.3 [pairs], 20.5 [tuple]: Large increase in the
number of pair and tuple constructors.
</p>
<p>
23 [containers]: Confusing "AllocatableElement" requirements throughout.
</p>
</blockquote>
<p>Suggested resolution:</p>

<p>
Remove support for scoped allocators from the working paper. This
includes at least the following changes:
</p>

<blockquote>
<p>
Remove 20.8.3 [allocator.element.concepts]
</p>
<p>
Remove 20.8.7 [allocator.adaptor]
</p>
<p>
Remove 20.8.10 [construct.element]
</p>
<p>
In Clause 23 [containers]: replace requirements naming the
<tt>AllocatableElement</tt> concept with requirements naming <tt>CopyConstructible</tt>,
<tt>MoveConstructible</tt>, <tt>DefaultConstructible</tt>, or <tt>Constructible</tt>, as
appropriate.
</p>
</blockquote>

</blockquote>

<p><i>[
Post Summit Alan moved from NAD to Open.
]</i></p>


<p><i>[
2009-05-15 Ganesh adds:
]</i></p>


<blockquote>
<p>
The requirement <tt>AllocatableElement</tt> should not be replaced with
<tt>Constructible</tt> on the <tt>emplace_xxx()</tt> functions as suggested. In the
one-parameter case the <tt>Constructible</tt> requirement is not satisfied when
the constructor is explicit (as per 14.10.2.1 [concept.map.fct], twelfth
bullet) but we do want to allow explicit constructors in emplace, as the
following example shows:
</p>

<blockquote><pre>vector&lt;shared_ptr&lt;int&gt;&gt; v;
v.emplace_back(new int); <font color="#c80000">// should be allowed</font>
</pre></blockquote>

<p>
If the issue is accepted and scoped allocators are removed, I suggest to
add a new pair of concepts to 20.2.7 [concept.construct], namely:
</p>

<blockquote><pre>auto concept HasExplicitConstructor&lt;typename T, typename... Args&gt; {
 explicit T::T(Args...);
}

auto concept ExplicitConstructible&lt;typename T, typename... Args&gt;
 : HasExplicitConstructor&lt;T, Args...&gt;, NothrowDestructible&lt;T&gt;
{ }
</pre></blockquote>

<p>
We should then use <tt>ExplicitConstructible</tt> as the requirement for all
<tt>emplace_xxx()</tt> member functions.
</p>
<p>
For coherence and consistency with the similar concepts
<tt>Convertible/ExplicitlyConvertible</tt>, we might also consider changing
<tt>Constructible</tt> to:
</p>

<blockquote><pre>auto concept Constructible&lt;typename T, typename... Args&gt;
 : HasConstructor&lt;T, Args...&gt;, ExplicitConstructible&lt;T, Args...&gt;
{ }
</pre></blockquote>

<p>
Moreover, all emplace-related concepts in 23.2.6 [container.concepts]
should also use <tt>ExplicitConstructible</tt> instead of <tt>Constructible</tt> in the
definitions of their axioms. In fact the concepts in 23.2.6 [container.concepts] should be
corrected even if the issue is not accepted.
</p>
<p>
On the other hand, if the issue is not accepted, the scoped allocator
adaptors should be fixed because the following code:
</p>

<blockquote><pre>template &lt;typename T&gt; using scoped_allocator = scoped_allocator_adaptor&lt;allocator&lt;T&gt;&gt;;

vector&lt;shared_ptr&lt;int&gt;, scoped_allocator&lt;shared_ptr&lt;int&gt;&gt;&gt; v;
v.emplace_back(new int); <font color="#c80000">// ops! doesn't compile</font>
</pre></blockquote>

<p>
doesn't compile, as the member function <tt>construct()</tt> of the scoped
allocator requires non-explicit constructors through concept
<tt>ConstructibleWithAllocator</tt>. Fixing that is not difficult but probably
more work than it's worth and is therefore, IMHO, one more reason in
support of the complete removal of scoped allocators.
</p>
</blockquote>

<p><i>[
2009-06-09 Alan adds:
]</i></p>


<blockquote>
<p>
I reopened this issue because I did not think that these National Body
comments were adequately addressed by marking them NAD. My understanding
is that something can be marked NAD if it is clearly a misunderstanding
or trivial, but a substantive issue that has any technical merit
requires a disposition that addresses the concerns.
</p>
<p>
The notes in the NB comment list (US 65 &amp; US 74.1) say that:
</p>
<ol type="a">
<li>
this issue has not introduced any new arguments not previously discussed,
</li>
<li>
the vote (4-9-3) was not a consensus for removing scoped allocators,
</li>
<li>
the issue is resolved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2840.pdf">N2840</a>.
</li>
</ol>
<p>
My opinion is:
</p>
<ol type="a">
<li>
there are new arguments in both comments regarding concepts (which were
not present in the library when the scoped allocator proposal was voted
in),
</li>
<li>
the vote was clearly not a consensus for removal, but just saying there
was a vote does not provide a rationale,
</li>
<li>
I do not believe that N2840 addresses these comments (although it does
many other things and was voted in with strong approval).
</li>
</ol>

<p>
My motivation to open the issue was to ensure that the NB comments were
adequately addressed in a way that would not risk a "no" vote on our
FCD. If there are responses to the technical concerns raised, then
perhaps they should be recorded. If the members of the NB who authored
the comments are satisfied with N2840 and the other disposition remarks
in the comment list, then I am sure they will say so. In either case,
this issue can be closed very quickly in Frankfurt, and hopefully will
have helped make us more confident of approval with little effort. If in
fact there is controversy, my thought is that it is better to know now
rather than later so there is more time to deal with it.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1076"></a>1076. unary/binary_negate need constraining and move support</h3>
<p><b>Section:</b> 20.7.11 [negators] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-20  <b>Last modified:</b> 2009-05-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The class templates <tt>unary/binary_negate</tt> need constraining and move support.
</p>
<p>
Ideally these classes would be deprecated, allowing <tt>unary/binary_function</tt> to
also be deprecated.  However, until a generic negate adaptor is introduced
that can negate any <tt>Callable</tt> type, they must be supported so should be
constrained.  Likewise, they should be movable, and support adopting a
move-only predicate type.
</p>
<p>
In order to preserve ABI compatibility, new rvalue overloads are supplied in
preference to changing the existing pass-by-const-ref to pass-by-value.
</p>
<p>
Do not consider the issue of forwarding mutable lvalues at this point,
although remain open to another issue on the topic.
</p>

<p><i>[
2009-05-01 Daniel adds:
]</i></p>

<blockquote>
<p>
IMO the currently proposed resolution needs some updates
because it is ill-formed at several places:
</p>

<ol>
<li>
<p>
In concept AdaptableUnaryFunction change
</p>
<blockquote><pre>typename X::result_type;
typename X::argument_type;
</pre></blockquote>
<p>
to
</p>
<blockquote><pre>Returnable result_type = typename X::result_type;
typename argument_type = typename X::argument_type;
</pre></blockquote>
<p>
[The replacement "Returnable result_type" instead of "typename
result_type" is non-editorial, but maybe you prefer that as well]
</p>
</li>
<li>
<p>
In concept AdaptableBinaryFunction change
</p>
<blockquote><pre>typename X::result_type;
typename X::first_argument_type;
typename X::second_argument_type;
</pre></blockquote>
<p>
to
</p>
<blockquote><pre>Returnable result_type = typename X::result_type;
typename first_argument_type = typename X::first_argument_type;
typename second_argument_type = typename X::second_argument_type;
</pre></blockquote>
<p>
[The replacement "Returnable result_type" instead of "typename
result_type" is non-editorial, but maybe you prefer that as well.]
</p>
</li>

<li>
<p>
In class unary/binary_function
</p>
<ol type="a">
<li>
I suggest to change "ReturnType" to "Returnable" in both cases.
</li>
<li>
I think you want to replace the remaining occurrences of "Predicate" by "P"
(in both classes in copy/move from a predicate)
</li>
</ol>
</li>
<li>
<p>
I think you need to change the proposed signatures of not1 and not2, because
they would still remain unconstrained: To make them constrained at least a
single requirement needs to be added to enable requirement implication. This
could be done via a dummy ("requires True&lt;true&gt;") or just explicit as follows:
</p>
<ol type="a">
<li>
<blockquote><pre>template &lt;AdaptableUnaryFunction P&gt;
requires Predicate&lt; P, P::argument_type&gt;
unary_negate&lt;P&gt; not1(const P&amp;&amp; pred);
template &lt;AdaptableUnaryFunction P&gt;
requires Predicate&lt; P, P::argument_type &gt;
unary_negate&lt;P&gt; not1(P&amp;&amp; pred);
</pre>
<blockquote>
-3- Returns: unary_negate&lt;P&gt;(pred).
</blockquote>
</blockquote>
<p>
[Don't we want a move call for the second overload as in
</p>
<blockquote><pre>unary_negate&lt;P&gt;(std::move(pred))
</pre></blockquote>
<p>
in the Returns clause ?]
</p>
</li>
<li>
<pre>template &lt;AdaptableBinaryFunction P&gt;
requires Predicate&lt; P, P::first_argument_type, P::second_argument_type &gt;
binary_negate&lt;P&gt; not2(const P&amp; pred);
template &lt;AdaptableBinaryFunction P&gt;
requires Predicate&lt; P, P::first_argument_type, P::second_argument_type &gt;
binary_negate&lt;P&gt; not2(P&amp;&amp; pred);
</pre>
<p>
-5- Returns: binary_negate&lt;P&gt;(pred).
</p>
<p>
[Don't we want a move call for the second overload as in
</p>
<blockquote><pre>binary_negate&lt;P&gt;(std::move(pred))
</pre></blockquote>
<p>
in the Returns clause ?]
</p>
</li>
</ol>
</li>
</ol>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
There is concern that complicating the solution
to preserve the ABI seems unnecessary,
since we're not in general preserving the ABI.
</p>
<p>
We would prefer a separate paper consolidating all Clause 20
issues that are for the purpose of providing constrained versions
of the existing facilities.
</p>
<p>
Move to Open.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Add new concepts where appropriate::
</p>

<blockquote><pre>auto concept AdaptableUnaryFunction&lt; typename X &gt; {
  typename X::result_type;
  typename X::argument_type;
}

auto concept AdaptableBinaryFunction&lt; typename X &gt; {
  typename X::result_type;
  typename X::first_argument_type;
  typename X::second_argument_type;
}
</pre></blockquote>

<p>
Revise as follows:
</p>

<p>
Base 20.7.3 [base] (Only change is constrained Result)
</p>

<blockquote>
<p>
-1-  The following classes are provided to simplify the typedefs of the
argument and result types:
</p>
<pre>namespace std {
  template &lt;class Arg, <del>class</del> <ins>ReturnType</ins> Result&gt;
  struct unary_function {
     typedef Arg    argument_type;
     typedef Result result_type;
  };

  template &lt;class Arg1, class Arg2, <del>class</del> <ins>ReturnType</ins> Result&gt;
  struct binary_function {
     typedef Arg1   first_argument_type;
     typedef Arg2   second_argument_type;
     typedef Result result_type;
  };
}
</pre></blockquote>

<p>
Negators 20.7.11 [negators]:
</p>

<blockquote>
<p>
-1- Negators <tt>not1</tt> and <tt>not2</tt> take a unary and a binary predicate,
respectively, and return their complements (5.3.1).
</p>

<pre>template &lt;<del>class</del> <ins>AdaptableUnaryFunction</ins> P<del>redicate</del>&gt;
  <ins>requires Predicate&lt; P, P::argument_type &gt;</ins>
  class unary_negate
    : public unary_function&lt;<del>typename</del> P<del>redicate</del>::argument_type,bool&gt; {
  public:
    <ins>unary_negate(const unary_negate &amp; ) = default;</ins>
    <ins>unary_negate(unary_negate &amp;&amp; );</ins>

    <ins>requires CopyConstructible&lt; P &gt;</ins>
       explicit unary_negate(const Predicate&amp; pred); 
    <ins>requires MoveConstructible&lt; P &gt;
       explicit unary_negate(Predicate &amp;&amp; pred);</ins>

    bool operator()(const <del>typename</del> P<del>redicate</del>::argument_type&amp; x) const;
  };
</pre>
<blockquote>
-2 <tt>operator()</tt> returns <tt>!pred(x)</tt>.
</blockquote>

<pre>template &lt;class Predicate&gt;
  unary_negate&lt;Predicate&gt; not1(const Predicate&amp;amp; pred);
<ins>template &lt;class Predicate&gt;
  unary_negate&lt;Predicate&gt; not1(Predicate&amp;&amp; pred);</ins>
</pre>
<blockquote>
-3-  <i>Returns:</i> <tt>unary_negate&lt;Predicate&gt;(pred)</tt>.
</blockquote>

<pre>template &lt;<del>class</del> <ins>AdaptableBinaryFunction</ins> P<del>redicate</del> &gt;
  <ins>requires Predicate&lt; P, P::first_argument_type, P::second_argument_type &gt;</ins>
  class binary_negate
    : public binary_function&lt;<del>typename</del> P<del>redicate</del>::first_argument_type,
                              <del>typename</del> P<del>redicate</del>::second_argument_type, bool&gt; {
  public:
    <ins>biary_negate(const binary_negate &amp; ) = default;</ins>
    <ins>binary_negate(binary_negate &amp;&amp; );</ins>

    <ins>requires CopyConstructible&lt; P &gt;</ins>
       explicit binary_negate(const Predicate&amp; pred);
    <ins>requires MoveConstructible&lt; P &gt;
       explicit binary_negate(const Predicate&amp; pred);</ins>

    bool operator()(const <del>typename</del> P<del>redicate</del>::first_argument_type&amp; x,
                    const <del>typename</del> P<del>redicate</del>::second_argument_type&amp; y) const;
  };
</pre>
<blockquote>
-4- <tt>operator()</tt> returns <tt>!pred(x,y)</tt>.
</blockquote>

<pre>template &lt;class Predicate&gt;
  binary_negate&lt;Predicate&gt; not2(const Predicate&amp; pred);
<ins>template &lt;class Predicate&gt;
  binary_negate&lt;Predicate&gt; not2(Predicate&amp;&amp; pred);</ins>
</pre>

<blockquote>
-5- <i>Returns:</i> <tt>binary_negate&lt;Predicate&gt;(pred)</tt>.
</blockquote>
</blockquote>






<hr>
<h3><a name="1077"></a>1077. Nonesense <tt>tuple</tt> declarations</h3>
<p><b>Section:</b> 20.5.2 [tuple.tuple] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">Tentatively NAD Editorial</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2009-03-20  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#tuple.tuple">active issues</a> in [tuple.tuple].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#tuple.tuple">issues</a> in [tuple.tuple].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20NAD%20Editorial">Tentatively NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Class template tuple 20.5.2 [tuple.tuple]:
</p>

<blockquote><pre>template &lt;class... UTypes&gt;
  requires Constructible&lt;Types, const UTypes&amp;&gt;...
template &lt;class... UTypes&gt;
  requires Constructible&lt;Types, RvalueOf&lt;UTypes&gt;::type&gt;...
</pre></blockquote>

<p>
Somebody needs to look at this and say what it should be.
</p>

<p><i>[
2009-03-21 Daniel provided wording.
]</i></p>


<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
The resolution looks correct; move to NAD Editorial.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
In 20.5.2 [tuple.tuple], class <tt>tuple</tt>, change as indicated:
</p>

<blockquote><pre>template &lt;class... UTypes&gt;
  requires Constructible&lt;Types, const UTypes&amp;&gt;...
  <ins>tuple(const pair&lt;UTypes...&gt;&amp;);</ins>
template &lt;class... UTypes&gt;
  requires Constructible&lt;Types, RvalueOf&lt;UTypes&gt;::type&gt;...
  <ins>tuple(pair&lt;UTypes...&gt;&amp;&amp;);</ins>
</pre></blockquote>

<p>
[NB.: The corresponding prototypes do already exist in 20.5.2.1 [tuple.cnstr]/7+8]
</p>





<hr>
<h3><a name="1078"></a>1078. DE-17: Remove class type_index</h3>
<p><b>Section:</b> 18.7.2 [type.index] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Doug Gregor <b>Opened:</b> 2009-03-20  <b>Last modified:</b> 2009-03-31</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses DE 17</b></p>

<p>
DE-17: 
</p>
<p>
The class <tt>type_index</tt> should be removed; it provides no additional
functionality beyond providing appropriate concept maps.
</p>

<p><i>[
2009-03-31 Peter adds:
]</i></p>


<blockquote>
<p>
It is not true, in principle, that <tt>std::type_index</tt> provides no  utility
compared to bare <tt>std::type_info*</tt>.
</p>
<p>
<tt>std::type_index</tt> can avoid the lifetime issues with <tt>type_info</tt> when  the
DLL that has produced the <tt>type_info</tt> object is unloaded. A raw
<tt>type_info*</tt> does not, and cannot, provide any protection in this  case.
A <tt>type_index</tt> can (if the implementor so chooses) because it  can wrap a
smart (counted or even cloning) pointer to the <tt>type_info</tt>  data that is
needed for <tt>name()</tt> and <tt>before()</tt> to work.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>Modify the header &lt;typeinfo&gt; synopsis in 
  18.7 [support.rtti]p1 as follows:</p>

<blockquote><pre>namespace std { 
  class type_info; 
  <del>class type_index;</del>
  template &lt;class T&gt; struct hash;
  template&lt;&gt; struct hash&lt;<del>type_index</del><ins>const type_info *</ins>&gt; : public std::unary_function&lt;<del>type_index</del><ins>const type_info *</ins>, size_t&gt; {
    size_t operator()(<del>type_index</del><ins>const type_info *</ins> <del>index</del><ins>t</ins>) const;
  }<ins>;</ins>
  <ins>concept_map LessThanComparable&lt;const type_info *&gt; <i>see below</i></ins>
  class bad_cast; 
  class bad_typeid;
}
</pre></blockquote>

<p>Add the following new subsection</p>
<blockquote>
<p>
<ins>18.7.1.1 Template specialization <code>hash&lt;const type_info *&gt;</code>
[type.info.hash]</ins></p>

<pre><ins>size_t operator()(const type_info *x) const;</ins>
</pre>
<ol>
<li><ins><i>Returns</i>: <code>x-&gt;hash_code()</code></ins></li>
</ol>
</blockquote>

 <p>Add the following new subsection</p>
 <blockquote>
<p><ins>18.7.1.2 <code>type_info</code> concept map [type.info.concepts]</ins></p>


<pre><ins>concept_map LessThanComparable&lt;const type_info *&gt; {</ins>
  <ins>bool operator&lt;(const type_info *x, const type_info *y) { return x-&gt;before(*y); }</ins>
  <ins>bool operator&lt;=(const type_info *x, const type_info *y) { return !y-&gt;before(*x); }</ins>
  <ins>bool operator&gt;(const type_info *x, const type_info *y) { return y-&gt;before(*x); }</ins>
  <ins>bool operator&gt;=(const type_info *x, const type_info *y) { return !x-&gt;before(*y); }</ins>
<ins>}</ins>
</pre>
<ol>
  <li><ins><i>Note</i>: provides a well-defined ordering among
  <code>type_info const</code> pointers, which makes such pointers
  usable in associative containers (23.4).</ins></li>
</ol>
</blockquote>

<p>Remove section 18.7.2 [type.index]</p>





<hr>
<h3><a name="1079"></a>1079. UK-265: <code>RandomAccessIterator</code>'s <code>operator-</code> has nonsensical effects clause</h3>
<p><b>Section:</b> 24.2.6 [random.access.iterators] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Doug Gregor <b>Opened:</b> 2009-03-20  <b>Last modified:</b> 2009-03-22</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#random.access.iterators">active issues</a> in [random.access.iterators].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#random.access.iterators">issues</a> in [random.access.iterators].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses UK 265</b></p>

<p>UK-265:</p>
<p>
This effects clause is nonesense. It looks more like an axiom stating
equivalence, and certainly an effects clause cannot change the state of
two arguments passed by const reference
</p>



<p><b>Proposed resolution:</b></p>

<p>Modify 24.2.6 [random.access.iterators]p7-9 as follows:</p>

<blockquote><pre>difference_type operator-(const X&amp; a, const X&amp; b);
</pre>
<ol start="7">
  <li><i>Precondition</i>: there exists a value <code>n</code> of
  <code>difference_type</code> such that <code>a == b + n</code>.</li>
  <li><del><i>Effects</i>: <code>b == a + (b - a)</code></del></li>
  <li><i>Returns</i>: <del><code>(a &lt; b) ? distance(a,b) :
  -distance(b,a)</code></del><ins><code>n</code></ins></li>
</ol>
</blockquote>





<hr>
<h3><a name="1080"></a>1080. Concept ArithmeticLike should provide explicit boolean  conversion</h3>
<p><b>Section:</b> 20.2.13 [concept.arithmetic] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Review">Review</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2009-03-21  <b>Last modified:</b> 2009-05-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Review">Review</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Astonishingly, the current concept ArithmeticLike as specified in
20.2.13 [concept.arithmetic] does not provide explicit conversion
to <tt>bool</tt> although this is a common property of arithmetic types
(4.12 [conv.bool]). Recent proposals that introduced such types
(integers of arbitrary precision,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2143.pdf">n2143</a>,
decimals
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2732.pdf">n2732</a>
indirectly
via conversion to <tt>long long</tt>) also took care of such a feature.
</p>
<p>
Adding such an explicit conversion associated function would also
partly solve a currently invalid effects clause in library, which bases
on this property, 24.2.6 [random.access.iterators]/2:
</p>
<blockquote><pre>{ difference_type m = n;
 if (m &gt;= 0) while (m--) ++r;
 else while (m++) --r;
 return r; }
</pre></blockquote>

<p>
Both while-loops take advantage of a contextual conversion to <tt>bool</tt>
(Another problem is that the &gt;= comparison uses the no
longer supported existing implicit conversion from <tt>int</tt> to <tt>IntegralLike</tt>).
</p>

<b>Original proposed resolution:</b>
<ol>
<li>
<p>
In 20.2.13 [concept.arithmetic], add to the list of less refined
concepts one further concept:
</p>

<blockquote><pre>concept ArithmeticLike&lt;typename T&gt;
  : Regular&lt;T&gt;, LessThanComparable&lt;T&gt;, HasUnaryPlus&lt;T&gt;, HasNegate&lt;T&gt;,
    HasPlus&lt;T, T&gt;, HasMinus&lt;T, T&gt;, HasMultiply&lt;T, T&gt;, HasDivide&lt;T, T&gt;,
    HasPreincrement&lt;T&gt;, HasPostincrement&lt;T&gt;, HasPredecrement&lt;T&gt;,
    HasPostdecrement&lt;T&gt;,
    HasPlusAssign&lt;T, const T&amp;&gt;, HasMinusAssign&lt;T, const T&amp;&gt;,
    HasMultiplyAssign&lt;T, const T&amp;&gt;,
    HasDivideAssign&lt;T, const T&amp;&gt;<ins>, ExplicitlyConvertible&lt;T, bool&gt;</ins> {
</pre></blockquote>
</li>
<li>
<p>
In 24.2.6 [random.access.iterators]/2 change the current effects clause
as indicated [The proposed insertion fixes the problem that the previous
implicit construction from integrals has been changed to an explicit
constructor]:
</p>
<blockquote><pre>{ difference_type m = n;
 if (m &gt;= <ins>difference_type(</ins>0<ins>)</ins>) while (m--) ++r;
 else while (m++) --r;
 return r; }
</pre></blockquote>
</li>
</ol>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We agree that arithmetic types ought be convertible to <tt>bool</tt>,
and we therefore agree with the proposed resolution's paragraph 1.
</p>
<p>
We do not agree that the cited effects clause is invalid,
as it expresses intent rather than specific code.
</p>
<p>
Move to Review, pending input from concepts experts.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
In 20.2.13 [concept.arithmetic], add to the list of less refined
concepts one further concept:
</p>

<blockquote><pre>concept ArithmeticLike&lt;typename T&gt;
  : Regular&lt;T&gt;, LessThanComparable&lt;T&gt;, HasUnaryPlus&lt;T&gt;, HasNegate&lt;T&gt;,
    HasPlus&lt;T, T&gt;, HasMinus&lt;T, T&gt;, HasMultiply&lt;T, T&gt;, HasDivide&lt;T, T&gt;,
    HasPreincrement&lt;T&gt;, HasPostincrement&lt;T&gt;, HasPredecrement&lt;T&gt;,
    HasPostdecrement&lt;T&gt;,
    HasPlusAssign&lt;T, const T&amp;&gt;, HasMinusAssign&lt;T, const T&amp;&gt;,
    HasMultiplyAssign&lt;T, const T&amp;&gt;,
    HasDivideAssign&lt;T, const T&amp;&gt;<ins>, ExplicitlyConvertible&lt;T, bool&gt;</ins> {
</pre></blockquote>





<hr>
<h3><a name="1081"></a>1081. Response to UK 216</h3>
<p><b>Section:</b> 21 [strings] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-03-22  <b>Last modified:</b> 2009-03-22</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#strings">issues</a> in [strings].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses UK 216, JP 46, JP 48</b></p>

<p>
All the containers use concepts for their iterator usage, exect for
<tt>basic_string</tt>. This needs fixing.
</p>

<p>
Use concepts for iterator template parameters throughout the chapter.
</p>

<p><i>[
Summit:
]</i></p>

<blockquote>
NB comments to be handled by Dave Abrahams and Howard Hinnant with
advice from PJP: UK216 (which duplicates) JP46, JP48. JP46 supplies
extensive proposed wording; start there.
</blockquote>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1082"></a>1082. Response to JP 49</h3>
<p><b>Section:</b> 22 [localization] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-03-22  <b>Last modified:</b> 2009-03-22</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#localization">active issues</a> in [localization].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#localization">issues</a> in [localization].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses JP 49</b></p>

<p>
<tt>codecvt</tt> does not use concept. For example, create <tt>CodeConvert</tt>
concept and change as follows.
</p>

<blockquote><pre>template&lt;CodeConvert Codecvt, class Elem = wchar_t&gt;
  class wstring_convert {
</pre></blockquote>

<p><i>[
Summit:
]</i></p>

<blockquote>
To be handled by Howard Hinnant, Dave Abrahams, Martin Sebor, PJ Plauger.
</blockquote>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1083"></a>1083. Response to JP 52, 53</h3>
<p><b>Section:</b> 22 [localization] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-03-22  <b>Last modified:</b> 2009-03-22</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#localization">active issues</a> in [localization].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#localization">issues</a> in [localization].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses JP 52, JP 53</b></p>

<p>
<tt>InputIterator</tt> does not use concept.
</p>

<p>
<tt>OutputIterator</tt> does not use concept.
</p>

<p>
Comments include proposed wording.
</p>

<p><i>[
Summit:
]</i></p>

<blockquote>
To be handled by Howard Hinnant, Dave Abrahams, Martin Sebor, PJ Plauger.
</blockquote>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1084"></a>1084. Response to UK 250</h3>
<p><b>Section:</b> 24.2.4 [forward.iterators] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-03-22  <b>Last modified:</b> 2009-06-09</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#forward.iterators">issues</a> in [forward.iterators].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses UK 250</b></p>

<p>
A default implementation should be supplied for the post-increment
operator to simplify implementation of iterators by users.
</p>

<p>
Copy the Effects clause into the concept description as the default
implementation. Assumes a default value for postincrement_result
</p>

<p><i>[
Summit:
]</i></p>

<blockquote>
Howard will open an issue.
</blockquote>

<p><i>[
2009-06-07 Daniel adds:
]</i></p>


<blockquote>
This issue cannot currently be resolved as suggested, because
that would render auto-detection of the return type
<tt>postincrement_result</tt> invalid, see 14.10.2.2 [concept.map.assoc]/4+5. The
best fix would be to add a default type to that associated type, but
unfortunately any default type will prevent auto-deduction of types of
associated functions as quoted above. A corresponding core issue
is in preparation.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p><i>[
This wording assumes the acceptance of UK 251 / <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1009">1009</a>.  Both
wordings change the same paragraphs.
]</i></p>


<p>
Change 24.2.4 [forward.iterators]:
</p>

<blockquote>
<pre>concept ForwardIterator&lt;typename X&gt; : InputIterator&lt;X&gt;, Regular&lt;X&gt; { 

  MoveConstructible postincrement_result;
  requires HasDereference&lt;postincrement_result&gt;
        &amp;&amp; Convertible&lt;HasDereference&lt;postincrement_result&gt;::result_type, const value_type&amp;&gt;;

  postincrement_result operator++(X&amp; r, int)<del>;</del> <ins>{
     X tmp = r;
     ++r;
     return tmp;
  }</ins>

  axiom MultiPass(X a, X b) { 
    if (a == b) *a == *b; 
    if (a == b) ++a == ++b; 
  } 
}
</pre></blockquote>






<hr>
<h3><a name="1085"></a>1085. Response to UK 258</h3>
<p><b>Section:</b> 24.2.5 [bidirectional.iterators] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-03-22  <b>Last modified:</b> 2009-06-09</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#bidirectional.iterators">issues</a> in [bidirectional.iterators].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses UK 258</b></p>

<p>
A default implementation should be supplied for the post-decrement
operator to simplify implementation of iterators by users.
</p>

<p>
Copy the Effects clause into the concept description as the default
implementation. Assumes a default value for postincrement_result
</p>

<p><i>[
Summit:
]</i></p>

<blockquote>
Howard will open an issue.
</blockquote>

<p><i>[
2009-06-07 Daniel adds:
]</i></p>


<blockquote>
This issue cannot currently be resolved as suggested, because
that would render auto-detection of the return type
<tt>postdecrement_result</tt> invalid, see <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1084">1084</a>.
</blockquote>


<p><b>Proposed resolution:</b></p>

<p>
Change 24.2.5 [bidirectional.iterators]:
</p>

<blockquote>
<pre>concept BidirectionalIterator&lt;typename X&gt; : ForwardIterator&lt;X&gt; { 
  MoveConstructible postdecrement_result; 
  requires HasDereference&lt;postdecrement_result&gt; 
        &amp;&amp; Convertible&lt;HasDereference&lt;postdecrement_result&gt;::result_type, const value_type&amp;&gt; 
        &amp;&amp; Convertible&lt;postdecrement_result, const X&amp;&gt;; 
  X&amp; operator--(X&amp;); 
  postdecrement_result operator--(X&amp; <ins>r</ins>, int)<del>;</del> <ins>{
     X tmp = r;
     --r;
     return tmp;
  }</ins>
}
</pre></blockquote>






<hr>
<h3><a name="1086"></a>1086. Response to UK 284</h3>
<p><b>Section:</b> 24.6 [stream.iterators] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-03-22  <b>Last modified:</b> 2009-03-22</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses UK 284</b></p>

<p>
The stream iterators need constraining with concepts/requrires clauses.
</p>

<p><i>[
Summit:
]</i></p>

<blockquote>
We agree. To be handled by Howard, Martin and PJ.
</blockquote>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1087"></a>1087. Response to UK 301</h3>
<p><b>Section:</b> 25.4.5 [alg.replace] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Review">Review</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-03-22  <b>Last modified:</b> 2009-06-11</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#alg.replace">active issues</a> in [alg.replace].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.replace">issues</a> in [alg.replace].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Review">Review</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses UK 301</b></p>

<p>
<tt>replace</tt> and <tt>replace_if</tt> have the requirement: <tt>OutputIterator&lt;Iter,
Iter::reference&gt;</tt> Which implies they need to copy some values in the
range the algorithm is iterating over. This is not however the case, the
only thing that happens is <tt>const T&amp;</tt>s might be copied over existing
elements (hence the <tt>OutputIterator&lt;Iter, const T&amp;&gt;</tt>.
</p>

<p>
Remove <tt>OutputIterator&lt;Iter, Iter::reference&gt;</tt> from <tt>replace</tt>
and <tt>replace_if</tt>.
</p>

<p><i>[
Summit:
]</i></p>

<blockquote>
We agree. To be handled by Howard.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change in 25.2 [algorithms.syn] and 25.4.5 [alg.replace]:
</p>

<blockquote><pre>template&lt;ForwardIterator Iter, class T&gt; 
  requires <del>OutputIterator&lt;Iter, Iter::reference&gt; 
        &amp;&amp;</del> OutputIterator&lt;Iter, const T&amp;&gt; 
        &amp;&amp; HasEqualTo&lt;Iter::value_type, T&gt; 
  void replace(Iter first, Iter last, 
               const T&amp; old_value, const T&amp; new_value); 

template&lt;ForwardIterator Iter, Predicate&lt;auto, Iter::value_type&gt; Pred, class T&gt; 
  requires <del>OutputIterator&lt;Iter, Iter::reference&gt; 
        &amp;&amp;</del> OutputIterator&lt;Iter, const T&amp;&gt; 
        &amp;&amp; CopyConstructible&lt;Pred&gt; 
  void replace_if(Iter first, Iter last,
                  Pred pred, const T&amp; new_value);
</pre></blockquote>





<hr>
<h3><a name="1088"></a>1088. Response to UK 342</h3>
<p><b>Section:</b> 30.6.6 [futures.promise] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-03-22  <b>Last modified:</b> 2009-03-22</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#futures.promise">active issues</a> in [futures.promise].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#futures.promise">issues</a> in [futures.promise].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses UK 342</b></p>

<p>
<tt>std::promise</tt> is missing a non-member overload of <tt>swap</tt>. This is
inconsistent with other types that provide a <tt>swap</tt> member function.
</p>

<p>
Add a non-member overload <tt>void swap(promise&amp;&amp; x,promise&amp;&amp; y){ x.swap(y); }</tt>
</p>

<p><i>[
Summit:
]</i></p>

<blockquote>
Create an issue. Move to review, attention: Howard. Detlef will also
look into it.
</blockquote>

<p><i>[
Post Summit Daniel provided wording.
]</i></p>



<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>
In 30.6.6 [futures.promise], before p.1, immediately after class template
promise add:
</p>
<blockquote><pre><ins>
template &lt;class R&gt;
void swap(promise&lt;R&gt;&amp; x, promise&lt;R&gt;&amp; y);
</ins>
</pre></blockquote>
</li>
<li>
<p>
Change 30.6.6 [futures.promise]/10 as indicated (to fix a circular definition):
</p>
<blockquote>
<p>
-10- <i>Effects:</i> <del>swap(*this, other)</del><ins>Swaps the associated state
of <tt>*this</tt> and <tt>other</tt></ins>
</p>
<p>
<ins><i>Throws:</i> Nothing.</ins>
</p>
</blockquote>
</li>
<li>
<p>
After the last paragraph in 30.6.6 [futures.promise] add the following
prototype description:
</p>
<blockquote><pre><ins>
template &lt;class R&gt;
void swap(promise&lt;R&gt;&amp; x, promise&lt;R&gt;&amp; y);
</ins></pre>
<blockquote>
<p>
<ins><i>Effects:</i> <tt>x.swap(y)</tt></ins>
</p>
<p>
<ins><i>Throws:</i> Nothing.</ins>
</p>
</blockquote>
</blockquote>
</li>

</ol>






<hr>
<h3><a name="1089"></a>1089. Response to JP 76</h3>
<p><b>Section:</b> 30 [thread] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-03-22  <b>Last modified:</b> 2009-03-22</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#thread">active issues</a> in [thread].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread">issues</a> in [thread].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses JP 76</b></p>

<p>
A description for "Throws: Nothing." are not unified.
</p>

<p>
At the part without throw, "Throws: Nothing." should be described.
</p>

<p>
Add "Throws: Nothing." to the following.
</p>

<ul>
<li>
30.3.1.6 [thread.thread.static] p1
</li>
<li>
30.4.3.1 [thread.lock.guard] p4
</li>
<li>
30.4.3.2.1 [thread.lock.unique.cons] p6
</li>
<li>
30.5.1 [thread.condition.condvar] p7 and p8
</li>
<li>
30.5.2 [thread.condition.condvarany] p6, p7, p19, p21 and p25
</li>
</ul>

<p><i>[
Summit:
]</i></p>

<blockquote>
Pass on to editor.
</blockquote>

<p><i>[
Post Summit:  Editor declares this non-editorial.
]</i></p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1090"></a>1090. Missing description of <tt>packaged_task</tt> member <tt>swap</tt>,  missing non-member <tt>swap</tt></h3>
<p><b>Section:</b> 30.6.8 [futures.task] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2009-03-22  <b>Last modified:</b> 2009-05-24</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Class template <tt>packaged_task</tt> in 30.6.8 [futures.task] shows a member <tt>swap</tt>
declaration, but misses to
document it's effects (No prototype provided). Further on this class
misses to provide a non-member
swap.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Alisdair notes that paragraph 2 of the proposed resolution has already been
applied in the current Working Draft.
</p>
<p>
We note a pending <tt>future</tt>-related paper by Detlef;
we would like to wait for this paper before proceeding.
</p>
<p>
Move to Open.
</p>
</blockquote>

<p><i>[
2009-05-24 Daniel removed part 2 of the proposed resolution.
]</i></p>



<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>
In 30.6.8 [futures.task], immediately after the definition of class
template packaged_task add:
</p>
<blockquote><pre><ins>
template&lt;class R, class... Argtypes&gt;
void swap(packaged_task&lt;R(ArgTypes...)&gt;&amp;, packaged_task&lt;R(ArgTypes...)&gt;&amp;);
</ins>
</pre></blockquote>
</li>
</ol>

<ol start="3">
<li>
<p>
In 30.6.8 [futures.task], immediately after <tt>operator=</tt> prototype
description (After p. 8) add:
</p>
<blockquote><pre><ins>void swap(packaged_task&amp; other);</ins>
</pre>
<blockquote>
<p><ins>
<i>Effects:</i> Swaps the associated state of <tt>*this</tt> and <tt>other</tt>.
</ins></p>
<p><ins>
<i>Throws:</i> Nothing.
</ins></p>
</blockquote>
</blockquote>
</li>
<li>
<p>
At the end of 30.6.8 [futures.task] (after p. 20), add add the following
prototype description:
</p>

<blockquote><pre><ins>
template&lt;class R, class... Argtypes&gt;
void swap(packaged_task&lt;R(ArgTypes...)&gt;&amp; x, packaged_task&lt;R(ArgTypes...)&gt;&amp; y);
</ins></pre>
<blockquote>
<p><ins>
<i>Effects:</i> <tt>x.swap(y)</tt>
</ins></p>
<p><ins>
<i>Throws:</i> Nothing.
</ins></p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="1091"></a>1091. Response to UK 246</h3>
<p><b>Section:</b> 23.4.2.2 [multimap.modifiers] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Review">Review</a>
 <b>Submitter:</b> Beman Dawes <b>Opened:</b> 2009-03-22  <b>Last modified:</b> 2009-05-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Review">Review</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 246</b></p>
<p>
The content of this sub-clause is purely trying to describe in words the
effect of the requires clauses on these operations, now that we have
Concepts. As such, the description is more confusing than the signature
itself. The semantic for these functions is adequately covered in the
requirements tables in 23.2.4 [associative.reqmts].
</p>

<p><i>[
Beman adds:
]</i></p>


<blockquote>
Pete is clearly right that
this one is technical rather than editorial.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We agree with the proposed resolution.
</p>
<p>
Move to Review.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Strike 23.4.2.2 [multimap.modifiers] entirely
(but do NOT strike these signatures from the class template definition!).
</p>





<hr>
<h3><a name="1092"></a>1092. Class template <tt>integral_constant</tt> should be a  constrained template</h3>
<p><b>Section:</b> 20.6.3 [meta.help] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2009-03-22  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#meta.help">active issues</a> in [meta.help].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#meta.help">issues</a> in [meta.help].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
A first step to change the type traits predicates to constrained templates is to
constrain their common base template <tt>integral_constant</tt>. This can be done,
without enforcing depending classes to be constrained as well, but not
vice versa
without brute force <tt>late_check</tt> usages. The following proposed resolution depends
on the resolution of LWG issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1019">1019</a>.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Move to Open, pending a paper that looks at constraints
for the entirety of the type traits
and their relationship to the foundation concepts.
We recommend this be deferred
until after the next Committee Draft is issued.
</blockquote>


<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>
In 20.6.2 [meta.type.synop], Header <tt>&lt;type_traits&gt;</tt>
synopsis change as indicated:
</p>
<blockquote><pre>namespace std {
// 20.5.3, helper class:
template &lt;<del>class</del><ins>IntegralConstantExpressionType</ins> T, T v&gt; struct integral_constant;
</pre></blockquote>
</li>
<li>
<p>
In 20.6.3 [meta.help] change as indicated:
</p>
<blockquote><pre>template &lt;<del>class</del><ins>IntegralConstantExpressionType</ins> T, T v&gt;
struct integral_constant {
  static constexpr T value = v;
  typedef T value_type;
  typedef integral_constant&lt;T,v&gt; type;
  constexpr operator value_type() { return value; }
};
</pre></blockquote>
</li>
</ol>





<hr>
<h3><a name="1093"></a>1093. Multiple definitions for random_shuffle algorithm</h3>
<p><b>Section:</b> 25.4.12 [alg.random.shuffle] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Review">Review</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-22  <b>Last modified:</b> 2009-06-09</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.random.shuffle">issues</a> in [alg.random.shuffle].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Review">Review</a> status.</p>
<p><b>Discussion:</b></p>

<p>
There are a couple of issues with the declaration of the <tt>random_shuffle</tt>
algorithm accepting a random number engine.
</p>

<ol type="i">
<li>
The Iterators must be shuffle iterators, yet this requirement is missing.
</li>
<li>
The <tt>RandomNumberEngine</tt> concept is now provided by the random number
library
(<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2836.pdf">n2836</a>)
and the placeholder should be removed.
</li>
</ol>

<p><i>[
2009-05-02 Daniel adds:
]</i></p>


<blockquote>
<p>
this issue completes adding necessary requirement to the
third new <tt>random_shuffle</tt> overload. The current suggestion is:
</p>

<blockquote><pre>template&lt;RandomAccessIterator Iter, UniformRandomNumberGenerator Rand&gt;
requires ShuffleIterator&lt;Iter&gt;
void random_shuffle(Iter first, Iter last, Rand&amp;&amp; g);
</pre></blockquote>

<p>
IMO this is still insufficient and I suggest to add the requirement
</p>
<blockquote><pre>Convertible&lt;Rand::result_type, Iter::difference_type&gt;
</pre></blockquote>
<p>
to the list (as the two other overloads already have).
</p>

<p>
Rationale:
</p>

<blockquote>
<p>
Its true that this third overload is somewhat different from the remaining
two. Nevertheless we know from <tt>UniformRandomNumberGenerator</tt>, that
it's <tt>result_type</tt> is an integral type and that it satisfies
<tt>UnsignedIntegralLike&lt;result_type&gt;</tt>.
</p>
<p>
To realize it's designated task, the algorithm has to invoke the
<tt>Callable</tt> aspect of <tt>g</tt> and needs to perform some algebra involving
it's <tt>min()/max()</tt> limits to compute another index value that
at this point is converted into <tt>Iter::difference_type</tt>. This is so,
because 24.2.6 [random.access.iterators] uses this type as argument
of it's algebraic operators. Alternatively consider the equivalent
iterator algorithms in 24.4 [iterator.operations] with the same result.
</p>
<p>
This argument leads us to the conclusion that we also need
<tt>Convertible&lt;Rand::result_type, Iter::difference_type&gt;</tt> here.
</p>
</blockquote>

</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Alisdair notes that point (ii) has already been addressed.
</p>
<p>
We agree with the proposed resolution to point (i)
with Daniel's added requirement.
</p>
<p>
Move to Review.
</p>
</blockquote>

<p><i>[
2009-06-05 Daniel updated proposed wording as recommended in Batavia.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
Change in 25.2 [algorithms.syn] and 25.4.12 [alg.random.shuffle]:
</p>

<blockquote><pre><del>concept UniformRandomNumberGenerator&lt;typename Rand&gt; { }</del>
template&lt;RandomAccessIterator Iter, UniformRandomNumberGenerator Rand&gt;
  <ins>requires ShuffleIterator&lt;Iter&gt; &amp;&amp;
  Convertible&lt;Rand::result_type, Iter::difference_type&gt;</ins>
  void random_shuffle(Iter first, Iter last, Rand&amp;&amp; g);
</pre></blockquote>






<hr>
<h3><a name="1094"></a>1094. Response to JP 65 and JP 66</h3>
<p><b>Section:</b> 27.5.4.3 [iostate.flags] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Review">Review</a>
 <b>Submitter:</b> P.J. Plauger <b>Opened:</b> 2009-03-24  <b>Last modified:</b> 2009-05-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#iostate.flags">issues</a> in [iostate.flags].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Review">Review</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses JP 65 and JP 66</b></p>

<p>
Switch from "unspecified-bool-type" to "explicit operator bool() const". 
</p>

<p>
Replace <tt>operator unspecified-bool-type() const;</tt>" with <tt>explicit operator bool() const;</tt>
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution.
Move to Review.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change the synopis in 27.5.4 [ios]:
</p>

<blockquote><pre><ins>explicit</ins> operator <del><i>unspecified-bool-type</i></del> <ins>bool</ins>() const;
</pre></blockquote>

<p>
Change 27.5.4.3 [iostate.flags]:
</p>

<blockquote><pre><ins>explicit</ins> operator <del><i>unspecified-bool-type</i></del> <ins>bool</ins>() const;
</pre>

<blockquote>
<p>
-1- <i>Returns:</i> <ins><tt>!fail()</tt></ins> <del>If <tt>fail()</tt> then a value that will evaluate
false in a boolean context; otherwise a value that will evaluate true in
a boolean context. The value type returned shall not be convertible to
int.</del>
</p>
<p>
<del>[<i>Note:</i> This conversion can be used in contexts where a bool is expected
(e.g., an <tt>if</tt> condition); however, implicit conversions (e.g.,
to <tt>int</tt>) that can occur with <tt>bool</tt> are not allowed,
eliminating some sources of user error. One possible implementation
choice for this type is pointer-to-member. <i>-- end note</i>]</del>
</p>
</blockquote>
</blockquote>







<hr>
<h3><a name="1095"></a>1095. <i>Shared objects and the library</i> wording unclear</h3>
<p><b>Section:</b> 17.6.3.10 [res.on.objects] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Review">Review</a>
 <b>Submitter:</b> Beman Dawes <b>Opened:</b> 2009-03-27  <b>Last modified:</b> 2009-05-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Review">Review</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2775.htm">N2775</a>,
<i>Small library thread-safety revisions</i>, among other changes, removed a note from
17.6.3.10 [res.on.objects] that read:
</p>

<blockquote>
[<i>Note:</i> This prohibition against concurrent non-const access means that
modifying an object of a standard library type shared between threads
without using a locking mechanism may result in a data race. <i>--end note</i>.]
</blockquote>

<p>
That resulted in wording which is technically correct but can only be
understood by reading the lengthy and complex 17.6.4.7 [res.on.data.races]
Data race avoidance. This has the effect of making
17.6.3.10 [res.on.objects] unclear, and has already resulted in a query
to the LWG reflector. See c++std-lib-23194.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
The proposed wording seems to need a bit of tweaking
("really bad idea" isn't quite up to standardese).
We would like feedback
as to whether the original Note's removal was intentional.
</p>
<p>
Change the phrase "is a really bad idea"
to "risks undefined behavior" and
move to Review status.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 17.6.3.10 [res.on.objects] as indicated:
</p>

<blockquote>
<p>
The behavior of a program is undefined if calls to standard library
functions from different threads may introduce a data race. The
conditions under which this may occur are specified in 17.6.4.7.
</p>
<p><ins>
[<i>Note:</i> Thus modifying an object of a standard library type shared between
threads risks undefined behavior unless objects of the type are explicitly
specified as being sharable without data races or the user supplies a
locking mechanism. <i>--end note</i>]
</ins></p>
</blockquote>





<hr>
<h3><a name="1096"></a>1096. unconstrained rvalue ref parameters</h3>
<p><b>Section:</b> 17 [library] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> David Abrahams <b>Opened:</b> 2009-03-21  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
TODO: Look at all cases of unconstrained rvalue ref parameters and check
that concept req'ts work when <tt>T</tt> deduced as reference.
</p>

<p>
 We found some instances where that was not done correctly and we figure
   the possibility of deducing <tt>T</tt> to be an lvalue reference was probably
   overlooked elsewhere.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Move to Open, pending proposed wording from Dave for further review.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="1097"></a>1097. #define __STDCPP_THREADS</h3>
<p><b>Section:</b> 18.2 [support.types] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Review">Review</a>
 <b>Submitter:</b> Jens Maurer <b>Opened:</b> 2009-04-03  <b>Last modified:</b> 2009-05-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#support.types">issues</a> in [support.types].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Review">Review</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses DE 18</b></p>

<p>
Freestanding implementations do not (necessarily) have
  support for multiple threads (see 1.10 [intro.multithread]).
  Applications and libraries may want to optimize for the
  absence of threads.  I therefore propose a preprocessor
  macro to indicate whether multiple threads can occur.
</p>

<p>
There is ample prior implementation experience for this
  feature with various spellings of the macro name.  For
  example, gcc implicitly defines <tt>_REENTRANT</tt>
  if multi-threading support is selected on the compiler
  command-line.
</p>

<p>
While this is submitted as a library issue, it may be more
  appropriate to add the macro in 16.8 cpp.predefined in the
  core language.
</p>

<p>
See also
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2693.html">N2693</a>.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We agree with the issue, and believe it is properly a library issue.
</p>
<p>
We prefer that the macro be conditionally defined
as part of the <tt>&lt;thread&gt;</tt> header.
</p>
<p>
Move to Review.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Insert a new subsection before 18.2 [support.types], entitled
"Feature Macros" (support.macros):
</p>
<blockquote>
<p>
The standard library defines the following macros; no explicit
prior inclusion of any header file is necessary.
</p>
<blockquote>
<dl>
<dt><tt>__STDCPP_THREADS</tt></dt>
<dd>
The macro <tt>__STDCPP_THREADS</tt> shall be defined if and only if a
    program can have more than one thread of execution (1.10 [intro.multithread]).
If the macro is defined, it shall have the same
    value as the predefined macro <tt>__cplusplus</tt> (16.8 [cpp.predefined]).
</dd>
</dl>
</blockquote>
</blockquote>






<hr>
<h3><a name="1098"></a>1098. definition of get_pointer_safety()</h3>
<p><b>Section:</b> 20.8.13.7 [util.dynamic.safety] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Jens Maurer <b>Opened:</b> 2009-04-03  <b>Last modified:</b> 2009-05-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#util.dynamic.safety">issues</a> in [util.dynamic.safety].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses DE 18</b></p>

<p>
 In 20.8.13.7 [util.dynamic.safety], <tt>get_pointer_safety()</tt> purports
to define behavior for
 non-safely derived pointers (3.7.4.3 [basic.stc.dynamic.safety]).  However,
 the cited core-language section in paragraph 4 specifies undefined behavior
 for the use of such pointer values.  This seems an unfortunate near-contradiction.
 I suggest to specify the term <i>relaxed pointer safety</i> in
 the core language section and refer to it from the library description.
 This issue deals with the library part, the corresponding core issue (c++std-core-13940)
 deals with the core modifications.
</p>

<p>
See also
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2693.html">N2693</a>.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We recommend if this issue is to be moved,
the issue be moved concurrently with the cited Core issue.
</p>
<p>
We agree with the intent of the proposed resolution.
We would like input from garbage collection specialists.
</p>
<p>
Move to Open.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
In 20.8.13.7 [util.dynamic.safety] p16, replace the description of
<tt>get_pointer_safety()</tt> with:
</p>

<blockquote>
<p>
<tt>pointer_safety get_pointer_safety();</tt>
</p>
<blockquote>
<p>
<del><i>Returns:</i> an enumeration value indicating the implementation's treatment
of pointers that are not safely derived (3.7.4.3). Returns
<tt>pointer_safety::relaxed</tt> if pointers that are not safely derived will be
treated the same as pointers that are safely derived for the duration of
the program. Returns <tt>pointer_safety::preferred</tt> if pointers that are not
safely derived will be treated the same as pointers that are safely
derived for the duration of the program but allows the implementation to
hint that it could be desirable to avoid dereferencing pointers that are
not safely derived as described. [<i>Example:</i> <tt>pointer_safety::preferred</tt>
might be returned to detect if a leak detector is running to avoid
spurious leak reports. -- <i>end note</i>] Returns <tt>pointer_safety::strict</tt> if
pointers that are not safely derived might be treated differently than
pointers that are safely derived.</del>
</p>
<p><ins>
<i>Returns:</i> Returns <tt>pointer_safety::strict</tt> if the implementation has
   strict pointer safety (3.7.4.3 [basic.stc.dynamic.safety]). It is
   implementation-defined whether <tt>get_pointer_safety</tt> returns
   <tt>pointer_safety::relaxed</tt> or <tt>pointer_safety::preferred</tt> if the
   implementation has relaxed pointer safety
   (3.7.4.3 [basic.stc.dynamic.safety]).<sup>Footnote</sup>
</ins></p>

<p><ins>
<i>Throws:</i> nothing
</ins></p>

<p><ins>
Footnote) <tt>pointer_safety::preferred</tt> might be returned to indicate to the
   program that a leak detector is running so that the program can avoid
   spurious leak reports.
</ins>
</p>

</blockquote>
</blockquote>





<hr>
<h3><a name="1099"></a>1099. Various issues</h3>
<p><b>Section:</b> 17 [library] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> David Abrahams <b>Opened:</b> 2009-03-21  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Notes
</p>
<blockquote>
<p>
[2009-03-21 Sat] p. 535 at the top we need MoveConstructible V1,
MoveConstructible V2 (where V1,V2 are defined on 539).  Also make_tuple
on 550
</p>
<p>
[2009-03-21 Sat] p1183 thread ctor, and in general, we need a way to
talk about "copiable from generalized rvalue ref argument" for cases
where we're going to forward and copy.  
</p>
<blockquote>
<p>
   This issue may well be quite large.  Language in para 4 about "if
   an lvalue" is wrong because types aren't expressions.
</p>
<p>
   p1199, call_once has all the same issues.
</p>
</blockquote>
<p>
[2009-03-21 Sat] p869 InputIterator pointer type should not be required
to be convertible to const value_type*, rather it needs to have a
operator-&gt; of its own that can be used for the value type.
</p>
<p>
[2009-03-21 Sat] p818 stack has the same problem with default ctor.
</p>
<p>
[2009-03-21 Sat] p816 priority_queue has the same sorts of problems as queue, only more so
</p>
<blockquote><pre>   requires MoveConstructible&lt;Cont&gt; 
     explicit priority_queue(const Compare&amp; x = Compare(), Cont&amp;&amp; = Cont()); 
</pre>
<p>
   Don't require MoveConstructible when default constructing Cont.
   Also missing semantics for move ctor.
</p>
</blockquote>
<p>
 [2009-03-21 Sat] Why are Allocators required to be CopyConstructible as
 opposed to MoveConstructible?
</p>
<p>
 [2009-03-21 Sat] p813 queue needs a separate default ctor (Cont needn't
 be MoveConstructible).  No documented semantics for move c'tor.  Or
 *any* of its 7 ctors!
</p>
<p>
 [2009-03-21 Sat] std::array should have constructors for C++0x,
 consequently must consider move construction.
</p>

<p><i>[
2009-05-01 Daniel adds:
]</i></p>


<blockquote>
This could be done as part of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1035">1035</a>, which already handles
deviation of <tt>std::array</tt> from container tables.
</blockquote>

<p>
 [2009-03-21 Sat] p622 all messed up.
</p>
<blockquote>
<p>
   para 8 "implementation-defined" is the wrong term; should be "see
   below" or something.  
</p>
<p>
   para 12 "will be selected" doesn't make any sense because we're not
   talking about actual arg types.
</p>
<p>
   paras 9-13 need to be totally rewritten for concepts.
</p>
</blockquote>

<p>
 [2009-03-21 Sat] Null pointer comparisons (p587) have all become
 unconstrained.  Need to fix that
</p>
<p>
 [2009-03-21 Sat] mem_fun_t etc. definition doesn't match declaration.
  We think CopyConstructible is the right reqt.
</p>
<p>
 make_pair needs Constructible&lt;V1, T1&amp;&amp;&gt; requirements!
</p>
<p>
 make_tuple needs something similar
</p>
<p>
 tuple bug in synopsis:
</p>
<blockquote><pre>   template &lt;class... UTypes&gt;
   requires Constructible&lt;Types, const UTypes&amp;&gt;...
   template &lt;class... UTypes&gt;
   requires Constructible&lt;Types, RvalueOf&lt;UTypes&gt;::type&gt;...
</pre>
<p>
   Note: removal of MoveConstructible requirements in std::function makes
   these routines unconstrained!
</p>
</blockquote>

<p><i>[
2009-05-02 Daniel adds:
]</i></p>


<blockquote>
This part of the issue is already covered by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1077">1077</a>.
</blockquote>

<p>
 these unique_ptr constructors are broken [ I think this is covered in "p622 all messed up" ]
</p>
<blockquote><pre> unique_ptr(pointer p, implementation-defined d);
 unique_ptr(pointer p, implementation-defined d);
</pre></blockquote>
<p>
 multimap range constructor should not have MoveConstructible&lt;value_type&gt; requirement.
</p>
<blockquote>
   same with insert(..., P&amp;&amp;); multiset has the same issue, as do
   unordered_multiset and unordered_multimap. Review these!
</blockquote>

</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Move to Open, pending proposed wording from Dave for further review.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="1100"></a>1100. <tt>auto_ptr</tt> to <tt>unique_ptr</tt> conversion</h3>
<p><b>Section:</b> D.9 [depr.auto.ptr] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-04-25  <b>Last modified:</b> 2009-05-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Message c++std-lib-23182 led to a discussion in which several people
expressed interest in being able to convert an <tt>auto_ptr</tt> to a
<tt>unique_ptr</tt> without the need to call <tt>release</tt>.  Below is
wording to accomplish this.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Pete believes it not a good idea to separate parts of a class's definition.
Therefore, if we do this,
it should be part of <tt>unique-ptr</tt>'s specification.
</p>
<p>
Alisdair believes the lvalue overload may be not necessary.
</p>
<p>
Marc believes it is more than just sugar,
as it does ease the transition to <tt>unique-ptr</tt>.
</p>
<p>
We agree with the resolution as presented.
Move to Tentatively Ready.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Add to D.9 [depr.auto.ptr]:
</p>

<blockquote>
<p>
The following <tt>unique_ptr</tt> constructors are in addition to those specified
in 20.8.12.2.1 [unique.ptr.single.ctor].
</p>
<pre>template &lt;class T, class D&gt;
class unique_ptr
{
public:
    template &lt;class U&gt;
      requires SameType&lt;D, default_delete&lt;T&gt;&gt;
            &amp;&amp; Convertible&lt;U*, T*&gt;
      unique_ptr(auto_ptr&lt;U&gt;&amp; u);
    template &lt;class U&gt;
      requires SameType&lt;D, default_delete&lt;T&gt;&gt;
            &amp;&amp; Convertible&lt;U*, T*&gt;
      unique_ptr(auto_ptr&lt;U&gt;&amp;&amp; u);
};
</pre>
<p>
<i>Effects:</i> Constructs a <tt>unique_ptr</tt> with <tt>u.release()</tt>.
</p>

<p>
<i>Postconditions:</i> <tt>get() == </tt> the value <tt>u.get()</tt> had before
the construciton, modulo any required offset adjustments resulting from the cast from
<tt>U*</tt> to <tt>T*</tt>.  <tt>u.get() == nullptr</tt>.
</p>

<p>
<i>Throws:</i> nothing.
</p>
</blockquote>






<hr>
<h3><a name="1101"></a>1101. <tt>unique</tt> requirements</h3>
<p><b>Section:</b> 25.4.9 [alg.unique] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">Tentatively NAD Editorial</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-04-25  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#alg.unique">active issues</a> in [alg.unique].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.unique">issues</a> in [alg.unique].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20NAD%20Editorial">Tentatively NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
From Message c++std-core-14160 Howard wrote:
</p>

<blockquote>
It was the intent of the rvalue reference proposal for unique to only require MoveAssignable:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1860.html#25.2.9%20-%20Unique">N1860</a>.
</blockquote>

<p>
And Pete replied:
</p>

<blockquote>
That was overridden by the subsequent changes made for concepts in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2573.pdf">N2573</a>,
which reimposed the C++03 requirements.
</blockquote>

<p>
My impression is that this overwrite was a simple (unintentional) mistake.
Wording below to correct it.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Howard notes this issue resolves a discrepancy between the synopsis
and the description.
</p>
<p>
Move to NAD Editorial.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 25.4.9 [alg.unique]:
</p>

<blockquote><pre>template&lt;ForwardIterator Iter&gt; 
  requires OutputIterator&lt;Iter, <ins>RvalueOf&lt;</ins>Iter::reference<ins>&gt;::type</ins>&gt; 
        &amp;&amp; EqualityComparable&lt;Iter::value_type&gt; 
  Iter unique(Iter first, Iter last); 

template&lt;ForwardIterator Iter, EquivalenceRelation&lt;auto, Iter::value_type&gt; Pred&gt; 
  requires OutputIterator&lt;Iter, RvalueOf&lt;Iter::reference&gt;::type&gt; 
        &amp;&amp; CopyConstructible&lt;Pred&gt; 
  Iter unique(Iter first, Iter last, Pred pred);
</pre></blockquote>

<p>
Note that the synopsis in 25.2 [algorithms.syn] is already correct.
</p>






<hr>
<h3><a name="1102"></a>1102. <tt>std::vector</tt>'s reallocation policy still unclear</h3>
<p><b>Section:</b> 23.3.6.2 [vector.capacity] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Review">Review</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2009-04-20  <b>Last modified:</b> 2009-05-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#vector.capacity">issues</a> in [vector.capacity].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Review">Review</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I have the impression that even the wording of current draft
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2857.pdf">N2857</a>
does insufficiently express the intent of <tt>vector</tt>'s
reallocation strategy. This has produced not too old library
implementations which release memory in the <tt>clear()</tt> function
and even modern articles about C++ programming cultivate
the belief that <tt>clear</tt> is allowed to do exactly this. A typical
example is something like this:
</p>

<blockquote><pre>const int buf_size = ...;
std::vector&lt;T&gt; buf(buf_size);
for (int i = 0; i &lt; some_condition; ++i) {
  buf.resize(buf_size);
  write_or_read_data(buf.data());
  buf.clear(); // Ensure that the next round get's 'zeroed' elements
}
</pre></blockquote>
<p>
where still the myth is ubiquitous that <tt>buf</tt> might be
allowed to reallocate it's memory *inside* the <tt>for</tt> loop.
</p>
<p>
IMO the problem is due to the fact, that
</p>

<ol type="a">
<li>
the actual memory-reallocation stability of <tt>std::vector</tt>
is explained in 23.3.6.2 [vector.capacity]/3 and /6 which
are describing just the effects of the <tt>reserve</tt>
function, but in many examples (like above) there
is no explicit call to <tt>reserve</tt> involved. Further-more
23.3.6.2 [vector.capacity]/6 does only mention <em>insertions</em>
and never mentions the consequences of erasing
elements.
</li>
<li>
<p>
the effects clause of <tt>std::vector</tt>'s <tt>erase</tt> overloads in
23.3.6.4 [vector.modifiers]/4 is silent about capacity changes. This
easily causes a misunderstanding, because the counter
parting insert functions described in 23.3.6.4 [vector.modifiers]/2
explicitly say, that
</p>
<blockquote>
Causes reallocation if the new size is greater than the
old capacity. If no reallocation happens, all the iterators
and references before the insertion point remain valid.
</blockquote>
<p>
It requires a complex argumentation chain about four
different places in the standard to provide the - possibly
weak - proof that calling <tt>clear()</tt> also does <em>never</em> change
the capacity of the <tt>std::vector</tt> container. Since <tt>std::vector</tt>
is the de-facto replacement of C99's dynamic arrays this
type is near to a built-in type and it's specification should
be clear enough that usual programmers can trust their
own reading.
</p>
</li>
</ol>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Bill believes paragraph 1 of the proposed resolution is unnecessary
because it is already implied (even if tortuously) by the current wording.
</p>
<p>
Move to Review.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p><i>[
This is a minimum version. I also
suggest that the wording explaining the allocation strategy
of <tt>std::vector</tt> in 23.3.6.2 [vector.capacity]/3 and /6 is moved into
a separate sub paragraph of 23.3.6.2 [vector.capacity] <em>before</em>
any of the prototype's are discussed, but I cannot provide
reasonable wording changes now
]</i></p>


<ol>
<li>
<p>
Change 23.3.6.2 [vector.capacity]/6 as follows:
</p>
<blockquote>
It is guaranteed that no reallocation takes place during
insertions <ins>or erasures</ins> that happen after a call
to <tt>reserve()</tt> until the time when an insertion would make
the size of the vector greater than the value of <tt>capacity()</tt>.
</blockquote>
</li>
<li>
<p>
Change 23.3.6.4 [vector.modifiers]/4 as follows:
</p>
<blockquote>
<i>Effects:</i> <ins>The capacity shall remain unchanged and no reallocation shall
happen.</ins>
Invalidates iterators and references at or after the point
of the erase.
</blockquote>
</li>
</ol>





<hr>
<h3><a name="1103"></a>1103. <tt>system_error</tt> constructor postcondition overly strict</h3>
<p><b>Section:</b> 19.5.5.2 [syserr.syserr.members] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-04-25  <b>Last modified:</b> 2009-05-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
19.5.5.2 [syserr.syserr.members] says:
</p>

<blockquote><pre>system_error(error_code ec, const string&amp; what_arg);
</pre>
<blockquote>
<p>
<i>Effects:</i> Constructs an object of class <tt>system_error</tt>.
</p>
<p>
<i>Postconditions:</i> <tt>code() == ec</tt> and <tt>strcmp(runtime_error::what(), what_arg.c_str()) == 0</tt>.
</p>
</blockquote>
</blockquote>

<p>
However the intent is for:
</p>

<blockquote><pre>std::system_error se(std::errc::not_a_directory, "In FooBar");
...
se.what();  <font color="#c80000">// returns something along the lines of:</font>
            <font color="#c80000">//   "In FooBar: Not a directory"</font>
</pre></blockquote>

<p>
The way the constructor postconditions are set up now, to achieve both
conformance, and the desired intent in the <tt>what()</tt> string, the
<tt>system_error</tt> constructor must store "In FooBar" in the base class,
and then form the desired output each time <tt>what()</tt> is called.  Or
alternatively, store "In FooBar" in the base class, and store the desired
<tt>what()</tt> string in the derived <tt>system_error</tt>, and override
<tt>what()</tt> to return the string in the derived part.
</p>

<p>
Both of the above implementations seem suboptimal to me.  In one I'm computing
a new string every time <tt>what()</tt> is called.  And since <tt>what()</tt>
can't propagate exceptions, the client may get a different string on different
calls.
</p>

<p>
The second solution requires storing two strings instead of one.
</p>

<p>
What I would like to be able to do is form the desired <tt>what()</tt> string
once in the <tt>system_error</tt> constructor, and store <em>that</em> in the
base class.  Now I'm:
</p>

<ol>
<li>Computing the desired <tt>what()</tt> only once.</li>
<li>The base class <tt>what()</tt> definition is sufficient and nothrow.</li>
<li>I'm not storing multiple strings.</li>
</ol>

<p>
This is smaller code, smaller data, and faster.
</p>

<p>
<tt>ios_base::failure</tt> has the same issue.
</p>

<p><i>[
Comments about this change received favorable comments from the <tt>system_error</tt>
designers.
]</i></p>


<p><i>[
Batavia (2009-05):
]</i></p>


<blockquote>
<p>
We agree with the proposed resolution.
</p>
<p>
Move to Tentatively Ready.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
In 19.5.5.2 [syserr.syserr.members], change the following constructor postconditions:
</p>

<blockquote>
<pre>system_error(error_code ec, const string&amp; what_arg);
</pre>
<blockquote>
-2- <i>Postconditions:</i> <tt>code() == ec</tt>
and <tt><del>strcmp(runtime_error::what(), what_arg.c_str()) == 0</del>
<ins>string(what()).find(what_arg) != string::npos</ins></tt>.
</blockquote>

<pre>system_error(error_code ec, const char* what_arg);
</pre>
<blockquote>
-4- <i>Postconditions:</i> <tt>code() == ec</tt>
and <tt><del>strcmp(runtime_error::what(), what_arg) == 0</del>
<ins>string(what()).find(what_arg) != string::npos</ins></tt>.
</blockquote>

<pre>system_error(error_code ec);
</pre>
<blockquote>
-6- <i>Postconditions:</i> <tt>code() == ec</tt>
<del>and <tt>strcmp(runtime_error::what(), ""</tt></del>.
</blockquote>

<pre>system_error(int ev, const error_category&amp; ecat, const string&amp; what_arg);
</pre>
<blockquote>
-8- <i>Postconditions:</i> <tt>code() == error_code(ev, ecat)</tt>
and <tt><del>strcmp(runtime_error::what(), what_arg.c_str()) == 0</del>
<ins>string(what()).find(what_arg) != string::npos</ins></tt>.
</blockquote>

<pre>system_error(int ev, const error_category&amp; ecat, const char* what_arg);
</pre>
<blockquote>
-10- <i>Postconditions:</i> <tt>code() == error_code(ev, ecat)</tt>
and <tt><del>strcmp(runtime_error::what(), what_arg) == 0</del>
<ins>string(what()).find(what_arg) != string::npos</ins></tt>.
</blockquote>

<pre>system_error(int ev, const error_category&amp; ecat);
</pre>
<blockquote>
-12- <i>Postconditions:</i> <tt>code() == error_code(ev, ecat)</tt>
<del>and <tt>strcmp(runtime_error::what(), "") == 0</tt></del>.
</blockquote>

</blockquote>

<p>
In 19.5.5.2 [syserr.syserr.members], change the description of <tt>what()</tt>:
</p>

<blockquote>
<pre>const char *what() const throw();
</pre>
<blockquote>
<p>
-14- <i>Returns:</i> An NTBS incorporating <del><tt>runtime_error::what()</tt> and
<tt>code().message()</tt></del> <ins>the arguments supplied in the constructor</ins>.
</p>
<p>
[<i>Note:</i> <del>One possible implementation would be:</del>
<ins>The return NTBS might take the form: <tt>what_arg + ": " + code().message()</tt></ins>
</p>
<blockquote><pre><del>
if (msg.empty()) { 
  try { 
    string tmp = runtime_error::what(); 
    if (code()) { 
      if (!tmp.empty()) 
        tmp += ": "; 
      tmp += code().message(); 
    } 
    swap(msg, tmp); 
  } catch(...) { 
    return runtime_error::what(); 
  } 
return msg.c_str();
</del></pre></blockquote>
<p>
&#8212; <i>end note</i>]
</p>
</blockquote>
</blockquote>

<p>
In 27.5.2.1.1 [ios::failure], change the synopsis:
</p>

<blockquote><pre>namespace std { 
  class ios_base::failure : public system_error { 
  public: 
    explicit failure(const string&amp; msg, const error_code&amp; ec = io_errc::stream); 
    explicit failure(const char* msg, const error_code&amp; ec = io_errc::stream); 
    <del>virtual const char* what() const throw();</del>
  }; 
}
</pre></blockquote>

<p>
In 27.5.2.1.1 [ios::failure], change the description of the constructors:
</p>

<blockquote>

<pre>explicit failure(const string&amp; msg, , const error_code&amp; ec = io_errc::stream);
</pre>
<blockquote>
<p>
-3- <i>Effects:</i> Constructs an object of class <tt>failure</tt>
<ins>by constructing the base class with <tt>msg</tt> and <tt>ec</tt></ins>.
</p>
<p>
<del>-4- <i>Postcondition:</i> <tt>code() == ec</tt> and <tt>strcmp(what(), msg.c_str()) == 0</tt></del>
</p>
</blockquote>

<pre>explicit failure(const char* msg, const error_code&amp; ec = io_errc::stream);
</pre>
<blockquote>
<p>
-5- <i>Effects:</i> Constructs an object of class <tt>failure</tt>
<ins>by constructing the base class with <tt>msg</tt> and <tt>ec</tt></ins>.
</p>
<p>
<del>-6- <i>Postcondition:</i> <tt>code() == ec and strcmp(what(), msg) == 0</tt></del>
</p>
</blockquote>

</blockquote>

<p>
In 27.5.2.1.1 [ios::failure], remove <tt>what</tt> (the base class definition
need not be repeated here).
</p>

<blockquote>
<pre><del>const char* what() const;</del>
</pre>
<blockquote>
<del>-7- <i>Returns:</i> The message <tt>msg</tt> with which the exception was created.</del>
</blockquote>

</blockquote>






<hr>
<h3><a name="1104"></a>1104. <tt>basic_ios::move</tt> should accept lvalues</h3>
<p><b>Section:</b> 27.5.4.2 [basic.ios.members] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Review">Review</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-04-25  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#basic.ios.members">active issues</a> in [basic.ios.members].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#basic.ios.members">issues</a> in [basic.ios.members].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Review">Review</a> status.</p>
<p><b>Discussion:</b></p>
<p>
With the rvalue reference changes in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2844.html">N2844</a>
<tt>basic_ios::move</tt> no longer has the most convenient signature:
</p>

<blockquote><pre>void move(basic_ios&amp;&amp; rhs);
</pre></blockquote>

<p>
This signature should be changed to accept lvalues.  It does not need to be
overloaded to accept rvalues.  This is a special case that only derived clients
will see.  The generic <tt>move</tt> still needs to accept rvalues.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Tom prefers, on general principles, to provide both overloads.
Alisdair agrees.
</p>
<p>
Howard points out that there is no backward compatibility issue
as this is new to C++0X.
</p>
<p>
We agree that both overloads should be provided,
and Howard will provide the additional wording.
Move to Open.
</p>
</blockquote>

<p><i>[
2009-05-23 Howard adds:
]</i></p>


<blockquote>
Added overload, moved to Review.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add a signature to the existing prototype in the synopsis of 27.5.4 [ios]
and in 27.5.4.2 [basic.ios.members]:
</p>

<blockquote><pre><ins>void move(basic_ios&amp; rhs);</ins>
void move(basic_ios&amp;&amp; rhs);
</pre></blockquote>





<hr>
<h3><a name="1105"></a>1105. Shouldn't <tt>Range</tt> be an <tt>auto concept</tt></h3>
<p><b>Section:</b> 24.2.8 [iterator.concepts.range] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> David Abrahams <b>Opened:</b> 2009-04-23  <b>Last modified:</b> 2009-05-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p><i>[
2009-04-26 Herb adds:
]</i></p>


<blockquote>
<p>
Here's a common example: We have many ISV customers who have built lots of
in-house STL-like containers. Imagine that, for the past ten years, the user
has been happily using his <tt>XYZCorpContainer&lt;T&gt;</tt> that has <tt>begin()</tt> and <tt>end()</tt>
and an iterator typedef, and indeed satisfies nearly all of <tt>Container</tt>,
though maybe not quite all just like <tt>valarray</tt>. The user upgrades to a
range-enabled version of a library, and now <tt>lib_algo( xyz.begin(), xyz.end());</tt>
no longer works -- compiler error.
</p>
<p>
Even though <tt>XYZCorpContainer</tt> matches the pre-conceptized version of the
algorithm, and has been working for years, it appears the user has to write
at least this:
</p>
<blockquote><pre>template&lt;class T&gt; concept_map Range&lt;XYZCorpContainer&lt;T&gt;&gt; {};

template&lt;class T&gt; concept_map Range&lt;const XYZCorpContainer&lt;T&gt;&gt; {};
</pre></blockquote>
<p>
Is that correct?
</p>
<p>
But he may actually have to write this as we do for initializer list:
</p>
<blockquote><pre>template&lt;class T&gt;
concept_map Range&lt;XYZCorpContainer&lt;T&gt;&gt; {
   typedef T* iterator;
   iterator begin(XYZCorpContainer&lt;T&gt; c) { return c.begin(); }
   iterator end(XYZCorpContainer&lt;T&gt; c) { return c.end(); }
};

template&lt;class T&gt;
concept_map Range&lt;const XYZCorpContainer&lt;T&gt;&gt; {
   typedef T* iterator;
   iterator begin(XYZCorpContainer&lt;T&gt; c) { return c.begin(); }
   iterator end(XYZCorpContainer&lt;T&gt; c) { return c.end(); }
};
</pre></blockquote>

</blockquote>

<p><i>[
2009-04-28 Alisdair adds:
]</i></p>


<blockquote>
<p>
I recommend NAD, although remain concerned about header organisation.
</p>
<p>
A user container will satisfy the <tt>MemberContainer</tt> concept, which IS auto.
There is a concept_map for all <tt>MemberContainers</tt> to <tt>Container</tt>, and then a
further concept_map for all <tt>Container</tt> to <tt>Range</tt>, so the stated problem is not
actually true.  User defined containers will automatically match the <tt>Range</tt>
concept without explicitly declaring a concept_map.
</p>
<p>
The problem is that they should now provide an additional two headers,
<tt>&lt;iterator_concepts&gt;</tt> and <tt>&lt;container_concepts&gt;</tt>.
 The only difference from
making <tt>Range</tt> an auto concept would be this reduces to a single header,
<tt>&lt;iterator_concepts&gt;</tt>.
</p>
<p>
I am strongly in favour of any resolution that tackles the issue of
explicitly requiring concept headers to make these concept maps available.
</p>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We observe there is a recent paper by Bjarne that overlaps this issue.
</p>
<p>
Alisdair continues to recommend NAD.
</p>
<p>
Move to Open, and recommend the issue be deferred until after the next
Committee Draft is issued.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1106"></a>1106. Multiple exceptions from connected <tt>shared_future::get()</tt>?</h3>
<p><b>Section:</b> 30.6.5 [future.shared_future] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Thomas J. Gritzan <b>Opened:</b> 2009-04-03  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#future.shared_future">active issues</a> in [future.shared_future].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#future.shared_future">issues</a> in [future.shared_future].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It is not clear, if multiple threads are waiting in a 
<tt>shared_future::get()</tt> call, if each will rethrow the stored exception.
</p>
<p>
Paragraph 9 reads: 
</p>
<blockquote>
<i>Throws:</i> the stored exception, if an exception was stored and not 
retrieved before.
</blockquote>
<p>
The "not retrieved before" suggests that only one exception is thrown, 
but one exception for each call to <tt>get()</tt> is needed, and multiple calls 
to <tt>get()</tt> even on the same <tt>shared_future</tt> object seem to be allowed. 
</p>
<p>
I suggest removing "and not retrieved before" from the Throws paragraph. 
I recommend adding a note that explains that multiple calls on <tt>get()</tt> are 
allowed, and each call would result in an exception if an exception was 
stored. 
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We note there is a pending paper by Detlef
on such <tt>future</tt>-related issues;
we would like to wait for his paper before proceeding.
</p>
<p>
Alisdair suggests we may want language to clarify that this
<tt>get()</tt> function can be called from several threads
with no need for explicit locking.
</p>
<p>
Move to Open.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 30.6.5 [future.shared_future]:
</p>

<blockquote><pre>const R&amp; shared_future::get() const; 
R&amp; shared_future&lt;R&amp;&gt;::get() const; 
void shared_future&lt;void&gt;::get() const;
</pre>
<blockquote>
<p>...</p>
<p>
-9- <i>Throws:</i> the stored exception, if an exception was stored<del> and not retrieved before</del>.
<ins>
[<i>Note:</i> Multiple calls on <tt>get()</tt> are 
allowed, and each call would result in an exception if an exception was 
stored. &#8212; <i>end note</i>]
</ins>
</p>
</blockquote>
</blockquote>






<hr>
<h3><a name="1107"></a>1107. constructor <tt>shared_future(unique_future)</tt> by value?</h3>
<p><b>Section:</b> 30.6.5 [future.shared_future] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Thomas J. Gritzan <b>Opened:</b> 2009-04-03  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#future.shared_future">active issues</a> in [future.shared_future].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#future.shared_future">issues</a> in [future.shared_future].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In the <tt>shared_future</tt> class definition in 30.6.5 [future.shared_future]
the move constructor 
that constructs a <tt>shared_future</tt> from an <tt>unique_future</tt> receives the 
parameter by value. In paragraph 3, the same constructor receives it as 
const value. 
</p>

<p>
I think that is a mistake and the constructor should take a r-value 
reference: 
</p>

<blockquote><pre>shared_future(unique_future&lt;R&gt;&amp;&amp; rhs);
</pre></blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We agree with the proposed resolution.
</p>
<p>
Move to Tentatively Ready.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change the synopsis in 30.6.5 [future.shared_future]:
</p>

<blockquote><pre>shared_future(unique_future&lt;R&gt;<ins>&amp;&amp;</ins> rhs);
</pre></blockquote>

<p>
Change the definition of the constructor in 30.6.5 [future.shared_future]:
</p>

<blockquote><pre>shared_future(<del>const</del> unique_future&lt;R&gt;<ins>&amp;&amp;</ins> rhs);
</pre></blockquote>






<hr>
<h3><a name="1108"></a>1108. thread.req.exception overly constrains implementations</h3>
<p><b>Section:</b> 30.2.2 [thread.req.exception] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Christopher Kohlhoff <b>Opened:</b> 2009-04-25  <b>Last modified:</b> 2009-05-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The current formulation of 30.2.2 [thread.req.exception]/2 reads:
</p>
<blockquote>
The error_category of the <tt>error_code</tt> reported by such an
exception's <tt>code()</tt> member function is as specified in the error
condition Clause.
</blockquote>
<p>
This constraint on the code's associated <tt>error_categor</tt> means an
implementation must perform a mapping from the system-generated
error to a <tt>generic_category()</tt> error code. The problems with this
include:
</p>

<ul>
<li>
The mapping is always performed, even if the resultant value is
 never used.
</li>
<li>
<p>
The original error produced by the operating system is lost.
</p>
</li>
</ul>
<p>
The latter was one of Peter Dimov's main objections (in a private
email discussion) to the original <tt>error_code</tt>-only design, and led to
the creation of <tt>error_condition</tt> in the first place. Specifically,
<tt>error_code</tt> and <tt>error_condition</tt> are intended to perform the following
roles:
</p>
<ul>
<li>
<tt>error_code</tt> holds the original error produced by the operating
 system.
</li>
<li>
<tt>error_condition</tt> and the generic category provide a set of well
 known error constants that error codes may be tested against.
</li>
</ul>
<p>
Any mapping determining correspondence of the returned error code to
the conditions listed in the error condition clause falls under the
"latitude" granted to implementors in 19.5.1.5 [syserr.errcat.objects].
(Although obviously their latitude is restricted a little by the
need to match the right error condition when returning an error code
from a library function.)
</p>
<p>
It is important that this <tt>error_code/error_condition</tt> usage is done
correctly for the thread library since it is likely to set the
pattern for future TR libraries that interact with the operating
system.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Move to Open, and recommend the issue be deferred until after the next
Committee Draft is issued.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 30.2.2 [thread.req.exception]/2:
</p>

<blockquote>
<p>
-2- <del>The <tt>error_category</tt> (19.5.1.1) of the <tt>error_code</tt> reported by
such an exception's <tt>code()</tt> member function 
is as specified in the error condition Clause.</del>
<ins>
The <tt>error_code</tt> reported by such an exception's <tt>code()</tt> member
function shall compare equal to one of the conditions specified in
the function's error condition Clause. [<i>Example:</i> When the thread
constructor fails:
</ins>
</p>
<blockquote><pre><ins>
ec.category() == implementation-defined // probably system_category
ec == errc::resource_unavailable_try_again // holds true
</ins></pre></blockquote>

<p><ins>
&#8212; <i>end example</i>]
</ins></p>

</blockquote>






<hr>
<h3><a name="1109"></a>1109. <tt>std::includes</tt> should require <tt>CopyConstructible</tt> predicate</h3>
<p><b>Section:</b> 25.5.5.1 [includes] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">Tentatively NAD Editorial</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-04-28  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#includes">active issues</a> in [includes].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#includes">issues</a> in [includes].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Tentatively%20NAD%20Editorial">Tentatively NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
All the set operation algorithms require a <tt>CopyConstructible</tt> predicate, with
the exception of <tt>std::includes</tt>.  This looks like a typo as much as anything,
given the general library requirement that predicates are copy
constructible, and wording style of other set-like operations.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution.
Move to NAD Editorial.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 25.2 [algorithms.syn] and 25.5.5.1 [includes]:
</p>

<blockquote><pre>template&lt;InputIterator Iter1, InputIterator Iter2,
         <del>typename</del> <ins>CopyConstructible</ins> Compare&gt;
  requires Predicate&lt;Compare, Iter1::value_type, Iter2::value_type&gt;
        &amp;&amp; Predicate&lt;Compare, Iter2::value_type, Iter1::value_type&gt;
  bool includes(Iter1 first1, Iter1 last1,
                Iter2 first2, Iter2 last2,
                Compare comp);
</pre></blockquote>





<hr>
<h3><a name="1110"></a>1110. Is <tt>for_each</tt> overconstrained?</h3>
<p><b>Section:</b> 25.3.4 [alg.foreach] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-04-29  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#alg.foreach">active issues</a> in [alg.foreach].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.foreach">issues</a> in [alg.foreach].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Quoting working paper for reference (25.3.4 [alg.foreach]):
</p>

<blockquote>
<pre>template&lt;InputIterator Iter, Callable&lt;auto, Iter::reference&gt; Function&gt;
  requires CopyConstructible&lt;Function&gt;
  Function for_each(Iter first, Iter last, Function f);
</pre>
<blockquote>
<p>
1 Effects: Applies f to the result of dereferencing every iterator in the
 range [first,last), starting from first and proceeding to last - 1.
</p>
<p>
2 Returns: f.
</p>
<p>
3 Complexity: Applies f exactly last - first times.
</p>
</blockquote>
</blockquote>

<p>
P2 implies the passed object <tt>f</tt> should be invoked at each stage, rather than
some copy of <tt>f</tt>.  This is important if the return value is to usefully
accumulate changes.  So the requirements are an object of type <tt>Function</tt> can
be passed-by-value, invoked multiple times, and then return by value.  In
this case, <tt>MoveConstructible</tt> is sufficient. This would open support for
move-only functors, which might become important in concurrent code as you
can assume there are no other references (copies) of a move-only type and so
freely use them concurrently without additional locks.
</p>

<p><i>[
See further discussion starting with c++std-lib-23686.
]</i></p>


<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Pete suggests we may want to look at this in a broader context
involving other algorithms.
We should also consider the implications of parallelism.
</p>
<p>
Move to Open, and recommend the issue be deferred until after the next
Committee Draft is issued.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 25.2 [algorithms.syn] and 25.3.4 [alg.foreach]:
</p>

<blockquote><pre>template&lt;InputIterator Iter, Callable&lt;auto, Iter::reference&gt; Function&gt;
  requires <del>CopyConstructible</del> <ins>MoveConstructible</ins>&lt;Function&gt;
  Function for_each(Iter first, Iter last, Function f);
</pre></blockquote>





<hr>
<h3><a name="1111"></a>1111. associative containers underconstrained</h3>
<p><b>Section:</b> 23.4 [associative] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Review">Review</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-04-29  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#associative">active issues</a> in [associative].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#associative">issues</a> in [associative].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Review">Review</a> status.</p>
<p><b>Discussion:</b></p>
<p>
According to table 87 (n2857) the expression <tt>X::key_equal</tt> for an unordered
container shall return a value of type <tt>Pred</tt>, where <tt>Pred</tt> is an equivalence
relation.
</p>

<p>
However, all 4 containers constrain <tt>Pred</tt> to be merely a <tt>Predicate</tt>,
and not <tt>EquivalenceRelation</tt>.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We agree with the proposed resolution.
</p>
<p>
Move to Review.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
For ordered containers, replace 
</p>
<blockquote><pre>Predicate&lt;auto, Key, Key&gt; Compare = less&lt;Key&gt;
</pre></blockquote>
<p>
with 
</p>
<blockquote><pre>StrictWeakOrder&lt;auto, Key, Key&gt; Compare = less&lt;Key&gt;
</pre></blockquote>

<p>
For unordered containers, replace 
</p>
<blockquote><pre>Predicate&lt;auto, Key, Key&gt; Compare = less&lt;Key&gt;
</pre></blockquote>
<p>
with 
</p>
<blockquote><pre>EquivalenceRelation&lt;auto, Key, Key&gt; Compare = less&lt;Key&gt;
</pre></blockquote>
<p>
As in the following declarations:
</p>

<blockquote>
<p>
Associative containers 23.4 [associative]
</p>
<p>
 1 Headers &lt;map&gt; and &lt;set&gt;:
</p>
<p>
   Header &lt;map&gt; synopsis
</p>
<blockquote><pre>   namespace std {
     template &lt;ValueType Key, ValueType T,
               <del>Predicate</del><ins>StrictWeakOrder</ins>&lt;auto, Key<del>, Key</del>&gt; Compare = less&lt;Key&gt;,
               Allocator Alloc = allocator&lt;pair&amp;lt;&lt;b&gt;const Key, T&gt; &gt; &gt;
       requires NothrowDestructible&lt;Key&gt; &amp;&amp; NothrowDestructible&lt;T&gt;
             &amp;&amp; CopyConstructible&lt;Compare&gt;
             &amp;&amp; AllocatableElement&lt;Alloc, Compare, const Compare&amp;&gt;
             &amp;&amp; AllocatableElement&lt;Alloc, Compare, Compare&amp;&amp;&gt;
     class map;

     ...

     template &lt;ValueType Key, ValueType T,
               <del>Predicate</del><ins>StrictWeakOrder</ins>&lt;auto, Key<del>, Key</del>&gt; Compare = less&lt;Key&gt;,
               Allocator Alloc = allocator&lt;pair&amp;lt;&lt;b&gt;const Key, T&gt; &gt; &gt;
       requires NothrowDestructible&lt;Key&gt; &amp;&amp; NothrowDestructible&lt;T&gt;
             &amp;&amp; CopyConstructible&lt;Compare&gt;
             &amp;&amp; AllocatableElement&lt;Alloc, Compare, const Compare&amp;&gt;
             &amp;&amp; AllocatableElement&lt;Alloc, Compare, Compare&amp;&amp;&gt;
     class multimap;

     ...

   }
</pre></blockquote>

<p>
   Header &lt;set&gt; synopsis
</p>
<blockquote><pre>   namespace std {
     template &lt;ValueType Key, <del>Predicate</del><ins>StrictWeakOrder</ins>&lt;auto, Key<del>, Key</del>&gt; Compare = less&lt;Key&gt;,
               Allocator Alloc = allocator&lt;Key&gt; &gt;
       requires NothrowDestructible&lt;Key&gt; &amp;&amp; CopyConstructible&lt;Compare&gt;
             &amp;&amp; AllocatableElement&lt;Alloc, Compare, const Compare&amp;&gt;
             &amp;&amp; AllocatableElement&lt;Alloc, Compare, Compare&amp;&amp;&gt;
     class set;

     ...

     template &lt;ValueType Key, <del>Predicate</del><ins>StrictWeakOrder</ins>&lt;auto, Key<del>, Key</del>&gt; Compare = less&lt;Key&gt;,
               Allocator Alloc = allocator&lt;Key&gt; &gt;
       requires NothrowDestructible&lt;Key&gt; &amp;&amp; CopyConstructible&lt;Compare&gt;
             &amp;&amp; AllocatableElement&lt;Alloc, Compare, const Compare&amp;&gt;
             &amp;&amp; AllocatableElement&lt;Alloc, Compare, Compare&amp;&amp;&gt;
     class multiset;

     ...

   }
</pre></blockquote>

<p>
 23.4.1p2 Class template map [map]
</p>
<blockquote><pre> namespace std {
   template &lt;ValueType Key, ValueType T,
             <del>Predicate</del><ins>StrictWeakOrder</ins>&lt;auto, Key<del>, Key</del>&gt; Compare = less&lt;Key&gt;,
             Allocator Alloc = allocator&lt;pair&amp;lt;&lt;b&gt;const Key, T&gt; &gt; &gt;
     requires NothrowDestructible&lt;Key&gt; &amp;&amp; NothrowDestructible&lt;T&gt;
           &amp;&amp; CopyConstructible&lt;Compare&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Compare, const Compare&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Compare, Compare&amp;&amp;&gt;
   class map {
     ...
   };
 }
</pre></blockquote>


<p>
 23.4.2p2 Class template multimap [multimap]
</p>
<blockquote><pre> namespace std {
   template &lt;ValueType Key, ValueType T,
             <del>Predicate</del><ins>StrictWeakOrder</ins>&lt;auto, Key<del>, Key</del>&gt; Compare = less&lt;Key&gt;,
             Allocator Alloc = allocator&lt;pair&amp;lt;&lt;b&gt;const Key, T&gt; &gt; &gt;
     requires NothrowDestructible&lt;Key&gt; &amp;&amp; NothrowDestructible&lt;T&gt;
           &amp;&amp; CopyConstructible&lt;Compare&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Compare, const Compare&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Compare, Compare&amp;&amp;&gt;
   class multimap {
     ...
   };
 }
</pre></blockquote>


<p>
 23.4.3p2 Class template set [set]
</p>
<blockquote><pre> namespace std {
   template &lt;ValueType Key, <del>Predicate</del><ins>StrictWeakOrder</ins>&lt;auto, Key<del>, Key</del>&gt; Compare = less&lt;Key&gt;,
             Allocator Alloc = allocator&lt;Key&gt; &gt;
     requires NothrowDestructible&lt;Key&gt; &amp;&amp; CopyConstructible&lt;Compare&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Compare, const Compare&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Compare, Compare&amp;&amp;&gt;
   class set {
     ...
   };
 }
</pre></blockquote>


<p>
 23.4.4p2 Class template multiset [multiset]
</p>
<blockquote><pre> namespace std {
   template &lt;ValueType Key, <del>Predicate</del><ins>StrictWeakOrder</ins>&lt;auto, Key<del>, Key</del>&gt; Compare = less&lt;Key&gt;,
             Allocator Alloc = allocator&lt;Key&gt; &gt;
     requires NothrowDestructible&lt;Key&gt; &amp;&amp; CopyConstructible&lt;Compare&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Compare, const Compare&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Compare, Compare&amp;&amp;&gt;
   class multiset {
     ...
   };
 }
</pre></blockquote>

<p>
 23.5 Unordered associative containers [unord]
</p>
<p>
 1 Headers &lt;unordered_map&gt; and &lt;unordered_set&gt;:
</p>
<p>
 Header &lt;unordered_map&gt; synopsis
</p>
<blockquote><pre> namespace std {
   // 23.5.1, class template unordered_map:
   template &lt;ValueType Key,
             ValueType T,
             Callable&lt;auto, const Key&amp;&gt; Hash = hash&lt;Key&gt;,
             <del>Predicate</del><ins>EquivalenceRelation</ins>&lt;auto, Key<del>, Key</del>&gt; Pred = equal_to&lt;Key&gt;,
             Allocator Alloc = allocator&lt;pair&amp;lt;&lt;b&gt;const Key, T&gt; &gt; &gt;
     requires NothrowDestructible&lt;Key&gt; &amp;&amp; NothrowDestructible&lt;T&gt;
           &amp;&amp; SameType&lt;Hash::result_type, size_t&gt;
           &amp;&amp; CopyConstructible&lt;Hash&gt; &amp;&amp; CopyConstructible&lt;Pred&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Pred, const Pred&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Pred, Pred&amp;&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Hash, const Hash&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Hash, Hash&amp;&amp;&gt;
     class unordered_map;

   // 23.5.2, class template unordered_multimap:
   template &lt;ValueType Key,
             ValueType T,
             Callable&lt;auto, const Key&amp;&gt; Hash = hash&lt;Key&gt;,
             <del>Predicate</del><ins>EquivalenceRelation</ins>&lt;auto, Key<del>, Key</del>&gt; Pred = equal_to&lt;Key&gt;,
             Allocator Alloc = allocator&lt;pair&amp;lt;&lt;b&gt;const Key, T&gt; &gt; &gt;
     requires NothrowDestructible&lt;Key&gt; &amp;&amp; NothrowDestructible&lt;T&gt;
           &amp;&amp; SameType&lt;Hash::result_type, size_t&gt;
           &amp;&amp; CopyConstructible&lt;Hash&gt; &amp;&amp; CopyConstructible&lt;Pred&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Pred, const Pred&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Pred, Pred&amp;&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Hash, const Hash&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Hash, Hash&amp;&amp;&gt;
     class unordered_multimap;

   ...
 }
</pre></blockquote>

<p>
 Header &lt;unordered_set&gt; synopsis
</p>
<blockquote><pre> namespace std {
   // 23.5.3, class template unordered_set:
   template &lt;ValueType Value,
             Callable&lt;auto, const Value&amp;&gt; Hash = hash&lt;Value&gt;,
             <del>Predicate</del><ins>EquivalenceRelation</ins>&lt;auto, Value<del>, Value</del>&gt; class Pred = equal_to&lt;Value&gt;,
             Allocator Alloc = allocator&lt;Value&gt; &gt;
     requires NothrowDestructible&lt;Value&gt;
           &amp;&amp; SameType&lt;Hash::result_type, size_t&gt;
           &amp;&amp; CopyConstructible&lt;Hash&gt; &amp;&amp; CopyConstructible&lt;Pred&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Pred, const Pred&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Pred, Pred&amp;&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Hash, const Hash&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Hash, Hash&amp;&amp;&gt;
     class unordered_set;

   // 23.5.4, class template unordered_multiset:
   template &lt;ValueType Value,
             Callable&lt;auto, const Value&amp;&gt; Hash = hash&lt;Value&gt;,
             <del>Predicate</del><ins>EquivalenceRelation</ins>&lt;auto, Value<del>, Value</del>&gt; class Pred = equal_to&lt;Value&gt;,
             Allocator Alloc = allocator&lt;Value&gt; &gt;
     requires NothrowDestructible&lt;Value&gt;
           &amp;&amp; SameType&lt;Hash::result_type, size_t&gt;
           &amp;&amp; CopyConstructible&lt;Hash&gt; &amp;&amp; CopyConstructible&lt;Pred&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Pred, const Pred&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Pred, Pred&amp;&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Hash, const Hash&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Hash, Hash&amp;&amp;&gt;
     class unordered_multiset;

   ...
 }
</pre></blockquote>

<p>
 23.5.1p3 Class template unordered_map [unord.map]
</p>
<blockquote><pre> namespace std {
   template &lt;ValueType Key,
             ValueType T,
             Callable&lt;auto, const Key&amp;&gt; Hash = hash&lt;Key&gt;,
             <del>Predicate</del><ins>EquivalenceRelation</ins>&lt;auto, Key<del>, Key</del>&gt; Pred = equal_to&lt;Key&gt;,
             Allocator Alloc = allocator&lt;pair&amp;lt;&lt;b&gt;const Key, T&gt; &gt; &gt;
     requires NothrowDestructible&lt;Key&gt; &amp;&amp; NothrowDestructible&lt;T&gt;
           &amp;&amp; SameType&lt;Hash::result_type, size_t&gt;
           &amp;&amp; CopyConstructible&lt;Hash&gt; &amp;&amp; CopyConstructible&lt;Pred&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Pred, const Pred&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Pred, Pred&amp;&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Hash, const Hash&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Hash, Hash&amp;&amp;&gt;
   class unordered_map
   {
     ...
   };
 }
</pre></blockquote>

<p>
 23.5.2p3 Class template unordered_multimap [unord.multimap]
</p>
<blockquote><pre> namespace std {
   template &lt;ValueType Key,
             ValueType T,
             Callable&lt;auto, const Key&amp;&gt; Hash = hash&lt;Key&gt;,
             <del>Predicate</del><ins>EquivalenceRelation</ins>&lt;auto, Key<del>, Key</del>&gt; Pred = equal_to&lt;Key&gt;,
             Allocator Alloc = allocator&lt;pair&amp;lt;&lt;b&gt;const Key, T&gt; &gt; &gt;
     requires NothrowDestructible&lt;Key&gt; &amp;&amp; NothrowDestructible&lt;T&gt;
           &amp;&amp; SameType&lt;Hash::result_type, size_t&gt;
           &amp;&amp; CopyConstructible&lt;Hash&gt; &amp;&amp; CopyConstructible&lt;Pred&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Pred, const Pred&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Pred, Pred&amp;&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Hash, const Hash&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Hash, Hash&amp;&amp;&gt;
   class unordered_multimap
   {
     ...
   };
 }
</pre></blockquote>

<p>
 23.5.3p3 Class template unordered_set [unord.set]
</p>
<blockquote><pre> namespace std {
   template &lt;ValueType Value,
             Callable&lt;auto, const Value&amp;&gt; Hash = hash&lt;Value&gt;,
             <del>Predicate</del><ins>EquivalenceRelation</ins>&lt;auto, Value<del>, Value</del>&gt; class Pred = equal_to&lt;Value&gt;,
             Allocator Alloc = allocator&lt;Value&gt; &gt;
     requires NothrowDestructible&lt;Value&gt;
           &amp;&amp; SameType&lt;Hash::result_type, size_t&gt;
           &amp;&amp; CopyConstructible&lt;Hash&gt; &amp;&amp; CopyConstructible&lt;Pred&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Pred, const Pred&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Pred, Pred&amp;&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Hash, const Hash&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Hash, Hash&amp;&amp;&gt;
   class unordered_set
   {
     ...
   };
 }
</pre></blockquote>
<p>
 23.5.4p3 Class template unordered_multiset [unord.multiset]
</p>
<blockquote><pre> namespace std {
   template &lt;ValueType Value,
             Callable&lt;auto, const Value&amp;&gt; Hash = hash&lt;Value&gt;,
             <del>Predicate</del><ins>EquivalenceRelation</ins>&lt;auto, Value<del>, Value</del>&gt; class Pred = equal_to&lt;Value&gt;,
             Allocator Alloc = allocator&lt;Value&gt; &gt;
     requires NothrowDestructible&lt;Value&gt;
           &amp;&amp; SameType&lt;Hash::result_type, size_t&gt;
           &amp;&amp; CopyConstructible&lt;Hash&gt; &amp;&amp; CopyConstructible&lt;Pred&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Pred, const Pred&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Pred, Pred&amp;&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Hash, const Hash&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Hash, Hash&amp;&amp;&gt;
   class unordered_multiset
   {
     ...
   };
 }
</pre></blockquote>

</blockquote>






<hr>
<h3><a name="1112"></a>1112. bitsets and new style for loop</h3>
<p><b>Section:</b> 20.3.6 [template.bitset] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-05-06  <b>Last modified:</b> 2009-05-25</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#template.bitset">active issues</a> in [template.bitset].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#template.bitset">issues</a> in [template.bitset].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>Std::bitset</tt> is a homogeneous container-like sequence of bits, yet it does
not model the Range concept so cannot be used with the new for-loop syntax.
It is the only such type in the library that does NOT support the new for
loop.
</p>
<p>
The obvious reason is that bitset does not support iterators.
</p>
<p>
At least two reasonable solutions are available:
</p>
<ol type="i">
<li>
Add an iterator interface to <tt>bitset</tt>, bringing its interface close to that
of <tt>std::array</tt>
</li>
<li>
Provide an unspecified concept_map for <tt>Range&lt;bitset&gt;</tt>.
</li>
</ol>
<p>
The latter will still need some kind of iterator-like adapter for <tt>bitset</tt>,
but gives implementers greater freedom on the details. E.g. begin/end return
some type that simply invokes <tt>operator[]</tt> on the object it wraps, and
increments its index on <tt>operator++</tt>.  A vendor can settle for <tt>InputIterator</tt>
support, rather than wrapping up a full <tt>RandomAccessIterator</tt>.
</p>
<p>
I have a mild preference for option (ii) as I think it is less work to
specify at this stage of the process, although (i) is probably more useful
in the long run.
</p>
<p>
Hmm, my wording looks a little woolly, as it does not say what the element
type of the range is.  Do I get a range of <tt>bool</tt>, <tt>bitset&lt;N&gt;::reference</tt>, or
something else entirely?
</p>
<p>
I guess most users will assume the behaviour of reference, but expect to
work with <tt>bool</tt>.  <tt>Bool</tt> is OK for read-only traversal, but you really need to
take a reference to a <tt>bitset::reference</tt> if you want to write back.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Move to Open.
We further recommend this be deferred until after the next Committee Draft.
</blockquote>

<p><i>[
2009-05-25 Alisdair adds:
]</i></p>


<blockquote>
<p>
I just stumbled over the <tt>Range concept_map</tt> for <tt>valarray</tt> and this should
probably set the precedent on how to write the wording.
</p>

<p><i>[
Howard: I've replaced the proposed wording with Alisdair's suggestion.
]</i></p>


</blockquote>



<p><b>Proposed resolution:</b></p>

<p>
20.3.6.X bitset concept maps [bitset.concepts] (made up clause name/number)
</p>
<pre>template&lt;size_t N&gt;
concept_map Range&lt;bitset&lt;N&gt;&gt; {
  typedef unspecified iterator;
  iterator begin(bitset&lt;N&gt;&amp; a);
  iterator end(bitset&lt;N&gt;&amp; a);
}

template&lt;typename T&gt;
concept_map Range&lt;const bitset&lt;N&gt;&gt; {
  typedef unspecified iterator;
  iterator begin(const bitset&lt;N&gt;&amp; a);
  iterator end(const bitset&lt;N&gt;&amp; a);
}
</pre>
<p>
-1- <i>Note:</i> these concept_maps adapt <tt>bitset</tt> to the <tt>Range</tt> concept.
</p>

<pre>typedef <i>unspecified</i> iterator;
</pre>

<blockquote>
-2- <i>Requires:</i> <tt>iterator</tt> shall meet the requirements of the
<tt>RandomAccessIterator</tt> concept and <tt>iterator::reference</tt>
shall equal <tt>bitset&lt;N&gt;::reference</tt> or <tt>const bitset&lt;N&gt;::reference</tt>.
</blockquote>

<pre>iterator begin(bitset&lt;N&gt;&amp; a);
iterator begin(const bitset&lt;N&gt;&amp; a);
</pre>

<blockquote>
-3- <i>Returns:</i> an <tt>iterator</tt> referencing the first bit in the <tt>bitset</tt>.
</blockquote>

<pre>iterator end(bitset&lt;N&gt;&amp; a);
iterator end(const bitset&lt;N&gt;&amp; a);
</pre>

<blockquote>
-4- <i>Returns:</i> an <tt>iterator</tt> referencing one past the last bit in the <tt>bitset</tt>.
</blockquote>










<hr>
<h3><a name="1113"></a>1113. <tt>bitset::to_string</tt> could be simplified</h3>
<p><b>Section:</b> 20.3.6 [template.bitset] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-05-09  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#template.bitset">active issues</a> in [template.bitset].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#template.bitset">issues</a> in [template.bitset].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#853">853</a> our resolution is changing the signature by adding two
defaulting arguments to 3 calls.  In principle, this means that ABI breakage
is not an issue, while API is preserved.
</p>
<p>
With that observation, it would be very nice to use the new ability to
supply default template parameters to function templates to collapse all 3
signatures into 1.  In that spirit, this issue offers an alternative resolution
than that of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#853">853</a>.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Move to Open,
and look at the issue again after <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#853">853</a> has been accepted.
We further recommend this be deferred until after the next Committee Draft.
</blockquote>


<p><b>Proposed resolution:</b></p>

<ol type="A">
<li>
<p>
In 20.3.6 [template.bitset]/1 (class bitset) ammend:
</p>
<blockquote><pre>template &lt;class charT <ins>= char</ins>,
            class traits <ins>= char_traits&lt;charT&gt;</ins>,
            class Allocator <ins>= allocator&lt;charT&gt;</ins>&gt; 
  basic_string&lt;charT, traits, Allocator&gt;
  to_string(charT zero = charT('0'), charT one = charT('1')) const;
<del>template &lt;class charT, class traits&gt; 
  basic_string&lt;charT, traits, allocator&lt;charT&gt; &gt; to_string() const; 
template &lt;class charT&gt; 
  basic_string&lt;charT, char_traits&lt;charT&gt;, allocator&lt;charT&gt; &gt; to_string() const; 
basic_string&lt;char, char_traits&lt;char&gt;, allocator&lt;char&gt; &gt; to_string() const;</del>
</pre></blockquote>
</li>
<li>
<p>
In 20.3.6.2 [bitset.members] prior to p35 ammend:
</p>
<blockquote><pre>template &lt;class charT <ins>= char</ins>,
            class traits <ins>= char_traits&lt;charT&gt;</ins>,
            class Allocator <ins>= allocator&lt;charT&gt;</ins>&gt; 
  basic_string&lt;charT, traits, Allocator&gt;
  to_string(charT zero = charT('0'), charT one = charT('1')) const;
</pre></blockquote>
</li>
<li>
Strike 20.3.6.2 [bitset.members] paragraphs 37 -&gt; 39 (including signature
above 37)
</li>
</ol>






<hr>
<h3><a name="1114"></a>1114. Type traits underspecified</h3>
<p><b>Section:</b> 20.6 [meta] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2009-05-12  <b>Last modified:</b> 2009-05-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#meta">active issues</a> in [meta].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#meta">issues</a> in [meta].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Related to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#975">975</a> and <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1023">1023</a>.
</p>

<p>
The current wording in 20.6.1 [meta.rqmts] is still unclear concerning
it's requirements on the type traits classes regarding ambiguities.
Specifically it's unclear
</p>

<ul>
<li>
if a predicate trait (20.6.4 [meta.unary], 20.6.5 [meta.rel]) could derive from both
<tt>true_type</tt>/<tt>false_type</tt>.
</li>
<li>
if any of the type traits (20.6.1 [meta.rqmts], 20.6.4 [meta.unary], 20.6.5 [meta.rel]) could ambiguously derive
from the same specified result type.
</li>
<li>
if any of the type traits (20.6.1 [meta.rqmts], 20.6.4 [meta.unary], 20.6.5 [meta.rel]) could derive from other
<tt>integral_constant</tt> types making the contained names ambiguous
</li>
<li>
if any of the type traits (20.6.1 [meta.rqmts], 20.6.4 [meta.unary], 20.6.5 [meta.rel]) could have other base
classes that contain members hiding the name of the result type members
or make the contained member names ambiguous.
</li>
</ul>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Alisdair would prefer to factor some of the repeated text,
but modulo a corner case or two,
he believes the proposed wording is otherwise substantially correct.
</p>
<p>
Move to Open.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p><i>[
The usage of the notion of a <i>BaseCharacteristic</i> below
might be
useful in other places - e.g. to define the base class relation in
20.7.5 [refwrap], 20.7.15 [func.memfn], or 20.7.16.2 [func.wrap.func].
In this case it's definition should probably
be moved to Clause 17
]</i></p>


<ol>
<li>
<p>
Change 20.6.1 [meta.rqmts]/1 as indicated:
</p>
<blockquote>
[..] It shall be <tt>DefaultConstructible</tt>, <tt>CopyConstructible</tt>, and publicly
<ins>and unambiguously</ins> derived, directly or indirectly, from
<ins>its <i>BaseCharacteristic</i>, which is</ins> a specialization of the
template <tt>integral_constant</tt> (20.6.3), with the arguments to the template
<tt>integral_constant</tt> determined by the requirements for the particular
property being described. <ins>The member names of the
<i>BaseCharacteristic</i> shall be unhidden and unambiguously
available in the <i>UnaryTypeTrait</i>.</ins>
</blockquote>
</li>
<li>
<p>
Change 20.6.1 [meta.rqmts]/2 as indicated:
</p>
<blockquote>
[..] It shall be <tt>DefaultConstructible</tt>, <tt>CopyConstructible</tt>, and publicly
<ins>and unambiguously</ins> derived, directly or indirectly, from
<del>an instance</del> <ins>its <i>BaseCharacteristic</i>, which is a
specialization</ins> of the template <tt>integral_constant</tt> (20.6.3), with
the arguments to the template <tt>integral_constant</tt> determined by the
requirements for the particular relationship being described. <ins>The
member names of the <i>BaseCharacteristic</i> shall be unhidden
and unambiguously available in the <i>BinaryTypeTrait</i>.</ins>
</blockquote>
</li>
<li>
<p>
Change 20.6.4 [meta.unary]/2 as indicated:
</p>
<blockquote>
Each of these templates shall be a <i>UnaryTypeTrait</i> (20.6.1),
<del>publicly derived directly or indirectly from <tt>true_type</tt> if the
corresponding condition is true, otherwise from <tt>false_type</tt></del>
<ins>where its <i>BaseCharacteristic</i> shall be <tt>true_type</tt> if the
corresponding condition is true, otherwise <tt>false_type</tt></ins>.
</blockquote>
</li>
<li>
<p>
Change 20.6.5 [meta.rel]/2 as indicated:
</p>

<blockquote>
Each of these templates shall be a <i>BinaryTypeTrait</i> (20.6.1),
<del>publicly derived directly or indirectly from <tt>true_type</tt> if the
corresponding condition is true, otherwise from <tt>false_type</tt></del>
<ins>where its <i>BaseCharacteristic</i> shall be <tt>true_type</tt> if the
corresponding condition is true, otherwise <tt>false_type</tt></ins>.
</blockquote>
</li>
</ol>






<hr>
<h3><a name="1115"></a>1115. <tt>va_copy</tt> missing from Standard macros table</h3>
<p><b>Section:</b> C.2 [diff.library] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Miles Zhao <b>Opened:</b> 2009-05-23  <b>Last modified:</b> 2009-05-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#diff.library">issues</a> in [diff.library].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In "Table 122 -- Standard macros" of C.2 [diff.library], which lists the 56 macros
inherited from C library, <tt>va_copy</tt> seems to be missing. But in
"Table 21 -- Header <tt>&lt;cstdarg&gt;</tt> synopsis" (18.10 [support.runtime]), there is.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add <tt>va_copy</tt> to Table 122 -- Standard macros in C.2 [diff.library].
</p>





<hr>
<h3><a name="1116"></a>1116. Literal constructors for tuple</h3>
<p><b>Section:</b> 20.5.2 [tuple.tuple] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-05-23  <b>Last modified:</b> 2009-05-24</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#tuple.tuple">active issues</a> in [tuple.tuple].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#tuple.tuple">issues</a> in [tuple.tuple].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It is not currently possible to construct <tt>tuple</tt> literal values,
even if the elements are all literal types.  This is because parameters
are passed to constructor by reference.
</p>
<p>
An alternative would be to pass all constructor arguments by value, where it
is known that *all* elements are literal types.  This can be determined with
concepts, although note that the negative constraint really requires
factoring out a separate concept, as there is no way to provide an 'any of
these fails' constraint inline.
</p>
<p>
Note that we will have similar issues with <tt>pair</tt> (and
<tt>tuple</tt> constructors from <tt>pair</tt>) although I am steering
clear of that class while other constructor-related issues settle.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Ammend the tuple class template declaration in 20.5.2 [tuple.tuple] as
follows
</p>

<blockquote>
<p>
Add the following concept:
</p>

<blockquote><pre>auto concept AllLiteral&lt; typename ... Types &gt; {
  requires LiteralType&lt;Types&gt;...;
}
</pre></blockquote>

<p>
ammend the constructor 
</p>

<blockquote><pre><ins>template &lt;class... UTypes&gt;
  requires AllLiteral&lt;Types...&gt;
        &amp;&amp; Constructible&lt;Types, UTypes&gt;...
  explicit tuple(UTypes...);</ins>

template &lt;class... UTypes&gt;
  requires <ins>!AllLiteral&lt;Types...&gt;</ins>
        <ins>&amp;&amp;</ins> Constructible&lt;Types, UTypes&amp;&amp;&gt;...
  explicit tuple(UTypes&amp;&amp;...);
</pre></blockquote>

<p>
ammend the constructor
</p>

<blockquote><pre><ins>template &lt;class... UTypes&gt;
  requires AllLiteral&lt;Types...&gt;
        &amp;&amp; Constructible&lt;Types, UTypes&gt;...
  tuple(tuple&lt;UTypes...&gt;);</ins>

template &lt;class... UTypes&gt;
  requires <ins>!AllLiteral&lt;Types...&gt;</ins>
        <ins>&amp;&amp;</ins> Constructible&lt;Types, const UTypes&amp;&gt;...
  tuple(const tuple&lt;UTypes...&gt;&amp;);
</pre></blockquote>

</blockquote>

<p>
Update the same signatures in 20.5.2.1 [tuple.cnstr], paras 3 and 5.
</p>





<hr>
<h3><a name="1117"></a>1117. tuple copy constructor</h3>
<p><b>Section:</b> 20.5.2.1 [tuple.cnstr] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-05-23  <b>Last modified:</b> 2009-05-30</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#tuple.cnstr">active issues</a> in [tuple.cnstr].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#tuple.cnstr">issues</a> in [tuple.cnstr].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The copy constructor for the <tt>tuple</tt> template is constrained.  This seems an
unusual strategy, as the copy constructor will be implicitly deleted if the
constraints are not met.  This is exactly the same effect as requesting an
<tt>=default;</tt> constructor.  The advantage of the latter is that it retains
triviality, and provides support for <tt>tuple</tt>s as literal types if issue
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1116">1116</a> is also accepted.
</p>
<p>
Actually, it might be worth checking with core if a constrained copy
constructor is treated as a constructor template, and as such does not
suppress the implicit generation of the copy constructor which would hide
the template in this case.
</p>

<p><i>[
2009-05-27 Daniel adds:
]</i></p>


<blockquote>
This would solve one half of the suggested changes in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#801">801</a>.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 20.5.2 [tuple.tuple] and 20.5.2.1 [tuple.cnstr] p4:
</p>

<blockquote><pre><del>requires CopyConstructible&lt;Types&gt;...</del> tuple(const tuple&amp;)<ins> = default</ins>;
</pre></blockquote>





<hr>
<h3><a name="1118"></a>1118. tuple query APIs do not support cv-qualification</h3>
<p><b>Section:</b> 20.5.2.3 [tuple.helper] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-05-23  <b>Last modified:</b> 2009-05-25</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#tuple.helper">active issues</a> in [tuple.helper].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#tuple.helper">issues</a> in [tuple.helper].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The APIs <tt>tuple_size</tt> and <tt>tuple_element</tt> do not support
cv-qualified <tt>tuple</tt>s, <tt>pair</tt>s or <tt>array</tt>s.
</p>
<p>
The most generic solution would be to supply partial specializations once
for each cv-type in the <tt>tuple</tt> header.  However, requiring this header for
cv-qualified <tt>pair</tt>s/<tt>array</tt>s seems unhelpful.  The BSI editorial
suggestion (UK-198/US-69,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2533.html">N2533</a>)
to merge <tt>tuple</tt> into <tt>&lt;utility&gt;</tt> would help with <tt>pair</tt>,
but not <tt>array</tt>.  That might be resolved by making a dependency between the
<tt>&lt;array&gt;</tt> header and <tt>&lt;utility&gt;</tt>, or simply recognising
the dependency be fulfilled in a Remark.
</p>

<p><i>[
2009-05-24 Daniel adds:
]</i></p>


<blockquote>
<p>
All <tt>tuple_size</tt> templates with a base class need to derive publicly, e.g.
</p>

<blockquote><pre>template &lt;IdentityOf T&gt; class tuple_size&lt; const T &gt; :
   <ins>public</ins> tuple_size&lt;T&gt; {};
</pre></blockquote>

<p>
The same applies to the tuple_element class hierarchies.
</p>
<p>
What is actually meant with the comment
</p>
<blockquote>
this solution relies on 'metafunction forwarding' to inherit the
nested typename type
</blockquote>
<p>
?
</p>
<p>
I ask, because all base classes are currently unconstrained and their
instantiation is invalid in the constrained context of the <tt>tuple_element</tt> partial
template specializations.
</p>
</blockquote>

<p><i>[
2009-05-24 Alisdair adds:
]</i></p>


<blockquote>
<p>
I think a better solution might be to ask Pete editorially to change all
declarations of tupling APIs to use the struct specifier instead of class.
</p>
<p>
"metafunction forwarding" refers to the MPL metafunction protocol, where a
metafunction result is declared as a nested typedef with the name "type",
allowing metafunctions to be chained by means of inheritance.  It is a
neater syntax than repeatedly declaring a typedef, and inheritance syntax is
slightly nicer when it comes to additional typename keywords.
</p>
<p>
The constrained template with an unconstrained base is a good observation
though.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add to 20.5.1 [tuple.general] p2 (Header <tt>&lt;tuple&gt;</tt> synopsis)
</p>

<blockquote><pre>// 20.5.2.3, tuple helper classes:
template &lt;IdentityOf T&gt; class tuple_size; // undefined
<ins>template &lt;IdentityOf T&gt; class tuple_size&lt; const T &gt; : tuple_size&lt;T&gt; {};</ins>
<ins>template &lt;IdentityOf T&gt; class tuple_size&lt; volatile T &gt; : tuple_size&lt;T&gt; {};</ins>
<ins>template &lt;IdentityOf T&gt; class tuple_size&lt; const volatile T &gt; : tuple_size&lt;T&gt; {};</ins>

template &lt;VariableType... Types&gt; class tuple_size&lt;tuple&lt;Types...&gt; &gt;;

template &lt;size_t I, IdentityOf T&gt; class tuple_element; // undefined
<ins>template &lt;size_t I, IdentityOf T&gt; class tuple_element&lt;I, const T&gt;;</ins>
<ins>template &lt;size_t I, IdentityOf T&gt; class tuple_element&lt;I, volatile T&gt;;</ins>
<ins>template &lt;size_t I, IdentityOf T&gt; class tuple_element&lt;I, const volatile T&gt;;</ins>

template &lt;size_t I, VariableType... Types&gt;
  requires True&lt;(I &lt; sizeof...(Types))&gt; class tuple_element&lt;I, tuple&lt;Types...&gt; &gt;;
</pre></blockquote>

<p>
Add to 20.5.2.3 [tuple.helper]
</p>
<p><i>[
(note that this solution relies on 'metafunction forwarding' to inherit the
nested typename type)
]</i></p>


<blockquote><pre>template &lt;class... Types&gt;
class tuple_size&lt;tuple&lt;Types...&gt; &gt;
  : public integral_constant&lt;size_t, sizeof...(Types)&gt; { };

template &lt;size_t I, class... Types&gt;
requires True&lt;(I &lt; sizeof...(Types))&gt;
class tuple_element&lt;I, tuple&lt;Types...&gt; &gt; {
public:
  typedef TI type;
};

<ins>template &lt;size_t I, IdentityOf T&gt;
  class tuple_element&lt;I, const T&gt; : add_const&lt;tuple_element&lt;I,T&gt;&gt; {};</ins>

<ins>template &lt;size_t I, IdentityOf T&gt;
  class tuple_element&lt;I, volatile T&gt; : add_volatile&lt;tuple_element&lt;I,T&gt;&gt; {};</ins>

<ins>template &lt;size_t I, IdentityOf T&gt;
  class tuple_element&lt;I, const volatile T&gt; : add_cv&lt;tuple_element&lt;I,T&gt;&gt; {};</ins>
</pre></blockquote>





<hr>
<h3><a name="1119"></a>1119. tuple query APIs do not support references</h3>
<p><b>Section:</b> 20.5.2.3 [tuple.helper] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-05-23  <b>Last modified:</b> 2009-05-24</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#tuple.helper">active issues</a> in [tuple.helper].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#tuple.helper">issues</a> in [tuple.helper].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <tt>tuple</tt> query APIs <tt>tuple_size</tt> and
<tt>tuple_element</tt> do not support references-to-tuples.  This can be
annoying when a template deduced a parameter type to be a reference,
which must be explicitly stripped with <tt>remove_reference</tt> before calling
these APIs.
</p>
<p>
I am not proposing a resolution at this point, as there is a
combinatorial explosion with lvalue/rvalue references and
cv-qualification (see previous issue) that suggests some higher
refactoring is in order.  This might be something to kick back over to
Core/Evolution.
</p>
<p>
Note that we have the same problem in numeric_limits.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1120"></a>1120. New type trait - remove_all</h3>
<p><b>Section:</b> 20.6 [meta] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-05-23  <b>Last modified:</b> 2009-05-24</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#meta">active issues</a> in [meta].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#meta">issues</a> in [meta].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Sometimes it is necessary to remove all qualifiers from a type before
passing on to a further API.  A good example would be calling the
<tt>tuple</tt> query APIs <tt>tuple_size</tt> or <tt>tuple_element</tt>
with a deduced type inside a function template.  If the deduced type is
cv-qualified or a reference then the call will fail.  The solution is to
chain calls to
<tt>remove_cv&lt;remove_reference&lt;T&gt;::type&gt;::type</tt>, and
note that the order matters.
</p>
<p>
Suggest it would be helpful to add a new type trait,
<tt>remove_all</tt>, that removes all top-level qualifiers from a type
i.e. cv-qualification and any references.  Define the term in such a way
that if additional qualifiers are added to the language, then
<tt>remove_all</tt> is defined as stripping those as well.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1121"></a>1121. Support for multiple arguments</h3>
<p><b>Section:</b> 20.4.2 [ratio.arithmetic] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-05-25  <b>Last modified:</b> 2009-05-25</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#ratio.arithmetic">active issues</a> in [ratio.arithmetic].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#ratio.arithmetic">issues</a> in [ratio.arithmetic].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Both add and multiply could sensibly be called with more than two arguments.
The variadic template facility makes such declarations simple, and is likely
to be frequently wrapped by end users if we do not supply the variant
ourselves.
</p>
<p>
We deliberately ignore divide at this point as it is not transitive.
Likewise, subtract places special meaning on the first argument so I do not
suggest extending that immediately.  Both could be supported with analogous
wording to that for add/multiply below.
</p>
<p>
Note that the proposed resolution is potentially incompatible with that
proposed for <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#921">921</a>, although the addition of the typedef to ratio would be
equally useful.
</p>


<p><b>Proposed resolution:</b></p>
<p><i>[
note that this wording relies on 'metafunction forwarding' as described by
Boost MPL
]</i></p>


<p>
20.4 [ratio] p3 synopsis: change
</p>

<blockquote><pre>// ratio arithmetic
template &lt;class R1, class R2<ins>, class ... RList</ins>&gt; struct ratio_add;
template &lt;class R1, class R2&gt; struct ratio_subtract;
template &lt;class R1, class R2<ins>, class ... RList</ins>&gt; struct ratio_multiply;
template &lt;class R1, class R2&gt; struct ratio_divide;
</pre></blockquote>

<p>
20.4.2 [ratio.arithmetic] p1: change
</p>

<blockquote><pre><ins>template &lt;class R1, class R2, class ... RList&gt; struct ratio_add
  : ratio_add&lt; R1, ratio_add&lt;R2, RList...&gt;&gt; {
};</ins>

template &lt;class R1, class R2&gt; struct ratio_add<ins>&lt;R1, R2&gt;</ins> {
  typedef <i>see below</i> type;
};
</pre></blockquote>


<p>
20.4.2 [ratio.arithmetic] p3: change
</p>

<blockquote><pre><ins>template &lt;class R1, class R2, class ... RList&gt; struct ratio_multiply
  : ratio_multiply&lt; R1, ratio_ multiply &lt;R2, RList...&gt;&gt; {
};</ins>

template &lt;class R1, class R2&gt; struct ratio_ multiply<ins>&lt;R1, R2&gt;</ins> {
  typedef <i>see below</i> type;
};
</pre></blockquote>






<hr>
<h3><a name="1122"></a>1122. Ratio values should be constexpr</h3>
<p><b>Section:</b> 20.4.1 [ratio.ratio] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-05-25  <b>Last modified:</b> 2009-05-25</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#ratio.ratio">active issues</a> in [ratio.ratio].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#ratio.ratio">issues</a> in [ratio.ratio].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The values <tt>num</tt> and <tt>den</tt> in the <tt>ratio</tt> template
should be declared <tt>constexpr</tt>.
</p>


<p><b>Proposed resolution:</b></p>
<p>
20.4.1 [ratio.ratio]
</p>

<blockquote><pre>namespace std {
  template &lt;intmax_t N, intmax_t D = 1&gt;
  class ratio {
  public:
    static const<ins>expr</ins> intmax_t num;
    static const<ins>expr</ins> intmax_t den;
  };
}
</pre></blockquote>






<hr>
<h3><a name="1123"></a>1123. no requirement that standard streams be flushed</h3>
<p><b>Section:</b> 27.5.2.1.6 [ios::Init] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> James Kanze <b>Opened:</b> 2009-05-14  <b>Last modified:</b> 2009-05-30</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#ios::Init">active issues</a> in [ios::Init].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#ios::Init">issues</a> in [ios::Init].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
As currently formulated, the standard doesn't require that there 
is ever a flush of <tt>cout</tt>, etc.  (This implies, for example, that 
the classical hello, world program may have no output.)  In the 
current draft
(<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2798.pdf">N2798</a>),
there is a requirement that the objects 
be constructed before <tt>main</tt>, and before the dynamic 
initialization of any non-local objects defined after the 
inclusion of <tt>&lt;iostream&gt;</tt> in the same translation unit.  The only 
requirement that I can find concerning flushing, however, is in 
27.5.2.1.6 [ios::Init], where the destructor of the last 
<tt>std::ios_base::Init</tt> object flushes.  But there is, as far as I 
can see, no guarantee that such an object ever exists. 
</p>
<p>
Also, the wording in  [iostreams.objects] says that:
</p>
<blockquote>
The objects 
are constructed and the associations are established at some 
time prior to or during the first time an object of class 
<tt>ios_base::Init</tt> is constructed, and in any case before the body 
of main begins execution.
</blockquote>
<p>
In 27.5.2.1.6 [ios::Init], however, as an 
effect of the constructor, it says that
</p>
<blockquote>
If <tt>init_cnt</tt> is zero, 
the function stores the value one in <tt>init_cnt</tt>, then constructs 
and initializes the objects <tt>cin</tt>, <tt>cout</tt>, <tt>cerr</tt>, <tt>clog</tt> 
<tt>wcin</tt>, <tt>wcout</tt>, <tt>wcerr</tt>, and <tt>wclog</tt>"
</blockquote>

<p>
which seems to forbid earlier 
construction. 
</p>

<p>
(Note that with these changes, the exposition only "<tt>static 
int init_cnt</tt>" in <tt>ios_base::Init</tt> can be dropped.) 
</p>
<p>
Of course, a determined programmer can still inhibit the 
flush with things like: 
</p>
<blockquote><pre>new std::ios_base::Init ;       //  never deleted 
</pre></blockquote>
<p>
or (in a function): 
</p>
<blockquote><pre>std::ios_base::Init ensureConstruction ; 
//  ... 
exit( EXIT_SUCCESS ) ; 
</pre></blockquote>
<p>
Perhaps some words somewhere to the effect that all 
<tt>std::ios_base::Init</tt> objects should have static lifetime 
would be in order. 
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change 27.4 [iostream.objects]/2:
</p>

<blockquote>
-2- The objects are constructed and the associations are established at
some time prior to or during the first time an object of class
<tt>ios_base::Init</tt> is constructed, and in any case before the body
of main begins execution.<sup>292</sup> The objects are not destroyed
during program execution.<sup>293</sup>
<del>If a translation unit includes
<tt>&lt;iostream&gt;</tt> or explicitly constructs an
<tt>ios_base::Init</tt> object, these stream objects shall be
constructed before dynamic initialization of non-local objects defined
later in that translation unit.</del>
<ins>The results of including <tt>&lt;iostream&gt;</tt> in a translation
unit shall be as if <tt>&lt;iostream&gt;</tt> defined an instance of
<tt>ios_base::Init</tt> with static lifetime. Similarly, the entire
program shall behave as if there were at least one instance of
<tt>ios_base::Init</tt> with static lifetime.</ins>
</blockquote>

<p>
Change 27.5.2.1.6 [ios::Init]/3:
</p>

<blockquote>
<pre>Init();
</pre>
<blockquote>
-3- <i>Effects:</i> Constructs an object of class <tt>Init</tt>. 
<del>If <tt>init_cnt</tt> is zero, the function stores the value one in
<tt>init_cnt</tt>, then constructs and initializes the objects
<tt>cin</tt>, <tt>cout</tt>, <tt>cerr</tt>, <tt>clog</tt> (27.4.1),
<tt>wcin</tt>, <tt>wcout</tt>, <tt>wcerr</tt>, and <tt>wclog</tt>
(27.4.2). In any case, the function then adds one to the value stored in
<tt>init_cnt</tt>.</del>
<ins>Constructs and initializes the objects <tt>cin</tt>, <tt>cout</tt>,
<tt>cerr</tt>, <tt>clog</tt>, <tt>wcin</tt>, <tt>wcout</tt>,
<tt>wcerr</tt> and <tt>wclog</tt> if they have not already been
constructed and initialized.</ins>
</blockquote>
</blockquote>

<p>
Change 27.5.2.1.6 [ios::Init]/4:
</p>

<blockquote>
<pre>~Init();
</pre>
<blockquote>
-4- <i>Effects:</i> Destroys an object of class <tt>Init</tt>.
<del>The function subtracts one from the value stored in <tt>init_cnt</tt> and,
if the resulting stored value is one,</del>
<ins>If there are no other instances of the class still in
existance,</ins>
calls <tt>cout.flush()</tt>,
<tt>cerr.flush()</tt>, <tt>clog.flush()</tt>, <tt>wcout.flush()</tt>,
<tt>wcerr.flush()</tt>, <tt>wclog.flush()</tt>.
</blockquote>
</blockquote>






<hr>
<h3><a name="1124"></a>1124.  Invalid definition of concept RvalueOf</h3>
<p><b>Section:</b> 20.2.1 [concept.transform] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2009-05-28  <b>Last modified:</b> 2009-05-30</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#concept.transform">active issues</a> in [concept.transform].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#concept.transform">issues</a> in [concept.transform].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
A recent news group
<a href="http://groups.google.de/group/comp.std.c++/browse_frm/thread/8eb92768a19fb46f">article</a>
points to several defects in the
specification of reference-related concepts.
</p>
<p>
One problem of the concept <tt>RvalueOf</tt> as currently defined in
20.2.1 [concept.transform]:
</p>

<blockquote><pre>concept RvalueOf&lt;typename T&gt; {
 typename type = T&amp;&amp;;
 requires ExplicitlyConvertible&lt;T&amp;,type&gt; &amp;&amp; Convertible&lt;T&amp;&amp;,type&gt;;
}

template&lt;typename T&gt; concept_map RvalueOf&lt;T&amp;&gt; {
 typedef T&amp;&amp; type;
}
</pre></blockquote>

<p>
is that if <tt>T</tt> is an lvalue-reference, the requirement
<tt>Convertible&lt;T&amp;&amp;,type&gt;</tt> isn't satisfied for
lvalue-references, because after reference-collapsing in the concept
definition we have <tt>Convertible&lt;T&amp;,type&gt;</tt> in this case,
which isn't satisfied in the concept map template and also is not the
right constraint either. I think that the reporter is right that
<tt>SameType</tt> requirements should do the job and that we also should
use the new <tt>RvalueReference</tt> concept to specify a best matching
type requirement.
</p>


<p><b>Proposed resolution:</b></p>
<p>
In 20.2.1 [concept.transform] before p. 4 change as indicated:
</p>

<blockquote><pre>auto concept RvalueOf&lt;typename T&gt; {
  <del>typename</del><ins>RvalueReference</ins> type = T&amp;&amp;;
  requires <del>ExplicitlyConvertible&lt;T&amp;, type&gt; &amp;&amp; Convertible&lt;T&amp;&amp;, type&gt;</del><ins>SameType&lt;T&amp;, type&amp;&gt;</ins>;
}
</pre></blockquote>





<hr>
<h3><a name="1125"></a>1125. ostream_iterator does not work with movable types</h3>
<p><b>Section:</b> 24.6.2.2 [ostream.iterator.ops] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-05-28  <b>Last modified:</b> 2009-05-30</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>ostream_iterator</tt> has not been updated to support moveable types, in a
similar manner to the insert iterators.
Note that this is not a problem for <tt>ostreambuf_iterator</tt>, as the types it is
restricted to dealing with do not support extra-efficient moving.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add second <tt>operator=</tt> overload to class <tt>template ostream_iterator</tt>
in 24.6.2 [ostream.iterator], para 2:
</p>

<blockquote><pre>ostream_iterator&lt;T,charT,traits&gt;&amp; operator=(const T&amp; value);
<ins>ostream_iterator&lt;T,charT,traits&gt;&amp; operator=(T&amp;&amp; value);</ins>
</pre></blockquote>

<p>
Add a new paragraph: in 24.6.2.2 [ostream.iterator.ops]:
</p>

<blockquote>
<pre>ostream_iterator&amp; operator=(T&amp;&amp; value);
</pre>
<blockquote>
<p>
-2- <i>Effects:</i>
</p>
<blockquote><pre>*out_stream &lt;&lt; std::move(value);
if(delim != 0)
  *out_stream &lt;&lt; delim;
return (*this);
</pre></blockquote>
</blockquote>
</blockquote>






<hr>
<h3><a name="1126"></a>1126. <tt>istreambuff_iterator::equal</tt> needs a const &amp; parameter</h3>
<p><b>Section:</b> 24.6.3.5 [istreambuf.iterator::equal] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-05-28  <b>Last modified:</b> 2009-05-30</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#istreambuf.iterator::equal">active issues</a> in [istreambuf.iterator::equal].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#istreambuf.iterator::equal">issues</a> in [istreambuf.iterator::equal].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <tt>equal</tt> member function of <tt>istreambuf_iterator</tt> is
declared <tt>const</tt>, but takes its argument by non-const reference.
</p>
<p>
This is not compatible with the <tt>operator==</tt> free function overload, which is
defined in terms of calling <tt>equal</tt> yet takes both arguments by reference to
const.
</p>

<p><i>[
The proposed wording is consistent with <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#110">110</a> with status TC1.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
Ammend in both:<br>
24.6.3 [istreambuf.iterator]<br>
24.6.3.5 [istreambuf.iterator::equal]<br>
</p>

<blockquote><pre>bool equal(<ins>const </ins>istreambuf_iterator&amp; b) const;
</pre></blockquote>






<hr>
<h3><a name="1127"></a>1127. rvalue references and iterator traits</h3>
<p><b>Section:</b> D.10.1 [iterator.traits] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-05-28  <b>Last modified:</b> 2009-05-30</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#iterator.traits">issues</a> in [iterator.traits].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The deprecated support for <tt>iterator_traits</tt> and legacy (unconstrained)
iterators features the (exposition only) concept:
</p>

<blockquote><pre>concept IsReference&lt;typename T&gt; { } // exposition only
template&lt;typename T&gt; concept_map IsReference&lt;T&amp;&gt; { }
</pre></blockquote>
<p>
Now this looks exactly like the <tt>LvalueReference</tt> concept recently added to
clause 20, so I wonder if we should use that instead?
Then I consider the lack of rvalue-reference support, which means that
<tt>move_iterator</tt> would always flag as merely supporting the <tt>input_iterator_tag</tt>
category.  This suggests we retain the exposition concept, but add a second
concept_map to support rvalue references.
</p>
<p>
I would suggest adding the extra concept_map is the right way forward, but
still wonder if the two exposition-only concepts in this clause might be
worth promoting to clause 20.  That question might better be answered with a
fuller investigation of type_trait/concept unification though.
</p>


<p><b>Proposed resolution:</b></p>
<p>
In Iterator traits D.10.1 [iterator.traits] para 4 add:
</p>

<blockquote><pre>concept IsReference&lt;typename T&gt; { } // exposition only
template&lt;typename T&gt; concept_map IsReference&lt;T&amp;&gt; { }
<ins>template&lt;typename T&gt; concept_map IsReference&lt;T&amp;&amp;&gt; { }</ins>
</pre></blockquote>






<hr>
<h3><a name="1128"></a>1128. Missing definition of <tt>iterator_traits&lt;T*&gt;</tt></h3>
<p><b>Section:</b> 24.3 [iterator.syn] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-05-28  <b>Last modified:</b> 2009-05-30</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <tt>&lt;iterator&gt;</tt> header synopsis declares a partial specialization of
<tt>iterator_traits</tt> to support pointers, 24.3 [iterator.syn].  The implication
is that specialization will be described in D10, yet it did not follow the
rest of the deprecated material into this clause.
</p>
<p>
However, this is not as bad as it first seems!
There are partial specializations of <tt>iterator_traits</tt> for types that satisfy
the various Iterator concepts, and there are concept_maps for pointers to
explicitly support the <tt>RandomAccessIterator</tt> concept, so the required
template will be present - just not in the manner advertised.
</p>
<p>
I can see two obvious solutions:
</p>

<ol type="i">
<li>
Restore the <tt>iterator_traits&lt;T*&gt;</tt> partial specialization in D.10
</li>
<li>
Remove the declaration of <tt>iterator_traits&lt;T*&gt;</tt> from 24.3 synopsis
</li>
</ol>
<p>
I recommend option (ii) in the wording below
</p>
<p>
Option (ii) could be extended to strike all the declarations of deprecated
material from the synopsis, as it is effectively duplicating D.10 anyway.
This is the approach taken for deprecated library components in the 98/03
standards.  This is probably a matter best left to the Editor though.
</p>


<p><b>Proposed resolution:</b></p>
<p>
In 24.3 [iterator.syn] strike:
</p>

<blockquote><pre><del>template&lt;class T&gt; struct iterator_traits&lt;T*&gt;;</del>
</pre></blockquote>






<hr>
<h3><a name="1129"></a>1129. <tt>istream(buf)_iterator</tt> should support literal sentinel value</h3>
<p><b>Section:</b> 24.6.1.1 [istream.iterator.cons], 24.6.3 [istreambuf.iterator] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-05-30  <b>Last modified:</b> 2009-06-09</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>istream_iterator</tt> and <tt>istreambuf_iterator</tt> should support literal sentinel
values.  The default constructor is frequently used to terminate ranges, and
could easily be a literal value for <tt>istreambuf_iterator</tt>, and
<tt>istream_iterator</tt> when iterating value types.  A little more work using a
suitably sized/aligned char-array for storage (or an updated component like
<tt>boost::optional</tt> proposed for TR2) would allow <tt>istream_iterator</tt> to support
<tt>constexpr</tt> default constructor in all cases, although we might leave this
tweak as a QoI issue.  Note that requiring <tt>constexpr</tt> be supported also
allows us to place no-throw guarantees on this constructor too.
</p>

<p><i>[
2009-06-02 Daniel adds:
]</i></p>


<blockquote>
<p>
I agree with the usefulness of the issue suggestion, but we need
to ensure that <tt>istream_iterator</tt> <em>can</em> satisfy be literal if needed.
Currently this is not clear, because 24.6.1 [istream.iterator]/3 declares
a copy constructor and a destructor and explains their semantic in
24.6.1.1 [istream.iterator.cons]/3+4.
</p>
<p>
The prototype semantic specification is ok (although it seems
somewhat redundant to me, because the semantic doesn't say
anything interesting in both cases), but for support of trivial class
types we also need a trivial copy constructor and destructor as of
9 [class]/6. The current non-informative specification of these
two special members suggests to remove their explicit declaration
in the class and add explicit wording that says that if <tt>T</tt> is
trivial a default constructed iterator is also literal, alternatively it
would be possible to mark both as defaulted and add explicit
(memberwise) wording that guarantees that they are trivial.
</p>
<p>
Btw.: I'm quite sure that the <tt>istreambuf_iterator</tt> additions to
ensure triviality are not sufficient as suggested, because the
library does not yet give general guarantees that a defaulted
special member declaration makes this member also trivial.
Note that e.g. the atomic types do give a general statement!
</p>
<p>
Finally there is a wording issue: There does not exist something
like a "literal constructor". The core language uses the term
"constexpr constructor" for this.
</p>
<p>
Suggestion:
</p>
<ol>
<li>
<p>
Change 24.6.1 [istream.iterator]/3 as indicated:
</p>
<blockquote><pre><ins>constexpr</ins> istream_iterator();
istream_iterator(istream_type&amp; s);
istream_iterator(const istream_iterator<del>&lt;T,charT,traits,Distance&gt;</del>&amp; x)<ins> = default</ins>;
~istream_iterator()<ins> = default</ins>;
</pre></blockquote>
</li>
<li>
<p>
Change 24.6.1.1 [istream.iterator.cons]/1 as indicated:
</p>
<blockquote><pre><ins>constexpr</ins> istream_iterator();
</pre>
<blockquote>
-1- <i>Effects:</i> Constructs the end-of-stream iterator. <ins>If <tt>T</tt> is a literal type,
then this constructor shall be a constexpr constructor.</ins>
</blockquote>
</blockquote>
</li>
<li>
<p>
Change 24.6.1.1 [istream.iterator.cons]/3 as indicated:
</p>
<blockquote><pre>istream_iterator(const istream_iterator<del>&lt;T,charT,traits,Distance&gt;</del>&amp; x)<ins> = default</ins>;
</pre>
<blockquote>
-3- <i>Effects:</i> Constructs a copy of <tt>x</tt>. <ins>If <tt>T</tt> is a literal type, then
this constructor shall be a trivial copy constructor.</ins>
</blockquote>
</blockquote>
</li>
<li>
<p>
Change 24.6.1.1 [istream.iterator.cons]/4 as indicated:
</p>

<blockquote><pre>~istream_iterator()<ins> = default</ins>;
</pre>
<blockquote>
-4- <i>Effects:</i> The iterator is destroyed. <ins>If <tt>T</tt> is a literal type, then
this destructor shall be a trivial
destructor.</ins>
</blockquote>
</blockquote>
</li>
<li>
<p>
Change 24.6.3 [istreambuf.iterator] before p. 1 as indicated:
</p>

<blockquote><pre><ins>constexpr</ins> istreambuf_iterator() throw();
<ins>istreambuf_iterator(const istreambuf_iterator&amp;)  throw() = default;</ins>
<ins>~istreambuf_iterator()  throw() = default;</ins>
</pre></blockquote>
</li>
<li>
<p>
Change 24.6.3 [istreambuf.iterator]/1 as indicated:
</p>
<blockquote>
[..] The default constructor <tt>istreambuf_iterator()</tt> and the constructor
<tt>istreambuf_iterator(0)</tt> both
construct an end of stream iterator object suitable for use as an
end-of-range. <ins>All
specializations of <tt>istreambuf_iterator</tt> shall have a trivial copy
constructor, a constexpr default
constructor and a trivial destructor.</ins>
</blockquote>
</li>
</ol>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
24.6.1 [istream.iterator] para 3
</p>

<blockquote><pre><ins>constexpr</ins> istream_iterator();
</pre></blockquote>

<p>
24.6.1.1 [istream.iterator.cons]
</p>

<blockquote><pre><ins>constexpr</ins> istream_iterator();
</pre>
<blockquote>
-1- <i>Effects:</i> Constructs the end-of-stream iterator.
<ins>If <tt>T</tt> is a literal type, then this constructor shall
be a literal constructor.</ins>
</blockquote>
</blockquote>

<p>
24.6.3 [istreambuf.iterator]
</p>

<blockquote><pre><ins>constexpr</ins> istreambuf_iterator() throw();
</pre></blockquote>






<hr>
<h3><a name="1130"></a>1130. <tt>copy_exception</tt> name misleading</h3>
<p><b>Section:</b> 18.8.5 [propagation] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Peter Dimov <b>Opened:</b> 2009-05-13  <b>Last modified:</b> 2009-06-02</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#propagation">active issues</a> in [propagation].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#propagation">issues</a> in [propagation].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The naming of <tt>std::copy_exception</tt> misleads almost everyone
(experts included!) to think that it is the function that copies an
<tt>exception_ptr</tt>:
</p>

<blockquote><pre>exception_ptr p1 = current_exception();
exception_ptr p2 = copy_exception( p1 );
</pre></blockquote>

<p>
But this is not at all what it does. The above actually creates an
<tt>exception_ptr p2</tt> that contains a copy of <tt>p1</tt>, not of
the exception to which <tt>p1</tt> refers!
</p>
<p>
This is, of course, all my fault; in my defence, I used <tt>copy_exception</tt>
because I was unable to think of a better name.
</p>
<p>
But I believe that, based on what we've seen so far, <em>any</em> other name would be better.
</p>
<p>
Therefore, I propose <tt>copy_exception</tt> to be renamed to
<tt>create_exception</tt>:
</p>

<blockquote><pre>template&lt;class E&gt; exception_ptr create_exception(E e);
</pre></blockquote>

<p>
with the following explanatory paragraph after it:
</p>

<blockquote>
Creates an <tt>exception_ptr</tt> that refers to a copy of <tt>e</tt>.
</blockquote>

<p><i>[
2009-05-13 Daniel adds:
]</i></p>


<blockquote>
<p>
What about
</p>
<blockquote><pre>make_exception_ptr
</pre></blockquote>
<p>
in similarity to <tt>make_pair</tt> and <tt>make_tuple</tt>, <tt>make_error_code</tt> and
<tt>make_error_condition</tt>, or <tt>make_shared</tt>? Or, if a stronger symmetry to
<tt>current_exception</tt> is preferred:
</p>

<blockquote><pre>make_exception
</pre></blockquote>
<p>
We have not a single <tt>create_*</tt> function in the library, it was always
<tt>make_*</tt> used.
</p>
</blockquote>

<p><i>[
2009-05-13 Peter adds:
]</i></p>


<blockquote>
<tt>make_exception_ptr</tt> works for me.
</blockquote>

<p><i>[
2009-06-02 Thomas J. Gritzan adds:
]</i></p>


<blockquote>
<p>
To avoid surprises and unwanted recursion, how about making a call to
<tt>std::make_exception_ptr</tt> with an <tt>exception_ptr</tt> illegal?
</p>
<p>
It might work like this:
</p>
<blockquote><pre>template&lt;class E&gt;
exception_ptr make_exception_ptr(E e);
template&lt;&gt;
exception_ptr make_exception_ptr&lt;exception_ptr&gt;(exception_ptr e) = delete;
</pre></blockquote>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 18.8.5 [propagation]:
</p>

<blockquote>
<pre>template&lt;class E&gt; exception_ptr <del>copy_exception</del><ins>make_exception_ptr</ins>(E e);
</pre>

<blockquote>
<p>
-11- <i>Effects:</i> <ins>Creates an <tt>exception_ptr</tt> that refers
to a copy of <tt>e</tt>,</ins> as if
</p>

<blockquote><pre>try {
  throw e;
} catch(...) {
  return current_exception();
}
</pre></blockquote>

<p>...</p>
</blockquote>

</blockquote>






<hr>
<h3><a name="1131"></a>1131. C++0x does not need <tt>alignment_of</tt></h3>
<p><b>Section:</b> 20.6.4.3 [meta.unary.prop] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Niels Dekker <b>Opened:</b> 2009-06-01  <b>Last modified:</b> 2009-06-02</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#meta.unary.prop">active issues</a> in [meta.unary.prop].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#meta.unary.prop">issues</a> in [meta.unary.prop].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <tt>alignment_of</tt> template is no longer necessary, now that the
core language will provide <tt>alignof</tt>. Scott Meyers raised this
issue at comp.std.c++,
<a href="http://groups.google.com/group/comp.std.c++/browse_thread/thread/9b020306e803f08a">C++0x: alignof vs. alignment_of</a>,
May 21, 2009.  In a reply, Daniel Krgler pointed out that
<tt>alignof</tt> was added to the working paper <i>after</i>
<tt>alignment_of</tt>. So it appears that <tt>alignment_of</tt> is only
part of the current Working Draft 
(<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2857.pdf">N2857</a>)
because it is in TR1.
</p>
<p>
Having both <tt>alignof</tt> and <tt>alignment_of</tt> would cause
unwanted confusion. In general, I think TR1 functionality should not be
brought into C++0x if it is entirely redundant with other C++0x language
or library features.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Remove from Header &lt;type_traits&gt; synopsis 20.6.2 [meta.type.synop]:
</p>
<blockquote><pre><del>template &lt;class T&gt; struct alignment_of;</del>
</pre></blockquote>

<p>
Remove the first row of Table 34 ("Type property queries"), from
Type properties 20.6.4.3 [meta.unary.prop]:
</p>
<blockquote>
<table border="1">
<caption>Table 34 -- Type property queries</caption>
<tbody><tr>
<td><del><tt>template &lt;class T&gt; struct alignment_of;</tt></del></td>
<td><del><tt>alignof(T)</tt>.</del><br>
<del><i>Precondition:</i> <tt>T</tt> shall be a complete type, a reference
type, or an array of unknown bound, but shall not be a function type or
(possibly cv-qualified) <tt>void</tt>.</del>
</td>
</tr>
</tbody></table>
</blockquote>

<p>
Change text in Table 41 ("Other transformations"), from Other
transformations 20.6.7 [meta.trans.other], as follows:
</p>
<blockquote>
<table border="1">
<caption>Table 41 -- Other transformations</caption>
<tbody><tr><td>...</td>
<td>
 Align shall be equal to <tt>
 <del>alignment_of&lt;T&gt;::value</del>
 <ins>alignof(T)</ins>
 </tt> for some type <tt>T</tt> or to <i>default-alignment</i>.
</td>
<td>...</td>
</tr></tbody></table>
</blockquote>





<hr>
<h3><a name="1132"></a>1132. JP-30: nested exceptions</h3>
<p><b>Section:</b> 18.8.6 [except.nested] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Seiji Hayashida <b>Opened:</b> 2009-06-01  <b>Last modified:</b> 2009-06-02</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#except.nested">active issues</a> in [except.nested].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#except.nested">issues</a> in [except.nested].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses JP 30</b></p>

<p>
C++0x <tt>nested_exception</tt> cannot handle a structured exception well. The
following codes show two types of tree structured exception handling.
</p>
<p>
The first one is based on <tt>nested_exception</tt> in C++0x,
while the second one is based on my library <tt>trickerr.h</tt> (in Japanese).
<a href="http://tricklib.com/cxx/dagger/trickerr.h">http://tricklib.com/cxx/dagger/trickerr.h</a>
</p>
<p>
Assume that Function <tt>A()</tt> calls two sub functions <tt>A_a()</tt> and <tt>A_b()</tt>, both might
throw tree structured exceptions, and <tt>A_b()</tt> must be called even if <tt>A_a()</tt>
throws an exception.
</p>
<p>
List A (code of tree structured exception handling based on nested_exception
in C++0x)
</p>

<blockquote><pre>void A()
{
    try
    {
        std::vector&lt;exception_ptr&gt; exception_list;
        try
        {
            // A_a() does a similar processing as A().
            A_a();
        }
        catch(...)
        {
            exception_list.push_back(current_exception());
        }

        // ***The processing A() has to do even when A_a() fails. ***
        try
        {
            // A_b() does a similar processing as A().
            A_b();
        }
        catch(...)
        {
            exception_list.push_back(current_exception());
        }
        if (!exception_list.empty())
        {
            throw exception_list;
        }
    }
    catch(...)
    {
        throw_with_nested(A_exception("someone error"));
    }
}
void print_tree_exception(exception_ptr e, const std::string &amp; indent ="")
{
    const char * indent_unit = " ";
    const char * mark = "- ";
    try
    {
        rethow_exception(e);
    }
    catch(const std::vector&lt;exception_ptr&gt; e)
    {
        for(std::vector&lt;exception_ptr&gt;::const_iterator i = e.begin(); i!=e.end(); ++i)
        {
            print_tree_exception(i, indent);
        }
    }
    catch(const std::nested_exception  e)
    {
        print_tree_exception(evil_i(e), indent +indent_unit);
    }
    catch(const std::exception e)
    {
        std::cout &lt;&lt; indent &lt;&lt; mark &lt;&lt; e.what() &lt;&lt; std::endl;
    }
    catch(...)
    {
        std::cout &lt;&lt; indent &lt;&lt; mark &lt;&lt; "unknown exception" &lt;&lt; std::endl;
    }
}
int main(int, char * [])
{
    try
    {
        A();
    }
    catch()
    {
        print_tree_exception(current_exception());
    }
    return EXIT_SUCCESS;
}
</pre></blockquote>

<p>
List B ( code of tree structured exception handling based on <tt>trickerr.h</tt>. )
"trickerr.h" (in Japanese), refer to:
<a href="http://tricklib.com/cxx/dagger/trickerr.h">http://tricklib.com/cxx/dagger/trickerr.h</a>.
</p>

<blockquote><pre>void A()
{
    tricklib::error_listener_type error_listener;
    // A_a() is like A(). A_a() can throw tree structured exception.
    A_a();

    // *** It must do process so that A_a() throws exception in A(). ***
    // A_b() is like A(). A_b() can throw tree structured exception.
    A_b();

    if (error_listener.has_error()) // You can write this "if block" in destructor
                                    //  of class derived from error_listener_type.
    {
        throw_error(new A_error("someone error",error_listener.listener_off().extract_pending_error()));
    }
}
void print_tree_error(const tricklib::error_type &amp;a_error, const std::string &amp; indent = "")
{
    const char * indent_unit = " ";
    const char * mark = "- ";

    tricklib::error_type error = a_error;
    while(error)
    {
        std::cout &lt;&lt; indent &lt;&lt; mark &lt;&lt; error-&gt;message &lt;&lt; std::endl;
        if (error-&gt;children)
        {
            print_tree_error(error-&gt;children, indent +indent_unit);
        }
        error = error-&gt;next;
    }
}
int main(int, char * [])
{
    tricklib::error_thread_power error_thread_power_on; // This object is necessary per thread.

    try
    {
        A();
    }
    catch(error_type error)
    {
        print_tree_error(error);
    }
    catch(...)
    {
        std::cout &lt;&lt; "- unknown exception" &lt;&lt; std::endl;
    }
    return EXIT_SUCCESS;
}
</pre></blockquote>

<p>
Prospect
</p>
<p>
We will focus on the method A() since the other methods, also main(), occur
only once respectively.
</p>

<ul>
<li>
 In the List A above (of the nested exception handling), it is hard to
 find out an active reason to use the nested exception handling at this
 scene. Rather, we can take a simpler description by throwing the entire
 exception_list directly to the top level.
</li>
<li>
 The code in the same example gives us a kind of redundant impression,
 which might have come from the fact that the try-throw-catch framework does
 not assume a tree structured exception handling.
</li>
</ul>

<p>
According to the above observation, we cannot help concluding that it is not
so easy to use the nested_exception handling as a tree structured exception
handling mechanism in a practical sense.
</p>
<p>
This text is based on the web page below (in Japanese).
<a href="http://d.hatena.ne.jp/wraith13/20081231/1230715424">http://d.hatena.ne.jp/wraith13/20081231/1230715424</a>
</p>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="1133"></a>1133. Does N2844 break current specification of list::splice?</h3>
<p><b>Section:</b> 23.3.3.5 [forwardlist.ops], 23.3.4.4 [list.ops] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-05-09  <b>Last modified:</b> 2009-06-09</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#forwardlist.ops">active issues</a> in [forwardlist.ops].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#forwardlist.ops">issues</a> in [forwardlist.ops].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
IIUC,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2844.html">N2844</a>
means that lvalues will no longer bind to rvalue references.
Therefore, the current specification of <tt>list::splice</tt> (list
operations 23.3.4.4 [list.ops]) will be a breaking change of behaviour for existing
programs.  That is because we changed the signature to swallow via an rvalue
reference rather than the lvalue reference used in 03.
</p>
<p>
Retaining this form would be safer, requiring an explicit move when splicing
from lvalues.  However, this will break existing programs.
We have the same problem with <tt>forward_list</tt>, although without the risk of
breaking programs so here it might be viewed as a positive feature.
</p>
<p>
The problem signatures:
</p>
<blockquote><pre>void splice_after(const_iterator position, forward_list&lt;T,Alloc&gt;&amp;&amp; x);
void splice_after(const_iterator position, forward_list&lt;T,Alloc&gt;&amp;&amp; x,
                  const_iterator i);
void splice_after(const_iterator position, forward_list&lt;T,Alloc&gt;&amp;&amp; x,
                  const_iterator first, const_iterator last);

void splice(const_iterator position, list&lt;T,Alloc&gt;&amp;&amp; x);
void splice(const_iterator position, list&lt;T,Alloc&gt;&amp;&amp; x,
            const_iterator i);
void splice(const_iterator position, list&lt;T,Alloc&gt;&amp;&amp; x,
            const_iterator first, const_iterator last);
</pre></blockquote>

<b>Possible resolutions:</b>

<p>
Option A.	Add an additional (non-const) lvalue-reference
overload in each case
</p>
<p>
Option B.	Change rvalue reference back to (non-const)
lvalue-reference overload in each case
</p>
<p>
Option C.	Add an additional (non-const) lvalue-reference
overload in just the <tt>std::list</tt> cases
</p>
<p>
I think (B) would be very unfortunate, I really like the <tt>forward_list</tt>
behaviour in (C) but feel (A) is needed for consistency.
</p>
<p>
My actual preference would be NAD, ship with this as a breaking change as it
is a more explicit interface.  I don't think that will fly though!
</p>

<p>
See the thread starting with c++std-lib-23725 for more discussion.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1134"></a>1134. Redundant specification of stdint.h, fenv.h, tgmath.h, and maybe complex.h</h3>
<p><b>Section:</b> 18.4.2 [stdinth], 26.3.2 [fenv], 26.8 [c.math], 26.4.11 [cmplxh] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Robert Klarer <b>Opened:</b> 2009-05-26  <b>Last modified:</b> 2009-06-14</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
This is probably editorial.
</p>
<p>
The following items should be removed from the draft, because they're
redundant with Annex D, and they arguably make some *.h headers
non-deprecated:
</p>
<p>
18.4.2 [stdinth] (regarding <tt>&lt;stdint.h&gt;</tt>) 
</p>
<p>
26.3.2 [fenv] (regarding <tt>&lt;fenv.h&gt;</tt>
</p>
<p>
Line 3 of 26.8 [c.math] (regarding <tt>&lt;tgmath.h&gt;</tt>) 
</p>
<p>
26.4.11 [cmplxh] (regarding <tt>&lt;complex.h&gt;</tt>, though the note in this subclause is not redundant) 
</p>

<p><i>[
2009-06-10 Ganesh adds:
]</i></p>


<blockquote>
While searching for <tt>stdint</tt> in the CD, I found that <tt>&lt;stdint.h&gt;</tt> is also
mentioned in 3.9.1 [basic.fundamental] /5. It guess it should refer to
<tt>&lt;cstdint&gt;</tt> instead.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Remove the section 18.4.2 [stdinth].
</p>
<p>
Remove the section 26.3.2 [fenv].
</p>
<p>
Remove 26.8 [c.math], p3:
</p>

<blockquote>
<del>-3- The header <tt>&lt;tgmath.h&gt;</tt> effectively includes the headers <tt>&lt;complex.h&gt;</tt>
and <tt>&lt;math.h&gt;</tt>.</del>
</blockquote>
<p>
Remove the section 26.4.11 [cmplxh].
</p>





<hr>
<h3><a name="1135"></a>1135. <tt>exception_ptr</tt> should support contextual conversion to <tt>bool</tt></h3>
<p><b>Section:</b> 18.8.5 [propagation] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2007-06-06  <b>Last modified:</b> 2009-06-09</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#propagation">active issues</a> in [propagation].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#propagation">issues</a> in [propagation].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
As of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2857.pdf">N2857</a>
18.8.5 [propagation]/5, the implementation-defined type
<tt>exception_ptr</tt> does provide the following ways to check whether
it is a null value:
</p>
<blockquote><pre>void f(std::exception_ptr p) {
  p == nullptr;
  p == 0;
  p == exception_ptr();
}
</pre></blockquote>
<p>
This is rather cumbersome way of checking for the null value
and I suggest to require support for evaluation in a boolean
context like so:
</p>

<blockquote><pre>void g(std::exception_ptr p) {
  if (p) {}
  !p;
}
</pre></blockquote>


<p><b>Proposed resolution:</b></p>
<p>
In section 18.8.5 [propagation] insert a new paragraph between p.5 and p.6:
</p>

<blockquote>
<ins>
An object <tt>e</tt> of type <tt>exception_ptr</tt> can be contextually converted to <tt>bool</tt>.
The effect shall be as if <tt>e != exception_ptr()</tt> had been evaluated in place
of <tt>e</tt>. There shall be no implicit conversion to arithmetic type, to
enumeration type or to pointer type.
</ins>
</blockquote>





<hr>
<h3><a name="1136"></a>1136. Incomplete specification of <tt>nested_exception::rethrow_nested()</tt></h3>
<p><b>Section:</b> 18.8.6 [except.nested] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2007-06-06  <b>Last modified:</b> 2009-06-09</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#except.nested">active issues</a> in [except.nested].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#except.nested">issues</a> in [except.nested].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It was recently mentioned in a newsgroup article
<a href="http://groups.google.de/group/comp.std.c++/msg/f82022aff68edf3d">http://groups.google.de/group/comp.std.c++/msg/f82022aff68edf3d</a>
that the specification of the member function <tt>rethrow_nested()</tt> of the
class <tt>nested_exception</tt> is incomplete, specifically it remains unclear
what happens, if member <tt>nested_ptr()</tt> returns a null value. In
18.8.6 [except.nested] we find only the following paragraph related to that:
</p>
<blockquote><pre>void rethrow_nested() const; // [[noreturn]]
</pre>
<blockquote>
-4- <i>Throws:</i> the stored exception captured by this <tt>nested_exception</tt> object.
</blockquote>
</blockquote>
<p>
This is a problem, because it is possible to create an object of
<tt>nested_exception</tt> with exactly such a state, e.g.
</p>
<blockquote><pre>#include &lt;exception&gt;
#include &lt;iostream&gt;

int main() try {
  std::nested_exception e; // OK, calls current_exception() and stores it's null value
  e.rethrow_nested(); // ?
  std::cout &lt;&lt; "A" &lt;&lt; std::endl;
}
catch(...) {
  std::cout &lt;&lt; "B" &lt;&lt; std::endl;
}
</pre></blockquote>
<p>
I suggest to follow the proposal of the reporter, namely to invoke
<tt>terminate()</tt> if <tt>nested_ptr()</tt> return a null value of <tt>exception_ptr</tt> instead
of relying on the fallback position of undefined behavior. This would
be consistent to the behavior of a <tt>throw;</tt> statement when no
exception is being handled.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change around 18.8.6 [except.nested]/4 as indicated:
</p>
<blockquote>
<p>
-4- <i>Throws:</i> the stored exception captured by this <tt>nested_exception</tt>
object<ins>, if <tt>nested_ptr() != nullptr</tt></ins>
</p>
<p>
<ins>- <i>Remarks:</i> If <tt>nested_ptr() == nullptr</tt>, <tt>terminate()</tt>
shall be called.</ins>
</p>
</blockquote>





<hr>
<h3><a name="1137"></a>1137. Return type of <tt>conj</tt> and <tt>proj</tt></h3>
<p><b>Section:</b> 26.4.9 [cmplx.over] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Marc Steinbach <b>Opened:</b> 2009-06-11  <b>Last modified:</b> 2009-06-14</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#cmplx.over">issues</a> in [cmplx.over].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In clause 1, the Working Draft 
(<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2857.pdf">N2857</a>)
specifies overloads of the
functions
</p>
<blockquote><pre>arg, conj, imag, norm, proj, real
</pre></blockquote>
<p>
for non-complex arithmetic types (<tt>float</tt>, <tt>double</tt>,
<tt>long double</tt>, and integers).
The only requirement (clause 2) specifies type promotion of arguments.
</p>
<p>
I strongly suggest to add the following requirement on the return types:
</p>
<blockquote>
All the specified overloads must return real (i.e., non-complex) values,
specifically, the nested <tt>value_type</tt> of promoted arguments.
</blockquote>

<p>
(This has no effect on <tt>arg</tt>, <tt>imag</tt>, <tt>norm</tt>, <tt>real</tt>:
they are real-valued anyway.)
</p>
<p><b>Rationale:</b></p>
<p>
Mathematically, <tt>conj()</tt> and <tt>proj()</tt>, like the transcendental functions, are
complex-valued in general but map the (extended) real line to itself.
In fact, both functions act as identity on the reals.
A typical user will expect <tt>conj()</tt> and <tt>proj()</tt> to preserve this essential
mathematical property in the same way as <tt>exp()</tt>, <tt>sin()</tt>, etc.
A typical use of <tt>conj()</tt>, e.g., is the generic scalar product of n-vectors:
</p>

<blockquote><pre>template&lt;typename T&gt;
inline T
scalar_product(size_t n, T const* x, T const* y) {
  T result = 0;
  for (size_t i = 0; i &lt; n; ++i)
    result += std::conj(x[i]) * y[i];
  return result;
}
</pre></blockquote>
<p>
This will work equally well for real and complex floating-point types <tt>T</tt> if
<tt>conj()</tt> returns <tt>T</tt>. It will not work with real types if <tt>conj()</tt>
returns complex values.
</p>
<p>
Instead, the implementation of <tt>scalar_product</tt> becomes either less efficient
and less useful (if a complex result is always returned), or unnecessarily
complicated (if overloaded versions with proper return types are defined).
In the second case, <tt>conj()</tt> is not used with real arguments.
</p>
<p>
Any use of <tt>conj()</tt> I can think of would benefit from the proposed return type
requirement, in a similar way.
It will not harm use cases where a complex value is expected, because of
implicit conversion to complex.
Without the proposed return type guarantee, I find an overloaded <tt>conj()</tt> not
only useless but actually troublesome.
</p>
<p>
I believe that the same applies to <tt>proj()</tt>, althought up to now I had no need
for it.
</p>



<p><b>Proposed resolution:</b></p>
<p>
Insert a new paragraph after 26.4.9 [cmplx.over]/2:
</p>

<blockquote>
<ins>
All of the specified overloads shall have a return type which is the nested <tt>value_type</tt> of
the promoted arguments.
</ins>
</blockquote>





<hr>
<h3><a name="1138"></a>1138. unusal return value for operator+</h3>
<p><b>Section:</b> 21.4.8.1 [string::op+] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-06-12  <b>Last modified:</b> 2009-06-15</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Many of the <tt>basic_string operator+</tt> overloads return an rvalue-reference.  Is
that really intended?
</p>
<p>
I'm considering it might be a mild performance tweak to avoid making
un-necessary copies of a cheaply movable type, but it opens risk to dangling
references in code like:
</p>

<blockquote><pre>auto &amp;&amp; s = string{"x"} + string{y};
</pre></blockquote>

<p>
and I'm not sure about:
</p>

<blockquote><pre>auto s = string{"x"} + string{y};
</pre></blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Strike the <tt>&amp;&amp;</tt> from the return type in the following function
signatures:
</p>

<blockquote>
<p>
21.3 [string.classes] p2 Header Synopsis
</p>

<blockquote><pre>template&lt;class charT, class traits, class Allocator&gt;
  basic_string&lt;charT,traits,Allocator&gt;<del>&amp;&amp;</del>
    operator+(basic_string&lt;charT,traits,Allocator&gt;&amp;&amp; lhs,
              const basic_string&lt;charT,traits,Allocator&gt;&amp; rhs);

template&lt;class charT, class traits, class Allocator&gt;
  basic_string&lt;charT,traits,Allocator&gt;<del>&amp;&amp;</del>
    operator+(const basic_string&lt;charT,traits,Allocator&gt;&amp; lhs,
              basic_string&lt;charT,traits,Allocator&gt;&amp;&amp; rhs);

template&lt;class charT, class traits, class Allocator&gt;
  basic_string&lt;charT,traits,Allocator&gt;<del>&amp;&amp;</del>
    operator+(basic_string&lt;charT,traits,Allocator&gt;&amp;&amp; lhs,
              basic_string&lt;charT,traits,Allocator&gt;&amp;&amp; rhs);


template&lt;class charT, class traits, class Allocator&gt;
  basic_string&lt;charT,traits,Allocator&gt;<del>&amp;&amp;</del>
    operator+(const charT* lhs,
              basic_string&lt;charT,traits,Allocator&gt;&amp;&amp; rhs);

template&lt;class charT, class traits, class Allocator&gt;
  basic_string&lt;charT,traits,Allocator&gt;<del>&amp;&amp;</del>
    operator+(charT lhs, basic_string&lt;charT,traits,Allocator&gt;&amp;&amp; rhs);

template&lt;class charT, class traits, class Allocator&gt;
  basic_string&lt;charT,traits,Allocator&gt;<del>&amp;&amp;</del>
    operator+(basic_string&lt;charT,traits,Allocator&gt;&amp;&amp; lhs,
              const charT* rhs);

template&lt;class charT, class traits, class Allocator&gt;
  basic_string&lt;charT,traits,Allocator&gt;<del>&amp;&amp;</del>
    operator+(basic_string&lt;charT,traits,Allocator&gt;&amp;&amp; lhs, charT rhs);
</pre></blockquote>

<p>
21.4.8.1 [string::op+]
</p>

<blockquote><pre>template&lt;class charT, class traits, class Allocator&gt;
  basic_string&lt;charT,traits,Allocator&gt;<del>&amp;&amp;</del>
    operator+(basic_string&lt;charT,traits,Allocator&gt;&amp;&amp; lhs,
              const basic_string&lt;charT,traits,Allocator&gt;&amp; rhs);

template&lt;class charT, class traits, class Allocator&gt;
  basic_string&lt;charT,traits,Allocator&gt;<del>&amp;&amp;</del>
    operator+(const basic_string&lt;charT,traits,Allocator&gt;&amp; lhs,
              basic_string&lt;charT,traits,Allocator&gt;&amp;&amp; rhs);

template&lt;class charT, class traits, class Allocator&gt;
  basic_string&lt;charT,traits,Allocator&gt;<del>&amp;&amp;</del>
    operator+(basic_string&lt;charT,traits,Allocator&gt;&amp;&amp; lhs,
              basic_string&lt;charT,traits,Allocator&gt;&amp;&amp; rhs);


template&lt;class charT, class traits, class Allocator&gt;
  basic_string&lt;charT,traits,Allocator&gt;<del>&amp;&amp;</del>
    operator+(const charT* lhs,
              basic_string&lt;charT,traits,Allocator&gt;&amp;&amp; rhs);

template&lt;class charT, class traits, class Allocator&gt;
  basic_string&lt;charT,traits,Allocator&gt;<del>&amp;&amp;</del>
    operator+(charT lhs, basic_string&lt;charT,traits,Allocator&gt;&amp;&amp; rhs);

template&lt;class charT, class traits, class Allocator&gt;
  basic_string&lt;charT,traits,Allocator&gt;<del>&amp;&amp;</del>
    operator+(basic_string&lt;charT,traits,Allocator&gt;&amp;&amp; lhs,
              const charT* rhs);

template&lt;class charT, class traits, class Allocator&gt;
  basic_string&lt;charT,traits,Allocator&gt;<del>&amp;&amp;</del>
    operator+(basic_string&lt;charT,traits,Allocator&gt;&amp;&amp; lhs, charT rhs);
</pre></blockquote>

</blockquote>






<hr>
<h3><a name="1139"></a>1139. Response to US 93</h3>
<p><b>Section:</b> 30 [thread] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Beman Dawes <b>Opened:</b> 2009-06-15  <b>Last modified:</b> 2009-06-15</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#thread">active issues</a> in [thread].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread">issues</a> in [thread].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses US 93, JP 79, UK 333, JP 81</b></p>

<p>
The thread chapter is not concept enabled.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1140"></a>1140. Response to US 84</h3>
<p><b>Section:</b> 26 [numerics] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Beman Dawes <b>Opened:</b> 2009-06-15  <b>Last modified:</b> 2009-06-15</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#numerics">active issues</a> in [numerics].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#numerics">issues</a> in [numerics].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses US 84</b></p>

<p>
The numerics chapter is not concept enabled.
</p>

<p>
The portion of this comment dealing with random numbers was resolved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2836.pdf">N2836</a>,
which was accepted in Summit.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1141"></a>1141. Response to US 85</h3>
<p><b>Section:</b> 27 [input.output] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Beman Dawes <b>Opened:</b> 2009-06-15  <b>Last modified:</b> 2009-06-15</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#input.output">active issues</a> in [input.output].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#input.output">issues</a> in [input.output].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses US 85, JP 67, JP 68, JP 69, JP 72</b></p>

<p>
The input/output chapter is not concept enabled.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1142"></a>1142. Response to US 86</h3>
<p><b>Section:</b> 28 [re] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Beman Dawes <b>Opened:</b> 2009-06-15  <b>Last modified:</b> 2009-06-15</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#re">active issues</a> in [re].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#re">issues</a> in [re].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses US 86, UK 309, UK 310</b></p>

<p>
The regular expressions chapter is not concept enabled.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1143"></a>1143. Response to US 87</h3>
<p><b>Section:</b> 29 [atomics] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New">New</a>
 <b>Submitter:</b> Beman Dawes <b>Opened:</b> 2009-06-15  <b>Last modified:</b> 2009-06-15</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#atomics">active issues</a> in [atomics].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#atomics">issues</a> in [atomics].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses US 87, UK 311</b></p>

<p>
The atomics chapter is not concept enabled.
</p>

<p>
Needs to also consider issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#923">923</a> and <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#924">924</a>.
</p>



<p><b>Proposed resolution:</b></p>





</body></html>