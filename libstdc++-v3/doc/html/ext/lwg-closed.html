<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">


<title>C++ Standard Library Closed Issues List</title>
<style type="text/css">
p {text-align:justify}
li {text-align:justify}
blockquote.note
{
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
}
ins {background-color:#A0FFA0}
del {background-color:#FFA0A0}
</style>
</head><body>
<table>
<tbody><tr>
<td align="left">Doc. no.</td>
<td align="left">N3013=09-0203</td>
</tr>
<tr>
<td align="left">Date:</td>
<td align="left">2009-11-08</td>
</tr>
<tr>
<td align="left">Project:</td>
<td align="left">Programming Language C++</td>
</tr>
<tr>
<td align="left">Reply to:</td>
<td align="left">Howard Hinnant &lt;<a href="mailto:howard.hinnant@gmail.com">howard.hinnant@gmail.com</a>&gt;</td>
</tr>
</tbody></table>
<h1>C++ Standard Library Closed Issues List (Revision R68)</h1>

  <p>Reference ISO/IEC IS 14882:2003(E)</p>
  <p>Also see:</p>
    <ul>
      <li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-toc.html">Table of Contents</a> for all library issues.</li>
      <li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html">Index by Section</a> for all library issues.</li>
      <li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html">Index by Status</a> for all library issues.</li>
      <li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html">Library Active Issues List</a></li>
      <li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html">Library Defect Reports List</a></li>
    </ul>

  <p>This document contains only library issues which have been closed
  by the Library Working Group as duplicates or not defects. That is,
  issues which have a status of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a> or
  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>. See the <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html">Library Active Issues List</a> active issues and more
  information. See the <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html">Library Defect Reports List</a> for issues considered
  defects.  The introductory material in that document also applies to
  this document.</p>

<h2>Revision History</h2>
<ul>
<li>R68: 
2009-11-06 post-Santa Cruz mailing.
<ul>
<li><b>Summary:</b><ul>
<li>205 open issues, down by 77.</li>
<li>1055 closed issues, up by 120.</li>
<li>1260 issues total, up by 43.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following Dup issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1230">1230</a>.</li>
<li>Added the following NAD issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1229">1229</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1236">1236</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1243">1243</a>.</li>
<li>Added the following NAD Editorial issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1232">1232</a>.</li>
<li>Added the following NAD Future issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1235">1235</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1242">1242</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1248">1248</a>.</li>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1218">1218</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1219">1219</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1221">1221</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1222">1222</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1223">1223</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1224">1224</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1225">1225</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1234">1234</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1240">1240</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1244">1244</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1245">1245</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1246">1246</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1249">1249</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1250">1250</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1251">1251</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1252">1252</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1253">1253</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1254">1254</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1255">1255</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1256">1256</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1257">1257</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1258">1258</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1259">1259</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1260">1260</a>.</li>
<li>Added the following Open issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1228">1228</a>.</li>
<li>Added the following Ready issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1227">1227</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1237">1237</a>.</li>
<li>Added the following Review issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1247">1247</a>.</li>
<li>Added the following Tentatively NAD Editorial issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1233">1233</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1239">1239</a>.</li>
<li>Added the following Tentatively NAD Future issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1238">1238</a>.</li>
<li>Added the following Tentatively Ready issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1220">1220</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1226">1226</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1231">1231</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1241">1241</a>.</li>
<li>Changed the following issues from New to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1132">1132</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1148">1148</a>.</li>
<li>Changed the following issues from Open to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#96">96</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#458">458</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#463">463</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#916">916</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#917">917</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#919">919</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#955">955</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#977">977</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1009">1009</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1020">1020</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1035">1035</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1042">1042</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1051">1051</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1064">1064</a>.</li>
<li>Changed the following issues from Review to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#668">668</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#930">930</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1091">1091</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1102">1102</a>.</li>
<li>Changed the following issues from Tentatively NAD to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#588">588</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#617">617</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#971">971</a>.</li>
<li>Changed the following issues from Tentatively NAD Future to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1062">1062</a>.</li>
<li>Changed the following issues from NAD Concepts to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1143">1143</a>.</li>
<li>Changed the following issues from New to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1116">1116</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1117">1117</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1122">1122</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1129">1129</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1145">1145</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1146">1146</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1147">1147</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1155">1155</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1166">1166</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1172">1172</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1174">1174</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1179">1179</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1195">1195</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1196">1196</a>.</li>
<li>Changed the following issues from Open to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#431">431</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#580">580</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#635">635</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#719">719</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#823">823</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#827">827</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#879">879</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#880">880</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#908">908</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#923">923</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#924">924</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#926">926</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#944">944</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#947">947</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#958">958</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1046">1046</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1048">1048</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1054">1054</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1055">1055</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1075">1075</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1088">1088</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1160">1160</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1161">1161</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1162">1162</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1163">1163</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1165">1165</a>.</li>
<li>Changed the following issues from Review to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#828">828</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#897">897</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#976">976</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1043">1043</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1047">1047</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1049">1049</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1050">1050</a>.</li>
<li>Changed the following issues from New to NAD Future: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1120">1120</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1150">1150</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1184">1184</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1203">1203</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1217">1217</a>.</li>
<li>Changed the following issues from Open to NAD Future: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#484">484</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#532">532</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#851">851</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#933">933</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#935">935</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#936">936</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#961">961</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1041">1041</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1053">1053</a>.</li>
<li>Changed the following issues from Tentatively NAD Future to NAD Future: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1031">1031</a>.</li>
<li>Changed the following issues from New to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1118">1118</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1119">1119</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1151">1151</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1153">1153</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1156">1156</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1171">1171</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1173">1173</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1183">1183</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1191">1191</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1211">1211</a>.</li>
<li>Changed the following issues from Ready to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#430">430</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#834">834</a>.</li>
<li>Changed the following issues from Review to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#397">397</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#408">408</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#835">835</a>.</li>
<li>Changed the following issues from Tentatively NAD to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#625">625</a>.</li>
<li>Changed the following issues from New to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1123">1123</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1134">1134</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1135">1135</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1136">1136</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1144">1144</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1177">1177</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1194">1194</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1204">1204</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1216">1216</a>.</li>
<li>Changed the following issues from Open to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#296">296</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#471">471</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#485">485</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#539">539</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#816">816</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#860">860</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#865">865</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#872">872</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#920">920</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#932">932</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#939">939</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#940">940</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#960">960</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#963">963</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#974">974</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#978">978</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1011">1011</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1030">1030</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1079">1079</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1098">1098</a>.</li>
<li>Changed the following issues from Review to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#473">473</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#671">671</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#836">836</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#854">854</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#868">868</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#871">871</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#889">889</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#893">893</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#921">921</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#950">950</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#954">954</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#957">957</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#962">962</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#967">967</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#968">968</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#983">983</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1052">1052</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1094">1094</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1095">1095</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1097">1097</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1100">1100</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1104">1104</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1157">1157</a>.</li>
<li>Changed the following issues from New to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1130">1130</a>.</li>
<li>Changed the following issues from Open to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#556">556</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#631">631</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#676">676</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#727">727</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#929">929</a>.</li>
<li>Changed the following issues from Open to Tentatively NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1056">1056</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1099">1099</a>.</li>
<li>Changed the following issues from New to Tentatively NAD Concepts: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1186">1186</a>.</li>
<li>Changed the following issues from New to Tentatively NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1115">1115</a>.</li>
<li>Changed the following issues from New to Tentatively NAD Future: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1121">1121</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1201">1201</a>.</li>
<li>Changed the following issues from Open to Tentatively NAD Future: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1112">1112</a>.</li>
<li>Changed the following issues from New to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1126">1126</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1138">1138</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1152">1152</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1158">1158</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1189">1189</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1192">1192</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1208">1208</a>.</li>
<li>Changed the following issues from Open to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#987">987</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#999">999</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1071">1071</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1090">1090</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1108">1108</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1113">1113</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1114">1114</a>.</li>
<li>Changed the following issues from Ready to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#149">149</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#419">419</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#498">498</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#564">564</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#565">565</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#630">630</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#659">659</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#696">696</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#711">711</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#716">716</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#723">723</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#788">788</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#822">822</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#838">838</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#847">847</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#857">857</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#859">859</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#876">876</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#881">881</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#883">883</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#886">886</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#934">934</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1004">1004</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1178">1178</a>.</li>
<li>Changed the following issues from Tentatively Ready to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1012">1012</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1019">1019</a>.</li>
</ul></li>
</ul>
</li>
<li>R67: 
2009-09-25 pre-Santa Cruz mailing.
<ul>
<li><b>Summary:</b><ul>
<li>282 open issues, up by 32.</li>
<li>935 closed issues, down by 1.</li>
<li>1217 issues total, up by 31.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1187">1187</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1188">1188</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1189">1189</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1190">1190</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1191">1191</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1192">1192</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1193">1193</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1194">1194</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1195">1195</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1196">1196</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1197">1197</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1198">1198</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1199">1199</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1200">1200</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1201">1201</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1202">1202</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1203">1203</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1204">1204</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1205">1205</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1206">1206</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1207">1207</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1208">1208</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1209">1209</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1210">1210</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1211">1211</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1212">1212</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1213">1213</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1214">1214</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1215">1215</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1216">1216</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1217">1217</a>.</li>
<li>Changed the following issues from NAD to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#296">296</a>.</li>
<li>Changed the following issues from WP to Pending WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#970">970</a>.</li>
<li>Changed the following issues from Open to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#976">976</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1052">1052</a>.</li>
<li>Changed the following issues from Ready to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#780">780</a>.</li>
</ul></li>
</ul>
</li>
<li>R66: 
2009-07-31 post-Frankfurt mailing.
<ul>
<li><b>Summary:</b><ul>
<li>250 open issues, down by 128.</li>
<li>936 closed issues, up by 171.</li>
<li>1186 issues total, up by 43.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following NAD issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1164">1164</a>.</li>
<li>Added the following NAD Concepts issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1149">1149</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1167">1167</a>.</li>
<li>Added the following NAD Editorial issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1168">1168</a>.</li>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1144">1144</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1145">1145</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1146">1146</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1147">1147</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1148">1148</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1150">1150</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1151">1151</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1152">1152</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1153">1153</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1154">1154</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1155">1155</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1156">1156</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1158">1158</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1159">1159</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1166">1166</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1169">1169</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1170">1170</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1171">1171</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1172">1172</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1173">1173</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1174">1174</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1175">1175</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1176">1176</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1177">1177</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1179">1179</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1180">1180</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1181">1181</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1182">1182</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1183">1183</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1184">1184</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1185">1185</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1186">1186</a>.</li>
<li>Added the following Open issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1160">1160</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1161">1161</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1162">1162</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1163">1163</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1165">1165</a>.</li>
<li>Added the following Ready issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1178">1178</a>.</li>
<li>Added the following Review issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1157">1157</a>.</li>
<li>Changed the following issues from Open to Dup: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#750">750</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#895">895</a>.</li>
<li>Changed the following issues from Open to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#111">111</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#128">128</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#138">138</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#190">190</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#219">219</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#290">290</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#309">309</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#342">342</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#343">343</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#382">382</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#394">394</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#398">398</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#417">417</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#418">418</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#421">421</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#459">459</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#466">466</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#492">492</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#502">502</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#503">503</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#546">546</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#573">573</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#582">582</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#585">585</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#597">597</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#606">606</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#614">614</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#632">632</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#721">721</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#747">747</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#751">751</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#833">833</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#941">941</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#992">992</a>.</li>
<li>Changed the following issues from Review to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1003">1003</a>.</li>
<li>Changed the following issues from Tentatively NAD to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#568">568</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#644">644</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#667">667</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#669">669</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#701">701</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#702">702</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#785">785</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#863">863</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#901">901</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#903">903</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#946">946</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#988">988</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#995">995</a>.</li>
<li>Changed the following issues from Tentatively Ready to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1002">1002</a>.</li>
<li>Changed the following issues from New to NAD Concepts: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1124">1124</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1127">1127</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1128">1128</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1139">1139</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1140">1140</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1141">1141</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1142">1142</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1143">1143</a>.</li>
<li>Changed the following issues from Open to NAD Concepts: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#902">902</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#989">989</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1000">1000</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1007">1007</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1010">1010</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1015">1015</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1016">1016</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1017">1017</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1018">1018</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1026">1026</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1027">1027</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1028">1028</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1029">1029</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1032">1032</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1036">1036</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1057">1057</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1059">1059</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1072">1072</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1078">1078</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1081">1081</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1082">1082</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1083">1083</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1084">1084</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1085">1085</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1086">1086</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1092">1092</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1096">1096</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1105">1105</a>.</li>
<li>Changed the following issues from Review to NAD Concepts: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1001">1001</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1005">1005</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1080">1080</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1087">1087</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1111">1111</a>.</li>
<li>Changed the following issues from Tentatively NAD to NAD Concepts: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#912">912</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#918">918</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1074">1074</a>.</li>
<li>Changed the following issues from Tentatively NAD Editorial to NAD Concepts: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#927">927</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1109">1109</a>.</li>
<li>Changed the following issues from Tentatively Ready to NAD Concepts: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#906">906</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#913">913</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#914">914</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#928">928</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1024">1024</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1063">1063</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1067">1067</a>.</li>
<li>Changed the following issues from Open to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#718">718</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#873">873</a>.</li>
<li>Changed the following issues from Tentatively NAD Editorial to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#424">424</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#825">825</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#830">830</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#837">837</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#862">862</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#867">867</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#884">884</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#945">945</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#952">952</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#969">969</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#972">972</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#973">973</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#979">979</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1023">1023</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1058">1058</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1060">1060</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1061">1061</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1077">1077</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1101">1101</a>.</li>
<li>Changed the following issues from Tentatively Ready to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1013">1013</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1107">1107</a>.</li>
<li>Changed the following issues from Open to NAD Future: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#255">255</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#423">423</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#523">523</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#708">708</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#760">760</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#839">839</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#877">877</a>.</li>
<li>Changed the following issues from CD1 to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#823">823</a>.</li>
<li>Changed the following issues from NAD Editorial to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#299">299</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#484">484</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#532">532</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#556">556</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#594">594</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#631">631</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#676">676</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#704">704</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#724">724</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#742">742</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#811">811</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#870">870</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#872">872</a>.</li>
<li>Changed the following issues from Review to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#879">879</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#919">919</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#929">929</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#939">939</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#987">987</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1009">1009</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1093">1093</a>.</li>
<li>Changed the following issues from Tentatively NAD to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#458">458</a>.</li>
<li>Changed the following issues from Tentatively NAD Future to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#96">96</a>.</li>
<li>Changed the following issues from Tentatively Ready to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#910">910</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#915">915</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#932">932</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#940">940</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#974">974</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#976">976</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#999">999</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1011">1011</a>.</li>
<li>Changed the following issues from Open to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#149">149</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#419">419</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#430">430</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#498">498</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#564">564</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#565">565</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#630">630</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#659">659</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#696">696</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#711">711</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#716">716</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#723">723</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#788">788</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#834">834</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#838">838</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#847">847</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#857">857</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#859">859</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#876">876</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#881">881</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#883">883</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#886">886</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1004">1004</a>.</li>
<li>Changed the following issues from Review to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#780">780</a>.</li>
<li>Changed the following issues from Tentatively NAD to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#822">822</a>.</li>
<li>Changed the following issues from Tentatively Ready to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#934">934</a>.</li>
<li>Changed the following issues from NAD to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#871">871</a>.</li>
<li>Changed the following issues from Open to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#397">397</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#408">408</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#473">473</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#671">671</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#836">836</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#868">868</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#889">889</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#893">893</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#930">930</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#954">954</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#962">962</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#967">967</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#968">968</a>.</li>
<li>Changed the following issues from Tentatively NAD to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#668">668</a>.</li>
<li>Changed the following issues from Tentatively Ready to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#950">950</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1100">1100</a>.</li>
<li>Changed the following issues from Open to Tentatively NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#588">588</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#617">617</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#625">625</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#971">971</a>.</li>
<li>Changed the following issues from Open to Tentatively NAD Future: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1031">1031</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1062">1062</a>.</li>
<li>Changed the following issues from Open to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1012">1012</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1019">1019</a>.</li>
<li>Changed the following issues from Tentatively Ready to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#688">688</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#765">765</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#810">810</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#814">814</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#853">853</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#869">869</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#878">878</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#888">888</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#890">890</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#898">898</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#899">899</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#904">904</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#907">907</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#909">909</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#922">922</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#925">925</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#931">931</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#938">938</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#943">943</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#948">948</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#949">949</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#965">965</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#970">970</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#975">975</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#981">981</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#982">982</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#984">984</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#986">986</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#990">990</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#991">991</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#993">993</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#994">994</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#997">997</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#998">998</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1006">1006</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1014">1014</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1021">1021</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1037">1037</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1038">1038</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1039">1039</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1040">1040</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1044">1044</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1045">1045</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1065">1065</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1066">1066</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1070">1070</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1073">1073</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1103">1103</a>.</li>
</ul></li>
</ul>
</li>
<li>R65: 
2009-06-19 pre-Frankfurt mailing.
<ul>
<li><b>Summary:</b><ul>
<li>378 open issues, up by 32.</li>
<li>765 closed issues, up by 0.</li>
<li>1143 issues total, up by 32.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1115">1115</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1116">1116</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1117">1117</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1118">1118</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1119">1119</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1120">1120</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1121">1121</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1122">1122</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1123">1123</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1124">1124</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1125">1125</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1126">1126</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1127">1127</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1128">1128</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1129">1129</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1130">1130</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1131">1131</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1132">1132</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1133">1133</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1134">1134</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1135">1135</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1136">1136</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1137">1137</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1138">1138</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1139">1139</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1140">1140</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1141">1141</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1142">1142</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1143">1143</a>.</li>
<li>Added the following Open issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1112">1112</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1113">1113</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1114">1114</a>.</li>
<li>Changed the following issues from Pending NAD Editorial to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#937">937</a>.</li>
<li>Changed the following issues from New to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#696">696</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#716">716</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#727">727</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#865">865</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#900">900</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#911">911</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#916">916</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#917">917</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#920">920</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#933">933</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#935">935</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#941">941</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#947">947</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#951">951</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#953">953</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#954">954</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#955">955</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#956">956</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#977">977</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#978">978</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#985">985</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#989">989</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#996">996</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1033">1033</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1054">1054</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1056">1056</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1057">1057</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1059">1059</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1062">1062</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1068">1068</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1069">1069</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1071">1071</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1072">1072</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1076">1076</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1090">1090</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1092">1092</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1096">1096</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1098">1098</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1099">1099</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1105">1105</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1106">1106</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1108">1108</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1110">1110</a>.</li>
<li>Changed the following issues from Review to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#817">817</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#971">971</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#992">992</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1004">1004</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1010">1010</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1012">1012</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1015">1015</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1019">1019</a>.</li>
<li>Changed the following issues from New to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#780">780</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#835">835</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#897">897</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#919">919</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#939">939</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#957">957</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#983">983</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1001">1001</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1080">1080</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1091">1091</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1093">1093</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1094">1094</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1095">1095</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1097">1097</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1102">1102</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1104">1104</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1111">1111</a>.</li>
<li>Changed the following issues from Open to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#921">921</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#987">987</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1087">1087</a>.</li>
<li>Changed the following issues from New to Tentatively NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#568">568</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#701">701</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#702">702</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#785">785</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#863">863</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#903">903</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#912">912</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#918">918</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#946">946</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#995">995</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1074">1074</a>.</li>
<li>Changed the following issues from Open to Tentatively NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#458">458</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#644">644</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#667">667</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#668">668</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#669">669</a>.</li>
<li>Changed the following issues from Review to Tentatively NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#901">901</a>.</li>
<li>Changed the following issues from Tentatively Ready to Tentatively NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#822">822</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#988">988</a>.</li>
<li>Changed the following issues from New to Tentatively NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#837">837</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#862">862</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#867">867</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#927">927</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#945">945</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#952">952</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#969">969</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#972">972</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#973">973</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#979">979</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1058">1058</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1060">1060</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1061">1061</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1077">1077</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1101">1101</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1109">1109</a>.</li>
<li>Changed the following issues from Open to Tentatively NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#424">424</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#825">825</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#830">830</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#884">884</a>.</li>
<li>Changed the following issues from Review to Tentatively NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1023">1023</a>.</li>
<li>Changed the following issues from Open to Tentatively NAD Future: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#96">96</a>.</li>
<li>Changed the following issues from New to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#810">810</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#898">898</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#906">906</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#910">910</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#913">913</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#914">914</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#915">915</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#925">925</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#974">974</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#976">976</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#981">981</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#982">982</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#984">984</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#990">990</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#998">998</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#999">999</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1063">1063</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1067">1067</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1070">1070</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1073">1073</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1100">1100</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1103">1103</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1107">1107</a>.</li>
<li>Changed the following issues from Open to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#688">688</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#814">814</a>.</li>
<li>Changed the following issues from Review to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#899">899</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#907">907</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#909">909</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#934">934</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#938">938</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#940">940</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#943">943</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#950">950</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#965">965</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#970">970</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#975">975</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#986">986</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#991">991</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#993">993</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#994">994</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#997">997</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1002">1002</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1006">1006</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1011">1011</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1013">1013</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1014">1014</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1021">1021</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1024">1024</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1037">1037</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1038">1038</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1039">1039</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1040">1040</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1044">1044</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1045">1045</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1065">1065</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1066">1066</a>.</li>
</ul></li>
</ul>
</li>
<li>R64: 
2009-05-01 mid-term mailing.
<ul>
<li><b>Summary:</b><ul>
<li>346 open issues, up by 19.</li>
<li>765 closed issues, up by 0.</li>
<li>1111 issues total, up by 19.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1093">1093</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1094">1094</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1095">1095</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1096">1096</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1097">1097</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1098">1098</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1099">1099</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1100">1100</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1101">1101</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1102">1102</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1103">1103</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1104">1104</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1105">1105</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1106">1106</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1107">1107</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1108">1108</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1109">1109</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1110">1110</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1111">1111</a>.</li>
<li>Changed the following issues from DR to CD1: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#130">130</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#386">386</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#406">406</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#409">409</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#413">413</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#434">434</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#438">438</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#444">444</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#445">445</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#455">455</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#457">457</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#460">460</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#469">469</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#533">533</a>.</li>
<li>Changed the following issues from Review to New: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1070">1070</a>.</li>
</ul></li>
</ul>
</li>
<li>R63: 
2009-03-20 post-Summit mailing.
<ul>
<li><b>Summary:</b><ul>
<li>327 open issues, up by 96.</li>
<li>765 closed issues, up by 14.</li>
<li>1092 issues total, up by 110.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following NAD Editorial issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1022">1022</a>.</li>
<li>Added the following NAD Future issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1025">1025</a>.</li>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#983">983</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#984">984</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#985">985</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#989">989</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#990">990</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#995">995</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#996">996</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#998">998</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#999">999</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1001">1001</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1033">1033</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1054">1054</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1056">1056</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1057">1057</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1058">1058</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1059">1059</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1060">1060</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1061">1061</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1062">1062</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1063">1063</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1067">1067</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1068">1068</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1069">1069</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1071">1071</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1072">1072</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1073">1073</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1074">1074</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1076">1076</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1077">1077</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1080">1080</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1090">1090</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1091">1091</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1092">1092</a>.</li>
<li>Added the following Open issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#987">987</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1000">1000</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1007">1007</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1008">1008</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1016">1016</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1017">1017</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1018">1018</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1020">1020</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1026">1026</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1027">1027</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1028">1028</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1029">1029</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1030">1030</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1031">1031</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1032">1032</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1034">1034</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1035">1035</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1036">1036</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1041">1041</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1042">1042</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1046">1046</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1048">1048</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1051">1051</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1052">1052</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1053">1053</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1055">1055</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1064">1064</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1075">1075</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1078">1078</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1079">1079</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1081">1081</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1082">1082</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1083">1083</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1084">1084</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1085">1085</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1086">1086</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1087">1087</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1088">1088</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1089">1089</a>.</li>
<li>Added the following Review issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#986">986</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#991">991</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#992">992</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#993">993</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#994">994</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#997">997</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1002">1002</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1003">1003</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1004">1004</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1005">1005</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1006">1006</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1009">1009</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1010">1010</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1011">1011</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1012">1012</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1013">1013</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1014">1014</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1015">1015</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1019">1019</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1021">1021</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1023">1023</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1024">1024</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1037">1037</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1038">1038</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1039">1039</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1040">1040</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1043">1043</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1044">1044</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1045">1045</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1047">1047</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1049">1049</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1050">1050</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1065">1065</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1066">1066</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1070">1070</a>.</li>
<li>Added the following Tentatively Ready issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#988">988</a>.</li>
<li>Changed the following issues from New to Dup: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#905">905</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#942">942</a>.</li>
<li>Changed the following issues from New to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#980">980</a>.</li>
<li>Changed the following issues from New to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#874">874</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#875">875</a>.</li>
<li>Changed the following issues from Open to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#732">732</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#793">793</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#794">794</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#800">800</a>.</li>
<li>Changed the following issues from Pending NAD Editorial to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#683">683</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#892">892</a>.</li>
<li>Changed the following issues from Ready to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#803">803</a>.</li>
<li>Changed the following issues from NAD to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#466">466</a>.</li>
<li>Changed the following issues from NAD Future to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#111">111</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#138">138</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#149">149</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#219">219</a>.</li>
<li>Changed the following issues from New to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#880">880</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#891">891</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#893">893</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#902">902</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#908">908</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#921">921</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#923">923</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#924">924</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#926">926</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#930">930</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#936">936</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#944">944</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#958">958</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#959">959</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#960">960</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#961">961</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#962">962</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#963">963</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#964">964</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#966">966</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#967">967</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#968">968</a>.</li>
<li>Changed the following issues from Ready to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#788">788</a>.</li>
<li>Changed the following issues from New to Pending NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#937">937</a>.</li>
<li>Changed the following issues from New to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#879">879</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#899">899</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#901">901</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#907">907</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#909">909</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#929">929</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#934">934</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#938">938</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#940">940</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#943">943</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#950">950</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#965">965</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#970">970</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#971">971</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#975">975</a>.</li>
<li>Changed the following issues from Open to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#817">817</a>.</li>
<li>Changed the following issues from New to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#904">904</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#922">922</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#928">928</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#931">931</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#932">932</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#948">948</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#949">949</a>.</li>
<li>Changed the following issues from Open to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#890">890</a>.</li>
<li>Changed the following issues from Review to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#765">765</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#822">822</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#853">853</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#869">869</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#878">878</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#888">888</a>.</li>
<li>Changed the following issues from Ready to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#752">752</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#753">753</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#758">758</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#821">821</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#866">866</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#894">894</a>.</li>
</ul></li>
</ul>
</li>
<li>R62: 
2009-02-06 pre-Summit mailing.
<ul>
<li><b>Summary:</b><ul>
<li>231 open issues, up by 44.</li>
<li>751 closed issues, up by 0.</li>
<li>982 issues total, up by 44.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#939">939</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#940">940</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#941">941</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#942">942</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#943">943</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#944">944</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#945">945</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#946">946</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#947">947</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#948">948</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#949">949</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#950">950</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#951">951</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#952">952</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#953">953</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#954">954</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#955">955</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#956">956</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#957">957</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#958">958</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#959">959</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#960">960</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#961">961</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#962">962</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#963">963</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#964">964</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#965">965</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#966">966</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#967">967</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#968">968</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#969">969</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#970">970</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#971">971</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#972">972</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#973">973</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#974">974</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#975">975</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#976">976</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#977">977</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#978">978</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#979">979</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#980">980</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#981">981</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#982">982</a>.</li>
</ul></li>
</ul>
</li>
<li>R61: 
2008-12-05 mid-term mailing.
<ul>
<li><b>Summary:</b><ul>
<li>187 open issues, up by 20.</li>
<li>751 closed issues, up by 0.</li>
<li>938 issues total, up by 20.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#919">919</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#920">920</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#921">921</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#922">922</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#923">923</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#924">924</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#925">925</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#926">926</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#927">927</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#928">928</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#929">929</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#930">930</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#931">931</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#932">932</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#933">933</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#934">934</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#935">935</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#936">936</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#937">937</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#938">938</a>.</li>
</ul></li>
</ul>
</li>
<li>R60: 
2008-10-03 post-San Francisco mailing.
<ul>
<li><b>Summary:</b><ul>
<li>167 open issues, down by 25.</li>
<li>751 closed issues, up by 65.</li>
<li>918 issues total, up by 40.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following CD1 issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#882">882</a>.</li>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#879">879</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#880">880</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#891">891</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#893">893</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#897">897</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#898">898</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#899">899</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#900">900</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#901">901</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#902">902</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#903">903</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#904">904</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#905">905</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#906">906</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#907">907</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#908">908</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#909">909</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#910">910</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#911">911</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#912">912</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#913">913</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#914">914</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#915">915</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#916">916</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#917">917</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#918">918</a>.</li>
<li>Added the following Open issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#881">881</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#883">883</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#884">884</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#885">885</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#886">886</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#887">887</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#889">889</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#890">890</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#895">895</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#896">896</a>.</li>
<li>Added the following Pending NAD Editorial issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#892">892</a>.</li>
<li>Added the following Ready issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#894">894</a>.</li>
<li>Added the following Review issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#888">888</a>.</li>
<li>Changed the following issues from New to CD1: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#818">818</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#820">820</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#843">843</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#845">845</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#846">846</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#856">856</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#858">858</a>.</li>
<li>Changed the following issues from Ready to CD1: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#180">180</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#387">387</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#396">396</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#522">522</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#629">629</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#691">691</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#713">713</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#714">714</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#720">720</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#728">728</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#762">762</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#769">769</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#771">771</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#772">772</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#776">776</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#779">779</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#787">787</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#805">805</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#806">806</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#807">807</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#808">808</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#809">809</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#813">813</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#824">824</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#829">829</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#842">842</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#844">844</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#848">848</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#850">850</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#852">852</a>.</li>
<li>Changed the following issues from Review to CD1: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#23">23</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#675">675</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#692">692</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#698">698</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#709">709</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#734">734</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#804">804</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#823">823</a>.</li>
<li>Changed the following issues from WP to CD1: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#44">44</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#49">49</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#76">76</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#91">91</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#92">92</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#98">98</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#103">103</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#109">109</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#117">117</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#118">118</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#120">120</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#123">123</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#136">136</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#153">153</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#165">165</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#167">167</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#171">171</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#179">179</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#182">182</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#183">183</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#184">184</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#185">185</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#186">186</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#187">187</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#198">198</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#200">200</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#201">201</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#202">202</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#206">206</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#214">214</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#221">221</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#225">225</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#226">226</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#228">228</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#229">229</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#230">230</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#231">231</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#232">232</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#233">233</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#234">234</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#235">235</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#237">237</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#238">238</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#239">239</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#240">240</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#241">241</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#242">242</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#243">243</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#247">247</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#248">248</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#250">250</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#251">251</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#252">252</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#253">253</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#254">254</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#256">256</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#258">258</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#259">259</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#260">260</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#261">261</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#262">262</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#263">263</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#264">264</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#265">265</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#266">266</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#268">268</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#270">270</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#271">271</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#272">272</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#273">273</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#274">274</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#275">275</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#276">276</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#278">278</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#280">280</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#281">281</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#282">282</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#283">283</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#284">284</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#285">285</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#286">286</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#288">288</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#291">291</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#292">292</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#294">294</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#295">295</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#297">297</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#298">298</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#300">300</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#301">301</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#303">303</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#305">305</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#306">306</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#307">307</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#308">308</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#310">310</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#311">311</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#312">312</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#315">315</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#316">316</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#317">317</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#318">318</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#319">319</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#320">320</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#321">321</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#322">322</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#324">324</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#325">325</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#327">327</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#328">328</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#329">329</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#331">331</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#333">333</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#334">334</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#335">335</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#336">336</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#337">337</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#338">338</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#339">339</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#340">340</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#341">341</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#345">345</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#346">346</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#347">347</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#349">349</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#352">352</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#354">354</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#355">355</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#358">358</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#359">359</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#360">360</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#362">362</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#363">363</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#364">364</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#365">365</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#369">369</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#370">370</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#371">371</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#373">373</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#375">375</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#376">376</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#379">379</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#380">380</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#381">381</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#383">383</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#384">384</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#389">389</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#391">391</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#395">395</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#400">400</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#401">401</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#402">402</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#403">403</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#404">404</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#405">405</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#407">407</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#410">410</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#411">411</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#412">412</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#414">414</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#415">415</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#416">416</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#420">420</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#422">422</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#425">425</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#426">426</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#428">428</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#432">432</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#435">435</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#436">436</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#441">441</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#442">442</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#443">443</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#448">448</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#449">449</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#453">453</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#456">456</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#461">461</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#464">464</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#465">465</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#467">467</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#468">468</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#474">474</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#475">475</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#478">478</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#488">488</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#495">495</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#496">496</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#497">497</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#505">505</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#507">507</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#508">508</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#518">518</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#519">519</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#520">520</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#521">521</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#524">524</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#527">527</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#530">530</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#531">531</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#534">534</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#535">535</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#537">537</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#538">538</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#540">540</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#541">541</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#542">542</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#543">543</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#545">545</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#550">550</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#551">551</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#552">552</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#559">559</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#561">561</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#562">562</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#563">563</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#566">566</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#567">567</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#574">574</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#575">575</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#576">576</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#577">577</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#578">578</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#581">581</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#586">586</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#589">589</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#593">593</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#595">595</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#596">596</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#607">607</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#608">608</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#609">609</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#610">610</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#611">611</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#612">612</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#613">613</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#616">616</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#618">618</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#619">619</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#620">620</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#621">621</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#622">622</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#623">623</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#624">624</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#628">628</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#634">634</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#638">638</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#640">640</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#643">643</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#646">646</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#650">650</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#651">651</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#652">652</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#654">654</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#655">655</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#660">660</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#661">661</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#664">664</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#665">665</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#666">666</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#672">672</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#673">673</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#674">674</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#677">677</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#678">678</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#679">679</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#680">680</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#681">681</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#682">682</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#685">685</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#687">687</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#689">689</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#693">693</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#694">694</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#695">695</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#699">699</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#700">700</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#703">703</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#705">705</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#706">706</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#710">710</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#712">712</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#715">715</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#722">722</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#740">740</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#743">743</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#744">744</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#746">746</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#749">749</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#755">755</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#759">759</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#761">761</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#766">766</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#768">768</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#770">770</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#775">775</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#777">777</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#778">778</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#781">781</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#782">782</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#783">783</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#789">789</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#792">792</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#798">798</a>.</li>
<li>Changed the following issues from Open to Dup: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#670">670</a>.</li>
<li>Changed the following issues from New to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#849">849</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#855">855</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#871">871</a>.</li>
<li>Changed the following issues from Open to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#454">454</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#832">832</a>.</li>
<li>Changed the following issues from New to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#811">811</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#812">812</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#841">841</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#864">864</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#870">870</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#872">872</a>.</li>
<li>Changed the following issues from Open to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#299">299</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#484">484</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#556">556</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#631">631</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#676">676</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#704">704</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#724">724</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#742">742</a>.</li>
<li>Changed the following issues from Pending NAD Editorial to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#532">532</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#594">594</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#717">717</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#725">725</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#738">738</a>.</li>
<li>Changed the following issues from New to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#721">721</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#751">751</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#814">814</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#816">816</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#817">817</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#819">819</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#827">827</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#836">836</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#838">838</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#847">847</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#857">857</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#859">859</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#860">860</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#861">861</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#868">868</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#873">873</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#876">876</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#877">877</a>.</li>
<li>Changed the following issues from Pending NAD Editorial to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#424">424</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#625">625</a>.</li>
<li>Changed the following issues from Review to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#851">851</a>.</li>
<li>Changed the following issues from New to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#788">788</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#821">821</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#866">866</a>.</li>
<li>Changed the following issues from Open to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#753">753</a>.</li>
<li>Changed the following issues from Review to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#752">752</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#758">758</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#803">803</a>.</li>
<li>Changed the following issues from New to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#765">765</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#822">822</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#853">853</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#854">854</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#869">869</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#878">878</a>.</li>
<li>Changed the following issues from TC to TC1: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1">1</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#3">3</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#5">5</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#7">7</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#8">8</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#9">9</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#11">11</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#13">13</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#14">14</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#15">15</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#16">16</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#17">17</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#18">18</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#19">19</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#20">20</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#21">21</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#22">22</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#24">24</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#25">25</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#26">26</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#27">27</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#28">28</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#29">29</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#30">30</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#31">31</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#32">32</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#33">33</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#34">34</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#35">35</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#36">36</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#37">37</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#38">38</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#39">39</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#40">40</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#41">41</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#42">42</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#46">46</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#47">47</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#48">48</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#50">50</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#51">51</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#52">52</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#53">53</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#54">54</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#55">55</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#56">56</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#57">57</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#59">59</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#60">60</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#61">61</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#62">62</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#63">63</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#64">64</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#66">66</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#68">68</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#69">69</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#70">70</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#71">71</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#74">74</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#75">75</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#78">78</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#79">79</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#80">80</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#83">83</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#86">86</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#90">90</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#106">106</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#108">108</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#110">110</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#112">112</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#114">114</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#115">115</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#119">119</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#122">122</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#124">124</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#125">125</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#126">126</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#127">127</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#129">129</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#132">132</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#133">133</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#134">134</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#137">137</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#139">139</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#141">141</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#142">142</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#144">144</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#146">146</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#147">147</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#148">148</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#150">150</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#151">151</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#152">152</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#154">154</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#155">155</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#156">156</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#158">158</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#159">159</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#160">160</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#161">161</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#164">164</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#168">168</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#169">169</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#170">170</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#172">172</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#173">173</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#174">174</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#175">175</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#176">176</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#181">181</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#189">189</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#193">193</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#195">195</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#199">199</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#208">208</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#209">209</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#210">210</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#211">211</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#212">212</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#217">217</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#220">220</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#222">222</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#223">223</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#224">224</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#227">227</a>.</li>
</ul></li>
</ul>
</li>
<li>R59: 
2008-08-22 pre-San Francisco mailing.
<ul>
<li><b>Summary:</b><ul>
<li>192 open issues, up by 9.</li>
<li>686 closed issues, up by 0.</li>
<li>878 issues total, up by 9.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#870">870</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#871">871</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#872">872</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#873">873</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#874">874</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#875">875</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#876">876</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#877">877</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#878">878</a>.</li>
</ul></li>
</ul>
</li>
<li>R58: 
2008-07-28 mid-term mailing.
<ul>
<li><b>Summary:</b><ul>
<li>183 open issues, up by 12.</li>
<li>686 closed issues, down by 4.</li>
<li>869 issues total, up by 8.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#862">862</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#863">863</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#864">864</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#865">865</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#866">866</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#867">867</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#868">868</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#869">869</a>.</li>
<li>Changed the following issues from Pending NAD Editorial to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#393">393</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#557">557</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#592">592</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#754">754</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#757">757</a>.</li>
<li>Changed the following issues from Pending WP to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#644">644</a>.</li>
<li>Changed the following issues from WP to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#387">387</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#629">629</a>.</li>
<li>Changed the following issues from Pending NAD Editorial to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#709">709</a>.</li>
</ul></li>
</ul>
</li>
<li>R57: 
2008-06-27 post-Sophia Antipolis mailing.
<ul>
<li><b>Summary:</b><ul>
<li>171 open issues, down by 20.</li>
<li>690 closed issues, up by 43.</li>
<li>861 issues total, up by 23.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following NAD issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#840">840</a>.</li>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#841">841</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#843">843</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#845">845</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#846">846</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#847">847</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#849">849</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#853">853</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#854">854</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#855">855</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#856">856</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#857">857</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#858">858</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#859">859</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#860">860</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#861">861</a>.</li>
<li>Added the following Open issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#839">839</a>.</li>
<li>Added the following Ready issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#842">842</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#844">844</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#848">848</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#850">850</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#852">852</a>.</li>
<li>Added the following Review issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#851">851</a>.</li>
<li>Changed the following issues from New to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#826">826</a>.</li>
<li>Changed the following issues from Open to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#570">570</a>.</li>
<li>Changed the following issues from New to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#786">786</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#831">831</a>.</li>
<li>Changed the following issues from Open to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#756">756</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#767">767</a>.</li>
<li>Changed the following issues from New to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#723">723</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#726">726</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#794">794</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#815">815</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#825">825</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#830">830</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#833">833</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#834">834</a>.</li>
<li>Changed the following issues from Ready to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#471">471</a>.</li>
<li>Changed the following issues from Review to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#539">539</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#711">711</a>.</li>
<li>Changed the following issues from New to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#713">713</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#714">714</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#769">769</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#772">772</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#779">779</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#787">787</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#805">805</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#806">806</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#807">807</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#808">808</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#809">809</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#813">813</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#824">824</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#829">829</a>.</li>
<li>Changed the following issues from Open to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#180">180</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#396">396</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#522">522</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#720">720</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#762">762</a>.</li>
<li>Changed the following issues from Review to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#691">691</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#728">728</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#771">771</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#776">776</a>.</li>
<li>Changed the following issues from New to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#692">692</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#698">698</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#752">752</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#804">804</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#823">823</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#828">828</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#832">832</a>.</li>
<li>Changed the following issues from Open to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#23">23</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#675">675</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#734">734</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#803">803</a>.</li>
<li>Changed the following issues from Ready to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#758">758</a>.</li>
<li>Changed the following issues from Ready to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#387">387</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#518">518</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#550">550</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#574">574</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#595">595</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#596">596</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#612">612</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#618">618</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#629">629</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#638">638</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#672">672</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#673">673</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#685">685</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#710">710</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#715">715</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#722">722</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#740">740</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#743">743</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#744">744</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#746">746</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#749">749</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#755">755</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#759">759</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#761">761</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#766">766</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#768">768</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#770">770</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#775">775</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#777">777</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#778">778</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#781">781</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#782">782</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#783">783</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#789">789</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#792">792</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#798">798</a>.</li>
</ul></li>
</ul>
</li>
<li>R56: 
2008-05-16 pre-Sophia Antipolis mailing.
<ul>
<li><b>Summary:</b><ul>
<li>191 open issues, up by 24.</li>
<li>647 closed issues, up by 1.</li>
<li>838 issues total, up by 25.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#814">814</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#815">815</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#816">816</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#817">817</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#818">818</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#819">819</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#820">820</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#821">821</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#822">822</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#823">823</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#824">824</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#825">825</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#826">826</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#827">827</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#828">828</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#829">829</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#830">830</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#831">831</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#832">832</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#833">833</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#834">834</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#835">835</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#836">836</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#837">837</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#838">838</a>.</li>
<li>Changed the following issues from New to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#802">802</a>.</li>
</ul></li>
</ul>
</li>
<li>R55: 
2008-03-14 post-Bellevue mailing.
<ul>
<li><b>Summary:</b><ul>
<li>167 open issues, down by 39.</li>
<li>646 closed issues, up by 65.</li>
<li>813 issues total, up by 26.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following Dup issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#795">795</a>.</li>
<li>Added the following NAD issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#790">790</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#791">791</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#796">796</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#797">797</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#799">799</a>.</li>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#788">788</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#794">794</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#802">802</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#804">804</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#805">805</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#806">806</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#807">807</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#808">808</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#809">809</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#810">810</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#811">811</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#812">812</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#813">813</a>.</li>
<li>Added the following Open issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#793">793</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#800">800</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#801">801</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#803">803</a>.</li>
<li>Added the following Ready issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#789">789</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#792">792</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#798">798</a>.</li>
<li>Changed the following issues from NAD Future to Dup: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#116">116</a>.</li>
<li>Changed the following issues from NAD Future to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#188">188</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#323">323</a>.</li>
<li>Changed the following issues from New to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#729">729</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#730">730</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#731">731</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#733">733</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#735">735</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#736">736</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#737">737</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#739">739</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#741">741</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#745">745</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#748">748</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#763">763</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#764">764</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#773">773</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#784">784</a>.</li>
<li>Changed the following issues from Open to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#388">388</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#462">462</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#579">579</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#627">627</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#653">653</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#686">686</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#707">707</a>.</li>
<li>Changed the following issues from NAD Future to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#140">140</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#390">390</a>.</li>
<li>Changed the following issues from Open to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#529">529</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#626">626</a>.</li>
<li>Changed the following issues from Review to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#645">645</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#684">684</a>.</li>
<li>Changed the following issues from NAD Future to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#128">128</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#180">180</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#190">190</a>.</li>
<li>Changed the following issues from New to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#617">617</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#718">718</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#719">719</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#720">720</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#724">724</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#732">732</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#734">734</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#742">742</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#747">747</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#750">750</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#753">753</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#756">756</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#760">760</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#762">762</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#767">767</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#774">774</a>.</li>
<li>Changed the following issues from Ready to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#675">675</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#676">676</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#688">688</a>.</li>
<li>Changed the following issues from New to Pending NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#709">709</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#717">717</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#725">725</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#738">738</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#754">754</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#757">757</a>.</li>
<li>Changed the following issues from Open to Pending NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#424">424</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#557">557</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#625">625</a>.</li>
<li>Changed the following issues from New to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#710">710</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#715">715</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#722">722</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#740">740</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#743">743</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#744">744</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#746">746</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#749">749</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#755">755</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#758">758</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#759">759</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#761">761</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#766">766</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#768">768</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#770">770</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#775">775</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#777">777</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#778">778</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#781">781</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#782">782</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#783">783</a>.</li>
<li>Changed the following issues from Open to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#387">387</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#471">471</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#550">550</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#612">612</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#629">629</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#673">673</a>.</li>
<li>Changed the following issues from Review to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#518">518</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#574">574</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#596">596</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#618">618</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#638">638</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#672">672</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#685">685</a>.</li>
<li>Changed the following issues from New to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#711">711</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#728">728</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#771">771</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#776">776</a>.</li>
<li>Changed the following issues from Open to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#539">539</a>.</li>
<li>Changed the following issues from Ready to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#561">561</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#562">562</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#563">563</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#567">567</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#581">581</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#620">620</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#621">621</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#622">622</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#623">623</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#624">624</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#661">661</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#664">664</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#665">665</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#666">666</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#674">674</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#679">679</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#680">680</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#687">687</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#689">689</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#693">693</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#694">694</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#695">695</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#700">700</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#703">703</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#705">705</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#706">706</a>.</li>
<li>Changed the following issues from Tentatively Ready to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#527">527</a>.</li>
</ul></li>
</ul>
</li>
<li>R54: 
2008-02-01 pre-Bellevue mailing.
<ul>
<li><b>Summary:</b><ul>
<li>206 open issues, up by 23.</li>
<li>581 closed issues, up by 0.</li>
<li>787 issues total, up by 23.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#765">765</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#766">766</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#767">767</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#768">768</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#769">769</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#770">770</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#771">771</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#772">772</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#773">773</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#774">774</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#775">775</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#776">776</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#777">777</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#778">778</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#779">779</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#780">780</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#781">781</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#782">782</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#783">783</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#784">784</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#785">785</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#786">786</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#787">787</a>.</li>
<li>Changed the following issues from NAD Future to Dup: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#105">105</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#348">348</a>.</li>
<li>Changed the following issues from NAD Future to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#353">353</a>.</li>
<li>Changed the following issues from New to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#697">697</a>.</li>
<li>Changed the following issues from NAD Future to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#388">388</a>.</li>
<li>Changed the following issues from Open to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#527">527</a>.</li>
</ul></li>
</ul>
</li>
<li>R53: 
2007-12-09 mid-term mailing.
<ul>
<li><b>Summary:</b><ul>
<li>183 open issues, up by 11.</li>
<li>581 closed issues, down by 1.</li>
<li>764 issues total, up by 10.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#755">755</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#756">756</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#757">757</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#758">758</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#759">759</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#760">760</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#761">761</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#762">762</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#763">763</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#764">764</a>.</li>
<li>Changed the following issues from NAD to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#463">463</a>.</li>
<li>Changed the following issues from Pending WP to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#607">607</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#608">608</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#654">654</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#655">655</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#677">677</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#682">682</a>.</li>
</ul></li>
</ul>
</li>
<li>R52: 
2007-10-19 post-Kona mailing.
<ul>
<li><b>Summary:</b><ul>
<li>172 open issues, up by 4.</li>
<li>582 closed issues, up by 27.</li>
<li>754 issues total, up by 31.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#724">724</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#725">725</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#726">726</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#727">727</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#728">728</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#729">729</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#730">730</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#731">731</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#732">732</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#733">733</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#734">734</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#735">735</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#736">736</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#737">737</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#738">738</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#739">739</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#740">740</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#741">741</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#742">742</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#743">743</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#744">744</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#745">745</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#746">746</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#747">747</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#748">748</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#749">749</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#750">750</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#751">751</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#752">752</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#753">753</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#754">754</a>.</li>
<li>Changed the following issues from NAD Future to Dup: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#77">77</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#350">350</a>.</li>
<li>Changed the following issues from New to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#639">639</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#657">657</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#663">663</a>.</li>
<li>Changed the following issues from Open to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#548">548</a>.</li>
<li>Changed the following issues from New to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#546">546</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#550">550</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#564">564</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#565">565</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#573">573</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#585">585</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#588">588</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#627">627</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#629">629</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#630">630</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#632">632</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#635">635</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#653">653</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#659">659</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#667">667</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#668">668</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#669">669</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#670">670</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#671">671</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#673">673</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#686">686</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#704">704</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#707">707</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#708">708</a>.</li>
<li>Changed the following issues from New to Pending NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#393">393</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#592">592</a>.</li>
<li>Changed the following issues from New to Pending WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#607">607</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#608">608</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#654">654</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#655">655</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#677">677</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#682">682</a>.</li>
<li>Changed the following issues from New to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#561">561</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#562">562</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#563">563</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#567">567</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#581">581</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#595">595</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#620">620</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#621">621</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#622">622</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#623">623</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#624">624</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#661">661</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#664">664</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#665">665</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#666">666</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#674">674</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#675">675</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#676">676</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#679">679</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#687">687</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#688">688</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#689">689</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#693">693</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#694">694</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#695">695</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#700">700</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#703">703</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#705">705</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#706">706</a>.</li>
<li>Changed the following issues from Open to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#680">680</a>.</li>
<li>Changed the following issues from New to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#574">574</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#596">596</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#618">618</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#638">638</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#645">645</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#672">672</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#684">684</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#685">685</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#691">691</a>.</li>
<li>Changed the following issues from New to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#552">552</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#634">634</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#650">650</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#651">651</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#652">652</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#678">678</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#681">681</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#699">699</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#712">712</a>.</li>
<li>Changed the following issues from Open to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#258">258</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#401">401</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#524">524</a>.</li>
<li>Changed the following issues from Ready to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#488">488</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#577">577</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#660">660</a>.</li>
</ul></li>
</ul>
</li>
<li>R51: 
2007-09-09 pre-Kona mailing.
<ul>
<li><b>Summary:</b><ul>
<li>168 open issues, up by 15.</li>
<li>555 closed issues, up by 0.</li>
<li>723 issues total, up by 15.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#709">709</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#710">710</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#711">711</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#712">712</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#713">713</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#714">714</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#715">715</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#716">716</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#717">717</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#718">718</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#719">719</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#720">720</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#721">721</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#722">722</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#723">723</a>.</li>
</ul></li>
</ul>
</li>
<li>R50: 
2007-08-05 post-Toronto mailing.
<ul>
<li><b>Summary:</b><ul>
<li>153 open issues, down by 5.</li>
<li>555 closed issues, up by 17.</li>
<li>708 issues total, up by 12.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#697">697</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#698">698</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#699">699</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#700">700</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#701">701</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#702">702</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#703">703</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#704">704</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#705">705</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#706">706</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#707">707</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#708">708</a>.</li>
<li>Changed the following issues from New to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#583">583</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#584">584</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#662">662</a>.</li>
<li>Changed the following issues from Open to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#528">528</a>.</li>
<li>Changed the following issues from New to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#637">637</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#647">647</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#658">658</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#690">690</a>.</li>
<li>Changed the following issues from Open to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#525">525</a>.</li>
<li>Changed the following issues from Pending NAD Editorial to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#553">553</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#571">571</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#591">591</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#633">633</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#636">636</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#641">641</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#642">642</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#648">648</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#649">649</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#656">656</a>.</li>
<li>Changed the following issues from New to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#579">579</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#631">631</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#680">680</a>.</li>
<li>Changed the following issues from Pending WP to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#258">258</a>.</li>
<li>Changed the following issues from Ready to Pending WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#644">644</a>.</li>
<li>Changed the following issues from New to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#577">577</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#660">660</a>.</li>
<li>Changed the following issues from Open to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#488">488</a>.</li>
<li>Changed the following issues from Open to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#518">518</a>.</li>
<li>Changed the following issues from Ready to TRDec: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#604">604</a>.</li>
<li>Changed the following issues from DR to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#453">453</a>.</li>
<li>Changed the following issues from Ready to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#531">531</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#551">551</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#566">566</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#628">628</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#640">640</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#643">643</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#646">646</a>.</li>
</ul></li>
</ul>
</li>
<li>R49: 
2007-06-23 pre-Toronto mailing.
<ul>
<li><b>Summary:</b><ul>
<li>158 open issues, up by 13.</li>
<li>538 closed issues, up by 7.</li>
<li>696 issues total, up by 20.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#677">677</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#678">678</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#679">679</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#680">680</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#681">681</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#682">682</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#684">684</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#685">685</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#686">686</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#687">687</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#688">688</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#689">689</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#690">690</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#691">691</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#692">692</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#693">693</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#694">694</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#695">695</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#696">696</a>.</li>
<li>Added the following Pending NAD Editorial issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#683">683</a>.</li>
<li>Changed the following issues from New to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#587">587</a>.</li>
<li>Changed the following issues from Open to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#590">590</a>.</li>
<li>Changed the following issues from New to Pending NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#636">636</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#642">642</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#648">648</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#649">649</a>.</li>
</ul></li>
</ul>
</li>
<li>R48: 
2007-05-06 post-Oxford mailing.
<ul>
<li><b>Summary:</b><ul>
<li>145 open issues, down by 33.</li>
<li>531 closed issues, up by 53.</li>
<li>676 issues total, up by 20.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#657">657</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#658">658</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#659">659</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#660">660</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#661">661</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#662">662</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#663">663</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#664">664</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#665">665</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#666">666</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#667">667</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#668">668</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#669">669</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#670">670</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#671">671</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#672">672</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#673">673</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#674">674</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#675">675</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#676">676</a>.</li>
<li>Changed the following issues from Tentatively Ready to Dup: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#479">479</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#536">536</a>.</li>
<li>Changed the following issues from Tentatively Ready to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#385">385</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#463">463</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#466">466</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#470">470</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#515">515</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#526">526</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#547">547</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#560">560</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#572">572</a>.</li>
<li>Changed the following issues from NAD to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#351">351</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#357">357</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#368">368</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#499">499</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#504">504</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#512">512</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#513">513</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#514">514</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#516">516</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#544">544</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#549">549</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#555">555</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#558">558</a>.</li>
<li>Changed the following issues from Tentatively Ready to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#482">482</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#615">615</a>.</li>
<li>Changed the following issues from NAD_Future to NAD Future: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#77">77</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#105">105</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#111">111</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#116">116</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#128">128</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#138">138</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#140">140</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#149">149</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#180">180</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#188">188</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#190">190</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#219">219</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#323">323</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#348">348</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#350">350</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#353">353</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#388">388</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#390">390</a>.</li>
<li>Changed the following issues from Tentatively Ready to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#471">471</a>.</li>
<li>Changed the following issues from New to Pending NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#633">633</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#641">641</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#656">656</a>.</li>
<li>Changed the following issues from Tentatively Ready to Pending NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#532">532</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#553">553</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#571">571</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#591">591</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#594">594</a>.</li>
<li>Changed the following issues from Tentatively Ready to Pending WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#258">258</a>.</li>
<li>Changed the following issues from New to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#566">566</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#628">628</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#640">640</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#643">643</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#644">644</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#646">646</a>.</li>
<li>Changed the following issues from Review to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#531">531</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#551">551</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#604">604</a>.</li>
<li>Changed the following issues from Ready to TRDec: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#598">598</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#599">599</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#600">600</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#601">601</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#602">602</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#603">603</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#605">605</a>.</li>
<li>Changed the following issues from Ready to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#543">543</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#545">545</a>.</li>
<li>Changed the following issues from Tentatively Ready to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#201">201</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#206">206</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#233">233</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#254">254</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#416">416</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#422">422</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#456">456</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#534">534</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#542">542</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#559">559</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#575">575</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#576">576</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#578">578</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#586">586</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#589">589</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#593">593</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#609">609</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#610">610</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#611">611</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#613">613</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#616">616</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#619">619</a>.</li>
</ul></li>
</ul>
</li>
<li>R47: 
2007-03-09 pre-Oxford mailing.
<ul>
<li><b>Summary:</b><ul>
<li>178 open issues, up by 37.</li>
<li>478 closed issues, up by 0.</li>
<li>656 issues total, up by 37.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#620">620</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#621">621</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#622">622</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#623">623</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#624">624</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#627">627</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#628">628</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#629">629</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#630">630</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#631">631</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#632">632</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#633">633</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#634">634</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#635">635</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#636">636</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#637">637</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#638">638</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#639">639</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#640">640</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#641">641</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#642">642</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#643">643</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#644">644</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#645">645</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#646">646</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#647">647</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#648">648</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#649">649</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#650">650</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#651">651</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#652">652</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#653">653</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#654">654</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#655">655</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#656">656</a>.</li>
<li>Added the following Open issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#625">625</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#626">626</a>.</li>
<li>Changed the following issues from New to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#570">570</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#580">580</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#582">582</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#590">590</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#612">612</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#614">614</a>.</li>
<li>Changed the following issues from New to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#547">547</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#553">553</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#560">560</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#571">571</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#572">572</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#575">575</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#576">576</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#578">578</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#586">586</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#589">589</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#591">591</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#593">593</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#594">594</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#609">609</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#610">610</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#611">611</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#613">613</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#615">615</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#616">616</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#619">619</a>.</li>
<li>Changed the following issues from Open to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#201">201</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#206">206</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#233">233</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#254">254</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#258">258</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#385">385</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#416">416</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#422">422</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#456">456</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#463">463</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#466">466</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#470">470</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#471">471</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#479">479</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#482">482</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#515">515</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#526">526</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#532">532</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#536">536</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#542">542</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#559">559</a>.</li>
<li>Changed the following issues from Review to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#534">534</a>.</li>
</ul></li>
</ul>
</li>
<li>R46: 
2007-01-12 mid-term mailing.
<ul>
<li><b>Summary:</b><ul>
<li>141 open issues, up by 11.</li>
<li>478 closed issues, down by 1.</li>
<li>619 issues total, up by 10.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#610">610</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#611">611</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#612">612</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#613">613</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#614">614</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#615">615</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#616">616</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#617">617</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#618">618</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#619">619</a>.</li>
</ul></li>
</ul>
</li>
<li>R45: 
2006-11-03 post-Portland mailing.
<ul>
<li><b>Summary:</b><ul>
<li>130 open issues, up by 0.</li>
<li>479 closed issues, up by 17.</li>
<li>609 issues total, up by 17.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Moved issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#520">520</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#521">521</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#530">530</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#535">535</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#537">537</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#538">538</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#540">540</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#541">541</a> to WP.</li>
<li>Moved issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#504">504</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#512">512</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#516">516</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#544">544</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#549">549</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#554">554</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#555">555</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#558">558</a> to NAD.</li>
<li>Moved issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#569">569</a> to Dup.</li>
<li>Moved issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#518">518</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#523">523</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#524">524</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#542">542</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#556">556</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#557">557</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#559">559</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#597">597</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#606">606</a> to Open.</li>
<li>Moved issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#543">543</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#545">545</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#549">549</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#549">549</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#598">598</a> - <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#603">603</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#605">605</a> to Ready.</li>
<li>Moved issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#531">531</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#551">551</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#604">604</a> to Review.</li>
<li>Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#593">593</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#594">594</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#595">595</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#596">596</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#597">597</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#598">598</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#599">599</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#600">600</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#601">601</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#602">602</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#603">603</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#604">604</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#605">605</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#606">606</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#607">607</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#608">608</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#609">609</a>.</li>
</ul></li>
</ul>
</li>
<li>R44: 
2006-09-08 pre-Portland mailing.
<ul>
<li><b>Summary:</b><ul>
<li>130 open issues, up by 6.</li>
<li>462 closed issues, down by 1.</li>
<li>592 issues total, up by 5.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#583">583</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#584">584</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#585">585</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#586">586</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#587">587</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#588">588</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#589">589</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#590">590</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#591">591</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#592">592</a>.</li>
</ul></li>
</ul>
</li>
<li>R43: 
2006-06-23 mid-term mailing.
<ul>
<li><b>Summary:</b><ul>
<li>124 open issues, up by 14.</li>
<li>463 closed issues, down by 1.</li>
<li>587 issues total, up by 13.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#575">575</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#576">576</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#577">577</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#578">578</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#579">579</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#580">580</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#581">581</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#582">582</a>.</li>
<li>Reopened <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#255">255</a>.</li>
<li>Moved issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#520">520</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#541">541</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#544">544</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#569">569</a> to Tentatively Ready.</li>
</ul></li>
</ul>
</li>
<li>R42: 
2006-04-21 post-Berlin mailing.
<ul>
<li><b>Summary:</b><ul>
<li>110 open issues, down by 16.</li>
<li>464 closed issues, up by 24.</li>
<li>574 issues total, up by 8.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#567">567</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#568">568</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#569">569</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#570">570</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#571">571</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#572">572</a>.</li>
<li>Moved issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#499">499</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#501">501</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#506">506</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#509">509</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#510">510</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#511">511</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#513">513</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#514">514</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#517">517</a> to NAD.</li>
<li>Moved issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#502">502</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#503">503</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#515">515</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#516">516</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#522">522</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#525">525</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#526">526</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#527">527</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#528">528</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#529">529</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#532">532</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#536">536</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#539">539</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#548">548</a> to Open.</li>
<li>Moved issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#504">504</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#512">512</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#521">521</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#530">530</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#531">531</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#535">535</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#537">537</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#538">538</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#540">540</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#549">549</a> to Ready.</li>
<li>Moved issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#247">247</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#294">294</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#362">362</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#369">369</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#371">371</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#376">376</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#384">384</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#475">475</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#478">478</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#495">495</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#497">497</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#505">505</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#507">507</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#508">508</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#519">519</a> to WP.</li>
<li>Moved issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#534">534</a> to Review.</li>
</ul></li>
</ul>
</li>
<li>R41: 
2006-02-24 pre-Berlin mailing.
<ul>
<li><b>Summary:</b><ul>
<li>126 open issues, up by 31.</li>
<li>440 closed issues, up by 0.</li>
<li>566 issues total, up by 31.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#536">536</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#537">537</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#538">538</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#539">539</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#540">540</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#541">541</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#542">542</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#543">543</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#544">544</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#545">545</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#546">546</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#547">547</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#548">548</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#549">549</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#550">550</a> ,<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#551">551</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#552">552</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#553">553</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#554">554</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#555">555</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#556">556</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#557">557</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#558">558</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#559">559</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#560">560</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#561">561</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#562">562</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#563">563</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#564">564</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#565">565</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#566">566</a>.</li>
<li>Moved <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#342">342</a> from Ready to Open.</li>
<li>Reopened <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#309">309</a>.</li>
</ul></li>
</ul>
</li>
<li>R40: 
2005-12-16 mid-term mailing.
<ul>
<li><b>Summary:</b><ul>
<li>95 open issues.</li>
<li>440 closed issues.</li>
<li>535 issues total.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#529">529</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#530">530</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#531">531</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#532">532</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#533">533</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#534">534</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#535">535</a>.</li>
</ul></li>
</ul>
</li>
<li>R39: 
2005-10-14 post-Mont Tremblant mailing.
Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#526">526</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#528">528</a>.
Moved issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#280">280</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#461">461</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#464">464</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#465">465</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#467">467</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#468">468</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#474">474</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#496">496</a> from Ready to WP as per the vote from Mont Tremblant.
Moved issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#247">247</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#294">294</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#342">342</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#362">362</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#369">369</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#371">371</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#376">376</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#384">384</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#475">475</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#478">478</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#495">495</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#497">497</a> from Review to Ready.
Moved issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#498">498</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#504">504</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#506">506</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#509">509</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#510">510</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#511">511</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#512">512</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#513">513</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#514">514</a> from New to Open.
Moved issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#505">505</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#507">507</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#508">508</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#519">519</a> from New to Ready.
Moved issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#500">500</a> from New to NAD.
Moved issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#518">518</a> from New to Review.
</li>
<li>R38: 
2005-07-03 pre-Mont Tremblant mailing.
Merged open TR1 issues in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#504">504</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#522">522</a>.
Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#523">523</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#523">523</a>
</li>
<li>R37: 
2005-06 mid-term mailing.
Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#498">498</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#503">503</a>.
</li>
<li>R36: 
2005-04 post-Lillehammer mailing. All issues in "ready" status except
for <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#454">454</a> were moved to "DR" status, and all issues
previously in "DR" status were moved to "WP".
</li>
<li>R35: 
2005-03 pre-Lillehammer mailing.
</li>
<li>R34: 
2005-01 mid-term mailing.  Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#488">488</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#494">494</a>.
</li>
<li>R33: 
2004-11 post-Redmond mailing. Reflects actions taken in Redmond.
</li>
<li>R32: 
2004-09 pre-Redmond mailing: reflects new proposed resolutions and
new issues received after the 2004-07 mailing.  Added
new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#479">479</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#481">481</a>.
</li>
<li>R31: 
2004-07 mid-term mailing: reflects new proposed resolutions and
new issues received after the post-Sydney mailing.  Added
new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#463">463</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#478">478</a>.
</li>
<li>R30: 
Post-Sydney mailing: reflects decisions made at the Sydney meeting.
Voted all "Ready" issues from R29 into the working paper.
Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#460">460</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#462">462</a>.
</li>
<li>R29: 
Pre-Sydney mailing.  Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#441">441</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#457">457</a>.
</li>
<li>R28: 
Post-Kona mailing: reflects decisions made at the Kona meeting.
Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#432">432</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#440">440</a>.
</li>
<li>R27: 
Pre-Kona mailing.  Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#404">404</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#431">431</a>.
</li>
<li>R26: 
Post-Oxford mailing: reflects decisions made at the Oxford meeting.
All issues in Ready status were voted into DR status.  All issues in
DR status were voted into WP status.
</li>
<li>R25: 
Pre-Oxford mailing.  Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#390">390</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#402">402</a>.
</li>
<li>R24: 
Post-Santa Cruz mailing: reflects decisions made at the Santa Cruz
meeting.  All Ready issues from R23 with the exception of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#253">253</a>, which has been given a new proposed resolution, were
moved to DR status.  Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#383">383</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#389">389</a>.  (Issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#387">387</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#389">389</a> were discussed
at the meeting.)  Made progress on issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#225">225</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#226">226</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#229">229</a>: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#225">225</a> and <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#229">229</a> have been moved to Ready status, and the only remaining
concerns with <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#226">226</a> involve wording.
</li>
<li>R23: 
Pre-Santa Cruz mailing.  Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#367">367</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#382">382</a>.
Moved issues in the TC to TC status.
</li>
<li>R22: 
Post-Curaao mailing.  Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#362">362</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#366">366</a>.
</li>
<li>R21: 
Pre-Curaao mailing.  Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#351">351</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#361">361</a>.
</li>
<li>R20: 
Post-Redmond mailing; reflects actions taken in Redmond.  Added
new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#336">336</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#350">350</a>, of which issues 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#347">347</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#350">350</a> were added since Redmond, hence
not discussed at the meeting.  

All Ready issues were moved to DR status, with the exception of issues
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#284">284</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#241">241</a>, and <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#267">267</a>.

Noteworthy issues discussed at Redmond include 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#120">120</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#202">202</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#226">226</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#233">233</a>, 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#270">270</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#253">253</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#254">254</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#323">323</a>.
</li>
<li>R19: 
Pre-Redmond mailing.  Added new issues 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#323">323</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#335">335</a>.
</li>
<li>R18: 
Post-Copenhagen mailing; reflects actions taken in Copenhagen.
Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#312">312</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#317">317</a>, and discussed
new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#271">271</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#314">314</a>.

Changed status of issues
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#103">103</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#118">118</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#136">136</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#153">153</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#165">165</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#171">171</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#183">183</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#184">184</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#185">185</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#186">186</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#214">214</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#221">221</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#234">234</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#237">237</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#243">243</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#248">248</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#251">251</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#252">252</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#256">256</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#260">260</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#261">261</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#262">262</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#263">263</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#265">265</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#268">268</a>
to DR.

Changed status of issues
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#49">49</a>  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#109">109</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#117">117</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#182">182</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#228">228</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#230">230</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#232">232</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#235">235</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#238">238</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#241">241</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#242">242</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#250">250</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#259">259</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#264">264</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#266">266</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#267">267</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#271">271</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#272">272</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#273">273</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#275">275</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#281">281</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#284">284</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#285">285</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#286">286</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#288">288</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#292">292</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#295">295</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#297">297</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#298">298</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#301">301</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#303">303</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#306">306</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#307">307</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#308">308</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#312">312</a>
to Ready.

Closed issues 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#111">111</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#277">277</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#279">279</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#287">287</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#289">289</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#293">293</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#302">302</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#313">313</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#314">314</a>
as NAD.

</li>
<li>R17: 
Pre-Copenhagen mailing.  Converted issues list to XML.  Added proposed
resolutions for issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#49">49</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#76">76</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#91">91</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#235">235</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#250">250</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#267">267</a>.
Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#278">278</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#311">311</a>.
</li>
<li>R16:  
post-Toronto mailing; reflects actions taken in Toronto. Added new
issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#265">265</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#277">277</a>.  Changed status of issues
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#3">3</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#8">8</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#9">9</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#19">19</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#26">26</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#31">31</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#61">61</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#63">63</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#86">86</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#108">108</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#112">112</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#114">114</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#115">115</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#122">122</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#127">127</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#129">129</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#134">134</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#137">137</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#142">142</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#144">144</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#146">146</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#147">147</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#159">159</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#164">164</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#170">170</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#181">181</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#199">199</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#208">208</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#209">209</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#210">210</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#211">211</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#212">212</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#217">217</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#220">220</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#222">222</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#223">223</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#224">224</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#227">227</a> to "DR".  Reopened issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#23">23</a>. Reopened
issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#187">187</a>. Changed issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#2">2</a> and
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#4">4</a> to NAD. Fixed a typo in issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#17">17</a>. Fixed
issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#70">70</a>: signature should be changed both places it
appears. Fixed issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#160">160</a>: previous version didn't fix
the bug in enough places.
</li>
<li>R15: 
pre-Toronto mailing. Added issues
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#233">233</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#264">264</a>. Some small HTML formatting
changes so that we pass Weblint tests.
</li>
<li>R14: 
post-Tokyo II mailing; reflects committee actions taken in
Tokyo. Added issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#228">228</a> to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#232">232</a>. (00-0019R1/N1242)
</li>
<li>R13: 
pre-Tokyo II updated: Added issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#212">212</a> to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#227">227</a>.
</li>
<li>R12: 
pre-Tokyo II mailing: Added issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#199">199</a> to
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#211">211</a>. Added "and paragraph 5" to the proposed resolution
of issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#29">29</a>.  Add further rationale to issue
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#178">178</a>.
</li>
<li>R11: 
post-Kona mailing: Updated to reflect LWG and full committee actions
in Kona (99-0048/N1224). Note changed resolution of issues
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#4">4</a> and <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#38">38</a>. Added issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#196">196</a>
to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#198">198</a>. Closed issues list split into "defects" and
"closed" documents.  Changed the proposed resolution of issue
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#4">4</a> to NAD, and changed the wording of proposed resolution
of issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#38">38</a>.
</li>
<li>R10: 
pre-Kona updated.  Added proposed resolutions <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#83">83</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#86">86</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#91">91</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#92">92</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#109">109</a>. Added issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#190">190</a> to
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#195">195</a>. (99-0033/D1209, 14 Oct 99)
</li>
<li>R9: 
pre-Kona mailing.  Added issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#140">140</a> to
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#189">189</a>. Issues list split into separate "active" and
"closed" documents. (99-0030/N1206, 25 Aug 99)
</li>
<li>R8: 
post-Dublin mailing. Updated to reflect LWG and full committee actions
in Dublin. (99-0016/N1193, 21 Apr 99)
</li>
<li>R7: 
pre-Dublin updated: Added issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#130">130</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#131">131</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#132">132</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#133">133</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#134">134</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#135">135</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#136">136</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#137">137</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#138">138</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#139">139</a> (31 Mar 99)
</li>
<li>R6: 
pre-Dublin mailing. Added issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#127">127</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#128">128</a>,
and <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#129">129</a>.  (99-0007/N1194, 22 Feb 99)
</li>
<li>R5: 
update issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#103">103</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#112">112</a>; added issues
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#114">114</a> to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#126">126</a>. Format revisions to prepare
for making list public. (30 Dec 98)
</li>
<li>R4: 
post-Santa Cruz II updated: Issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#110">110</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#111">111</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#112">112</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#113">113</a> added, several
issues corrected. (22 Oct 98)
</li>
<li>R3: 
post-Santa Cruz II: Issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#94">94</a> to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#109">109</a>
added, many issues updated to reflect LWG consensus (12 Oct 98)
</li>
<li>R2: 
pre-Santa Cruz II: Issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#73">73</a> to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#93">93</a> added,
issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#17">17</a> updated. (29 Sep 98)
</li>
<li>R1: 
Correction to issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#55">55</a> resolution, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#60">60</a> code
format, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#64">64</a> title. (17 Sep 98)
</li>
</ul>

<h2>Closed Issues</h2>
<hr>
<h3><a name="2"></a>2. Auto_ptr conversions effects incorrect</h3>
<p><b>Section:</b> D.10.1.3 [auto.ptr.conv] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Nathan Myers <b>Opened:</b> 1997-12-04  <b>Last modified:</b> 2006-12-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>Paragraph 1 in "Effects", says "Calls
p-&gt;release()" where it clearly must be "Calls
p.release()". (As it is, it seems to require using
auto_ptr&lt;&gt;::operator-&gt; to refer to X::release, assuming that
exists.)</p>


<p><b>Proposed resolution:</b></p>
<p>Change 20.6.4.3 [meta.unary.prop] paragraph 1 Effects from 
"Calls p-&gt;release()" to "Calls p.release()".</p>


<p><b>Rationale:</b></p>
<p>Not a defect: the proposed change is already found in the standard.
[Originally classified as a defect, later reclassified.]</p>





<hr>
<h3><a name="4"></a>4. Basic_string size_type and difference_type should be implementation defined</h3>
<p><b>Section:</b> 21.4 [basic.string] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Beman Dawes <b>Opened:</b> 1997-11-16  <b>Last modified:</b> 2006-12-27</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#basic.string">issues</a> in [basic.string].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>In Morristown we changed the size_type and difference_type typedefs
for all the other containers to implementation defined with a
reference to 23.2 [container.requirements].  This should probably also have been
done for strings. </p>


<p><b>Rationale:</b></p>
<p>Not a defect.  [Originally classified as a defect, later
reclassified.]  basic_string, unlike the other standard library
template containers, is severely constrained by its use of
char_traits. Those types are dictated by the traits class, and are far
from implementation defined.</p>





<hr>
<h3><a name="6"></a>6. File position not an offset unimplementable</h3>
<p><b>Section:</b> 27.5.3 [fpos] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 1997-12-15  <b>Last modified:</b> 2006-12-27</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#fpos">issues</a> in [fpos].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>Table 88, in I/O, is too strict; it's unimplementable on systems
where a file position isn't just an offset. It also never says just
what fpos&lt;&gt; is really supposed to be.  [Here's my summary, which
Jerry agrees is more or less accurate. "I think I now know what
the class really is, at this point: it's a magic cookie that
encapsulates an mbstate_t and a file position (possibly represented as
an fpos_t), it has syntactic support for pointer-like arithmetic, and
implementors are required to have real, not just syntactic, support
for arithmetic." This isn't standardese, of course.] </p>


<p><b>Rationale:</b></p>
<p>Not a defect. The LWG believes that the Standard is already clear,
and that the above summary is what the Standard in effect says.</p>





<hr>
<h3><a name="10"></a>10. Codecvt&lt;&gt;::do unclear</h3>
<p><b>Section:</b> 22.4.1.5 [locale.codecvt.byname] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 1998-01-14  <b>Last modified:</b> 2006-12-30</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.codecvt.byname">issues</a> in [locale.codecvt.byname].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#19">19</a></p>
<p><b>Discussion:</b></p>
<p>Section 22.2.1.5.2 says that codecvt&lt;&gt;::do_in and do_out
should return the value noconv if "no conversion was
needed". However, I don't see anything anywhere that defines what
it means for a conversion to be needed or not needed. I can think of
several circumstances where one might plausibly think that a
conversion is not "needed", but I don't know which one is
intended here. </p>


<p><b>Rationale:</b></p>






<hr>
<h3><a name="12"></a>12. Way objects hold allocators unclear</h3>
<p><b>Section:</b> 20.2.2 [allocator.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Angelika Langer <b>Opened:</b> 1998-02-23  <b>Last modified:</b> 2006-12-30</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#allocator.requirements">issues</a> in [allocator.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>I couldn't find a statement in the standard saying whether the allocator object held by
a container is held as a copy of the constructor argument or whether a pointer of
reference is maintained internal. There is an according statement for compare objects and
how they are maintained by the associative containers, but I couldn't find anything
regarding allocators. </p>

<p>Did I overlook it? Is it an open issue or known defect? Or is it deliberately left
unspecified? </p>


<p><b>Rationale:</b></p>
<p>Not a defect. The LWG believes that the Standard is already
clear.&nbsp; See 23.2 [container.requirements], paragraph 8.</p>





<hr>
<h3><a name="43"></a>43. Locale table correction</h3>
<p><b>Section:</b> 22.4.1.5 [locale.codecvt.byname] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Brendan Kehoe <b>Opened:</b> 1998-06-01  <b>Last modified:</b> 2006-12-30</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.codecvt.byname">issues</a> in [locale.codecvt.byname].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#33">33</a></p>
<p><b>Discussion:</b></p>


<p><b>Rationale:</b></p>






<hr>
<h3><a name="45"></a>45. Stringstreams read/write pointers initial position unclear</h3>
<p><b>Section:</b> 27.8.3 [ostringstream] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Matthias Mueller <b>Opened:</b> 1998-05-27  <b>Last modified:</b> 2006-12-27</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>In a comp.lang.c++.moderated Matthias Mueller wrote:</p>

<p>"We are not sure how to interpret the CD2 (see 27.3
[iostream.forward], 27.8.3.1 [ostringstream.cons], 27.8.1.1
[stringbuf.cons])
with respect to the question as to what the correct initial positions
of the write and&nbsp; read pointers of a stringstream should
be."</p>

<p>"Is it the same to output two strings or to initialize the stringstream with the
first and to output the second?"</p>

<p><i>[PJ Plauger, Bjarne Stroustrup, Randy Smithey, Sean Corfield, and
Jerry Schwarz have all offered opinions; see reflector messages
lib-6518, 6519, 6520, 6521, 6523, 6524.]</i></p>




<p><b>Rationale:</b></p>
<p>The LWG believes the Standard is correct as written. The behavior
of stringstreams is consistent with fstreams, and there is a
constructor which can be used to obtain the desired effect. This
behavior is known to be different from strstreams.</p>





<hr>
<h3><a name="58"></a>58. Extracting a char from a wide-oriented stream</h3>
<p><b>Section:</b> 27.7.1.2.3 [istream::extractors] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 1998-07-01  <b>Last modified:</b> 2006-12-27</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#istream::extractors">issues</a> in [istream::extractors].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>27.6.1.2.3 has member functions for extraction of signed char and
unsigned char, both singly and as strings. However, it doesn't say
what it means to extract a <tt>char</tt> from a
<tt>basic_streambuf&lt;charT, Traits&gt;</tt>. </p>

<p>basic_streambuf, after all, has no members to extract a char, so
basic_istream must somehow convert from charT to signed char or
unsigned char. The standard doesn't say how it is to perform that
conversion. </p>


<p><b>Rationale:</b></p>
<p>The Standard is correct as written.  There is no such extractor and
this is the intent of the LWG.</p>




<hr>
<h3><a name="65"></a>65. Underspecification of strstreambuf::seekoff</h3>
<p><b>Section:</b> D.8.1.3 [depr.strstreambuf.virtuals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 1998-08-18  <b>Last modified:</b> 2006-12-27</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#depr.strstreambuf.virtuals">issues</a> in [depr.strstreambuf.virtuals].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>The standard says how this member function affects the current
stream position. (<tt>gptr</tt> or <tt>pptr</tt>) However, it does not
say how this member function affects the beginning and end of the
get/put area. </p>

<p>This is an issue when seekoff is used to position the get pointer
beyond the end of the current read area. (Which is legal. This is
implicit in the definition of <i>seekhigh</i> in D.7.1, paragraph 4.)
</p>


<p><b>Rationale:</b></p>
<p>The LWG agrees that seekoff() is underspecified, but does not wish
to invest effort in this deprecated feature.</p>





<hr>
<h3><a name="67"></a>67. Setw useless for strings</h3>
<p><b>Section:</b> 21.4.8.9 [string.io] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Steve Clamage <b>Opened:</b> 1998-07-09  <b>Last modified:</b> 2006-12-30</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#string.io">issues</a> in [string.io].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#25">25</a></p>
<p><b>Discussion:</b></p>
<p>In a comp.std.c++ posting Michel Michaud wrote: What
should be output by: </p>

<pre>   string text("Hello");
   cout &lt;&lt; '[' &lt;&lt; setw(10) &lt;&lt; right &lt;&lt; text &lt;&lt; ']';
</pre>

<p>Shouldn't it be:</p>

<pre>   [     Hello]</pre>

<p>Another person replied: Actually, according to the FDIS, the width
of the field should be the minimum of width and the length of the
string, so the output shouldn't have any padding. I think that this is
a typo, however, and that what is wanted is the maximum of the
two. (As written, setw is useless for strings. If that had been the
intent, one wouldn't expect them to have mentioned using its value.)
</p>

<p>It's worth pointing out that this is a recent correction anyway;
IIRC, earlier versions of the draft forgot to mention formatting
parameters whatsoever.</p>


<p><b>Rationale:</b></p>






<hr>
<h3><a name="72"></a>72. Do_convert phantom member function</h3>
<p><b>Section:</b> 22.4.1.4 [locale.codecvt] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Nathan Myers <b>Opened:</b> 1998-08-24  <b>Last modified:</b> 2006-12-30</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.codecvt">issues</a> in [locale.codecvt].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#24">24</a></p>
<p><b>Discussion:</b></p>
<p>In 22.4.1.4 [locale.codecvt] par 3, and in 22.4.1.4.2 [locale.codecvt.virtuals] par 8, a nonexistent member function
"do_convert" is mentioned. This member was replaced with
"do_in" and "do_out", the proper referents in the
contexts above.</p>


<p><b>Rationale:</b></p>





<hr>
<h3><a name="73"></a>73. <tt>is_open</tt> should be const</h3>
<p><b>Section:</b> 27.9.1 [fstreams] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 1998-08-27  <b>Last modified:</b> 2006-12-27</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#fstreams">issues</a> in [fstreams].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>Classes <tt>basic_ifstream</tt>, <tt>basic_ofstream</tt>, and
<tt>basic_fstream</tt> all have a member function <tt>is_open</tt>. It
should be a <tt>const</tt> member function, since it does nothing but
call one of <tt>basic_filebuf</tt>'s const member functions. </p>


<p><b>Rationale:</b></p>
<p>Not a defect. This is a deliberate feature; const streams would be
meaningless.</p>




<hr>
<h3><a name="77"></a>77. Valarray operator[] const returning value</h3>
<p><b>Section:</b> 26.6.2.3 [valarray.access] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Levente Farkas <b>Opened:</b> 1998-09-09  <b>Last modified:</b> 2007-10-11</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#valarray.access">issues</a> in [valarray.access].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#389">389</a></p>
<p><b>Discussion:</b></p>
<p>valarray:<br>
<br>
&nbsp;&nbsp;&nbsp; <tt>T operator[] (size_t) const;</tt><br>
<br>
why not <br>
<br>
&nbsp;&nbsp;&nbsp; <tt>const T&amp; operator[] (size_t) const;</tt><br>
<br>
as in vector ???<br>
<br>
One can't copy even from a const valarray eg:<br>
<br>
&nbsp;&nbsp;&nbsp; <tt>memcpy(ptr, &amp;v[0], v.size() * sizeof(double));<br>
</tt><br>
[I] find this bug in valarray is very difficult.</p>


<p><b>Rationale:</b></p>
<p>The LWG believes that the interface was deliberately designed that
way. That is what valarray was designed to do; that's where the
"value array" name comes from. LWG members further comment
that "we don't want valarray to be a full STL container."
26.6.2.3 [valarray.access] specifies properties that indicate "an
absence of aliasing" for non-constant arrays; this allows
optimizations, including special hardware optimizations, that are not
otherwise possible. </p>





<hr>
<h3><a name="81"></a>81. Wrong declaration of slice operations</h3>
<p><b>Section:</b> 26.6.5 [template.slice.array], 26.6.7 [template.gslice.array], 26.6.8 [template.mask.array], 26.6.9 [template.indirect.array] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Nico Josuttis <b>Opened:</b> 1998-09-29  <b>Last modified:</b> 2006-12-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#template.slice.array">issues</a> in [template.slice.array].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>Isn't the definition of copy constructor and assignment operators wrong?
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Instead of</p>

<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; slice_array(const slice_array&amp;); 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; slice_array&amp; operator=(const slice_array&amp;);</pre>

<p>IMHO they have to be</p>

<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;slice_array(const slice_array&lt;T&gt;&amp;); 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;slice_array&amp; operator=(const slice_array&lt;T&gt;&amp;);</pre>

<p>Same for gslice_array. </p>


<p><b>Rationale:</b></p>
<p>Not a defect. The Standard is correct as written. </p>




<hr>
<h3><a name="82"></a>82. Missing constant for set elements</h3>
<p><b>Section:</b> 23.2.4 [associative.reqmts] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Nico Josuttis <b>Opened:</b> 1998-09-29  <b>Last modified:</b> 2007-01-15</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#associative.reqmts">active issues</a> in [associative.reqmts].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#associative.reqmts">issues</a> in [associative.reqmts].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>Paragraph 5 specifies:</p>

<blockquote><p>
For set and multiset the value type is the same as the key type. For
map and multimap it is equal to pair&lt;const Key, T&gt;.  
</p></blockquote>

<p>Strictly speaking, this is not correct because for set and multiset
the value type is the same as the <b>constant</b> key type.</p>


<p><b>Rationale:</b></p>
<p>Not a defect. The Standard is correct as written; it uses a
different mechanism (const &amp;) for <tt>set</tt> and
<tt>multiset</tt>. See issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#103">103</a> for a related
issue.</p>




<hr>
<h3><a name="84"></a>84. Ambiguity with string::insert()</h3>
<p><b>Section:</b> 21.4.5 [string.access] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Nico Josuttis <b>Opened:</b> 1998-09-29  <b>Last modified:</b> 2006-12-27</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>If I try</p>
<pre>    s.insert(0,1,' ');</pre>

<p>&nbsp; I get an nasty ambiguity. It might be</p>
<pre>    s.insert((size_type)0,(size_type)1,(charT)' ');</pre>

<p>which inserts 1 space character at position 0, or</p>
<pre>    s.insert((char*)0,(size_type)1,(charT)' ')</pre>

<p>which inserts 1 space character at iterator/address 0 (bingo!), or</p>
<pre>    s.insert((char*)0, (InputIterator)1, (InputIterator)' ')</pre>

<p>which normally inserts characters from iterator 1 to iterator '
'. But according to 23.1.1.9 (the "do the right thing" fix)
it is equivalent to the second. However, it is still ambiguous,
because of course I mean the first!</p>


<p><b>Rationale:</b></p>
<p>Not a defect. The LWG believes this is a "genetic
misfortune" inherent in the design of string and thus not a
defect in the Standard as such .</p>




<hr>
<h3><a name="85"></a>85. String char types</h3>
<p><b>Section:</b> 21 [strings] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Nico Josuttis <b>Opened:</b> 1998-09-29  <b>Last modified:</b> 2006-12-27</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#strings">issues</a> in [strings].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>The standard seems not to require that charT is equivalent to
traits::char_type. So, what happens if charT is not equivalent to
traits::char_type?</p>


<p><b>Rationale:</b></p>
<p>There is already wording in 21.2 [char.traits] paragraph 3 that
requires them to be the same.</p>




<hr>
<h3><a name="87"></a>87. Error in description of string::compare()</h3>
<p><b>Section:</b> 21.4.6.8 [string::swap] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Nico Josuttis <b>Opened:</b> 1998-09-29  <b>Last modified:</b> 2006-12-30</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#string::swap">issues</a> in [string::swap].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#5">5</a></p>
<p><b>Discussion:</b></p>
<p>The following compare() description is obviously a bug:</p>

<pre>int compare(size_type pos, size_type n1, 
            charT *s, size_type n2 = npos) const;
</pre>

<p>because without passing n2 it should compare up to the end of the
string instead of comparing npos characters (which throws an
exception) </p>


<p><b>Rationale:</b></p>





<hr>
<h3><a name="88"></a>88. Inconsistency between string::insert() and string::append()</h3>
<p><b>Section:</b> 21.4.6.4 [string::insert], 21.4.6.2 [string::append] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Nico Josuttis <b>Opened:</b> 1998-09-29  <b>Last modified:</b> 2006-12-27</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#string::insert">issues</a> in [string::insert].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>Why does </p>
<pre>  template&lt;class InputIterator&gt; 
       basic_string&amp; append(InputIterator first, InputIterator last);</pre>

<p>return a string, while</p>
<pre>  template&lt;class InputIterator&gt; 
       void insert(iterator p, InputIterator first, InputIterator last);</pre>

<p>returns nothing ?</p>


<p><b>Rationale:</b></p>
<p>The LWG believes this stylistic inconsistency is not sufficiently 
serious to constitute a defect.</p>




<hr>
<h3><a name="89"></a>89. Missing throw specification for string::insert() and string::replace()</h3>
<p><b>Section:</b> 21.4.6.4 [string::insert], 21.4.6.6 [string::replace] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Nico Josuttis <b>Opened:</b> 1998-09-29  <b>Last modified:</b> 2006-12-30</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#string::insert">issues</a> in [string::insert].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#83">83</a></p>
<p><b>Discussion:</b></p>
<p>All insert() and replace() members for strings with an iterator as
first argument lack a throw specification. The throw
specification should probably be: length_error if size exceeds
maximum. </p>


<p><b>Rationale:</b></p>
<p>Considered a duplicate because it will be solved by the resolution
of issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#83">83</a>.</p>





<hr>
<h3><a name="93"></a>93. Incomplete Valarray Subset Definitions</h3>
<p><b>Section:</b> 26.6 [numarray] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Nico Josuttis <b>Opened:</b> 1998-09-29  <b>Last modified:</b> 2006-12-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#numarray">issues</a> in [numarray].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>You can easily create subsets, but you can't easily combine them
with other subsets.  Unfortunately, you almost always needs an
explicit type conversion to valarray. This is because the standard
does not specify that valarray subsets provide the same operations as
valarrays. </p>

<p>For example, to multiply two subsets and assign the result to a third subset, you can't
write the following:</p>

<pre>va[slice(0,4,3)] = va[slice(1,4,3)] * va[slice(2,4,3)];</pre>

<p>Instead, you have to code as follows:</p>

<pre>va[slice(0,4,3)] = static_cast&lt;valarray&lt;double&gt; &gt;(va[slice(1,4,3)]) * 
                   static_cast&lt;valarray&lt;double&gt; &gt;(va[slice(2,4,3)]);</pre>

<p>This is tedious and error-prone. Even worse, it costs performance because each cast
creates a temporary objects, which could be avoided without the cast. </p>


<p><b>Proposed resolution:</b></p>
<p>Extend all valarray subset types so that they offer all valarray operations.</p>


<p><b>Rationale:</b></p>
<p>This is not a defect in the Standard; it is a request for an extension.</p>




<hr>
<h3><a name="94"></a>94. May library implementors add template parameters to Standard Library classes?</h3>
<p><b>Section:</b> 17.6.4 [conforming] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 1998-01-22  <b>Last modified:</b> 2006-12-27</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>Is it a permitted extension for library implementors to add template parameters to
standard library classes, provided that those extra parameters have defaults? For example,
instead of defining <tt>template &lt;class T, class Alloc = allocator&lt;T&gt; &gt; class
vector;</tt> defining it as <tt>template &lt;class T, class Alloc = allocator&lt;T&gt;,
int N = 1&gt; class vector;</tt> </p>

<p>The standard may well already allow this (I can't think of any way that this extension
could break a conforming program, considering that users are not permitted to
forward-declare standard library components), but it ought to be explicitly permitted or
forbidden. </p>

<p>comment from Steve Cleary via comp.std.c++:</p>
<blockquote>
<p>I disagree [with the proposed resolution] for the following reason:
consider user library code with template template parameters. For
example, a user library object may be templated on the type of
underlying sequence storage to use (deque/list/vector), since these
classes all take the same number and type of template parameters; this
would allow the user to determine the performance tradeoffs of the
user library object. A similar example is a user library object
templated on the type of underlying set storage (set/multiset) or map
storage (map/multimap), which would allow users to change (within
reason) the semantic meanings of operations on that object.</p>
<p>I think that additional template parameters should be forbidden in
the Standard classes. Library writers don't lose any expressive power,
and can still offer extensions because additional template parameters
may be provided by a non-Standard implementation class:</p>
<pre> 
   template &lt;class T, class Allocator = allocator&lt;T&gt;, int N = 1&gt;
   class __vector
   { ... };
   template &lt;class T, class Allocator = allocator&lt;T&gt; &gt;
   class vector: public __vector&lt;T, Allocator&gt;
   { ... };
</pre>

</blockquote>



<p><b>Proposed resolution:</b></p>
<p>Add a new subclause [presumably 17.4.4.9] following 17.6.4.11 [res.on.exception.handling]:</p>

<blockquote>
  <p>17.4.4.9 Template Parameters</p> <p>A specialization of a
  template class described in the C++ Standard Library behaves the
  same as if the implementation declares no additional template
  parameters.</p> <p>Footnote: Additional template parameters with
  default values are thus permitted.</p>
</blockquote>

<p>Add "template parameters" to the list of subclauses at
the end of 17.6.4 [conforming] paragraph 1.</p>

<p><i>[Kona: The LWG agreed the standard needs clarification. After
discussion with John Spicer, it seems added template parameters can be
detected by a program using template-template parameters. A straw vote
- "should implementors be allowed to add template
parameters?" found no consensus ; 5 - yes, 7 - no.]</i></p>




<p><b>Rationale:</b></p>
<p>
There is no ambiguity; the standard is clear as written.  Library
implementors are not permitted to add template parameters to standard
library classes.  This does not fall under the "as if" rule,
so it would be permitted only if the standard gave explicit license
for implementors to do this.  This would require a change in the 
standard.
</p>

<p>
The LWG decided against making this change, because it would break
user code involving template template parameters or specializations
of standard library class templates.
</p>





<hr>
<h3><a name="95"></a>95. Members added by the implementation</h3>
<p><b>Section:</b> 17.6.4.5 [member.functions] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> AFNOR <b>Opened:</b> 1998-10-07  <b>Last modified:</b> 2006-12-27</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>In 17.3.4.4/2 vs 17.3.4.7/0 there is a hole; an implementation could add virtual
members a base class and break user derived classes.</p>

<p>Example: </p>

<blockquote>
  <pre>// implementation code:
struct _Base { // _Base is in the implementer namespace
        virtual void foo ();
};
class vector : _Base // deriving from a class is allowed
{ ... };

// user code:
class vector_checking : public vector 
{
        void foo (); // don't want to override _Base::foo () as the 
                     // user doesn't know about _Base::foo ()
};</pre>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>Clarify the wording to make the example illegal.</p>


<p><b>Rationale:</b></p>
<p>This is not a defect in the Standard.&nbsp; The example is already
illegal.&nbsp; See 17.6.4.5 [member.functions] paragraph 2.</p>




<hr>
<h3><a name="96"></a>96. Vector&lt;bool&gt; is not a container</h3>
<p><b>Section:</b> 23.3.6 [vector] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> AFNOR <b>Opened:</b> 1998-10-07  <b>Last modified:</b> 2009-10-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#vector">issues</a> in [vector].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><tt>vector&lt;bool&gt;</tt> is not a container as its reference and
pointer types are not references and pointers. </p>

<p>Also it forces everyone to have a space optimization instead of a
speed one.</p>

<p><b>See also:</b> 99-0008 == N1185 Vector&lt;bool&gt; is
Nonconforming, Forces Optimization Choice.</p>

<p><i>[In Santa Cruz the LWG felt that this was Not A Defect.]</i></p>


<p><i>[In Dublin many present felt that failure to meet Container
requirements was a defect. There was disagreement as to whether
or not the optimization requirements constituted a defect.]</i></p>


<p><i>[The LWG looked at the following resolutions in some detail:
<br>
&nbsp;&nbsp;&nbsp;&nbsp; * Not A Defect.<br>
&nbsp;&nbsp;&nbsp;&nbsp; * Add a note explaining that vector&lt;bool&gt; does not meet
Container requirements.<br>
&nbsp;&nbsp;&nbsp;&nbsp; * Remove vector&lt;bool&gt;.<br>
&nbsp;&nbsp;&nbsp;&nbsp; * Add a new category of container requirements which
vector&lt;bool&gt; would meet.<br>
&nbsp;&nbsp;&nbsp;&nbsp; * Rename vector&lt;bool&gt;.<br>
<br>
No alternative had strong, wide-spread, support and every alternative
had at least one "over my dead body" response.<br>
<br>
There was also mention of a transition scheme something like (1) add
vector_bool and deprecate vector&lt;bool&gt; in the next standard. (2)
Remove vector&lt;bool&gt; in the following standard.]</i></p>


<p><i>[Modifying container requirements to permit returning proxies
(thus allowing container requirements conforming vector&lt;bool&gt;)
was also discussed.]</i></p>


<p><i>[It was also noted that there is a partial but ugly workaround in
that vector&lt;bool&gt; may be further specialized with a customer
allocator.]</i></p>


<p><i>[Kona: Herb Sutter presented his paper J16/99-0035==WG21/N1211,
vector&lt;bool&gt;: More Problems, Better Solutions. Much discussion
of a two step approach: a) deprecate, b) provide replacement under a
new name.  LWG straw vote on that: 1-favor, 11-could live with, 2-over
my dead body.  This resolution was mentioned in the LWG report to the
full committee, where several additional committee members indicated
over-my-dead-body positions.]</i></p>


<p>Discussed at Lillehammer.  General agreement that we should
  deprecate vector&lt;bool&gt; and introduce this functionality under
  a different name, e.g. bit_vector.  This might make it possible to
  remove the vector&lt;bool&gt; specialization in the standard that comes
  after C++0x. There was also a suggestion that
  in C++0x we could additional say that it's implementation defined
  whether vector&lt;bool&gt; refers to the specialization or to the
  primary template, but there wasn't general agreement that this was a
  good idea.</p>

<p>We need a paper for the new bit_vector class.</p>

<p><i>[
Batavia:
]</i></p>

<blockquote>
The LWG feels we need something closer to SGI's <tt>bitvector</tt> to ease migration
from <tt>vector&lt;bool&gt;</tt>.  Although some of the funcitonality from
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2050.pdf">N2050</a>
could well be used in such a template.  The concern is easing the API migration for those
users who want to continue using a bit-packed container.  Alan and Beman to work.
</blockquote>

<p><i>[
Post Summit Alisdair adds:
]</i></p>


<blockquote>
<p>
<tt>vector&lt;bool&gt;</tt> is now a conforming container under the revised terms of C++0x,
which supports containers of proxies.
</p>
<p>
Recommend NAD.
</p>
<p>
Two issues remain:
</p>
<p>
i/ premature optimization in the specification.
There is still some sentiment that deprecation is the correct way to go,
although it is still not clear what it would mean to deprecate a single
specialization of a template.
</p>
<p>
Recommend: Create a new issue for the discussion, leave as Open.
</p>
<p>
ii/ Request for a new bitvector class to guarantee the optimization, perhaps
with a better tuned interface.
</p>
<p>
This is a clear extension request that may be handled via a future TR.
</p>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We note that most of this issue has become moot over time,
and agree with Alisdair's recommendations.
Move to NAD Future for reconsideration of part (ii).
</blockquote>

<p><i>[
2009-07-29 Alisdair reopens:
]</i></p>


<blockquote>
<p>
This infamous issue was closed as NAD Future when concepts introduced
support for proxy iterators, so the only remaining requirement was to
provide a better type to support bitsets of dynamic length.  I fear we
must re-open this issue until the post-concept form of iterators is
available, and hopefully will support the necessary proxy functionality
to allow us to close this issue as NAD.
</p>

<p>
I recommend we spawn a separate issue (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1184">1184</a>) requesting a dynamic length bitset
and pre-emptively file it as NAD Future.  It is difficult to resolve #96
when it effectively contains two separate sub-issues.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Mark as NAD, and give rationale.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
We now have:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2050.pdf">N2050</a>
and
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2160.html">N2160</a>.
</p>



<p><b>Rationale:</b></p>
<p>
We want to support proxy iterators but that is going to be separate
work. Don't want to see this issue come back in these kinds of terms.
We're interested in a separate container, and proxy iterators, but both
of those are separate issues.
</p>
<p>
We've looked at a lot of ways to fix this that would be close to this,
but those things would break existing code. Attempts to fix this
directly have not been tractable, and removing it has not been
tractable. Therefore we are closing.
</p>





<hr>
<h3><a name="97"></a>97. Insert inconsistent definition</h3>
<p><b>Section:</b> 23 [containers] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> AFNOR <b>Opened:</b> 1998-10-07  <b>Last modified:</b> 2006-12-27</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#containers">active issues</a> in [containers].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#containers">issues</a> in [containers].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><tt>insert(iterator, const value_type&amp;)</tt> is defined both on
sequences and on set, with unrelated semantics: insert here (in
sequences), and insert with hint (in associative containers). They
should have different names (B.S. says: do not abuse overloading).</p>


<p><b>Rationale:</b></p>
<p>This is not a defect in the Standard. It is a genetic misfortune of
the design, for better or for worse.</p>




<hr>
<h3><a name="99"></a>99. Reverse_iterator comparisons completely wrong</h3>
<p><b>Section:</b> 24.5.1.3.13 [reverse.iter.op==] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> AFNOR <b>Opened:</b> 1998-10-07  <b>Last modified:</b> 2006-12-27</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>The &lt;, &gt;, &lt;=, &gt;= comparison operator are wrong: they
return the opposite of what they should.</p>

<p>Note: same problem in CD2, these were not even defined in CD1.  SGI
STL code is correct; this problem is known since the Morristown
meeting but there it was too late</p>


<p><b>Rationale:</b></p>
<p>This is not a defect in the Standard. A careful reading shows the Standard is correct
as written. A review of several implementations show that they implement
exactly what the Standard says.</p>




<hr>
<h3><a name="100"></a>100. Insert iterators/ostream_iterators overconstrained</h3>
<p><b>Section:</b> 24.5.2 [insert.iterators], 24.6.4 [ostreambuf.iterator] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> AFNOR <b>Opened:</b> 1998-10-07  <b>Last modified:</b> 2006-12-27</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#insert.iterators">issues</a> in [insert.iterators].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>Overspecified For an insert iterator it, the expression *it is
required to return a reference to it. This is a simple possible
implementation, but as the SGI STL documentation says, not the only
one, and the user should not assume that this is the case.</p>


<p><b>Rationale:</b></p>
<p>The LWG believes this causes no harm and is not a defect in the
standard. The only example anyone could come up with caused some
incorrect code to work, rather than the other way around.</p>





<hr>
<h3><a name="101"></a>101. No way to free storage for vector and deque</h3>
<p><b>Section:</b> 23.3.6 [vector], 23.3.1 [array] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> AFNOR <b>Opened:</b> 1998-10-07  <b>Last modified:</b> 2007-02-19</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#vector">issues</a> in [vector].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>Reserve can not free storage, unlike string::reserve</p>


<p><b>Rationale:</b></p>
<p>This is not a defect in the Standard. The LWG has considered this
issue in the past and sees no need to change the Standard. Deque has
no reserve() member function. For vector, shrink-to-fit can be
expressed in a single line of code (where <tt>v</tt> is
<tt>vector&lt;T&gt;</tt>):
</p>

<blockquote>
  <p><tt>vector&lt;T&gt;(v).swap(v);&nbsp; // shrink-to-fit v</tt></p>
</blockquote>





<hr>
<h3><a name="102"></a>102. Bug in insert range in associative containers</h3>
<p><b>Section:</b> 23.2.4 [associative.reqmts] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> AFNOR <b>Opened:</b> 1998-10-07  <b>Last modified:</b> 2006-12-30</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#associative.reqmts">active issues</a> in [associative.reqmts].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#associative.reqmts">issues</a> in [associative.reqmts].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#264">264</a></p>
<p><b>Discussion:</b></p>
<p>Table 69 of Containers say that a.insert(i,j) is linear if [i, j) is ordered. It seems
impossible to implement, as it means that if [i, j) = [x], insert in an associative
container is O(1)!</p>


<p><b>Proposed resolution:</b></p>
<p>N+log (size()) if [i,j) is sorted according to value_comp()</p>


<p><b>Rationale:</b></p>
<p>Subsumed by issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#264">264</a>.</p>





<hr>
<h3><a name="104"></a>104. Description of basic_string::operator[] is unclear</h3>
<p><b>Section:</b> 21.4.4 [string.capacity] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> AFNOR <b>Opened:</b> 1998-10-07  <b>Last modified:</b> 2006-12-27</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#string.capacity">issues</a> in [string.capacity].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>It is not clear that undefined behavior applies when pos == size ()
for the non const version.</p>


<p><b>Proposed resolution:</b></p>
<p>Rewrite as: Otherwise, if pos &gt; size () or pos == size () and
the non-const version is used, then the behavior is undefined.</p>


<p><b>Rationale:</b></p>
<p>The Standard is correct. The proposed resolution already appears in
the Standard.</p>




<hr>
<h3><a name="105"></a>105. fstream ctors argument types desired</h3>
<p><b>Section:</b> 27.9 [file.streams] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> AFNOR <b>Opened:</b> 1998-10-07  <b>Last modified:</b> 2008-01-05</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#454">454</a></p>
<p><b>Discussion:</b></p>


<p>fstream ctors take a const char* instead of string.<br>
fstream ctors can't take wchar_t</p>

<p>An extension to add a const wchar_t* to fstream would make the
implementation non conforming.</p>


<p><b>Rationale:</b></p>
<p>This is not a defect in the Standard. It might be an
interesting extension for the next Standard. </p>




<hr>
<h3><a name="107"></a>107. Valarray constructor is strange</h3>
<p><b>Section:</b> 26.6.2 [template.valarray] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> AFNOR <b>Opened:</b> 1998-10-07  <b>Last modified:</b> 2006-12-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#template.valarray">issues</a> in [template.valarray].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>The order of the arguments is (elem, size) instead of the normal
(size, elem) in the rest of the library. Since elem often has an
integral or floating point type, both types are convertible to each
other and reversing them leads to a well formed program.</p>


<p><b>Proposed resolution:</b></p>
<p>Inverting the arguments could silently break programs. Introduce
the two signatures (const T&amp;, size_t) and (size_t, const T&amp;),
but make the one we do not want private so errors result in a
diagnosed access violation. This technique can also be applied to STL
containers.</p>


<p><b>Rationale:</b></p>
<p>The LWG believes that while the order of arguments is unfortunate,
it does not constitute a defect in the standard. The LWG believes that
the proposed solution will not work for valarray&lt;size_t&gt; and
perhaps other cases.</p>




<hr>
<h3><a name="111"></a>111. istreambuf_iterator::equal overspecified, inefficient</h3>
<p><b>Section:</b> 24.6.3.5 [istreambuf.iterator::equal] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Nathan Myers <b>Opened:</b> 1998-10-15  <b>Last modified:</b> 2009-07-14</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#istreambuf.iterator::equal">issues</a> in [istreambuf.iterator::equal].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>The member istreambuf_iterator&lt;&gt;::equal is specified to be
unnecessarily inefficient. While this does not affect the efficiency
of conforming implementations of iostreams, because they can
"reach into" the iterators and bypass this function, it does
affect users who use istreambuf_iterators. </p>

<p>The inefficiency results from a too-scrupulous definition, which
requires a "true" result if neither iterator is at eof. In
practice these iterators can only usefully be compared with the
"eof" value, so the extra test implied provides no benefit,
but slows down users' code. </p>

<p>The solution is to weaken the requirement on the function to return
true only if both iterators are at eof. </p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Reopened by Alisdair.
</blockquote>

<p><i>[
Post Summit Daniel adds:
]</i></p>


<blockquote>
<p>
Recommend NAD. The proposed wording would violate the axioms of
concept requirement <tt>EqualityComparable</tt> axioms as part of concept <tt>InputIterator</tt>
and more specifically it would violate the explicit wording of
24.2.1 [input.iterators]/7:
</p>

<blockquote>
If two iterators <tt>a</tt> and <tt>b</tt> of the same type are equal, then either <tt>a</tt>
and <tt>b</tt> are both
dereferenceable or else neither is dereferenceable.
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
Agree NAD.
</blockquote>

</blockquote>



<p><b>Proposed resolution:</b></p>
<p>Replace 24.6.3.5 [istreambuf.iterator::equal],
paragraph 1, </p>

<blockquote>
  <p>-1- Returns: true if and only if both iterators are at end-of-stream, or neither is at
  end-of-stream, regardless of what streambuf object they use. </p>
</blockquote>

<p>with</p>

<blockquote>
  <p>-1- Returns: true if and only if both iterators are at
  end-of-stream, regardless of what streambuf object they use. </p>
</blockquote>



<p><b>Rationale:</b></p>
<p>It is not clear that this is a genuine defect.  Additionally, the
LWG was reluctant to make a change that would result in 
operator== not being a equivalence relation.  One consequence of
this change is that an algorithm that's passed the range [i, i)
would no longer treat it as an empty range.</p>





<hr>
<h3><a name="113"></a>113. Missing/extra iostream sync semantics</h3>
<p><b>Section:</b> 27.7.1.1 [istream], 27.7.1.3 [istream.unformatted] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Steve Clamage <b>Opened:</b> 1998-10-13  <b>Last modified:</b> 2006-12-27</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#istream">issues</a> in [istream].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>In 27.6.1.1, class basic_istream has a member function sync, described in 27.6.1.3,
paragraph 36. </p>

<p>Following the chain of definitions, I find that the various sync functions have defined
semantics for output streams, but no semantics for input streams. On the other hand,
basic_ostream has no sync function. </p>

<p>The sync function should at minimum be added to basic_ostream, for internal
consistency. </p>

<p>A larger question is whether sync should have assigned semantics for input streams. </p>

<p>Classic iostreams said streambuf::sync flushes pending output and attempts to return
unread input characters to the source. It is a protected member function. The filebuf
version (which is public) has that behavior (it backs up the read pointer). Class
strstreambuf does not override streambuf::sync, and so sync can't be called on a
strstream. </p>

<p>If we can add corresponding semantics to the various sync functions, we should. If not,
we should remove sync from basic_istream.</p>


<p><b>Rationale:</b></p>
<p>A sync function is not needed in basic_ostream because the flush function provides the
desired functionality.</p>

<p>As for the other points, the LWG finds the standard correct as written.</p>





<hr>
<h3><a name="116"></a>116. bitset cannot be constructed with a const char*</h3>
<p><b>Section:</b> 20.3.7 [template.bitset] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Judy Ward <b>Opened:</b> 1998-11-06  <b>Last modified:</b> 2008-03-14</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#template.bitset">active issues</a> in [template.bitset].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#template.bitset">issues</a> in [template.bitset].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#778">778</a></p>
<p><b>Discussion:</b></p>



<p>The following code does not compile with the EDG compiler:</p>

<blockquote>
  <pre>#include &lt;bitset&gt;
using namespace std;
bitset&lt;32&gt; b("111111111");</pre>
</blockquote>

<p>If you cast the ctor argument to a string, i.e.:</p>

<blockquote>
  <pre>bitset&lt;32&gt; b(string("111111111"));</pre>
</blockquote>

<p>then it will compile. The reason is that bitset has the following templatized
constructor:</p>

<blockquote>
  <pre>template &lt;class charT, class traits, class Allocator&gt;
explicit bitset (const basic_string&lt;charT, traits, Allocator&gt;&amp; str, ...);</pre>
</blockquote>

<p>According to the compiler vendor, Steve Adamcyk at EDG, the user
cannot pass this template constructor a <tt>const char*</tt> and
expect a conversion to <tt>basic_string</tt>.  The reason is
"When you have a template constructor, it can get used in
contexts where type deduction can be done. Type deduction basically
comes up with exact matches, not ones involving conversions."
</p>

<p>I don't think the intention when this constructor became
templatized was for construction from a <tt>const char*</tt> to no
longer work.</p>


<p><b>Proposed resolution:</b></p>
<p>Add to 20.3.7 [template.bitset] a bitset constructor declaration</p>

<blockquote>
  <pre>explicit bitset(const char*);</pre>
</blockquote>

<p>and in Section 20.3.7.1 [bitset.cons] add:</p>

<blockquote>
  <pre>explicit bitset(const char* str);</pre>
  <p>Effects: <br>
  &nbsp;&nbsp;&nbsp; Calls <tt>bitset((string) str, 0, string::npos);</tt></p>
</blockquote>


<p><b>Rationale:</b></p>
<p>Although the problem is real, the standard is designed that way so
it is not a defect.  Education is the immediate workaround. A future
standard may wish to consider the Proposed Resolution as an
extension.</p>





<hr>
<h3><a name="121"></a>121. Detailed definition for ctype&lt;wchar_t&gt; specialization</h3>
<p><b>Section:</b> 22.3.1.1.1 [locale.category] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Judy Ward <b>Opened:</b> 1998-12-15  <b>Last modified:</b> 2006-12-27</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.category">issues</a> in [locale.category].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>Section 22.1.1.1.1 has the following listed in Table 51: ctype&lt;char&gt; ,
ctype&lt;wchar_t&gt;. </p>

<p>Also Section 22.4.1.1 [locale.ctype] says: </p>

<blockquote>
  <p>The instantiations required in Table 51 (22.1.1.1.1) namely ctype&lt;char&gt; and
  ctype&lt;wchar_t&gt; , implement character classing appropriate to the implementation's
  native character set. </p>
</blockquote>

<p>However, Section 22.4.1.3 [facet.ctype.special]
only has a detailed description of the ctype&lt;char&gt; specialization, not the
ctype&lt;wchar_t&gt; specialization. </p>


<p><b>Proposed resolution:</b></p>
<p>Add the ctype&lt;wchar_t&gt; detailed class description to Section 
22.4.1.3 [facet.ctype.special]. </p>


<p><b>Rationale:</b></p>
<p>Specialization for wchar_t is not needed since the default is acceptable.</p>





<hr>
<h3><a name="128"></a>128. Need open_mode() function for file stream, string streams, file buffers, and string&nbsp; buffers</h3>
<p><b>Section:</b> 27.8 [string.streams], 27.9 [file.streams] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Angelika Langer <b>Opened:</b> 1999-02-22  <b>Last modified:</b> 2009-07-14</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#string.streams">issues</a> in [string.streams].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>The following question came from Thorsten Herlemann:</p>

<blockquote>
  <p>You can set a mode when constructing or opening a file-stream or
  filebuf, e.g.  ios::in, ios::out, ios::binary, ... But how can I get
  that mode later on, e.g. in my own operator &lt;&lt; or operator
  &gt;&gt; or when I want to check whether a file-stream or
  file-buffer object passed as parameter is opened for input or output
  or binary? Is there no possibility? Is this a design-error in the
  standard C++ library? </p>
</blockquote>

<p>It is indeed impossible to find out what a stream's or stream
buffer's open mode is, and without that knowledge you don't know
how certain operations behave. Just think of the append mode. </p>

<p>Both streams and stream buffers should have a <tt>mode()</tt> function that returns the
current open mode setting. </p>

<p><i>[
post Bellevue:  Alisdair requested to re-Open.
]</i></p>


<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
Neither Howard nor Bill has received a customer request for this.
</p>
<p>
No consensus for change. The programmer can save this information to the side.
</p>
<p>
Moved to NAD.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>For stream buffers, add a function to the base class as a non-virtual function
qualified as const to 27.6.2 [streambuf]:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;<tt>openmode mode() const</tt>;</p>

<p><b>&nbsp;&nbsp;&nbsp; Returns</b> the current open mode.</p>

<p>With streams, I'm not sure what to suggest. In principle, the mode
could already be returned by <tt>ios_base</tt>, but the mode is only
initialized for file and string stream objects, unless I'm overlooking
anything. For this reason it should be added to the most derived
stream classes. Alternatively, it could be added to <tt>basic_ios</tt>
and would be default initialized in <tt>basic_ios&lt;&gt;::init()</tt>.</p>


<p><b>Rationale:</b></p>
<p>This might be an interesting extension for some future, but it is
not a defect in the current standard. The Proposed Resolution is
retained for future reference.</p>





<hr>
<h3><a name="131"></a>131. list::splice throws nothing</h3>
<p><b>Section:</b> 23.3.4.4 [list.ops] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 1999-03-06  <b>Last modified:</b> 2007-02-19</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#list.ops">active issues</a> in [list.ops].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#list.ops">issues</a> in [list.ops].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>What happens if a splice operation causes the size() of a list to grow 
beyond max_size()?</p>


<p><b>Rationale:</b></p>
<p>Size() cannot grow beyond max_size().&nbsp; </p>





<hr>
<h3><a name="135"></a>135. basic_iostream doubly initialized</h3>
<p><b>Section:</b> 27.7.1.5.1 [iostream.cons] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 1999-03-06  <b>Last modified:</b> 2006-12-27</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>-1- Effects Constructs an object of class basic_iostream, assigning
initial values to the base classes by calling
basic_istream&lt;charT,traits&gt;(sb) (lib.istream) and
basic_ostream&lt;charT,traits&gt;(sb) (lib.ostream)</p>

<p>The called for basic_istream and basic_ostream constructors call
init(sb). This means that the basic_iostream's virtual base class is
initialized twice.</p>


<p><b>Proposed resolution:</b></p>
<p>Change 27.6.1.5.1, paragraph 1 to:</p>

<p>-1- Effects Constructs an object of class basic_iostream, assigning
initial values to the base classes by calling
basic_istream&lt;charT,traits&gt;(sb) (lib.istream).</p>


<p><b>Rationale:</b></p>
<p>The LWG agreed that the <tt> init()</tt> function is called
twice, but said that this is harmless and so not a defect in the
standard.</p>




<hr>
<h3><a name="138"></a>138. Class ctype_byname&lt;char&gt; redundant and misleading</h3>
<p><b>Section:</b> 22.4.1.4 [locale.codecvt] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Angelika Langer <b>Opened:</b> 1999-03-18  <b>Last modified:</b> 2009-07-14</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.codecvt">issues</a> in [locale.codecvt].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>Section 22.4.1.4 [locale.codecvt] specifies that
ctype_byname&lt;char&gt; must be a specialization of the ctype_byname
template.</p>

<p>It is common practice in the standard that specializations of class templates are only
mentioned where the interface of the specialization deviates from the interface of the
template that it is a specialization of. Otherwise, the fact whether or not a required
instantiation is an actual instantiation or a specialization is left open as an
implementation detail. </p>

<p>Clause 22.2.1.4 deviates from that practice and for that reason is misleading. The
fact, that ctype_byname&lt;char&gt; is specified as a specialization suggests that there
must be something "special" about it, but it has the exact same interface as the
ctype_byname template. Clause 22.2.1.4 does not have any explanatory value, is at best
redundant, at worst misleading - unless I am missing anything. </p>

<p>Naturally, an implementation will most likely implement ctype_byname&lt;char&gt; as a
specialization, because the base class ctype&lt;char&gt; is a specialization with an
interface different from the ctype template, but that's an implementation detail and need
not be mentioned in the standard. </p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Reopened by Alisdair.
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
Moved to NAD.
</blockquote>



<p><b>Rationale:</b></p>
<p> The standard as written is mildly misleading, but the correct fix
is to deal with the underlying problem in the ctype_byname base class,
not in the specialization. See issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#228">228</a>.</p>




<hr>
<h3><a name="140"></a>140. map&lt;Key, T&gt;::value_type does not satisfy the assignable requirement</h3>
<p><b>Section:</b> 23.4.1 [map] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Mark Mitchell <b>Opened:</b> 1999-04-14  <b>Last modified:</b> 2008-03-14</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#map">issues</a> in [map].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<blockquote>
  <p>23.2 [container.requirements]<br>
  <br>
  expression&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return type
  &nbsp;&nbsp;&nbsp;&nbsp; pre/post-condition<br>
  -------------&nbsp;&nbsp;&nbsp;&nbsp; ----------- &nbsp;&nbsp;&nbsp;&nbsp;
  -------------------<br>
  X::value_type&nbsp;&nbsp;&nbsp; T
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  T is assignable<br>
  <br>
  23.4.1 [map]<br>
  <br>
  A map satisfies all the requirements of a container.<br>
  <br>
  For a map&lt;Key, T&gt; ... the value_type is pair&lt;const Key, T&gt;.</p>
</blockquote>

<p>There's a contradiction here. In particular, `pair&lt;const Key,
T&gt;' is not assignable; the `const Key' cannot be assigned
to. So,&nbsp; map&lt;Key, T&gt;::value_type does not satisfy the
assignable requirement imposed by a container.</p>

<p><i>[See issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#103">103</a> for the slightly related issue of
modification of set keys.]</i></p>



<p><b>Rationale:</b></p>
<p>The LWG believes that the standard is inconsistent, but that this
is a design problem rather than a strict defect. May wish to
reconsider for the next standard.</p>




<hr>
<h3><a name="143"></a>143. C .h header wording unclear</h3>
<p><b>Section:</b> D.6 [depr.c.headers] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Christophe de Dinechin <b>Opened:</b> 1999-05-04  <b>Last modified:</b> 2006-12-27</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>[depr.c.headers] paragraph 2 reads:</p>

<blockquote>

<p>Each C header, whose name has the form name.h, behaves as if each
name placed in the Standard library namespace by the corresponding
cname header is also placed within the namespace scope of the
namespace std and is followed by an explicit using-declaration
(_namespace.udecl_)</p>

</blockquote>

<p>I think it should mention the global name space somewhere...&nbsp;
Currently, it indicates that name placed in std is also placed in
std...</p>

<p>I don't know what is the correct wording. For instance, if struct
tm is defined in time.h, ctime declares std::tm. However, the current
wording seems ambiguous regarding which of the following would occur
for use of both ctime and time.h:</p>

<blockquote>
  <pre>// version 1:
namespace std {
        struct tm { ... };
}
using std::tm;

// version 2:
struct tm { ... };
namespace std {
        using ::tm;
}

// version 3:
struct tm { ... };
namespace std {
        struct tm { ... };
}</pre>
</blockquote>

<p>I think version 1 is intended.</p>

<p><i>[Kona: The LWG agreed that the wording is not clear. It also
agreed that version 1 is intended, version 2 is not equivalent to
version 1, and version 3 is clearly not intended. The example below
was constructed by Nathan Myers to illustrate why version 2 is not
equivalent to version 1.</i></p>

<p><i>Although not equivalent, the LWG is unsure if (2) is enough of
a problem to be prohibited. Points discussed in favor of allowing
(2):</i></p>

<blockquote>
  <ul>
    <li><i>It may be a convenience to implementors.</i></li>
    <li><i>The only cases that fail are structs, of which the C library
      contains only a few.</i></li>
  </ul>
</blockquote>

<p><i>]</i></p>

<p><b>Example:</b></p>

<blockquote>

<pre>#include &lt;time.h&gt;
#include &lt;utility&gt;

int main() {
    std::tm * t;
    make_pair( t, t ); // okay with version 1 due to Koenig lookup
                       // fails with version 2; make_pair not found
    return 0;
}</pre>

</blockquote>


<p><b>Proposed resolution:</b></p>

<p>Replace D.6 [depr.c.headers] paragraph 2 with:</p>

<blockquote>

<p> Each C header, whose name has the form name.h, behaves as if each
name placed in the Standard library namespace by the corresponding
cname header is also placed within the namespace scope of the
namespace std by name.h and is followed by an explicit
using-declaration (_namespace.udecl_) in global scope.</p>

</blockquote>



<p><b>Rationale:</b></p>
<p> The current wording in the standard is the result of a difficult
compromise that averted delay of the standard. Based on discussions
in Tokyo it is clear that there is no still no consensus on stricter
wording, so the issue has been closed. It is suggested that users not
write code that depends on Koenig lookup of C library functions.</p>




<hr>
<h3><a name="145"></a>145. adjustfield lacks default value</h3>
<p><b>Section:</b> 27.5.4.1 [basic.ios.cons] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Angelika Langer <b>Opened:</b> 1999-05-12  <b>Last modified:</b> 2006-12-27</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#basic.ios.cons">issues</a> in [basic.ios.cons].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>There is no initial value for the adjustfield defined, although
many people believe that the default adjustment were right. This is a
common misunderstanding. The standard only defines that, if no
adjustment is specified, all the predefined inserters must add fill
characters before the actual value, which is "as if" the
right flag were set. The flag itself need not be set.</p>

<p>When you implement a user-defined inserter you cannot rely on right
being the default setting for the adjustfield. Instead, you must be
prepared to find none of the flags set and must keep in mind that in
this case you should make your inserter behave "as if" the
right flag were set. This is surprising to many people and complicates
matters more than necessary.</p>

<p>Unless there is a good reason why the adjustfield should not be
initialized I would suggest to give it the default value that
everybody expects anyway.</p>



<p><b>Rationale:</b></p>
<p>This is not a defect. It is deliberate that the default is no bits
set. Consider Arabic or Hebrew, for example. See 22.4.2.2.2 [facet.num.put.virtuals] paragraph 19, Table 61 - Fill padding.</p>




<hr>
<h3><a name="157"></a>157. Meaningless error handling for <tt>pword()</tt> and <tt>iword()</tt></h3>
<p><b>Section:</b> 27.5.2.5 [ios.base.storage] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Dietmar Khl <b>Opened:</b> 1999-07-20  <b>Last modified:</b> 2007-01-15</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#ios.base.storage">issues</a> in [ios.base.storage].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#41">41</a></p>
<p><b>Discussion:</b></p>
<p>According to paragraphs 2 and 4 of 27.5.2.5 [ios.base.storage], the
functions <tt>iword()</tt> and <tt>pword()</tt> "set the
<tt>badbit</tt> (which might throw an exception)" on
failure. ... but what does it mean for <tt>ios_base</tt> to set the
<tt>badbit</tt>? The state facilities of the IOStream library are
defined in <tt>basic_ios</tt>, a derived class! It would be possible
to attempt a down cast but then it would be necessary to know the
character type used...</p>


<p><b>Rationale:</b></p>





<hr>
<h3><a name="162"></a>162. Really "formatted input functions"?</h3>
<p><b>Section:</b> 27.7.1.2.3 [istream::extractors] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Dietmar Khl <b>Opened:</b> 1999-07-20  <b>Last modified:</b> 2007-01-15</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#istream::extractors">issues</a> in [istream::extractors].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#60">60</a></p>
<p><b>Discussion:</b></p>
<p>It appears to be somewhat nonsensical to consider the functions
defined in the paragraphs 1 to 5 to be "Formatted input
function" but since these functions are defined in a section
labeled "Formatted input functions" it is unclear to me
whether these operators are considered formatted input functions which
have to conform to the "common requirements" from 27.7.1.2.1
[istream.formatted.reqmts]: If this is the case, all manipulators, not
just
<tt>ws</tt>, would skip whitespace unless <tt>noskipws</tt> is set
(... but setting <tt>noskipws</tt> using the manipulator syntax would
also skip whitespace :-)</p>

<p>See also issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#166">166</a> for the same problem in formatted
output</p>


<p><b>Rationale:</b></p>





<hr>
<h3><a name="163"></a>163. Return of <tt>gcount()</tt> after a call to <tt>gcount</tt></h3>
<p><b>Section:</b> 27.7.1.3 [istream.unformatted] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Dietmar Khl <b>Opened:</b> 1999-07-20  <b>Last modified:</b> 2007-01-15</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#istream.unformatted">issues</a> in [istream.unformatted].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#60">60</a></p>
<p><b>Discussion:</b></p>
<p>It is not clear which functions are to be considered unformatted
input functions. As written, it seems that all functions in 27.7.1.3
[istream.unformatted] are unformatted input functions. However, it does
not
really make much sense to construct a sentry object for
<tt>gcount()</tt>, <tt>sync()</tt>, ... Also it is unclear what
happens to the <tt>gcount()</tt> if eg. <tt>gcount()</tt>,
<tt>putback()</tt>, <tt>unget()</tt>, or <tt>sync()</tt> is called:
These functions don't extract characters, some of them even
"unextract" a character. Should this still be reflected in
<tt>gcount()</tt>? Of course, it could be read as if after a call to
<tt>gcount()</tt> <tt>gcount()</tt> return <tt>0</tt> (the last
unformatted input function, <tt>gcount()</tt>, didn't extract any
character) and after a call to <tt>putback()</tt> <tt>gcount()</tt>
returns <tt>-1</tt> (the last unformatted input function
<tt>putback()</tt> did "extract" back into the
stream). Correspondingly for <tt>unget()</tt>. Is this what is
intended?  If so, this should be clarified. Otherwise, a corresponding
clarification should be used.</p>


<p><b>Rationale:</b></p>





<hr>
<h3><a name="166"></a>166. Really "formatted output functions"?</h3>
<p><b>Section:</b> 27.7.2.6.3 [ostream.inserters] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Dietmar Khl <b>Opened:</b> 1999-07-20  <b>Last modified:</b> 2007-01-15</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#60">60</a></p>
<p><b>Discussion:</b></p>
<p>From 27.7.2.6.1 [ostream.formatted.reqmts] it appears that all the functions
defined in 27.7.2.6.3 [ostream.inserters] have to construct a
<tt>sentry</tt> object. Is this really intended?</p> 

<p>This is basically the same problem as issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#162">162</a> but
for output instead of input.</p>


<p><b>Rationale:</b></p>





<hr>
<h3><a name="177"></a>177. Complex operators cannot be explicitly instantiated</h3>
<p><b>Section:</b> 26.4.6 [complex.ops] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Judy Ward <b>Opened:</b> 1999-07-02  <b>Last modified:</b> 2006-12-27</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#complex.ops">issues</a> in [complex.ops].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>A user who tries to explicitly instantiate a complex non-member operator will
get compilation errors. Below is a simplified example of the reason why. The
problem is that iterator_traits cannot be instantiated on a non-pointer type
like float, yet when the compiler is trying to decide which operator+ needs to
be instantiated it must instantiate the declaration to figure out the first
argument type of a reverse_iterator operator.</p>
<pre>namespace std {
template &lt;class Iterator&gt; 
struct iterator_traits
{
    typedef typename Iterator::value_type value_type;
};

template &lt;class T&gt; class reverse_iterator;

// reverse_iterator operator+
template &lt;class T&gt; 
reverse_iterator&lt;T&gt; operator+
(typename iterator_traits&lt;T&gt;::difference_type, const reverse_iterator&lt;T&gt;&amp;);

template &lt;class T&gt; struct complex {};

// complex operator +
template &lt;class T&gt;
complex&lt;T&gt; operator+ (const T&amp; lhs, const complex&lt;T&gt;&amp; rhs) 
{ return complex&lt;T&gt;();} 
}

// request for explicit instantiation
template std::complex&lt;float&gt; std::operator+&lt;float&gt;(const float&amp;, 
     const std::complex&lt;float&gt;&amp;);</pre>
<p>See also c++-stdlib reflector messages: lib-6814, 6815, 6816.</p>


<p><b>Rationale:</b></p>
<p>Implementors can make minor changes and the example will
work. Users are not affected in any case.</p> <p>According to John
Spicer, It is possible to explicitly instantiate these operators using
different syntax: change "std::operator+&lt;float&gt;" to
"std::operator+".</p>

<p>The proposed resolution of issue 120 is that users will not be able
to explicitly instantiate standard library templates. If that
resolution is accepted then library implementors will be the only ones
that will be affected by this problem, and they must use the indicated
syntax.</p>




<hr>
<h3><a name="178"></a>178. Should clog and cerr initially be tied to cout?</h3>
<p><b>Section:</b> 27.4.1 [narrow.stream.objects] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Judy Ward <b>Opened:</b> 1999-07-02  <b>Last modified:</b> 2006-12-27</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#narrow.stream.objects">issues</a> in [narrow.stream.objects].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Section 27.3.1 says "After the object cerr is initialized,
cerr.flags() &amp; unitbuf is nonzero. Its state is otherwise the same as
required for ios_base::init (lib.basic.ios.cons).  It doesn't say
anything about the the state of clog.  So this means that calling
cerr.tie() and clog.tie() should return 0 (see Table 89 for
ios_base::init effects).
</p>
<p>
Neither of the popular standard library implementations
that I tried does this, they both tie cerr and clog
to &amp;cout. I would think that would be what users expect.
</p>


<p><b>Rationale:</b></p>
<p>The standard is clear as written.</p>
<p>27.3.1/5 says that "After the object cerr is initialized, cerr.flags()
&amp; unitbuf is nonzero. Its state is otherwise the same as required for
ios_base::init (27.4.4.1)." Table 89 in 27.4.4.1, which gives the
postconditions of basic_ios::init(), says that tie() is 0. (Other issues correct
ios_base::init to basic_ios::init().)</p>




<hr>
<h3><a name="188"></a>188. valarray helpers missing augmented assignment operators</h3>
<p><b>Section:</b> 26.6.2.6 [valarray.cassign] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Gabriel Dos Reis <b>Opened:</b> 1999-08-15  <b>Last modified:</b> 2008-03-11</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#valarray.cassign">issues</a> in [valarray.cassign].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>26.5.2.6 defines augmented assignment operators
valarray&lt;T&gt;::op=(const T&amp;), but fails to provide
corresponding versions for the helper classes. Thus making the
following illegal:</p>
<blockquote>
<pre>#include &lt;valarray&gt;

int main()
{
std::valarray&lt;double&gt; v(3.14, 1999);

v[99] *= 2.0; // Ok

std::slice s(0, 50, 2);

v[s] *= 2.0; // ERROR
}</pre>
</blockquote>
<p>I can't understand the intent of that omission.  It makes the
valarray library less intuitive and less useful.</p>


<p><b>Rationale:</b></p>
<p>Although perhaps an unfortunate
design decision, the omission is not a defect in the current
standard.&nbsp; A future standard may wish to add the missing
operators.</p>




<hr>
<h3><a name="190"></a>190. min() and max() functions should be std::binary_functions</h3>
<p><b>Section:</b> 25.4.7 [alg.min.max] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Mark Rintoul <b>Opened:</b> 1999-08-26  <b>Last modified:</b> 2009-07-14</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.min.max">issues</a> in [alg.min.max].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>Both std::min and std::max are defined as template functions.  This
is very different than the definition of std::plus (and similar
structs) which are defined as function objects which inherit
std::binary_function.<br>
<br>
        This lack of inheritance leaves std::min and std::max somewhat useless in standard library algorithms which require
a function object that inherits std::binary_function.</p>

<p><i>[
post Bellevue:  Alisdair requested to re-Open.
]</i></p>


<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
C++0x has lambdas to address this problem now.
</p>
<p>
Moved to NAD.
</p>
</blockquote>



<p><b>Rationale:</b></p>
<p>Although perhaps an unfortunate design decision, the omission is not a defect
in the current standard.&nbsp; A future standard may wish to consider additional
function objects.</p>




<hr>
<h3><a name="191"></a>191. Unclear complexity for algorithms such as binary search</h3>
<p><b>Section:</b> 25.4.3 [alg.binary.search] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Nico Josuttis <b>Opened:</b> 1999-10-10  <b>Last modified:</b> 2006-12-27</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.binary.search">issues</a> in [alg.binary.search].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>The complexity of binary_search() is stated as "At most
log(last-first) + 2 comparisons", which seems to say that the
algorithm has logarithmic complexity. However, this algorithms is
defined for forward iterators. And for forward iterators, the need to
step element-by-element results into linear complexity. But such a
statement is missing in the standard. The same applies to
lower_bound(), upper_bound(), and equal_range().&nbsp;<br>
<br>
However, strictly speaking the standard contains no bug here. So this
might considered to be a clarification or improvement.
</p>


<p><b>Rationale:</b></p>
<p>The complexity is expressed in terms of comparisons, and that
complexity can be met even if the number of iterators accessed is
linear. Paragraph 1 already says exactly what happens to
iterators.</p>




<hr>
<h3><a name="192"></a>192. a.insert(p,t) is inefficient and overconstrained</h3>
<p><b>Section:</b> 23.2.4 [associative.reqmts] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Ed Brey <b>Opened:</b> 1999-06-06  <b>Last modified:</b> 2006-12-30</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#associative.reqmts">active issues</a> in [associative.reqmts].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#associative.reqmts">issues</a> in [associative.reqmts].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#233">233</a></p>
<p><b>Discussion:</b></p>
<p>As defined in 23.1.2, paragraph 7 (table 69), a.insert(p,t) suffers from
several problems:</p>
<table border="1" cellpadding="5">
  <tbody><tr>
    <td><b>expression</b></td>
    <td><b>return type</b></td>
    <td><b>pre/post-condition</b></td>
    <td><b>complexity</b></td>
  </tr>
  <tr>
    <td><tt>a.insert(p,t)</tt></td>
    <td><tt>iterator</tt></td>
    <td>inserts t if and only if there is no element with key equivalent to the key of 
       t in containers with unique keys; always inserts t in containers with equivalent 
       keys. always returns the iterator pointing to the element with key equivalent to 
       the key of t . iterator p is a hint pointing to where the insert should start to search.</td>
    <td>logarithmic in general, but amortized constant if t is inserted right after p .</td>
  </tr>
</tbody></table>
<p>1. For a container with unique keys, only logarithmic complexity is
guaranteed if no element is inserted, even though constant complexity is always
possible if p points to an element equivalent to t.</p>
<p>2. For a container with equivalent keys, the amortized constant complexity
guarantee is only useful if no key equivalent to t exists in the container.
Otherwise, the insertion could occur in one of multiple locations, at least one
of which would not be right after p.</p>
<p>3. By guaranteeing amortized constant complexity only when t is inserted
after p, it is impossible to guarantee constant complexity if t is inserted at
the beginning of the container. Such a problem would not exist if amortized
constant complexity was guaranteed if t is inserted before p, since there is
always some p immediately before which an insert can take place.</p>
<p>4. For a container with equivalent keys, p does not allow specification of
where to insert the element, but rather only acts as a hint for improving
performance. This negates the added functionality that p would provide if it
specified where within a sequence of equivalent keys the insertion should occur.
Specifying the insert location provides more control to the user, while
providing no disadvantage to the container implementation.</p>


<p><b>Proposed resolution:</b></p>
<p>In 23.2.4 [associative.reqmts] paragraph 7, replace the row in table 69
for a.insert(p,t) with the following two rows:</p>
<table border="1" cellpadding="5">
  <tbody><tr>
    <td><b>expression</b></td>
    <td><b>return type</b></td>
    <td><b>pre/post-condition</b></td>
    <td><b>complexity</b></td>
  </tr>
  <tr>
    <td><tt>a_uniq.insert(p,t)</tt></td>
    <td><tt>iterator</tt></td>
    <td>inserts t if and only if there is no element with key equivalent to the
      key of t. returns the iterator pointing to the element with key equivalent
      to the key of t.</td>
    <td>logarithmic in general, but amortized constant if t is inserted right
      before p or p points to an element with key equivalent to t.</td>
  </tr>
  <tr>
    <td><tt>a_eq.insert(p,t)</tt></td>
    <td><tt>iterator</tt></td>
    <td>inserts t and returns the iterator pointing to the newly inserted
      element. t is inserted right before p if doing so preserves the container
      ordering.</td>
    <td>logarithmic in general, but amortized constant if t is inserted right
      before p.</td>
  </tr>
</tbody></table>



<p><b>Rationale:</b></p>
<p>Too big a change.&nbsp; Furthermore, implementors report checking
both before p and after p, and don't want to change this behavior.</p>





<hr>
<h3><a name="194"></a>194. rdbuf() functions poorly specified</h3>
<p><b>Section:</b> 27.5.4 [ios] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Steve Clamage <b>Opened:</b> 1999-09-07  <b>Last modified:</b> 2006-12-27</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>In classic iostreams, base class ios had an rdbuf function that returned a
pointer to the associated streambuf. Each derived class had its own rdbuf
function that returned a pointer of a type reflecting the actual type derived
from streambuf. Because in ARM C++, virtual function overrides had to have the
same return type, rdbuf could not be virtual.</p>
<p>In standard iostreams, we retain the non-virtual rdbuf function design, and
in addition have an overloaded rdbuf function that sets the buffer pointer.
There is no need for the second function to be virtual nor to be implemented in
derived classes.</p>
<p>Minor question: Was there a specific reason not to make the original rdbuf
function virtual?</p>
<p>Major problem: Friendly compilers warn about functions in derived classes
that hide base-class overloads. Any standard implementation of iostreams will
result in such a warning on each of the iostream classes, because of the
ill-considered decision to overload rdbuf only in a base class.</p>
<p>In addition, users of the second rdbuf function must use explicit
qualification or a cast to call it from derived classes. An explicit
qualification or cast to basic_ios would prevent access to any later overriding
version if there was one.</p>
<p>What I'd like to do in an implementation is add a using- declaration for the
second rdbuf function in each derived class. It would eliminate warnings about
hiding functions, and would enable access without using explicit qualification.
Such a change I don't think would change the behavior of any valid program, but
would allow invalid programs to compile:</p>
<blockquote>
  <pre> filebuf mybuf;
 fstream f;
 f.rdbuf(mybuf); // should be an error, no visible rdbuf</pre>
</blockquote>
<p>I'd like to suggest this problem as a defect, with the proposed resolution to
require the equivalent of a using-declaration for the rdbuf function that is not
replaced in a later derived class. We could discuss whether replacing the
function should be allowed.</p>


<p><b>Rationale:</b></p>
<p>For historical reasons, the standard is correct as written. There is a subtle difference between the base
class <tt> rdbuf()</tt> and derived class <tt>rdbuf()</tt>. The derived
class <tt> rdbuf()</tt> always returns the original streambuf, whereas the base class
<tt> rdbuf()</tt> will return the "current streambuf" if that has been changed by the variant you mention.</p>

<p>Permission is not required to add such an extension.  See 
17.6.4.5 [member.functions].</p>




<hr>
<h3><a name="196"></a>196. Placement new example has alignment problems</h3>
<p><b>Section:</b> 18.6.1.3 [new.delete.placement] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Herb Sutter <b>Opened:</b> 1998-12-15  <b>Last modified:</b> 2006-12-30</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#new.delete.placement">issues</a> in [new.delete.placement].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#114">114</a></p>
<p><b>Discussion:</b></p>
<p>The example in 18.6.1.3 [new.delete.placement] paragraph 4 reads: </p>

<blockquote>

<p>[Example: This can be useful for constructing an object at a known address:<br>
<br>
<tt>&nbsp;&nbsp; char place[sizeof(Something)];<br>
&nbsp;&nbsp; Something* p = new (place) Something();<br>
<br>
</tt>end example] </p>

</blockquote>

<p>This example has potential alignment problems. </p>


<p><b>Rationale:</b></p>





<hr>
<h3><a name="197"></a>197. max_size() underspecified</h3>
<p><b>Section:</b> 20.2.2 [allocator.requirements], 23.2 [container.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Andy Sawyer <b>Opened:</b> 1999-10-21  <b>Last modified:</b> 2006-12-30</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#allocator.requirements">issues</a> in [allocator.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>Must the value returned by max_size() be unchanged from call to call? </p>

<p>Must the value returned from max_size() be meaningful? </p>

<p>Possible meanings identified in lib-6827: </p>

<p>1) The largest container the implementation can support given "best
case" conditions - i.e. assume the run-time platform is "configured to
the max", and no overhead from the program itself. This may possibly
be determined at the point the library is written, but certainly no
later than compile time.<br>
<br>
2) The largest container the program could create, given "best case"
conditions - i.e. same platform assumptions as (1), but take into
account any overhead for executing the program itself. (or, roughly
"storage=storage-sizeof(program)"). This does NOT include any resource
allocated by the program. This may (or may not) be determinable at
compile time.<br>
<br>
3) The largest container the current execution of the program could
create, given knowledge of the actual run-time platform, but again,
not taking into account any currently allocated resource. This is
probably best determined at program start-up.<br>
<br>
4) The largest container the current execution program could create at
the point max_size() is called (or more correctly at the point
max_size() returns :-), given it's current environment (i.e. taking
into account the actual currently available resources). This,
obviously, has to be determined dynamically each time max_size() is
called. </p>


<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>max_size() isn't useful for very many things, and the existing
  wording is sufficiently clear for the few cases that max_size() can
  be used for.  None of the attempts to change the existing wording
  were an improvement.</p>

<p>It is clear to the LWG that the value returned by max_size() can't
  change from call to call.</p>






<hr>
<h3><a name="203"></a>203. basic_istream::sentry::sentry() is uninstantiable with ctype&lt;user-defined type&gt;</h3>
<p><b>Section:</b> 27.7.1.1.3 [istream::sentry] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Matt McClure and Dietmar Khl <b>Opened:</b> 2000-01-01  <b>Last modified:</b> 2007-01-15</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#istream::sentry">issues</a> in [istream::sentry].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>27.6.1.1.2 Paragraph 4 states:</p>
<blockquote>
  <p>To decide if the character c is a whitespace character, the constructor      
     performs ''as if'' it executes the following code fragment:&nbsp;</p>
  <pre>const ctype&lt;charT&gt;&amp; ctype = use_facet&lt;ctype&lt;charT&gt; &gt;(is.getloc());
if (ctype.is(ctype.space,c)!=0)
// c is a whitespace character.</pre>
</blockquote>

<p> But Table 51 in 22.1.1.1.1 only requires an implementation to
provide specializations for ctype&lt;char&gt; and
ctype&lt;wchar_t&gt;.  If sentry's constructor is implemented using
ctype, it will be uninstantiable for a user-defined character type
charT, unless the implementation has provided non-working (since it
would be impossible to define a correct ctype&lt;charT&gt; specialization
for an arbitrary charT) definitions of ctype's virtual member
functions.</p>

<p>
It seems the intent the standard is that sentry should behave, in
every respect, not just during execution, as if it were implemented
using ctype, with the burden of providing a ctype specialization
falling on the user.  But as it is written, nothing requires the
translation of sentry's constructor to behave as if it used the above
code, and it would seem therefore, that sentry's constructor should be
instantiable for all character types.
</p>

<p> 
Note: If I have misinterpreted the intent of the standard with
respect to sentry's constructor's instantiability, then a note should
be added to the following effect:
</p>

<blockquote><p>
An implementation is forbidden from using the above code if it renders
the constructor uninstantiable for an otherwise valid character
type.
</p></blockquote>

<p>In any event, some clarification is needed.</p>



<p><b>Rationale:</b></p>
<p>It is possible but not easy to instantiate on types other than char
or wchar_t; many things have to be done first. That is by intention
and is not a defect.</p>




<hr>
<h3><a name="204"></a>204. distance(first, last) when "last" is before "first"</h3>
<p><b>Section:</b> 24.4.4 [iterator.operations] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Rintala Matti <b>Opened:</b> 2000-01-28  <b>Last modified:</b> 2008-09-30</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#iterator.operations">active issues</a> in [iterator.operations].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#iterator.operations">issues</a> in [iterator.operations].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>Section 24.3.4 describes the function distance(first, last) (where first and
last are iterators) which calculates "the number of increments or
decrements needed to get from 'first' to 'last'".</p>
<p>The function should work for forward, bidirectional and random access
iterators, and there is a requirement 24.3.4.5 which states that "'last'
must be reachable from 'first'".</p>
<p>With random access iterators the function is easy to implement as "last
- first".</p>
<p>With forward iterators it's clear that 'first' must point to a place before
'last', because otherwise 'last' would not be reachable from 'first'.</p>
<p>But what about bidirectional iterators? There 'last' is reachable from
'first' with the -- operator even if 'last' points to an earlier position than
'first'. However, I cannot see how the distance() function could be implemented
if the implementation does not know which of the iterators points to an earlier
position (you cannot use ++ or -- on either iterator if you don't know which
direction is the "safe way to travel").</p>
<p>The paragraph 24.3.4.1 states that "for ... bidirectional iterators they
use ++ to provide linear time implementations". However, the ++ operator is
not mentioned in the reachability requirement. Furthermore 24.3.4.4 explicitly
mentions that distance() returns the number of increments _or decrements_,
suggesting that it could return a negative number also for bidirectional
iterators when 'last' points to a position before 'first'.</p>
<p>Is a further requirement is needed to state that for forward and
bidirectional iterators "'last' must be reachable from 'first' using the ++
operator". Maybe this requirement might also apply to random access
iterators so that distance() would work the same way for every iterator
category?</p>


<p><b>Rationale:</b></p>
<p>"Reachable" is defined in the standard in X [iterator.concepts] paragraph 6.
The definition is only in terms of operator++(). The LWG sees no defect in
the standard.</p>




<hr>
<h3><a name="205"></a>205.  numeric_limits unclear on how to determine floating point types</h3>
<p><b>Section:</b> 18.3.1.2 [numeric.limits.members] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Steve Cleary <b>Opened:</b> 2000-01-28  <b>Last modified:</b> 2006-12-27</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#numeric.limits.members">issues</a> in [numeric.limits.members].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>In several places in 18.3.1.2 [numeric.limits.members], a member is
described as "Meaningful for all floating point types."
However, no clear method of determining a floating point type is
provided.</p>

<p>In 18.3.1.5 [numeric.special], paragraph 1 states ". . . (for
example, epsilon() is only meaningful if is_integer is
false). . ." which suggests that a type is a floating point type
if is_specialized is true and is_integer is false; however, this is
unclear.</p>

<p>When clarifying this, please keep in mind this need of users: what
exactly is the definition of floating point? Would a fixed point or
rational representation be considered one? I guess my statement here
is that there could also be types that are neither integer or
(strictly) floating point.</p>


<p><b>Rationale:</b></p>
<p>It is up to the implementor of a user define type to decide if it is a
floating point type.</p>




<hr>
<h3><a name="207"></a>207. ctype&lt;char&gt; members return clause incomplete</h3>
<p><b>Section:</b> 22.4.1.3.2 [facet.ctype.char.members] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Robert Klarer <b>Opened:</b> 1999-11-02  <b>Last modified:</b> 2006-12-30</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#facet.ctype.char.members">issues</a> in [facet.ctype.char.members].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#153">153</a></p>
<p><b>Discussion:</b></p>
<p>
The <tt>widen</tt> and <tt>narrow</tt> member functions are described
in 22.2.1.3.2, paragraphs 9-11.  In each case we have two overloaded
signatures followed by a <b>Returns</b> clause.  The <b>Returns</b>
clause only describes one of the overloads.
</p>


<p><b>Proposed resolution:</b></p>
<p>Change the returns clause in 22.4.1.3.2 [facet.ctype.char.members]
paragraph 10 from:</p>
<p>&nbsp;&nbsp;&nbsp; Returns: do_widen(low, high, to).</p>

<p>to:</p>
<p>&nbsp;&nbsp;&nbsp; Returns: do_widen(c) or do_widen(low, high, to), 
respectively.</p>

<p>Change the returns clause in 22.4.1.3.2 [facet.ctype.char.members] paragraph 11
from:</p> 
<p>&nbsp;&nbsp;&nbsp; Returns: do_narrow(low, high, to).</p>

<p>to:</p>
<p>&nbsp;&nbsp;&nbsp; Returns: do_narrow(c) or do_narrow(low, high, to), 
respectively.</p>


<p><b>Rationale:</b></p>
<p>Subsumed by issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#153">153</a>, which addresses the same
paragraphs.</p>






<hr>
<h3><a name="213"></a>213. Math function overloads ambiguous</h3>
<p><b>Section:</b> 26.8 [c.math] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Nico Josuttis <b>Opened:</b> 2000-02-26  <b>Last modified:</b> 2006-12-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#c.math">issues</a> in [c.math].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>Due to the additional overloaded versions of numeric functions for
float and long double according to Section 26.5, calls such as int x;
std::pow (x, 4) are ambiguous now in a standard conforming
implementation. Current implementations solve this problem very
different (overload for all types, don't overload for float and long
double, use preprocessor, follow the standard and get
ambiguities).</p> <p>This behavior should be standardized or at least
identified as implementation defined.</p>


<p><b>Rationale:</b></p>
<p>These math issues are an
understood and accepted consequence of the design. They have
been discussed several times in the past. Users must write casts
or write floating point expressions as arguments.</p>




<hr>
<h3><a name="215"></a>215. Can a map's key_type be const?</h3>
<p><b>Section:</b> 23.2.4 [associative.reqmts] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Judy Ward <b>Opened:</b> 2000-02-29  <b>Last modified:</b> 2006-12-27</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#associative.reqmts">active issues</a> in [associative.reqmts].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#associative.reqmts">issues</a> in [associative.reqmts].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>A user noticed that this doesn't compile with the Rogue Wave library because
the rb_tree class declares a key_allocator, and allocator&lt;const int&gt; is
not legal, I think:</p>
<blockquote>
  <pre>map &lt; const int, ... &gt; // legal?</pre>
</blockquote>
<p>which made me wonder whether it is legal for a map's key_type to be const. In
email from Matt Austern he said:</p>
<blockquote>
<p>I'm not sure whether it's legal to declare a map with a const key type. I
hadn't thought about that question until a couple weeks ago. My intuitive
feeling is that it ought not to be allowed, and that the standard ought to say
so. It does turn out to work in SGI's library, though, and someone in the
compiler group even used it. Perhaps this deserves to be written up as an issue
too.</p>
</blockquote>


<p><b>Rationale:</b></p>
<p>The "key is assignable" requirement from table 69 in
23.2.4 [associative.reqmts] already implies the key cannot be const.</p>




<hr>
<h3><a name="216"></a>216. setbase manipulator description flawed</h3>
<p><b>Section:</b> 27.7.3 [std.manip] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Hyman Rosen <b>Opened:</b> 2000-02-29  <b>Last modified:</b> 2006-12-30</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#std.manip">issues</a> in [std.manip].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#193">193</a></p>
<p><b>Discussion:</b></p>
<p>27.7.3 [std.manip] paragraph 5 says:</p>
<blockquote>
<pre>smanip setbase(int base);</pre>
<p> Returns: An object s of unspecified type such that if out is an
(instance of) basic_ostream then the expression out&lt;&lt;s behaves
as if f(s) were called, in is an (instance of) basic_istream then the
expression in&gt;&gt;s behaves as if f(s) were called. Where f can be
defined as:</p>
<pre>ios_base&amp; f(ios_base&amp; str, int base)
{
  // set basefield
  str.setf(n == 8 ? ios_base::oct :
                n == 10 ? ios_base::dec :
                n == 16 ? ios_base::hex :
                  ios_base::fmtflags(0), ios_base::basefield);
  return str;
}</pre>
</blockquote>
<p>There are two problems here. First, f takes two parameters, so the
description needs to say that out&lt;&lt;s and in&gt;&gt;s behave as if f(s,base)
had been called. Second, f is has a parameter named base, but is written as if
the parameter was named n.</p>
<p>Actually, there's a third problem. The paragraph has grammatical errors.
There needs to be an "and" after the first comma, and the "Where
f" sentence fragment needs to be merged into its preceding sentence. You
may also want to format the function a little better. The formatting above is
more-or-less what the Standard contains.</p>


<p><b>Rationale:</b></p>
<p>The resolution of this defect is subsumed by the proposed resolution for
issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#193">193</a>.</p>

<p><i>[Tokyo: The LWG agrees that this is a defect and notes that it
occurs additional places in the section, all requiring fixes.]</i></p>








<hr>
<h3><a name="218"></a>218. Algorithms do not use binary predicate objects for default comparisons</h3>
<p><b>Section:</b> 25.4 [alg.sorting] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Pablo Halpern <b>Opened:</b> 2000-03-06  <b>Last modified:</b> 2006-12-27</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.sorting">issues</a> in [alg.sorting].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>Many of the algorithms take an argument, pred, of template parameter type
BinaryPredicate or an argument comp of template parameter type Compare. These
algorithms usually have an overloaded version that does not take the predicate
argument. In these cases pred is usually replaced by the use of operator== and
comp is replaced by the use of operator&lt;.</p>
<p>This use of hard-coded operators is inconsistent with other parts of the
library, particularly the containers library, where equality is established
using equal_to&lt;&gt; and ordering is established using less&lt;&gt;. Worse,
the use of operator&lt;, would cause the following innocent-looking code to have
undefined behavior:</p>
<blockquote>
  <pre>vector&lt;string*&gt; vec;
sort(vec.begin(), vec.end());</pre>
</blockquote>
<p>The use of operator&lt; is not defined for pointers to unrelated objects. If
std::sort used less&lt;&gt; to compare elements, then the above code would be
well-defined, since less&lt;&gt; is explicitly specialized to produce a total
ordering of pointers.</p>


<p><b>Rationale:</b></p>
<p>This use of operator== and operator&lt; was a very deliberate, conscious, and
explicitly made design decision; these operators are often more efficient. The
predicate forms are available for users who don't want to rely on operator== and
operator&lt;.</p>




<hr>
<h3><a name="219"></a>219. find algorithm missing version that takes a binary predicate argument</h3>
<p><b>Section:</b> 25.2.5 [alg.find] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Pablo Halpern <b>Opened:</b> 2000-03-06  <b>Last modified:</b> 2009-07-14</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.find">issues</a> in [alg.find].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>The find function always searches for a value using operator== to compare the
value argument to each element in the input iterator range. This is inconsistent
with other find-related functions such as find_end and find_first_of, which
allow the caller to specify a binary predicate object to be used for determining
equality. The fact that this can be accomplished using a combination of find_if
and bind_1st or bind_2nd does not negate the desirability of a consistent,
simple, alternative interface to find.</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Reopened by Alisdair.
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
The same thing can be achieved using find_if (as noted in the issue).
</p>
<p>
Moved to NAD.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<blockquote>
<p>In section 25.2.5 [alg.find], add a second prototype for find
(between the existing prototype and the prototype for find_if), as
follows:</p>
<pre>    template&lt;class InputIterator, class T, class BinaryPredicate&gt;
      InputIterator find(InputIterator first, InputIterator last,
                         const T&amp; value, BinaryPredicate bin_pred);</pre>
<p>Change the description of the return from:</p>
<blockquote>
  <p>Returns: The first iterator i in the range [first, last) for which the following corresponding
  conditions hold: *i == value, pred(*i) != false. Returns last if no such iterator is found.</p>
</blockquote>
<p>&nbsp;to:</p>
<blockquote>
  <p>Returns: The first iterator i in the range [first, last) for which the following&nbsp;
  corresponding condition holds: *i == value, bin_pred(*i,value) != false, pred(*)
  != false. Return last if no such iterator is found.</p>
</blockquote>
</blockquote>


<p><b>Rationale:</b></p>
<p>This is request for a pure extension, so it is not a defect in the
current standard.&nbsp; As the submitter pointed out, "this can
be accomplished using a combination of find_if and bind_1st or
bind_2nd".</p>




<hr>
<h3><a name="236"></a>236. ctype&lt;char&gt;::is() member modifies facet</h3>
<p><b>Section:</b> 22.4.1.3.2 [facet.ctype.char.members] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Dietmar Khl <b>Opened:</b> 2000-04-24  <b>Last modified:</b> 2007-01-15</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#facet.ctype.char.members">issues</a> in [facet.ctype.char.members].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#28">28</a></p>
<p><b>Discussion:</b></p>
<p>The description of the <tt>is()</tt> member in paragraph 4 of 22.4.1.3.2 [facet.ctype.char.members] is broken: According to this description, the
second form of the <tt>is()</tt> method modifies the masks in the
<tt>ctype</tt> object. The correct semantics if, of course, to obtain
an array of masks. The corresponding method in the general case,
ie. the <tt>do_is()</tt> method as described in 22.4.1.1.2 [locale.ctype.virtuals] paragraph 1 does the right thing.</p>


<p><b>Proposed resolution:</b></p>
  <p>Change paragraph 4 from</p>
    <blockquote><p>
    The second form, for all *p in the range [low, high), assigns
    vec[p-low] to table()[(unsigned char)*p].
    </p></blockquote>
  <p>to become</p>
    <blockquote><p>
    The second form, for all *p in the range [low, high), assigns
    table()[(unsigned char)*p] to vec[p-low].
  </p></blockquote>


<p><b>Rationale:</b></p>





<hr>
<h3><a name="244"></a>244. Must <tt>find</tt>'s third argument be CopyConstructible?</h3>
<p><b>Section:</b> 25.2.5 [alg.find] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Andrew Koenig <b>Opened:</b> 2000-05-02  <b>Last modified:</b> 2006-12-27</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.find">issues</a> in [alg.find].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>Is the following implementation of <tt>find</tt> acceptable?</p>

<pre>        template&lt;class Iter, class X&gt;
        Iter find(Iter begin, Iter end, const X&amp; x)
        {
            X x1 = x;           // this is the crucial statement
            while (begin != end &amp;&amp; *begin != x1)
                ++begin;
            return begin;
        }
</pre>

<p>If the answer is yes, then it is implementation-dependent as to
whether the following fragment is well formed:</p>

<pre>        vector&lt;string&gt; v;

        find(v.begin(), v.end(), "foo");
</pre>

<p>At issue is whether there is a requirement that the third argument
of find be CopyConstructible.  There may be no problem here, but
analysis is necessary.</p>


<p><b>Rationale:</b></p>
<p>There is no indication in the standard that find's third argument
is required to be Copy Constructible.  The LWG believes that no such
requirement was intended.  As noted above, there are times when a user
might reasonably pass an argument that is not Copy Constructible.</p>




<hr>
<h3><a name="245"></a>245. Which operations on <tt>istream_iterator</tt> trigger input operations?</h3>
<p><b>Section:</b> 24.6.1 [istream.iterator] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Andrew Koenig <b>Opened:</b> 2000-05-02  <b>Last modified:</b> 2006-12-27</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#istream.iterator">issues</a> in [istream.iterator].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>I do not think the standard specifies what operation(s) on istream
iterators trigger input operations.  So, for example:</p>

<pre>        istream_iterator&lt;int&gt; i(cin);

        int n = *i++;
</pre>

<p>I do not think it is specified how many integers have been read
from cin.  The number must be at least 1, of course, but can it be 2?
More?</p>


<p><b>Rationale:</b></p>
<p>The standard is clear as written: the stream is read every time
operator++ is called, and it is also read either when the iterator is
constructed or when operator* is called for the first time.  In the
example above, exactly two integers are read from cin.</p>

<p>There may be a problem with the interaction between istream_iterator
and some STL algorithms, such as find.  There are no guarantees about
how many times find may invoke operator++.</p>




<hr>
<h3><a name="246"></a>246. <tt>a.insert(p,t)</tt> is incorrectly specified</h3>
<p><b>Section:</b> 23.2.4 [associative.reqmts] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Mark Rodgers <b>Opened:</b> 2000-05-19  <b>Last modified:</b> 2007-01-15</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#associative.reqmts">active issues</a> in [associative.reqmts].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#associative.reqmts">issues</a> in [associative.reqmts].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#233">233</a></p>
<p><b>Discussion:</b></p>
<p>Closed issue 192 raised several problems with the specification of
this function, but was rejected as Not A Defect because it was too big
a change with unacceptable impacts on existing implementations.
However, issues remain that could be addressed with a smaller change
and with little or no consequent impact.</p>

<ol>
   <li><p> The specification is inconsistent with the original
   proposal and with several implementations.</p>

   <p>The initial implementation by Hewlett Packard only ever looked
   immediately <i>before</i> p, and I do not believe there was any
   intention to standardize anything other than this behavior.
   Consequently, current implementations by several leading
   implementors also look immediately before p, and will only insert
   after p in logarithmic time.  I am only aware of one implementation
   that does actually look after p, and it looks before p as well.  It
   is therefore doubtful that existing code would be relying on the
   behavior defined in the standard, and it would seem that fixing
   this defect as proposed below would standardize existing
   practice.</p></li>

   <li><p>
   The specification is inconsistent with insertion for sequence
   containers.</p>

   <p>This is difficult and confusing to teach to newcomers.  All
   insert operations that specify an iterator as an insertion location
   should have a consistent meaning for the location represented by
   that iterator.</p></li>

   <li><p> As specified, there is no way to hint that the insertion
   should occur at the beginning of the container, and the way to hint
   that it should occur at the end is long winded and unnatural.</p>

   <p>For a container containing n elements, there are n+1 possible
   insertion locations and n+1 valid iterators.  For there to be a
   one-to-one mapping between iterators and insertion locations, the
   iterator must represent an insertion location immediately before
   the iterator.</p></li>

   <li><p> When appending sorted ranges using insert_iterators,
   insertions are guaranteed to be sub-optimal.</p>

   <p>In such a situation, the optimum location for insertion is
   always immediately after the element previously inserted.  The
   mechanics of the insert iterator guarantee that it will try and
   insert after the element after that, which will never be correct.
   However, if the container first tried to insert before the hint,
   all insertions would be performed in amortized constant
   time.</p></li>
</ol>


<p><b>Proposed resolution:</b></p>
<p>In 23.1.2 [lib.associative.reqmts] paragraph 7, table 69, make
the following changes in the row for a.insert(p,t):</p>

<p><i>assertion/note pre/post condition:</i>
<br>Change the last sentence from</p>
     <blockquote><p>
     "iterator p is a hint pointing to where the insert should
     start to search."
     </p></blockquote>
<p>to</p>
     <blockquote><p>
     "iterator p is a hint indicating that immediately before p
     may be a correct location where the insertion could occur."
     </p></blockquote>

<p><i>complexity:</i><br>
Change the words "right after" to "immediately before".</p>


<p><b>Rationale:</b></p>





<hr>
<h3><a name="249"></a>249. Return Type of <tt>auto_ptr::operator=</tt></h3>
<p><b>Section:</b> D.10.1 [auto.ptr] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Joseph Gottman <b>Opened:</b> 2000-06-30  <b>Last modified:</b> 2006-12-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#auto.ptr">issues</a> in [auto.ptr].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>According to section 20.4.5, the function
<tt>auto_ptr::operator=()</tt> returns a reference to an auto_ptr.
The reason that <tt>operator=()</tt> usually returns a reference is to
facilitate code like</p>

<pre>    int x,y,z;
    x = y = z = 1;
</pre>

<p>However, given analogous code for <tt>auto_ptr</tt>s,</p>
<pre>    auto_ptr&lt;int&gt; x, y, z;
    z.reset(new int(1));
    x = y = z;
</pre>

<p>the result would be that <tt>z</tt> and <tt>y</tt> would both be set to 
NULL, instead of all the <tt>auto_ptr</tt>s being set to the same value. 
This makes such cascading assignments useless and counterintuitive for 
<tt>auto_ptr</tt>s.</p>


<p><b>Proposed resolution:</b></p>
<p>Change <tt>auto_ptr::operator=()</tt> to return <tt>void</tt> instead
of an <tt>auto_ptr</tt> reference.</p>


<p><b>Rationale:</b></p>
<p>The return value has uses other than cascaded assignments: a user can
call an auto_ptr member function, pass the auto_ptr to a
function, etc.  Removing the return value could break working user
code.</p>




<hr>
<h3><a name="255"></a>255. Why do <tt>basic_streambuf&lt;&gt;::pbump()</tt> and <tt>gbump()</tt> take an int?</h3>
<p><b>Section:</b> 27.6.2 [streambuf] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Future">NAD Future</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2000-08-12  <b>Last modified:</b> 2009-07-14</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#streambuf">issues</a> in [streambuf].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Future">NAD Future</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The basic_streambuf members gbump() and pbump() are specified to take an
int argument. This requirement prevents the functions from effectively
manipulating buffers larger than std::numeric_limits&lt;int&gt;::max()
characters. It also makes the common use case for these functions
somewhat difficult as many compilers will issue a warning when an
argument of type larger than int (such as ptrdiff_t on LLP64
architectures) is passed to either of the function. Since it's often the
result of the subtraction of two pointers that is passed to the
functions, a cast is necessary to silence such warnings. Finally, the
usage of a native type in the functions signatures is inconsistent with
other member functions (such as sgetn() and sputn()) that manipulate the
underlying character buffer. Those functions take a streamsize argument.
</p>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
This is part of a bigger problem. If anyone cares enough, they should
write a paper solving the bigger problem of offset types in iostreams.
</p>
<p>
This is related to the paper about large file sizes. Beman has already
agreed to drop the section of that paper that deals with this.
</p>
<p>
int is big enough for reasonable buffers.
</p>
<p>
Move to NAD Future.
</p>
<p>
This is related to LWG <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#423">423</a>.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change the signatures of these functions in the synopsis of template
class basic_streambuf (27.5.2) and in their descriptions (27.5.2.3.1, p4
and 27.5.2.3.2, p4) to take a streamsize argument.
</p>

<p>
Although this change has the potential of changing the ABI of the
library, the change will affect only platforms where int is different
than the definition of streamsize. However, since both functions are
typically inline (they are on all known implementations), even on such
platforms the change will not affect any user code unless it explicitly
relies on the existing type of the functions (e.g., by taking their
address). Such a possibility is IMO quite remote.
</p>

<p>
Alternate Suggestion from Howard Hinnant, c++std-lib-7780:
</p>

<p>
This is something of a nit, but I'm wondering if streamoff wouldn't be a 
better choice than streamsize.  The argument to pbump and gbump MUST be 
signed.  But the standard has this to say about streamsize 
(27.4.1/2/Footnote):
</p>

<blockquote><p>
     [Footnote: streamsize is used in most places where ISO C would use
     size_t.  Most of the uses of streamsize could use size_t, except for
     the strstreambuf constructors, which require negative values. It
     should probably be the signed type corresponding to size_t (which is
     what Posix.2 calls ssize_t). --- end footnote]
</p></blockquote>

<p>
This seems a little weak for the argument to pbump and gbump.  Should we 
ever really get rid of strstream, this footnote might go with it, along 
with the reason to make streamsize signed.
</p>


<p><b>Rationale:</b></p>
<p>The LWG believes this change is too big for now.  We may wish to
reconsider this for a future revision of the standard.  One
possibility is overloading pbump, rather than changing the
signature.</p>
<p><i>[
[2006-05-04: Reopened at the request of Chris (Krzysztof ?elechowski)]
]</i></p>





<hr>
<h3><a name="257"></a>257. STL functional object and iterator inheritance.</h3>
<p><b>Section:</b> 20.7.3 [base], 24.4.2 [iterator.basic] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Robert Dick  <b>Opened:</b> 2000-08-17  <b>Last modified:</b> 2006-12-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#base">issues</a> in [base].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
According to the November 1997 Draft Standard, the results of deleting an
object of a derived class through a pointer to an object of its base class are
undefined if the base class has a non-virtual destructor.  Therefore, it is
potentially dangerous to publicly inherit from such base classes.
</p>

<p>Defect:
<br>
The STL design encourages users to publicly inherit from a number of classes
which do nothing but specify interfaces, and which contain non-virtual
destructors.
</p>

<p>Attribution:
<br>
Wil Evers and William E. Kempf suggested this modification for functional
objects.
</p>


<p><b>Proposed resolution:</b></p>
<p>
When a base class in the standard library is useful only as an interface
specifier, i.e., when an object of the class will never be directly
instantiated, specify that the class contains a protected destructor.  This
will prevent deletion through a pointer to the base class without performance,
or space penalties (on any implementation I'm aware of).
</p>

<p>
As an example, replace...
</p>

<pre>    template &lt;class Arg, class Result&gt;
    struct unary_function {
            typedef Arg    argument_type;
            typedef Result result_type;
    };
</pre>

<p>
... with...
</p>

<pre>    template &lt;class Arg, class Result&gt;
    struct unary_function {
            typedef Arg    argument_type;
            typedef Result result_type;
    protected:
            ~unary_function() {}
    };
</pre>

<p>
Affected definitions:
<br>
  &nbsp;20.3.1 [lib.function.objects] -- unary_function, binary_function
  <br>
  &nbsp;24.3.2 [lib.iterator.basic] -- iterator
</p>


<p><b>Rationale:</b></p>
<p>
The standard is clear as written; this is a request for change, not a
defect in the strict sense.  The LWG had several different objections
to the proposed change.  One is that it would prevent users from
creating objects of type <tt>unary_function</tt> and
<tt>binary_function</tt>.  Doing so can sometimes be legitimate, if users
want to pass temporaries as traits or tag types in generic code.
</p>





<hr>
<h3><a name="267"></a>267. interaction of strstreambuf::overflow() and seekoff()</h3>
<p><b>Section:</b> D.8.1.3 [depr.strstreambuf.virtuals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2000-10-05  <b>Last modified:</b> 2007-01-15</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#depr.strstreambuf.virtuals">issues</a> in [depr.strstreambuf.virtuals].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It appears that the interaction of the strstreambuf members overflow()
and seekoff() can lead to undefined behavior in cases where defined
behavior could reasonably be expected. The following program
demonstrates this behavior:
</p>

<pre>    #include &lt;strstream&gt;

    int main ()
    {
         std::strstreambuf sb;
         sb.sputc ('c');

         sb.pubseekoff (-1, std::ios::end, std::ios::in);
         return !('c' == sb.sgetc ());
    }
</pre>

<p>
D.7.1.1, p1 initializes strstreambuf with a call to basic_streambuf&lt;&gt;(),
which in turn sets all pointers to 0 in 27.5.2.1, p1.
</p>
 
<p>
27.5.2.2.5, p1 says that basic_streambuf&lt;&gt;::sputc(c) calls
overflow(traits::to_int_type(c)) if a write position isn't available (it
isn't due to the above).
</p>

<p>
D.7.1.3, p3 says that strstreambuf::overflow(off, ..., ios::in) makes at
least one write position available (i.e., it allows the function to make
any positive number of write positions available).
</p>

<p>
D.7.1.3, p13 computes newoff = seekhigh - eback(). In D.7.1, p4 we see
seekhigh = epptr() ? epptr() : egptr(), or seekhigh = epptr() in this
case. newoff is then epptr() - eback().
</p>

<p>
D.7.1.4, p14 sets gptr() so that gptr() == eback() + newoff + off, or
gptr() == epptr() + off holds.
</p>

<p>
If strstreambuf::overflow() made exactly one write position available
then gptr() will be set to just before epptr(), and the program will
return 0. Buf if the function made more than one write position
available, epptr() and gptr() will both point past pptr() and the
behavior of the program is undefined.
</p>


<p><b>Proposed resolution:</b></p>


   <p>Change the last sentence of D.8.1 [depr.strstreambuf] paragraph 4 from</p>

      <blockquote><p>
      Otherwise, seeklow equals gbeg and seekhigh is either pend, if
      pend is not a null pointer, or gend.
      </p></blockquote>

   <p>to become</p>

      <blockquote><p>
      Otherwise, seeklow equals gbeg and seekhigh is either gend if
      0 == pptr(), or pbase() + max where max is the maximum value of
      pptr() - pbase() ever reached for this stream.
      </p></blockquote>

<p><i>[
  pre-Copenhagen: Dietmar provided wording for proposed resolution.
]</i></p>


<p><i>[
  post-Copenhagen: Fixed a typo: proposed resolution said to fix
  4.7.1, not D.7.1.
]</i></p>




<p><b>Rationale:</b></p>
<p>This is related to issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#65">65</a>: it's not clear what it
means to seek beyond the current area.  Without resolving issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#65">65</a> we can't resolve this.  As with issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#65">65</a>, 
the library working group does not wish to invest time nailing down
corner cases in a deprecated feature.</p>





<hr>
<h3><a name="269"></a>269. cstdarg and unnamed parameters</h3>
<p><b>Section:</b> 18.8 [support.exception] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> J. Stephen Adamczyk <b>Opened:</b> 2000-10-10  <b>Last modified:</b> 2006-12-27</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#support.exception">issues</a> in [support.exception].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
One of our customers asks whether this is valid C++:
</p>

<pre>   #include &lt;cstdarg&gt;

   void bar(const char *, va_list);

   void
   foo(const char *file, const char *, ...)
   {
     va_list ap;
     va_start(ap, file);
     bar(file, ap);
     va_end(ap);
   }
</pre>

<p>
The issue being whether it is valid to use cstdarg when the final
parameter before the "..." is unnamed.  cstdarg is, as far
as I can tell, inherited verbatim from the C standard. and the
definition there (7.8.1.1 in the ISO C89 standard) refers to "the
identifier of the rightmost parameter".  What happens when there
is no such identifier?
</p>

<p>
My personal opinion is that this should be allowed, but some tweak
might be required in the C++ standard.
</p>


<p><b>Rationale:</b></p>
<p>
Not a defect, the C and C++ standards are clear.  It is impossible to
use varargs if the parameter immediately before "..." has no
name, because that is the parameter that must be passed to va_start.
The example given above is broken, because va_start is being passed
the wrong parameter.
</p>

<p>
There is no support for extending varargs to provide additional
functionality beyond what's currently there.  For reasons of C/C++
compatibility, it is especially important not to make gratuitous
changes in this part of the C++ standard.  The C committee has already
been requested not to touch this part of the C standard unless
necessary.
</p>




<hr>
<h3><a name="277"></a>277. Normative encouragement in allocator requirements unclear</h3>
<p><b>Section:</b> 20.2.2 [allocator.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2000-11-07  <b>Last modified:</b> 2006-12-30</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#allocator.requirements">issues</a> in [allocator.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 20.1.5, paragraph 5, the standard says that "Implementors are
encouraged to supply libraries that can accept allocators that
encapsulate more general memory models and that support non-equal
instances." This is intended as normative encouragement to
standard library implementors.  However, it is possible to interpret
this sentence as applying to nonstandard third-party libraries.
</p>


<p><b>Proposed resolution:</b></p>
<p>
In 20.1.5, paragraph 5, change "Implementors" to
"Implementors of the library described in this International
Standard".
</p>


<p><b>Rationale:</b></p>
<p>The LWG believes the normative encouragement is already
sufficiently clear, and that there are no important consequences
even if it is misunderstood.</p>





<hr>
<h3><a name="279"></a>279. const and non-const iterators should have equivalent typedefs</h3>
<p><b>Section:</b> 23.2 [container.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Steve Cleary <b>Opened:</b> 2000-11-27  <b>Last modified:</b> 2006-12-27</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#container.requirements">active issues</a> in [container.requirements].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#container.requirements">issues</a> in [container.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p>
This came from an email from Steve Cleary to Fergus in reference to
issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#179">179</a>. The library working group briefly discussed
this in Toronto and believes it should be a separate issue.
</p>

<p>
Steve said: "We may want to state that the const/non-const iterators must have
the same difference type, size_type, and category."
</p>

<p>
(Comment from Judy)
I'm not sure if the above sentence should be true for all
const and non-const iterators in a particular container, or if it means 
the container's iterator can't be compared with the container's
const_iterator unless the above it true. I suspect the former.
</p>


<p><b>Proposed resolution:</b></p>
<p>
In <b>Section:</b> 23.2 [container.requirements],
table 65, in the assertion/note pre/post condition for X::const_iterator,
add the following:
</p>

<blockquote>
<p>
typeid(X::const_iterator::difference_type) == typeid(X::iterator::difference_type)
</p>

<p>
typeid(X::const_iterator::size_type) == typeid(X::iterator::size_type)
</p>

<p>
typeid(X::const_iterator::category) == typeid(X::iterator::category)
</p>
</blockquote>


<p><b>Rationale:</b></p>
<p>Going through the types one by one: Iterators don't have a
<tt>size_type</tt>.  We already know that the difference types are
identical, because the container requirements already say that the
difference types of both X::iterator and X::const_iterator are both
X::difference_type.  The standard does not require that X::iterator
and X::const_iterator have the same iterator category, but the LWG
does not see this as a defect: it's possible to imagine cases in which
it would be useful for the categories to be different.</p>

<p>It may be desirable to require X::iterator and X::const_iterator to
have the same value type, but that is a new issue. (Issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#322">322</a>.)</p>






<hr>
<h3><a name="287"></a>287. conflicting ios_base fmtflags</h3>
<p><b>Section:</b> 27.5.2.2 [fmtflags.state] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Judy Ward <b>Opened:</b> 2000-12-30  <b>Last modified:</b> 2006-12-27</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#fmtflags.state">issues</a> in [fmtflags.state].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The Effects clause for ios_base::setf(fmtflags fmtfl) says
"Sets fmtfl in flags()".  What happens if the user first calls
ios_base::scientific and then calls ios_base::fixed or vice-versa?
This is an issue for all of the conflicting flags, i.e. ios_base::left
and ios_base::right or ios_base::dec, ios_base::hex and ios_base::oct.
</p>

<p>
I see three possible solutions: 
</p>

<ol>
<li>Set ios_base::failbit whenever the user specifies a conflicting
flag with one previously explicitly set. If the constructor is
supposed to set ios_base::dec (see discussion below), then
the user setting hex or oct format after construction will not
set failbit. </li>
<li>The last call to setf "wins", i.e. it clears any conflicting
previous setting.</li>
<li>All the flags that the user specifies are set, but when actually 
interpreting them, fixed always override scientific, right always 
overrides left, dec overrides hex which overrides oct.</li>
</ol>

<p>
Most existing implementations that I tried seem to conform to resolution #3,
except that when using the iomanip manipulator hex or oct then that always 
overrides dec, but calling setf(ios_base::hex) doesn't. 
</p>

<p>
There is a sort of related issue, which is that although the ios_base
constructor says that each ios_base member has an indeterminate value
after construction, all the existing implementations I tried explicitly set 
ios_base::dec.
</p>


<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>
<tt>adjustfield</tt>, <tt>basefield</tt>, and <tt>floatfield</tt>
are each multi-bit fields.  It is possible to set multiple bits within
each of those fields.  (For example, <tt>dec</tt> and
<tt>oct</tt>). These fields are used by locale facets. The LWG
reviewed the way in which each of those three fields is used, and
believes that in each case the behavior is well defined for any
possible combination of bits. See for example Table 58, in 22.4.2.2.2
[facet.num.put.virtuals], noting the requirement in paragraph 6 of that
section.
</p>
<p>
Users are advised to use manipulators, or else use the two-argument
version of <tt>setf</tt>, to avoid unexpected behavior.
</p>





<hr>
<h3><a name="289"></a>289. &lt;cmath&gt; requirements missing C float and long double versions</h3>
<p><b>Section:</b> 26.8 [c.math] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Judy Ward <b>Opened:</b> 2000-12-30  <b>Last modified:</b> 2007-01-15</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#c.math">issues</a> in [c.math].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
    In ISO/IEC 9899:1990 Programming Languages C we find the following
    concerning &lt;math.h&gt;:
</p>

<blockquote><p>
         7.13.4 Mathematics &lt;math.h&gt;
         <br>
         The names of all existing functions declared in the &lt;math.h&gt;
         header, suffixed with f or l, are reserved respectively for
         corresponding functions with float and long double arguments
         are return values.
</p></blockquote>

<p>
    For example, <tt>float&nbsp;sinf(float)</tt>
    is reserved.
</p>

<p>
    In the C99 standard, &lt;math.h&gt; must contain declarations
    for these functions.
</p>

<p>
So, is it acceptable for an implementor to add these prototypes to the
C++ versions of the math headers? Are they required?
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add these Functions to Table 80, section 26.5 and to Table 99,
section C.2:
</p>

<pre>    acosf asinf atanf atan2f ceilf cosf coshf 
    expf fabsf floorf fmodf frexpf ldexpf 
    logf log10f modff powf sinf sinhf sqrtf 
    tanf tanhf 
    acosl asinl atanl atan2l ceill cosl coshl 
    expl fabsl floorl fmodl frexpl ldexpl 
    logl log10l modfl powl sinl sinhl sqrtl 
    tanl tanhl
</pre>

<p>
There should probably be a note saying that these functions
are optional and, if supplied, should match the description in
the 1999 version of the C standard. In the next round
of C++ standardization they can then become mandatory. 
</p>


<p><b>Rationale:</b></p>
<p>The C90 standard, as amended, already permits (but does not
require) these functions, and the C++ standard incorporates the
C90 standard by reference.  C99 is not an issue, because it is
never referred to by the C++ standard.</p>





<hr>
<h3><a name="290"></a>290. Requirements to for_each and its function object</h3>
<p><b>Section:</b> 25.2.4 [alg.foreach] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Angelika Langer <b>Opened:</b> 2001-01-03  <b>Last modified:</b> 2009-07-14</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.foreach">issues</a> in [alg.foreach].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>The specification of the for_each algorithm does not have a
"Requires" section, which means that there are no
restrictions imposed on the function object whatsoever. In essence it
means that I can provide any function object with arbitrary side
effects and I can still expect a predictable result. In particular I
can expect that the function object is applied exactly last - first
times, which is promised in the "Complexity" section.
</p>

<p>I don't see how any implementation can give such a guarantee
without imposing requirements on the function object.
</p>

<p>Just as an example: consider a function object that removes
elements from the input sequence.  In that case, what does the
complexity guarantee (applies f exactly last - first times) mean?
</p>

<p>One can argue that this is obviously a nonsensical application and
a theoretical case, which unfortunately it isn't.  I have seen
programmers shooting themselves in the foot this way, and they did not
understand that there are restrictions even if the description of the
algorithm does not say so.
</p>
<p><i>[Lillehammer: This is more general than for_each.  We don't want
  the function object in transform invalidiating iterators
  either. There should be a note somewhere in clause 17 (17, not 25)
  saying that user code operating on a range may not invalidate
  iterators unless otherwise specified.  Bill will provide wording.]</i></p>


<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
Moved to NAD.
</p>
<p>
It was felt that the current description is adequate, and that there are
limits to what the standard can reasonably say to prohibit perverse uses
of the library.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>






<hr>
<h3><a name="293"></a>293. Order of execution in transform algorithm</h3>
<p><b>Section:</b> 25.3.4 [alg.transform] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Angelika Langer <b>Opened:</b> 2001-01-04  <b>Last modified:</b> 2007-01-15</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.transform">issues</a> in [alg.transform].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>This issue is related to issue 242.  In case that the resolution
proposed for issue 242 is accepted, we have have the following
situation: The 4 numeric algorithms (accumulate and consorts) as well
as transform would allow a certain category of side effects.  The
numeric algorithms specify that they invoke the functor "for
every iterator i in the range [first, last) in order". transform,
in contrast, would not give any guarantee regarding order of
invocation of the functor, which means that the functor can be invoked
in any arbitrary order.
</p>

<p>Why would that be a problem?  Consider an example: say the
transformator that is a simple enumerator ( or more generally
speaking, "is order-sensitive" ).  Since a standard
compliant implementation of transform is free to invoke the enumerator
in no definite order, the result could be a garbled enumeration.
Strictly speaking this is not a problem, but it is certainly at odds
with the prevalent understanding of transform as an algorithms that
assigns "a new _corresponding_ value" to the output
elements.
</p>

<p>All implementations that I know of invoke the transformator in
definite order, namely starting from first and proceeding to last -
1. Unless there is an optimization conceivable that takes advantage of
the indefinite order I would suggest to specify the order, because it
eliminate the uncertainty that users would otherwise have regarding
the order of execution of their potentially order-sensitive function
objects.
</p>


<p><b>Proposed resolution:</b></p>
<p>In section 25.2.3 - Transform [lib.alg.transform] change:</p>
<blockquote><p>
-1- Effects: Assigns through every iterator i in the range [result,
result + (last1 - first1)) a new corresponding
value equal to op(*(first1 + (i - result)) or binary_op(*(first1 +
(i - result), *(first2 + (i - result))).
</p></blockquote>
<p>to:</p>
<blockquote><p>
-1- Effects: Computes values by  invoking the operation op or binary_op 
for every iterator in the range [first1, last1) in order. Assigns through
every iterator i in the range [result, result + (last1 - first1)) a new
corresponding
value equal to op(*(first1 + (i - result)) or binary_op(*(first1 +
(i - result), *(first2 + (i - result))).
</p></blockquote>


<p><b>Rationale:</b></p>
<p>For Input Iterators an order is already guaranteed, because
only one order is possible.  If a user who passes a Forward
Iterator to one of these algorithms really needs a specific
order of execution, it's possible to achieve that effect by
wrapping it in an Input Iterator adaptor.</p>





<hr>
<h3><a name="302"></a>302. Need error indication from codecvt&lt;&gt;::do_length</h3>
<p><b>Section:</b> 22.4.1.5 [locale.codecvt.byname] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Gregory Bumgardner <b>Opened:</b> 2001-01-25  <b>Last modified:</b> 2006-12-27</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.codecvt.byname">issues</a> in [locale.codecvt.byname].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The effects of <tt>codecvt&lt;&gt;::do_length()</tt> are described in
22.2.1.5.2, paragraph 10.  As implied by that paragraph, and clarified
in issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#75">75</a>, <tt>codecvt&lt;&gt;::do_length()</tt> must
process the source data and update the <tt>stateT</tt> argument just
as if the data had been processed by <tt>codecvt&lt;&gt;::in()</tt>.
However, the standard does not specify how <tt>do_length()</tt> would
report a translation failure, should the source sequence contain
untranslatable or illegal character sequences.
</p>

<p>
The other conversion methods return an "error" result value
to indicate that an untranslatable character has been encountered, but
<tt>do_length()</tt> already has a return value (the number of source
characters that have been processed by the method).
</p>


<p><b>Proposed resolution:</b></p>
<p>
This issue cannot be resolved without modifying the interface. An exception
cannot be used, as there would be no way to determine how many characters
have been processed and the state object would be left in an indeterminate
state.
</p>

<p>
A source compatible solution involves adding a fifth argument to length()
and do_length() that could be used to return position of the offending
character sequence. This argument would have a default value that would
allow it to be ignored:
</p>

<pre>  int length(stateT&amp; state, 
             const externT* from, 
             const externT* from_end, 
             size_t max,
             const externT** from_next = 0);

  virtual
  int do_length(stateT&amp; state, 
                const externT* from, 
                const externT* from_end, 
                size_t max,
                const externT** from_next);
</pre>

<p>
Then an exception could be used to report any translation errors and
the from_next argument, if used, could then be used to retrieve the
location of the offending character sequence.
</p>


<p><b>Rationale:</b></p>
<p>The standard is already clear: the return value is the number of
"valid complete characters".  If it encounters an invalid sequence of
external characters, it stops.</p>





<hr>
<h3><a name="304"></a>304. Must <tt>*a</tt> return an lvalue when <tt>a</tt> is an input iterator?</h3>
<p><b>Section:</b> X [iterator.concepts] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Dave Abrahams <b>Opened:</b> 2001-02-05  <b>Last modified:</b> 2008-09-30</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#iterator.concepts">issues</a> in [iterator.concepts].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
We all "know" that input iterators are allowed to produce
values when dereferenced of which there is no other in-memory copy.
</p>

<p>
But: Table 72, with a careful reading, seems to imply that this can only be
the case if the value_type has no members (e.g. is a built-in type).
</p>

<p>The problem occurs in the following entry:</p>

<pre>  a-&gt;m     pre: (*a).m is well-defined
           Equivalent to (*a).m
</pre>

<p>
<tt>*a.m</tt> can be well-defined if <tt>*a</tt> is not a reference
type, but since <tt>operator-&gt;()</tt> must return a pointer for
<tt>a-&gt;m</tt> to be well-formed, it needs something to return a
pointer <i>to</i>. This seems to indicate that <tt>*a</tt> must be
buffered somewhere to make a legal input iterator.
</p>

<p>I don't think this was intentional.</p>


<p><b>Rationale:</b></p>
<p>The current standard is clear and consistent.  Input iterators that
  return rvalues are in fact implementable.  They may in some cases
  require extra work, but it is still possible to define an operator-&gt;
  in such cases: it doesn't have to return a T*, but may return a
  proxy type.  No change to the standard is justified.</p>





<hr>
<h3><a name="309"></a>309. Does sentry catch exceptions?</h3>
<p><b>Section:</b> 27.7 [iostream.format] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2001-03-19  <b>Last modified:</b> 2009-07-14</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#iostream.format">issues</a> in [iostream.format].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The descriptions of the constructors of basic_istream&lt;&gt;::sentry
(27.7.1.1.3 [istream::sentry]) and basic_ostream&lt;&gt;::sentry
(27.7.2.4 [ostream::sentry]) do not explain what the functions do in
case an exception is thrown while they execute. Some current
implementations allow all exceptions to propagate, others catch them
and set ios_base::badbit instead, still others catch some but let
others propagate.
</p>

<p>
The text also mentions that the functions may call setstate(failbit)
(without actually saying on what object, but presumably the stream
argument is meant).  That may have been fine for
basic_istream&lt;&gt;::sentry prior to issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#195">195</a>, since
the function performs an input operation which may fail. However,
issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#195">195</a> amends 27.7.1.1.3 [istream::sentry], p2 to
clarify that the function should actually call setstate(failbit |
eofbit), so the sentence in p3 is redundant or even somewhat
contradictory.
</p>

<p>
The same sentence that appears in 27.7.2.4 [ostream::sentry], p3
doesn't seem to be very meaningful for basic_istream&lt;&gt;::sentry
which performs no input. It is actually rather misleading since it
would appear to guide library implementers to calling
setstate(failbit) when os.tie()-&gt;flush(), the only called function,
throws an exception (typically, it's badbit that's set in response to
such an event).
</p>

<p><b>Additional comments from Martin, who isn't comfortable with the
    current proposed resolution</b> (see c++std-lib-11530)</p>

<p>
The istream::sentry ctor says nothing about how the function
deals with exemptions (27.6.1.1.2, p1 says that the class is
responsible for doing "exception safe"(*) prefix and suffix
operations but it doesn't explain what level of exception
safety the class promises to provide). The mockup example
of a "typical implementation of the sentry ctor" given in
27.6.1.1.2, p6, removed in ISO/IEC 14882:2003, doesn't show
exception handling, either. Since the ctor is not classified
as a formatted or unformatted input function, the text in
27.6.1.1, p1 through p4 does not apply. All this would seem
to suggest that the sentry ctor should not catch or in any
way handle exceptions thrown from any functions it may call.
Thus, the typical implementation of an istream extractor may
look something like [1].
</p>

<p>
The problem with [1] is that while it correctly sets ios::badbit
if an exception is thrown from one of the functions called from
the sentry ctor, if the sentry ctor reaches EOF while extracting
whitespace from a stream that has eofbit or failbit set in
exceptions(), it will cause an ios::failure to be thrown, which
will in turn cause the extractor to set ios::badbit.
</p>

<p>
The only straightforward way to prevent this behavior is to
move the definition of the sentry object in the extractor
above the try block (as suggested by the example in 22.2.8,
p9 and also indirectly supported by 27.6.1.3, p1). See [2].
But such an implementation will allow exceptions thrown from
functions called from the ctor to freely propagate to the
caller regardless of the setting of ios::badbit in the stream
object's exceptions().
</p>

<p>
So since neither [1] nor [2] behaves as expected, the only
possible solution is to have the sentry ctor catch exceptions
thrown from called functions, set badbit, and propagate those
exceptions if badbit is also set in exceptions(). (Another
solution exists that deals with both kinds of sentries, but
the code is non-obvious and cumbersome -- see [3].)
</p>

<p>
Please note that, as the issue points out, current libraries
do not behave consistently, suggesting  that implementors are
not quite clear on the exception handling in istream::sentry,
despite the fact that some LWG members might feel otherwise.
(As documented by the parenthetical comment here:
http://anubis.dkuug.dk/jtc1/sc22/wg21/docs/papers/2003/n1480.html#309)
</p>

<p>
Also please note that those LWG members who in Copenhagen
felt that "a sentry's constructor should not catch exceptions,
because sentries should only be used within (un)formatted input
functions and that exception handling is the responsibility of
those functions, not of the sentries," as noted here
http://anubis.dkuug.dk/jtc1/sc22/wg21/docs/papers/2001/n1310.html#309
would in effect be either arguing for the behavior described
in [1] or for extractors implemented along the lines of [3].
</p>

<p>
The original proposed resolution (Revision 25 of the issues
list) clarifies the role of the sentry ctor WRT exception
handling by making it clear that extractors (both library
or user-defined) should be implemented along the lines of
[2] (as opposed to [1]) and that no exception thrown from
the callees should propagate out of either function unless
badbit is also set in exceptions().
</p>


<p>[1] Extractor that catches exceptions thrown from sentry:</p>

<blockquote>
<pre>struct S { long i; };

istream&amp; operator&gt;&gt; (istream &amp;strm, S &amp;s)
{
    ios::iostate err = ios::goodbit;
    try {
        const istream::sentry guard (strm, false);
        if (guard) {
            use_facet&lt;num_get&lt;char&gt; &gt;(strm.getloc ())
                .get (istreambuf_iterator&lt;char&gt;(strm),
                      istreambuf_iterator&lt;char&gt;(),
                      strm, err, s.i);
        }
    }
    catch (...) {
        bool rethrow;
        try {
            strm.setstate (ios::badbit);
            rethrow = false;
        }
        catch (...) {
            rethrow = true;
        }
        if (rethrow)
            throw;
    }
    if (err)
        strm.setstate (err);
    return strm;
}
</pre>
</blockquote>

<p>[2] Extractor that propagates exceptions thrown from sentry:</p>

<blockquote>
<pre>istream&amp; operator&gt;&gt; (istream &amp;strm, S &amp;s)
{
    istream::sentry guard (strm, false);
    if (guard) {
        ios::iostate err = ios::goodbit;
        try {
            use_facet&lt;num_get&lt;char&gt; &gt;(strm.getloc ())
                .get (istreambuf_iterator&lt;char&gt;(strm),
                      istreambuf_iterator&lt;char&gt;(),
                      strm, err, s.i);
        }
        catch (...) {
            bool rethrow;
            try {
                strm.setstate (ios::badbit);
                rethrow = false;
            }
            catch (...) {
                rethrow = true;
            }
            if (rethrow)
                throw;
        }
        if (err)
            strm.setstate (err);
    }
    return strm;
}
</pre>
</blockquote>

<p>
[3] Extractor that catches exceptions thrown from sentry
but doesn't set badbit if the exception was thrown as a
result of a call to strm.clear().
</p>

<blockquote>
<pre>istream&amp; operator&gt;&gt; (istream &amp;strm, S &amp;s)
{
    const ios::iostate state = strm.rdstate ();
    const ios::iostate except = strm.exceptions ();
    ios::iostate err = std::ios::goodbit;
    bool thrown = true;
    try {
        const istream::sentry guard (strm, false);
        thrown = false;
        if (guard) {
            use_facet&lt;num_get&lt;char&gt; &gt;(strm.getloc ())
                .get (istreambuf_iterator&lt;char&gt;(strm),
                      istreambuf_iterator&lt;char&gt;(),
                      strm, err, s.i);
        }
    }
    catch (...) {
        if (thrown &amp;&amp; state &amp; except)
            throw;
        try {
            strm.setstate (ios::badbit);
            thrown = false;
        }
        catch (...) {
            thrown = true;
        }
        if (thrown)
            throw;
    }
    if (err)
        strm.setstate (err);

    return strm;
}
</pre>
</blockquote>

<p>
[Pre-Berlin] Reopened at the request of Paolo Carlini and Steve Clamage.
</p>

<p>
[Pre-Portland] A relevant newsgroup post:
</p>

<p>
The current proposed resolution of issue #309
(http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#309)  is
unacceptable.   I write commerical software and coding around this
makes my code ugly, non-intuitive, and requires comments referring
people to this very issue.   Following is the full explanation of my
experience.
</p>
<p>
In the course of writing software for commercial use, I constructed
std::ifstream's based on user-supplied pathnames on typical POSIX
systems.
</p>
<p>
It was expected that some files that opened successfully might not read
successfully -- such as a pathname which actually refered to a
directory.   Intuitively, I expected the streambuffer underflow() code
to throw an exception in this situation, and recent implementations of
libstdc++'s basic_filebuf do just that (as well as many of my own
custom streambufs).
</p>
<p>
I also intuitively expected that the istream code would convert these
exceptions to the "badbit' set on the stream object, because I had not
requested exceptions.    I refer to 27.6.1.1. P4.
</p>
<p>
However, this was not the case on at least two implementations -- if
the first thing I did with an istream was call operator&gt;&gt;( T&amp; ) for T
among the basic arithmetic types and std::string.   Looking further I
found that the sentry's constructor was invoking the exception when it
pre-scanned for whitespace, and the extractor function (operator&gt;&gt;())
was not catching exceptions in this situation.
</p>
<p>
So, I was in a situation where setting 'noskipws' would change the
istream's behavior even though no characters (whitespace or not) could
ever be successfully read.
</p>
<p>
Also, calling .peek() on the istream before calling the extractor()
changed the behavior (.peek() had the effect of setting the badbit
ahead of time).
</p>
<p>
I found this all to be so inconsistent and inconvenient for me and my
code design, that I filed a bugzilla entry for libstdc++.   I was then
told that the bug cannot be fixed until issue #309 is resolved by the
committee.
</p>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
Moved to NAD.
</p>
<p>
See the rationale in the issue. Paolo, who requested that the issue be
reopened, agreed with the rationale.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>The LWG agrees there is minor variation between implementations,
  but believes that it doesn't matter. This is a rarely used corner
  case. There is no evidence that this has any commercial importance
  or that it causes actual portability problems for customers trying
  to write code that runs on multiple implementations.</p>





<hr>
<h3><a name="313"></a>313. set_terminate and set_unexpected question</h3>
<p><b>Section:</b> 18.8.3.3 [terminate] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Judy Ward <b>Opened:</b> 2001-04-03  <b>Last modified:</b> 2006-12-27</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#terminate">issues</a> in [terminate].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
According to section 18.7.3.3 of the standard, std::terminate() is
supposed to call the terminate_handler in effect immediately after
evaluating the throw expression.
</p>

<p>
Question: what if the terminate_handler in effect is itself
std::terminate?
</p>

<p>For example:</p>

<pre>  #include &lt;exception&gt;

  int main () {
      std::set_terminate(std::terminate);
      throw 5;
      return 0;
  }
</pre>

<p>
Is the implementation allowed to go into an infinite loop?
</p>

<p>
I think the same issue applies to std::set_unexpected.
</p>


<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>Infinite recursion is to be expected: users who set the terminate
handler to <tt>terminate</tt> are explicitly asking for <tt>terminate</tt>
to call itself.</p>





<hr>
<h3><a name="314"></a>314. Is the stack unwound when terminate() is called?</h3>
<p><b>Section:</b> 18.8.3.3 [terminate] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Detlef Vollmann <b>Opened:</b> 2001-04-11  <b>Last modified:</b> 2007-01-15</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#terminate">issues</a> in [terminate].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p>
The standard appears to contradict itself about whether the stack is
unwound when the implementation calls terminate().
</p>

<p>From 18.7.3.3p2:</p>
<blockquote><p>
    Calls the terminate_handler function in effect immediately
    after evaluating the throw-expression (lib.terminate.handler),
    if called by the implementation [...]
</p></blockquote>

<p>So the stack is guaranteed not to be unwound.</p>

<p>But from 15.3p9:</p>
<blockquote><p>
    [...]whether or not the stack is unwound before this call
    to terminate() is implementation-defined (except.terminate).
</p></blockquote>

<p>
And 15.5.1 actually defines that in most cases the stack is unwound.
</p>


<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>There is definitely no contradiction between the core and library
clauses; nothing in the core clauses says that stack unwinding happens
after <tt>terminate</tt> is called.  18.7.3.3p2 does not say anything
about when terminate() is called; it merely specifies which
<tt>terminate_handler</tt> is used.</p>





<hr>
<h3><a name="323"></a>323. abs() overloads in different headers</h3>
<p><b>Section:</b> 26.8 [c.math] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Dave Abrahams <b>Opened:</b> 2001-06-04  <b>Last modified:</b> 2008-03-12</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#c.math">issues</a> in [c.math].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>Currently the standard mandates the following overloads of
abs():</p>

<pre>    abs(long), abs(int) in &lt;cstdlib&gt;

    abs(float), abs(double), abs(long double) in &lt;cmath&gt;

    template&lt;class T&gt; T abs(const complex&lt;T&gt;&amp;) in &lt;complex&gt;

    template&lt;class T&gt; valarray&lt;T&gt; abs(const valarray&lt;T&gt;&amp;); in &lt;valarray&gt;
</pre>

<p>
The problem is that having only some overloads visible of a function
that works on "implicitly inter-convertible" types is dangerous in
practice. The headers that get included at any point in a translation
unit can change unpredictably during program
development/maintenance. The wrong overload might be unintentionally
selected.
</p>

<p>
Currently, there is nothing that mandates the simultaneous visibility
of these overloads. Indeed, some vendors have begun fastidiously
reducing dependencies among their (public) headers as a QOI issue: it
helps people to write portable code by refusing to compile unless all
the correct headers are #included.
</p>

<p>The same issue may exist for other functions in the library.</p>

<p>Redmond: PJP reports that C99 adds two new kinds of abs: complex,
and int_max_abs.</p>

<p>Related issue: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#343">343</a>.</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
The situation is not sufficiently severe to warrant a change.
</blockquote>




<p><b>Rationale:</b></p>
<p>The programs that could potentially be broken by this situation are
  already fragile, and somewhat contrived: For example, a user-defined
  class that has conversion overloads both to <tt>long</tt> and
  to <tt>float</tt>.  If <tt>x</tt> is a value of such a class, then
  <tt>abs(x)</tt> would give the <tt>long</tt> version if the user
  included &lt;cstdlib&gt;, the <tt>float</tt> version if the user
  included &lt;cmath&gt;, and would be diagnosed as ambiguous at
  compile time if the user included both headers.  The LWG couldn't
  find an example of a program whose meaning would be changed (as
  opposed to changing it from well-formed to ill-formed) simply by
  adding another standard header.</p>

<p>Since the harm seems minimal, and there don't seem to be any simple
  and noninvasive solutions, this is being closed as NAD.  It is
  marked as "Future" for two reasons.  First, it might be useful to
  define an <tt>&lt;all&gt;</tt> header that would include all
  Standard Library headers.  Second, we should at least make sure that
  future library extensions don't make this problem worse.</p>





<hr>
<h3><a name="326"></a>326. Missing typedef in moneypunct_byname</h3>
<p><b>Section:</b> 22.4.6.4 [locale.moneypunct.byname] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2001-07-05  <b>Last modified:</b> 2006-12-27</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>The definition of the moneypunct facet contains the typedefs char_type
and string_type. Only one of these names, string_type, is defined in
the derived facet, moneypunct_byname.</p>


<p><b>Proposed resolution:</b></p>
<p>For consistency with the numpunct facet, add a typedef for
char_type to the definition of the moneypunct_byname facet in
22.4.6.4 [locale.moneypunct.byname].</p>


<p><b>Rationale:</b></p>
<p>The absence of the typedef is irrelevant.  Users can still access
the typedef, because it is inherited from the base class.</p>





<hr>
<h3><a name="330"></a>330. Misleading "exposition only" value in class locale definition</h3>
<p><b>Section:</b> 22.3.1 [locale] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2001-07-15  <b>Last modified:</b> 2006-12-27</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale">issues</a> in [locale].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The "exposition only" value of the std::locale::none constant shown in
the definition of class locale is misleading in that it on many
systems conflicts with the value assigned to one if the LC_XXX
constants (specifically, LC_COLLATE on AIX, LC_ALL on HP-UX, LC_CTYPE
on Linux and SunOS). This causes incorrect behavior when such a
constant is passed to one of the locale member functions that accept a
locale::category argument and interpret it as either the C LC_XXX
constant or a bitmap of locale::category values. At least three major
implementations adopt the suggested value without a change and
consequently suffer from this problem.
</p>

<p>
For instance, the following code will (presumably) incorrectly copy facets
belonging to the collate category from the German locale on AIX:
</p>

<pre>  std::locale l (std::locale ("C"), "de_DE", std::locale::none);
</pre>


<p><b>Rationale:</b></p>
<p>The LWG agrees that it may be difficult to implement locale member
functions in such a way that they can take either <tt>category</tt>
arguments or the LC_ constants defined in &lt;cctype&gt;.  In light of
this requirement (22.3.1.1.1 [locale.category], paragraph 2), and in light
of the requirement in the preceding paragraph that it is possible to
combine <tt>category</tt> bitmask elements with bitwise operations,
defining the <tt>category</tt> elements is delicate,
particularly if an implementor is constrained to work with a
preexisting C library.  (Just using the existing LC_ constants would
not work in general.)  There's no set of "exposition only" values that
could give library implementors proper guidance in such a delicate
matter.  The non-normative example we're giving is no worse than
any other choice would be.</p>

<p>See issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#347">347</a>.</p>





<hr>
<h3><a name="332"></a>332. Consider adding increment and decrement operators to std::fpos&lt; T &gt; </h3>
<p><b>Section:</b> 27.5.3 [fpos] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> PremAnand M. Rao <b>Opened:</b> 2001-08-27  <b>Last modified:</b> 2006-12-27</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#fpos">issues</a> in [fpos].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Increment and decrement operators are missing from 
Table 88 -- Position type requirements in 27.5.3 [fpos].
</p>


<p><b>Proposed resolution:</b></p>
<p>
Table 88 (section 27.4.3) -- Position type requirements
be updated to include increment and decrement operators.
</p>

<pre>expression        return type     operational    note

++p               fpos&amp;           p += O(1)
p++               fpos            { P tmp = p;
                                    ++p;
                                    return tmp; }
--p               fpos&amp;           p -= O(1)
p--               fpos            { P tmp = p;
                                    --p;
                                    return tmp; }
</pre>



<p><b>Rationale:</b></p>
<p>The LWG believes this is a request for extension, not a defect
report.  Additionally, nobody saw a clear need for this extension;
<tt>fpos</tt> is used only in very limited ways.</p>





<hr>
<h3><a name="342"></a>342. seek and eofbit</h3>
<p><b>Section:</b> 27.7.1.3 [istream.unformatted] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2001-10-09  <b>Last modified:</b> 2009-07-14</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#istream.unformatted">issues</a> in [istream.unformatted].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>I think we have a defect.</p>

<p>According to lwg issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#60">60</a> which is now a dr, the
description of seekg in 27.7.1.3 [istream.unformatted] paragraph 38 now looks
like:</p>

<blockquote><p>
Behaves as an unformatted input function (as described in 27.6.1.3, 
paragraph 1), except that it does not count the number of characters 
extracted and does not affect the value returned by subsequent calls to 
gcount(). After constructing a sentry object, if fail() != true, 
executes rdbuf()-&gt;pubseekpos( pos).
</p></blockquote>

<p>And according to lwg issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#243">243</a> which is also now a dr,
27.6.1.3, paragraph 1 looks like:</p>

<blockquote><p>
Each unformatted input function begins execution by constructing an 
object of class sentry with the default argument noskipws (second) 
argument true. If the sentry object returns true, when converted to a 
value of type bool, the function endeavors to obtain the requested 
input.  Otherwise, if the sentry constructor exits by throwing an 
exception or if the sentry object returns false, when converted to a 
value of type bool, the function returns without attempting to obtain 
any input. In either case the number of extracted characters is set to 
0; unformatted input functions taking a character array of non-zero 
size as an argument shall also store a null character (using charT()) 
in the first location of the array. If an exception is thrown during 
input then ios::badbit is turned on in *this'ss error state. If 
(exception()&amp;badbit)!= 0 then the exception is rethrown. It also counts 
the number of characters extracted. If no exception has been thrown it 
ends by storing the count in a member object and returning the value 
specified. In any event the sentry object is destroyed before leaving 
the unformatted input function.
</p></blockquote>

<p>And finally 27.6.1.1.2/5 says this about sentry:</p>

<blockquote><p>
If, after any preparation is completed, is.good() is true, ok_ != false 
otherwise, ok_ == false.
</p></blockquote>

<p>
So although the seekg paragraph says that the operation proceeds if 
!fail(), the behavior of unformatted functions says the operation 
proceeds only if good().  The two statements are contradictory when only 
eofbit is set.  I don't think the current text is clear which condition 
should be respected.
</p>

<p><b>Further discussion from Redmond:</b></p>

<p>PJP: It doesn't seem quite right to say that <tt>seekg</tt> is
"unformatted". That makes specific claims about sentry that
aren't quite appropriate for seeking, which has less fragile failure
modes than actual input.  If we do really mean that it's unformatted
input, it should behave the same way as other unformatted input.  On
the other hand, "principle of least surprise" is that seeking from EOF
ought to be OK.</p>

<p>
Pre-Berlin:  Paolo points out several problems with the proposed resolution in
Ready state:
</p>

<ul>
<li>It should apply to both overloads of seekg.</li>
<li>tellg has similar issues, except that it should not call clear().</li>
<li>The point about clear() seems to apply to seekp().</li>
<li>Depending on the outcome of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#419">419</a>
if the sentry
sets <tt>failbit</tt> when it finds <tt>eofbit</tt> already set, then
you can never seek away from the end of stream.</li>
</ul>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
Moved to NAD. Will reopen if proposed resolution is supplied.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>

<p>Change 27.7.1.3 [istream.unformatted] to:</p>
<blockquote><p>
Behaves as an unformatted input function (as described in 27.6.1.3,
paragraph 1), except that it does not count the number of characters
extracted, does not affect the value returned by subsequent calls to
gcount(), and does not examine the value returned by the sentry
object. After constructing a sentry object, if <tt>fail() !=
true</tt>, executes <tt>rdbuf()-&gt;pubseekpos(pos)</tt>.  In
case of success, the function calls clear().
In case of failure, the function calls <tt>setstate(failbit)</tt>
(which may throw <tt>ios_base::failure</tt>).
</p></blockquote>

<p><i>[Lillehammer: Matt provided wording.]</i></p>




<p><b>Rationale:</b></p>
<p>In C, fseek does clear EOF.  This is probably what most users would
  expect.  We agree that having eofbit set should not deter a seek,
  and that a successful seek should clear eofbit. Note
  that <tt>fail()</tt> is true only if <tt>failbit</tt>
  or <tt>badbit</tt> is set, so using <tt>!fail()</tt>, rather
  than <tt>good()</tt>, satisfies this goal.</p>





<hr>
<h3><a name="343"></a>343. Unspecified library header dependencies</h3>
<p><b>Section:</b> 17 [library] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2001-10-09  <b>Last modified:</b> 2009-07-28</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The synopses of the C++ library headers clearly show which names are
required to be defined in each header. Since in order to implement the
classes and templates defined in these headers declarations of other
templates (but not necessarily their definitions) are typically
necessary the standard in 17.4.4, p1 permits library implementers to
include any headers needed to implement the definitions in each header.
</p>

<p>
For instance, although it is not explicitly specified in the synopsis of
&lt;string&gt;, at the point of definition of the std::basic_string template
the declaration of the std::allocator template must be in scope. All
current implementations simply include &lt;memory&gt; from within &lt;string&gt;,
either directly or indirectly, to bring the declaration of
std::allocator into scope.
</p>

<p>
Additionally, however, some implementation also include &lt;istream&gt; and
&lt;ostream&gt; at the top of &lt;string&gt; to bring the declarations of
std::basic_istream and std::basic_ostream into scope (which are needed
in order to implement the string inserter and extractor operators
(21.3.7.9 [lib.string.io])). Other implementations only include
&lt;iosfwd&gt;, since strictly speaking, only the declarations and not the
full definitions are necessary.
</p>

<p>
Obviously, it is possible to implement &lt;string&gt; without actually
providing the full definitions of all the templates std::basic_string
uses (std::allocator, std::basic_istream, and std::basic_ostream).
Furthermore, not only is it possible, doing so is likely to have a
positive effect on compile-time efficiency.
</p>

<p>
But while it may seem perfectly reasonable to expect a program that uses
the std::basic_string insertion and extraction operators to also
explicitly include &lt;istream&gt; or &lt;ostream&gt;, respectively, it doesn't seem
reasonable to also expect it to explicitly include &lt;memory&gt;. Since
what's reasonable and what isn't is highly subjective one would expect
the standard to specify what can and what cannot be assumed.
Unfortunately, that isn't the case.
</p>

<p>The examples below demonstrate the issue.</p>

<p>Example 1:</p>

<p>It is not clear whether the following program is complete:</p>

<pre>#include &lt;string&gt;

extern std::basic_ostream&lt;char&gt; &amp;strm;

int main () {
    strm &lt;&lt; std::string ("Hello, World!\n");
}
</pre>    

<p>or whether one must explicitly include &lt;memory&gt; or
&lt;ostream&gt; (or both) in addition to &lt;string&gt; in order for
the program to compile.</p>


<p>Example 2:</p>

<p>Similarly, it is unclear whether the following program is complete:</p>

<pre>#include &lt;istream&gt;

extern std::basic_iostream&lt;char&gt; &amp;strm;

int main () {
    strm &lt;&lt; "Hello, World!\n";
}
</pre>

<p>
or whether one needs to explicitly include &lt;ostream&gt;, and
perhaps even other headers containing the definitions of other
required templates:</p>

<pre>#include &lt;ios&gt;
#include &lt;istream&gt;
#include &lt;ostream&gt;
#include &lt;streambuf&gt;

extern std::basic_iostream&lt;char&gt; &amp;strm;

int main () {
    strm &lt;&lt; "Hello, World!\n";
}
</pre>

<p>Example 3:</p>

<p>Likewise, it seems unclear whether the program below is complete:</p>
<pre>#include &lt;iterator&gt;

bool foo (std::istream_iterator&lt;int&gt; a, std::istream_iterator&lt;int&gt; b)
{
    return a == b;
}

int main () { }
</pre>

<p>or whether one should be required to include &lt;istream&gt;.</p>

<p>There are many more examples that demonstrate this lack of a
requirement.  I believe that in a good number of cases it would be
unreasonable to require that a program explicitly include all the
headers necessary for a particular template to be specialized, but I
think that there are cases such as some of those above where it would
be desirable to allow implementations to include only as much as
necessary and not more.</p>

<p><i>[
post Bellevue:
]</i></p>


<blockquote>
Position taken in prior reviews is that the idea of a table of header
dependencies is a good one. Our view is that a full paper is needed to
do justice to this, and we've made that recommendation to the issue
author.
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
NAD. Handled by LWG <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1178">1178</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
For every C++ library header, supply a minimum set of other C++ library
headers that are required to be included by that header. The proposed
list is below (C++ headers for C Library Facilities, table 12 in
17.4.1.2, p3, are omitted):
</p>

<pre>+------------+--------------------+
| C++ header |required to include |
+============+====================+
|&lt;algorithm&gt; |                    |
+------------+--------------------+
|&lt;bitset&gt;    |                    |
+------------+--------------------+
|&lt;complex&gt;   |                    |
+------------+--------------------+
|&lt;deque&gt;     |&lt;memory&gt;            |
+------------+--------------------+
|&lt;exception&gt; |                    |
+------------+--------------------+
|&lt;fstream&gt;   |&lt;ios&gt;               |
+------------+--------------------+
|&lt;functional&gt;|                    |
+------------+--------------------+
|&lt;iomanip&gt;   |&lt;ios&gt;               |
+------------+--------------------+
|&lt;ios&gt;       |&lt;streambuf&gt;         |
+------------+--------------------+
|&lt;iosfwd&gt;    |                    |
+------------+--------------------+
|&lt;iostream&gt;  |&lt;istream&gt;, &lt;ostream&gt;|
+------------+--------------------+
|&lt;istream&gt;   |&lt;ios&gt;               |
+------------+--------------------+
|&lt;iterator&gt;  |                    |
+------------+--------------------+
|&lt;limits&gt;    |                    |
+------------+--------------------+
|&lt;list&gt;      |&lt;memory&gt;            |
+------------+--------------------+
|&lt;locale&gt;    |                    |
+------------+--------------------+
|&lt;map&gt;       |&lt;memory&gt;            |
+------------+--------------------+
|&lt;memory&gt;    |                    |
+------------+--------------------+
|&lt;new&gt;       |&lt;exception&gt;         |
+------------+--------------------+
|&lt;numeric&gt;   |                    |
+------------+--------------------+
|&lt;ostream&gt;   |&lt;ios&gt;               |
+------------+--------------------+
|&lt;queue&gt;     |&lt;deque&gt;             |
+------------+--------------------+
|&lt;set&gt;       |&lt;memory&gt;            |
+------------+--------------------+
|&lt;sstream&gt;   |&lt;ios&gt;, &lt;string&gt;     |
+------------+--------------------+
|&lt;stack&gt;     |&lt;deque&gt;             |
+------------+--------------------+
|&lt;stdexcept&gt; |                    |
+------------+--------------------+
|&lt;streambuf&gt; |&lt;ios&gt;               |
+------------+--------------------+
|&lt;string&gt;    |&lt;memory&gt;            |
+------------+--------------------+
|&lt;strstream&gt; |                    |
+------------+--------------------+
|&lt;typeinfo&gt;  |&lt;exception&gt;         |
+------------+--------------------+
|&lt;utility&gt;   |                    |
+------------+--------------------+
|&lt;valarray&gt;  |                    |
+------------+--------------------+
|&lt;vector&gt;    |&lt;memory&gt;            |
+------------+--------------------+
</pre>


<p><b>Rationale:</b></p>
<p>The portability problem is real.  A program that works correctly on
one implementation might fail on another, because of different header
dependencies.  This problem was understood before the standard was
completed, and it was a conscious design choice.</p>
<p>One possible way to deal with this, as a library extension, would
be an &lt;all&gt; header.</p>

<p>
Hinnant:  It's time we dealt with this issue for C++0X.  Reopened.
</p>







<hr>
<h3><a name="344"></a>344. grouping + showbase</h3>
<p><b>Section:</b> 22.4.2 [category.numeric] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2001-10-13  <b>Last modified:</b> 2007-01-15</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
When both grouping and showbase are active and the basefield is octal, 
does the leading 0 participate in the grouping or not?  For example, 
should one format as: 0,123,456 or 0123,456?
</p>
<p>
An analogy can be drawn with hexadecimal.  It appears that 0x123,456 is 
preferred over 0x,123,456.  However, this analogy is not universally 
accepted to apply to the octal base.  The standard is not clear on how 
to format (or parse) in this manner.
</p>

<p><b>Proposed resolution:</b></p>
<p>
Insert into 22.4.3.1.2 [facet.numpunct.virtuals] paragraph 3, just before the last
sentence:
</p>
<blockquote><p>
The leading hexadecimal base specifier "0x" does not participate in 
grouping.  The leading '0' octal base specifier may participate in 
grouping.  It is unspecified if the leading '0' participates in 
formatting octal numbers.  In parsing octal numbers, the implementation 
is encouraged to accept both the leading '0' participating in the 
grouping, and not participating (e.g. 0123,456 or 0,123,456).
</p></blockquote>

<p><b>Rationale:</b></p>
<p>
The current behavior may be unspecified, but it's not clear that it
matters.  This is an obscure corner case, since grouping is usually
intended for the benefit of humans and oct/hex prefixes are usually
intended for the benefit of machines.  There is not a strong enough
consensus in the LWG for action.
</p>




<hr>
<h3><a name="348"></a>348. Minor issue with std::pair operator&lt;</h3>
<p><b>Section:</b> 20.3.4 [pairs] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Andy Sawyer <b>Opened:</b> 2001-10-23  <b>Last modified:</b> 2008-01-05</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#pairs">active issues</a> in [pairs].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#pairs">issues</a> in [pairs].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#532">532</a></p>
<p><b>Discussion:</b></p>


<p>
The current wording of 20.2.2 [lib.pairs] p6 precludes the use of
operator&lt; on any pair type which contains a pointer.
</p>


<p><b>Proposed resolution:</b></p>
<p>In 20.3.4 [pairs] paragraph 6, replace:</p>
<pre>    Returns: x.first &lt; y.first || (!(y.first &lt; x.first) &amp;&amp; x.second &lt;
        y.second).
</pre>
<p>With:</p>
<pre>    Returns: std::less&lt;T1&gt;()( x.first, y.first ) ||
             (!std::less&lt;T1&gt;()( y.first, x.first) &amp;&amp; 
             std::less&lt;T2&gt;()( x.second, y.second ) )
</pre>



<p><b>Rationale:</b></p>
<p>This is an instance of a much more general problem.  If we want
  operator&lt; to translate to std::less for pairs of pointers, where
  do we draw the line?  The same issue applies to individual
  pointers, smart pointer wrappers, std::vector&lt;T*&gt;, and so
  on.</p>

<p>Andy Koenig suggests that the real issue here is that we aren't
  distinguishing adequately between two different orderings, a
  "useful ordering" and a "canonical ordering" that's used just
  because we sometimes need <i>some</i> ordering without caring much
  which ordering it is.  Another example of the later is typeinfo's
  <tt>before</tt>.</p>






<hr>
<h3><a name="350"></a>350. allocator&lt;&gt;::address</h3>
<p><b>Section:</b> 20.8.8.1 [allocator.members], 20.2.2 [allocator.requirements], 17.6.1.1 [contents] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Nathan Myers <b>Opened:</b> 2001-10-25  <b>Last modified:</b> 2007-10-11</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#allocator.members">issues</a> in [allocator.members].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#634">634</a></p>
<p><b>Discussion:</b></p>
<p>See c++std-lib-9006 and c++std-lib-9007.  This issue is taken
verbatim from -9007.</p>

<p>
The core language feature allowing definition of operator&amp;() applied 
to any non-builtin type makes that operator often unsafe to use in 
implementing libraries, including the Standard Library.  The result
is that many library facilities fail for legal user code, such as
the fragment</p>
<pre>  class A { private: A* operator&amp;(); };
  std::vector&lt;A&gt; aa;

  class B { };
  B* operator&amp;(B&amp;) { return 0; }
  std::vector&lt;B&gt; ba;
</pre>

<p>
In particular, the requirements table for Allocator (Table 32) specifies
no semantics at all for member address(), and allocator&lt;&gt;::address is 
defined in terms of unadorned operator &amp;.
</p>



<p><b>Proposed resolution:</b></p>
<p>
In 20.6.1.1, Change the definition of allocator&lt;&gt;::address from:</p>
<blockquote><p>
  Returns: &amp;x
</p></blockquote>

<p>to:</p>

<p>
  Returns: The value that the built in operator&amp;(x) would return if not 
  overloaded.
</p>

<p>
In 20.1.6, Table 32, add to the Notes column of the a.address(r) and
a.address(s) lines, respectively: 
</p>

<pre>  allocator&lt;T&gt;::address(r)
  allocator&lt;T&gt;::address(s)
</pre> 

<p>In addition, in clause 17.4.1.1, add a statement:</p>

<blockquote><p>
 The Standard Library does not apply operator&amp; to any type for which
 operator&amp; may be overloaded.
</p></blockquote> 



<p><b>Rationale:</b></p>
<p>The LWG believes both examples are ill-formed.  The contained type
is required to be CopyConstructible (20.2.1 [utility.arg.requirements]), and that
includes the requirement that &amp;t return the usual types and
values. Since allocators are intended to be used in conjunction with
containers, and since the CopyConstructible requirements appear to
have been written to deal with the concerns of this issue, the LWG
feels it is NAD unless someone can come up with a well-formed example
exhibiting a problem.</p>

<p>It may well be that the CopyConstructible requirements are too
  restrictive and that either the container requirements or the
  CopyConstructive requirements should be relaxed, but that's a far
  larger issue.  Marking this issue as "future" as a pointer to that
  larger issue.</p>





<hr>
<h3><a name="351"></a>351. unary_negate and binary_negate: struct or class?</h3>
<p><b>Section:</b> 20.7 [function.objects] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Dale Riley <b>Opened:</b> 2001-11-12  <b>Last modified:</b> 2007-04-24</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#function.objects">issues</a> in [function.objects].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 20.7 [function.objects] the header &lt;functional&gt; synopsis declares
the unary_negate and binary_negate function objects as struct.
However in 20.7.10 [negators] the unary_negate and binary_negate
function objects are defined as class.  Given the context, they are
not "basic function objects" like negate, so this is either a typo or
an editorial oversight.
</p>

<p><i>[Taken from comp.std.c++]</i></p>



<p><b>Proposed resolution:</b></p>
<p>Change the synopsis to reflect the useage in 20.7.10 [negators]</p>

<p><i>[Curaao: Since the language permits "struct", the LWG
views this as NAD. They suggest, however, that the Project Editor
might wish to make the change as editorial.]</i></p>







<hr>
<h3><a name="353"></a>353. <tt>std::pair</tt> missing template assignment</h3>
<p><b>Section:</b> 20.3.4 [pairs] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2001-12-02  <b>Last modified:</b> 2008-01-05</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#pairs">active issues</a> in [pairs].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#pairs">issues</a> in [pairs].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The class template <tt>std::pair</tt> defines a template ctor (20.2.2, p4) but
no template assignment operator. This may lead to inefficient code since
assigning an object of <tt>pair&lt;C, D&gt;</tt> to <tt>pair&lt;A, B&gt;</tt>
where the types <tt>C</tt> and <tt>D</tt> are distinct from but convertible to
<tt>A</tt> and <tt>B</tt>, respectively, results in a call to the template copy
ctor to construct an unnamed temporary of type <tt>pair&lt;A, B&gt;</tt>
followed by an ordinary (perhaps implicitly defined) assignment operator,
instead of just a straight assignment.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add the following declaration to the definition of <tt>std::pair</tt>:
</p>
<pre>    template&lt;class U, class V&gt;
    pair&amp; operator=(const pair&lt;U, V&gt; &amp;p);
</pre>
<p>
And also add a paragraph describing the effects of the function template to the
end of 20.2.2:
</p>
<pre>    template&lt;class U, class V&gt;
    pair&amp; operator=(const pair&lt;U, V&gt; &amp;p);
</pre>
<p>
    <b>Effects</b>: <tt>first = p.first;</tt>
                    <tt>second = p.second;</tt>
    <b>Returns</b>: <tt>*this</tt>
</p>

<p><i>[Curaao: There is no indication this is was anything other than
a design decision, and thus NAD.&nbsp; May be appropriate for a future
standard.]</i></p>


<p><i>[
Pre Bellevue:  It was recognized that this was taken care of by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1856.html">N1856</a>,
and thus moved from NAD Future to NAD Editorial.
]</i></p>






<hr>
<h3><a name="356"></a>356. Meaning of ctype_base::mask enumerators</h3>
<p><b>Section:</b> 22.4.1 [category.ctype] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2002-01-23  <b>Last modified:</b> 2006-12-27</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#category.ctype">issues</a> in [category.ctype].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p>What should the following program print?</p>

<pre>  #include &lt;locale&gt;
  #include &lt;iostream&gt;

  class my_ctype : public std::ctype&lt;char&gt;
  {
    typedef std::ctype&lt;char&gt; base;
  public:
    my_ctype(std::size_t refs = 0) : base(my_table, false, refs)
    {
      std::copy(base::classic_table(), base::classic_table() + base::table_size,
                my_table);
      my_table[(unsigned char) '_'] = (base::mask) (base::print | base::space);
    }
  private:
    mask my_table[base::table_size];
  };

  int main()
  {
    my_ctype ct;
    std::cout &lt;&lt; "isspace: " &lt;&lt; ct.is(std::ctype_base::space, '_') &lt;&lt; "    "
              &lt;&lt; "isalpha: " &lt;&lt; ct.is(std::ctype_base::alpha, '_') &lt;&lt; std::endl;
  }
</pre>

<p>The goal is to create a facet where '_' is treated as whitespace.</p>

<p>On gcc 3.0, this program prints "isspace: 1 isalpha: 0".  On
Microsoft C++ it prints "isspace: 1 isalpha: 1".</p>

<p>
I believe that both implementations are legal, and the standard does not
give enough guidance for users to be able to use std::ctype's
protected interface portably.</p>

<p>
The above program assumes that ctype_base::mask enumerators like
<tt>space</tt> and <tt>print</tt> are disjoint, and that the way to
say that a character is both a space and a printing character is to or
those two enumerators together.  This is suggested by the "exposition
only" values in 22.4.1 [category.ctype], but it is nowhere specified in
normative text.  An alternative interpretation is that the more
specific categories subsume the less specific.  The above program
gives the results it does on the Microsoft compiler because, on that
compiler, <tt>print</tt> has all the bits set for each specific
printing character class.
</p>

<p>From the point of view of std::ctype's public interface, there's no
important difference between these two techniques.  From the point of
view of the protected interface, there is.  If I'm defining a facet
that inherits from std::ctype&lt;char&gt;, I'm the one who defines the
value that table()['a'] returns.  I need to know what combination of
mask values I should use.  This isn't so very esoteric: it's exactly
why std::ctype has a protected interface.  If we care about users
being able to write their own ctype facets, we have to give them a
portable way to do it.
</p>

<p>
Related reflector messages:
lib-9224, lib-9226, lib-9229, lib-9270, lib-9272, lib-9273, lib-9274,
lib-9277, lib-9279.
</p>

<p>Issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#339">339</a> is related, but not identical.  The
proposed resolution if issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#339">339</a> says that
ctype_base::mask must be a bitmask type. It does not say that the
ctype_base::mask elements are bitmask elements, so it doesn't
directly affect this issue.</p>

<p>More comments from Benjamin Kosnik, who believes that 
that C99 compatibility essentially requires what we're
calling option 1 below.</p>

<blockquote>
<pre>I think the C99 standard is clear, that isspace -&gt; !isalpha.
--------

#include &lt;locale&gt;
#include &lt;iostream&gt;

class my_ctype : public std::ctype&lt;char&gt;
{
private:
  typedef std::ctype&lt;char&gt; base;
  mask my_table[base::table_size];

public:
  my_ctype(std::size_t refs = 0) : base(my_table, false, refs)
  {
    std::copy(base::classic_table(), base::classic_table() + base::table_size,
              my_table);
    mask both = base::print | base::space;
    my_table[static_cast&lt;mask&gt;('_')] = both;
  }
};

int main()
{
  using namespace std;
  my_ctype ct;
  cout &lt;&lt; "isspace: " &lt;&lt; ct.is(ctype_base::space, '_') &lt;&lt; endl;
  cout &lt;&lt; "isprint: " &lt;&lt; ct.is(ctype_base::print, '_') &lt;&lt; endl;

  // ISO C99, isalpha iff upper | lower set, and !space.
  // 7.5, p 193
  // -&gt; looks like g++ behavior is correct.
  // 356 -&gt; bitmask elements are required for ctype_base
  // 339 -&gt; bitmask type required for mask
  cout &lt;&lt; "isalpha: " &lt;&lt; ct.is(ctype_base::alpha, '_') &lt;&lt; endl;
}
</pre>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>Informally, we have three choices:</p> 
<ol>
<li>Require that the enumerators are disjoint (except for alnum and
graph)</li>
<li>Require that the enumerators are not disjoint, and specify which
of them subsume which others.  (e.g. mandate that lower includes alpha
and print)</li>
<li>Explicitly leave this unspecified, which the result that the above
program is not portable.</li>
</ol>

<p>Either of the first two options is just as good from the standpoint
of portability.  Either one will require some implementations to
change.</p>


<p><b>Rationale:</b></p>
<p>The LWG agrees that this is a real ambiguity, and that both
interpretations are conforming under the existing standard. However,
there's no evidence that it's causing problems for real users. Users
who want to define ctype facets portably can test the ctype_base masks
to see which interpretation is being used.</p>





<hr>
<h3><a name="357"></a>357. &lt;cmath&gt; float functions cannot return HUGE_VAL</h3>
<p><b>Section:</b> 26.8 [c.math] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Ray Lischner <b>Opened:</b> 2002-02-26  <b>Last modified:</b> 2007-04-24</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#c.math">issues</a> in [c.math].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The float versions of the math functions have no meaningful value to return 
for a range error. The long double versions have a value they can return, 
but it isn't necessarily the most reasonable value.
</p>

<p>
Section 26.5 [lib.c.math], paragraph 5, says that C++ "adds float and long 
double overloaded versions of these functions, with the same semantics," 
referring to the math functions from the C90 standard.
</p>

<p>
The C90 standard, in section 7.5.1, paragraph 3, says that functions return 
"the value of the macro HUGE_VAL" when they encounter a range error. 
Section 7.5, paragraph 2, defines HUGE_VAL as a macro that "expands to a 
positive double expression, not necessarily representable as a float."
</p>

<p>
Therefore, the float versions of the math functions have no way to
signal a range error. <i>[Curaao: The LWG notes that this isn't
strictly correct, since errno is set.]</i> The semantics require that they
return HUGE_VAL, but they cannot because HUGE_VAL might not be
representable as a float.
</p>

<p>
The problem with long double functions is less severe because HUGE_VAL is 
representable as a long double. On the other hand, it might not be a "huge" 
long double value, and might fall well within the range of normal return 
values for a long double function. Therefore, it does not make sense for a 
long double function to return a double (HUGE_VAL) for a range error.
</p>


<p><b>Proposed resolution:</b></p>
<p>Curaao: C99 was faced with a similar problem, which they fixed by
adding HUGE_VALF and HUGE_VALL in addition to HUGE_VAL.</p>

<p>C++ must also fix, but it should be done in the context of the
general C99 based changes to C++, not via DR. Thus the LWG in Curaao
felt the resolution should be NAD, FUTURE, but the issue is being held
open for one more meeting to ensure LWG members not present during the
discussion concur.</p>


<p><b>Rationale:</b></p>
<p>Will be fixed as part of more general work in the TR.</p>





<hr>
<h3><a name="361"></a>361. num_get&lt;&gt;::do_get (..., void*&amp;) checks grouping</h3>
<p><b>Section:</b> 22.4.2.2.2 [facet.num.put.virtuals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2002-03-12  <b>Last modified:</b> 2007-01-15</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#facet.num.put.virtuals">active issues</a> in [facet.num.put.virtuals].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#facet.num.put.virtuals">issues</a> in [facet.num.put.virtuals].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
22.2.2.2.2, p12 specifies that <tt>thousands_sep</tt> is to be inserted only
for integral types (issue 282 suggests that this should be done for
all arithmetic types).
</p>

<p>
22.2.2.1.2, p12 requires that grouping be checked for all extractors
including that for <tt>void*</tt>.
</p>

<p>
I don't think that's right. <tt>void*</tt> values should not be checked for
grouping, should they? (Although if they should, then <tt>num_put</tt> needs
to write them out, otherwise their extraction will fail.)
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change the first sentence of 22.2.2.2.2, p12 from
</p>
<blockquote><p>
    Digit grouping is checked. That is, the positions of discarded
    separators is examined for consistency with
    use_facet&lt;numpunct&lt;charT&gt; &gt;(loc).grouping().
    If they are not consistent then ios_base::failbit is assigned
    to err.
</p></blockquote>

<p>to</p>
<blockquote><p>
    Except for conversions to void*, digit grouping is checked...
</p></blockquote>



<p><b>Rationale:</b></p>
<p>This would be a change: as it stands, the standard clearly
  specifies that grouping applies to void*.  A survey of existing
  practice shows that most existing implementations do that, as they
  should.</p>





<hr>
<h3><a name="366"></a>366. Excessive const-qualification</h3>
<p><b>Section:</b> 27 [input.output] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Walter Brown, Marc Paterno <b>Opened:</b> 2002-05-10  <b>Last modified:</b> 2006-12-27</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#input.output">issues</a> in [input.output].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The following member functions are declared const, yet return non-const
pointers. We believe they are should be changed, because they allow code
that may surprise the user. See document N1360 for details and
rationale.
</p>

<p><i>[Santa Cruz: the real issue is that we've got const member
functions that return pointers to non-const, and N1360 proposes
replacing them by overloaded pairs.  There isn't a consensus about
whether this is a real issue, since we've never said what our
constness policy is for iostreams.  N1360 relies on a distinction
between physical constness and logical constness; that distinction, or
those terms, does not appear in the standard.]</i></p>




<p><b>Proposed resolution:</b></p>
<p>In 27.4.4 and 27.4.4.2</p>
<p>Replace</p>
<pre>  basic_ostream&lt;charT,traits&gt;* tie() const;
</pre>
<p>with</p>
<pre>  basic_ostream&lt;charT,traits&gt;* tie();
  const basic_ostream&lt;charT,traits&gt;* tie() const;
</pre>

<p>and replace</p>
<pre>  basic_streambuf&lt;charT,traits&gt;* rdbuf() const;
</pre>
<p>with</p>
<pre>  basic_streambuf&lt;charT,traits&gt;* rdbuf();
  const basic_streambuf&lt;charT,traits&gt;* rdbuf() const;
</pre>

<p>In 27.5.2 and 27.5.2.3.1</p>
<p>Replace</p>
<pre>  char_type* eback() const;
</pre>
<p>with</p>
<pre>  char_type* eback();
  const char_type* eback() const;
</pre>

<p>Replace</p>
<pre>  char_type gptr() const;
</pre>
<p>with</p>
<pre>  char_type* gptr();
  const char_type* gptr() const;
</pre>

<p>Replace</p>
<pre>  char_type* egptr() const;
</pre>
<p>with</p>
<pre>  char_type* egptr();
  const char_type* egptr() const;
</pre>

<p>In 27.5.2 and 27.5.2.3.2</p>
<p>Replace</p>
<pre>  char_type* pbase() const;
</pre>
<p>with</p>
<pre>  char_type* pbase();
  const char_type* pbase() const;
</pre>

<p>Replace</p>
<pre>  char_type* pptr() const;
</pre>
<p>with</p>
<pre>  char_type* pptr();
  const char_type* pptr() const;
</pre>

<p>Replace</p>
<pre>  char_type* epptr() const;
</pre>
<p>with</p>
<pre>  char_type* epptr();
  const char_type* epptr() const;
</pre>

<p>In 27.7.2, 27.7.2.2, 27.7.3 27.7.3.2, 27.7.4, and 27.7.6</p>
<p>Replace</p>
<pre>  basic_stringbuf&lt;charT,traits,Allocator&gt;* rdbuf() const;
</pre>
<p>with</p>
<pre>  basic_stringbuf&lt;charT,traits,Allocator&gt;* rdbuf();
  const basic_stringbuf&lt;charT,traits,Allocator&gt;* rdbuf() const;
</pre>

<p>In  27.8.1.5, 27.8.1.7, 27.8.1.8, 27.8.1.10, 27.8.1.11, and 27.8.1.13</p>
<p>Replace</p>
<pre>  basic_filebuf&lt;charT,traits&gt;* rdbuf() const;
</pre>
<p>with</p>
<pre>  basic_filebuf&lt;charT,traits&gt;* rdbuf();
  const basic_filebuf&lt;charT,traits&gt;* rdbuf() const;
</pre>


<p><b>Rationale:</b></p>
<p>The existing specification is a bit sloppy, but there's no
  particular reason to change this other than tidiness, and there are
  a number of ways in which streams might have been designed
  differently if we were starting today.  There's no evidence that the
  existing constness policy is harming users.  We might consider
  a different constness policy as part of a full stream redesign.</p>





<hr>
<h3><a name="367"></a>367. remove_copy/remove_copy_if and Input Iterators</h3>
<p><b>Section:</b> 25.3.8 [alg.remove] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Anthony Williams <b>Opened:</b> 2002-05-13  <b>Last modified:</b> 2006-12-27</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.remove">issues</a> in [alg.remove].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
remove_copy and remove_copy_if (25.3.8 [alg.remove]) permit their
input range to be marked with Input Iterators. However, since two
operations are required against the elements to copy (comparison and
assigment), when the input range uses Input Iterators, a temporary
copy must be taken to avoid dereferencing the iterator twice. This
therefore requires the value type of the InputIterator to be
CopyConstructible. If the iterators are at least Forward Iterators,
then the iterator can be dereferenced twice, or a reference to the
result maintained, so the temporary is not required.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add "If InputIterator does not meet the requirements of forward
iterator, then the value type of InputIterator must be copy
constructible. Otherwise copy constructible is not required." to
25.3.8 [alg.remove] paragraph 6.
</p>


<p><b>Rationale:</b></p>
<p>The assumption is that an input iterator can't be dereferenced
  twice.  There's no basis for that assumption in the Standard.</p>





<hr>
<h3><a name="368"></a>368. basic_string::replace has two "Throws" paragraphs</h3>
<p><b>Section:</b> 21.4.6.6 [string::replace] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Beman Dawes <b>Opened:</b> 2002-06-03  <b>Last modified:</b> 2007-04-24</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
21.4.6.6 [string::replace] basic_string::replace, second
signature, given in paragraph 1, has two "Throws" paragraphs (3 and
5).
</p>

<p>
In addition, the second "Throws" paragraph (5) includes specification
(beginning with "Otherwise, the function replaces ...") that should be
part of the "Effects" paragraph.
</p>


<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>This is editorial. Both "throws" statements are true. The bug is
  just that the second one should be a sentence, part of the "Effects"
  clause, not a separate "Throws".  The project editor has been
  notified.</p>





<hr>
<h3><a name="372"></a>372. Inconsistent description of stdlib exceptions</h3>
<p><b>Section:</b> 17.6.4.11 [res.on.exception.handling], 18.7.1 [type.info] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Randy Maddox <b>Opened:</b> 2002-07-22  <b>Last modified:</b> 2006-12-27</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#res.on.exception.handling">issues</a> in [res.on.exception.handling].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p>Paragraph 3 under clause 17.6.4.11 [res.on.exception.handling], Restrictions on
Exception Handling, states that "Any other functions defined in the
C++ Standard Library that do not have an exception-specification may
throw implementation-defined exceptions unless otherwise specified."
This statement is followed by a reference to footnote 178 at the
bottom of that page which states, apparently in reference to the C++
Standard Library, that "Library implementations are encouraged (but
not required) to report errors by throwing exceptions from (or derived
from) the standard exceptions."</p>

<p>These statements appear to be in direct contradiction to clause
18.7.1 [type.info], which states "The class exception defines the
base class for the types of objects thrown as exceptions by the C++
Standard library components ...".</p>

<p>Is this inconsistent?</p>



<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>Clause 17 is setting the overall library requirements, and it's
  clear and consistent.  This sentence from Clause 18 is descriptive,
  not setting a requirement on any other class.
</p>





<hr>
<h3><a name="374"></a>374. moneypunct::frac_digits returns int not unsigned</h3>
<p><b>Section:</b> 22.4.6.3.1 [locale.moneypunct.members], 22.4.6.3.2 [locale.moneypunct.virtuals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Ray Lischner <b>Opened:</b> 2002-08-08  <b>Last modified:</b> 2006-12-27</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In section 22.4.6.3.1 [locale.moneypunct.members], frac_digits() returns type
"int". This implies that frac_digits() might return a negative value,
but a negative value is nonsensical. It should return "unsigned".
</p>

<p>
Similarly, in section 22.4.6.3.2 [locale.moneypunct.virtuals], do_frac_digits()
should return "unsigned".
</p>



<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>Regardless of whether the return value is int or unsigned, it's
always conceivable that frac_digits might return a nonsensical
value. (Is 4294967295 really any better than -1?)  The clients of
moneypunct, the get and put facets, can and do perform range
checks.</p>





<hr>
<h3><a name="377"></a>377. basic_string::insert and length_error</h3>
<p><b>Section:</b> 21.4.6.4 [string::insert] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Ray Lischner <b>Opened:</b> 2002-08-16  <b>Last modified:</b> 2006-12-27</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#string::insert">issues</a> in [string::insert].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Section 21.4.6.4 [string::insert], paragraph 4, contains the following,
"Then throws length_error if size() &gt;= npos - rlen."
</p>

<p>
Related to DR 83, this sentence should probably be removed.
</p>


<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p><p>This requirement is redundant but correct.  No change is
needed.</p>




<hr>
<h3><a name="378"></a>378. locale immutability and locale::operator=()</h3>
<p><b>Section:</b> 22.3.1 [locale] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2002-09-06  <b>Last modified:</b> 2006-12-30</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale">issues</a> in [locale].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#31">31</a></p>
<p><b>Discussion:</b></p>
<p>
I think there is a problem with 22.1.1, p6 which says that
</p>
<pre>    -6- An instance of locale is immutable; once a facet reference
        is obtained from it, that reference remains usable as long
        as the locale value itself exists.
</pre>
<p>
and 22.1.1.2, p4:
</p>
<pre>    const locale&amp; operator=(const locale&amp; other) throw();

    -4- Effects: Creates a copy of other, replacing the current value.
</pre>
<p>
How can a reference to a facet obtained from a locale object remain
valid after an assignment that clearly must replace all the facets
in the locale object? Imagine a program such as this
</p>
<pre>    std::locale loc ("de_DE");
    const std::ctype&lt;char&gt; &amp;r0 = std::use_facet&lt;std::ctype&lt;char&gt; &gt;(loc);
    loc = std::locale ("en_US");
    const std::ctype&lt;char&gt; &amp;r1 = std::use_facet&lt;std::ctype&lt;char&gt; &gt;(loc);
</pre>
<p>
Is r0 really supposed to be preserved and destroyed only when loc goes
out of scope?
</p>


<p><b>Proposed resolution:</b></p>
<p><i>[Summer '04 mid-meeting mailing: Martin and Dietmar believe this
  is a duplicate of issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#31">31</a> and recommend that it be
  closed.
]</i></p>






<hr>
<h3><a name="382"></a>382. codecvt do_in/out result</h3>
<p><b>Section:</b> 22.4.1.4 [locale.codecvt] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2002-08-30  <b>Last modified:</b> 2009-07-14</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.codecvt">issues</a> in [locale.codecvt].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It seems that the descriptions of codecvt do_in() and do_out() leave
sufficient room for interpretation so that two implementations of
codecvt may not work correctly with the same filebuf. Specifically,
the following seems less than adequately specified:
</p>

<ol>
<li>
  the conditions under which the functions terminate
</li>
<li>
  precisely when the functions return ok
</li>
<li>
  precisely when the functions return partial
</li>
<li>
  the full set of conditions when the functions return error
</li>
</ol>

<ol>
<li>
   22.4.1.4.2 [locale.codecvt.virtuals], p2 says this about the effects of the
   function: ...Stops if it encounters a character it cannot
   convert...  This assumes that there *is* a character to
   convert. What happens when there is a sequence that doesn't form a
   valid source character, such as an unassigned or invalid UNICODE
   character, or a sequence that cannot possibly form a character
   (e.g., the sequence "\xc0\xff" in UTF-8)?
</li>
<li>
   Table 53 says that the function returns codecvt_base::ok
   to indicate that the function(s) "completed the conversion."
   Suppose that the source sequence is "\xc0\x80" in UTF-8,
   with from pointing to '\xc0' and (from_end==from + 1).
   It is not clear whether the return value should be ok
   or partial (see below).
</li>
<li>
   Table 53 says that the function returns codecvt_base::partial
   if "not all source characters converted." With the from pointers
   set up the same way as above, it is not clear whether the return
   value should be partial or ok (see above).
</li>
<li>
   Table 53, in the row describing the meaning of error mistakenly
   refers to a "from_type" character, without the symbol from_type
   having been defined. Most likely, the word "source" character
   is intended, although that is not sufficient. The functions
   may also fail when they encounter an invalid source sequence
   that cannot possibly form a valid source character (e.g., as
   explained in bullet 1 above).
</li>
</ol>
<p>
Finally, the conditions described at the end of 22.4.1.4.2 [locale.codecvt.virtuals], p4 don't seem to be possible:
</p>
<blockquote><p>
    "A return value of partial, if (from_next == from_end),
    indicates that either the destination sequence has not
    absorbed all the available destination elements, or that
    additional source elements are needed before another
    destination element can be produced."
</p></blockquote>
<p>
If the value is partial, it's not clear to me that (from_next
==from_end) could ever hold if there isn't enough room
in the destination buffer. In order for (from_next==from_end) to
hold, all characters in that range must have been successfully
converted (according to 22.4.1.4.2 [locale.codecvt.virtuals], p2) and since there are no
further source characters to convert, no more room in the
destination buffer can be needed.
</p>
<p>
It's also not clear to me that (from_next==from_end) could ever
hold if additional source elements are needed to produce another
destination character (not element as incorrectly stated in the
text). partial is returned if "not all source characters have
been converted" according to Table 53, which also implies that
(from_next==from) does NOT hold.
</p>
<p>
Could it be that the intended qualifying condition was actually
(from_next != from_end), i.e., that the sentence was supposed
to read
</p>
<blockquote><p>
    "A return value of partial, if (from_next != from_end),..."
</p></blockquote>
<p>
which would make perfect sense, since, as far as I understand it,
partial can only occur if (from_next != from_end)?
</p>
<p><i>[Lillehammer: Defer for the moment, but this really needs to be
  fixed. Right now, the description of codecvt is too vague for it to
  be a useful contract between providers and clients of codecvt
  facets.  (Note that both vendors and users can be both providers and
  clients of codecvt facets.) The major philosophical issue is whether
  the standard should only describe mappings that take a single wide
  character to multiple narrow characters (and vice versa), or whether
  it should describe fully general N-to-M conversions. When the
  original standard was written only the former was contemplated, but
  today, in light of the popularity of utf8 and utf16, that doesn't
  seem sufficient for C++0x. Bill supports general N-to-M conversions;
  we need to make sure Martin and Howard agree.]</i></p>


<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
codecvt is meant to be a 1-to-N to N-to-1 conversion. It does not work
well for N-to-M conversions. wbuffer_convert now exists, and handles
N-to-M cases. Also, there is a new specialization of codecvt that
permits UTF-16 &lt;-&gt; UTF-8 conversions.
</p>
<p>
NAD without prejudice. Will reopen if proposed resolution is supplied.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>




<hr>
<h3><a name="385"></a>385. Does call by value imply the CopyConstructible requirement?</h3>
<p><b>Section:</b> 17 [library] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2002-10-23  <b>Last modified:</b> 2007-04-18</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Many function templates have parameters that are passed by value;
a typical example is <tt>find_if</tt>'s <i>pred</i> parameter in
25.2.5 [alg.find].  Are the corresponding template parameters
(<tt>Predicate</tt> in this case) implicitly required to be
CopyConstructible, or does that need to be spelled out explicitly?
</p>

<p>
This isn't quite as silly a question as it might seem to be at first
sight.  If you call <tt>find_if</tt> in such a way that template
argument deduction applies, then of course you'll get call by value
and you need to provide a copy constructor.  If you explicitly provide
the template arguments, however, you can force call by reference by
writing something like <tt>find_if&lt;my_iterator,
my_predicate&amp;&gt;</tt>.  The question is whether implementation
are required to accept this, or whether this is ill-formed because
my_predicate&amp; is not CopyConstructible.
</p>

<p>
The scope of this problem, if it is a problem, is unknown.  Function
object arguments to generic algorithms in clauses 25 [algorithms]
and 26 [numerics] are obvious examples.  A review of the whole
library is necessary.
</p>
<p><i>[
This is really two issues.  First, predicates are typically passed by
value but we don't say they must be Copy Constructible.  They should
be. Second: is specialization allowed to transform value arguments
into references? References aren't copy constructible, so this should
not be allowed.
]</i></p>

<p><i>[
2007-01-12, Howard: First, despite the note above, references <b>are</b>
copy constructible. They just aren't assignable.  Second, this is very
closely related to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#92">92</a> and should be consistent with that.
That issue already says that implementations are allowed to copy
function objects.  If one passes in a reference, it is copyable, but
susceptible to slicing if one passes in a reference to a base.  Third,
with rvalue reference in the language one only needs to satisfy
MoveConstructible to pass an rvalue "by value".  Though the function
might still copy the function object internally (requiring
CopyConstructible). Finally (and fwiw), if we wanted to, it is easy to
code all of the std::algorithms such that they do not copy function
objects internally.  One merely passes them by reference internally if
desired (this has been fully implemented and shipped for several years).
 If this were mandated, it would reverse <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#92">92</a>, allowing
function objects to reliably maintain state.  E.g. the example in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#92">92</a> would reliably remove only the third element.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
Recommend NAD.
</p>


<p><b>Rationale:</b></p>
<p>
Generic algorithms will be marked with concepts and these will imply a requirement
of MoveConstructible (not CopyConstructible).  The signature of the function will
then precisely describe and enforce the precise requirements.
</p>





<hr>
<h3><a name="388"></a>388. Use of complex as a key in associative containers</h3>
<p><b>Section:</b> 26.4 [complex.numbers] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Gabriel Dos Reis <b>Opened:</b> 2002-11-08  <b>Last modified:</b> 2008-02-27</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#complex.numbers">issues</a> in [complex.numbers].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Practice with std::complex&lt;&gt; and the associative containers
occasionally reveals artificial and distracting issues with constructs
resembling: std::set&lt;std::complex&lt;double&gt; &gt; s;
</p>

<p>
The main reason for the above to fail is the absence of an approriate
definition for std::less&lt;std::complex&lt;T&gt; &gt;. That in turn comes from
the definition of the primary template std::less&lt;&gt; in terms of
operator&lt;.
</p>

<p>
The usual argument goes as follows: Since there is no ordering over
the complex field compatible with field operations it makes little
sense to define a function operator&lt; operating on the datatype
std::complex&lt;T&gt;.  That is fine. However, that reasoning does not carry
over to std::less&lt;T&gt; which is used, among other things, by associative
containers as an ordering useful to meet complexity requirements.
</p>

<p>Related issue: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#348">348</a>.</p>

<p><i>[
Pre Bellevue: Reopened at the request of Alisdair.
]</i></p>


<p><i>[
Bellevue:
]</i></p>


<blockquote>
This is a request for a design change, and not a defect in the standard.
It is in scope to consider, but the group feels that it is not a change
that we need to do. Is there a total ordering for floating point values,
including NaN? There is not a clear enough solution or big enough
problem for us to solve. Solving this problem would require solving the
problem for floating point, which is equally unclear. The LWG noted that
users who want to put objects into an associative container for which
operator&lt; isn't defined can simply provide their own comparison function
object. NAD
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>Informally: Add a specialization of std::less for std::complex.</p>


<p><b>Rationale:</b></p>
<p>Discussed in Santa Cruz.  An overwhelming majority of the LWG
believes this should not be treated a DR: it's a request for a design
change, not a defect in the existing standard.  Most people (10-3)
believed that we probably don't want this change, period: as with
issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#348">348</a>, it's hard to know where to draw the line.
The LWG noted that users who want to put objects into an associative
container for which <tt>operator&lt;</tt> isn't defined can simply
provide their own comparison function object.</p>





<hr>
<h3><a name="390"></a>390. CopyConstructible requirements too strict</h3>
<p><b>Section:</b> 20.2.1 [utility.arg.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Doug Gregor <b>Opened:</b> 2002-10-24  <b>Last modified:</b> 2008-03-14</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#utility.arg.requirements">active issues</a> in [utility.arg.requirements].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#utility.arg.requirements">issues</a> in [utility.arg.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The CopyConstructible requirements in Table 30 state that for an
object t of type T (where T is CopyConstructible), the expression &amp;t
returns the address of t (with type T*). This requirement is overly
strict, in that it disallows types that overload operator&amp; to not
return a value of type T*. This occurs, for instance, in the <a href="http://www.boost.org/libs/lambda">Boost.Lambda</a> library, where
operator&amp; is overloaded for a Boost.Lambda function object to return
another function object.
</p>

<p>Example:</p>

<pre>  std::vector&lt;int&gt; u, v;
  int x;
  // ...
  std::transform(u.begin(), u.end(), std::back_inserter(v), _1 * x);
</pre>

<p>
_1 * x returns an unnamed function object with operator&amp; overloaded to
not return T* , therefore rendering the std::transform call ill-formed.
However, most standard library implementations will compile this code
properly, and the viability of such binder libraries is severely hindered
by the unnecessary restriction in the CopyConstructible requirements.
</p>

<p>
For reference, the address of an object can be retrieved without using
the address-of operator with the following function template:
</p>

<pre>  template &lt;typename T&gt; T* addressof(T&amp; v)
  {
    return reinterpret_cast&lt;T*&gt;(
         &amp;const_cast&lt;char&amp;&gt;(reinterpret_cast&lt;const volatile char &amp;&gt;(v)));
  }
</pre>

<p>
Note: this relates directly to library issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#350">350</a>, which
will need to be reexamined if the CopyConstructible requirements
change.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Remove the last two rows of Table 30, eliminating the requirements
that &amp;t and &amp;u return the address of t and u, respectively.
</p>


<p><b>Rationale:</b></p>
<p>This was a deliberate design decision.  Perhaps it should be
   reconsidered for C++0x. </p>





<hr>
<h3><a name="392"></a>392. 'equivalence' for input iterators</h3>
<p><b>Section:</b> 24.2.1 [input.iterators] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Corwin Joy <b>Opened:</b> 2002-12-11  <b>Last modified:</b> 2006-12-27</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#input.iterators">issues</a> in [input.iterators].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p>
In section 24.2.1 [input.iterators] table 72 -
'Input Iterator Requirements' we have as a postcondition of *a:
"If a==b and (a, b) is in the domain of == then *a is equivalent to *b".
</p>

<p>
In section 24.6.3.5 [istreambuf.iterator::equal] it states that
"istreambuf_iterator::equal returns true if and only if both iterators
are at end-of-stream, or neither is at end-of-stream, <i>regardless of
what streambuf object they use</i>."  (My emphasis).
</p>

<p>
The defect is that either 'equivalent' needs to be more precisely
defined or the conditions for equality in 24.6.3.5 [istreambuf.iterator::equal]
are incorrect. (Or both).
</p>

<p>Consider the following example:</p>
<pre>   #include &lt;iostream&gt;
   #include &lt;fstream&gt;
   #include &lt;iterator&gt;
   using namespace std;

   int main() {
    ifstream file1("file1.txt"), file2("file2.txt");
    istreambuf_iterator&lt;char&gt; f1(file1), f2(file2);
    cout &lt;&lt; "f1 == f2 : " &lt;&lt; boolalpha &lt;&lt; (f1 == f2) &lt;&lt; endl;
    cout &lt;&lt; "f1 = " &lt;&lt; *f1 &lt;&lt; endl;
    cout &lt;&lt; "f2 = " &lt;&lt; *f2 &lt;&lt; endl;
    return 0;
   }
</pre>

<p>Now assuming that neither f1 or f2 are at the end-of-stream then
f1 == f2 by 24.6.3.5 [istreambuf.iterator::equal].</p>

<p>However, it is unlikely that *f1 will give the same value as *f2 except
by accident.</p>

<p>So what does *f1 'equivalent' to *f2 mean?  I think the standard should
be clearer on this point, or at least be explicit that this does not
mean that *f1 and *f2 are required to have the same value in the case
of input iterators.</p>


<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p><p>The two iterators aer not in the domain of ==</p>






<hr>
<h3><a name="393"></a>393. do_in/do_out operation on state unclear</h3>
<p><b>Section:</b> 22.4.1.4.2 [locale.codecvt.virtuals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Alberto Barbati <b>Opened:</b> 2002-12-24  <b>Last modified:</b> 2008-07-02</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.codecvt.virtuals">issues</a> in [locale.codecvt.virtuals].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
this DR follows the discussion on the previous thread "codecvt::do_in
not consuming external characters". It's just a clarification issue
and not a request for a change.
</p>
<p>
Can do_in()/do_out() produce output characters without consuming input 
characters as a result of operation on state?
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add a note at the end of 22.4.1.4.2 [locale.codecvt.virtuals], 
paragraph 3:
</p>

<p>
[Note: As a result of operations on state, it can return ok or partial 
and set from_next == from and to_next != to. --end note]
</p>


<p><b>Rationale:</b></p>
<p>
The submitter believes that standard already provides an affirmative
answer to the question. However, the current wording has induced a few
library implementors to make the incorrect assumption that
do_in()/do_out() always consume at least one internal character when
they succeed.
</p>

<p>
The submitter also believes that the proposed resolution is not in
conflict with the related issue 76. Moreover, by explicitly allowing
operations on state to produce characters, a codecvt implementation
may effectively implement N-to-M translations without violating the
"one character at a time" principle described in such issue. On a side
note, the footnote in the proposed resolution of issue 76 that
informally rules out N-to-M translations for basic_filebuf should be
removed if this issue is accepted as valid.
</p>


<p><i>[
Kona (2007): The proposed resolution is to add a note. Since this is
non-normative, the issue is editorial, but we believe that the note is
correct. Proposed Disposition: NAD, Editorial
]</i></p>






<hr>
<h3><a name="394"></a>394. behavior of formatted output on failure</h3>
<p><b>Section:</b> 27.7.2.6.1 [ostream.formatted.reqmts] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2002-12-27  <b>Last modified:</b> 2009-07-14</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There is a contradiction in Formatted output about what bit is
supposed to be set if the formatting fails. On sentence says it's
badbit and another that it's failbit.
</p>
<p>
27.6.2.5.1, p1 says in the Common Requirements on Formatted output
functions:
</p>
<pre>     ... If the generation fails, then the formatted output function
     does setstate(ios::failbit), which might throw an exception.
</pre>
<p>
27.6.2.5.2, p1 goes on to say this about Arithmetic Inserters:
</p>
<p>
     ... The formatting conversion occurs as if it performed the
     following code fragment:
</p>
<pre>     bool failed =
         use_facet&lt;num_put&lt;charT,ostreambuf_iterator&lt;charT,traits&gt;
         &gt; &gt;
         (getloc()).put(*this, *this, fill(), val). failed();

     ... If failed is true then does setstate(badbit) ...
</pre>
<p>
The original intent of the text, according to Jerry Schwarz (see
c++std-lib-10500), is captured in the following paragraph:
</p>
<p>
In general "badbit" should mean that the stream is unusable because
of some underlying failure, such as disk full or socket closure;
"failbit" should mean that the requested formatting wasn't possible
because of some inconsistency such as negative widths.  So typically
if you clear badbit and try to output something else you'll fail
again, but if you clear failbit and try to output something else
you'll succeed.
</p>
<p>
In the case of the arithmetic inserters, since num_put cannot
report failure by any means other than exceptions (in response
to which the stream must set badbit, which prevents the kind of
recoverable error reporting mentioned above), the only other
detectable failure is if the iterator returned from num_put
returns true from failed().
</p>
<p>
Since that can only happen (at least with the required iostream
specializations) under such conditions as the underlying failure
referred to above (e.g., disk full), setting badbit would seem
to be the appropriate response (indeed, it is required in
27.6.2.5.2, p1). It follows that failbit can never be directly
set by the arithmetic (it can only be set by the sentry object
under some unspecified conditions).
</p>
<p>
The situation is different for other formatted output functions
which can fail as a result of the streambuf functions failing
(they may do so by means other than exceptions), and which are
then required to set failbit.
</p>
<p>
The contradiction, then, is that ostream::operator&lt;&lt;(int) will
set badbit if the disk is full, while operator&lt;&lt;(ostream&amp;,
char) will set failbit under the same conditions. To make the behavior
consistent, the Common requirements sections for the Formatted output
functions should be changed as proposed below.
</p>
<p><i>[Kona: There's agreement that this is a real issue.  What we
  decided at Kona: 1. An error from the buffer (which can be detected
  either directly from streambuf's member functions or by examining a
  streambuf_iterator) should always result in badbit getting set.
  2. There should never be a circumstance where failbit gets set.
  That represents a formatting error, and there are no circumstances
  under which the output facets are specified as signaling a
  formatting error. (Even more so for string output that for numeric
  because there's nothing to format.)  If we ever decide to make it
  possible for formatting errors to exist then the facets can signal
  the error directly, and that should go in clause 22, not clause 27.
  3. The phrase "if generation fails" is unclear and should be
  eliminated.  It's not clear whether it's intended to mean a buffer
  error (e.g. a full disk), a formatting error, or something else.
  Most people thought it was supposed to refer to buffer errors; if
  so, we should say so.  Martin will provide wording.]</i></p>


<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
NAD. This issue is already fixed.
</blockquote>



<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>






<hr>
<h3><a name="398"></a>398. effects of end-of-file on unformatted input functions</h3>
<p><b>Section:</b> 27.7.2.4 [ostream::sentry] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2003-01-05  <b>Last modified:</b> 2009-07-14</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#ostream::sentry">issues</a> in [ostream::sentry].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
    <p>
While reviewing unformatted input member functions of istream
for their behavior when they encounter end-of-file during input
I found that the requirements vary, sometimes unexpectedly, and
in more than one case even contradict established practice (GNU
libstdc++ 3.2, IBM VAC++ 6.0, STLPort 4.5, SunPro 5.3, HP aCC
5.38, Rogue Wave libstd 3.1, and Classic Iostreams).
    </p>
    <p>
The following unformatted input member functions set eofbit if they
encounter an end-of-file (this is the expected behavior, and also
the behavior of all major implementations):
    </p>
    <pre>    basic_istream&lt;charT, traits&gt;&amp;
    get (char_type*, streamsize, char_type);
    </pre>
    <p>
    Also sets failbit if it fails to extract any characters.
    </p>
    <pre>    basic_istream&lt;charT, traits&gt;&amp;
    get (char_type*, streamsize);
    </pre>
    <p>
    Also sets failbit if it fails to extract any characters.
    </p>
    <pre>    basic_istream&lt;charT, traits&gt;&amp;
    getline (char_type*, streamsize, char_type);
    </pre>
    <p>
    Also sets failbit if it fails to extract any characters.
    </p>
    <pre>    basic_istream&lt;charT, traits&gt;&amp;
    getline (char_type*, streamsize);
    </pre>
    <p>
    Also sets failbit if it fails to extract any characters.
    </p>
    <pre>    basic_istream&lt;charT, traits&gt;&amp;
    ignore (int, int_type);
    </pre>
    <pre>    basic_istream&lt;charT, traits&gt;&amp;
    read (char_type*, streamsize);
    </pre>
    <p>
    Also sets failbit if it encounters end-of-file.
    </p>
    <pre>    streamsize readsome (char_type*, streamsize);
    </pre>

    <p>
The following unformated input member functions set failbit but
not eofbit if they encounter an end-of-file (I find this odd
since the functions make it impossible to distinguish a general
failure from a failure due to end-of-file; the requirement is
also in conflict with all major implementation which set both
eofbit and failbit):
    </p>
    <pre>    int_type get();
    </pre>
    <pre>    basic_istream&lt;charT, traits&gt;&amp;
    get (char_type&amp;);
    </pre>
    <p>
These functions only set failbit of they extract no characters,
otherwise they don't set any bits, even on failure (I find this
inconsistency quite unexpected; the requirement is also in
conflict with all major implementations which set eofbit
whenever they encounter end-of-file):
    </p>
    <pre>    basic_istream&lt;charT, traits&gt;&amp;
    get (basic_streambuf&lt;charT, traits&gt;&amp;, char_type);
    </pre>
    <pre>    basic_istream&lt;charT, traits&gt;&amp;
    get (basic_streambuf&lt;charT, traits&gt;&amp;);
    </pre>
    <p>
This function sets no bits (all implementations except for
STLport and Classic Iostreams set eofbit when they encounter
end-of-file):
    </p>
    <pre>    int_type peek ();
    </pre>
<p>Informally, what we want is a global statement of intent saying
  that eofbit gets set if we trip across EOF, and then we can take
  away the specific wording for individual functions.  A full review
  is necessary.  The wording currently in the standard is a mishmash,
  and changing it on an individual basis wouldn't make things better.
  Dietmar will do this work.</p>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
Moved to NAD.  See 27.7.1.1 [istream] p3.
</blockquote>



<p><b>Proposed resolution:</b></p>




<hr>
<h3><a name="399"></a>399. volations of unformatted input function requirements</h3>
<p><b>Section:</b> 27.7.1.3 [istream.unformatted] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2003-01-05  <b>Last modified:</b> 2006-12-27</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#istream.unformatted">issues</a> in [istream.unformatted].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
    <p>
The Effects clauses for the two functions below violate the
general requirements on unformatted input functions outlined
in 27.6.1.3: they do not begin by constructing a sentry object.
Instead, they begin by calling widen ('\n'), which may throw
an exception. The exception is then allowed to propagate from
the unformatted input function irrespective of the setting of
exceptions().
    </p>
    <p>
Note that in light of 27.6.1.1, p3 and p4, the fact that the
functions allow exceptions thrown from widen() to propagate
may not strictly speaking be a defect (but the fact that the
functions do not start by constructing a sentry object still
is). However, since an exception thrown from ctype&lt;charT&gt;
::widen() during any other input operation (say, from within
a call to num_get&lt;charT&gt;::get()) will be caught and cause
badbit to be set, these two functions should not be treated
differently for the sake of consistency.
    </p>
  

<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>
Not a defect.  The standard is consistent, and the behavior required
by the standard is unambiguous.  Yes, it's theoretically possible for
widen to throw.  (Not that this will happen for the default ctype
facet or for most real-world replacement ctype facets.)  Users who
define ctype facets that can throw, and who care about this behavior,
can use alternative signatures that don't call widen.
</p>






<hr>
<h3><a name="417"></a>417. what does ctype::do_widen() return on failure</h3>
<p><b>Section:</b> 22.4.1.1.2 [locale.ctype.virtuals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2003-09-18  <b>Last modified:</b> 2009-07-14</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.ctype.virtuals">issues</a> in [locale.ctype.virtuals].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The Effects and Returns clauses of the do_widen() member function of
the ctype facet fail to specify the behavior of the function on failure.
That the function may not be able to simply cast the narrow character
argument to the type of the result since doing so may yield the wrong value
for some wchar_t encodings. Popular implementations of ctype&lt;wchar_t&gt; that
use mbtowc() and UTF-8 as the native encoding (e.g., GNU glibc) will fail
when the argument's MSB is set. There is no way for the the rest of locale
and iostream to reliably detect this failure. 
</p>
<p><i>[Kona: This is a real problem.  Widening can fail.  It's unclear
  what the solution should be.  Returning WEOF works for the wchar_t
  specialization, but not in general.  One option might be to add a
  default, like <i>narrow</i>.  But that's an incompatible change.
  Using <i>traits::eof</i> might seem like a good idea, but facets
  don't have access to traits (a recurring problem).  We could
  have <i>widen</i> throw an exception, but that's a scary option;
  existing library components aren't written with the assumption
  that <i>widen</i> can throw.]</i></p>


<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
NAD. The behavior is specified for all of the facets that an
implementation is required to provide, for the basic character set.
</blockquote>



<p><b>Proposed resolution:</b></p>




<hr>
<h3><a name="418"></a>418. exceptions thrown during iostream cleanup</h3>
<p><b>Section:</b> 27.5.2.1.6 [ios::Init] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2003-09-18  <b>Last modified:</b> 2009-07-14</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#ios::Init">issues</a> in [ios::Init].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The dtor of the ios_base::Init object is supposed to call flush() on the
6 standard iostream objects cout, cerr, clog, wcout, wcerr, and wclog.
This call may cause an exception to be thrown.
</p>

<p>
17.4.4.8, p3 prohibits all library destructors from throwing exceptions.
</p>

<p>
The question is: What should this dtor do if one or more of these calls
to flush() ends up throwing an exception? This can happen quite easily
if one of the facets installed in the locale imbued in the iostream
object throws.
</p>
<p><i>[Kona: We probably can't do much better than what we've got, so
  the LWG is leaning toward NAD.  At the point where the standard
  stream objects are being cleaned up, the usual error reporting
  mechanism are all unavailable.  And exception from flush at this
  point will definitely cause problems.  A quality implementation
  might reasonably swallow the exception, or call abort, or do
  something even more drastic.]</i></p>


<p><i>[
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#397">397</a> and <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#622">622</a> for related issues.
]</i></p>


<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
Moved to NAD, no consensus for change.
</blockquote>



<p><b>Proposed resolution:</b></p>




<hr>
<h3><a name="421"></a>421. is basic_streambuf copy-constructible?</h3>
<p><b>Section:</b> 27.6.2.1 [streambuf.cons] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2003-09-18  <b>Last modified:</b> 2009-07-14</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#streambuf.cons">issues</a> in [streambuf.cons].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The reflector thread starting with c++std-lib-11346 notes that the class
template basic_streambuf, along with basic_stringbuf and basic_filebuf,
is copy-constructible but that the semantics of the copy constructors
are not defined anywhere. Further, different implementations behave
differently in this respect: some prevent copy construction of objects
of these types by declaring their copy ctors and assignment operators
private, others exhibit undefined behavior, while others still give
these operations well-defined semantics.
</p>

<p>
Note that this problem doesn't seem to be isolated to just the three
types mentioned above. A number of other types in the library section
of the standard provide a compiler-generated copy ctor and assignment
operator yet fail to specify their semantics.  It's believed that the
only types for which this is actually a problem (i.e. types where the
compiler-generated default may be inappropriate and may not have been
intended) are locale facets.  See issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#439">439</a>.
</p>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
NAD. Option B is already in the Working Draft.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
27.5.2 [lib.streambuf]:  Add into the synopsis, public section, just above the destructor declaration:
</p>

<blockquote>
<pre>basic_streambuf(const basic_streambuf&amp; sb);
basic_streambuf&amp; operator=(const basic_streambuf&amp; sb);
</pre>
</blockquote>

<p>Insert after 27.5.2.1, paragraph 2:</p>
<blockquote>
<pre>basic_streambuf(const basic_streambuf&amp; sb);
</pre>

<p>Constructs a copy of sb.</p>
<p>Postcondtions:</p>
<pre>                eback() == sb.eback()
                gptr()  == sb.gptr()
                egptr() == sb.egptr()
                pbase() == sb.pbase()
                pptr()  == sb.pptr()
                epptr() == sb.epptr()
                getloc() == sb.getloc()
</pre>

<pre>basic_streambuf&amp; operator=(const basic_streambuf&amp; sb);
</pre>

<p>Assigns the data members of sb to this.</p>

<p>Postcondtions:</p>
<pre>                eback() == sb.eback()
                gptr()  == sb.gptr()
                egptr() == sb.egptr()
                pbase() == sb.pbase()
                pptr()  == sb.pptr()
                epptr() == sb.epptr()
                getloc() == sb.getloc()
</pre>

<p>Returns: *this.</p>
</blockquote>

<p>27.7.1 [lib.stringbuf]:</p>

<p><b>Option A:</b></p>

<blockquote>
<p>Insert into the basic_stringbuf synopsis in the private section:</p>

<pre>basic_stringbuf(const basic_stringbuf&amp;);             // not defined
basic_stringbuf&amp; operator=(const basic_stringbuf&amp;);  // not defined
</pre>
</blockquote>

<p><b>Option B:</b></p>

<blockquote>
<p>Insert into the basic_stringbuf synopsis in the public section:</p>

<pre>basic_stringbuf(const basic_stringbuf&amp; sb);
basic_stringbuf&amp; operator=(const basic_stringbuf&amp; sb);
</pre>

<p>27.7.1.1, insert after paragraph 4:</p>

<pre>basic_stringbuf(const basic_stringbuf&amp; sb);</pre>

<p>
Constructs an independent copy of sb as if with sb.str(), and with the openmode that sb was constructed with.
</p>

<p>Postcondtions: </p>
<pre>               str() == sb.str()
               gptr()  - eback() == sb.gptr()  - sb.eback()
               egptr() - eback() == sb.egptr() - sb.eback()
               pptr()  - pbase() == sb.pptr()  - sb.pbase()
               getloc() == sb.getloc()
</pre>

<p>Note: The only requirement on epptr() is that it point beyond the
initialized range if an output sequence exists. There is no requirement
that epptr() - pbase() == sb.epptr() - sb.pbase().
</p>

<pre>basic_stringbuf&amp; operator=(const basic_stringbuf&amp; sb);</pre>
<p>After assignment the basic_stringbuf has the same state as if it
were initially copy constructed from sb, except that the
basic_stringbuf is allowed to retain any excess capacity it might have,
which may in turn effect the value of epptr().
</p>
</blockquote>

<p>27.8.1.1 [lib.filebuf]</p>

<p>Insert at the bottom of the basic_filebuf synopsis:</p>

<blockquote>
<pre>private:
  basic_filebuf(const basic_filebuf&amp;);             // not defined
  basic_filebuf&amp; operator=(const basic_filebuf&amp;);  // not defined
</pre>
</blockquote>
<p><i>[Kona: this is an issue for basic_streambuf itself and for its
  derived classes.  We are leaning toward allowing basic_streambuf to
  be copyable, and specifying its precise semantics.  (Probably the
  obvious: copying the buffer pointers.)  We are less sure whether
  the streambuf derived classes should be copyable.  Howard will
  write up a proposal.]</i></p>


<p><i>[Sydney: Dietmar presented a new argument against basic_streambuf
  being copyable: it can lead to an encapsulation violation. Filebuf
  inherits from streambuf. Now suppose you inhert a my_hijacking_buf
  from streambuf. You can copy the streambuf portion of a filebuf to a
  my_hijacking_buf, giving you access to the pointers into the
  filebuf's internal buffer. Perhaps not a very strong argument, but
  it was strong enough to make people nervous. There was weak
  preference for having streambuf not be copyable. There was weak
  preference for having stringbuf not be copyable even if streambuf
  is. Move this issue to open for now.
]</i></p>


<p><i>[
2007-01-12, Howard:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1862.html#27.5.2%20-%20Class%20template%20basic_streambuf%3CcharT,traits%3E">Rvalue Reference Recommendations for Chapter 27</a>
recommends protected copy constructor and assignment for <tt>basic_streambuf</tt> with the same semantics
as would be generated by the compiler.  These members aid in derived classes implementing move semantics.
A protected copy constructor and copy assignment operator do not expose encapsulation more so than it is
today as each data member of a <tt>basic_streambuf</tt> is already both readable and writable by derived
classes via various get/set protected member functions (<tt>eback()</tt>, <tt>setp()</tt>, etc.).  Rather
a protected copy constructor and copy assignment operator simply make the job of derived classes implementing
move semantics less tedious and error prone.
]</i></p>




<p><b>Rationale:</b></p>
<p>
27.5.2 [lib.streambuf]: The proposed basic_streambuf copy constructor
and assignment operator are the same as currently implied by the lack
of declarations: public and simply copies the data members.  This
resolution is not a change but a clarification of the current
standard.
</p>

<p>
27.7.1 [lib.stringbuf]: There are two reasonable options: A) Make
basic_stringbuf not copyable.  This is likely the status-quo of
current implementations.  B) Reasonable copy semantics of
basic_stringbuf can be defined and implemented.  A copyable
basic_streambuf is arguably more useful than a non-copyable one.  This
should be considered as new functionality and not the fixing of a
defect.  If option B is chosen, ramifications from issue 432 are taken
into account.
</p>

<p>
27.8.1.1 [lib.filebuf]: There are no reasonable copy semantics for
basic_filebuf.
</p>






<hr>
<h3><a name="423"></a>423. effects of negative streamsize in iostreams</h3>
<p><b>Section:</b> 27 [input.output] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Future">NAD Future</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2003-09-18  <b>Last modified:</b> 2009-07-14</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#input.output">issues</a> in [input.output].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Future">NAD Future</a> status.</p>
<p><b>Discussion:</b></p>

<p>
A third party test suite tries to exercise istream::ignore(N) with
a negative value of N and expects that the implementation will treat
N as if it were 0. Our implementation asserts that (N &gt;= 0) holds and
aborts the test.
</p>

<p>
I can't find anything in section 27 that prohibits such values but I don't
see what the effects of such calls should be, either (this applies to
a number of unformatted input functions as well as some member functions
of the basic_streambuf template).
</p>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
This is related to LWG <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#255">255</a>.
</p>
<p>
Move to NAD Future.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
I propose that we add to each function in clause 27 that takes an argument,
say N, of type streamsize a Requires clause saying that "N &gt;= 0." The intent
is to allow negative streamsize values in calls to precision() and width()
but disallow it in calls to streambuf::sgetn(), istream::ignore(), or
ostream::write().
</p>

<p><i>[Kona: The LWG agreed that this is probably what we want.  However, we
  need a review to find all places where functions in clause 27 take
  arguments of type streamsize that shouldn't be allowed to go
  negative.  Martin will do that review.]</i></p>






<hr>
<h3><a name="424"></a>424. normative notes</h3>
<p><b>Section:</b> 17.5.1.2 [structure.summary] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2003-09-18  <b>Last modified:</b> 2009-07-13</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p>
The text in 17.3.1.1, p1 says:
<br>

"Paragraphs labelled "Note(s):" or "Example(s):" are informative, other
paragraphs are normative."
<br>

The library section makes heavy use of paragraphs labeled "Notes(s),"
some of which are clearly intended to be normative (see list 1), while
some others are not (see list 2). There are also those where the intent
is not so clear (see list 3).
<br><br>

List 1 -- Examples of (presumably) normative Notes:
<br>

20.8.8.1 [allocator.members], p3,<br>
20.8.8.1 [allocator.members], p10,<br>
21.4.2 [string.cons], p11,<br>
22.3.1.2 [locale.cons], p11,<br>
23.3.2.3 [deque.modifiers], p2,<br>
25.4.7 [alg.min.max], p3,<br>
26.4.6 [complex.ops], p15,<br>
27.6.2.4.3 [streambuf.virt.get], p7.<br>
<br>

List 2 -- Examples of (presumably) informative Notes:
<br>

18.6.1.3 [new.delete.placement], p3,<br>
21.4.6.6 [string::replace], p14,<br>
22.4.1.4.2 [locale.codecvt.virtuals], p3,<br>
25.2.4 [alg.foreach], p4,<br>
26.4.5 [complex.member.ops], p1,<br>
27.5.2.5 [ios.base.storage], p6.<br>
<br>

List 3 -- Examples of Notes that are not clearly either normative
or informative:
<br>

22.3.1.2 [locale.cons], p8,<br>
22.3.1.5 [locale.statics], p6,<br>
27.6.2.4.5 [streambuf.virt.put], p4.<br>
<br>

None of these lists is meant to be exhaustive.
</p>

<p><i>[Definitely a real problem.  The big problem is there's material
  that doesn't quite fit any of the named paragraph categories
  (e.g. <b>Effects</b>).  Either we need a new kind of named
  paragraph, or we need to put more material in unnamed paragraphs
  jsut after the signature.  We need to talk to the Project Editor
  about how to do this.
]</i></p>


<p><i>[
Bellevue: Specifics of list 3: First 2 items correct in std (22.1.1.2,
22.1.1.5) Third item should be non-normative (27.5.2.4.5), which Pete
will handle editorially.
]</i></p>


<p><i>[
post San Francisco:  Howard: reopened, needs attention.
]</i></p>


<p><i>[Pete: I changed the paragraphs marked "Note" and "Notes" to use "Remark" and "Remarks".
Fixed as editorial.  This change has been in the WD since the post-Redmond mailing, in 2004.
Recommend NAD.]</i></p>


<p><i>[
Batavia:  We feel that the references in List 2 above should be changed from <i>Remarks</i>
to <i>Notes</i>.  We also feel that those items in List 3 need to be double checked for
the same change.  Alan and Pete to review.
]</i></p>


<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
A spot-check of List 2 suggests the issue is still relevant,
and a review of List 3 still seems called-for.
</p>
<p>
Move to NAD Editorial.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>




<hr>
<h3><a name="429"></a>429. typo in basic_ios::clear(iostate)</h3>
<p><b>Section:</b> 27.5.4.3 [iostate.flags] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2003-09-18  <b>Last modified:</b> 2006-12-30</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#iostate.flags">issues</a> in [iostate.flags].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#412">412</a></p>
<p><b>Discussion:</b></p>
        <p>

The Effects clause in 27.4.4.3, p5 describing the effects of a call to
the ios_base member function clear(iostate state) says that the function
only throws if the respective bits are already set prior to the function
call. That's obviously not the intent. If it was, a call to clear(badbit)
on an object for which (rdstate() == goodbit &amp;&amp; exceptions() == badbit)
holds would not result in an exception being thrown.

        </p>
    
    <p><b>Proposed resolution:</b></p>
        <p>

The text ought to be changed from
<br>

"If (rdstate() &amp; exceptions()) == 0, returns. ..."
<br>

to
<br>

"If (state &amp; exceptions()) == 0, returns. ..."
        </p>


<p><b>Rationale:</b></p>






<hr>
<h3><a name="431"></a>431. Swapping containers with unequal allocators</h3>
<p><b>Section:</b> 20.2.2 [allocator.requirements], 25 [algorithms] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2003-09-20  <b>Last modified:</b> 2009-10-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#allocator.requirements">issues</a> in [allocator.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>Clause 20.2.2 [allocator.requirements] paragraph 4 says that implementations
  are permitted to supply containers that are unable to cope with
  allocator instances and that container implementations may assume
  that all instances of an allocator type compare equal.  We gave
  implementers this latitude as a temporary hack, and eventually we
  want to get rid of it.  What happens when we're dealing with
  allocators that <i>don't</i> compare equal?
</p>

<p>In particular: suppose that <tt>v1</tt> and <tt>v2</tt> are both
  objects of type <tt>vector&lt;int, my_alloc&gt;</tt> and that
  <tt>v1.get_allocator() != v2.get_allocator()</tt>.  What happens if
  we write <tt>v1.swap(v2)</tt>?  Informally, three possibilities:</p>

<p>1. This operation is illegal.  Perhaps we could say that an
  implementation is required to check and to throw an exception, or
  perhaps we could say it's undefined behavior.</p>
<p>2. The operation performs a slow swap (i.e. using three
  invocations of <tt>operator=</tt>, leaving each allocator with its
  original container.  This would be an O(N) operation.</p>
<p>3. The operation swaps both the vectors' contents and their
  allocators.  This would be an O(1) operation. That is:</p>
  <blockquote>
  <pre>    my_alloc a1(...);
    my_alloc a2(...);
    assert(a1 != a2);

    vector&lt;int, my_alloc&gt; v1(a1);
    vector&lt;int, my_alloc&gt; v2(a2);
    assert(a1 == v1.get_allocator());
    assert(a2 == v2.get_allocator());

    v1.swap(v2);
    assert(a1 == v2.get_allocator());
    assert(a2 == v1.get_allocator());
  </pre>
  </blockquote>

<p><i>[Kona: This is part of a general problem.  We need a paper
  saying how to deal with unequal allocators in general.]</i></p>


<p><i>[pre-Sydney: Howard argues for option 3 in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1599.html">N1599</a>.
]</i></p>


<p><i>[
2007-01-12, Howard:  This issue will now tend to come up more often with move constructors
and move assignment operators.  For containers, these members transfer resources (i.e.
the allocated memory) just like swap.
]</i></p>


<p><i>[
Batavia:  There is agreement to overload the container <tt>swap</tt> on the allocator's Swappable
requirement using concepts.  If the allocator supports Swappable, then container's swap will
swap allocators, else it will perform a "slow swap" using copy construction and copy assignment.
]</i></p>


<p><i>[
2009-04-28 Pablo adds:
]</i></p>

<blockquote>
Fixed in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2525.pdf">N2525</a>.
I argued for marking this Tentatively-Ready right after Bellevue,
but there was a concern that
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2525.pdf">N2525</a>
would break in the presence of the RVO. (That breakage had nothing to do with
swap, but never-the-less). I addressed that breakage in in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2840.pdf">N2840</a>
(Summit) by means of a non-normative reference:

<blockquote>
[<i>Note:</i> in situations where the copy constructor for a container is elided,
this function is not called. The behavior in these cases is as if
<tt>select_on_container_copy_construction</tt> returned <tt>x</tt> &#8212; <i>end note</i>]
</blockquote>

</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD Editorial.  Addressed by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2982.pdf">N2982</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="433"></a>433. Contradiction in specification of unexpected()</h3>
<p><b>Section:</b> 18.8.2.4 [unexpected] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Vyatcheslav Sysoltsev <b>Opened:</b> 2003-09-29  <b>Last modified:</b> 2006-12-27</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Clause 15.5.2 [except.unexpected] paragraph 1 says that "void unexpected();
is called (18.7.2) immediately after completing the stack unwinding
for the former function", but 18.7.2.4 (Effects) says that "void
unexpected(); . . . Calls the unexpected_handler function in effect
immediately after evaluating the throwexpression (18.7.2.2),".  Isn't
here a contradiction: 15.5.2 requires stack have been unwound when in
void unexpected() and therefore in unexpected_handler but 18.7.2.4
claims that unexpected_handler is called "in effect immediately" after
evaluation of throw expression is finished, so there is no space left
for stack to be unwound therefore?  I think the phrase "in effect
immediately" should be removed from the standard because it brings
ambiguity in understanding.
</p>


<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>There is no contradiction.  The phrase "in effect immediately" is
  just to clarify which handler is to be called.</p>





<hr>
<h3><a name="437"></a>437. Formatted output of function pointers is confusing</h3>
<p><b>Section:</b> 27.7.2.6.2 [ostream.inserters.arithmetic] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Ivan Godard <b>Opened:</b> 2003-10-24  <b>Last modified:</b> 2006-12-27</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#ostream.inserters.arithmetic">issues</a> in [ostream.inserters.arithmetic].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Given:
</p>
<pre>void f(int) {}
void(*g)(int) = f;
cout &lt;&lt; g;
</pre>

<p>
(with the expected #include and usings), the value printed is a rather
surprising "true". Rather useless too.
</p>

<p>The standard defines:</p>

<pre>ostream&amp; operator&lt;&lt;(ostream&amp;, void*);</pre>

<p>which picks up all data pointers and prints their hex value, but does
not pick up function pointers because there is no default conversion
from function pointer to void*. Absent that, we fall back to legacy
conversions from C and the function pointer is converted to bool.
</p>

<p>There should be an analogous inserter that prints the address of a
  function pointer.</p>


<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>This is indeed a wart, but there is no good way to solve it.  C
  doesn't provide a portable way of outputting the address of a
  function point either.</p>





<hr>
<h3><a name="439"></a>439. Should facets be copyable?</h3>
<p><b>Section:</b> 22.4 [locale.categories] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2003-11-02  <b>Last modified:</b> 2006-12-27</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.categories">issues</a> in [locale.categories].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>The following facets classes have no copy constructors described in
  the standard, which, according to the standard, means that they are
  supposed to use the compiler-generated defaults.  Default copy
  behavior is probably inappropriate.  We should either make these
  classes uncopyable or else specify exactly what their constructors do.</p>

<p>Related issue: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#421">421</a>.</p>

<pre>        ctype_base
        ctype
        ctype_byname
        ctype&lt;char&gt;
        ctype_byname&lt;char&gt;
        codecvt_base
        codecvt
        codecvt_byname
        num_get
        num_put
        numpunct
        numpunct_byname
        collate
        collate_byname
        time_base
        time_get
        time_get_byname
        time_put
        time_put_byname
        money_get
        money_put
        money_base
        moneypunct
        moneypunct_byname
        messages_base
        messages
        messages_byname
</pre>



<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>The copy constructor in the base class is private.</p>





<hr>
<h3><a name="440"></a>440. Should std::complex use unqualified transcendentals?</h3>
<p><b>Section:</b> 26.4.8 [complex.transcendentals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2003-11-05  <b>Last modified:</b> 2009-03-21</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Operations like <tt>pow</tt> and <tt>exp</tt> on
<tt>complex&lt;T&gt;</tt> are typically implemented in terms of
operations like <tt>sin</tt> and <tt>cos</tt> on <tt>T</tt>.  
Should implementations write this as <tt>std::sin</tt>, or as plain
unqualified <tt>sin</tt>?
</p>

<p>The issue, of course, is whether we want to use
argument-dependent lookup in the case where <tt>T</tt> is a
user-defined type.  This is similar to the issue of valarray
transcendentals, as discussed in issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#226">226</a>.</p>

<p>This issue differs from valarray transcendentals in two important
ways.  First, "the effect of instantiating the template
<tt>complex</tt> for types other than float, double or long double is
unspecified." (26.4.1 [complex.syn]) Second, the standard does not
dictate implementation, so there is no guarantee that a particular
real math function is used in the implementation of a particular
complex function.</p>



<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>If you instantiate std::complex for user-defined types, all bets
are off.</p>





<hr>
<h3><a name="447"></a>447. Wrong template argument for time facets</h3>
<p><b>Section:</b> 22.3.1.1.1 [locale.category] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2003-12-26  <b>Last modified:</b> 2007-01-15</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.category">issues</a> in [locale.category].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#327">327</a></p>
<p><b>Discussion:</b></p>
<p>
22.1.1.1.1/4, table 52, "Required Instantiations", lists, among others:
</p>
<pre>    time_get&lt;char,InputIterator&gt;
    time_get_byname&lt;char,InputIterator&gt;
    time_get&lt;wchar_t,OutputIterator&gt;
    time_get_byname&lt;wchar_t,OutputIterator&gt;
</pre>

<p>
The second argument to the last two should be InputIterator, not
OutputIterator.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change the second template argument to InputIterator.
</p>


<p><b>Rationale:</b></p>






<hr>
<h3><a name="450"></a>450. set::find is inconsistent with associative container requirements</h3>
<p><b>Section:</b> 23.4.3 [set] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Bill Plauger <b>Opened:</b> 2004-01-30  <b>Last modified:</b> 2009-05-01</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#set">issues</a> in [set].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#214">214</a></p>
<p><b>Discussion:</b></p>
<p>map/multimap have:</p>

<pre>    iterator find(const key_type&amp; x) const;
    const_iterator find(const key_type&amp; x) const;
</pre>

<p>
which is consistent with the table of associative container requirements.
But set/multiset have:
</p>
<pre>    iterator find(const key_type&amp;) const;
</pre>

<p>
set/multiset should look like map/multimap, and honor the requirements
table, in this regard.
</p>


<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>






<hr>
<h3><a name="451"></a>451. Associative erase should return an iterator</h3>
<p><b>Section:</b> 23.2.4 [associative.reqmts], 23.4 [associative] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Bill Plauger <b>Opened:</b> 2004-01-30  <b>Last modified:</b> 2009-05-01</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#associative.reqmts">active issues</a> in [associative.reqmts].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#associative.reqmts">issues</a> in [associative.reqmts].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#130">130</a></p>
<p><b>Discussion:</b></p>
<p>map/multimap/set/multiset have:</p>
<pre>    void erase(iterator);
    void erase(iterator, iterator);
</pre>

<p>But there's no good reason why these can't return an iterator, as for
vector/deque/list:</p>
<pre>    iterator erase(iterator);
    iterator erase(iterator, iterator);
</pre>



<p><b>Proposed resolution:</b></p>
<p>
Informally: The table of associative container requirements, and the
relevant template classes, should return an iterator designating the
first element beyond the erased subrange.
</p>


<p><b>Rationale:</b></p>






<hr>
<h3><a name="452"></a>452.  locale::combine should be permitted to generate a named locale</h3>
<p><b>Section:</b> 22.3.1.3 [locale.members] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Bill Plauger <b>Opened:</b> 2004-01-30  <b>Last modified:</b> 2009-05-01</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.members">issues</a> in [locale.members].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<pre>template&lt;class Facet&gt;
    locale::combine(const locale&amp;) const;
</pre>
<p>
is obliged to create a locale that has no name. This is overspecification
and overkill. The resulting locale should follow the usual rules -- it
has a name if the locale argument has a name and Facet is one of the
standard facets.
</p>

<p><i>[
 Sydney and post-Sydney (see c++std-lib-13439, c++std-lib-13440,
 c++std-lib-13443): agreed that it's overkill to say that the locale
 is obligated to be nameless.  However, we also can't require it to
 have a name.  At the moment, locale names are based on categories
 and not on individual facets.  If a locale contains two different
 facets of different names from the same category, then this would
 not fit into existing naming schemes.  We need to give
 implementations more freedom.  Bill will provide wording.
]</i></p>




<p><b>Rationale:</b></p>
<p>After further discussion the LWG decided to close this as NAD.
  The fundamental problem is that names right now are per-category,
  not per-facet.  The <tt>combine</tt> member function works at the
  wrong level of granularity.</p>





<hr>
<h3><a name="454"></a>454. basic_filebuf::open should accept wchar_t names</h3>
<p><b>Section:</b> 27.9.1.4 [filebuf.members] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Bill Plauger <b>Opened:</b> 2004-01-30  <b>Last modified:</b> 2009-05-01</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#filebuf.members">issues</a> in [filebuf.members].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#105">105</a></p>
<p><b>Discussion:</b></p>
<pre>    basic_filebuf *basic_filebuf::open(const char *, ios_base::open_mode);
</pre>

<p>should be supplemented with the overload:</p>

<pre>    basic_filebuf *basic_filebuf::open(const wchar_t *, ios_base::open_mode);
</pre>

<p>
Depending on the operating system, one of these forms is fundamental and
the other requires an implementation-defined mapping to determine the
actual filename.
</p>

<p><i>[Sydney: Yes, we want to allow wchar_t filenames.  Bill will
  provide wording.]</i></p>


<p><i>[
In Toronto we noted that this is issue 5 from
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1569.htm">N1569</a>.
]</i></p>

<p>
How does this interact with the newly-defined character types, and how
do we avoid interface explosion considering <tt>std::string</tt> overloads that
were added? Propose another solution that is different than the
suggestion proposed by PJP.
</p>
<p>
Suggestion is to make a member template function for <tt>basic_string</tt> (for
<tt>char</tt>, <tt>wchar_t</tt>, <tt>u16char</tt>, <tt>u32char</tt> instantiations), and then just keep a
<tt>const char*</tt> member.
</p>
<p>
Goal is to do implicit conversion between character string literals to
appropriate <tt>basic_string</tt> type. Not quite sure if this is possible.
</p>
<p>
Implementors are free to add specific overloads for non-char character
types.
</p>

<p><i>[
Martin adds pre-Sophia Antipolis:
]</i></p>


<blockquote>
Please see <a href="http://wiki.dinkumware.com/twiki/pub/Wg21sophiaAntipolis/LibraryWorkingGroup/issue-454.html">issue 454: problems and solutions</a>.
</blockquote>

<p><i>[
Sophia Antipolis:
]</i></p>


<blockquote>
<p>
Beman is concerned that making these changes to <tt>basic_filebuf</tt> is not
usefully changed unless <tt>fstream</tt> is also changed; this also only handles
<tt>wchar_t</tt> and not other character types.
</p>
<p>
The TR2 filesystem library is a more complete solution, but is not available soon.
</p>
</blockquote>

<p><i>[
Martin adds:  please reference
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2683.html">N2683</a> for
problems and solutions.
]</i></p>




<p><b>Proposed resolution:</b></p>

<p>Change from:</p>
<blockquote>
<pre>basic_filebuf&lt;charT,traits&gt;* open(
    const char* s,
    ios_base::openmode mode );
</pre>

<p>
Effects: If is_open() != false, returns a null pointer.
Otherwise, initializes the filebuf as required. It then
opens a file, if possible, whose name is the NTBS s ("as if"
by calling std::fopen(s,modstr)).</p>
</blockquote>

<p>to:</p>

<blockquote>
<pre>basic_filebuf&lt;charT,traits&gt;* open(
    const char* s,
    ios_base::openmode mode );

basic_filebuf&lt;charT,traits&gt;* open(
    const wchar_t* ws,
    ios_base::openmode mode );
</pre>

<p>
Effects: If is_open() != false, returns a null pointer.
Otherwise, initializes the filebuf as required. It then
opens a file, if possible, whose name is the NTBS s ("as if"
by calling std::fopen(s,modstr)).
For the second signature, the NTBS s is determined from the
WCBS ws in an implementation-defined manner.
</p>

<p>
(NOTE: For a system that "naturally" represents a filename
as a WCBS, the NTBS s in the first signature may instead
be mapped to a WCBS; if so, it follows the same mapping
rules as the first argument to open.)
</p>
</blockquote>



<p><b>Rationale:</b></p>
<p>
Slightly controversial, but by a 7-1 straw poll the LWG agreed to move
this to Ready.  The controversy was because the mapping between wide
names and files in a filesystem is implementation defined.  The
counterargument, which most but not all LWG members accepted, is that
the mapping between narrow files names and files is also
implemenation defined.</p>

<p><i>[Lillehammer: Moved back to "open" status, at Beman's urging.
(1) Why just basic_filebuf, instead of also basic_fstream (and
possibly other things too). (2) Why not also constructors that take
std::basic_string? (3) We might want to wait until we see Beman's
filesystem library; we might decide that it obviates this.]</i></p>


<p><i>[
post Bellevue:
]</i></p>


<blockquote>
<p>
Move again to Ready.
</p>
<p>
There is a timing issue here. Since the filesystem library will not be
in C++0x, this should be brought forward. This solution would remain
valid in the context of the proposed filesystem.
</p>
<p>
This issue has been kicking around for a while, and the wchar_t addition
alone would help many users. Thus, we suggest putting this on the
reflector list with an invitation for someone to produce proposed
wording that covers basic_fstream. In the meantime, we suggest that the
proposed wording be adopted as-is.
</p>
<p>
If more of the Lillehammer questions come back, they should be
introduced as separate issues.
</p>
</blockquote>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
Some existing implementations provide overload already. Expected
filesystem "path" object overloads neatly, without surprises; implying
NAD.
</blockquote>







<hr>
<h3><a name="458"></a>458. 24.1.5 contains unintended limitation for operator-</h3>
<p><b>Section:</b> 24.2.5 [random.access.iterators] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Daniel Frey <b>Opened:</b> 2004-02-27  <b>Last modified:</b> 2009-10-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#random.access.iterators">issues</a> in [random.access.iterators].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 24.1.5 [lib.random.access.iterators], table 76 the operational
semantics for the expression "r -= n" are defined as "return r += -n".
This means, that the expression -n must be valid, which is not the case
for unsigned types.
</p>

<p><i>[
Sydney: Possibly not a real problem, since difference type is required
to be a signed integer type. However, the wording in the standard may
be less clear than we would like.
]</i></p>


<p><i>[
Post Summit Alisdair adds:
]</i></p>


<blockquote>
<p>
This issue refers to a requirements table we have removed.
</p>
<p>
The issue might now relate to 24.2.5 [random.access.iterators] p5.
However, the rationale in the issue already recognises that the
<tt>difference_type</tt> must be signed, so this really looks NAD.
</p>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We agree with Alisdair's observations.
</p>
<p>
Move to NAD.
</p>
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
<p>
Need to look at again without concepts.
</p>
<p>
There was a question about this phrase in the discussion: "the
expression -n must be valid, which is not the case for unsigned types."
If n is an object ofthe iterator difference_type (eg ptrdiff_t), then it
is never unsigned.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
The group reviewed the wording in the draft and agreed that n is of
difference type, the difference type is signed, and the current wording
is correct.  Moved to NAD.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
To remove this limitation, I suggest to change the
operational semantics for this column to:
</p>
<blockquote><pre>    { Distance m = n;
      if (m &gt;= 0)
        while (m--) --r;
      else
        while (m++) ++r;
      return r; }
</pre></blockquote>






<hr>
<h3><a name="459"></a>459. Requirement for widening in stage 2 is overspecification</h3>
<p><b>Section:</b> 22.4.2.1.2 [facet.num.get.virtuals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2004-03-16  <b>Last modified:</b> 2009-07-14</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#facet.num.get.virtuals">active issues</a> in [facet.num.get.virtuals].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#facet.num.get.virtuals">issues</a> in [facet.num.get.virtuals].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>When parsing strings of wide-character digits, the standard
  requires the library to widen narrow-character "atoms" and compare
  the widened atoms against the characters that are being parsed.
  Simply narrowing the wide characters would be far simpler, and
  probably more efficient.  The two choices are equivalent except in
  convoluted test cases, and many implementations already ignore the
  standard and use narrow instead of widen.</p>

<p>
First, I disagree that using narrow() instead of widen() would
necessarily have unfortunate performance implications. A possible
implementation of narrow() that allows num_get to be implemented
in a much simpler and arguably comparably efficient way as calling
widen() allows, i.e. without making a virtual call to do_narrow every
time, is as follows:
</p>

<pre>  inline char ctype&lt;wchar_t&gt;::narrow (wchar_t wc, char dflt) const
  {
      const unsigned wi = unsigned (wc);

      if (wi &gt; UCHAR_MAX)
          return typeid (*this) == typeid (ctype&lt;wchar_t&gt;) ?
                 dflt : do_narrow (wc, dflt);

      if (narrow_ [wi] &lt; 0) {
         const char nc = do_narrow (wc, dflt);
         if (nc == dflt)
             return dflt;
         narrow_ [wi] = nc;
      }

      return char (narrow_ [wi]);
  }
</pre>

<p>
Second, I don't think the change proposed in the issue (i.e., to use
narrow() instead of widen() during Stage 2) would be at all
drastic. Existing implementations with the exception of libstdc++
currently already use narrow() so the impact of the change on programs
would presumably be isolated to just a single implementation. Further,
since narrow() is not required to translate alternate wide digit
representations such as those mentioned in issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#303">303</a>
to
their narrow equivalents (i.e., the portable source characters '0'
through '9'), the change does not necessarily imply that these
alternate digits would be treated as ordinary digits and accepted as
part of numbers during parsing. In fact, the requirement in 22.4.1.1.2
[locale.ctype.virtuals], p13 forbids narrow() to translate an alternate
digit character, wc, to an ordinary digit in the basic source
character set unless the expression
(ctype&lt;charT&gt;::is(ctype_base::digit, wc) == true) holds. This in
turn is prohibited by the C standard (7.25.2.1.5, 7.25.2.1.5, and
5.2.1, respectively) for charT of either char or wchar_t.
</p>

<p><i>[Sydney: To a large extent this is a nonproblem. As long as
you're only trafficking in char and wchar_t we're only dealing with a
stable character set, so you don't really need either 'widen' or
'narrow': can just use literals. Finally, it's not even clear whether
widen-vs-narrow is the right question; arguably we should be using
codecvt instead.]</i></p>


<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
NAD. The standard is clear enough as written.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>Change stage 2 so that implementations are permitted to use either
technique to perform the comparison:</p>
<ol>
  <li> call widen on the atoms and compare (either by using
      operator== or char_traits&lt;charT&gt;::eq) the input with
      the widened atoms, or</li>
  <li> call narrow on the input and compare the narrow input
      with the atoms</li>
  <li> do (1) or (2) only if charT is not char or wchar_t,
      respectively; i.e., avoid calling widen or narrow
      if it the source and destination types are the same</li>
</ol>





<hr>
<h3><a name="462"></a>462. Destroying objects with static storage duration</h3>
<p><b>Section:</b> 3.6.3 [basic.start.term], 18.4 [cstdint] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Bill Plauger <b>Opened:</b> 2004-03-23  <b>Last modified:</b> 2008-02-25</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
3.6.3 Termination spells out in detail the interleaving of static
destructor calls and calls to functions registered with atexit. To
match this behavior requires intimate cooperation between the code
that calls destructors and the exit/atexit machinery. The former
is tied tightly to the compiler; the latter is a primitive mechanism
inherited from C that traditionally has nothing to do with static
construction and destruction. The benefits of intermixing destructor
calls with atexit handler calls is questionable at best, and <i>very</i>
difficult to get right, particularly when mixing third-party C++
libraries with different third-party C++ compilers and C libraries
supplied by still other parties.
</p>

<p>
I believe the right thing to do is defer all static destruction
until after all atexit handlers are called. This is a change in
behavior, but one that is likely visible only to perverse test
suites. At the very least, we should <i>permit</i> deferred destruction
even if we don't require it.
</p>

<p><i>[If this is to be changed, it should probably be changed by CWG.
  At this point, however, the LWG is leaning toward NAD.  Implementing
  what the standard says is hard work, but it's not impossible and
  most vendors went through that pain years ago.  Changing this
  behavior would be a user-visible change, and would break at least
  one real application.]</i></p>


<p><i>[
Batavia:  Send to core with our recommendation that we should permit deferred
destruction but not require it.
]</i></p>


<p><i>[
Howard:  The course of action recommended in Batavia would undo LWG
issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#3">3</a> and break current code implementing the "phoenix
singleton". Search the net for "phoenix singleton atexit" to get a feel
for the size of the adverse impact this change would have.  Below is
sample code which implements the phoenix singleton and would break if
<tt>atexit</tt> is changed in this way:
]</i></p>


<blockquote><pre>#include &lt;cstdlib&gt;
#include &lt;iostream&gt;
#include &lt;type_traits&gt;
#include &lt;new&gt;

class A
{
    bool alive_;
    A(const A&amp;);
    A&amp; operator=(const A&amp;);
public:
    A() : alive_(true) {std::cout &lt;&lt; "A()\n";}
    ~A() {alive_ = false; std::cout &lt;&lt; "~A()\n";}
    void use()
    {
        if (alive_)
            std::cout &lt;&lt; "A is alive\n";
        else
            std::cout &lt;&lt; "A is dead\n";
    }
};

void deallocate_resource();

// This is the phoenix singleton pattern
A&amp; get_resource(bool create = true)
{
    static std::aligned_storage&lt;sizeof(A), std::alignment_of&lt;A&gt;::value&gt;::type buf;
    static A* a;
    if (create)
    {
        if (a != (A*)&amp;buf)
        {
            a = ::new (&amp;buf) A;
            std::atexit(deallocate_resource);
        }
    }
    else
    {
        a-&gt;~A();
        a = (A*)&amp;buf + 1;
    }
    return *a;
}

void deallocate_resource()
{
    get_resource(false);
}

void use_A(const char* message)
{
    A&amp; a = get_resource();
    std::cout &lt;&lt; "Using A " &lt;&lt; message &lt;&lt; "\n";
    a.use();
}

struct B
{
    ~B() {use_A("from ~B()");}
};

B b;

int main()
{
    use_A("from main()");
}
</pre></blockquote>

<p>
The correct output is:
</p>

<blockquote><pre>A()
Using A from main()
A is alive
~A()
A()
Using A from ~B()
A is alive
~A()
</pre></blockquote>

<p><i>[
Bellevue: Confirmed no interaction with <tt>quick_exit</tt>.
Strong feeling against mandating the change. Leaning towards NAD rather than permitting the change,
as this would make common implementations of pheonix-singleton pattern implementation defined, as noted by Howard.
Bill agrees issue is no longer serious, and accepts NAD.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="463"></a>463. auto_ptr usability issues</h3>
<p><b>Section:</b> D.10.1 [auto.ptr] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Rani Sharoni <b>Opened:</b> 2003-12-07  <b>Last modified:</b> 2009-10-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#auto.ptr">issues</a> in [auto.ptr].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p>
TC1 CWG DR #84 effectively made the template&lt;class Y&gt; operator auto_ptr&lt;Y&gt;()
member of auto_ptr (20.4.5.3/4) obsolete.
</p>

<p>
The sole purpose of this obsolete conversion member is to enable copy
initialization base from r-value derived (or any convertible types like
cv-types) case:
</p>
<pre>#include &lt;memory&gt;
using std::auto_ptr;

struct B {};
struct D : B {};

auto_ptr&lt;D&gt; source();
int sink(auto_ptr&lt;B&gt;);
int x1 = sink( source() ); // #1 EDG - no suitable copy constructor
</pre>

<p>
The excellent analysis of conversion operations that was given in the final
auto_ptr proposal
(http://anubis.dkuug.dk/jtc1/sc22/wg21/docs/papers/1997/N1128.pdf)
explicitly specifies this case analysis (case 4). DR #84 makes the analysis
wrong and actually comes to forbid the loophole that was exploited by the
auto_ptr designers.
</p>

<p>
I didn't encounter any compliant compiler (e.g. EDG, GCC, BCC and VC) that
ever allowed this case. This is probably because it requires 3 user defined
conversions and in fact current compilers conform to DR #84.
</p>

<p>
I was surprised to discover that the obsolete conversion member actually has
negative impact of the copy initialization base from l-value derived
case:</p>
<pre>auto_ptr&lt;D&gt; dp;
int x2 = sink(dp); // #2 EDG - more than one user-defined conversion applies
</pre>

<p>
I'm sure that the original intention was allowing this initialization using
the template&lt;class Y&gt; auto_ptr(auto_ptr&lt;Y&gt;&amp; a) constructor (20.4.5.1/4) but
since in this copy initialization it's merely user defined conversion (UDC)
and the obsolete conversion member is UDC with the same rank (for the early
overloading stage) there is an ambiguity between them.
</p>

<p>
Removing the obsolete member will have impact on code that explicitly
invokes it:
</p>
<pre>int y = sink(source().operator auto_ptr&lt;B&gt;());
</pre>

<p>
IMHO no one ever wrote such awkward code and the reasonable workaround for
#1 is:
</p>
<pre>int y = sink( auto_ptr&lt;B&gt;(source()) );
</pre>

<p>
I was even more surprised to find out that after removing the obsolete
conversion member the initialization was still ill-formed:
int x3 = sink(dp); // #3 EDG - no suitable copy constructor
</p>

<p>
This copy initialization semantically requires copy constructor which means
that both template conversion constructor and the auto_ptr_ref conversion
member (20.4.5.3/3) are required which is what was explicitly forbidden in
DR #84. This is a bit amusing case in which removing ambiguity results with
no candidates.
</p>

<p>
I also found exception safety issue with auto_ptr related to auto_ptr_ref:
</p>
<pre>int f(auto_ptr&lt;B&gt;, std::string);
auto_ptr&lt;B&gt; source2();

// string constructor throws while auto_ptr_ref
// "holds" the pointer
int x4 = f(source2(), "xyz"); // #4
</pre>

<p>
The theoretic execution sequence that will cause a leak:
</p>
<ol>
<li>call auto_ptr&lt;B&gt;::operator auto_ptr_ref&lt;B&gt;()</li>
<li>call string::string(char const*) and throw</li>
</ol>

<p>
According to 20.4.5.3/3 and 20.4.5/2 the auto_ptr_ref conversion member
returns auto_ptr_ref&lt;Y&gt; that holds *this and this is another defect since
the type of *this is auto_ptr&lt;X&gt; where X might be different from Y. Several
library vendors (e.g. SGI) implement auto_ptr_ref&lt;Y&gt; with Y* as member which
is much more reasonable. Other vendor implemented auto_ptr_ref as
defectively required and it results with awkward and catastrophic code:
int oops = sink(auto_ptr&lt;B&gt;(source())); // warning recursive on all control
paths
</p>

<p>
Dave Abrahams noticed that there is no specification saying that
auto_ptr_ref copy constructor can't throw.
</p>

<p>
My proposal comes to solve all the above issues and significantly simplify
auto_ptr implementation. One of the fundamental requirements from auto_ptr
is that it can be constructed in an intuitive manner (i.e. like ordinary
pointers) but with strict ownership semantics which yield that source
auto_ptr in initialization must be non-const. My idea is to add additional
constructor template with sole propose to generate ill-formed, diagnostic
required, instance for const auto_ptr arguments during instantiation of
declaration. This special constructor will not be instantiated for other
types which is achievable using 14.8.2/2 (SFINAE). Having this constructor
in hand makes the constructor template&lt;class Y&gt; auto_ptr(auto_ptr&lt;Y&gt; const&amp;)
legitimate since the actual argument can't be const yet non const r-value
are acceptable.
</p>

<p>
This implementation technique makes the "private auxiliary class"
auto_ptr_ref obsolete and I found out that modern C++ compilers (e.g. EDG,
GCC and VC) consume the new implementation as expected and allow all
intuitive initialization and assignment cases while rejecting illegal cases
that involve const auto_ptr arguments.
</p>

<p>The proposed auto_ptr interface:</p>

<pre>namespace std {
    template&lt;class X&gt; class auto_ptr {
    public:
        typedef X element_type;

        // 20.4.5.1 construct/copy/destroy:
        explicit auto_ptr(X* p=0) throw();
        auto_ptr(auto_ptr&amp;) throw();
        template&lt;class Y&gt; auto_ptr(auto_ptr&lt;Y&gt; const&amp;) throw();
        auto_ptr&amp; operator=(auto_ptr&amp;) throw();
        template&lt;class Y&gt; auto_ptr&amp; operator=(auto_ptr&lt;Y&gt;) throw();
        ~auto_ptr() throw();

        // 20.4.5.2 members:
        X&amp; operator*() const throw();
        X* operator-&gt;() const throw();
        X* get() const throw();
        X* release() throw();
        void reset(X* p=0) throw();

    private:
        template&lt;class U&gt;
        auto_ptr(U&amp; rhs, typename
unspecified_error_on_const_auto_ptr&lt;U&gt;::type = 0);
    };
}
</pre>

<p>
One compliant technique to implement the unspecified_error_on_const_auto_ptr
helper class is using additional private auto_ptr member class template like
the following:
</p>
<pre>template&lt;typename T&gt; struct unspecified_error_on_const_auto_ptr;

template&lt;typename T&gt;
struct unspecified_error_on_const_auto_ptr&lt;auto_ptr&lt;T&gt; const&gt;
{ typedef typename auto_ptr&lt;T&gt;::const_auto_ptr_is_not_allowed type; };
</pre>

<p>
There are other techniques to implement this helper class that might work
better for different compliers (i.e. better diagnostics) and therefore I
suggest defining its semantic behavior without mandating any specific
implementation. IMO, and I didn't found any compiler that thinks otherwise,
14.7.1/5 doesn't theoretically defeat the suggested technique but I suggest
verifying this with core language experts.
</p>

<p><b>Further changes in standard text:</b></p>
<p>Remove section 20.4.5.3</p>

<p>Change 20.4.5/2 to read something like:
Initializing auto_ptr&lt;X&gt; from const auto_ptr&lt;Y&gt; will result with unspecified
ill-formed declaration that will require unspecified diagnostic.</p>

<p>Change 20.4.5.1/4,5,6 to read:</p>

<pre>template&lt;class Y&gt; auto_ptr(auto_ptr&lt;Y&gt; const&amp; a) throw();</pre>
<p> 4 Requires: Y* can be implicitly converted to X*.</p>
<p> 5 Effects: Calls const_cast&lt;auto_ptr&lt;Y&gt;&amp;&gt;(a).release().</p>
<p> 6 Postconditions: *this holds the pointer returned from a.release().</p>

<p>Change 20.4.5.1/10</p>
<pre>template&lt;class Y&gt; auto_ptr&amp; operator=(auto_ptr&lt;Y&gt; a) throw();
</pre>
<p>
10 Requires: Y* can be implicitly converted to X*. The expression delete
get() is well formed.
</p>

<p>LWG TC DR #127 is obsolete.</p>

<p>
Notice that the copy constructor and copy assignment operator should remain
as before and accept non-const auto_ptr&amp; since they have effect on the form
of the implicitly declared copy constructor and copy assignment operator of
class that contains auto_ptr as member per 12.8/5,10:
</p>
<pre>struct X {
    // implicit X(X&amp;)
    // implicit X&amp; operator=(X&amp;)
    auto_ptr&lt;D&gt; aptr_;
};
</pre>

<p>
In most cases this indicates about sloppy programming but preserves the
current auto_ptr behavior.
</p>

<p>
Dave Abrahams encouraged me to suggest fallback implementation in case that
my suggestion that involves removing of auto_ptr_ref will not be accepted.
In this case removing the obsolete conversion member to auto_ptr&lt;Y&gt; and
20.4.5.3/4,5 is still required in order to eliminate ambiguity in legal
cases. The two constructors that I suggested will co exist with the current
members but will make auto_ptr_ref obsolete in initialization contexts.
auto_ptr_ref will be effective in assignment contexts as suggested in DR
#127 and I can't see any serious exception safety issues in those cases
(although it's possible to synthesize such). auto_ptr_ref&lt;X&gt; semantics will
have to be revised to say that it strictly holds pointer of type X and not
reference to an auto_ptr for the favor of cases in which auto_ptr_ref&lt;Y&gt; is
constructed from auto_ptr&lt;X&gt; in which X is different from Y (i.e. assignment
from r-value derived to base).
</p>

<p><i>[Redmond: punt for the moment. We haven't decided yet whether we
  want to fix auto_ptr for C++-0x, or remove it and replace it with
  move_ptr and unique_ptr.]</i></p>


<p><i>[
Oxford 2007: Recommend NAD.  We're just going to deprecate it.  It still works for simple use cases
and people know how to deal with it.  Going forward <tt>unique_ptr</tt> is the recommended
tool.
]</i></p>


<p><i>[
2007-11-09: Reopened at the request of David Abrahams, Alisdair Meredith and Gabriel Dos Reis.
]</i></p>


<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
This is a complicated issue, so we agreed to defer discussion until
later in the week so that interested parties can read up on it.
</blockquote>

<p><i>[
209-10-04 Daniel adds:
]</i></p>


<blockquote>
<p>
I suggest to close this issue as NAD. The reasons are two-fold: First, the
suggested proposed resolution uses no longer appropriate language means
to solve this issue, which has the effect that the recommended resolution is
another - but better - form of hack. Second, either following the suggested
resolution or the now more natural alternative via the added member set
</p>

<blockquote><pre>template&lt;class Y&gt; auto_ptr(auto_ptr&lt;Y&gt;&amp;&amp;) throw();
template&lt;class Y&gt; auto_ptr&amp; operator=(auto_ptr&lt;Y&gt;&amp;&amp;) throw();
</pre></blockquote>

<p>
would still have a non-zero probability to break user-code that actively
references <tt>auto_ptr_ref</tt>. This risk seems to indicate that a
decision which would not touch the current spec of <tt>auto_ptr</tt> at
all (but deprecating it) and instead recommending to use
<tt>unique_ptr</tt> for new code instead might have the best
cost-benefit ratio. IMO the current solution of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1100">1100</a> can
be considered as an active user-support for this transition.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Mark as NAD. Alisdair will open a new issue (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1247">1247</a>) with
proposed wording to handle <tt>auto_ptr_ref</tt>.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change the synopsis in D.10.1 [auto.ptr]:
</p>

<blockquote><pre>namespace std { 
  <del>template &lt;class Y&gt; struct auto_ptr_ref {};</del>

  <ins>// exposition only</ins>
  <ins>template &lt;class T&gt; struct constant_object;</ins>

  <ins>// exposition only</ins>
  <ins>template &lt;class T&gt;</ins>
  <ins>struct cannot_transfer_ownership_from</ins>
    <ins>: constant_object&lt;T&gt; {};</ins>

  template &lt;class X&gt; class auto_ptr { 
  public: 
    typedef X element_type; 

    // D.9.1.1 construct/copy/destroy: 
    explicit auto_ptr(X* p =0) throw(); 
    auto_ptr(auto_ptr&amp;) throw(); 
    template&lt;class Y&gt; auto_ptr(auto_ptr&lt;Y&gt;<ins> const</ins>&amp;) throw(); 
    auto_ptr&amp; operator=(auto_ptr&amp;) throw(); 
    template&lt;class Y&gt; auto_ptr&amp; operator=(auto_ptr&lt;Y&gt;<del>&amp;</del>) throw();
    <del>auto_ptr&amp; operator=(auto_ptr_ref&lt;X&gt; r) throw();</del>
    ~auto_ptr() throw(); 

    // D.9.1.2 members: 
    X&amp; operator*() const throw();
    X* operator-&gt;() const throw();
    X* get() const throw();
    X* release() throw();
    void reset(X* p =0) throw();

    <del>// D.9.1.3 conversions:</del>
    <del>auto_ptr(auto_ptr_ref&lt;X&gt;) throw();</del>
    <del>template&lt;class Y&gt; operator auto_ptr_ref&lt;Y&gt;() throw();</del>
    <del>template&lt;class Y&gt; operator auto_ptr&lt;Y&gt;() throw();</del>

    <ins>// exposition only</ins>
    <ins>template&lt;class U&gt;</ins>
    <ins>auto_ptr(U&amp; rhs, typename cannot_transfer_ownership_from&lt;U&gt;::error = 0);</ins>
  }; 

  template &lt;&gt; class auto_ptr&lt;void&gt; 
  { 
  public: 
    typedef void element_type; 
  }; 

}
</pre></blockquote>

<p>
Remove D.10.1.3 [auto.ptr.conv].
</p>

<p>
Change D.10.1 [auto.ptr], p3:
</p>

<blockquote>
The <tt>auto_ptr</tt> provides a semantics of strict ownership. An
<tt>auto_ptr</tt> owns the object it holds a pointer to. Copying an
<tt>auto_ptr</tt> copies the pointer and transfers ownership to the
destination. If more than one <tt>auto_ptr</tt> owns the same object at
the same time the behavior of the program is undefined. <ins>Templates
<tt>constant_object</tt> and <tt>cannot_transfer_ownership_from</tt>,
and the final constructor of <tt>auto_ptr</tt> are for exposition only.
For any types <tt>X</tt> and <tt>Y</tt>, initializing
<tt>auto_ptr&lt;X&gt;</tt> from <tt>const auto_ptr&lt;Y&gt;</tt> is
ill-formed, diagnostic required.</ins> [<i>Note:</i> The uses of
<tt>auto_ptr</tt> include providing temporary exception-safety for
dynamically allocated memory, passing ownership of dynamically allocated
memory to a function, and returning dynamically allocated memory from a
function. <tt>auto_ptr</tt> does not meet the <tt>CopyConstructible</tt>
and <tt>Assignable</tt> requirements for Standard Library container
elements and thus instantiating a Standard Library container with an
<tt>auto_ptr</tt> results in undefined behavior. <i>-- end note</i>]
</blockquote>

<p>
Change D.10.1.1 [auto.ptr.cons], p5:
</p>

<blockquote>
<pre>template&lt;class Y&gt; auto_ptr(auto_ptr&lt;Y&gt;<ins> const</ins>&amp; a) throw();
</pre>
<blockquote>
<p>
<i>Requires:</i> <tt>Y*</tt> can be implicitly converted to <tt>X*</tt>.
</p>
<p>
<i>Effects:</i> Calls <ins><tt>const_cast&lt;auto_ptr&lt;Y&gt;&amp;&gt;(</tt></ins><tt>a</tt><ins><tt>)</tt></ins><tt>.release()</tt>.
</p>
<p>
<i>Postconditions:</i> <tt>*this</tt> holds the pointer returned from <tt>a.release()</tt>.
</p>
</blockquote>
</blockquote>

<p>
Change D.10.1.1 [auto.ptr.cons], p10:
</p>

<blockquote>
<pre>template&lt;class Y&gt; auto_ptr&amp; operator=(auto_ptr&lt;Y&gt;<del>&amp;</del> a) throw();
</pre>
<blockquote>
<p>
<i>Requires:</i> <tt>Y*</tt> can be implicitly converted to <tt>X*</tt>.
The expression <tt>delete get()</tt> is well formed.
</p>
<p>
<i>Effects:</i> Calls <tt>reset(a.release())</tt>.
</p>
<p>
<i>Returns:</i> <tt>*this</tt>.
</p>
</blockquote>
</blockquote>






<hr>
<h3><a name="466"></a>466. basic_string ctor should prevent null pointer error</h3>
<p><b>Section:</b> 21.4.1 [string.require] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Daniel Frey <b>Opened:</b> 2004-06-10  <b>Last modified:</b> 2009-07-14</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#string.require">issues</a> in [string.require].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Today, my colleagues and me wasted a lot of time. After some time, I
found the problem. It could be reduced to the following short example:
</p>

<pre>  #include &lt;string&gt;
  int main() { std::string( 0 ); }
</pre>

<p>The problem is that the tested compilers (GCC 2.95.2, GCC 3.3.1 and
Comeau online) compile the above without errors or warnings! The
programs (at least for the GCC) resulted in a SEGV.</p>

<p>I know that the standard explicitly states that the ctor of string
requires a char* which is not zero. STLs could easily detect the above
case with a private ctor for basic_string which takes a single 'int'
argument. This would catch the above code at compile time and would not
ambiguate any other legal ctors.</p>

<p><i>[Redmond: No great enthusiasm for doing this.  If we do,
  however, we want to do it for all places that take <tt>charT*</tt>
  pointers, not just the single-argument constructor.  The other
  question is whether we want to catch this at compile time (in which
  case we catch the error of a literal 0, but not an expression whose
  value is a null pointer), at run time, or both.
  Recommend NAD.  Relegate this functionality to debugging implementations.]</i></p>


<p><i>[
Post Summit: Alisdair requests this be re-opened as several new language facilities are
designed to solve exactly this kind of problem.
]</i></p>


<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We are unable to achieve consensus on an approach to a resolution.
There is some sentiment for treating this as a QOI matter.
It is also possible
that when <tt>string</tt> is brought into the concepts world,
this issue might be addressed in that context.
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
We considered three options:
</p>

<ul>
<li>The proposed resolution.</li>
<li>NAD</li>
<li>Interpret a null pointer as the empty string.</li>
</ul>

<p>
The consensus was NAD.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add to the synopsis in 21.4 [basic.string]
</p>

<blockquote><pre><ins>basic_string( nullptr_t ) = delete;</ins>
</pre></blockquote>





<hr>
<h3><a name="470"></a>470. accessing containers from their elements' special functions</h3>
<p><b>Section:</b> 23 [containers] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2004-06-28  <b>Last modified:</b> 2007-04-18</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#containers">active issues</a> in [containers].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#containers">issues</a> in [containers].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p>
The standard doesn't prohibit the destructors (or any other special
functions) of containers' elements invoked from a member function
of the container from "recursively" calling the same (or any other)
member function on the same container object, potentially while the
container is in an intermediate state, or even changing the state
of the container object while it is being modified. This may result
in some surprising (i.e., undefined) behavior.
</p>

<p>Read email thread starting with c++std-lib-13637 for more.</p>



<p><b>Proposed resolution:</b></p>

<p>Add to Container Requirements the following new paragraph:</p>

<pre>    Unless otherwise specified, the behavior of a program that
    invokes a container member function f from a member function
    g of the container's value_type on a container object c that
    called g from its mutating member function h, is undefined.
    I.e., if v is an element of c, directly or indirectly calling
    c.h() from v.g() called from c.f(), is undefined.
</pre>

<p><i>[Redmond: This is a real issue, but it's probably a clause 17
  issue, not clause 23.  We get the same issue, for example, if we
  try to destroy a stream from one of the stream's callback functions.]</i></p>

  


<p><b>Rationale:</b></p>
<p>
Recommend NAD.  We agree this is an issue, but not a defect.
We believe that there is no wording we can put in the standard
that will cover all cases without introducing unfortunate
corner cases.
</p>





<hr>
<h3><a name="472"></a>472. Missing "Returns" clause in std::equal_range</h3>
<p><b>Section:</b> 25.4.3.3 [equal.range] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Prateek R Karandikar <b>Opened:</b> 2004-06-30  <b>Last modified:</b> 2006-12-30</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#equal.range">issues</a> in [equal.range].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#270">270</a></p>
<p><b>Discussion:</b></p>
<p>
There is no "Returns:" clause for std::equal_range, which returns non-void.
</p>


<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>Fixed as part of issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#270">270</a>.</p>






<hr>
<h3><a name="476"></a>476. Forward Iterator implied mutability</h3>
<p><b>Section:</b> 24.2.3 [forward.iterators] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Dave Abrahams <b>Opened:</b> 2004-07-09  <b>Last modified:</b> 2007-01-15</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#forward.iterators">issues</a> in [forward.iterators].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p>24.1/3 says:</p>
<blockquote><p>
  Forward iterators satisfy all the requirements of the input and
  output iterators and can be used whenever either kind is specified
</p></blockquote>

<p>
The problem is that satisfying the requirements of output iterator
means that you can always assign *something* into the result of
dereferencing it.  That makes almost all non-mutable forward
iterators non-conforming.  I think we need to sever the refinement
relationship between forward iterator and output iterator.
</p>

<p>Related issue: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#200">200</a>.  But this is not a dup.</p>



<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>Yes, 24.1/3 does say that. But it's introductory material. The
precise specification is in 24.1.3, and the requrements table there is
right.  We don't need to fine-tune introductory wording.  (Especially
since this wording is likely to be changed as part of the iterator
overhaul.)</p> 





<hr>
<h3><a name="477"></a>477. Operator-&gt; for const forward iterators</h3>
<p><b>Section:</b> 24.2.3 [forward.iterators] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Dave Abrahams <b>Opened:</b> 2004-07-11  <b>Last modified:</b> 2007-01-15</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#forward.iterators">issues</a> in [forward.iterators].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#478">478</a></p>
<p><b>Discussion:</b></p>
<p>
The Forward Iterator requirements table contains the following:
</p>
<pre> expression  return type         operational  precondition
                                  semantics
  ==========  ==================  ===========  ==========================
  a-&gt;m        U&amp; if X is mutable, (*a).m       pre: (*a).m is well-defined.
              otherwise const U&amp;

  r-&gt;m        U&amp;                  (*r).m       pre: (*r).m is well-defined.
</pre>

<p>
The first line is exactly right.  The second line is wrong.  Basically
it implies that the const-ness of the iterator affects the const-ness
of referenced members.  But Paragraph 11 of [lib.iterator.requirements] says:
</p>

<blockquote><p>
   In the following sections, a and b denote values of type const X, n
   denotes a value of the difference type Distance, u, tmp, and m
   denote identifiers, r denotes a value of X&amp;, t denotes a value of
   value type T, o denotes a value of some type that is writable to
   the output iterator.
</p></blockquote>

<p>AFAICT if we need the second line at all, it should read the same
as the first line.</p>

<p>Related issue: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#478">478</a></p>


<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>The LWG agrees that this is a real problem.  Marked as a DUP
  because the LWG chose to adopt the solution proposed in
  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#478">478</a>.
</p>





<hr>
<h3><a name="479"></a>479. Container requirements and placement new</h3>
<p><b>Section:</b> 23.2 [container.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Herb Sutter <b>Opened:</b> 2004-08-01  <b>Last modified:</b> 2007-04-18</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#container.requirements">active issues</a> in [container.requirements].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#container.requirements">issues</a> in [container.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#580">580</a></p>
<p><b>Discussion:</b></p>
<p>Nothing in the standard appears to make this program ill-formed:</p>

<pre>  struct C {
    void* operator new( size_t s ) { return ::operator new( s ); }
    // NOTE: this hides in-place and nothrow new
  };

  int main() {
    vector&lt;C&gt; v;
    v.push_back( C() );
  }
</pre>

<p>Is that intentional?  We should clarify whether or not we intended
  to require containers to support types that define their own special
  versions of <tt>operator new</tt>.</p>

<p><i>[
Lillehammer: A container will definitely never use this overridden
operator new, but whether it will fail to compile is unclear from the
standard.  Are containers supposed to use qualified or unqualified
placement new?  20.4.1.1 is somewhat relevant, but the standard
doesn't make it completely clear whether containers have to use
Allocator::construct(). If containers don't use it, the details of how
containers use placement new are unspecified. That is the real bug,
but it needs to be fixed as part of the allocator overhaul.  Weak
support that the eventual solution should make this code well formed.
]</i></p>




<p><b>Proposed resolution:</b></p>







<hr>
<h3><a name="480"></a>480. unary_function and binary_function should have protected nonvirtual destructors</h3>
<p><b>Section:</b> 20.7.3 [base] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Joe Gottman <b>Opened:</b> 2004-08-19  <b>Last modified:</b> 2006-12-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#base">issues</a> in [base].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>The classes std::unary_function and std::binary_function are both
designed to be inherited from but contain no virtual functions.  This
makes it too easy for a novice programmer to write code like
binary_function&lt;int, int, int&gt; *p = new plus&lt;int&gt;; delete p;</p>

<p>There are two common ways to prevent this source of undefined
behavior: give the base class a public virtual destructor, or give it
a protected nonvirtual destructor.  Since unary_function and
binary_function have no other virtual functions, (note in particular
the absence of an operator()() ), it would cost too much to give them
public virtual destructors.  Therefore, they should be given protected
nonvirtual destructors.</p>


<p><b>Proposed resolution:</b></p>
<p>Change Paragraph 20.3.1 of the Standard from</p>
<pre>    template &lt;class Arg, class Result&gt;
    struct unary_function {
        typedef Arg argument_type;
        typedef Result result_type;
    };

    template &lt;class Arg1, class Arg2, class Result&gt;
    struct binary_function {
        typedef Arg1 first_argument_type;
        typedef Arg2 second_argument_type;
        typedef Result result_type;
    };
</pre>

<p>to</p>
<pre>    template &lt;class Arg, class Result&gt;
        struct unary_function {
        typedef Arg argument_type;
        typedef Result result_type;
    protected:
        ~unary_function() {}
    };

    template &lt;class Arg1, class Arg2, class Result&gt;
    struct binary_function {
        typedef Arg1 first_argument_type;
        typedef Arg2 second_argument_type;
        typedef Result result_type;
    protected:
        ~binary_function() {}
    };
</pre>


<p><b>Rationale:</b></p>
<p>The LWG doesn't believe the existing definition causes anybody any
  concrete harm.</p>





<hr>
<h3><a name="481"></a>481. unique's effects on the range [result, last)</h3>
<p><b>Section:</b> 25.3.9 [alg.unique] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Andrew Koenig <b>Opened:</b> 2004-08-30  <b>Last modified:</b> 2006-12-27</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.unique">issues</a> in [alg.unique].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The standard says that unique(first, last) "eliminates all but the
first element from every consecutive group of equal elements" in
[first, last) and returns "the end of the resulting range".  So a
postcondition is that [first, result) is the same as the old [first,
last) except that duplicates have been eliminated.
</p>

<p>What postconditions are there on the range [result, last)?  One
  might argue that the standard says nothing about those values, so
  they can be anything.  One might also argue that the standard
  doesn't permit those values to be changed, so they must not be.
  Should the standard say something explicit one way or the other?</p>



<p><b>Proposed resolution:</b></p>
<p>
</p>


<p><b>Rationale:</b></p>
<p>We don't want to make many guarantees about what's in [result,
end). Maybe we aren't being quite explicit enough about not being
explicit, but it's hard to think that's a major problem.</p>





<hr>
<h3><a name="482"></a>482. Swapping pairs</h3>
<p><b>Section:</b> 20.3.4 [pairs], 20.5 [tuple] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Andrew Koenig <b>Opened:</b> 2004-09-14  <b>Last modified:</b> 2007-05-06</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#pairs">active issues</a> in [pairs].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#pairs">issues</a> in [pairs].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>(Based on recent comp.std.c++ discussion)</p>

<p>Pair (and tuple) should specialize std::swap to work in terms of
std::swap on their components.  For example, there's no obvious reason
why swapping two objects of type pair&lt;vector&lt;int&gt;,
list&lt;double&gt; &gt; should not take O(1).</p>

<p><i>[Lillehammer: We agree it should be swappable.  Howard will
  provide wording.]</i></p>


<p><i>[
Post Oxford:  We got <tt>swap</tt> for <tt>pair</tt> but accidently
missed <tt>tuple</tt>.  <tt>tuple::swap</tt> is being tracked by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#522">522</a>.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
Wording provided in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1856.html#20.2.3%20-%20Pairs">N1856</a>.
</p>

<p><b>Rationale:</b></p>
<p>
Recommend NAD, fixed by 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1856.html#20.2.3%20-%20Pairs">N1856</a>.
</p>





<hr>
<h3><a name="483"></a>483. Heterogeneous equality and EqualityComparable</h3>
<p><b>Section:</b> 25.2 [alg.nonmodifying], 25.3 [alg.modifying.operations] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Peter Dimov <b>Opened:</b> 2004-09-20  <b>Last modified:</b> 2007-01-15</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#283">283</a></p>
<p><b>Discussion:</b></p>
<p>c++std-lib-14262</p>

<p>[lib.alg.find] requires T to be EqualityComparable:</p>

<pre>template &lt;class InputIterator, class T&gt;
   InputIterator find(InputIterator first, InputIterator last,
                      const T&amp; value);
</pre>

<p>
However the condition being tested, as specified in the Effects
clause, is actually *i == value, where i is an InputIterator.
</p>

<p>
The two clauses are in agreement only if the type of *i is T, but this
isn't necessarily the case. *i may have a heterogeneous comparison
operator that takes a T, or a T may be convertible to the type of *i.
</p>

<p>Further discussion (c++std-lib-14264): this problem affects a
  number of algorithsm in clause 25, not just <tt>find</tt>.  We
  should try to resolve this problem everywhere it appears.</p>


<p><b>Proposed resolution:</b></p>

<p>[lib.alg.find]:</p>
<blockquote><p>
   Remove [lib.alg.find]/1.
</p></blockquote>

<p>[lib.alg.count]:</p>
<blockquote><p>
   Remove [lib.alg.count]/1.
</p></blockquote>

<p>[lib.alg.search]:</p>
<blockquote><p>
   Remove "Type T is EqualityComparable (20.1.1), " from [lib.alg.search]/4.
</p></blockquote>

<p>[lib.alg.replace]:</p>

<blockquote>
   <p>
   Remove [lib.alg.replace]/1.
   Replace [lb.alg.replace]/2 with:
   </p>

       <blockquote><p>
       For every iterator i in the range [first, last) for which *i == value
       or pred(*i) holds perform *i = new_value.
       </p></blockquote>

   <p>
   Remove the first sentence of /4.
   Replace the beginning of /5 with:
   </p>

       <blockquote><p>
       For every iterator i in the range [result, result + (last -
       first)), assign to *i either...
       </p></blockquote>

   <p>(Note the defect here, current text says assign to i, not *i).</p>
</blockquote>

<p>[lib.alg.fill]:</p>

<blockquote>
   <p>
   Remove "Type T is Assignable (23.1), " from /1.
   Replace /2 with:
   </p>

       <blockquote><p>
       For every iterator i in the range [first, last) or [first, first + n),
       perform *i = value.
       </p></blockquote>
</blockquote>

<p>[lib.alg.remove]:</p>
<blockquote><p>
   Remove /1.
   Remove the first sentence of /6.
</p></blockquote>



<p><b>Rationale:</b></p>
<p>Duplicate of (a subset of) issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#283">283</a>.</p>






<hr>
<h3><a name="484"></a>484. Convertible to T</h3>
<p><b>Section:</b> 24.2.1 [input.iterators] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Future">NAD Future</a>
 <b>Submitter:</b> Chris Jefferson <b>Opened:</b> 2004-09-16  <b>Last modified:</b> 2009-10-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#input.iterators">issues</a> in [input.iterators].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Future">NAD Future</a> status.</p>
<p><b>Discussion:</b></p>
<p>From comp.std.c++:</p>

<p>
I note that given an input iterator a for type T, 
then *a only has to be "convertable to T", not actually of type T.
</p>

<p>Firstly, I can't seem to find an exact definition of "convertable to T". 
While I assume it is the obvious definition (an implicit conversion), I 
can't find an exact definition. Is there one?</p>

<p>Slightly more worryingly, there doesn't seem to be any restriction on 
the this type, other than it is "convertable to T". Consider two input 
iterators a and b. I would personally assume that most people would 
expect *a==*b would perform T(*a)==T(*b), however it doesn't seem that 
the standard requires that, and that whatever type *a is (call it U) 
could have == defined on it with totally different symantics and still 
be a valid inputer iterator.</p>

<p>Is this a correct reading? When using input iterators should I write 
T(*a) all over the place to be sure that the object i'm using is the 
class I expect?</p>

<p>This is especially a nuisance for operations that are defined to be
  "convertible to bool".  (This is probably allowed so that
  implementations could return say an int and avoid an unnessary
  conversion. However all implementations I have seen simply return a
  bool anyway.  Typical implemtations of STL algorithms just write
  things like <tt>while(a!=b &amp;&amp; *a!=0)</tt>.  But strictly
  speaking, there are lots of types that are convertible to T but
  that also overload the appropriate operators so this doesn't behave
  as expected.</p>

<p>If we want to make code like this legal (which most people seem to
  expect), then we'll need to tighten up what we mean by "convertible
  to T".</p>

<p><i>[Lillehammer: The first part is NAD, since "convertible" is
 well-defined in core. The second part is basically about pathological
 overloads. It's a minor problem but a real one. So leave open for
 now, hope we solve it as part of iterator redesign.]</i></p>


<p><i>[
2009-07-28 Reopened by Alisdair.  No longer solved by concepts.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Mark as NAD Future. We agree there's an issue, but there is no
proposed solution at this time and this will be solved by concepts in
the future.
</blockquote>



<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p><i>[
San Francisco:
]</i></p>


<blockquote>
Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2758.pdf">N2758</a>.
</blockquote>







<hr>
<h3><a name="486"></a>486. min/max CopyConstructible requirement is too strict</h3>
<p><b>Section:</b> 25.4.7 [alg.min.max] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Dave Abrahams <b>Opened:</b> 2004-10-13  <b>Last modified:</b> 2006-12-30</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.min.max">issues</a> in [alg.min.max].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#281">281</a></p>
<p><b>Discussion:</b></p>
<p>A straightforward implementation of these algorithms does not need to
copy T.</p>


<p><b>Proposed resolution:</b></p>
<p>drop the the words "and CopyConstructible" from paragraphs 1 and 4</p>


<p><b>Rationale:</b></p>






<hr>
<h3><a name="487"></a>487. Allocator::construct is too limiting</h3>
<p><b>Section:</b> 20.2.2 [allocator.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Dhruv Matani <b>Opened:</b> 2004-10-17  <b>Last modified:</b> 2006-12-30</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#allocator.requirements">issues</a> in [allocator.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The standard's version of allocator::construct(pointer,
const_reference) severely limits what you can construct using this
function.  Say you can construct a socket from a file descriptor. Now,
using this syntax, I first have to manually construct a socket from
the fd, and then pass the constructed socket to the construct()
function so it will just to an uninitialized copy of the socket I
manually constructed. Now it may not always be possible to copy
construct a socket eh! So, I feel that the changes should go in the
allocator::construct(), making it:
</p>
<pre>    template&lt;typename T&gt;
    struct allocator{
      template&lt;typename T1&gt;
      void construct(pointer T1 const&amp; rt1);
    };
</pre>

<p>
Now, the ctor of the class T which matches the one that takes a T1 can
be called! Doesn't that sound great?
</p>


<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>NAD. STL uses copying all the time, and making it possible for
  allocators to construct noncopyable objects is useless in the
  absence of corresponding container changes. We might consider this
  as part of a larger redesign of STL.</p>





<hr>
<h3><a name="489"></a>489. std::remove / std::remove_if wrongly specified</h3>
<p><b>Section:</b> 25.3.8 [alg.remove] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Thomas Mang <b>Opened:</b> 2004-12-12  <b>Last modified:</b> 2006-12-27</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.remove">issues</a> in [alg.remove].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>In Section 25.2.7 [lib.alg.remove], paragraphs 1 to 5 describe the
behavior of the mutating sequence operations std::remove and
std::remove_if. However, the wording does not reflect the intended
behavior [Note: See definition of intended behavior below] of these
algorithms, as it is known to the C++ community [1].
</p>



<p>1) Analysis of current wording:</p>


<p>25.2.7 [lib.alg.remove], paragraph 2:</p>

<p>Current wording says:
"Effects: Eliminates all the elements referred to by iterator i in the
range [first, last) for which the following corresponding conditions
hold: *i == value, pred(*i) != false."</p>

<p>
This sentences expresses specifically that all elements denoted by the
(original) range [first, last) for which the corresponding condition
hold will be eliminated. Since there is no formal definition of the term
"eliminate" provided, the meaning of "eliminate" in everyday language
implies that as postcondition, no element in the range denoted by
[first, last) will hold the corresponding condition on reiteration over
the range [first, last).
</p>

<p>
However, this is neither the intent [Note: See definition of intended
behavior below] nor a general possible approach. It can be easily proven
that if all elements of the original range[first, last) will hold the
condition, it is not possible to substitute them by an element for which
the condition will not hold.
</p>


<p>25.2.7 [lib.alg.remove], paragraph 3:</p>

<p>
Current wording says:
"Returns: The end of the resulting range."
</p>

<p>
The resulting range is not specified. In combination with 25.2.7
[lib.alg.remove], paragraph 2, the only reasonable interpretation of
this so-called resulting range is the range [first,last) - thus
returning always the ForwardIterator 'last' parameter.
</p>


<p>
25.2.7 [lib.alg.remove], paragraph 4:
</p>

<p>
Current wording says:
"Notes: Stable: the relative order of the elements that are not removed
is the same as their relative order in the original range"
</p>

<p>
This sentences makes use of the term "removed", which is neither
specified, nor used in a previous paragraph (which uses the term
"eliminate"), nor unamgiuously separated from the name of the algorithm.
</p>


<p>2) Description of intended behavior:</p>

<p>
For the rest of this Defect Report, it is assumed that the intended
behavior was that all elements of the range [first, last) which do not
hold the condition *i == value (std::remove) or  pred(*i) != false
(std::remove_if)], call them s-elements [Note: s...stay], will be placed
into a contiguous subrange of [first, last), denoted by the iterators
[first, return value). The number of elements in the resulting range
[first, return value) shall be equal to the number of s-elements in the
original range [first, last). The relative order of the elements in the
resulting subrange[first, return value) shall be the same as the
relative order of the corresponding elements in the original range. It
is undefined whether any elements in the resulting subrange [return
value, last) will hold the corresponding condition, or not.
</p>

<p>
All implementations known to the author of this Defect Report comply
with this intent. Since the intent  of the behavior (contrary to the
current wording) is also described in various utility references serving
the C++ community [1], it is not expected that fixing the paragraphs
will influence current code - unless the code relies on the behavior as
it is described by current wording and the implementation indeed
reflects the current wording, and not the intent.
</p>



<p>3) Proposed fixes:</p>


<p>Change 25.2.7 [lib.alg.remove], paragraph 2 to:</p>

<p>
"Effect: Places all the elements referred to by iterator i in the range
[first, last) for which the following corresponding conditions hold :
!(*i == value), pred(*i) == false into the subrange [first, k) of the
original range, where k shall denote a value of type ForwardIterator. It
is undefined whether any elements in the resulting subrange [k, last)
will hold the corresponding condition, or not."
</p>

<p>Comments to the new wording:</p>

<p>
a) "Places" has no special meaning, and the everyday language meaning
should fit.
b) The corresponding conditions were negated compared to the current
wording, becaue the new wording requires it.
c) The wording "of the original range" might be redundant, since any
subrange starting at 'first' and containing no more elements than the
original range is implicitly a subrange of the original range [first,
last).
d) The iterator k was introduced instead of "return value" in order to
avoid a cyclic dependency on 25.2.7/3. The wording ", where k shall
denote a value of type ForwardIterator" might be redundant, because it
follows implicitly by 25.2.7/3.
e) "Places" does, in the author's opinion, explicitly forbid duplicating
any element holding the corresponding condition in the original range
[first, last) within the resulting range [first, k). If there is doubt
this term might be not unambiguous regarding this, it is suggested that
k is specified more closely by the following wording: "k shall denote a
value of type ForwardIterator [Note: see d)] so that k - first is equal
to the number of elements in the original range [first, last) for which
the corresponding condition did hold". This could also be expressed as a
separate paragraph "Postcondition:"
f) The senctence "It is undefined whether any elements in the resulting
subrange [k, last) will hold the corresponding condition, or not." was
added consciously so the term "Places" does not imply if the original
range [first, last) contains n elements holding the corresponding
condition, the identical range[first, last) will also contain exactly n
elements holding the corresponding condition after application of the
algorithm.
</p>

<p>
Change 25.2.7 [lib.alg.remove], paragraph 3 to:

"Returns: The iterator k."
</p>

<p>
Change 25.2.7 [lib.alg.remove], paragraph 4 to:

"Notes: Stable: the relative order of the elements that are placed into
the subrange [first, return value) shall be the same as their relative
order was in the original range [first, last) prior to application of
the algorithm."
</p>

<p>
Comments to the new wording:
</p>

<p>
a) the wording "was ...  prior to application of the algorithm" is used
to explicitly distinguish the original range not only by means of
iterators, but also by a 'chronological' factor from the resulting range
[first, return value). It might be redundant.
</p>

<p>
[1]:
The wording of these references is not always unambiguous, and provided
examples partially contradict verbal description of the algorithms,
because the verbal description resembles the problematic wording of
ISO/IEC 14882:2003.
</p>


<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>The LWG believes that the standard is sufficiently clear, and that
  there is no evidence of any real-world confusion about this point.</p>





<hr>
<h3><a name="490"></a>490. std::unique wrongly specified</h3>
<p><b>Section:</b> 25.3.9 [alg.unique] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Thomas Mang <b>Opened:</b> 2004-12-12  <b>Last modified:</b> 2006-12-27</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.unique">issues</a> in [alg.unique].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>In Section 25.2.8 [lib.alg.unique], paragraphs 1 to 3 describe the
behavior of the mutating sequence operation std::unique. However, the
wording does not reflect the intended behavior [Note: See definition of
intended behavior below] of these algorithms, as it is known to the C++
community [1].</p>



<p>1) Analysis of current wording:</p>


<p>25.2.8 [lib.alg.unique], paragraph 1:</p>

<p>
Current wording says:
"Effects: Eliminates all but the first element from every consecutive
group of equal elements referred to by the iterator i in the range
[first, last) for which the following corresponding conditions hold: *i
== *(i - 1) or pred(*i, *(i -1)) != false"
</p>

<p>
This sentences expresses specifically that all elements denoted by the
(original) range [first, last) which are not but the first element from
a consecutive group of equal elements (where equality is defined as *i
== *(i - 1) or pred(*i, *(i - 1)) ! = false) [Note: See DR 202], call
them r-elements [Note: r...remove], will be eliminated. Since there is
no formal definition of the term "eliminate" provided, it is undefined
how this "elimination" takes place. But the meaning of "eliminate" in
everyday language seems to disallow explicitly that after application of
the algorithm, any r-element will remain at any position of the range
[first, last) [2].
</p>

<p>
Another defect in the current wording concerns the iterators used to
compare two elements for equality: The current wording contains the
expression "(i - 1)", which is not covered by 25/9 [Note: See DR
submitted by Thomas Mang regarding invalid iterator arithmetic
expressions].
</p>


<p>
25.2.8 [lib.alg.unique], paragraph 2:
</p>
<p>Current wording says:
"Returns: The end of the resulting range."</p>

<p>
The resulting range is not specified. In combination with 25.2.8
[lib.alg.unique], paragraph 1, one reasonable interpretation (in the
author's opinion even the only possible interpretation) of this
so-called resulting range is the range [first, last) - thus returning
always the ForwardIterator 'last' parameter.
</p>

<p>2) Description of intended behavior:</p>

<p>
For the rest of this Defect Report, it is assumed that the intended
behavior was that all elements denoted by the original range [first,
last) which are the first element from a consecutive group of elements
for which the corresponding conditions: *(i-1) == *i (for the version of
unique without a predicate argument) or pred(*(i-1), *i) ! = false (for
the version of unique with a predicate argument) [Note: If such a group
of elements consists of only a single element, this is also considered
the first element] [Note: See resolutions of DR 202], call them
s-elements [Note: s...stay], will be placed into a contiguous subrange
of [first, last), denoted by the iterators [first, return value). The
number of elements in the resulting range [first, return value) shall be
equal to the number of s-elements in the original range [first, last).
Invalid iterator arithmetic expressions are expected to be resolved as
proposed in DR submitted by Thomas Mang regarding invalid iterator
arithmetic expressions. It is also assumed by the author that the
relative order of the elements in the resulting subrange [first, return
value) shall be the same as the relative order of the corresponding
elements (the s-elements) in the original range [Note: If this was not
intended behavior, the additional proposed paragraph about stable order
will certainly become obsolete].
Furthermore, the resolutions of DR 202 are partially considered.
</p>

<p>
All implementations known to the author of this Defect Report comply
with this intent [Note: Except possible effects of DR 202]. Since this
intent of the behavior (contrary to the current wording) is also
described in various utility references serving the C++ community [1],
it is not expected that fixing the paragraphs will influence current
code [Note: Except possible effects of DR 202] - unless the code relies
on the behavior as it is described by current wording and the
implementation indeed reflects the current wording, and not the intent.
</p>



<p>3) Proposed fixes:</p>

<p>
Change 25.2.8 [lib.alg.unique], paragraph 1 to:
</p>

<p>
"Effect: Places the first element from every consecutive group of
elements, referred to by the iterator i in the range [first, last), for
which the following conditions hold: *(i-1) == *i (for the version of
unique without a predicate argument) or pred(*(i -1), *i) != false (for
the version of unique with a predicate argument), into the subrange
[first, k) of the original range, where k shall denote a value of type
ForwardIterator."
</p>

<p>Comments to the new wording:</p>

<p>
a) The new wording was influenced by the resolutions of DR 202. If DR
202 is resolved in another way, the proposed wording need also
additional review.
b) "Places" has no special meaning, and the everyday language meaning
should fit.
c) The expression "(i - 1)" was left, but is expected that DR submitted
by Thomas Mang regarding invalid iterator arithmetic expressions will
take this into account.
d) The wording "(for the version of unique without a predicate
argument)" and "(for the version of unique with a predicate argument)"
was added consciously for clarity and is in resemblence with current
23.2.2.4 [lib.list.ops], paragraph 19. It might be considered redundant.
e) The wording "of the original range" might be redundant, since any
subrange starting at first and containing no more elements than the
original range is implicitly a subrange of the original range [first,
last).
f) The iterator k was introduced instead of "return value" in order to
avoid a cyclic dependency on 25.2.8 [lib.alg.unique], paragraph 2. The
wording ", where k shall denote a value of type ForwardIterator" might
be redundant, because it follows implicitly by 25.2.8 [lib.alg.unique],
paragraph 2.
g) "Places" does, in the author's opinion, explicitly forbid duplicating
any s-element in the original range [first, last) within the resulting
range [first, k). If there is doubt this term might be not unambiguous
regarding this, it is suggested that k is specified more closely by the
following wording: "k shall denote a value of type ForwardIterator
[Note: See f)] so that k - first is equal to the number of elements in
the original range [first, last) being the first element from every
consecutive group of elements for which the corresponding condition did
hold". This could also be expressed as a separate paragraph
"Postcondition:".
h) If it is considered that the wording is unclear whether it declares
the element of a group which consists of only a single element
implicitly to be the first element of this group [Note: Such an
interpretation could eventually arise especially in case last - first ==
1] , the following additional sentence is proposed: "If such a group of
elements consists of only a single element, this element is also
considered the first element."
</p>

<p>
Change 25.2.8 [lib.alg.unique], paragraph 2 to:
"Returns: The iterator k."
</p>

<p>
Add a separate paragraph "Notes:" as 25.2.8 [lib.alg.unique], paragraph
2a or 3a, or a separate paragraph "Postcondition:" before 25.2.8
[lib.alg.unique], paragraph 2 (wording inside {} shall be eliminated if
the preceding expressions are used, or the preceding expressions shall
be eliminated if wording inside {} is used):
</p>

<p>
"Notes:{Postcondition:} Stable: the relative order of the elements that
are placed into the subrange [first, return value {k}) shall be the same
as their relative order was in the original range [first, last) prior to
application of the algorithm."
</p>

<p>Comments to the new wording:</p>

<p>
a) It is assumed by the author that the algorithm was intended to be
stable.
In case this was not the intent, this paragraph becomes certainly
obsolete.
b) The wording "was ...  prior to application of the algorithm" is used
to explicitly distinguish the original range not only by means of
iterators, but also by a 'chronological' factor from the resulting range
[first, return value). It might be redundant.
</p>

<p>
25.2.8 [lib.alg.unique], paragraph 3:
</p>
<p>See DR 239.</p>

<p>
4) References to other DRs:
</p>

<p>
See DR 202, but which does not address any of the problems described in
this Defect Report [Note: This DR is supposed to complement DR 202].
See DR 239.
See DR submitted by Thomas Mang regarding invalid iterator arithmetic
expressions.
</p>

<p>
[1]:
The wording of these references is not always unambiguous, and provided
examples partially contradict verbal description of the algorithms,
because the verbal description resembles the problematic wording of
ISO/IEC 14882:2003.
</p>

<p>
[2]:
Illustration of conforming implementations according to current wording:
</p>

<p>
One way the author of this DR considers how this "elimination" could be
achieved by a conforming implementation according to current wording is
by substituting each r-element by _any_ s-element [Note: s...stay; any
non-r-element], since all r-elements are "eliminated".
</p>

<p>
In case of a sequence consisting of elements being all 'equal' [Note:
See DR 202], substituting each r-element by the single s-element is the
only possible solution according to current wording.
</p>


<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>The LWG believes the standard is sufficiently clear. No
implementers get it wrong, and changing it wouldn't cause any code to
change, so there is no real-world harm here.</p>





<hr>
<h3><a name="491"></a>491. std::list&lt;&gt;::unique incorrectly specified</h3>
<p><b>Section:</b> 23.3.4.4 [list.ops] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Thomas Mang <b>Opened:</b> 2004-12-12  <b>Last modified:</b> 2007-02-19</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#list.ops">active issues</a> in [list.ops].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#list.ops">issues</a> in [list.ops].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>In Section 23.3.4.4 [list.ops], paragraphs 19 to 21 describe the
behavior of the std::list&lt;T, Allocator&gt;::unique operation. However, the
current wording is defective for various reasons.</p>



<p>
1) Analysis of current wording:
</p>

<p>23.3.4.4 [list.ops], paragraph 19:</p>

<p>
Current wording says:
"Effects:  Eliminates all but the first element from every consecutive
group of equal elements referred to by the iterator i in the range
[first + 1, last) for which *i == *(i - 1) (for the version of unique
with no argument) or pred(*i, *(i -1)) (for the version of unique with a
predicate argument) holds."</p>

<p>
This sentences makes use of the undefined term "Eliminates". Although it
is, to a certain degree, reasonable to consider the term "eliminate"
synonymous with "erase", using "Erase" in the first place, as the
wording of 23.3.4.4 [list.ops], paragraph 15 does, would be clearer.</p>

<p>
The range of the elements referred to by iterator i is "[first + 1,
last)". However, neither "first" nor "last" is defined.</p>

<p>
The sentence makes three times use of iterator arithmetic expressions (
"first + 1", "*i == *(i - 1)", "pred(*i, *(i -1))" ) which is not
defined for bidirectional iterator [see DR submitted by Thomas Mang
regarding invalid iterator arithmetic expressions].</p>

<p>
The same problems as pointed out in DR 202 (equivalence relation / order
of arguments for pred()) apply to this paragraph.</p>

<p>
23.3.4.4 [list.ops], paragraph 20:
</p>

<p>
Current wording says:
"Throws: Nothing unless an exception in thrown by *i == *(i-1) or
pred(*i, *(i - 1))"</p>

<p>
The sentence makes two times use of invalid iterator arithmetic
expressions ( "*i == *(i - 1)", "pred(*i, *(i -1))" ).
</p>
<p>
[Note: Minor typos: "in" / missing dot at end of sentence.]
</p>

<p>
23.3.4.4 [list.ops], paragraph 21:</p>

<p>
Current wording says:
"Complexity: If the range (last - first) is not empty, exactly (last -
first) - 1 applications of the corresponding predicate, otherwise no
application of the predicate.</p>

<p>
See DR 315 regarding "(last - first)" not yielding a range.</p>

<p>
Invalid iterator arithmetic expression "(last - first) - 1" left .</p>


<p>2) Description of intended behavior:</p>

<p>
For the rest of this Defect Report, it is assumed that "eliminate" is
supposed to be synonymous to "erase", that "first" is equivalent to an
iterator obtained by a call to begin(), "last" is equivalent to an
iterator obtained by a call to end(), and that all invalid iterator
arithmetic expressions are resolved as described in DR submitted by
Thomas Mang regarding invalid iterator arithmetic expressions.</p>

<p>
Furthermore, the resolutions of DR 202 are considered regarding
equivalence relation and order of arguments for a call to pred.</p>

<p>
All implementations known to the author of this Defect Report comply
with these assumptions, apart from the impact of the alternative
resolution of DR 202. Except for the changes implied by the resolutions
of DR 202, no impact on current code is expected.</p>

<p>
3) Proposed fixes:</p>

<p>
Change 23.3.4.4 [list.ops], paragraph 19 to:</p>

<p>
"Effect: Erases all but the first element from every consecutive group
of elements, referred to by the iterator i in the range [begin(),
end()), for which the following conditions hold: *(i-1) == *i (for the
version of unique with no argument) or pred(*(i-1), *i) != false (for
the version of unique with a predicate argument)."</p>

<p>
Comments to the new wording:</p>

<p>
a) The new wording was influenced by DR 202 and the resolutions
presented there. If DR 202 is resolved in another way, the proposed
wording need also additional review.
b) "Erases" refers in the author's opinion unambiguously to the member
function "erase". In case there is doubt this might not be unamgibuous,
a direct reference to the member function "erase" is suggested [Note:
This would also imply a change of 23.3.4.4 [list.ops], paragraph
15.].
c) The expression "(i - 1)" was left, but is expected that DR submitted
by Thomas Mang regarding invalid iterator arithmetic expressions will
take this into account.
d) The wording "(for the version of unique with no argument)" and "(for
the version of unique with a predicate argument)" was kept consciously
for clarity.
e) "begin()" substitutes "first", and "end()" substitutes "last". The
range need adjustment from "[first + 1, last)" to "[begin(), end())" to
ensure a valid range in case of an empty list.
f) If it is considered that the wording is unclear whether it declares
the element of a group which consists of only a single element
implicitly to be the first element of this group [Note: Such an
interpretation could eventually arise especially in case size() == 1] ,
the following additional sentence is proposed: "If such a group of
elements consists of only a single element, this element is also
considered the first element."</p>

<p>
Change 23.3.4.4 [list.ops], paragraph 20 to:</p>

<p>
"Throws: Nothing unless an exception is thrown by *(i-1) == *i or
pred(*(i-1), *i)."</p>

<p>
Comments to the new wording:</p>

<p>
a) The wording regarding the conditions is identical to proposed
23.3.4.4 [list.ops], paragraph 19. If 23.3.4.4 [list.ops],
paragraph 19 is resolved in another way, the proposed wording need also
additional review.
b) The expression "(i - 1)" was left, but is expected that DR submitted
by Thomas Mang regarding invalid iterator arithmetic expressions will
take this into account.
c) Typos fixed.</p>

<p>
Change 23.3.4.4 [list.ops], paragraph 21 to:</p>

<p>
"Complexity: If empty() == false, exactly size() - 1 applications of the
corresponding predicate, otherwise no applications of the corresponding
predicate."</p>

<p>
Comments to the new wording:</p>

<p>
a) The new wording is supposed to also replace the proposed resolution
of DR 315, which suffers from the problem of undefined "first" / "last".
</p>

<p>
5) References to other DRs:</p>

<p>See DR 202.
See DR 239.
See DR 315.
See DR submitted by Thomas Mang regarding invalid iterator arithmetic
expressions.</p>



<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>"All implementations known to the author of this Defect Report
comply with these assumption", and "no impact on current code is
expected", i.e. there is no evidence of real-world confusion or
harm.</p>





<hr>
<h3><a name="492"></a>492. Invalid iterator arithmetic expressions</h3>
<p><b>Section:</b> 17.5.1.4 [structure.specifications] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Thomas Mang <b>Opened:</b> 2004-12-12  <b>Last modified:</b> 2009-07-15</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#structure.specifications">issues</a> in [structure.specifications].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>Various clauses other than clause 25 make use of iterator arithmetic not
supported by the iterator category in question.
Algorithms in clause 25 are exceptional because of 25 [lib.algorithms],
paragraph 9, but this paragraph does not provide semantics to the
expression "iterator - n", where n denotes a value of a distance type
between iterators.</p>

<p>1) Examples of current wording:</p>

<p>Current wording outside clause 25:</p>

<p>
23.2.2.4 [lib.list.ops], paragraphs 19-21: "first + 1", "(i - 1)",
"(last - first)"
23.3.1.1 [lib.map.cons], paragraph 4: "last - first"
23.3.2.1 [lib.multimap.cons], paragraph 4: "last - first"
23.3.3.1 [lib.set.cons], paragraph 4: "last - first"
23.3.4.1 [lib.multiset.cons], paragraph 4: "last - first"
24.4.1 [lib.reverse.iterators], paragraph 1: "(i - 1)"
</p>

<p>
[Important note: The list is not complete, just an illustration. The
same issue might well apply to other paragraphs not listed here.]</p>

<p>None of these expressions is valid for the corresponding iterator
category.</p>

<p>Current wording in clause 25:</p>

<p>
25.1.1 [lib.alg.foreach], paragraph 1: "last - 1"
25.1.3 [lib.alg.find.end], paragraph 2: "[first1, last1 -
(last2-first2))"
25.2.8 [lib.alg.unique], paragraph 1: "(i - 1)"
25.2.8 [lib.alg.unique], paragraph 5: "(i - 1)"
</p>

<p>
However, current wording of 25 [lib.algorithms], paragraph 9 covers
neither of these four cases:</p>

<p>Current wording of 25 [lib.algorithms], paragraph 9:</p>

<p>
"In the description of the algorithms operator + and - are used for some
of the iterator categories for which they do not have to be defined. In
these cases the semantics of a+n is the same as that of</p>
<pre>{X tmp = a;
advance(tmp, n);
return tmp;
}
</pre>
<p>and that of b-a is the same as of return distance(a, b)"</p>

<p>
This paragrpah does not take the expression "iterator - n" into account,
where n denotes a value of a distance type between two iterators [Note:
According to current wording, the expression "iterator - n" would be
resolved as equivalent to "return distance(n, iterator)"]. Even if the
expression "iterator - n" were to be reinterpreted as equivalent to
"iterator + -n" [Note: This would imply that "a" and "b" were
interpreted implicitly as values of iterator types, and "n" as value of
a distance type], then 24.3.4/2 interfers because it says: "Requires: n
may be negative only for random access and bidirectional iterators.",
and none of the paragraphs quoted above requires the iterators on which
the algorithms operate to be of random access or bidirectional category.
</p>

<p>2) Description of intended behavior:</p>

<p>
For the rest of this Defect Report, it is assumed that the expression
"iterator1 + n" and "iterator1 - iterator2" has the semantics as
described in current 25 [lib.algorithms], paragraph 9, but applying to
all clauses. The expression "iterator1 - n" is equivalent to an
result-iterator for which the expression "result-iterator + n" yields an
iterator denoting the same position as iterator1 does. The terms
"iterator1", "iterator2" and "result-iterator" shall denote the value of
an iterator type, and the term "n" shall denote a value of a distance
type between two iterators.</p>

<p>
All implementations known to the author of this Defect Report comply
with these assumptions.
No impact on current code is expected.</p>

<p>3) Proposed fixes:</p>


<p>Change 25 [lib.algorithms], paragraph 9 to:</p>

<p>
"In the description of the algorithms operator + and - are used for some
of the iterator categories for which they do not have to be defined. In
this paragraph, a and b denote values of an iterator type, and n denotes
a value of a distance type between two iterators. In these cases the
semantics of a+n is the same as that of</p>
<pre>{X tmp = a;
advance(tmp, n);
return tmp;
}
</pre>
<p>,the semantics of a-n denotes the value of an iterator i for which the
following condition holds:
advance(i, n) == a,
and that of b-a is the same as of
return distance(a, b)".
</p>

<p>Comments to the new wording:</p>

<p>
a) The wording " In this paragraph, a and b denote values of an iterator
type, and n denotes a value of a distance type between two iterators."
was added so the expressions "b-a" and "a-n" are distinguished regarding
the types of the values on which they operate.
b) The wording ",the semantics of a-n denotes the value of an iterator i
for which the following condition holds: advance(i, n) == a" was added
to cover the expression 'iterator - n'. The wording "advance(i, n) == a"
was used to avoid a dependency on the semantics of a+n, as the wording
"i + n == a" would have implied. However, such a dependency might well
be deserved.
c) DR 225 is not considered in the new wording.
</p>

<p>
Proposed fixes regarding invalid iterator arithmetic expressions outside
clause 25:</p>

<p>
Either
a) Move modified 25 [lib.algorithms], paragraph 9 (as proposed above)
before any current invalid iterator arithmetic expression. In that case,
the first sentence of 25 [lib.algorithms], paragraph 9, need also to be
modified and could read: "For the rest of this International Standard,
...." / "In the description of the following clauses including this
...." / "In the description of the text below ..." etc. - anyways
substituting the wording "algorithms", which is a straight reference to
clause 25.
In that case, 25 [lib.algorithms] paragraph 9 will certainly become
obsolete.
Alternatively,
b) Add an appropiate paragraph similar to resolved 25 [lib.algorithms],
paragraph 9, to the beginning of each clause containing invalid iterator
arithmetic expressions.
Alternatively,
c) Fix each paragraph (both current wording and possible resolutions of
DRs) containing invalid iterator arithmetic expressions separately.
</p>

<p>5) References to other DRs:</p>

<p>
See DR 225.
See DR 237. The resolution could then also read "Linear in last -
first".
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
Keep open and ask Bill to provide wording.
</blockquote>

<p><i>[
2009-05-09 Alisdair adds:
]</i></p>


<blockquote>
This issue is related to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#997">997</a>.
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
Hinnant: this isn't going to change any user's code or any vendor's implementation.
</p>
<p>
No objection to "NAD without prejudice." If anyone proposes a
resolution, the LWG will consider it.
</p>
<p>
Move to NAD.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>

<p><i>[Lillehammer: Minor issue, but real. We have a blanket statement
about this in 25/11. But (a) it should be in 17, not 25; and (b) it's
not quite broad enough, because there are some arithmetic expressions
it doesn't cover. Bill will provide wording.]</i></p>







<hr>
<h3><a name="493"></a>493. Undefined Expression in Input Iterator Note Title</h3>
<p><b>Section:</b> 24.2.1 [input.iterators] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Chris Jefferson <b>Opened:</b> 2004-12-13  <b>Last modified:</b> 2006-12-27</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#input.iterators">issues</a> in [input.iterators].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>1) In 24.1.1/3, the following text is currently present.</p>

<p>"Note: For input iterators, a==b does not imply ++a=++b (Equality does
not guarantee the substitution property or referential transparency)."</p>

<p>However, when in Table 72, part of the definition of ++r is given as:</p>

<p>"pre: r is dereferenceable.
post: any copies of the previous value of r are no longer required
either to be dereferenceable ..."</p>

<p>While a==b does not imply that b is a copy of a, this statement should
perhaps still be made more clear.</p>

<p>2) There are no changes to intended behaviour</p>

<p>
3) This Note should be altered to say "Note: For input iterators a==b,
when its behaviour is defined ++a==++b may still be false (Equality does
not guarantee the substitution property or referential transparency).</p>



<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>This is descriptive text, not normative, and the meaning is clear.</p>





<hr>
<h3><a name="494"></a>494. Wrong runtime complexity for associative container's insert and delete</h3>
<p><b>Section:</b> 23.2.4 [associative.reqmts] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Hans B os <b>Opened:</b> 2004-12-19  <b>Last modified:</b> 2006-12-27</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#associative.reqmts">active issues</a> in [associative.reqmts].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#associative.reqmts">issues</a> in [associative.reqmts].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>According to [lib.associative.reqmts] table 69, the runtime comlexity
of insert(p, t) and erase(q) can be done in amortized constant time.</p>

<p>It was my understanding that an associative container could be
implemented as a balanced binary tree.</p>

<p>For inser(p, t), you 'll have to iterate to p's next node to see if t
can be placed next to p.  Furthermore, the insertion usually takes
place at leaf nodes. An insert next to the root node will be done at
the left of the root next node</p>

<p>So when p is the root node you 'll have to iterate from the root to
its next node, which  takes O(log(size)) time in a balanced tree.</p>

<p>If you insert all values with insert(root, t) (where root is the
root of the tree before insertion) then each insert takes O(log(size))
time.  The amortized complexity per insertion will be O(log(size))
also.</p>

<p>For erase(q), the normal algorithm for deleting a node that has no
empty left or right subtree, is to iterate to the next (or previous),
which is a leaf node. Then exchange the node with the next and delete
the leaf node.  Furthermore according to DR 130, erase should return
the next node of the node erased.  Thus erasing the root node,
requires iterating to the next node.</p>

<p>Now if you empty a map by deleting the root node until the map is
empty, each operation will take O(log(size)), and the amortized
complexity is still O(log(size)).</p>

<p>The operations can be done in amortized constant time if iterating
to the next node can be done in (non amortized) constant time.  This
can be done by putting all nodes in a double linked list.  This
requires two extra links per node.  To me this is a bit overkill since
you can already efficiently insert or erase ranges with erase(first,
last) and insert(first, last).</p>



<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>Only "amortized constant" in special circumstances, and we believe
  that's implementable. That is: doing this N times will be O(N), not
  O(log N).</p>





<hr>
<h3><a name="499"></a>499. Std. doesn't seem to require stable_sort() to be stable!</h3>
<p><b>Section:</b> 25.4.1.2 [stable.sort] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Prateek Karandikar <b>Opened:</b> 2005-04-12  <b>Last modified:</b> 2008-03-13</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<blockquote><p>
17.3.1.1 Summary</p>

<p>
1 The Summary provides a synopsis of the category, and introduces the 
first-level subclauses. Each subclause also provides a summary, listing 
the headers specified in the subclause and the library entities 
provided in each header. 
</p>
<p>
2 Paragraphs labelled "Note(s):" or "Example(s):" are informative, 
other paragraphs are normative.
</p></blockquote> 

<p>So this means that a "Notes" paragraph wouldn't be normative. </p>

<blockquote><p>
25.3.1.2 stable_sort
</p>
<pre>template&lt;class RandomAccessIterator&gt; 
void stable_sort(RandomAccessIterat or first, RandomAccessIterator last); 

template&lt;class RandomAccessIterator, class Compare&gt; 
void stable_sort(RandomAccessIterat or first, RandomAccessIterator last, Compare comp);
</pre>
<p>
1 Effects: Sorts the elements in the range [first, last).
</p>
<p>
2 Complexity: It does at most N(log N)^2 (where N == last - first) 
comparisons; if enough extra memory is available, it is N log N.
</p>
<p>
3 Notes: Stable: the relative order of the equivalent elements is 
preserved. 
</p></blockquote> 

<p>
The Notes para is informative, and nowhere else is stability mentioned above. 
</p>

<p>
Also, I just searched for the word "stable" in my copy of the Standard. 
and the phrase "Notes: Stable: the relative order of the elements..." 
is repeated several times in the Standard library clauses for 
describing various functions. How is it that stability is talked about 
in the informative paragraph? Or am I missing something obvious? 
</p>


<p><b>Proposed resolution:</b></p>
<p>
</p>


<p><b>Rationale:</b></p>
<p>
This change has already been made.
</p>





<hr>
<h3><a name="500"></a>500. do_length cannot be implemented correctly</h3>
<p><b>Section:</b> 22.4.1.5 [locale.codecvt.byname] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Krzysztof &#379;elechowski <b>Opened:</b> 2005-05-24  <b>Last modified:</b> 2008-03-13</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.codecvt.byname">issues</a> in [locale.codecvt.byname].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<ol>
<li>codecvt::do_length is of type int;</li>
<li>it is assumed to be sort-of returning from_next - from of type ptrdiff_t;</li>
<li>ptrdiff_t cannot be cast to an int without data loss.</li>
</ol>
<p>
Contradiction.
</p>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="501"></a>501. Proposal: strengthen guarantees of lib.comparisons</h3>
<p><b>Section:</b> 20.7.3 [base] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Me &lt;anti_spam_email2003@yahoo.com&gt; <b>Opened:</b> 2005-06-07  <b>Last modified:</b> 2008-03-13</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#base">issues</a> in [base].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<blockquote><p>
"For templates greater, less, greater_equal, and less_equal,
the specializations for any pointer type yield a total order, even if
the built-in operators &lt;, &gt;, &lt;=, &gt;= do not."
</p></blockquote>

<p>
The standard should do much better than guarantee that these provide a
total order, it should guarantee that it can be used to test if memory
overlaps, i.e. write a portable memmove. You can imagine a platform
where the built-in operators use a uint32_t comparison (this tests for
overlap on this platform) but the less&lt;T*&gt; functor is allowed to be
defined to use a int32_t comparison. On this platform, if you use
std::less with the intent of making a portable memmove, comparison on
an array that straddles the 0x7FFFFFFF/0x8000000 boundary can give
incorrect results.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add a footnote to 20.5.3/8 saying:
</p>

<blockquote><p>
Given a p1 and p2 such that p1 points to N objects of type T and p2
points to M objects of type T. If [p1,p1+N) does not overlap [p2,p2+M),
less returns the same value when comparing all pointers in [p1,p1+N) to
all pointers in [p2,p2+M). Otherwise, there is a value Q and a value R
such that less returns the same value when comparing all pointers in
[p1,p1+Q) to all pointers in [p2,p2+R) and an opposite value when
comparing all pointers in [p1+Q,p1+N) to all pointers in [p2+R,p2+M).
For the sake of completeness, the null pointer value (4.10) for T is
considered to be an array of 1 object that doesn't overlap with any
non-null pointer to T. less_equal, greater, greater_equal, equal_to,
and not_equal_to give the expected results based on the total ordering
semantics of less. For T of void, treat it as having similar semantics
as T of char i.e. less&lt;cv T*&gt;(a, b) gives the same results as less&lt;cv
void*&gt;(a, b) which gives the same results as less&lt;cv char*&gt;((cv
char*)(cv void*)a, (cv char*)(cv void*)b).
</p></blockquote>

<p>
I'm also thinking there should be a footnote to 20.5.3/1 saying that if
A and B are similar types (4.4/4), comp&lt;A&gt;(a,b) returns the same value
as comp&lt;B&gt;(a,b) (where comp is less, less_equal, etc.). But this might
be problematic if there is some really funky operator overloading going
on that does different things based on cv (that should be undefined
behavior if somebody does that though). This at least should be
guaranteed for all POD types (especially pointers) that use the
built-in comparison operators.
</p>



<p><b>Rationale:</b></p>
<p>
less is already required to provide a strict weak ordering which is good enough
to detect overlapping memory situations.
</p>





<hr>
<h3><a name="502"></a>502. Proposition: Clarification of the interaction between a facet and an iterator</h3>
<p><b>Section:</b> 22.3.1.1.1 [locale.category] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Christopher Conrade Zseleghovski <b>Opened:</b> 2005-06-07  <b>Last modified:</b> 2009-07-15</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.category">issues</a> in [locale.category].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Motivation:
</p>

<p>
This requirement seems obvious to me, it is the essence of code modularity. 
I have complained to Mr. Plauger that the Dinkumware library does not 
observe this principle but he objected that this behaviour is not covered in 
the standard.
</p>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
No objection to NAD, Fixed.
</p>
<p>
Move to NAD.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Append the following point to 22.1.1.1.1:
</p>

<p>
6. The implementation of a facet of Table 52 parametrized with an 
InputIterator/OutputIterator should use that iterator only as character 
source/sink respectively.
For a *_get facet, it means that the value received depends only on the 
sequence of input characters and not on how they are accessed.
For a *_put facet, it means that the sequence of characters output depends 
only on the value to be formatted and not of how the characters are stored.
</p>

<p><i>[
Berlin:  Moved to Open, Need to clean up this area to make it clear
locales don't have to contain open ended sets of facets. Jack, Howard,
Bill.
]</i></p>







<hr>
<h3><a name="503"></a>503. more on locales</h3>
<p><b>Section:</b> 22.4 [locale.categories] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> P.J. Plauger <b>Opened:</b> 2005-06-20  <b>Last modified:</b> 2009-07-15</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.categories">issues</a> in [locale.categories].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
a) In 22.2.1.1 para. 2 we refer to "the instantiations required in Table
51" to refer to the facet *objects* associated with a locale. And we
almost certainly mean just those associated with the default or "C"
locale. Otherwise, you can't switch to a locale that enforces a different
mapping between narrow and wide characters, or that defines additional
uppercase characters.
</p>

<p>
b) 22.2.1.5 para. 3 (codecvt) has the same issues.
</p>

<p>
c) 22.2.1.5.2 (do_unshift) is even worse. It *forbids* the generation of
a homing sequence for the basic character set, which might very well need
one.
</p>

<p>
d) 22.2.1.5.2 (do_length) likewise dictates that the default mapping
between wide and narrow characters be taken as one-for-one.
</p>

<p>
e) 22.2.2 para. 2 (num_get/put) is both muddled and vacuous, as far as
I can tell. The muddle is, as before, calling Table 51 a list of
instantiations. But the constraint it applies seems to me to cover
*all* defined uses of num_get/put, so why bother to say so?
</p>

<p>
f) 22.2.3.1.2 para. 1(do_decimal_point) says "The required instantiations
return '.' or L'.'.) Presumably this means "as appropriate for the
character type. But given the vague definition of "required" earlier,
this overrules *any* change of decimal point for non "C" locales.
Surely we don't want to do that.
</p>

<p>
g) 22.2.3.1.2 para. 2 (do_thousands_sep) says "The required instantiations
return ',' or L','.) As above, this probably means "as appropriate for the
character type. But this overrules the "C" locale, which requires *no*
character ('\0') for the thousands separator. Even if we agree that we
don't mean to block changes in decimal point or thousands separator,
we should also eliminate this clear incompatibility with C.
</p>

<p>
h) 22.2.3.1.2 para. 2 (do_grouping) says "The required instantiations
return the empty string, indicating no grouping." Same considerations
as for do_decimal_point.
</p>

<p>
i) 22.2.4.1 para. 1 (collate) refers to "instantiations required in Table
51". Same bad jargon.
</p>

<p>
j) 22.2.4.1.2 para. 1 (do_compare) refers to "instantiations required
in Table 51". Same bad jargon.
</p>

<p>
k) 22.2.5 para. 1 (time_get/put) uses the same muddled and vacuous
as num_get/put.
</p>

<p>
l) 22.2.6 para. 2 (money_get/put) uses the same muddled and vacuous
as num_get/put.
</p>

<p>
m) 22.2.6.3.2 (do_pos/neg_format) says "The instantiations required
in Table 51 ... return an object of type pattern initialized to
{symbol, sign, none, value}." This once again *overrides* the "C"
locale, as well as any other locale."
</p>

<p>
3) We constrain the use_facet calls that can be made by num_get/put,
so why don't we do the same for money_get/put? Or for any of the
other facets, for that matter?
</p>

<p>
4) As an almost aside, we spell out when a facet needs to use the ctype
facet, but several also need to use a codecvt facet and we don't say so.
</p>
<p><i>[
Berlin: Bill to provide wording.
]</i></p>


<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
No objection to NAD.
</p>
<p>
Move to NAD.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="504"></a>504. Integer types in pseudo-random number engine requirements</h3>
<p><b>Section:</b> X [rand.req], TR1 5.1.1 [tr.rand.req] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Walter Brown <b>Opened:</b> 2005-07-03  <b>Last modified:</b> 2008-03-13</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.req">issues</a> in [rand.req].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In [tr.rand.req], Paragraph 2 states that "... s is a value of integral type,
g is an ... object returning values of unsigned integral type ..."
</p>


<p><b>Proposed resolution:</b></p>
<p>
In 5.1.1 [tr.rand.req], Paragraph 2 replace
</p>

<blockquote><p>
... s is a value of integral type, g is an lvalue of a type other than X that
defines a zero-argument function object returning values of <del>unsigned integral</del> type
<ins><tt>unsigned long int</tt></ins>,
...
</p></blockquote>

<p>
In 5.1.1 [tr.rand.seq], Table 16, replace in the line for X(s)
</p>

<blockquote><p>
creates an engine with the initial internal state
determined by <ins><tt>static_cast&lt;unsigned long&gt;(</tt></ins><tt><i>s</i></tt><ins><tt>)</tt></ins>
</p></blockquote>

<p><i>[
Mont Tremblant:  Both s and g should be unsigned long.
This should refer to the constructor signatures. Jens  provided wording post Mont Tremblant.
]</i></p>


<p><i>[
Berlin:  N1932 adopts the proposed resolution:  see 26.3.1.3/1e and Table 3 row 2. Moved
to Ready.
]</i></p>




<p><b>Rationale:</b></p>
<p>
Jens:  Just requiring X(unsigned long) still makes it possible
for an evil library writer to also supply a X(int) that does something
unexpected.  The wording above requires that X(s) always performs
as if X(unsigned long) would have been called.  I believe that is
sufficient and implements our intentions from Mont Tremblant.  I
see no additional use in actually requiring a X(unsigned long)
signature.  u.seed(s) is covered by its reference to X(s), same
arguments.
</p>


<p><i>[
Portland:  Subsumed by N2111.
]</i></p>





<hr>
<h3><a name="506"></a>506. Requirements of Distribution parameter for variate_generator</h3>
<p><b>Section:</b> 26.5 [rand], TR1 5.1.3 [tr.rand.var] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Walter Brown <b>Opened:</b> 2005-07-03  <b>Last modified:</b> 2008-03-13</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand">issues</a> in [rand].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Paragraph 3 requires that template argument U (which corresponds to template
parameter Engine) satisfy all uniform random number generator requirements.
However, there is no  analogous requirement regarding the template argument
that corresponds to template parameter Distribution.  We believe there should
be, and that it should require that this template argument satisfy all random
distribution requirements.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Consequence 1: Remove the precondition clauses [tr.rand.var]/16 and /18.
</p>
<p>
Consequence 2: Add max() and min() functions to those distributions that
do not already have them.
</p>

<p><i>[
Mont Tremblant: Jens reccommends NAD, min/max not needed everywhere.
Marc supports having min and max to satisfy generic programming interface.
]</i></p>




<p><b>Rationale:</b></p>
<p>Berlin:  N1932 makes this moot: variate_generator has been eliminated.</p>





<hr>
<h3><a name="509"></a>509. Uniform_int template parameters</h3>
<p><b>Section:</b> 26.5.8.1 [rand.dist.uni], TR1 5.1.7.1 [tr.rand.dist.iunif] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Walter Brown <b>Opened:</b> 2005-07-03  <b>Last modified:</b> 2008-03-13</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.dist.uni">issues</a> in [rand.dist.uni].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In [tr.rand.dist.iunif] the uniform_int distribution currently has a single
template parameter, IntType, used as the input_type and as the result_type
of the distribution.  We believe there is no reason to conflate these types
in this way.
</p>


<p><b>Proposed resolution:</b></p>
<p>
We recommend that there be a second template  parameter to
reflect the distribution's input_type, and that the existing first template
parameter continue to reflect (solely) the result_type:
</p>
<blockquote><pre>template&lt; class IntType = int, UIntType = unsigned int &gt;
class uniform_int
{
public:
  // types
  typedef  UIntType  input_type;
  typedef  IntType   result_type;
</pre></blockquote>

<p><i>[
Berlin: Moved to NAD.  N1932 makes this moot: the input_type template parameter has been
eliminated.
]</i></p>







<hr>
<h3><a name="510"></a>510. Input_type for bernoulli_distribution</h3>
<p><b>Section:</b> 26.5.8.2 [rand.dist.bern], TR1 5.1.7.2 [tr.rand.dist.bern] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Walter Brown <b>Opened:</b> 2005-07-03  <b>Last modified:</b> 2008-03-13</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In [tr.rand.dist.bern] the distribution currently requires;
</p>
<blockquote><pre>typedef  int  input_type;
</pre></blockquote>


<p><b>Proposed resolution:</b></p>
<p>
We believe this is an unfortunate choice, and recommend instead:
</p>
<blockquote><pre>typedef  unsigned int  input_type;
</pre></blockquote>

<p><i>[
Berlin:  Moved to NAD. N1932 makes this moot: the input_type template parameter has been
eliminated.
]</i></p>







<hr>
<h3><a name="511"></a>511. Input_type for binomial_distribution</h3>
<p><b>Section:</b> 26.5.8 [rand.dist], TR1 5.1.7.5 [tr.rand.dist.bin] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Walter Brown <b>Opened:</b> 2005-07-03  <b>Last modified:</b> 2008-03-13</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.dist">issues</a> in [rand.dist].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Unlike all other distributions in TR1, this binomial_distribution has an
implementation-defined  input_type.  We believe this is an unfortunate choice,
because it hinders users from writing portable code.  It also hinders the
writing of compliance tests.  We recommend instead:
</p>
<blockquote><pre>typedef  RealType  input_type;
</pre></blockquote>
<p>
While this choice is somewhat arbitrary (as it was for some of the other
distributions), we make  this particular choice because (unlike all other
distributions) otherwise this template would not publish its RealType
argument and so users could not write generic code that accessed this
second template parameter.  In this respect, the choice is consistent with
the other distributions in  TR1. 
</p>
<p>
We have two reasons for recommending that a real type be specified instead.
One reason is  based specifically on characteristics of binomial distribution
implementations, while the other is based on mathematical characteristics of
probability distribution functions in general.
</p>
<p>
Implementations of binomial distributions commonly use Stirling approximations
for values in certain ranges.  It is far more natural to use real values to
represent these approximations than it would be to use integral values to do
so.  In other ranges, implementations reply on the Bernoulli  distribution to
obtain values.  While TR1's bernoulli_distribution::input_type is specified as
int, we believe this would be better specified as double.
</p>
<p>
This brings us to our main point:  The notion of a random distribution rests
on the notion of a cumulative distribution function, which in turn mathematically
depends on a continuous dependent variable.  Indeed, such a distribution function
would be meaningless if it depended on  discrete values such as integers - and this
remains true even if the distribution function were to take discrete steps.
</p>
<p>
Although this note is specifically about binomial_distribution::input_type,
we intend to recommend that all of the random distributions input_types be
specified as a real type (either a RealType template parameter, or double,
as appropriate).
</p>
<p>
Of the nine distributions in TR1, four already have this characteristic
(uniform_real, exponential_distribution, normal_distribution, and
gamma_distribution).  We have already argued the case for the binomial the
remaining four distributions.
</p>
<p>
In the case of uniform_int, we believe that the calculations to produce an
integer result in a  specified range from an integer in a different specified
range is best done using real arithmetic.  This is because it involves a
product, one of whose terms is the ratio of the extents of the two ranges.
Without real arithmetic, the results become less uniform: some numbers become
more  (or less) probable that they should be.  This is, of course, undesireable
behavior in a uniform distribution.
</p>
<p>
Finally, we believe that in the case of the bernoulli_distribution (briefly
mentioned earlier), as well as the cases of the geometric_distribution and the
poisson_distribution, it would be far more natural to have a real input_type.
This is because the most natural computation involves the  random number
delivered and the distribution's parameter p (in the case of bernoulli_distribution,
for example, the computation is a comparison against p), and p is already specified
in each case as having some real type.
</p>


<p><b>Proposed resolution:</b></p>
<blockquote><pre>typedef  RealType  input_type;
</pre></blockquote>

<p><i>[
Berlin:  Moved to NAD.  N1932 makes this moot: the input_type template parameter has been
eliminated.
]</i></p>






<hr>
<h3><a name="512"></a>512. Seeding subtract_with_carry_01 from a single unsigned long</h3>
<p><b>Section:</b> 26.5.3 [rand.eng], TR1 5.1.4.4 [tr.rand.eng.sub1] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Walter Brown <b>Opened:</b> 2005-07-03  <b>Last modified:</b> 2008-03-13</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.eng">issues</a> in [rand.eng].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Paragraph 8 specifies the algorithm by which a subtract_with_carry_01  engine
is to be seeded given a single unsigned long.  This algorithm is seriously
flawed in the case where the engine parameter w (also known as word_size)
exceeds 31 [bits].  The key part of the paragraph reads:
</p>
<blockquote><p>
sets x(-r) ... x(-1) to (lcg(1)*2**(-w)) mod 1
</p></blockquote>
<p>
and so forth. 
</p>
<p>
Since the specified linear congruential engine, lcg, delivers numbers with
a maximum of 2147483563 (just a shade under 31 bits), then when w is, for
example, 48, each of the x(i) will be less than 2**-17.  The consequence
is that roughly the first 400 numbers delivered will be  conspicuously
close to either zero or one.
</p>
<p>
Unfortunately, this is not an innocuous flaw:  One of the predefined engines
in [tr.rand.predef],  namely ranlux64_base_01, has w = 48 and would exhibit
this poor behavior, while the original N1378 proposal states that these
pre-defined engines are intended to be of "known good properties."
</p>


<p><b>Proposed resolution:</b></p>
<p>
In 5.1.4.4 [tr.rand.eng.sub1], replace the "effects" clause for
void seed(unsigned long value = 19780503) by
</p>

<blockquote><p>
<i>Effects:</i> If <tt>value == 0</tt>, sets value to <tt>19780503</tt>. In any
case, <del>with a linear congruential generator <tt>lcg</tt>(i) having parameters
<tt><i>m<sub>lcg</sub></i> = 2147483563</tt>, <tt><i>a<sub>lcg</sub></i> = 40014</tt>,
<tt><i>c<sub>lcg</sub></i> = 0</tt>, and <tt><i>lcg</i>(0) = value</tt>,</del>
sets <ins>carry<tt>(-1)</tt> and</ins> <tt>x(-r) &#8230; x(-1)</tt>
<ins>as if executing</ins></p>

<blockquote><pre><ins>
linear_congruential&lt;unsigned long, 40014, 0, 2147483563&gt; lcg(value);
seed(lcg);
</ins></pre></blockquote>

<p>
<del>to <tt>(<i>lcg</i>(1)  2<sup>-<i>w</i></sup>) mod 1
&#8230; (<i>lcg</i>(<i>r</i>)  2<sup>-<i>w</i></sup>) mod 1</tt>,
respectively. If <tt><i>x</i>(-1) == 0</tt>, sets carry<tt>(-1) = 2<sup>-<i>w</i></sup></tt>,
else sets carry<tt>(-1) = 0</tt>.</del></p>
</blockquote>

<p><i>[
Jens provided revised wording post Mont Tremblant.
]</i></p>


<p><i>[
Berlin: N1932 adopts the originally-proposed resolution of the issue.
Jens's supplied wording is a clearer description of what is
intended.  Moved to Ready.
]</i></p>




<p><b>Rationale:</b></p>
<p>
Jens: I'm using an explicit type here, because fixing the
prose would probably not qualify for the (with issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#504">504</a> even
stricter) requirements we have for seed(Gen&amp;).
</p>

<p><i>[
Portland:  Subsumed by N2111.
]</i></p>






<hr>
<h3><a name="513"></a>513. Size of state for subtract_with_carry_01</h3>
<p><b>Section:</b> 26.5.3 [rand.eng], TR1 5.1.4.4 [tr.rand.eng.sub1] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Walter Brown <b>Opened:</b> 2005-07-03  <b>Last modified:</b> 2008-03-13</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.eng">issues</a> in [rand.eng].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Paragraph 3 begins:
</p>
<blockquote><p>
The size of the state is r.
</p></blockquote>
<p>
However, this is not quite consistent with the remainder of the paragraph
which specifies a total  of nr+1 items in the textual representation of
the state.  We recommend the sentence be corrected to match:
</p>
<blockquote><p>
The size of the state is nr+1.
</p></blockquote>
<p>
To give meaning to the coefficient n, it may be also desirable to move
n's definition from later in the paragraph.  Either of the following
seem reasonable formulations:
</p>
<blockquote><p>
With n=..., the size of the state is nr+1.
</p></blockquote>
<blockquote><p>
The size of the state is nr+1, where n=... .
</p></blockquote>



<p><b>Proposed resolution:</b></p>
<p><i>[
Jens:  I plead for "NAD" on the grounds that "size of state" is only
used as an argument for big-O complexity notation, thus
constant factors and additions don't count.
]</i></p>


<p><i>[
Berlin: N1932 adopts the proposed NAD.
]</i></p>







<hr>
<h3><a name="514"></a>514. Size of state for subtract_with_carry</h3>
<p><b>Section:</b> 26.5.3.3 [rand.eng.sub], TR1 5.1.4.3 [tr.rand.eng.sub] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Walter Brown <b>Opened:</b> 2005-07-03  <b>Last modified:</b> 2008-03-13</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Paragraph 2 begins:
</p>
<blockquote><p>
The size of the state is r.
</p></blockquote>
<p>
However, the next sentence specifies a total of r+1 items in the textual
representation of the state,  r specific x's as well as a specific carry.
This makes a total of r+1 items that constitute the size of the state,
rather than r.
</p>


<p><b>Proposed resolution:</b></p>
<p>
We recommend the sentence be corrected to match:
</p>
<blockquote><p>
 The size of the state is r+1.
</p></blockquote>

<p><i>[
Jens:  I plead for "NAD" on the grounds that "size of state" is only
used as an argument for big-O complexity notation, thus
constant factors and additions don't count.
]</i></p>


<p><i>[
Berlin: N1932 adopts the proposed NAD.
]</i></p>







<hr>
<h3><a name="515"></a>515. Random number engine traits</h3>
<p><b>Section:</b> 26.5.1 [rand.synopsis], TR1 5.1.2 [tr.rand.synopsis] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Walter Brown <b>Opened:</b> 2005-07-03  <b>Last modified:</b> 2008-03-13</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.synopsis">issues</a> in [rand.synopsis].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
To accompany the concept of a pseudo-random number engine as defined in Table 17,
we propose and recommend an adjunct template, engine_traits, to be declared in
[tr.rand.synopsis] as:
</p>
<blockquote><pre>template&lt; class PSRE &gt;
class engine_traits;
</pre></blockquote>
<p>
This template's primary purpose would be as an aid to generic programming involving
pseudo-random number engines.  Given only the facilities described in tr1, it would
be very difficult to produce any algorithms involving the notion of a generic engine.
The intent of this proposal is to  provide, via engine_traits&lt;&gt;, sufficient
descriptive information to allow an algorithm to employ a pseudo-random number engine
without regard to its exact type, i.e., as a template parameter.
</p>
<p>
For example, today it is not possible to write an efficient generic function that
requires any specific number of random bits.  More specifically, consider a
cryptographic application that internally needs 256 bits of randomness per call:
</p>
<blockquote><pre>template&lt; class Eng, class InIter, class OutIter &gt;
void crypto( Eng&amp; e, InIter in, OutIter out );
</pre></blockquote>
<p>
Without knowning the number of bits of randomness produced per call to a provided
engine, the algorithm has no means of determining how many times to call the engine.
</p>
<p>
In a new section [tr.rand.eng.traits], we proposed to define the engine_traits
template as: 
</p>
<blockquote><pre>template&lt; class PSRE &gt;
class engine_traits
{
  static  std::size_t  bits_of_randomness = 0u;
  static  std::string  name()  { return "unknown_engine"; }
  // TODO: other traits here
};
</pre></blockquote>
<p>
Further, each engine described in [tr.rand.engine] would be accompanied by a
complete specialization of this new engine_traits template.
</p>



<p><b>Proposed resolution:</b></p>
<p><i>[
Berlin:  Walter: While useful for implementation per TR1, N1932 has no need for this
feature.  Recommend close as NAD.
]</i></p>



<p><b>Rationale:</b></p>
<p>
Recommend NAD,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1932.pdf">N1932</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2111.pdf">N2111</a>
covers this.  Already in WP.
</p>





<hr>
<h3><a name="516"></a>516. Seeding subtract_with_carry_01 using a generator</h3>
<p><b>Section:</b> 26.5.3 [rand.eng], TR1 5.1.4.4 [tr.rand.eng.sub1] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Walter Brown <b>Opened:</b> 2005-07-03  <b>Last modified:</b> 2008-03-13</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.eng">issues</a> in [rand.eng].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Paragraph 6 says:
</p>
<blockquote><p>
... obtained by successive invocations of g, ... 
</p></blockquote>
<p>
We recommend instead:
</p>
<blockquote><p>
... obtained by taking successive invocations of g mod 2**32, ...
</p></blockquote>
<p>
as the context seems to require only 32-bit quantities be used here.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Berlin: N1932 adopts the proposed resultion: see 26.3.3.4/7.  Moved to Ready.
</p>

<p><i>[
Portland:  Subsumed by N2111.
]</i></p>






<hr>
<h3><a name="517"></a>517. Should include name in external representation</h3>
<p><b>Section:</b> X [rand.req], TR1 5.1.1 [tr.rand.req] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Walter Brown <b>Opened:</b> 2005-07-03  <b>Last modified:</b> 2008-03-13</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.req">issues</a> in [rand.req].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The last two rows of Table 16 deal with the i/o requirements of an engine,
specifying that the textual representation of an engine's state,
appropriately formatted, constitute the engine's  external representation.
</p>
<p>
This seems adequate when an engine's type is known.  However, it seems
inadequate in the  context of generic code, where it becomes useful and
perhaps even necessary to determine an engine's type via input.
</p>
<p>
</p>


<p><b>Proposed resolution:</b></p>
<p>
We therefore recommend that, in each of these two rows of Table 16, the
text "textual representation" be expanded so as to read "engine name
followed by the textual representation."
</p>

<p><i>[
Berlin: N1932 considers this NAD. This is a QOI issue.
]</i></p>







<hr>
<h3><a name="523"></a>523. regex case-insensitive character ranges are unimplementable as specified</h3>
<p><b>Section:</b> 28 [re] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Future">NAD Future</a>
 <b>Submitter:</b> Eric Niebler <b>Opened:</b> 2005-07-01  <b>Last modified:</b> 2009-07-15</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#re">issues</a> in [re].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Future">NAD Future</a> status.</p>
<p><b>Discussion:</b></p>
<p>
A problem with TR1 regex is currently being discussed on the Boost 
developers list. It involves the handling of case-insensitive matching 
of character ranges such as [Z-a]. The proper behavior (according to the 
ECMAScript standard) is unimplementable given the current specification 
of the TR1 regex_traits&lt;&gt; class template. John Maddock, the author of 
the TR1 regex proposal, agrees there is a problem. The full discussion 
can be found at http://lists.boost.org/boost/2005/06/28850.php (first 
message copied below). We don't have any recommendations as yet.
</p>
<p>
-- Begin original message --
</p>
<p>
The situation of interest is described in the ECMAScript specification
(ECMA-262), section 15.10.2.15:
</p>
<p>
"Even if the pattern ignores case, the case of the two ends of a range
is significant in determining which characters belong to the range.
Thus, for example, the pattern /[E-F]/i matches only the letters E, F,
e, and f, while the pattern /[E-f]/i matches all upper and lower-case
ASCII letters as well as the symbols [, \, ], ^, _, and `."
</p>
<p>
A more interesting case is what should happen when doing a
case-insentitive match on a range such as [Z-a]. It should match z, Z,
a, A and the symbols [, \, ], ^, _, and `. This is not what happens with
Boost.Regex (it throws an exception from the regex constructor).
</p>
<p>
The tough pill to swallow is that, given the specification in TR1, I
don't think there is any effective way to handle this situation.
According to the spec, case-insensitivity is handled with
regex_traits&lt;&gt;::translate_nocase(CharT) -- two characters are equivalent
if they compare equal after both are sent through the translate_nocase
function. But I don't see any way of using this translation function to
make character ranges case-insensitive. Consider the difficulty of
detecting whether "z" is in the range [Z-a]. Applying the transformation
to "z" has no effect (it is essentially std::tolower). And we're not
allowed to apply the transformation to the ends of the range, because as
ECMA-262 says, "the case of the two ends of a range is significant."
</p>
<p>
So AFAICT, TR1 regex is just broken, as is Boost.Regex. One possible fix
is to redefine translate_nocase to return a string_type containing all
the characters that should compare equal to the specified character. But
this function is hard to implement for Unicode, and it doesn't play nice
with the existing ctype facet. What a mess!
</p>
<p>
-- End original message --
</p>

<p><i>[
John Maddock adds:
]</i></p>


<p>
One small correction, I have since found that ICU's regex package does 
implement this correctly, using a similar mechanism to the current 
TR1.Regex.
</p>
<p>
Given an expression [c1-c2] that is compiled as case insensitive it:
</p>
<p>
Enumerates every character in the range c1 to c2 and converts it to it's 
case folded equivalent.  That case folded character is then used a key to a 
table of equivalence classes, and each member of the class is added to the 
list of possible matches supported by the character-class.  This second step 
isn't possible with our current traits class design, but isn't necessary if 
the input text is also converted to a case-folded equivalent on the fly.
</p>
<p>
ICU applies similar brute force mechanisms to character classes such as 
[[:lower:]] and [[:word:]], however these are at least cached, so the impact 
is less noticeable in this case.
</p>
<p>
Quick and dirty performance comparisons show that expressions such as 
"[X-\\x{fff0}]+" are indeed very slow to compile with ICU (about 200 times 
slower than a "normal" expression).  For an application that uses a lot of 
regexes this could have a noticeable performance impact.  ICU also has an 
advantage in that it knows the range of valid characters codes: code points 
outside that range are assumed not to require enumeration, as they can not 
be part of any equivalence class.  I presume that if we want the TR1.Regex 
to work with arbitrarily large character sets enumeration really does become 
impractical.
</p>
<p>
Finally note that Unicode has:
</p>
<p>
Three cases (upper, lower and title).
One to many, and many to one case transformations.
Character that have context sensitive case translations - for example an 
uppercase sigma has two different lowercase forms  - the form chosen depends 
on context(is it end of a word or not), a caseless match for an upper case 
sigma should match either of the lower case forms, which is why case folding 
is often approximated by tolower(toupper(c)).
</p>
<p>
Probably we need some way to enumerate character equivalence classes, 
including digraphs (either as a result or an input), and some way to tell 
whether the next character pair is a valid digraph in the current locale.
</p>
<p>
Hoping this doesn't make this even more complex that it was already,
</p>

<p><i>[
Portland:  Alisdair: Detect as invalid, throw an exception.
Pete: Possible general problem with case insensitive ranges.
]</i></p>


<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
We agree that this is a problem, but we do not know the answer.
</p>
<p>
We are going to declare this NAD until existing practice leads us in some direction.
</p>
<p>
No objection to NAD Future.
</p>
<p>
Move to NAD Future.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="525"></a>525. type traits definitions not clear</h3>
<p><b>Section:</b> 20.6.4 [meta.unary], TR1 4.5 [tr.meta.unary] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Robert Klarer <b>Opened:</b> 2005-07-11  <b>Last modified:</b> 2008-03-13</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It is not completely clear how the primary type traits deal with
cv-qualified types.  And several of the secondary type traits
seem to be lacking a definition.
</p>

<p><i>[
Berlin:  Howard to provide wording.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
Wording provided in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2028.html">N2028</a>.
A
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2157.html">revision (N2157)</a>
provides more detail for motivation.
</p>


<p><b>Rationale:</b></p>
Solved by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2157.html">revision (N2157)</a>
in the WP.





<hr>
<h3><a name="526"></a>526. Is it undefined if a function in the standard changes in parameters?</h3>
<p><b>Section:</b> 23.2.3 [sequence.reqmts] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Chris Jefferson <b>Opened:</b> 2005-09-14  <b>Last modified:</b> 2008-03-13</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#sequence.reqmts">active issues</a> in [sequence.reqmts].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#sequence.reqmts">issues</a> in [sequence.reqmts].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Problem: There are a number of places in the C++ standard library where
it is possible to write what appear to be sensible ways of calling
functions, but which can cause problems in some (or all)
implementations, as they cause the values given to the function to be
changed in a way not specified in standard (and therefore not coded to
correctly work). These fall into two similar categories.
</p>

<p>
1) Parameters taken by const reference can be changed during execution
of the function
</p>

<p>
Examples:
</p>

<p>
Given std::vector&lt;int&gt; v:
</p>
<p>
v.insert(v.begin(), v[2]);
</p>
<p>
v[2] can be changed by moving elements of vector
</p>


<p>
Given std::list&lt;int&gt; l:
</p>
<p>
l.remove(*l.begin());
</p>
<p>
Will delete the first element, and then continue trying to access it.
This is particularily vicious, as it will appear to work in almost all
cases.
</p>

<p>
2) A range is given which changes during the execution of the function:
Similarly,
</p>

<p>
v.insert(v.begin(), v.begin()+4, v.begin()+6);
</p>

<p>
This kind of problem has been partly covered in some cases. For example
std::copy(first, last, result) states that result cannot be in the range
[first, last). However, does this cover the case where result is a
reverse_iterator built from some iterator in the range [first, last)?
Also, std::copy would still break if result was reverse_iterator(last +
1), yet this is not forbidden by the standard
</p>

<p>
Solution:
</p>

<p>
One option would be to try to more carefully limit the requirements of
each function. There are many functions which would have to be checked.
However as has been shown in the std::copy case, this may be difficult.
A simpler, more global option would be to somewhere insert text similar to:
</p>

<p>
If the execution of any function would change either any values passed
by reference or any value in any range passed to a function in a way not
defined in the definition of that function, the result is undefined.
</p>

<p>
Such code would have to at least cover chapters 23 and 25 (the sections
I read through carefully). I can see no harm on applying it to much of
the rest of the standard.
</p>

<p>
Some existing parts of the standard could be improved to fit with this,
for example the requires for 25.2.1 (Copy) could be adjusted to:
</p>

<p>
Requires: For each non-negative integer n &lt; (last - first), assigning to
*(result + n) must not alter any value in the range [first + n, last).
</p>

<p>
However, this may add excessive complication.
</p>

<p>
One other benefit of clearly introducing this text is that it would
allow a number of small optimisations, such as caching values passed
by const reference.
</p>

<p>
Matt Austern adds that this issue also exists for the <tt>insert</tt> and
<tt>erase</tt> members of the ordered and unordered associative containers.
</p>

<p><i>[
Berlin: Lots of controversey over how this should be solved. Lots of confusion
as to whether we're talking about self referencing iterators or references.
Needs a good survey as to the cases where this matters, for which
implementations, and how expensive it is to fix each case.
]</i></p>




<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>
Recommend NAD.
</p>
<ul>
<li><tt>vector::insert(iter, value)</tt> is required to work because the standard
doesn't give permission for it not to work.</li>
<li><tt>list::remove(value)</tt> is required to work because the standard
doesn't give permission for it not to work.</li>
<li><tt>vector::insert(iter, iter, iter)</tt> is not required to work because
23.2.3 [sequence.reqmts], p4 says so.</li>
<li><tt>copy</tt> has to work, except where 25.3.1 [alg.copy] says
it doesn't have to work.  While a language lawyer can tear this wording apart,
it is felt that the wording is not prone to accidental interpretation.</li>
<li>The current working draft provide exceptions for the unordered associative
containers similar to the containers requirements which exempt the member
template insert functions from self referencing.</li>
</ul>





<hr>
<h3><a name="528"></a>528. <tt>const_iterator</tt> <tt>iterator</tt> issue when they are the same type</h3>
<p><b>Section:</b> 23.5 [unord], TR1 6.3.4 [tr.unord.unord] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Paolo Carlini <b>Opened:</b> 2005-10-12  <b>Last modified:</b> 2008-03-13</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#unord">issues</a> in [unord].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
while implementing the resolution of issue 6.19 I'm noticing the
following: according to 6.3.4.3/2 (and 6.3.4.5/2), for unordered_set and
unordered_multiset:
</p>

<blockquote><p>
    "The iterator and const_iterator types are both const types. It is
unspecified whether they are the same type"
</p></blockquote>

<p>
Now, according to the resolution of 6.19, we have overloads of insert
with hint and erase (single and range) both for iterator and
const_iterator, which, AFAICS, can be meaningful at the same time *only*
if iterator and const_iterator *are* in fact different types.
</p>
<p>
Then, iterator and const_iterator are *required* to be different types?
Or that is an unintended consequence? Maybe the overloads for plain
iterators should be added only to unordered_map and unordered_multimap?
Or, of course, I'm missing something?
</p>



<p><b>Proposed resolution:</b></p>
<p>
Add to 6.3.4.3p2 (and 6.3.4.5p2):
</p>
<p>
2  ... The iterator and const_iterator types are both <del>const</del>
<ins>constant</ins> iterator types.
It is unspecified whether they are the same type. 
</p>

<p>
Add a new subsection to 17.4.4 [lib.conforming]:
</p>

<blockquote>
<p>
An implementation shall not supply an overloaded function
       signature specified in any library clause if such a signature
       would be inherently ambiguous during overload resolution
       due to two library types referring to the same type.
</p>
<p>
       [Note: For example, this occurs when a container's iterator
       and const_iterator types are the same. -- end note]
</p>
</blockquote>

<p><i>[
Post-Berlin: Beman supplied wording.
]</i></p>




<p><b>Rationale:</b></p>
Toronto:  The first issue has been fixed by N2350 (the insert and erase members
are collapsed into one signature).  Alisdair to open a separate issue on the
chapter 17 wording.





<hr>
<h3><a name="529"></a>529. The standard encourages redundant and confusing preconditions</h3>
<p><b>Section:</b> 17.6.3.11 [res.on.required] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> David Abrahams <b>Opened:</b> 2005-10-25  <b>Last modified:</b> 2008-03-13</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
17.4.3.8/1 says:
</p>

<blockquote><p>
Violation of the preconditions specified in a function's 
Required behavior: paragraph results in undefined behavior unless the 
function's Throws: paragraph specifies throwing an exception when the 
precondition is violated.
</p></blockquote>

<p>
This implies that a precondition violation can lead to defined
behavior.  That conflicts with the only reasonable definition of
precondition: that a violation leads to undefined behavior.  Any other
definition muddies the waters when it comes to analyzing program
correctness, because precondition violations may be routinely done in
correct code (e.g. you can use std::vector::at with the full
expectation that you'll get an exception when your index is out of
range, catch the exception, and continue).  Not only is it a bad
example to set, but it encourages needless complication and redundancy
in the standard.  For example:
</p>

<blockquote><pre>  21 Strings library 
  21.3.3 basic_string capacity

  void resize(size_type n, charT c);

  5 Requires: n &lt;= max_size()
  6 Throws: length_error if n &gt; max_size().
  7 Effects: Alters the length of the string designated by *this as follows:
</pre></blockquote>

<p>
The Requires clause is entirely redundant and can be dropped.  We
could make that simplifying change (and many others like it) even
without changing 17.4.3.8/1; the wording there just seems to encourage
the redundant and error-prone Requires: clause.
</p>

<p><i>[
Batavia:  Alan and Pete to work.
]</i></p>


<p><i>[
Bellevue:  NAD Editorial, this group likes 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2121.html">N2121</a>,
Pete agrees, accepting it is Pete's business.
General agreement that precondition violations are synonymous with UB.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
1. Change 17.4.3.8/1 to read:
</p>

<blockquote><p>
Violation of the preconditions specified in a function's
<i>Required behavior:</i> paragraph results in undefined behavior
<del>unless the function's <i>Throws:</i> paragraph specifies throwing
an exception when the precondition is violated</del>.
</p></blockquote>

<p>
2. Go through and remove redundant Requires: clauses.  Specifics to be
   provided by Dave A.
</p>

<p><i>[
Berlin: The LWG requests a detailed survey of part 2 of the proposed resolution.
]</i></p>


<p><i>[
Alan provided the survey
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2121.html">N2121</a>.
]</i></p>







<hr>
<h3><a name="532"></a>532. Tuple comparison</h3>
<p><b>Section:</b> 20.5.2.7 [tuple.rel], TR1 6.1.3.5 [tr.tuple.rel] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Future">NAD Future</a>
 <b>Submitter:</b> David Abrahams <b>Opened:</b> 2005-11-29  <b>Last modified:</b> 2009-10-24</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#tuple.rel">issues</a> in [tuple.rel].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Future">NAD Future</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#348">348</a></p>
<p><b>Discussion:</b></p>
<p>
Where possible, tuple comparison operators &lt;,&lt;=,=&gt;, and &gt; ought to be
defined in terms of std::less rather than operator&lt;, in order to
support comparison of tuples of pointers.  
</p>

<p><i>[
2009-07-28 Reopened by Alisdair.  No longer solved by concepts.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
<p>
If we solve this for <tt>tuple</tt> we would have to solve it for <tt>pair</tt>
algorithms, etc.  It is too late to do that at this time.  Move to NAD Future.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
change 6.1.3.5/5 from:
</p>

<blockquote><p>
  Returns: The result of a lexicographical comparison between t and
  u. The result is defined as: (bool)(get&lt;0&gt;(t) &lt; get&lt;0&gt;(u)) ||
  (!(bool)(get&lt;0&gt;(u) &lt; get&lt;0&gt;(t)) &amp;&amp; ttail &lt; utail), where rtail for
  some tuple r is a tuple containing all but the first element of
  r. For any two zero-length tuples e and f, e &lt; f returns false.
</p></blockquote>

<p>
to:
</p>

<blockquote>
<p>
  Returns: The result of a lexicographical comparison between t and
  u. For any two zero-length tuples e and f, e &lt; f returns false.
  Otherwise, the result is defined as: cmp( get&lt;0&gt;(t), get&lt;0&gt;(u)) ||
  (!cmp(get&lt;0&gt;(u), get&lt;0&gt;(t)) &amp;&amp; ttail &lt; utail), where rtail for some
  tuple r is a tuple containing all but the first element of r, and
  cmp(x,y) is an unspecified function template defined as follows.
</p>
<p>
  Where T is the type of x and U is the type of y:
</p>

<p>
     if T and U are pointer types and T is convertible to U, returns
     less&lt;U&gt;()(x,y)
</p>

<p>
     otherwise, if T and U are pointer types, returns less&lt;T&gt;()(x,y)
</p>

<p>
     otherwise, returns (bool)(x &lt; y)
</p>
</blockquote>

<p><i>[
Berlin: This issue is much bigger than just tuple (pair, containers,
algorithms). Dietmar will survey and work up proposed wording.
]</i></p>




<p><b>Rationale:</b></p>
<p>
Recommend NAD.  This will be fixed with the next revision of concepts.
</p>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2770.pdf">N2770</a>.
</blockquote>





<hr>
<h3><a name="536"></a>536. Container iterator constructor and explicit convertibility</h3>
<p><b>Section:</b> 23.2 [container.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Joaqun M Lpez Muoz <b>Opened:</b> 2005-12-17  <b>Last modified:</b> 2007-04-18</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#container.requirements">active issues</a> in [container.requirements].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#container.requirements">issues</a> in [container.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#589">589</a></p>
<p><b>Discussion:</b></p>
<p>
The iterator constructor X(i,j) for containers as defined in 23.1.1 and
23.2.2 does only require that i and j be input iterators but
nothing is said about their associated value_type. There are three
sensible
options:
</p>
<ol>
<li>iterator's value_type is exactly X::value_type (modulo cv).</li>
<li>iterator's value_type is *implicitly* convertible to X::value_type.</li>
<li>iterator's value_type is *explicitly* convertible to X::value_type.</li>
</ol>
<p>
The issue has practical implications, and stdlib vendors have
taken divergent approaches to it: Dinkumware follows 2,
libstdc++ follows 3.
</p>
<p>
The same problem applies to the definition of insert(p,i,j) for
sequences and insert(i,j) for associative contianers, as well as
assign.
</p>

<p><i>[
The following added by Howard and the example code was originally written by
Dietmar.
]</i></p>

<p>
Valid code below?
</p>

<blockquote><pre>#include &lt;vector&gt; 
#include &lt;iterator&gt; 
#include &lt;iostream&gt; 

struct foo 
{ 
    explicit foo(int) {} 
}; 

int main() 
{ 
    std::vector&lt;int&gt; v_int; 
    std::vector&lt;foo&gt; v_foo1(v_int.begin(), v_int.end()); 
    std::vector&lt;foo&gt; v_foo2((std::istream_iterator&lt;int&gt;(std::cin)), 
                             std::istream_iterator&lt;int&gt;()); 
} 
</pre></blockquote>
<p><i>[
Berlin: Some support, not universal, for respecting the explicit qualifier.
]</i></p>




<p><b>Proposed resolution:</b></p>






<hr>
<h3><a name="544"></a>544. minor NULL problems in C.2</h3>
<p><b>Section:</b> C.2 [diff.library] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2005-11-25  <b>Last modified:</b> 2007-04-24</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#diff.library">issues</a> in [diff.library].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
According to C.2.2.3, p1, "the macro NULL, defined in any of &lt;clocale&gt;,
&lt;cstddef&gt;, &lt;cstdio&gt;, &lt;cstdlib&gt;, &lt;cstring&gt;, &lt;ctime&gt;,
or &lt;cwchar&gt;." This is consistent with the C standard.
</p>
<p>
However, Table 95 in C.2 fails to mention &lt;clocale&gt; and &lt;cstdlib&gt;.
</p>
<p>
In addition, C.2, p2 claims that "The C++ Standard library provides
54 standard macros from the C library, as shown in Table 95." While
table 95 does have 54 entries, since a couple of them (including the
NULL macro) are listed more than once, the actual number of macros
defined by the C++ Standard Library may not be 54.
</p>


<p><b>Proposed resolution:</b></p>
<p>
I propose we add &lt;clocale&gt; and &lt;cstdlib&gt; to Table 96 and remove the
number of macros from C.2, p2 and reword the sentence as follows:
</p>
<blockquote><p>
The C++ Standard library <del>provides 54 standard macros from</del>
<ins>defines a number macros corresponding to those defined by</ins> the C 
<ins>Standard</ins> library, as shown in Table 96.
</p></blockquote>

<p><i>[
Portland:  Resolution is considered editorial.  It will be incorporated into the WD.
]</i></p>







<hr>
<h3><a name="546"></a>546. _Longlong and _ULonglong are integer types</h3>
<p><b>Section:</b> TR1 5.1.1 [tr.rand.req] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2006-01-10  <b>Last modified:</b> 2009-07-15</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The TR sneaks in two new integer types, _Longlong and _Ulonglong, in [tr.c99].
The rest of the TR should use that type.  I believe this affects two places.
First, the random number requirements, 5.1.1/10-11, lists all of the types with
which template parameters named IntType and UIntType may be instantiated.
_Longlong (or "long long", assuming it is added to C++0x) should be added to the
IntType list, and UIntType (again, or "unsigned long long") should be added to
the UIntType list.  Second, 6.3.2 lists the types for which hash&lt;&gt; is
required to be instantiable. _Longlong and _Ulonglong should be added to that
list, so that people may use long long as a hash key.
</p>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
We are not going to fix TR1.
</p>
<p>
The paper "long long goes to the library" addresses the integration of
long long into the C++0x library.
</p>
<p>
Move to NAD.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="547"></a>547. division should be floating-point, not integer</h3>
<p><b>Section:</b> 26.5 [rand], TR1 5.1 [tr.rand] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2006-01-10  <b>Last modified:</b> 2007-04-18</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand">issues</a> in [rand].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Paragraph 10 describes how a variate generator uses numbers produced by an
engine to pass to a generator. The sentence that concerns me is: "Otherwise, if
the value for engine_value_type::result_type is true and the value for
Distribution::input_type is false [i.e. if the engine produces integers and the
engine wants floating-point values], then the numbers in s_eng are divided by
engine().max() - engine().min() + 1 to obtain the numbers in s_e." Since the
engine is producing integers, both the numerator and the denominator are
integers and we'll be doing integer division, which I don't think is what we
want. Shouldn't we be performing a conversion to a floating-point type first?
</p>


<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>
Recommend NAD as the affected section is now gone and so the issue is moot.
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2111.pdf">N2111</a>.
</p>





<hr>
<h3><a name="548"></a>548. May random_device block?</h3>
<p><b>Section:</b> 26.5.6 [rand.device], TR1 5.1.6 [tr.rand.device] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2006-01-10  <b>Last modified:</b> 2007-10-18</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.device">issues</a> in [rand.device].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Class random_device "produces non-deterministic random numbers", using some
external source of entropy. In most real-world systems, the amount of available
entropy is limited. Suppose that entropy has been exhausted. What is an
implementation permitted to do? In particular, is it permitted to block
indefinitely until more random bits are available, or is the implementation
required to detect failure immediately? This is not an academic question. On
Linux a straightforward implementation would read from /dev/random, and "When
the entropy pool is empty, reads to /dev/random will block until additional
environmental noise is gathered." Programmers need to know whether random_device
is permitted to (or possibly even required to?) behave the same way.
</p>

<p><i>[
Berlin: Walter: N1932 considers this NAD. Does the standard specify whether std::cin
may block?
]</i></p>


<p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2391.pdf">N2391</a> and
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2423.pdf">N2423</a>
for some further discussion.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Adopt the proposed resolution in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2423.pdf">N2423</a> (NAD).
</p>





<hr>
<h3><a name="549"></a>549. Undefined variable in binomial_distribution</h3>
<p><b>Section:</b> 26.5.8 [rand.dist], TR1 5.1.7.5 [tr.rand.dist.bin] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2006-01-10  <b>Last modified:</b> 2007-04-24</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.dist">issues</a> in [rand.dist].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Paragraph 1 says that "A binomial distributon random distribution produces
integer values i&gt;0 with p(i) = (n choose i) * p*i * (1-p)^(t-i), where t and
p are the parameters of the distribution. OK, that tells us what t, p, and i
are. What's n?
</p>


<p><b>Proposed resolution:</b></p>
<p>
Berlin: Typo: "n" replaced by "t" in N1932: see 26.3.7.2.2/1.
</p>

<p><i>[
Portland:  Subsumed by N2111.
]</i></p>






<hr>
<h3><a name="553"></a>553. very minor editorial change intptr_t / uintptr_t</h3>
<p><b>Section:</b> 18.4.1 [cstdint.syn], TR1 8.22.1 [tr.c99.cstdint.syn] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Paolo Carlini <b>Opened:</b> 2006-01-30  <b>Last modified:</b> 2007-07-02</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#cstdint.syn">issues</a> in [cstdint.syn].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In the synopsis, some types are identified as optional: int8_t, int16_t,
and so on, consistently with C99, indeed.
</p>
<p>
On the other hand, intptr_t and uintptr_t, are not marked as such and
probably should, consistently with C99, 7.18.1.4.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change 18.4.1 [cstdint.syn]:
</p>

<blockquote><pre>...
typedef <i>signed integer type</i> intptr_t;    <ins><i>// optional</i></ins>
...
typedef <i>unsigned integer type</i> uintptr_t;    <ins><i>// optional</i></ins>
...
</pre></blockquote>



<p><b>Rationale:</b></p>
Recommend NAD and fix as editorial with the proposed resolution.





<hr>
<h3><a name="554"></a>554. Problem with lwg DR 184 numeric_limits&lt;bool&gt;</h3>
<p><b>Section:</b> 18.3.1.5 [numeric.special] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2006-01-29  <b>Last modified:</b> 2007-01-15</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#numeric.special">issues</a> in [numeric.special].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I believe we have a bug in the resolution of:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#184">lwg 184</a>
(WP status).
</p>

<p>
The resolution spells out each member of <tt>numeric_limits&lt;bool&gt;</tt>.
The part I'm having a little trouble with is:
</p>
<blockquote><pre>static const bool traps = false;
</pre></blockquote>

<p>
Should this not be implementation defined?  Given:
</p>

<blockquote><pre>int main()
{
     bool b1 = true;
     bool b2 = false;
     bool b3 = b1/b2;
}
</pre></blockquote>

<p>
If this causes a trap, shouldn't <tt>numeric_limits&lt;bool&gt;::traps</tt> be
<tt>true</tt>?
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change 18.2.1.5p3:
</p>

<blockquote><p>
-3- The specialization for <tt>bool</tt> shall be provided as follows: </p>
<blockquote><pre>namespace std { 
   template &lt;&gt; class numeric_limits&lt;bool&gt; {
      ...
      static const bool traps = <del>false</del> <ins><i>implementation-defined</i></ins>;
      ...
   };
}
</pre></blockquote>
</blockquote>

<p><i>[
Redmond:  NAD because traps refers to values, not operations.  There is no bool
value that will trap.
]</i></p>







<hr>
<h3><a name="555"></a>555. TR1, 8.21/1: typo</h3>
<p><b>Section:</b> TR1 8.21 [tr.c99.boolh] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Paolo Carlini <b>Opened:</b> 2006-02-02  <b>Last modified:</b> 2007-04-24</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
This one, if nobody noticed it yet, seems really editorial:
s/cstbool/cstdbool/
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change 8.21p1:
</p>
<blockquote><p>
-1- The header behaves as if it defines the additional macro defined in
<tt>&lt;cst<ins>d</ins>bool&gt;</tt> by including the header <tt>&lt;cstdbool&gt;</tt>.
</p></blockquote>

<p><i>[
Redmond:  Editorial.
]</i></p>







<hr>
<h3><a name="557"></a>557. TR1: div(_Longlong, _Longlong) vs div(intmax_t, intmax_t)</h3>
<p><b>Section:</b> 18.4 [cstdint], TR1 8.22 [tr.c99.cstdint] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Paolo Carlini <b>Opened:</b> 2006-02-06  <b>Last modified:</b> 2008-07-02</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#cstdint">issues</a> in [cstdint].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I'm seeing a problem with such overloads: when, _Longlong == intmax_t ==
long long we end up, essentially, with the same arguments and different
return types (lldiv_t and imaxdiv_t, respectively). Similar issue with
abs(_Longlong) and abs(intmax_t), of course.
</p>
<p>
Comparing sections 8.25 and 8.11, I see an important difference,
however: 8.25.3 and 8.25.4 carefully describe div and abs for _Longlong
types (rightfully, because not moved over directly from C99), whereas
there is no equivalent in 8.11: the abs and div overloads for intmax_t
types appear only in the synopsis and are not described anywhere, in
particular no mention in 8.11.2 (at variance with 8.25.2).
</p>
<p>
I'm wondering whether we really, really, want div and abs for intmax_t...
</p>



<p><b>Proposed resolution:</b></p>



<p><i>[
Portland: no consensus.
]</i></p>


<p><b>Rationale:</b></p>
<p><i>[
Batavia, Bill: The <tt>&lt;cstdint&gt;</tt> synopsis in TR1 8.11.1 [tr.c99.cinttypes.syn] contains:
]</i></p>

<blockquote><pre>intmax_t imaxabs(intmax_t i);
intmax_t abs(intmax_t i);

imaxdiv_t imaxdiv(intmax_t numer, intmax_t denom);
imaxdiv_t div(intmax_t numer, intmax_t denom);
</pre></blockquote>

<p><i>[
and in TR1 8.11.2 [tr.c99.cinttypes.def]:
]</i></p>


<blockquote><p>
The header defines all functions, types, and macros the same as C99
subclause 7.8.
</p></blockquote>

<p><i>[
This is as much definition as we give for most other C99 functions,
so nothing need change. We might, however, choose to add the footnote:
]</i></p>


<blockquote><p>
[<i>Note:</i> These overloads for <tt>abs</tt> and <tt>div</tt> may well be equivalent to
those that take <tt>long long</tt> arguments. If so, the implementation is
responsible for avoiding conflicting declarations. -- <i>end note</i>]
</p></blockquote>

<p><i>[
Bellevue: NAD Editorial. Pete must add a footnote, as described below.
]</i></p>


<blockquote>
<p><i>[
Looks like a real problem. Dietmar suggests div() return a template
type. Matt: looks like imaxdiv_t is loosly defined. Can it be a typedef
for lldiv_t when _Longlong == intmax_t? PJP seems to agree. We would
need a non-normative note declaring that the types lldiv_t and imaxdiv_t
may not be unique if intmax_t==_longlong.
]</i></p>

</blockquote>






<hr>
<h3><a name="558"></a>558. lib.input.iterators Defect</h3>
<p><b>Section:</b> 24.2.1 [input.iterators] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> David Abrahams <b>Opened:</b> 2006-02-09  <b>Last modified:</b> 2007-04-24</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#input.iterators">issues</a> in [input.iterators].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<blockquote>
<p>
  24.1.1 Input iterators [lib.input.iterators]
</p>
<p>
  1 A class or a built-in type X satisfies the requirements of an
  input iterator for the value type T if the following expressions are
  valid, where U is the type of any specified member of type T, as
  shown in Table 73.
</p>
</blockquote>
<p>
There is no capital U used in table 73.  There is a lowercase u, but
that is clearly not meant to denote a member of type T.  Also, there's
no description in 24.1.1 of what lowercase a means.  IMO the above
should have been...Hah, a and b are already covered in 24.1/11, so maybe it
should have just been:
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change 24.1.1p1:
</p>
<blockquote><p>
-1- A class or a built-in type <tt>X</tt> satisfies the requirements of an
input iterator for the value type <tt>T</tt> if the following expressions 
are valid<del>, where <tt>U</tt> is the type of any specified member of type
<tt>T</tt>,</del> as shown in Table 73.
</p></blockquote>

<p><i>[
Portland: Editorial.
]</i></p>







<hr>
<h3><a name="560"></a>560. User-defined allocators without default constructor</h3>
<p><b>Section:</b> 20.2.2 [allocator.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Sergey P. Derevyago <b>Opened:</b> 2006-02-17  <b>Last modified:</b> 2007-04-18</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#allocator.requirements">issues</a> in [allocator.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<h4>1. The essence of the problem.</h4>
<p>
User-defined allocators without default constructor are not explicitly
supported by the standard but they can be supported just like std::vector
supports elements without default constructor.
</p>
<p>
As a result, there exist implementations that work well with such allocators
and implementations that don't.
</p>

<h4>2. The cause of the problem.</h4>
<p>
1) The standard doesn't explicitly state this intent but it should. In
particular, 20.1.5p5 explicitly state the intent w.r.t. the allocator
instances that compare non-equal. So it can similarly state the intent w.r.t.
the user-defined allocators without default constructor.
</p>
<p>
2) Some container operations are obviously underspecified. In particular,
21.3.7.1p2 tells:
</p>
<blockquote><pre>template&lt;class charT, class traits, class Allocator&gt;
  basic_string&lt;charT,traits,Allocator&gt; operator+(
    const charT* lhs,
    const basic_string&lt;charT,traits,Allocator&gt;&amp; rhs
  );
</pre>
<p>
Returns: <tt>basic_string&lt;charT,traits,Allocator&gt;(lhs) + rhs</tt>.
</p>
</blockquote>
<p>
That leads to the basic_string&lt;charT,traits,Allocator&gt;(lhs, Allocator()) call.
Obviously, the right requirement is:
</p>
<blockquote><p>
Returns: <tt>basic_string&lt;charT,traits,Allocator&gt;(lhs, rhs.get_allocator()) + rhs</tt>.
</p></blockquote>
<p>
It seems like a lot of DRs can be submitted on this "Absent call to
get_allocator()" topic.
</p>

<h4>3. Proposed actions.</h4>
<p>
1) Explicitly state the intent to allow for user-defined allocators without
default constructor in 20.1.5 Allocator requirements.
</p>
<p>
2) Correct all the places, where a correct allocator object is available
through the get_allocator() call but default Allocator() gets passed instead.
</p>
<h4>4. Code sample.</h4>
<p>
Let's suppose that the following memory pool is available:
</p>
<blockquote><pre>class mem_pool {
      // ...
      void* allocate(size_t size);
      void deallocate(void* ptr, size_t size);
};
</pre></blockquote>
<p>
So the following allocator can be implemented via this pool:
</p>
<blockquote><pre>class stl_allocator {
      mem_pool&amp; pool;

 public:
      explicit stl_allocator(mem_pool&amp; mp) : pool(mp) {}
      stl_allocator(const stl_allocator&amp; sa) : pool(sa.pool) {}
      template &lt;class U&gt;
      stl_allocator(const stl_allocator&lt;U&gt;&amp; sa)  : pool(sa.get_pool()) {}
      ~stl_allocator() {}

      pointer allocate(size_type n, std::allocator&lt;void&gt;::const_pointer = 0)
      {
       return (n!=0) ? static_cast&lt;pointer&gt;(pool.allocate(n*sizeof(T))) : 0;
      }

      void deallocate(pointer p, size_type n)
      {
       if (n!=0) pool.deallocate(p, n*sizeof(T));
      }

      // ...
};
</pre></blockquote>
<p>
Then the following code works well on some implementations and doesn't work on
another:
</p>
<blockquote><pre>typedef basic_string&lt;char, char_traits&lt;char&gt;, stl_allocator&lt;char&gt; &gt; 
  tl_string;
mem_pool mp;
tl_string s1("abc", stl_allocator&lt;int&gt;(mp));
printf("(%s)\n", ("def"+s1).c_str());
</pre></blockquote>
<p>
In particular, on some implementations the code can't be compiled without
default stl_allocator() constructor.
</p>
<p>
The obvious way to solve the compile-time problems is to intentionally define
a NULL pointer dereferencing default constructor
</p>
<blockquote><pre>stl_allocator() : pool(*static_cast&lt;mem_pool*&gt;(0)) {}
</pre></blockquote>
<p>
in a hope that it will not be called. The problem is that it really gets
called by operator+(const char*, const string&amp;) under the current 21.3.7.1p2
wording.
</p>


<p><b>Proposed resolution:</b></p>
<p>
</p>


<p><b>Rationale:</b></p>
<p>
Recommend NAD.  <tt>operator+()</tt> with <tt>string</tt> already requires the desired
semantics of copying the allocator from one of the strings (<i>lhs</i> when there is a choice).
</p>





<hr>
<h3><a name="568"></a>568. log2 overloads missing</h3>
<p><b>Section:</b> TR1 8.16.4 [tr.c99.cmath.over] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Paolo Carlini <b>Opened:</b> 2006-03-07  <b>Last modified:</b> 2009-07-13</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>log2</tt> is missing from the list of "additional overloads" in TR1 8.16.4 [tr.c99.cmath.over] p1.
</p>

<p>
Hinnant:  This is a TR1 issue only.  It is fixed in the current (N2135) WD.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree this has been fixed in the Working Draft.
Move to NAD.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Add <tt>log2</tt> to the list of functions in TR1 8.16.4 [tr.c99.cmath.over] p1.
</p>





<hr>
<h3><a name="569"></a>569. Postcondition for basic_ios::clear(iostate) incorrectly stated</h3>
<p><b>Section:</b> 27.5.4.3 [iostate.flags] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Seungbeom Kim <b>Opened:</b> 2006-03-10  <b>Last modified:</b> 2006-12-30</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#iostate.flags">issues</a> in [iostate.flags].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#272">272</a></p>
<p><b>Discussion:</b></p>
<p>
Section: 27.4.4.3 [lib.iostate.flags]
</p>
<p>
Paragraph 4 says:
</p>
<blockquote>
<blockquote><pre>void clear(iostate <i>state</i> = goodbit);
</pre></blockquote>
<p>
<i>Postcondition:</i> If <tt>rdbuf()!=0</tt> then <tt><i>state</i> == rdstate();</tt>
otherwise <tt>rdstate()==<i>state</i>|ios_base::badbit</tt>.
</p>
</blockquote>

<p>
The postcondition "rdstate()==state|ios_base::badbit" is parsed as
"(rdstate()==state)|ios_base::badbit", which is probably what the
committee meant.
</p>




<p><b>Rationale:</b></p>






<hr>
<h3><a name="570"></a>570. Request adding additional explicit specializations of char_traits</h3>
<p><b>Section:</b> 21.2 [char.traits] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Jack Reeves <b>Opened:</b> 2006-04-06  <b>Last modified:</b> 2008-06-18</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#char.traits">issues</a> in [char.traits].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently, the Standard Library specifies only a declaration for template class
char_traits&lt;&gt; and requires the implementation provide two explicit
specializations: char_traits&lt;char&gt; and char_traits&lt;wchar_t&gt;. I feel the Standard
should require explicit specializations for all built-in character types, i.e.
char, wchar_t, unsigned char, and signed char.
</p>
<p>
I have put together a paper
(<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1985.htm">N1985</a>)
that describes this in more detail and
includes all the necessary wording.
</p>
<p><i>[
Portland: Jack will rewrite
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1985.htm">N1985</a>
to propose a primary template that will work with other integral types.
]</i></p>

<p><i>[
Toronto: issue has grown with addition of <tt>char16_t</tt> and <tt>char32_t</tt>.
]</i></p>


<p><i>[
post Bellevue:
]</i></p>


<blockquote>
<p>
We suggest that Jack be asked about the status of his paper, and if it
is not forthcoming, the work-item be assigned to someone else. If no one
steps forward to do the paper before the next meeting, we propose to
make this NAD without further discussion. We leave this Open for now,
but our recommendation is NAD.
</p>
<p>
Note: the issue statement should be updated, as the Toronto comment has
already been resolved. E.g., char_traits specializations for char16_t
and char32_t are now in the working paper.
</p>
</blockquote>

<p><i>[
Sophia Antipolis:
]</i></p>


<blockquote>
Nobody has submitted the requested paper, so we move to NAD, as suggested by the decision at the last meeting.
</blockquote>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="571"></a>571. Update C90 references to C99?</h3>
<p><b>Section:</b> 1.2 [intro.refs] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Beman Dawes <b>Opened:</b> 2006-04-08  <b>Last modified:</b> 2007-07-02</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#intro.refs">issues</a> in [intro.refs].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
1.2 Normative references [intro.refs] of the WP currently refers to ISO/IEC
9899:1990, Programming languages - C. Should that be changed to ISO/IEC
9899:1999?
</p>
<p>
What impact does this have on the library?
</p>


<p><b>Proposed resolution:</b></p>
<p>
In 1.2/1 [intro.refs] of the WP, change:
</p>
<blockquote>
<ul>
<li>ISO/IEC 9899:<del>1990</del><ins>1999 + TC1 + TC2</ins>, <i>Programming languages - C</i></li>
</ul>
</blockquote>



<p><b>Rationale:</b></p>
Recommend NAD, fixed editorially.





<hr>
<h3><a name="572"></a>572. Oops, we gave 507 WP status</h3>
<p><b>Section:</b> 26.5 [rand], TR1 5.1 [tr.rand] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2006-04-11  <b>Last modified:</b> 2007-04-18</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand">issues</a> in [rand].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In Berlin, as a working group, we voted in favor of N1932 which makes issue 507 moot:
variate_generator has been eliminated.  Then in full committee we voted to give
this issue WP status (mistakenly).
</p>


<p><b>Proposed resolution:</b></p>
<p>
Strike the proposed resolution of issue 507.
</p>
<p><i>[
post-Portland:  Walter and Howard recommend NAD.  The proposed resolution of 507 no longer
exists in the current WD.
]</i></p>



<p><b>Rationale:</b></p>
<p>
NAD.  Will be moot once
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2135.pdf">N2135</a>
is adopted.
</p>





<hr>
<h3><a name="573"></a>573. C++0x file positioning should handle modern file sizes</h3>
<p><b>Section:</b> 27.5.3 [fpos] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Beman Dawes <b>Opened:</b> 2006-04-12  <b>Last modified:</b> 2009-07-15</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#fpos">issues</a> in [fpos].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There are two deficiencies related to file sizes:
</p>
<ol>
<li>It doesn't appear that the Standard Library is specified in
      a way that handles modern file sizes, which are often too
      large to be represented by an unsigned long.</li>

<li>The std::fpos class does not currently have the ability to
      set/get file positions.</li>
</ol>
<p>
The Dinkumware implementation of the Standard Library as shipped with the Microsoft compiler copes with these issues by:
</p>
<ol type="A">
<li>Defining fpos_t be long long, which is large enough to
      represent any file position likely in the foreseeable future.</li>

<li>Adding member functions to class fpos. For example,
<blockquote><pre>fpos_t seekpos() const;
</pre></blockquote>
</li>
</ol>
<p>
Because there are so many types relating to file positions and offsets (fpos_t,
fpos, pos_type, off_type, streamoff, streamsize, streampos, wstreampos, and
perhaps more), it is difficult to know if the Dinkumware extensions are
sufficient. But they seem a useful starting place for discussions, and they do
represent existing practice.
</p>

<p><i>[
Kona (2007): We need a paper. It would be nice if someone proposed
clarifications to the definitions of <tt>pos_type</tt> and <tt>off_type</tt>. Currently
these definitions are horrible. Proposed Disposition: Open
]</i></p>


<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
This is the subject of paper N2926.
</p>
<p>
If we choose to take any action, we will move the paper, so the issue can be closed.
</p>
<p>
Move to NAD.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="579"></a>579. erase(iterator) for unordered containers should not return an iterator</h3>
<p><b>Section:</b> 23.2.5 [unord.req] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Joaqun M Lpez Muoz <b>Opened:</b> 2006-06-13  <b>Last modified:</b> 2008-03-12</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#unord.req">active issues</a> in [unord.req].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#unord.req">issues</a> in [unord.req].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
See
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2023.pdf">N2023</a>
for full discussion.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Option 1:
</p>

<p>
The problem can be eliminated by omitting the requirement that <tt>a.erase(q)</tt> return an 
iterator. This is, however, in contrast with the equivalent requirements for other 
standard containers.
</p>

<p>
Option 2:
</p>

<p>
<tt>a.erase(q)</tt> can be made to compute the next iterator only when explicitly requested: 
the technique consists in returning a proxy object implicitly convertible to <tt>iterator</tt>, so 
that
</p>

<blockquote><pre>iterator q1=a.erase(q);
</pre></blockquote>

<p>
works as expected, while
</p>

<blockquote><pre>a.erase(q);
</pre></blockquote>

<p>
does not ever invoke the conversion-to-iterator operator, thus avoiding the associated 
computation. To allow this technique, some sections of TR1 along the line "return value 
is an iterator..." should be changed to "return value is an unspecified object implicitly 
convertible to an iterator..." Although this trick is expected to work transparently, it can 
have some collateral effects when the expression <tt>a.erase(q)</tt> is used inside generic 
code.
</p>



<p><b>Rationale:</b></p>
<p>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2023.pdf">N2023</a>
was discussed in Portland and the consensus was that there appears to be
no need for either change proposed in the paper.  The consensus opinion
was that since the iterator could serve as its own proxy, there appears
to be no need for the change. In general, "converts to" is undesirable
because it interferes with template matching.
</p>

<p>
Post Toronto:  There does not at this time appear to be consensus with the Portland consensus. 
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
The Bellevue review of this issue reached consensus with the Portland
consensus, in contravention of the Toronto non-consensus. Common
implementations have the iterator readily available, and most common
uses depend on the iterator being returned.
</blockquote>






<hr>
<h3><a name="580"></a>580. unused allocator members</h3>
<p><b>Section:</b> 23.2.1 [container.requirements.general] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2006-06-14  <b>Last modified:</b> 2009-10-26</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#container.requirements.general">active issues</a> in [container.requirements.general].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#container.requirements.general">issues</a> in [container.requirements.general].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#479">479</a></p>
<p><b>Discussion:</b></p>
        <p>

C++ Standard Library  templates that take an allocator  as an argument
are    required    to    call    the    <code>allocate()</code>    and
<code>deallocate()</code>  members of the  allocator object  to obtain
storage.  However, they do not appear to be required to call any other
allocator      members      such     as      <code>construct()</code>,
<code>destroy()</code>,           <code>address()</code>,          and
<code>max_size()</code>.  This makes these allocator members less than
useful in portable programs.

        </p>
        <p>

It's unclear to me whether the absence of the requirement to use these
allocator  members  is  an  unintentional  omission  or  a  deliberate
choice. However,  since the functions exist in  the standard allocator
and  since  they are  required  to  be  provided by  any  user-defined
allocator I  believe the standard  ought to be clarified  to explictly
specify  whether programs  should or  should not  be able  to  rely on
standard containers calling the functions.

        </p>
        <p>

I  propose  that all  containers  be required  to  make  use of  these
functions.

        </p>
<p><i>[
Batavia:  We support this resolution.  Martin to provide wording.
]</i></p>

<p><i>[
pre-Oxford:  Martin provided wording.
]</i></p>


<p><i>[
2009-04-28 Pablo adds:
]</i></p>


<blockquote>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2554.pdf">N2554</a>
(scoped allocators),
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2768.pdf">N2768</a>
(allocator concepts), and
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2810.pdf">N2810</a>
(allocator defects), address all of these points EXCEPT <tt>max_size()</tt>.
So, I would add a note to that affect and re-class the defect as belonging
to section 23.2.1 [container.requirements.general].
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
The comment in the description of this issue that this "would be"
rendered editorial by the adoption of N2257 is confusing. It appears
that N2257 was never adopted.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD Editorial.  Addressed by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2982.pdf">N2982</a>.
</blockquote>



    <p><b>Proposed resolution:</b></p>
       <p>

Specifically, I propose to change 23.2 [container.requirements],
p9 as follows:

       </p>
           <blockquote>
<p>
-9- Copy constructors  for all container types defined  in this clause
<ins>that   are  parametrized  on   <code>Allocator</code></ins>  copy
<del>an</del><ins>the</ins>  allocator argument from  their respective
first parameters.

All other  constructors for  these container types  take a<del>n</del>
<ins>const</ins>  <code>Allocator&amp;</code>  argument  (20.1.6),  an
allocator whose <code>value_type</code> is the same as the container's
<code>value_type</code>.

A copy of this  argument <del>is</del><ins>shall be</ins> used for any
memory  allocation <ins> and  deallocation</ins> performed<del>,</del>
by these  constructors and by all  member functions<del>,</del> during
the  lifetime  of each  container  object.   <ins>Allocation shall  be
performed  "as  if"  by  calling  the  <code>allocate()</code>  member
function on  a copy  of the allocator  object of the  appropriate type
<sup>New  Footnote)</sup>,   and  deallocation  "as   if"  by  calling
<code>deallocate()</code> on  a copy of  the same allocator  object of
the corresponding type.</ins>

<ins>A  copy of  this argument  shall also  be used  to  construct and
destroy objects whose lifetime  is managed by the container, including
but not  limited to those of  the container's <code>value_type</code>,
and  to  obtain  their  address.   All  objects  residing  in  storage
allocated by a  container's allocator shall be constructed  "as if" by
calling the <code>construct()</code> member  function on a copy of the
allocator object of  the appropriate type.  The same  objects shall be
destroyed "as if"  by calling <code>destroy()</code> on a  copy of the
same allocator object  of the same type.  The  address of such objects
shall be obtained "as if" by calling the <code>address()</code> member
function  on  a  copy  of  the allocator  object  of  the  appropriate
type.</ins>

<ins>Finally, a copy  of this argument shall be  used by its container
object to determine  the maximum number of objects  of the container's
<code>value_type</code> the container may  store at the same time. The
container  member function <code>max_size()</code> obtains  this number
from      the      value      returned      by     a      call      to
<code>get_allocator().max_size()</code>.</ins>

In   all  container   types  defined   in  this   clause <ins>that  are
parametrized     on    <code>Allocator</code></ins>,     the    member
<code>get_allocator()</code>     returns     a     copy     of     the
<code>Allocator</code>     object     used     to    construct     the
container.<sup>258)</sup>
</p>
<p>
New Footnote: This type  may be different from <code>Allocator</code>:
it     may    be     derived    from     <code>Allocator</code>    via
<code>Allocator::rebind&lt;U&gt;::other</code>   for  the  appropriate
type <code>U</code>.
</p>
           </blockquote>
       <p>

The proposed wording seems cumbersome but I couldn't think of a better
way   to  describe   the   requirement  that   containers  use   their
<code>Allocator</code>  to manage  only objects  (regardless  of their
type)  that  persist  over  their  lifetimes  and  not,  for  example,
temporaries  created on the  stack. That  is, containers  shouldn't be
required  to  call  <code>Allocator::construct(Allocator::allocate(1),
elem)</code>  just to  construct a  temporary copy  of an  element, or
<code>Allocator::destroy(Allocator::address(temp),     1)</code>    to
destroy temporaries.

       </p>


<p><i>[
Howard: This same paragraph will need some work to accommodate <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#431">431</a>.
]</i></p>


<p><i>[
post Oxford:  This would be rendered NAD Editorial by acceptance of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2257.html">N2257</a>.
]</i></p>





<hr>
<h3><a name="582"></a>582. specialized algorithms and volatile storage</h3>
<p><b>Section:</b> 20.8.13.2 [uninitialized.copy] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2006-06-14  <b>Last modified:</b> 2009-07-15</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#uninitialized.copy">issues</a> in [uninitialized.copy].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p>Related to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1029">1029</a></p>
        <p>

The specialized  algorithms [lib.specialized.algorithms] are specified
as having the general effect of invoking the following expression:

        </p>
            <pre>
new (static_cast&lt;void*&gt;(&amp;*i))
    typename iterator_traits&lt;ForwardIterator&gt;::value_type (x)

            </pre>
        <p>

This  expression is  ill-formed  when the  type  of the  subexpression
<code>&amp;*i</code> is some volatile-qualified <code>T</code>.

        </p>

<p><i>[
Batavia:  Lack of support for proposed resolution but agree there is a
defect.  Howard to look at wording.  Concern that move semantics
properly expressed if iterator returns rvalue.
]</i></p>



<p><i>[
2009-06-17 Pablo adds:
]</i></p>


<blockquote>

<p>Propose that Issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#582">582</a> be closed NAD.</p>
<p>
Issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#582">582</a> asks that <tt>uninitialized_copy</tt>,
<tt>uninitialized_fill</tt>, and <tt>uninitialized_fill_n</tt> should be
well-formed if the result type is volatile.  My feeling is that the
standard does not, and should not, guarantee any useful behavior when
constructors are invoked on volatile storage, so making it syntactically
legal to call <tt>uninitialized_copy</tt> on volatile storage is not useful. A
possible editorial change would be to put my previous sentence into a
non-normative note.
</p>
<p>
Note that the three sections starting with 20.8.13.2 [uninitialized.copy] do not
yet have concepts.  Here's a first crack at the first one:
</p>
<blockquote><pre>template &lt;InputIterator InIter, OutputIterator OutIter&gt;
requires ExplicitConvertible&lt;HasDereference&lt;OutIter::reference&gt;::result,
                             OutIter::value_type&amp;&gt;
      &amp;&amp; Convertible&lt;OutIter::value_type*, void*&gt;
      &amp;&amp; ExplicitConvertible&lt;OutIter::value_type, InIter::reference&gt;
  OutIter uninitialized_copy(InIter first, InIter last, OutIter result);
</pre>
<blockquote>
<p>
Effects:
</p>
<blockquote><pre>while (first != last) {
  typedef OutIter::value_type value_type;
  value_type&amp; outRef = static_cast&lt;value_type&amp;&gt;(*result++);
  ::new (static_cast&lt;void*&gt;(addressof(outRef))) value_type(*first++);
}
</pre></blockquote>
</blockquote>

</blockquote>

<p>
Notes:
</p>
<ol>
<li>This definition is actually LESS constrained than in C++03 because
there is no requirement that the result be a forward iterator.
</li>
<li>
If
OutIter returns a proxy type with an overloaded operator&amp;, this
definition probably won't compile.  Lifting this limitation while
allowing value_type to have an overloaded operator&amp; would be hard, but
is probably possible with careful overloading.  I'm not sure it's worth
it.
</li>
<li>
This definition retains the prohibition on the use of volatile types for the result.
</li>
</ol>

</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
We don't deal with volatile in the library.
</p>
<p>
Jim: should we state that explicitly somewhere?
</p>
<p>
Beman: you might argue that clause 17 should say something about
volatile. However, if you want to raise we argument, we should open it
as a separate issue and consult with experts on concurrency.
</p>
<p>
Hinnant: actually, some library components do handle volatile, so we'd
need to be very careful about what we say in clause 17.
</p>
<p>
No objection to NAD.
</p>
<p>
Move to NAD.
</p>
</blockquote>

    

    <p><b>Proposed resolution:</b></p>
        <p>

In order  to allow these algorithms  to operate on  volatile storage I
propose to change the expression so as to make it well-formed even for
pointers  to volatile  types.  Specifically,  I propose  the following
changes to clauses 20 and 24. Change 20.6.4.1, p1 to read:

        </p>
            <pre>
<i>Effects</i>:

typedef typename iterator_traits&lt;ForwardIterator&gt;::pointer    pointer;
typedef typename iterator_traits&lt;ForwardIterator&gt;::value_type value_type;

for (; first != last; ++result, ++first)
    new (static_cast&lt;void*&gt;(const_cast&lt;pointer&gt;(&amp;*result))
        value_type (*first);

            </pre>
        <p>

change 20.6.4.2, p1 to read

        </p>
            <pre>
<i>Effects</i>:

typedef typename iterator_traits&lt;ForwardIterator&gt;::pointer    pointer;
typedef typename iterator_traits&lt;ForwardIterator&gt;::value_type value_type;

for (; first != last; ++result, ++first)
    new (static_cast&lt;void*&gt;(const_cast&lt;pointer&gt;(&amp;*first))
        value_type (*x);

            </pre>
        <p>

and change 20.6.4.3, p1 to read

        </p>
            <pre>
<i>Effects</i>:

typedef typename iterator_traits&lt;ForwardIterator&gt;::pointer    pointer;
typedef typename iterator_traits&lt;ForwardIterator&gt;::value_type value_type;

for (; n--; ++first)
    new (static_cast&lt;void*&gt;(const_cast&lt;pointer&gt;(&amp;*first))
        value_type (*x);

            </pre>
        <p>

In   addition,  since   there   is  no   partial  specialization   for
<code>iterator_traits&lt;volatile T*&gt;</code>  I propose to  add one
to parallel such specialization  for &lt;const T*&gt;. Specifically, I
propose to add the following text to the end of 24.3.1, p3:

        </p>
        <p>

and for pointers to volatile as 

        </p>
            <pre>
namespace std {
template&lt;class T&gt; struct iterator_traits&lt;volatile T*&gt; {
typedef ptrdiff_t difference_type;
typedef T value_type;
typedef volatile T* pointer;
typedef volatile T&amp; reference;
typedef random_access_iterator_tag iterator_category;
};
}

            </pre>
        <p>

Note that  the change to  <code>iterator_traits</code> isn't necessary
in order to implement the  specialized algorithms in a way that allows
them to operate on volatile  strorage. It is only necesassary in order
to specify  their effects in terms  of <code>iterator_traits</code> as
is  done here.   Implementations can  (and some  do) achieve  the same
effect by means of function template overloading.

        </p>
    



<hr>
<h3><a name="583"></a>583. div() for unsigned integral types</h3>
<p><b>Section:</b> 26.8 [c.math] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Beman Dawes <b>Opened:</b> 2006-06-15  <b>Last modified:</b> 2007-07-25</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#c.math">issues</a> in [c.math].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There is no div() function for unsigned integer types.
</p>
<p>
There are several possible resolutions.  The simplest one is noted below.  Other
possibilities include a templated solution.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add to 26.7 [lib.c.math] paragraph 8:
</p>

<blockquote><pre>struct udiv_t div(unsigned, unsigned);
struct uldiv_t div(unsigned long, unsigned long);
struct ulldiv_t div(unsigned long long, unsigned long long);
</pre></blockquote>



<p><b>Rationale:</b></p>
Toronto:  C99 does not have these unsigned versions because
the signed version exist just to define the implementation-defined behavior
of signed integer division.  Unsigned integer division has no implementation-defined
behavior and thus does not need this treatment.





<hr>
<h3><a name="584"></a>584. missing int pow(int,int) functionality</h3>
<p><b>Section:</b> 26.8 [c.math] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Beman Dawes <b>Opened:</b> 2006-06-15  <b>Last modified:</b> 2007-07-25</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#c.math">issues</a> in [c.math].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There is no pow() function for any integral type.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add something like:
</p>

<blockquote><pre>template&lt; typename T&gt;
T power( T x, int n );
// requires: n &gt;=0
</pre></blockquote>


<p><b>Rationale:</b></p>
Toronto:  We already have double pow(integral, integral) from 26.8 [c.math] p11.





<hr>
<h3><a name="585"></a>585. facet error reporting</h3>
<p><b>Section:</b> 22.4 [locale.categories] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Martin Sebor, Paolo Carlini <b>Opened:</b> 2006-06-22  <b>Last modified:</b> 2009-07-15</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.categories">issues</a> in [locale.categories].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
        <p>

Section  22.2, paragraph 2  requires facet  <code>get()</code> members
that    take    an    <code>ios_base::iostate&amp;</code>    argument,
<code><i>err</i></code>,  to   ignore  the  (initial)   value  of  the
argument, but to set it to <code>ios_base::failbit</code> in case of a
parse error.

        </p>
        <p>

We  believe  there  are  a   few  minor  problems  with  this  blanket
requirement  in   conjunction  with   the  wording  specific   to  each
<code>get()</code> member function.

        </p>
        <p>

First,  besides <code>get()</code>  there are  other  member functions
with     a      slightly     different     name      (for     example,
<code>get_date()</code>). It's not completely clear that the intent of
the  paragraph  is  to  include  those  as  well,  and  at  least  one
implementation has interpreted the requirement literally.

        </p>
        <p>

Second,    the     requirement    to    "set     the    argument    to
<code>ios_base::failbit</code>  suggests that  the  functions are  not
permitted    to   set    it   to    any   other    value    (such   as
<code>ios_base::eofbit</code>,   or   even  <code>ios_base::eofbit   |
ios_base::failbit</code>).

        </p>
        <p>

However, 22.2.2.1.2, p5 (Stage  3 of <code>num_get</code> parsing) and
p6 (<code>bool</code> parsing)  specifies that the <code>do_get</code>
functions  perform <code><i>err</i> |=  ios_base::eofbit</code>, which
contradicts  the earlier  requirement to  ignore  <i>err</i>'s initial
value.

        </p>
        <p>

22.2.6.1.2,  p1  (the  Effects  clause of  the  <code>money_get</code>
facet's  <code>do_get</code>  member  functions) also  specifies  that
<code><i>err</i></code>'s initial  value be used to  compute the final
value  by  ORing  it  with  either  <code>ios_base::failbit</code>  or
with<code>ios_base::eofbit | ios_base::failbit</code>.

        </p>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
Move to NAD.
</blockquote>

    

    <p><b>Proposed resolution:</b></p>
        <p>

We believe the  intent is for all facet member  functions that take an
<code>ios_base::iostate&amp;</code> argument to:

        </p>
            <ul>
                <li>

ignore the initial value of the <code><i>err</i></code> argument,

                </li>
                <li>

reset <code><i>err</i></code>  to <code>ios_base::goodbit</code> prior
to any further processing,

                </li>
                <li>

and       set      either       <code>ios_base::eofbit</code>,      or
<code>ios_base::failbit</code>, or both in <code><i>err</i></code>, as
appropriate,  in response  to  reaching the  end-of-file  or on  parse
error, or both.

                </li>
            </ul>
        <p>

To that effect we propose to change 22.2, p2 as follows:

        </p>
        <p>

The  <i>put</i><del>()</del>  members  make  no  provision  for  error
reporting.   (Any  failures of  the  OutputIterator  argument must  be
extracted   from  the   returned  iterator.)    <ins>Unless  otherwise
specified, </ins>the <i>get</i><del>()</del>  members  <ins>that</ins>
take an  <code>ios_base::iostate&amp;</code> argument <del>whose value
they  ignore,  but  set  to  ios_base::failbit  in  case  of  a  parse
error.</del><ins>,   <code><i>err</i></code>,   start  by   evaluating
<code>err  =   ios_base::goodbit</code>,  and  may   subsequently  set
<i>err</i>     to     either     <code>ios_base::eofbit</code>,     or
<code>ios_base::failbit</code>,     or     <code>ios_base::eofbit    |
ios_base::failbit</code> in response to reaching the end-of-file or in
case of a parse error, or both, respectively.</ins>

        </p>
    
    
<p><i>[
Kona (2007): We need to change the proposed wording to clarify that the
phrase "the get members" actually denotes <tt>get()</tt>, <tt>get_date()</tt>, etc.
Proposed Disposition: Open
]</i></p>




<hr>
<h3><a name="587"></a>587. iststream ctor missing description</h3>
<p><b>Section:</b> D.8.2.1 [depr.istrstream.cons] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2006-06-22  <b>Last modified:</b> 2007-05-11</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
        <p>

The  <code>iststream(char*, streamsize)</code>  ctor is  in  the class
synopsis  in D.7.2  but its  signature is  missing in  the description
below (in D.7.2.1).

        </p>
    

    <p><b>Proposed resolution:</b></p>
        <p>

This seems like a simple editorial issue and the missing signature can
be added to the one for <code>const char*</code> in paragraph 2.

        </p>

<p><i>[
post Oxford: Noted that it is already fixed in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2284.pdf">N2284</a>
]</i></p>


    



<hr>
<h3><a name="588"></a>588. requirements on zero sized tr1::arrays and other details</h3>
<p><b>Section:</b> 23.3.1 [array] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Gennaro Prota <b>Opened:</b> 2006-07-18  <b>Last modified:</b> 2009-10-20</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#array">issues</a> in [array].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The wording used for section 23.2.1 [lib.array] seems to be subtly
ambiguous about zero sized arrays (N==0). Specifically:
</p>
<p>
* "An instance of array&lt;T, N&gt; stores N elements of type T, so that
[...]"
</p>
<p>
Does this imply that a zero sized array object stores 0 elements, i.e.
that it cannot store any element of type T? The next point clarifies
the rationale behind this question, basically how to implement begin()
and end():
</p>
<p>
* 23.2.1.5 [lib.array.zero], p2: "In the case that N == 0, begin() ==
end() == unique value."
</p>
<p>
What does "unique" mean in this context? Let's consider the following
possible implementations, all relying on a partial specialization:
</p>
<blockquote><pre>a)
    template&lt; typename T &gt;
    class array&lt; T, 0 &gt; {
    
        ....

        iterator begin()
        { return iterator( reinterpret_cast&lt; T * &gt;( this ) ); }
        ....

    };
</pre></blockquote>
<p>
This has been used in boost, probably intending that the return value
had to be unique to the specific array object and that array couldn't
store any T. Note that, besides relying on a reinterpret_cast, has
(more than potential) alignment problems.
</p>
<blockquote><pre>b)
    template&lt; typename T &gt;
    class array&lt; T, 0 &gt; {
    
        T t;

        iterator begin()
        { return iterator( &amp;t ); }
        ....

    };
</pre></blockquote>
<p>
This provides a value which is unique to the object and to the type of
the array, but requires storing a T. Also, it would allow the user to
mistakenly provide an initializer list with one element.
</p>
<p>
A slight variant could be returning *the* null pointer of type T
</p>
<blockquote><pre>    return static_cast&lt;T*&gt;(0);
</pre></blockquote>
<p>
In this case the value would be unique to the type array&lt;T, 0&gt; but not
to the objects (all objects of type array&lt;T, 0&gt; with the same value
for T would yield the same pointer value).
</p>
<p>
Furthermore this is inconsistent with what the standard requires from
allocation functions (see library issue 9).
</p>
<p>
c) same as above but with t being a static data member; again, the
value would be unique to the type, not to the object.
</p>
<p>
d) to avoid storing a T *directly* while disallowing the possibility
to use a one-element initializer list a non-aggregate nested class
could be defined
</p>
<blockquote><pre>    struct holder { holder() {} T t; } h;
</pre></blockquote>
<p>
and then begin be defined as
</p>
<blockquote><pre> iterator begin() { return &amp;h.t; }
</pre></blockquote>
<p>
But then, it's arguable whether the array stores a T or not.
Indirectly it does.
</p>
<p>
-----------------------------------------------------
</p>
<p>
Now, on different issues:
</p>
<p>
* what's the effect of calling assign(T&amp;) on a zero-sized array? There
seems to be only mention of front() and back(), in 23.2.1 [lib.array]
p4 (I would also suggest to move that bullet to section 23.2.1.5
[lib.array.zero], for locality of reference)
</p>
<p>
* (minor) the opening paragraph of 23.2.1 [lib.array] wording is a bit
inconsistent with that of other sequences: that's not a problem in
itself, but compare it for instance with "A vector is a kind of
sequence that supports random access iterators"; though the intent is
obvious one might argue that the wording used for arrays doesn't tell
what an array is, and relies on the reader to infer that it is what
the &lt;array&gt; header defines.
</p>
<p>
* it would be desiderable to have a static const data member of type
std::size_t, with value N, for usage as integral constant expression
</p>
<p>
* section 23.1 [lib.container.requirements] seem not to consider
fixed-size containers at all, as it says: "[containers] control
allocation and deallocation of these objects [the contained objects]
through constructors, destructors, *insert and erase* operations"
</p>
<p>
* max_size() isn't specified: the result is obvious but, technically,
it relies on table 80: "size() of the largest possible container"
which, again, doesn't seem to consider fixed size containers
</p>

<p><i>[
2009-05-29 Daniel adds:
]</i></p>


<blockquote>
<ol type="a">
<li>
<p>
star bullet 1 ("what's the effect of calling <tt>assign(T&amp;)</tt> on a
zero-sized array?[..]");
</p>
<blockquote>
<tt>assign</tt> has been renamed to <tt>fill</tt> and the semantic of <tt>fill</tt> is now
defined in terms of
the free algorithm <tt>fill_n</tt>, which is well-defined for this situation.
</blockquote>
</li>
<li>
<p>
star bullet 3 ("it would be desiderable to have a static const data
member..."):
</p>
<blockquote>
It seems that <tt>tuple_size&lt;array&lt;T, N&gt; &gt;::value</tt> as of 23.3.1.7 [array.tuple] does
provide this functionality now.
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
Alisdair to address by the next meeting, or declare NAD.
</p>
<p>
Moved to Tentatively NAD.
</p>
</blockquote>

<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote>
Moved to NAD.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>


<p><i>[
Kona (2007): requirements on zero sized <tt>tr1::array</tt>s and other details
Issue 617: <tt>std::array</tt> is a sequence that doesn't satisfy the sequence
requirements? Alisdair will prepare a paper. Proposed Disposition: Open
]</i></p>





<hr>
<h3><a name="590"></a>590. Type traits implementation latitude should be removed for C++0x</h3>
<p><b>Section:</b> 20.6 [meta], TR1 4.9 [tr.meta.req] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Beman Dawes <b>Opened:</b> 2006-08-10  <b>Last modified:</b> 2007-05-11</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#meta">issues</a> in [meta].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
20.4.9 [lib.meta.req], Implementation requirements, provides latitude for type
traits implementers that is not needed in C++0x. It includes the wording:
</p>

<blockquote><p>
[<i>Note:</i> the latitude granted to implementers in this clause is temporary,
and is expected to be removed in future revisions of this document. -- <i>end note</i>]
</p></blockquote>

<p>
Note:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2157.html">N2157: Minor Modifications to the type traits Wording</a>
also has the intent of removing this wording from the WP.
</p>



<p><b>Proposed resolution:</b></p>
<p>
Remove 20.4.9 [lib.meta.req] in its entirety from the WP.
</p>

<p><i>[
post-Oxford: Recommend NAD Editorial.  This resolution is now in the
current working draft.
]</i></p>







<hr>
<h3><a name="591"></a>591. Misleading "built-in</h3>
<p><b>Section:</b> 18.3.1.2 [numeric.limits.members] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> whyglinux <b>Opened:</b> 2006-08-08  <b>Last modified:</b> 2007-07-02</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#numeric.limits.members">issues</a> in [numeric.limits.members].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
18.2.1.2 numeric_limits members [lib.numeric.limits.members]
Paragraph 7:
</p>
<blockquote><p>
"For built-in integer types, the number of non-sign bits in the
representation."
</p></blockquote>

<p>
26.1 Numeric type requirements [lib.numeric.requirements]
Footnote:
</p>

<blockquote><p>
"In other words, value types. These include built-in arithmetic types,
pointers, the library class complex, and instantiations of valarray for
value types."
</p></blockquote>

<p>
Integer types (which are bool, char, wchar_t, and the signed and
unsigned integer types) and arithmetic types (which are integer and
floating types) are all built-in types and thus there are no
non-built-in (that is, user-defined) integer or arithmetic types. Since
the redundant "built-in" in the above 2 sentences can mislead that
there may be built-in or user-defined integer and arithmetic types
(which is not correct), the "built-in" should be removed.
</p>


<p><b>Proposed resolution:</b></p>
<p>
18.2.1.2 numeric_limits members [lib.numeric.limits.members]
Paragraph 7:
</p>
<blockquote><p>
"For <del>built-in</del> integer types, the number of non-sign bits in the
representation."
</p></blockquote>

<p>
26.1 Numeric type requirements [lib.numeric.requirements]
Footnote:
</p>

<blockquote><p>
"In other words, value types. These include <del>built-in</del> arithmetic types,
pointers, the library class complex, and instantiations of valarray for
value types."
</p></blockquote>


<p><b>Rationale:</b></p>
<p>
Recommend NAD / Editorial.  The proposed resolution is accepted as editorial.
</p>





<hr>
<h3><a name="592"></a>592. Incorrect treatment of rdbuf()-&gt;close() return type</h3>
<p><b>Section:</b> 27.9.1.9 [ifstream.members] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Christopher Kohlhoff <b>Opened:</b> 2006-08-17  <b>Last modified:</b> 2008-07-02</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#ifstream.members">issues</a> in [ifstream.members].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I just spotted a minor problem in 27.8.1.7
[lib.ifstream.members] para 4 and also 27.8.1.13
[lib.fstream.members] para 4. In both places it says:
</p>
<blockquote>
<pre>void close();
</pre>
<p>
Effects: Calls rdbuf()-&gt;close() and, if that function returns false, ...
</p>
</blockquote>
<p>
However, basic_filebuf::close() (27.8.1.2) returns a pointer to the
filebuf on success, null on failure, so I think it is meant to
say "if that function returns a null pointer". Oddly, it is
correct for basic_ofstream.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change 27.9.1.9 [ifstream.members], p5:
</p>

<blockquote><p>
<i>Effects:</i> Calls <tt>rdbuf()-&gt;close()</tt> and, if that function
<ins>fails (</ins>returns <del><tt>false</tt></del> <ins>a null pointer)</ins>,
calls <tt>setstate(failbit)</tt> (which may throw <tt>ios_base::failure</tt>
(27.4.4.3)).
</p></blockquote>

<p>
Change 27.9.1.17 [fstream.members], p5:
</p>

<blockquote><p>
<i>Effects:</i> Calls <tt>rdbuf()-&gt;close()</tt> and, if that function
<ins>fails (</ins>returns <del><tt>false</tt></del> <ins>a null pointer)</ins>,
calls <tt>setstate(failbit)</tt> (which may throw <tt>ios_base::failure</tt>
(27.4.4.3)).
</p></blockquote>



<p><i>[
Kona (2007): Proposed Disposition: NAD, Editorial
]</i></p>





<hr>
<h3><a name="597"></a>597. Decimal: The notion of 'promotion' cannot be emulated by user-defined types.</h3>
<p><b>Section:</b> TRDecimal 3.2 [trdec.types.types] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Daveed Vandevoorde <b>Opened:</b> 2006-04-05  <b>Last modified:</b> 2009-07-15</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#trdec.types.types">issues</a> in [trdec.types.types].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In a private email, Daveed writes:
</p>
<blockquote>
<p>
I am not familiar with the C TR, but my guess is that the
class type approach still won't match a built-in type
approach because the notion of "promotion" cannot be
emulated by user-defined types.
</p>
<p>
Here is an example:
</p>
</blockquote>
<pre>
         struct S {
           S(_Decimal32 const&amp;);  // Converting constructor
         };
         void f(S);

         void f(_Decimal64);

         void g(_Decimal32 d) {
           f(d);
         }
</pre>

<blockquote>
<p>
If _Decimal32 is a built-in type, the call f(d) will likely
resolve to f(_Decimal64) because that requires only a
promotion, whereas f(S) requires a user-defined conversion.
</p>
<p>
If _Decimal32 is a class type, I think the call f(d) will be
ambiguous because both the conversion to _Decimal64 and the
conversion to S will be user-defined conversions with neither
better than the other.
</p>
</blockquote>
<p>
Robert comments:
</p>
<p>In general, a library of arithmetic types cannot exactly emulate the
behavior of the intrinsic numeric types. There are several ways to tell
whether an implementation of the decimal types uses compiler
intrinisics or a library. For example:
</p>
<pre>                 _Decimal32 d1;
                 d1.operator+=(5);  // If d1 is a builtin type, this won't compile.
</pre>
<p>
In preparing the decimal TR, we have three options:
</p>
<ol>
<li>require that the decimal types be class types</li>
<li>require that the decimal types be builtin types, like float and double</li>
<li>specify a library of class types, but allow enough implementor
latitude that a conforming implementation could instead provide builtin
types</li>
</ol>
<p>
We decided as a group to pursue option #3, but that approach implies
that implementations may not agree on the semantics of certain use
cases (first example, above), or on whether certain other cases are
well-formed (second example). Another potentially important problem is
that, under the present definition of POD, the decimal classes are not
POD types, but builtins will be.
</p>
<p>Note that neither example above implies any problems with respect to
C-to-C++ compatibility, since neither example can be expressed in C.
</p>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
Decimal numeric types may either be builtin types or library types. We
only intend to specify the common subset of behaviors of the two
implementation approaches. The front matter of the Decimal TR says this
explicitly.
</p>
<p>
Move to NAD.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="606"></a>606. Decimal: allow narrowing conversions</h3>
<p><b>Section:</b> TRDecimal 3.2 [trdec.types.types] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2006-06-15  <b>Last modified:</b> 2009-07-15</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#trdec.types.types">issues</a> in [trdec.types.types].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In c++std-lib-17205, Martin writes:
</p>
<blockquote><p>...was it a deliberate design choice to make narrowing
assignments ill-formed while permitting narrowing compound assignments?
For instance:
</p></blockquote>
<pre>      decimal32 d32;
      decimal64 d64;

      d32 = 64;     // error
      d32 += 64;    // okay
</pre>
<p>
In c++std-lib-17229, Robert responds:
</p>
<blockquote><p>It is a vestige of an old idea that I forgot to remove
from the paper. Narrowing assignments should be permitted. The bug is
that the converting constructors that cause narrowing should not be
explicit. Thanks for pointing this out.
</p></blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
The current state of the Decimal TR is the result of a deliberate design
decision that has been examined many times.
</p>
<p>
Move to NAD.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
1.  In "3.2.2 Class <code>decimal32</code>" synopsis, remove the <code>explicit</code> specifier from the narrowing conversions:
</p>
<pre>                // <i>3.2.2.2 conversion from floating-point type:</i>
                <del>explicit</del> decimal32(decimal64 <i>d64</i>);
                <del>explicit</del> decimal32(decimal128 <i>d128</i>);
</pre>
<p>
2.  Do the same thing in "3.2.2.2. Conversion from floating-point type."
</p>
<p>
3.  In "3.2.3 Class <code>decimal64</code>" synopsis, remove the <code>explicit</code> specifier from the narrowing conversion:
</p>
<pre>                // <i>3.2.3.2 conversion from floating-point type:</i>
                <del>explicit</del> decimal64(decimal128 <i>d128</i>);
</pre>
<p>
4.  Do the same thing in "3.2.3.2. Conversion from floating-point type."
</p>

<p><i>[
Redmond: We prefer explicit conversions for narrowing and implicit for widening.
]</i></p>






<hr>
<h3><a name="614"></a>614. std::string allocator requirements still inconsistent</h3>
<p><b>Section:</b> 21.4 [basic.string] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Bo Persson <b>Opened:</b> 2006-12-05  <b>Last modified:</b> 2009-07-15</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#basic.string">issues</a> in [basic.string].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
This is based on N2134, where 21.3.1/2 states:
"... The Allocator object used shall be a copy of the Allocator object 
passed to the basic_string object's constructor or, if the constructor does 
not take an Allocator argument, a copy of a default-constructed Allocator 
object."
</p>
<p>
Section 21.3.2/1 lists two constructors:
</p>
<blockquote><pre>basic_string(const basic_string&lt;charT,traits,Allocator&gt;&amp; str );

basic_string(const basic_string&lt;charT,traits,Allocator&gt;&amp; str ,
             size_type pos , size_type n = npos,
             const Allocator&amp; a = Allocator());
</pre></blockquote>
<p>
and then says "In the first form, the Allocator value used is copied from 
str.get_allocator().", which isn't an option according to 21.3.1.
</p>
<p><i>[
Batavia:  We need blanket statement to the effect of:
]</i></p>


<ol>
<li>If an allocator is passed in, use it, or,</li>
<li>If a string is passed in, use its allocator.</li>
</ol>
<p><i>[
Review constructors and functions that return a string; make sure we follow these
rules (substr, operator+, etc.).  Howard to supply wording.
]</i></p>


<p><i>[
Bo adds:  The new container constructor which takes only a <tt>size_type</tt> is not
consistent with 23.2 [container.requirements], p9 which says in part:

<blockquote>
All other constructors for these container types take an
<tt>Allocator&amp;</tt> argument (20.1.2), an allocator whose value type
is the same as the container's value type. A copy of this argument is
used for any memory allocation performed, by these constructors and by
all member functions, during the lifetime of each container object.
</blockquote>
]</i></p>


<p><i>[
post Bellevue: We re-confirm that the issue is real. Pablo will provide wording.
]</i></p>


<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
Move to NAD.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="615"></a>615. Inconsistencies in Section 21.4</h3>
<p><b>Section:</b> 21.6 [c.strings] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Bo Persson <b>Opened:</b> 2006-12-11  <b>Last modified:</b> 2007-04-24</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#c.strings">issues</a> in [c.strings].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In the current draft N2134, 21.4/1 says
</p>
<p>
"Tables 59,228) 60, 61, 62,and 63 229) 230) describe headers &lt;cctype&gt;, 
&lt;cwctype&gt;, &lt;cstring&gt;, &lt;cwchar&gt;, and &lt;cstdlib&gt; (character conversions), 
respectively."
</p>
<p>
Here footnote 229 applies to table 62, not table 63.
</p>
<p>
Also, footnote 230 lists the new functions in table 63, "atoll, strtoll, 
strtoull, strtof, and strtold added by TR1". However, strtof is not present 
in table 63.
</p>


<p><b>Proposed resolution:</b></p>
<p>
</p>


<p><b>Rationale:</b></p>
<p>
Recommend NAD, editorial.  Send to Pete.
</p>





<hr>
<h3><a name="617"></a>617. std::array is a sequence that doesn't satisfy the sequence requirements?</h3>
<p><b>Section:</b> 23.3.1 [array] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Bo Persson <b>Opened:</b> 2006-12-30  <b>Last modified:</b> 2009-10-20</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#array">issues</a> in [array].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <tt>&lt;array&gt;</tt> header is given under 23.3 [sequences].
23.3.1 [array]/paragraph 3 says:
</p>
<blockquote><p>
"Unless otherwise specified, all array operations are as described in
23.2 [container.requirements]".
</p></blockquote>
<p>
However, array isn't mentioned at all in section 23.2 [container.requirements].
In particular, Table 82 "Sequence requirements" lists several operations (insert, erase, clear) 
that std::array does not have in 23.3.1 [array].
</p>
<p>
Also, Table 83 "Optional sequence operations" lists several operations that 
std::array does have, but array isn't mentioned.
</p>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
The real issue seems to be different than what is described here.
Non-normative text says that std::array is a sequence container, but
there is disagreement about what that really means. There are two
possible interpretations:
</p>
<ol>
<li>
a sequence container is one that satisfies all sequence container requirements
</li>
<li>
a sequence container is one that satisfies some of the sequence
container requirements. Any operation that the container supports is
specified by one or more sequence container requirements, unless that
operation is specifically singled out and defined alongside the
description of the container itself.
</li>
</ol>
<p>
Move to Tentatively NAD.
</p>
</blockquote>

<p><i>[
2009-07-15 Loc Joly adds:
]</i></p>


<blockquote>
<p>
The section 23.2.3 [sequence.reqmts]/1 states that array is a sequence. 23.2.3 [sequence.reqmts]/3
introduces table 83, named Sequence container requirements. This seems
to me to be defining the requirements for all sequences. However, array
does not follow all of this requirements (this can be read in the array
specific section, for the standard is currently inconsistent).
</p>

<p>
Proposed resolution 1 (minimal change): 
</p>
<blockquote>
<p>
Say that array is a container, that in addition follows only some of the
sequence requirements, as described in the array section:
</p>

<blockquote>
The library provides <del>five</del> <ins>three</ins> basic kinds of sequence containers: <del><tt>array</tt></del>,
<tt>vector</tt>, 
<del><tt>forward_list</tt></del>, <tt>list</tt>, and <tt>deque</tt>. <ins>In addition, <tt>array</tt>
and <tt>forward_list</tt> follows some of the requirements 
of sequences, as described in their respective sections.</ins>
</blockquote>

</blockquote>

<p>
Proposed resolution 2 (most descriptive description, no full wording provided): 
</p>
<blockquote>
Introduce the notion of a Fixed Size Sequence, with it requirement table
that would be a subset of the current Sequence container. array would be
the only Fixed Size Sequence (but dynarray is in the queue for TR2).
Sequence requirements would now be requirements in addition to Fixed
Size Sequence requirements (it is currently in addition to container).
</blockquote>
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
Move to NAD Editorial
</blockquote>

<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote>
This will require a lot of reorganization. Editor doesn't think this is really
an issue, since the description of array can be considered as overriding
what's specified about sequences. Move to NAD.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="626"></a>626. new <i>Remark</i> clauses not documented</h3>
<p><b>Section:</b> 17.5.1.4 [structure.specifications] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2007-01-20  <b>Last modified:</b> 2008-02-25</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#structure.specifications">issues</a> in [structure.specifications].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
        <p>

The <i>Remark</i> clauses newly  introduced into the Working Paper 
(<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2134.pdf">N2134</a>)
are  not mentioned  in  17.5.1.4 [structure.specifications] where  we list  the
meaning  of <i>Effects</i>, <i>Requires</i>,  and other  clauses (with
the exception  of <i>Notes</i> which are documented  as informative in
17.5.1.2 [structure.summary], p2, and which they replace in many cases).

        </p>
        <p>

Propose add a bullet for <i>Remarks</i> along with a brief description.

        </p>
<p><i>[
Batavia:  Alan and Pete to work.
]</i></p>


<p><i>[
Bellevue: Already resolved in current working paper.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="627"></a>627. Low memory and exceptions</h3>
<p><b>Section:</b> 18.6.1.1 [new.delete.single] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> P.J. Plauger <b>Opened:</b> 2007-01-23  <b>Last modified:</b> 2008-02-25</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#new.delete.single">issues</a> in [new.delete.single].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I recognize the need for nothrow guarantees in the exception reporting
mechanism, but I strongly believe that implementors also need an escape hatch
when memory gets really low. (Like, there's not enough heap to construct and
copy exception objects, or not enough stack to process the throw.) I'd like to
think we can put this escape hatch in 18.6.1.1 [new.delete.single],
<tt>operator new</tt>, but I'm not sure how to do it. We need more than a
footnote, but the wording has to be a bit vague. The idea is that if
<tt>new</tt> can't allocate something sufficiently small, it has the right to
<tt>abort</tt>/call <tt>terminate</tt>/call <tt>unexpected</tt>.
</p>

<p><i>[
Bellevue: NAD.  1.4p2 specifies a program must behave correctly "within
its resource limits", so no further escape hatch is necessary.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="632"></a>632. Time complexity of size() for std::set</h3>
<p><b>Section:</b> 23.2 [container.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Lionel B <b>Opened:</b> 2007-02-01  <b>Last modified:</b> 2009-07-15</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#container.requirements">active issues</a> in [container.requirements].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#container.requirements">issues</a> in [container.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
A recent news group discussion:
</p>
<blockquote>
<p>
Anyone know if the Standard has anything to say about the time complexity
of size() for std::set?   I need to access a set's size (/not/ to know if it is empty!) heavily
during an algorithm and was thus wondering whether I'd be better off
tracking the size "manually" or whether that'd be pointless.
</p>
<p>
That would be pointless. size() is O(1).
</p>
<p>
Nit: the standard says "should" have constant time. Implementations may take
license to do worse. I know that some do this for <tt>std::list&lt;&gt;</tt> as a part of
some trade-off with other operation.
</p>

<p>
I was aware of that, hence my reluctance to use size() for std::set.
</p>
<p>
However, this reason would not apply to <tt>std::set&lt;&gt;</tt> as far as I can see.
</p>
<p>
Ok, I guess the only option is to try it and see...
</p>
</blockquote>

<p>
If I have any recommendation to the C++ Standards Committee it is that
implementations must (not "should"!) document clearly[1], where known, the
time complexity of *all* container access operations.
</p>
<p>
[1] In my case (gcc 4.1.1) I can't swear that the time complexity of size()
for std::set is not documented... but if it is it's certainly well hidden
away.
</p>

<p><i>[
Kona (2007): This issue affects all the containers. We'd love to see a
paper dealing with the broad issue. We think that the complexity of the
<tt>size()</tt> member of every container -- except possibly <tt>list</tt> -- should be
O(1). Alan has volunteered to provide wording.
]</i></p>


<p><i>[
Bellevue:
]</i></p>


<blockquote>
Mandating O(1) size will not fly, too many implementations would be
invalidated. Alan to provide wording that toughens wording, but that
does not absolutely mandate O(1).
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We observed that the wording "should" (in note a) has no effect.
Howard prefers that O(1) size be mandated.
It is not clear that this issue can be resolved to everyone's satisfaction,
but Alan will provide wording nonetheless.
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
Fixed by paper N2923.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="633"></a>633. Return clause mentions undefined "type()"</h3>
<p><b>Section:</b> 20.7.15.2.5 [func.wrap.func.targ] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2007-02-03  <b>Last modified:</b> 2007-07-02</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
20.7.15.2.5 [func.wrap.func.targ], p4 says:
</p>
<blockquote><p>
<i>Returns:</i> If <tt>type() == typeid(T)</tt>, a pointer to the stored
function target; otherwise a null pointer.
</p></blockquote>

<ol>
<li>
There exists neither a type, a typedef <tt>type</tt>, nor member
function <tt>type()</tt> in class template function nor in the global or
<tt>std</tt> namespace.
</li>
<li>
Assuming that <tt>type</tt> should have been <tt>target_type()</tt>,
this description would lead to false results, if <tt>T = <i>cv</i>
void</tt> due to returns clause 20.7.15.2.5 [func.wrap.func.targ], p1.
</li>
</ol>



<p><b>Proposed resolution:</b></p>
<p>
Change 20.7.15.2.5 [func.wrap.func.targ], p4:
</p>

<blockquote><p>
<i>Returns:</i> If <tt><del>type()</del> <ins>target_type()</ins> == typeid(T) <ins>&amp;&amp; typeid(T) !=
typeid(void)</ins></tt>, a pointer to the stored function target;
otherwise a null pointer.
</p></blockquote>

<p><i>[
Pete: Agreed. It's editorial, so I'll fix it.
]</i></p>







<hr>
<h3><a name="635"></a>635. domain of <tt>allocator::address</tt></h3>
<p><b>Section:</b> 20.2.2 [allocator.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2007-02-08  <b>Last modified:</b> 2009-10-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#allocator.requirements">issues</a> in [allocator.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The table of allocator requirements in 20.2.2 [allocator.requirements] describes
<tt>allocator::address</tt> as:
</p>
<blockquote><pre>a.address(r)
a.address(s)
</pre></blockquote>
<p>
where <tt>r</tt> and <tt>s</tt> are described as:
</p>
<blockquote><p>
a value of type <tt>X::reference</tt> obtained by the expression <tt>*p</tt>. 
</p></blockquote>

<p>
and <tt>p</tt> is 
</p>

<blockquote><p>
a value of type <tt>X::pointer</tt>, obtained by calling <tt>a1.allocate</tt>, 
where <tt>a1 == a</tt>
</p></blockquote>

<p>
This all implies that to get the address of some value of type <tt>T</tt> that
value must have been allocated by this allocator or a copy of it.
</p>

<p>
However sometimes container code needs to compare the address of an external value of
type <tt>T</tt> with an internal value.  For example <tt>list::remove(const T&amp; t)</tt>
may want to compare the address of the external value <tt>t</tt> with that of a value
stored within the list.  Similarly <tt>vector</tt> or <tt>deque insert</tt> may
want to make similar comparisons (to check for self-referencing calls).
</p>

<p>
Mandating that <tt>allocator::address</tt> can only be called for values which the
allocator allocated seems overly restrictive.
</p>

<p><i>[
post San Francisco:
]</i></p>


<blockquote>
Pablo recommends NAD Editorial, solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2768.pdf">N2768</a>.
</blockquote>

<p><i>[
2009-04-28 Pablo adds:
]</i></p>


<blockquote>
Tentatively-ready NAD Editorial as fixed by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2768.pdf">N2768</a>.
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
Fixed by N2768.
</blockquote>

<p><i>[
2009-07-28 Reopened by Alisdair.  No longer solved by concepts.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD Editorial.  Addressed by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2982.pdf">N2982</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 20.2.2 [allocator.requirements]:
</p>

<blockquote>
<p>
<tt>r</tt> : a value of type <tt>X::reference</tt> <del>obtained by the expression *p</del>.
</p>
<p>
<tt>s</tt> : a value of type <tt>X::const_reference</tt> <del>obtained by the 
expression <tt>*q</tt> or by conversion from a value <tt>r</tt></del>.
</p>
</blockquote>

<p><i>[
post Oxford:  This would be rendered NAD Editorial by acceptance of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2257.html">N2257</a>.
]</i></p>


<p><i>[
Kona (2007):  This issue is section 8 of N2387.  There was some discussion of it but
no resolution to this issue was recorded.  Moved to Open.
]</i></p>







<hr>
<h3><a name="636"></a>636. 26.5.2.3 valarray::operator[]</h3>
<p><b>Section:</b> 26.6.2.3 [valarray.access] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Bo Persson <b>Opened:</b> 2007-02-11  <b>Last modified:</b> 2007-07-02</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#valarray.access">issues</a> in [valarray.access].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The signature of the const operator[] has been changed to return a const 
reference.
</p>
<p>
The description in paragraph 1 still says that the operator returns by 
value.
</p>
<p><i>[
Pete recommends editorial fix.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="637"></a>637. [c.math]/10 inconsistent return values</h3>
<p><b>Section:</b> 26.8 [c.math] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Bo Persson <b>Opened:</b> 2007-02-13  <b>Last modified:</b> 2007-07-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#c.math">issues</a> in [c.math].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
26.8 [c.math], paragraph 10 has long lists of added signatures for float and long double 
functions. All the signatures have float/long double return values, which is 
inconsistent with some of the double functions they are supposed to 
overload.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change 26.8 [c.math], paragraph 10,
</p>

<blockquote><pre><del>float</del> <ins>int</ins> ilogb(float);
<del>float</del> <ins>long</ins> lrint(float);
<del>float</del> <ins>long</ins> lround(float);
<del>float</del> <ins>long long</ins> llrint(float);
<del>float</del> <ins>long long</ins> llround(float);

<del>long double</del> <ins>int</ins> ilogb(long double);
<del>long double</del> <ins>long</ins> lrint(long double);
<del>long double</del> <ins>long</ins> lround(long double);
<del>long double</del> <ins>long long</ins> llrint(long double);
<del>long double</del> <ins>long long</ins> llround(long double);
</pre></blockquote>





<hr>
<h3><a name="639"></a>639. Still problems with exceptions during streambuf IO</h3>
<p><b>Section:</b> 27.7.1.2.3 [istream::extractors], 27.7.2.6.3 [ostream.inserters] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2007-02-17  <b>Last modified:</b> 2007-10-10</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#istream::extractors">issues</a> in [istream::extractors].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There already exist two active DR's for the wording of 27.7.1.2.3 [istream::extractors]/13
from 14882:2003(E), namely <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#64">64</a> and <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#413">413</a>.
</p>

<p>
Even with these proposed corrections, already maintained in N2134,
I have the feeling, that the current wording does still not properly
handle the "exceptional" situation. The combination of para 14
</p>

<blockquote><p>
"[..] Characters are extracted and inserted until
any of the following occurs:
</p>
<p>
[..]
</p>
<p>
- an exception occurs (in which case the exception is caught)."
</p></blockquote>

<p>
and 15
</p>

<blockquote><p>
"If the function inserts no characters, it calls setstate(failbit),
which
may throw ios_base::failure (27.4.4.3). If it inserted no characters
because it caught an exception thrown while extracting characters
from *this and failbit is on in exceptions() (27.4.4.3), then the
caught
exception is rethrown."
</p></blockquote>

<p>
both in N2134 seems to imply that any exception, which occurs
*after* at least one character has been inserted is caught and lost
for
ever. It seems that even if failbit is on in exceptions() rethrow is
not
allowed due to the wording "If it inserted no characters because it
caught an exception thrown while extracting".
</p>

<p>
Is this behaviour by design?
</p>

<p>
I would like to add that its output counterpart in 27.7.2.6.3 [ostream.inserters]/7-9
(also
N2134) does not demonstrate such an exception-loss-behaviour.
On the other side, I wonder concerning several subtle differences
compared to input::
</p>
<p>
1) Paragraph 8 says at its end:
</p>

<blockquote><p>
"- an exception occurs while getting a character from sb."
</p></blockquote>

<p>
Note that there is nothing mentioned which would imply that such
an exception will be caught compared to 27.7.1.2.3 [istream::extractors]/14.
</p>

<p>
2) Paragraph 9 says:
</p>

<blockquote><p>
"If the function inserts no characters, it calls setstate(failbit)
(which
may throw ios_base::failure (27.4.4.3)). If an exception was thrown
while extracting a character, the function sets failbit in error
state,
and if failbit is on in exceptions() the caught exception is
rethrown."
</p></blockquote>

<p>
The sentence starting with "If an exception was thrown" seems to
imply that such an exception *should* be caught before.
</p>


<p><b>Proposed resolution:</b></p>
<p>
(a) In 27.7.1.2.3 [istream::extractors]/15 (N2134) change the sentence
</p>

<blockquote><p>
If the function inserts no characters, it calls
<tt>setstate(failbit)</tt>, which may throw <tt>ios_base::failure</tt>
(27.4.4.3). If <del>it inserted no characters because it caught an
exception thrown while extracting characters from <tt>*this</tt></del>
<ins>an exception was thrown while extracting a character from
<tt>*this</tt>, the function sets <tt>failbit</tt> in error state,</ins>
and <tt>failbit</tt> is on in <tt>exceptions()</tt> (27.4.4.3), then the
caught exception is rethrown.
</p></blockquote>

<p>
(b) In 27.7.2.6.3 [ostream.inserters]/8 (N2134) change the sentence:
</p>

<blockquote>
<p>
Gets characters from <tt>sb</tt> and inserts them in <tt>*this</tt>.
Characters are read from <tt>sb</tt> and inserted until any of the
following occurs:
</p>
<ul>
<li>end-of-file occurs on the input sequence;</li>
<li>inserting in the output sequence fails (in which case the character to be inserted is not extracted);</li>
<li>an exception occurs while getting a character from <tt>sb</tt> <ins>(in which
case the exception is caught)</ins>.</li>
</ul>
</blockquote>



<p><b>Rationale:</b></p>
This extractor is described as a formatted input function so the
exception behavior is already specified. There is additional behavior
described in this section that applies to the case in which failbit is
set. This doesn't contradict the usual exception behavior for formatted
input functions because that applies to the case in which badbit is set.





<hr>
<h3><a name="641"></a>641. Editorial fix for 27.6.4 (N2134)</h3>
<p><b>Section:</b> 27.7.4 [ext.manip] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2007-02-18  <b>Last modified:</b> 2007-07-02</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#ext.manip">issues</a> in [ext.manip].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The function <tt>f</tt> in para 4 (27.7.4 [ext.manip]) references an unknown <tt>strm</tt>
in the following line:
</p>

<blockquote><pre>mg.get(Iter(str.rdbuf()), Iter(), intl, strm, err, mon);
</pre></blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 27.7.4 [ext.manip], p4:
</p>

<blockquote><pre>mg.get(Iter(str.rdbuf()), Iter(), intl, str<del>m</del>, err, mon);
</pre></blockquote>

<p><i>[
Oxford:  Editorial.
]</i></p>







<hr>
<h3><a name="642"></a>642. Invalidated fstream footnotes in N2134</h3>
<p><b>Section:</b> 27.9.1.9 [ifstream.members], 27.9.1.13 [ofstream.members] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2007-02-20  <b>Last modified:</b> 2007-07-02</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#ifstream.members">issues</a> in [ifstream.members].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The standard wording of N2134 has extended the 14882:2003(E)
wording for the ifstream/ofstream/fstream open function to fix
a long standing problem, see <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#409">409</a>.
</p>

<p>
Now it's properly written as
</p>

<blockquote><p>
"If that function does not return a null pointer calls clear(),
otherwise
calls setstate(failbit)[..]"
</p></blockquote>

<p>
instead of the previous
</p>

<blockquote><p>
"If that function returns a null pointer, calls setstate(failbit)[..]
</p></blockquote>

<p>
While the old footnotes saying
</p>

<blockquote><p>
"A successful open does not change the error state."
</p></blockquote>

<p>
where correct and important, they are invalid now for ifstream and
ofstream (because clear *does* indeed modify the error state) and
should be removed (Interestingly fstream itself never had these,
although
they where needed for that time).
</p>


<p><b>Proposed resolution:</b></p>
<p>
In 27.9.1.9 [ifstream.members], remove footnote:
</p>

<blockquote><p>
<del><sup>334)</sup> A successful open does not change the error state.</del>
</p></blockquote>

<p>
In 27.9.1.13 [ofstream.members], remove footnote:
</p>

<blockquote><p>
<del><sup>335)</sup> A successful open does not change the error state.</del>
</p></blockquote>






<hr>
<h3><a name="644"></a>644. Possible typos in 'function' description</h3>
<p><b>Section:</b> 20.7.15.2 [func.wrap.func] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Bo Persson <b>Opened:</b> 2007-02-25  <b>Last modified:</b> 2009-07-13</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#func.wrap.func">issues</a> in [func.wrap.func].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
20.7.15.2 [func.wrap.func]
</p>
<p>
The note in paragraph 2 refers to 'undefined void operators', while the
section declares a pair of operators returning bool.
</p>

<p><i>[
Post-Sophia Antipolis:
]</i></p>


<blockquote>
Changed from Pending WP to Open.  This issue was voted to WP at the same time the operators were
changed from private to deleted.  The two issues stepped on each other.  What do we want the return
type of these deleted functions to be?
</blockquote>

<p><i>[
2009-05-02 Daniel adds:
]</i></p>


<blockquote>
<p>
I suggest harmonizing this issue with similar classes. E.g. in
20.8.15.3 [util.smartptr.weak] <tt>bool</tt> return values for
</p>
<blockquote><pre>template &lt;class Y&gt; bool operator&lt;(weak_ptr&lt;Y&gt; const&amp;) const = delete;
template &lt;class Y&gt; bool operator&lt;=(weak_ptr&lt;Y&gt; const&amp;) const = delete;
template &lt;class Y&gt; bool operator&gt;(weak_ptr&lt;Y&gt; const&amp;) const = delete;
template &lt;class Y&gt; bool operator&gt;=(weak_ptr&lt;Y&gt; const&amp;) const = delete;
</pre></blockquote>

<p>
are used and basically all <em>newer</em> provided deleted copy assignment operators
of type <tt>X</tt> use the canonical return type <tt>X&amp;</tt> instead of <tt>void</tt>. Since the note
mentioned in the issue description has now already been changed to
</p>
<blockquote>
deleted overloads close possible hole in the type system
</blockquote>
<p>
it seems to be of even lesser need to perform the change. Therefore
I recommend declaring the issue as NAD.
</p>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We agree with Daniel's recommendation.
</p>
<p>
Move to NAD.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 20.7.15.2 [func.wrap.func]
</p>

<blockquote><pre>...
private:
   // 20.7.15.2 [func.wrap.func], undefined operators:
   template&lt;class Function2&gt; <del>bool</del> <ins>void</ins> operator==(const function&lt;Function2&gt;&amp;);
   template&lt;class Function2&gt; <del>bool</del> <ins>void</ins> operator!=(const function&lt;Function2&gt;&amp;);
};
</pre></blockquote>

<p>
Change 20.7.15.2 [func.wrap.func]
</p>

<blockquote><pre>template&lt;class Function2&gt; <del>bool</del> <ins>void</ins> operator==(const function&lt;Function2&gt;&amp;);
template&lt;class Function2&gt; <del>bool</del> <ins>void</ins> operator!=(const function&lt;Function2&gt;&amp;);
</pre></blockquote>





<hr>
<h3><a name="645"></a>645. Missing members in match_results</h3>
<p><b>Section:</b> 28.10 [re.results] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2007-02-26  <b>Last modified:</b> 2008-03-12</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#re.results">issues</a> in [re.results].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
According to the description given in 28.10 [re.results]/2 the class template
match_results "shall satisfy the requirements of a Sequence, [..],
except that only operations defined for const-qualified Sequences
are supported".
Comparing the provided operations from 28.10 [re.results]/3 with the
sequence/container tables 80 and 81 one recognizes the following
missing operations:
</p>

<p>
1) The members
</p>

<blockquote><pre>const_iterator rbegin() const;
const_iterator rend() const;
</pre></blockquote>

<p>
should exists because 23.1/10 demands these for containers
(all sequences are containers) which support bidirectional
iterators. Aren't these supported by match_result? This is not
explicitely expressed, but it's somewhat implied by two arguments:
</p>
<p>
(a) Several typedefs delegate to
<tt>iterator_traits&lt;BidirectionalIterator&gt;</tt>.
</p>
<p>
(b) The existence of <tt>const_reference operator[](size_type n) const</tt>
implies even random-access iteration.
I also suggest, that <tt>match_result</tt> should explicitly mention,
which minimum iterator category is supported and if this does
not include random-access the existence of <tt>operator[]</tt> is
somewhat questionable.
</p>
<p>
2) The new "convenience" members
</p>
<blockquote><pre>const_iterator cbegin() const;
const_iterator cend() const;
const_iterator crbegin() const;
const_iterator crend() const;
</pre></blockquote>
<p>
should be added according to tables 80/81.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add the following members to the <tt>match_results</tt> synopsis after <tt>end()</tt> in 28.10 [re.results]
para 3:
</p>

<blockquote><pre>const_iterator cbegin() const; 
const_iterator cend() const;
</pre></blockquote>

<p>
In section 28.10.3 [re.results.acc] change:
</p>

<blockquote>
<pre>const_iterator begin() const;
<ins>const_iterator cbegin() const;</ins>
</pre>
<blockquote>
<p>
-7- <i>Returns:</i> A starting iterator that enumerates over all the sub-expressions stored in <tt>*this</tt>.
</p>
</blockquote>

<pre>const_iterator end() const;
<ins>const_iterator cend() const;</ins>
</pre>
<blockquote>
<p>
-8- <i>Returns:</i> A terminating iterator that enumerates over all the sub-expressions stored in <tt>*this</tt>.
</p>
</blockquote>
</blockquote>



<p><i>[
Kona (2007): Voted to adopt proposed wording in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2409.pdf">N2409</a>
except removing the entry in the table container requirements.  Moved to Review.
]</i></p>


<p><i>[
Bellevue:  Proposed wording now in the WP.
]</i></p>





<hr>
<h3><a name="647"></a>647. Inconsistent regex_search params</h3>
<p><b>Section:</b> 28.11.3 [re.alg.search] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2007-02-26  <b>Last modified:</b> 2007-07-26</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
28.11.3 [re.alg.search]/5 declares
</p>

<blockquote><pre>template &lt;class iterator, class charT, class traits&gt;
bool regex_search(iterator first, iterator last,
                  const basic_regex&lt;charT, traits&gt;&amp; e,
                  regex_constants::match_flag_type flags =
                      regex_constants::match_default);
</pre></blockquote>

<p>
where it's not explained, which iterator category
the parameter iterator belongs to. This is inconsistent
to the preceding declaration in the synopsis section
28.4 [re.syn], which says:
</p>

<blockquote><pre>template &lt;class BidirectionalIterator, class charT, class traits&gt;
bool regex_search(BidirectionalIterator first, BidirectionalIterator last,
                  const basic_regex&lt;charT, traits&gt;&amp; e,
                  regex_constants::match_flag_type flags =
                      regex_constants::match_default);
</pre></blockquote>


<p><b>Proposed resolution:</b></p>
<p>
In 28.11.3 [re.alg.search]/5 replace all three occurences of param "iterator" with
"BidirectionalIterator"
</p>

<blockquote><pre>template &lt;class <del>iterator</del> <ins>BidirectionalIterator</ins>, class charT, class traits&gt;
  bool regex_search(<del>iterator</del> <ins>BidirectionalIterator</ins> first, <del>iterator</del> <ins>BidirectionalIterator</ins> last, 
                    const basic_regex&lt;charT, traits&gt;&amp; e, 
                    regex_constants::match_flag_type flags = 
                      regex_constants::match_default);
</pre>
<p>
-6- <i>Effects:</i> Behaves "as if" by constructing an object what of
type <tt>match_results&lt;<del>iterator</del>
<ins>BidirectionalIterator</ins>&gt;</tt> and then returning the result
of <tt>regex_search(first, last, what, e, flags)</tt>.
</p>
</blockquote>


<p><b>Rationale:</b></p>
Applied to working paper while issue was still in New status.





<hr>
<h3><a name="648"></a>648. regex_iterator c'tor needs clarification/editorial fix</h3>
<p><b>Section:</b> 28.12.1.1 [re.regiter.cnstr] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2007-03-03  <b>Last modified:</b> 2007-07-02</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 28.12.1.1 [re.regiter.cnstr]/2 the effects paragraph starts with:
</p>

<blockquote>
<p>
<i>Effects:</i> Initializes begin and end to point to the beginning and the
end of the target sequence, sets pregex to &amp;re, sets flags to f,[..]
</p></blockquote>

<p>
There are two issues with this description:
</p>

<ol>
<li>
The meaning of very first part of this quote is unclear, because
there is no target sequence provided, instead there are given two
parameters a and b, both of type BidirectionalIterator. The mentioned
part does not explain what a and b represent.
</li>
<li>
There does not exist any parameter f, but instead a parameter
m in the constructor declaration, so this is actually an editorial
fix.
</li>
</ol>


<p><b>Proposed resolution:</b></p>
<p>
In 28.12.1.1 [re.regiter.cnstr]/2 change the above quoted part by
</p>

<blockquote><p>
<i>Effects:</i> Initializes <tt>begin</tt> and <tt>end</tt> to point to
the beginning and the end of the target sequence <ins>designated by the
iterator range <tt>[a, b)</tt></ins>, sets <tt>pregex</tt> to
<tt>&amp;re</tt>, sets <tt>flags</tt> to <tt><del>f</del>
<ins>m</ins></tt>, then calls <tt>regex_search(begin, end, match,
*pregex, flags)</tt>. If this call returns <tt>false</tt> the
constructor sets <tt>*this</tt> to the end-of-sequence iterator.
</p></blockquote>





<hr>
<h3><a name="649"></a>649. Several typos in regex_token_iterator constructors</h3>
<p><b>Section:</b> 28.12.2.1 [re.tokiter.cnstr] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2007-03-03  <b>Last modified:</b> 2007-07-02</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#re.tokiter.cnstr">issues</a> in [re.tokiter.cnstr].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 28.12.2.1 [re.tokiter.cnstr]/1+2 both the constructor declaration
and the following text shows some obvious typos:
</p>
<p>
1) The third constructor form is written as
</p>
<blockquote><pre>template &lt;std::size_t N&gt;
  regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b, 
                       const regex_type&amp; re, 
                       const int (&amp;submatches)[R], 
                       regex_constants::match_flag_type m = 
                         regex_constants::match_default);
</pre></blockquote>

<p>
where the dimensions of submatches are specified by an
unknown value R, which should be N.
</p>
<p>
2) Paragraph 2 of the same section says in its last sentence:
</p>

<blockquote><p>
The third constructor initializes the member <tt>subs</tt> to hold a
copy of the sequence of integer values pointed to by the iterator range
<tt>[&amp;submatches, &amp;submatches + R)</tt>.
</p></blockquote>

<p>
where again R must be replaced by N.
</p>

<p>
3) Paragraph 3 of the same section says in its first sentence:
</p>

<blockquote><p>
Each constructor then sets <tt>N</tt> to <tt>0</tt>, and
<tt>position</tt> to <tt>position_iterator(a, b, re, f)</tt>.
</p></blockquote>

<p>
where a non-existing parameter "f" is mentioned, which must be
replaced
by the parameter "m".
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change 28.12.2.1 [re.tokiter.cnstr]/1:
</p>
<blockquote><pre>template &lt;std::size_t N&gt;
  regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b, 
                       const regex_type&amp; re, 
                       const int (&amp;submatches)[<del>R</del> <ins>N</ins>], 
                       regex_constants::match_flag_type m = 
                         regex_constants::match_default);
</pre></blockquote>

<p>
Change 28.12.2.1 [re.tokiter.cnstr]/2:
</p>

<blockquote><p>
<i>Effects:</i> The first constructor initializes the member
<tt>subs</tt> to hold the single value <tt>submatch</tt>. The second
constructor initializes the member <tt>subs</tt> to hold a copy of the
argument <tt>submatches</tt>. The third constructor initializes the
member <tt>subs</tt> to hold a copy of the sequence of integer values
pointed to by the iterator range <tt>[&amp;submatches, &amp;submatches +
<del>R</del> <ins>N</ins>)</tt>.
</p></blockquote>

<p>
Change 28.12.2.1 [re.tokiter.cnstr]/3:
</p>

<blockquote><p>
Each constructor then sets <tt>N</tt> to <tt>0</tt>, and
<tt>position</tt> to <tt>position_iterator(a, b, re, <del>f</del>
<ins>m</ins>)</tt>. If <tt>position</tt> is not an end-of-sequence
iterator the constructor sets <tt>result</tt> to the address of the
current match. Otherwise if any of the values stored in <tt>subs</tt> is
equal to <tt>-1</tt> the constructor sets <tt>*this</tt> to a suffix
iterator that points to the range <tt>[a, b)</tt>, otherwise the
constructor sets <tt>*this</tt> to an end-of-sequence iterator.
</p></blockquote>






<hr>
<h3><a name="653"></a>653. Library reserved names</h3>
<p><b>Section:</b> 1.2 [intro.refs] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2007-03-08  <b>Last modified:</b> 2008-02-25</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#intro.refs">issues</a> in [intro.refs].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
</p>
<blockquote>
<p>
1.2 [intro.refs] Normative references
</p>

<p>
The following standards contain provisions which, through reference in
this text, constitute provisions of this Interna- tional Standard. At
the time of publication, the editions indicated were valid. All
standards are subject to revision, and parties to agreements based on
this International Standard are encouraged to investigate the
possibility of applying the most recent editions of the standards
indicated below. Members of IEC and ISO maintain registers of currently
valid International Standards.
</p>

<ul>
<li>Ecma International, ECMAScript Language Specification, Standard
Ecma-262, third edition, 1999.</li>
<li>ISO/IEC 2382 (all parts), Information technology - Vocabulary</li>
<li>ISO/IEC 9899:1990, Programming languages - C</li>
<li>ISO/IEC 9899/Amd.1:1995, Programming languages - C, AMENDMENT 1: C
Integrity</li>
<li>ISO/IEC 9899:1999, Programming languages - C</li>
<li>ISO/IEC 9899:1999/Cor.1:2001 Programming languages - C</li>
<li>ISO/IEC 9899:1999/Cor.2:2004 Programming languages - C</li>
<li>ISO/IEC 9945:2003, Information Technology-Portable Operating System
Interface (POSIX)</li>
<li>ISO/IEC 10646-1:1993 Information technology - Universal Multiple-Octet
Coded Character Set (UCS) - Part 1: Architecture and Basic Multilingual
Plane</li>
</ul>
</blockquote>

<p>
I'm not sure how many of those reserve naming patterns that might affect
us, but I am equally sure I don't own a copy of any of these to check!
</p>
<p>
The point is to list the reserved naming patterns, rather than the
individual names themselves - although we may want to list C keywords
that are valid identifiers in C++ but likely to cause trouble in shared
headers (e.g. restrict)
</p>

<p><i>[
Kona (2007): Recommend NAD.  No one has identified a specific defect, just the possibility of one.
]</i></p>


<p><i>[
Post-Kona: Alisdair request Open. A good example of the problem was a
discussion of the system error proposal, where it was pointed out an all-caps
identifier starting with a capital E conflicted with reserved macro names for
both Posix and C.  I had absolutely no idea of this rule, and suspect I was
not the only one in the room.<br>
<br>
Resolution will require someone with access to all the listed documents to
research their respective name reservation rules, or people with access to
specific documents add their rules to this issue until the list is complete.
]</i></p>


<p><i>[
Bellevue: Wording is aleady present in various standards, and no-one has come forward with wording.
Suggest a formal paper rather than a defect report is the correct way to proceed.
]</i></p>




<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="656"></a>656. Typo in subtract_with_carry_engine declaration</h3>
<p><b>Section:</b> 26.5.1 [rand.synopsis] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2007-03-08  <b>Last modified:</b> 2007-07-02</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.synopsis">issues</a> in [rand.synopsis].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
26.5.1 [rand.synopsis] the header <tt>&lt;random&gt;</tt> synopsis
contains an unreasonable closing curly brace inside the
<tt>subtract_with_carry_engine</tt> declaration.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change the current declaration in 26.5.1 [rand.synopsis]
</p>

<blockquote><pre>template &lt;class UIntType, size_t w<del>}</del>, size_t s, size_t r&gt;
class subtract_with_carry_engine;
</pre></blockquote>


<p><i>[
Pete: Recommends editorial.
]</i></p>





<hr>
<h3><a name="657"></a>657. unclear requirement about header inclusion</h3>
<p><b>Section:</b> 17.6.2.2 [using.headers] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Gennaro Prota <b>Opened:</b> 2007-03-14  <b>Last modified:</b> 2007-10-10</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
17.6.2.2 [using.headers] states:
</p>

<blockquote><p>
A translation unit shall include a header only outside of any
external declaration or definition, [...]
</p></blockquote>

<p>
I see three problems with this requirement:
</p>

<ol type="a">
<li><p>The C++ standard doesn't define what an "external declaration" or
an "external definition" are (incidentally the C99 standard does, and
has a sentence very similar to the above regarding header inclusion).
</p><p>
I think the intent is that the #include directive shall lexically
appear outside *any* declaration; instead, when the issue was pointed
out on comp.std.c++ at least one poster interpreted "external
declaration" as "declaration of an identifier with external linkage".
If this were the correct interpretation, then the two inclusions below
would be legal:
</p>
<blockquote><pre>  // at global scope
  static void f()
  {
# include &lt;cstddef&gt;
  }

  static void g()
  {
# include &lt;stddef.h&gt;
  }
</pre></blockquote>
<p>
(note that while the first example is unlikely to compile correctly,
the second one may well do)
</p></li>

<li><p>as the sentence stands, violations will require a diagnostic; is
this the intent? It was pointed out on comp.std.c++ (by several
posters) that at least one way to ensure a diagnostic exists:
</p>
<blockquote><p>
   [If there is an actual file for each header,] one simple way
   to implement this would be to insert a reserved identifier
   such as __begin_header  at the start of each standard header.
   This reserved identifier would be ignored for all other
   purposes, except that, at the appropriate point in phase 7, if
   it is found inside an external definition, a diagnostic is
   generated. There's many other similar ways to achieve the same
   effect.
   </p>
<p>                                 --James Kuyper, on comp.std.c++
</p></blockquote></li>

<li><p>is the term "header" meant to be limited to standard headers?
Clause 17 is all about the library, but still the general question is
interesting and affects one of the points in the explicit namespaces
proposal (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1691.html">n1691</a>):
</p>
<blockquote><p>
    Those seeking to conveniently enable argument-dependent
    lookups for all operators within an explicit namespace
    could easily create a header file that does so:
</p><pre>    namespace mymath::
    {
        #include "using_ops.hpp"
    }
</pre></blockquote>
</li>
</ol>


<p><b>Proposed resolution:</b></p>
<p>
</p>


<p><b>Rationale:</b></p>
We believe that the existing language does not cause any real confusion
and any new formulation of the rules that we could come up with are
unlikely to be better than what's already in the standard.





<hr>
<h3><a name="658"></a>658. Two unspecified function comparators in [function.objects]</h3>
<p><b>Section:</b> 20.7 [function.objects] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2007-03-19  <b>Last modified:</b> 2007-08-05</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#function.objects">issues</a> in [function.objects].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The header <tt>&lt;functional&gt;</tt> synopsis in 20.7 [function.objects]
contains the following two free comparison operator templates
for the <tt>function</tt> class template
</p>

<blockquote><pre>template&lt;class Function1, class Function2&gt;
void operator==(const function&lt;Function1&gt;&amp;, const function&lt;Function2&gt;&amp;);
template&lt;class Function1, class Function2&gt;
void operator!=(const function&lt;Function1&gt;&amp;, const function&lt;Function2&gt;&amp;);
</pre></blockquote>

<p>
which are nowhere described. I assume that they are relicts before the
corresponding two private and undefined member templates in the function
template (see 20.7.15.2 [func.wrap.func] and  [func.wrap.func.undef]) have been introduced. The original free
function templates should be removed, because using an undefined entity
would lead to an ODR violation of the user.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Remove the above mentioned two function templates from
the header <tt>&lt;functional&gt;</tt> synopsis (20.7 [function.objects])
</p>

<blockquote><pre><del>template&lt;class Function1, class Function2&gt;
void operator==(const function&lt;Function1&gt;&amp;, const function&lt;Function2&gt;&amp;);
template&lt;class Function1, class Function2&gt;
void operator!=(const function&lt;Function1&gt;&amp;, const function&lt;Function2&gt;&amp;);</del>
</pre></blockquote>



<p><b>Rationale:</b></p>
Fixed by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2292.html">N2292</a>
Standard Library Applications for Deleted Functions.





<hr>
<h3><a name="662"></a>662. Inconsistent handling of incorrectly-placed thousands separators</h3>
<p><b>Section:</b> 22.4.2.1.2 [facet.num.get.virtuals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Cosmin Truta <b>Opened:</b> 2007-04-05  <b>Last modified:</b> 2007-07-25</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#facet.num.get.virtuals">active issues</a> in [facet.num.get.virtuals].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#facet.num.get.virtuals">issues</a> in [facet.num.get.virtuals].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
From Section 22.4.2.1.2 [facet.num.get.virtuals], paragraphs 11 and 12, it is implied
that the value read from a stream must be stored
even if the placement of thousands separators does not conform to the
<code>grouping()</code> specification from the <code>numpunct</code> facet.
Since incorrectly-placed thousands separators are flagged as an extraction
failure (by the means of <code>failbit</code>), we believe it is better not
to store the value. A consistent strategy, in which any kind of extraction
failure leaves the input item intact, is conceptually cleaner, is able to avoid
corner-case traps, and is also more understandable from the programmer's point
of view.
</p>
<p>
Here is a quote from <i>"The C++ Programming Language (Special Edition)"</i>
by B.&nbsp;Stroustrup (Section&nbsp;D.4.2.3, pg.&nbsp;897):
</p>
<blockquote><p>
<i>"If a value of the desired type could not be read, failbit is set in r.
[...] An input operator will use r to determine how to set the state of its
stream. If no error was encountered, the value read is assigned through v;
otherwise, v is left unchanged."</i>
</p></blockquote>
<p>
This statement implies that <code>rdstate()</code> alone is sufficient to
determine whether an extracted value is to be assigned to the input item
<i>val</i> passed to <code>do_get</code>. However, this is in disagreement
with the current C++ Standard. The above-mentioned assumption is true in all
cases, except when there are mismatches in digit grouping. In the latter case,
the parsed value is assigned to <i>val</i>, and, at the same time, <i>err</i>
is assigned to <code>ios_base::failbit</code> (essentially "lying" about the
success of the operation). Is this intentional? The current behavior raises
both consistency and usability concerns.
</p>
<p>
Although digit grouping is outside the scope of <code>scanf</code> (on which
the virtual methods of <code>num_get</code> are based), handling of grouping
should be consistent with the overall behavior of scanf. The specification of
<code>scanf</code> makes a distinction between input failures and matching
failures, and yet both kinds of failures have no effect on the input items
passed to <code>scanf</code>. A mismatch in digit grouping logically falls in
the category of matching failures, and it would be more consistent, and less
surprising to the user, to leave the input item intact whenever a failure is
being signaled.
</p>
<p>
The extraction of <code>bool</code> is another example outside the scope of
<code>scanf</code>, and yet consistent, even in the event of a successful
extraction of a <code>long</code> but a failed conversion from
<code>long</code> to <code>bool</code>.
</p>
<p>
Inconsistency is further aggravated by the fact that, when failbit is set,
subsequent extraction operations are no-ops until <code>failbit</code> is
explicitly cleared. Assuming that there is no explicit handling of
<code>rdstate()</code> (as in <code>cin&gt;&gt;i&gt;&gt;j</code>) it is
counter-intuitive to be able to extract an integer with mismatched digit
grouping, but to be unable to extract another, properly-formatted integer
that immediately follows.
</p>
<p>
Moreover, setting <code>failbit</code>, and selectively assigning a value to
the input item, raises usability problems. Either the strategy of
<code>scanf</code> (when there is no extracted value in case of failure), or
the strategy of the <code>strtol</code> family (when there is always an
extracted value, and there are well-defined defaults in case of a failure) are
easy to understand and easy to use. On the other hand, if <code>failbit</code>
alone cannot consistently make a difference between a failed extraction, and a
successful but not-quite-correct extraction whose output happens to be the same
as the previous value, the programmer must resort to implementation tricks.
Consider the following example:
</p>
<pre>    int i = old_i;
    cin &gt;&gt; i;
    if (cin.fail())
        // can the value of i be trusted?
        // what does it mean if i == old_i?
        // ...
</pre>
<p>
Last but not least, the current behvaior is not only confusing to the casual
reader, but it has also been confusing to some book authors. Besides
Stroustrup's book, other books (e.g. "Standard C++ IOStreams and Locales" by
Langer and Kreft) are describing the same mistaken assumption. Although books
are not to be used instead of the standard reference, the readers of these
books, as well as the people who are generally familiar to <code>scanf</code>,
are even more likely to misinterpret the standard, and expect the input items
to remain intact when a failure occurs.
</p>


<p><b>Proposed resolution:</b></p>

<p>
Change 22.4.2.1.2 [facet.num.get.virtuals]:
</p>

<blockquote>
<p>
<b>Stage 3:</b> The result of stage 2 processing can be one of
</p>
<ul>
<li>A sequence of <code>chars</code> has been accumulated in stage 2 that is converted (according to the rules of <code>scanf</code>) to a value of the type of <code><i>val</i></code>.  <del>This value is stored in <code><i>val</i></code> and <code>ios_base::goodbit</code> is stored in <code><i>err</i></code>.</del></li>

<li>The sequence of <code>chars</code> accumulated in stage 2 would have caused <code>scanf</code> to report an input failure. <code>ios_base::failbit</code> is assigned to <code><i>err</i></code>.</li>
</ul>
<p>
<ins>In the first case,</ins> <del>D</del><ins>d</ins>igit grouping is checked.  That is, the positions of discarded separators is examined for consistency with <code>use_facet&lt;numpunct&lt;charT&gt; &gt;(<i>loc</i>).grouping()</code>.  If they are not consistent then <code>ios_base::failbit</code> is assigned to <code><i>err</i></code>.  <ins>Otherwise, the value that was converted in stage 2 is stored in <code><i>val</i></code> and <code>ios_base::goodbit</code> is stored in <code><i>err</i></code>.</ins>
</p>
</blockquote>


<p><b>Rationale:</b></p>
post-Toronto: Changed from New to NAD at the request of the author.  The preferred solution of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2327.pdf">N2327</a>
makes this resolution obsolete.





<hr>
<h3><a name="663"></a>663. Complexity Requirements</h3>
<p><b>Section:</b> 17.5.1.4 [structure.specifications] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Thomas Plum <b>Opened:</b> 2007-04-16  <b>Last modified:</b> 2009-05-01</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#structure.specifications">issues</a> in [structure.specifications].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
17.5.1.4 [structure.specifications] para 5 says
</p>

<blockquote><p>
-5- Complexity requirements specified in the library
clauses are upper bounds, and implementations that provide better
complexity guarantees satisfy the requirements.
</p></blockquote>

<p>
The following
objection has been raised:
</p>

<blockquote><p>
The library clauses suggest general
guidelines regarding complexity, but we have been unable to discover
any absolute hard-and-fast formulae for these requirements. Unless
or until the Library group standardizes specific hard-and-fast
formulae, we regard all the complexity requirements as subject to a
"fudge factor" without any intrinsic upper bound.
</p></blockquote>

<p>
[Plum ref
_23213Y31 etc]
</p>


<p><b>Proposed resolution:</b></p>
<p>
</p>


<p><b>Rationale:</b></p>
Kona (2007): No specific instances of underspecification have been
identified, and big-O notation always involves constant factors.





<hr>
<h3><a name="667"></a>667. <tt>money_get</tt>'s widened minus sign</h3>
<p><b>Section:</b> 22.4.6.1.2 [locale.money.get.virtuals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Thomas Plum <b>Opened:</b> 2007-04-16  <b>Last modified:</b> 2009-07-13</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.money.get.virtuals">issues</a> in [locale.money.get.virtuals].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
22.4.6.1.2 [locale.money.get.virtuals], para 1 says:
</p>

<blockquote><p>
The result is returned as an integral value
stored in <tt>units</tt> or as a sequence of digits possibly preceded by a
minus sign (as produced by <tt>ct.widen(c)</tt> where <tt>c</tt> is '-' or in the range
from '0' through '9', inclusive) stored in <tt>digits</tt>.
</p></blockquote>

<p>
The following
objection has been raised:
</p>

<blockquote><p>
Some implementations interpret this to mean that a facet derived from
<tt>ctype&lt;wchar_t&gt;</tt> can provide its own member <tt>do_widen(char)</tt>
which produces e.g. <tt>L'@'</tt> for the "widened" minus sign, and that the
<tt>'@'</tt> symbol will appear in the resulting sequence of digits.  Other
implementations have assumed that one or more places in the standard permit the
implementation to "hard-wire" <tt>L'-'</tt> as the "widened" minus sign.  Are
both interpretations permissible, or only  one?
</p></blockquote>

<p>
[Plum ref _222612Y14]
</p>

<p>
Furthermore: if <tt>ct.widen('9')</tt> produces <tt>L'X'</tt> (a non-digit), does a
parse fail if a <tt>'9'</tt> appears in the subject string? [Plum ref _22263Y33]
</p>

<p><i>[
Kona (2007): Bill and Dietmar to provide proposed wording.
]</i></p>


<p><i>[
post Bellevue: Bill adds:
]</i></p>


<blockquote>
The Standard is clear that the minus sign stored in <tt>digits</tt> is <tt>ct.widen('-')</tt>.
The subject string must contain characters <tt>c</tt> in the set <tt>[-0123456789]</tt>
which are translated by <tt>ct.widen(c)</tt> calls before being stored in <tt>digits</tt>;
the widened characters are not relevant to the parsing of the subject string.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with Bill's comment above,
in line with the first of the interpretations offered in the issue.
Move to NAD.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="668"></a>668. <tt>money_get</tt>'s empty minus sign</h3>
<p><b>Section:</b> 22.4.6.1.2 [locale.money.get.virtuals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Thomas Plum <b>Opened:</b> 2007-04-16  <b>Last modified:</b> 2009-10-21</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.money.get.virtuals">issues</a> in [locale.money.get.virtuals].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
22.4.6.1.2 [locale.money.get.virtuals], para 3 says:
</p>

<blockquote><p>
If <tt>pos</tt> or <tt>neg</tt> is empty, the sign component is
optional, and if no sign is detected, the result is given the sign
that corresponds to the source of the empty string.
</p></blockquote>

<p>
The following objection has been raised:
</p>

<blockquote><p>
A <tt>negative_sign</tt> of "" means "there is no
way to write a negative sign" not "any null sequence is a negative
sign, so it's always there when you look for it".
</p></blockquote>

<p>
[Plum ref _222612Y32]
</p>

<p><i>[
Kona (2007): Bill to provide proposed wording and interpretation of existing wording.
]</i></p>


<p>
Related to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#669">669</a>.
</p>

<p><i>[
2009-05-17 Howard adds:
]</i></p>


<blockquote>
<p>
I disagree that a <tt>negative_sign</tt> of "" means "there is no
way to
write a negative sign". The meaning requires the sentences of
22.4.6.1.2 [locale.money.get.virtuals] p3 following that quoted above
to be
taken into account:
</p>

<blockquote>
-3- ... If <tt>pos</tt> or <tt>neg</tt> is empty, the sign component is
optional, and if no sign is detected, the result is given the sign that
corresponds to the source of the empty string. Otherwise, the character
in the indicated position must match the first character of <tt>pos</tt>
or <tt>neg</tt>, and the result is given the corresponding sign. If the
first character of <tt>pos</tt> is equal to the first character of
<tt>neg</tt>, or if both strings are empty, the result is given a
positive sign.
</blockquote>

<p>
So a <tt>negative_sign</tt> of "" means "there is no way to write a
negative sign" only when <tt>positive_sign</tt> is also "".  However
when <tt>negative_sign</tt> is "" and <tt>postive_sign.size() &gt;
0</tt>, then one writes a negative value by not writing the
<tt>postive_sign</tt> in the position indicated by
<tt>money_base::sign</tt>.
For example:
</p>

<blockquote><pre>pattern = {symbol, sign, value, none}
positive_sign = "+"
negative_sign = ""
$123   // a negative value, using optional sign
$+123  // a positive value
$-123  // a parse error
</pre></blockquote>

<p>
And:
</p>

<blockquote><pre>pattern = {symbol, sign, value, none}
positive_sign = ""
negative_sign = ""
$123   // a positive value, no sign possible
$+123  // a parse error
$-123  // a parse error
</pre></blockquote>


<p>
And (regarding <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#669">669</a>):
</p>

<blockquote><pre>pattern = {symbol, sign, value, none}
positive_sign = "-"
negative_sign = "-"
$123   // a parse error, sign is mandatory
$+123  // a parse error
$-123  // a positive value
</pre></blockquote>


<p>
The text seems both unambiguous and clear to me.  I recommend NAD for
both this issue and <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#669">669</a>.  However I would have no
objection to adding examples such as those above.
</p>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
This discussion applies equally to issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#669">669</a> (q.v.).
Howard has added examples above,
and recommends either NAD or a resolution that adds his (or similar) examples
to the Working Paper.
</p>
<p>
Alan would like to rewrite paragraph 3.
</p>
<p>
We recommend moving to NAD.
Anyone who feels strongly about adding the examples
is invited to submit corresponding wording.
We further recommend issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#669">669</a> be handled identically.
</p>
</blockquote>

<p><i>[
2009-07-14 Alan reopens with improved wording.
]</i></p>


<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
No consensus for closing as NAD.  Leave in Review.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD.  Agreed that the original assessment as NAD was correct.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 22.4.6.1.2 [locale.money.get.virtuals] p3:
</p>

<blockquote>
-3- <del>If the first character (if any) in the string pos returned by
<tt>mp.positive_sign()</tt> or the string <tt>neg</tt> returned by
<tt>mp.negative_sign()</tt> is recognized in the position indicated by
sign in the format pattern, it is consumed and any remaining characters
in the string are required after all the other format components.
[<i>Example:</i> If <tt>showbase</tt> is off, then for a <tt>neg</tt>
value of "()" and a currency symbol of "L", in "(100 L)" the "L" is
consumed; but if <tt>neg</tt> is "-", the "L" in "-100 L" is not
consumed. -- <i>end example</i>] If <tt>pos</tt> or <tt>neg</tt> is
empty, the sign component is optional, and if no sign is detected, the
result is given the sign that corresponds to the source of the empty
string. Otherwise, the character in the indicated position must match
the first character of <tt>pos</tt> or <tt>neg</tt>, and the result is
given the corresponding sign. If the first character of <tt>pos</tt> is
equal to the first character of <tt>neg</tt>, or if both strings are
empty, the result is given a positive sign.</del>

<ins>The sign pattern strings <tt>pos</tt> and <tt>neg</tt> are returned by
<tt>mp.positive_sign()</tt> and <tt>mp.negative_sign()</tt> respectively. A sign pattern
is matched if its first character is recognized in <tt>s</tt> in the position
indicated by <tt>sign</tt> in the format pattern, or if the pattern is empty and
there is no sign recognized in <tt>s</tt>. A match is required to occur. If both
patterns are matched, the result is given a positive sign, otherwise the
result is given the sign corresponding to the matched pattern. 
If the pattern contains more than one character, the characters after the first 
must be matched in <tt>s</tt> after all other format components. 
If any sign
characters are matched, <tt>s</tt> is consumed up to and including those characters.
[<i>Example:</i> If <tt>showbase</tt> is off, then for a <tt>neg</tt>
value of "<tt>()</tt>" and a currency symbol of "<tt>L</tt>", in
"<tt>(100 L)</tt>" the entire string is consumed; but for a <tt>neg</tt>
value of "<tt>-</tt>", in "<tt>-100 L</tt>", the string is consumed
through the second "<tt>0</tt>" (the space and "<tt>L</tt>" are not consumed). &#8212; <i>end
example</i>] </ins>
</blockquote>





<hr>
<h3><a name="669"></a>669. Equivalent postive and negative signs in <tt>money_get</tt></h3>
<p><b>Section:</b> 22.4.6.1.2 [locale.money.get.virtuals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Thomas Plum <b>Opened:</b> 2007-04-16  <b>Last modified:</b> 2009-07-13</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.money.get.virtuals">issues</a> in [locale.money.get.virtuals].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
22.4.6.1.2 [locale.money.get.virtuals], para 3 sentence 4 says:
</p>

<blockquote><p>
If the first character of <tt>pos</tt> is equal to the first character of <tt>neg</tt>, 
or if both strings are empty, the result is given a positive sign.
</p></blockquote>

<p>
One interpretation is that an input sequence must match either the
positive pattern or the negative pattern, and then in either event it
is interpreted as positive.  The following objections has been raised:
</p>

<blockquote><p>
The input can successfully match only a positive sign, so the negative
pattern is an unsuccessful match.
</p></blockquote>

<p>
[Plum ref _222612Y34, 222612Y51b]
</p>

<p><i>[
Bill to provide proposed wording and interpretation of existing wording.
]</i></p>


<p><i>[
2009-05-17 See Howard's comments in related issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#668">668</a>.
]</i></p>


<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
This discussion applies equally to issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#668">668</a> (q.v.).
Howard has added examples there,
and recommends either NAD or a resolution that adds his (or similar) examples
to the Working Paper.
</p>
<p>
We recommend moving to NAD.
Anyone who feels strongly about adding the examples
is invited to submit corresponding wording.
We further recommend issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#668">668</a> be handled identically.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="670"></a>670. <tt>money_base::pattern</tt> and <tt>space</tt></h3>
<p><b>Section:</b> 22.4.6.3 [locale.moneypunct] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Thomas Plum <b>Opened:</b> 2007-04-16  <b>Last modified:</b> 2008-09-22</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#836">836</a></p>
<p><b>Discussion:</b></p>
<p>
22.4.6.3 [locale.moneypunct], para 2 says:
</p>

<blockquote><p>
The value <tt>space</tt> indicates that at least one space is required at 
that position.
</p></blockquote>

<p>
The following objection has been raised:
</p>

<blockquote><p>
Whitespace is optional when matching space. (See 22.4.6.1.2 [locale.money.get.virtuals], para 2.)
</p></blockquote>

<p>
[Plum ref _22263Y22]
</p>

<p><i>[
Kona (2007): Bill to provide proposed wording. We agree that C++03 is
ambiguous, and that we want C++0X to say "space" means 0 or more
whitespace characters on input.
]</i></p>




<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="683"></a>683. regex_token_iterator summary error</h3>
<p><b>Section:</b> 28.12.2 [re.tokiter] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Eric Niebler <b>Opened:</b> 2007-06-02  <b>Last modified:</b> 2009-03-09</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#re.tokiter">issues</a> in [re.tokiter].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
28.12.2 [re.tokiter], p3 says:
</p>
<blockquote>
<p>
After it is constructed, the iterator finds and stores a value
<tt>match_results&lt;BidirectionalIterator&gt;</tt> position and sets the
internal count <tt>N</tt> to zero.
</p>
</blockquote>

<p>
Should read:
</p>

<blockquote>
<p>
After it is constructed, the iterator finds and stores a value
<tt><del>match_results</del><ins>regex_iterator</ins>&lt;BidirectionalIterator<ins>, charT, traits</ins>&gt;</tt>
position and sets the internal count <tt>N</tt> to zero.
</p>
</blockquote>

<p><i>[
John adds:
]</i></p>


<blockquote><p>
Yep, looks like a typo/administrative fix to me.
</p></blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="684"></a>684. Unclear which members of match_results should be used in comparison</h3>
<p><b>Section:</b> 28.10 [re.results] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Nozomu Katoo <b>Opened:</b> 2007-05-27  <b>Last modified:</b> 2008-03-12</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#re.results">issues</a> in [re.results].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 28.4 [re.syn] of N2284, two template functions 
are declared here: 
</p>
<blockquote><pre>// 28.10, class template match_results: 
  &lt;<i>snip</i>&gt;
// match_results comparisons 
  template &lt;class BidirectionalIterator, class Allocator&gt; 
    bool operator== (const match_results&lt;BidirectionalIterator, Allocator&gt;&amp; m1, 
                     const match_results&lt;BidirectionalIterator, Allocator&gt;&amp; m2); 
  template &lt;class BidirectionalIterator, class Allocator&gt; 
    bool operator!= (const match_results&lt;BidirectionalIterator, Allocator&gt;&amp; m1, 
                     const match_results&lt;BidirectionalIterator, Allocator&gt;&amp; m2); 

// 28.10.6, match_results swap:
</pre></blockquote>

<p>
But the details of these two bool operator functions (i.e., which members of
<tt>match_results</tt> should be used in comparison) are not described in any
following sections.
</p>

<p><i>[
John adds:
]</i></p>


<blockquote><p>
That looks like a bug: <tt>operator==</tt> should return <tt>true</tt> only if
the two objects refer to the same match - ie if one object was constructed as a
copy of the other.
</p></blockquote>

<p><i>[
Kona (2007): Bill and Pete to add minor wording to that proposed in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2409.pdf">N2409</a>.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
Add a new section after 28.10.6 [re.results.swap], which reads:
</p>
<p>
28.10.7 match_results non-member functions.
</p>

<blockquote>
<pre>template&lt;class BidirectionalIterator, class Allocator&gt; 
  bool operator==(const match_results&lt;BidirectionalIterator, Allocator&gt;&amp; m1, 
                  const match_results&lt;BidirectionalIterator, Allocator&gt;&amp; m2);
</pre>
<blockquote>
<p>
<i>Returns:</i> <tt>true</tt> only if the two objects refer to the same match.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>template&lt;class BidirectionalIterator, class Allocator&gt; 
  bool operator!=(const match_results&lt;BidirectionalIterator, Allocator&gt;&amp; m1, 
                  const match_results&lt;BidirectionalIterator, Allocator&gt;&amp; m2);
</pre>
<blockquote>
<p>
<i>Returns:</i> <tt>!(m1 == m2)</tt>.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>template&lt;class BidirectionalIterator, class Allocator&gt; 
  void swap(match_results&lt;BidirectionalIterator, Allocator&gt;&amp; m1, 
            match_results&lt;BidirectionalIterator, Allocator&gt;&amp; m2);
</pre>
<blockquote>
<p>
<i>Returns:</i> <tt>m1.swap(m2)</tt>.
</p>
</blockquote>
</blockquote>


<p><i>[
Bellevue:  Proposed wording now in WP.
]</i></p>





<hr>
<h3><a name="686"></a>686. Unique_ptr and shared_ptr fail to specify non-convertibility to int for unspecified-bool-type</h3>
<p><b>Section:</b> 20.8.14.2.4 [unique.ptr.single.observers], 20.8.15.2.5 [util.smartptr.shared.obs] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Beman Dawes <b>Opened:</b> 2007-06-14  <b>Last modified:</b> 2008-02-27</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The standard library uses the <tt>operator <i>unspecified-bool-type</i>() const</tt> idiom in
five places. In three of those places (20.7.15.2.3 [func.wrap.func.cap], function capacity 
for example) the returned value is constrained to disallow
unintended conversions to int. The standardese is
</p>
<blockquote><p>
The return type shall not be convertible to <tt>int</tt>.
</p></blockquote>
<p>
This constraint is omitted for <tt>unique_ptr</tt> and <tt>shared_ptr</tt>. It should be added for those.
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
Close as NAD. Accepting paper
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2435.htm">N2435</a>
makes it irrelevant.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
To the <i>Returns</i> paragraph for <tt>operator <i>unspecified-bool-type</i>()
const</tt>
of 20.8.14.2.4 [unique.ptr.single.observers] paragraph 11 and
20.8.15.2.5 [util.smartptr.shared.obs] paragraph 16, add the sentence:
</p>
<blockquote><p>
The return type shall not be convertible to <tt>int</tt>.
</p></blockquote>


<p><i>[
Kona (2007): Uncertain if <tt>nullptr</tt> will address this issue.
]</i></p>





<hr>
<h3><a name="690"></a>690. abs(long long) should return long long</h3>
<p><b>Section:</b> 26.8 [c.math] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Niels Dekker <b>Opened:</b> 2007-06-10  <b>Last modified:</b> 2007-07-25</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#c.math">issues</a> in [c.math].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Quoting the latest draft (n2135), 26.8 [c.math]: 
</p>

<blockquote>
<p>
The added signatures are:
</p>
<blockquote><pre>long abs(long); // labs()
long abs(long long); // llabs()
</pre></blockquote>
</blockquote>
<p>
Shouldn't <tt>abs(long long)</tt> have <tt>long long</tt> as return type?
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change 26.8 [c.math]: 
</p>
<blockquote><pre><ins>long </ins>long abs(long long); // llabs()
</pre></blockquote>


<p><b>Rationale:</b></p>
Had already been fixed in the WP by the time the LWG reviewed this.





<hr>
<h3><a name="697"></a>697. New <tt>&lt;system_error&gt;</tt> header leads to name clashes</h3>
<p><b>Section:</b> 19.5 [syserr] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2007-06-24  <b>Last modified:</b> 2008-01-06</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#syserr">issues</a> in [syserr].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The most recent state of 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2241.html">N2241</a>
as well as the current draft
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2284.pdf">N2284</a>
(section 19.5 [syserr], p.2) proposes a
new
enumeration type <tt>posix_errno</tt> immediatly in the namespace <tt>std</tt>. One of
the enumerators has the name <tt>invalid_argument</tt>, or fully qualified:
<tt>std::invalid_argument</tt>. This name clashes with the exception type
<tt>std::invalid_argument</tt>, see 19.2 [std.exceptions]/p.3. This clash makes
e.g. the following snippet invalid:
</p>

<blockquote><pre>#include &lt;system_error&gt;
#include &lt;stdexcept&gt;

void foo() { throw std::invalid_argument("Don't call us - we call you!"); }
</pre></blockquote>

<p>
I propose that this enumeration type (and probably the remaining parts
of
<tt>&lt;system_error&gt;</tt> as well) should be moved into one additional inner
namespace, e.g. <tt>sys</tt> or <tt>system</tt> to reduce foreseeable future clashes
due
to the great number of members that <tt>std::posix_errno</tt> already contains
(Btw.: Why has the already proposed <tt>std::sys</tt> sub-namespace from
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2066.html">N2066</a>
been rejected?). A further clash <em>candidate</em> seems to be
<tt>std::protocol_error</tt>
(a reasonable name for an exception related to a std network library,
I guess).
</p>

<p>
Another possible resolution would rely on the proposed strongly typed
enums,
as described in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2213.pdf">N2213</a>.
But maybe the forbidden implicit conversion to integral types would
make
these enumerators less attractive in this special case?
</p>


<p><b>Proposed resolution:</b></p>
<p>
Fixed by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2422.htm#Issue7">issue 7 of N2422</a>.
</p>






<hr>
<h3><a name="701"></a>701. assoc laguerre poly's</h3>
<p><b>Section:</b> TR1 5.2.1.1 [tr.num.sf.Lnm] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Christopher Crawford <b>Opened:</b> 2007-06-30  <b>Last modified:</b> 2009-07-13</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I see that the definition the associated Laguerre
polynomials TR1 5.2.1.1 [tr.num.sf.Lnm] has been corrected since
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1687.pdf">N1687</a>.
However, the draft standard only specifies ranks of integer value <tt>m</tt>,
while the associated Laguerre polynomials are actually valid for real
values of <tt>m &gt; -1</tt>.  In the case of non-integer values of <tt>m</tt>, the
definition  <tt><i>L</i><sub>n</sub><sup>(m)</sup> = (1/n!)e<sup>x</sup>x<sup>-m</sup> (d/dx)<sup>n</sup> (e<sup>-x</sup>x<sup>m+n</sup>)</tt>
must be used, which also holds for integer values of <tt>m</tt>.  See
Abramowitz &amp; Stegun, 22.11.6 for the general case, and 22.5.16-17 for
the integer case.  In fact fractional values are most commonly used in
physics, for example to <tt>m = +/- 1/2</tt> to describe the harmonic
oscillator in 1 dimension, and <tt>1/2, 3/2, 5/2, ...</tt> in 3
dimensions.
</p>
<p>
If I am correct, the calculation of the more general case is no
more difficult, and is in fact the function implemented in the GNU
Scientific Library.  I would urge you to consider upgrading the 
standard, either adding extra functions for real <tt>m</tt> or switching the
current ones to <tt>double</tt>.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We understand the issue, and have opted not to extend as recommended.
</p>
<p>
Move to NAD.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="702"></a>702. Restriction in associated Legendre functions</h3>
<p><b>Section:</b> TR1 5.2.1.2 [tr.num.sf.Plm] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Christopher Crawford <b>Opened:</b> 2007-06-30  <b>Last modified:</b> 2009-07-13</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
One other small thing, in TR1 5.2.1.2 [tr.num.sf.Plm], the restriction should  be
<tt>|x| &lt;= 1</tt>, not <tt>x &gt;= 0</tt>.</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
The error has been corrected in the pending IS.
</p>
<p>
Move to NAD.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="707"></a>707. null pointer constant for <tt>exception_ptr</tt></h3>
<p><b>Section:</b> 18.8.5 [propagation] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Jens Maurer <b>Opened:</b> 2007-07-20  <b>Last modified:</b> 2008-02-25</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#propagation">active issues</a> in [propagation].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#propagation">issues</a> in [propagation].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p>
From the Toronto Core wiki:
</p>

<p>
What do you mean by "null pointer constant"? How do you guarantee that
<tt>exception_ptr() == 1</tt> doesn't work?  Do you even want to prevent that?
What's the semantics?  What about <tt>void *p = 0; exception_ptr() == p</tt>?
Maybe disallow those in the interface, but how do you do that with
portable C++? Could specify just "make it work".
</p>

<p>
Peter's response:
</p>

<p>
null pointer constant as defined in 4.10 [conv.ptr]. Intent is "just make it
work", can be implemented as assignment operator taking a unique pointer
to member, as in the unspecified bool type idiom.
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
<p>
Original implementation was possible using the "unspecified-null-pointer" idiom, similar to unspecified-bool.
</p>
<p>
Even simpler now with nullptr_t.
</p>
<p>
NAD Rationale : null pointer constant is a perfectly defined term, and
while API is clearly implementable there is no need to spell out
implementation details.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="708"></a>708. Locales need to be per thread and updated for POSIX changes</h3>
<p><b>Section:</b> 22 [localization] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Future">NAD Future</a>
 <b>Submitter:</b> Peter Dimov <b>Opened:</b> 2007-07-28  <b>Last modified:</b> 2009-07-16</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#localization">issues</a> in [localization].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Future">NAD Future</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The POSIX "Extended API Set Part 4,"
</p>
<blockquote><p>
<a href="http://www.opengroup.org/sib/details.tpl?id=C065">http://www.opengroup.org/sib/details.tpl?id=C065</a>
</p></blockquote>
<p>
introduces extensions to the C locale mechanism that
allow multiple concurrent locales to be used in the same application
by introducing a type <tt>locale_t</tt> that is very similar to
<tt>std::locale</tt>, and a number of <tt>_l</tt> functions that make use of it.
</p>
<p>
The global locale (set by setlocale) is now specified to be per-
process. If a thread does not call <tt>uselocale</tt>, the global locale is
in effect for that thread. It can install a per-thread locale by
using <tt>uselocale</tt>.
</p>
<p>
There is also a nice <tt>querylocale</tt> mechanism by which one can obtain
the name (such as "de_DE") for a specific <tt>facet</tt>, even for combined
locales, with no <tt>std::locale</tt> equivalent.
</p>
<p>
<tt>std::locale</tt> should be harmonized with the new POSIX <tt>locale_t</tt>
mechanism and provide equivalents for <tt>uselocale</tt> and <tt>querylocale</tt>.
</p>

<p><i>[
Kona (2007): Bill and Nick to provide wording.
]</i></p>


<p><i>[
San Francisco: Bill and Nick still intend to provide wording, but this
is a part of the task to be addressed by the group that will look into
issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#860">860</a>.
]</i></p>


<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
<p>
It's our intention to stay in sync with WG14. If WG14 makes a decision
that requires a change in WG21 the issue will be reopened.
</p>
<p>
Move to NAD Future.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="717"></a>717. Incomplete <tt>valarray::operator[]</tt> specification in [valarray.access]</h3>
<p><b>Section:</b> 26.6.2.3 [valarray.access] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2007-08-27  <b>Last modified:</b> 2008-09-22</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#valarray.access">issues</a> in [valarray.access].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Since the return type of <tt>valarray</tt>'s <tt>operator[] const</tt> overload has been
changed to <tt>const T&amp;</tt> as described in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#389">389</a> several paragraphs of
the section 26.6.2.3 [valarray.access] are now
incompletely
specified, because many requirements and guarantees should now also
apply to the const overload. Most notably, the address and reference
guarantees should be extended to the const overload case.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change 26.6.2.3 [valarray.access]:
</p>

<blockquote>
<p>
-1- <del>When applied to a constant array, the subscript operator returns a
reference to the corresponding element of the array. When applied to a
non-constant array, t</del><ins>T</ins>he subscript operator returns a
reference to the corresponding element of the array.
</p>

<p>
-3- The expression <tt>&amp;a[i+j] == &amp;a[i] + j</tt> evaluates as <tt>true</tt> for all <tt>size_t i</tt>
and <tt>size_t j</tt> such that <tt>i+j</tt> is less 
than the length of the <del>non-constant</del> array <tt>a</tt>.
</p>

<p>
-4- Likewise, the expression <tt>&amp;a[i] != &amp;b[j]</tt> evaluates
as <tt>true</tt> for any two <del>non-constant</del> arrays <tt>a</tt> and
<tt>b</tt> and for any <tt>size_t i</tt> and <tt>size_t j</tt> such that
<tt>i</tt> is less than the length of <tt>a</tt> and <tt>j</tt> is less
than the length of <tt>b</tt>. This property indicates an absence of
aliasing and may be used to advantage by optimizing
compilers.<sup>281)</sup>
</p>

<p>
-5- The reference returned by the subscript operator for a<ins>n</ins> <del>non-constant</del> array is guaranteed to be valid until
the member function <tt>resize(size_t, T)</tt> (26.5.2.7) is called for that array or until the lifetime 
of that array ends, whichever happens first.
</p>

</blockquote>






<hr>
<h3><a name="718"></a>718. <tt>basic_string</tt> is not a sequence</h3>
<p><b>Section:</b> 21.4 [basic.string] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Bo Persson <b>Opened:</b> 2007-08-18  <b>Last modified:</b> 2009-07-16</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#basic.string">issues</a> in [basic.string].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Paragraph 21.4 [basic.string]/3 states:
</p>

<blockquote>
<p>
The class template <tt>basic_string</tt> conforms to the requirements for a 
Sequence (23.1.1) and for a Reversible Container (23.1).
</p>
</blockquote>

<p>
First of all, 23.2.3 [sequence.reqmts] is no longer "Sequence" but "Sequence container". 
Secondly, after the resent changes to containers (<tt>emplace</tt>, <tt>push_back</tt>, 
<tt>const_iterator</tt> parameters to <tt>insert</tt> and <tt>erase</tt>), <tt>basic_string</tt> is not 
even close to conform to the current requirements.
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
<ul>
<li>emplace, for example, may not make sense for strings. Is also likely suboptimal</li>
<li>with concepts do we need to maintain string as sequence container?</li>
<li>One approach might be to say something like: string is a sequence except it doesn't have these functions</li>
</ul>
<ul>
<li>basic_string already has push_back</li>
<li>const_iterator parameters to insert and erase should be added to basic_string</li>
<li>this leaves emplace to handle -- we have the following options:
<ul>
<li>option 1: add it to string even though it's optional</li>
<li>option 2: make emplace optional to sequences (move from table 89 to 90)</li>
<li>option 3: say string not sequence (the proposal),</li>
<li>option 4: add an exception to basic string wording.</li>
</ul>
</li>
</ul>
General consensus is to suggest option 2.
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
Move to NAD Editorial
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Remove this sentence, in recognition of the fact that <tt>basic_string</tt> is 
not just a <tt>vector</tt>-light for literal types, but something quite 
different, a string abstraction in its own right.
</p>





<hr>
<h3><a name="719"></a>719. <tt>std::is_literal</tt> type traits should be provided</h3>
<p><b>Section:</b> 20.6 [meta] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2007-08-25  <b>Last modified:</b> 2009-10-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#meta">issues</a> in [meta].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#750">750</a></p>
<p><b>Discussion:</b></p>
<p>
Since the inclusion of <tt>constexpr</tt> in the standard draft N2369 we have
a new type category "literal", which is defined in 3.9 [basic.types]/p.11:
</p>

<blockquote>
<p>
-11- A type is a <i>literal</i> type if it is:
</p>
<ul>
<li>a scalar type; or</li>
<li><p>a class type (clause 9) with</p>
<ul>
<li>a trivial copy constructor,</li>
<li>a trivial destructor,</li>
<li>at least one constexpr constructor other than the copy constructor,</li>
<li>no virtual base classes, and</li>
<li>all non-static data members and base classes of literal types; or</li>
</ul>
</li>
<li>an array of literal type.</li>
</ul>
</blockquote>

<p>
I strongly suggest that the standard provides a type traits for
literal types in 20.6.4.3 [meta.unary.prop] for several reasons:
</p>

<ol type="a">
<li>To keep the traits in sync with existing types.</li>
<li>I see many reasons for programmers to use this trait in template
   code to provide optimized template definitions for these types,
   see below.</li>
<li>A user-provided definition of this trait is practically impossible
to write portably.</li>
</ol>

<p>
The special problem of reason (c) is that I don't see currently a
way to portably test the condition for literal class types:
</p>

<blockquote>
<ul>
<li>at least one constexpr constructor other than the copy constructor,</li>
</ul>
</blockquote>



<p><i>[
Alisdair is considering preparing a paper listing a number of missing
type traits, and feels that it might be useful to handle them all
together rather than piecemeal. This would affect issue 719 and 750.
These two issues should move to OPEN pending AM paper on type traits.
]</i></p>


<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
Beman, Daniel, and Alisdair will work on a paper proposing new type traits.
</blockquote>

<p><i>[
Addressed in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2947.html">N2947</a>.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD Editorial.  Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2984.html">N2984</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
In 20.6.2 [meta.type.synop] in the group "type properties",
just below the line
</p>

<blockquote><pre>template &lt;class T&gt; struct is_pod;
</pre></blockquote>

<p>
add a new one:
</p>

<blockquote><pre>template &lt;class T&gt; struct is_literal;
</pre></blockquote>

<p>
In 20.6.4.3 [meta.unary.prop], table Type Property Predicates, just
below the line for the <tt>is_pod</tt> property add a new line:
</p>

<table border="1">
<tbody><tr>
<th>Template</th><th>Condition</th><th>Preconditions</th>
</tr>
<tr>
<td><tt>template &lt;class T&gt; struct is_literal;</tt></td>
<td><tt>T</tt> is a literal type (3.9)</td>
<td><tt>T</tt> shall be a complete type, an
array of unknown bound, or
(possibly cv-qualified) <tt>void</tt>.</td>
</tr>
</tbody></table>






<hr>
<h3><a name="721"></a>721. <tt>wstring_convert</tt> inconsistensies</h3>
<p><b>Section:</b> 22.3.3.2.2 [conversions.string] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Bo Persson <b>Opened:</b> 2007-08-27  <b>Last modified:</b> 2009-07-16</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#conversions.string">issues</a> in [conversions.string].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Paragraph 3 says that the <tt>Codecvt</tt> template parameter shall meet the 
requirements of <tt>std::codecvt</tt>, even though <tt>std::codecvt</tt> itself cannot 
be used (because of a protected destructor).
</p>

<p>
How are we going to explain this code to beginning programmers?
</p>

<blockquote><pre>template&lt;class I, class E, class S&gt;
struct codecvt : std::codecvt&lt;I, E, S&gt;
{
    ~codecvt()
    { }
};

void main()
{
    std::wstring_convert&lt;codecvt&lt;wchar_t, char, std::mbstate_t&gt; &gt; compiles_ok;
    
    std::wstring_convert&lt;std::codecvt&lt;wchar_t, char, std::mbstate_t&gt; &gt;   not_ok;
}
</pre></blockquote>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
Bill will propose a resolution.
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
<p>
codecvt isn't intended for beginning programmers. This is a regrettable
consequence of the original design of the facet.
</p>
<p>
Move to NAD.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="725"></a>725. Optional sequence container requirements column label</h3>
<p><b>Section:</b> 23.2.3 [sequence.reqmts] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> David Abrahams <b>Opened:</b> 2007-09-16  <b>Last modified:</b> 2008-09-22</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#sequence.reqmts">active issues</a> in [sequence.reqmts].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#sequence.reqmts">issues</a> in [sequence.reqmts].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Table 90: (Optional sequence container operations) states the
"assertion note pre/post-condition" of <tt>operator[]</tt> to be
</p>

<blockquote><pre>*(a.begin() + n)
</pre></blockquote>

<p>
Surely that's meant to be "operational semantics?"
</p>



<p><b>Proposed resolution:</b></p>
<blockquote>
<table border="1">
<caption>Table 90: Optional sequence container operations</caption>
<tbody><tr>
<th>expression</th> <th>return type</th> <th><del>assertion/note<br>pre/post-condition</del><br> <ins>operational semantics</ins></th> <th>container</th>
</tr>
</tbody></table>
</blockquote>






<hr>
<h3><a name="729"></a>729. Problem in [rand.req.eng]/3</h3>
<p><b>Section:</b> X [rand.req.eng] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Stephan Tolksdorf <b>Opened:</b> 2007-09-21  <b>Last modified:</b> 2008-02-27</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.req.eng">issues</a> in [rand.req.eng].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The 3rd table row in X [rand.req.eng]/3 requires random number engines to accept any 
arithmetic type as a seed, which is then casted to the engine's <tt>result_type</tt> and subsequently 
used for seeding the state of the engine. The requirement stated as "Creates an engine with 
initial state determined by <tt>static_cast&lt;X::result_type&gt;(s)</tt>" forces random number engines 
to either use a seeding method that completely depends on the <tt>result_type</tt> (see the discussion 
of seeding for the <tt>mersenne_twister_engine</tt> in point T2 above) or at least to throw away "bits 
of randomness" in the seed value if the <tt>result_type</tt> is smaller than the seed type. This seems 
to be inappropriate for many modern random number generators, in particular F2-linear or 
cryptographic ones, which operate on an internal bit array that in principle is independent of the 
type of numbers returned.
</p>

<p>
<b>Posible resolution:</b> I propose to change the wording to a version similar to "Creates an 
engine with initial state determined by <tt>static_cast&lt;UintType&gt;(s)</tt>, where <tt>UintType</tt> is an 
implementation specific unsigned integer type."
</p>

<p>
Additionally, the definition of s in X [rand.req.eng]/1 c) could be restricted to unsigned integer types.
</p>

<p>
Similarly, the type of the seed in X [rand.req.adapt]/3 e) could be left unspecified.
</p>

<p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2424.pdf">N2424</a>
for further discussion.
</p>

<p><i>[
Stephan Tolksdorf adds pre-Bellevue:
]</i></p>


<blockquote>
<p>
In reply to the discussion in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2424.pdf">N2424</a>
regarding this issue:
</p>
<p>
The descriptions of all engines and engine adaptors given in sections
26.5.3 [rand.eng] and 26.5.4 [rand.adapt] already specify the concrete
types of the integer arguments for seeding. Hence, relaxing the general
requirement in X [rand.req.eng] would not affect portability and
reproducibility of the standard library. Furthermore, it is not clear to
me what exactly the guarantee "with initial state determined by
<tt>static_cast&lt;X::result_type&gt;(s)</tt>" is useful for. On the other hand,
relaxing the requirement would allow developers to implement  other
random number engines that do not have to cast all arithmetic seed
arguments to their result_types.
</p>
</blockquote>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
Propose close NAD for the reasons given in N2424.
</blockquote>




<p><b>Proposed resolution:</b></p>
<p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2424.pdf">N2424</a>
for further discussion.
</p>

<p><i>[
Stephan Tolksdorf adds pre-Bellevue:
]</i></p>


<blockquote>
<p>
Change row 3 of table 105 "Random number engine requirements" in X [rand.req.eng]/3
</p>

<blockquote>
Creates an engine with initial state determined by
<tt><del>static_cast&lt;X::result_type&gt;(</del>s<del>)</del></tt>
</blockquote>

<p>
Similarly, change X [rand.req.adapt]/3 e)
</p>

<blockquote>
When <tt>X::X</tt> is invoked with <del>an <tt>X::result_type</tt></del> value <tt>s</tt>
<ins>of arithmetic type (3.9.1)</ins>, ...
</blockquote>

</blockquote>






<hr>
<h3><a name="730"></a>730. Comment on [rand.req.adapt]/3 e)</h3>
<p><b>Section:</b> X [rand.req.adapt] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Stephan Tolksdorf <b>Opened:</b> 2007-09-21  <b>Last modified:</b> 2008-02-27</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
If an engine adaptor is invoked with an argument of type <tt>seed_seq</tt>, then all base 
engines are specified to be seeded with this <tt>seed_seq</tt>. As <tt>seed_seq</tt>'s randomization method is 
qualified as constant, this procedure will ef fectively initialize all base engines with the same seed 
(though the resulting state might still dif fer to a certain degree if the engines are of different types). 
It is not clear whether this mode of operation is in general appropriate, hence -- as far as the 
stated requirements are of general nature and not just specific to the engine adaptors provided by 
the library -- it might be better to leave the behaviour unspecified, since the current definition of 
<tt>seed_seq</tt> does not allow for a generally satisfying specification.
</p>

<p>
<b>Posssible resolution:</b> [As above]
</p>

<p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2424.pdf">N2424</a>
for further discussion.
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
Close NAD for the reasons given in N2424.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2424.pdf">N2424</a>
for the proposed resolution.
</p>





<hr>
<h3><a name="731"></a>731. proposal for a customizable <tt>seed_seq</tt></h3>
<p><b>Section:</b> 26.5.7.1 [rand.util.seedseq] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Stephan Tolksdorf <b>Opened:</b> 2007-09-21  <b>Last modified:</b> 2008-02-27</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.util.seedseq">issues</a> in [rand.util.seedseq].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The proper way to seed random number engines seems to be the most frequently 
discussed issue of the 26.5 [rand] proposal. While the new <tt>seed_seq</tt> approach is already rather 
general and probably sufficient for most situations, it is unlikely to be optimal in every case (one 
problem was pointed out in point T5 above). In some situations it might, for instance, be better to 
seed the state with a cryptographic generator. 
</p>
<p>
In my opinion this is a pretty strong argument for extending the standard with a simple facility to 
customize the seeding procedure. This could, for example, be done with the following minimal 
changes:
</p>

<p>
<b>Possible resolution:</b>
</p>

<ol type="a">
<li>
Turn the interface specification of 26.5.7.1 [rand.util.seedseq]/2 into a "SeedSeq" requirement, where the 
exact behaviour of the constructors and the randomize method are left unspecified and where the
const qualification for randomize is removed. Classes implementing this interface are additionally 
required to specialize the traits class in c).
</li>
<li>
Provide the class <tt>seed_seq</tt> as a default implementation of the SeedSeq interface.
</li>
<li>
<p>
Supplement the <tt>seed_seq</tt> with a traits class
</p>
<blockquote><pre>template &lt;typename T&gt; 
struct is_seed_seq { static const bool value = false; }
</pre></blockquote>
<p>and the specialization</p>
<blockquote><pre>template &lt;&gt; 
struct is_seed_seq&lt;seed_seq&gt; { static const bool value = true; }
</pre></blockquote>
<p>which users can supplement with further specializations.</p>
</li>
<li>
Change X [rand.req.eng]/1 d) to "q is an lvalue of a type that fulfils the SeedSeq requirements", and 
modify the constructors and seed methods in 26.5.3 [rand.eng] appropriately (the actual implementation 
could be done using the SFINAE technique).
</li>
</ol>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
See N2424. Close NAD but note that "conceptizing" the library may cause
this problem to be solved by that route.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2424.pdf">N2424</a>
for the proposed resolution.
</p>





<hr>
<h3><a name="732"></a>732. Defect in [rand.dist.samp.genpdf]</h3>
<p><b>Section:</b> X [rand.dist.samp.genpdf] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Stephan Tolksdorf <b>Opened:</b> 2007-09-21  <b>Last modified:</b> 2009-03-09</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.dist.samp.genpdf">issues</a> in [rand.dist.samp.genpdf].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#795">795</a></p>
<p><b>Discussion:</b></p>
<p>
X [rand.dist.samp.genpdf] describes the interface for a distribution template that is 
meant to simulate random numbers from any general distribution given only the density and the 
support of the distribution. I'm not aware of any general purpose algorithm that would be capable 
of correctly and efficiently implementing the described functionality. From what I know, this is 
essentially an unsolved research problem. Existing algorithms either require more knowledge 
about the distribution and the problem domain or work only under very limited circumstances. 
Even the state of the art special purpose library UNU.RAN does not solve the problem in full 
generality, and in any case, testing and customer support for such a library feature would be a 
nightmare.
</p>

<p>
<b>Possible resolution:</b> For these reasons, I propose to delete section X [rand.dist.samp.genpdf].
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
<p>
Disagreement persists.
</p>
<p>
Objection to this issue is that this function takes a general functor.
The general approach would be to normalize this function, integrate it,
and take the inverse of the integral, which is not possible in general.
An example function is sin(1+n*x) -- for any spatial frequency that the
implementor chooses, there is a value of n that renders that choice
arbitrarily erroneous.
</p>
<p>
Correction: The formula above should instead read 1+sin(n*x).
</p>
<p>
Objector proposes the following possible compromise positions:
</p>
<ul>
<li>
rand.dist.samp.genpdf takes an number of points so that implementor need not guess.
</li>
<li>replace rand.disk.samp.genpdf with an extension to either or both
of the discrete functions to take arguments that take a functor and
number of points in place of the list of probabilities. Reference
issues 793 and 794.
</li>
</ul>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2813.pdf">N2813</a>
for the proposed resolution.
</p>


<p><b>Rationale:</b></p>
Addressed by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2836.pdf">N2836</a> "Wording Tweaks for Concept-enabled Random Number Generation in C++0X".





<hr>
<h3><a name="733"></a>733. Comment on [rand.req.dist]/9</h3>
<p><b>Section:</b> X [rand.req.dist] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Stephan Tolksdorf <b>Opened:</b> 2007-09-21  <b>Last modified:</b> 2008-02-27</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The requirement "P shall have a declaration of the form <tt>typedef X distribution_- 
type</tt>" effectively makes the use of inheritance for implementing distributions very inconvenient, 
because the child of a distribution class in general will not satisfy this requirement. In my opinion 
the benefits of having a typedef in the parameter class pointing back to the distribution class are 
not worth the hassle this requirement causes. [In my code base I never made use of the nested 
typedef but on several occasions could have profited from being able to use simple inheritance for 
the implementation of a distribution class.]
</p>

<p>
<b>Proposed resolution:</b> I propose to drop this requirement.
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
Close NAD for the reasons given in N2424. In practice it is not inconvenient to meet these requirements.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2424.pdf">N2424</a>
for the proposed resolution.
</p>





<hr>
<h3><a name="735"></a>735. Unfortunate naming</h3>
<p><b>Section:</b> 26.5.8.2.2 [rand.dist.bern.bin], 26.5.8.2.4 [rand.dist.bern.negbin] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Stephan Tolksdorf <b>Opened:</b> 2007-09-21  <b>Last modified:</b> 2008-02-27</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In my opinion the choice of name for the <tt>t</tt> parameter of the <tt>binomial_distribution</tt>
is very unfortunate. In virtually every internet reference, book and software implementation 
this parameter is called <tt>n</tt> instead, see for example Wikipedia, Mathworld, Evans et al. (1993) 
Statistical Distributions, 2nd E., Wiley, p. 38, the R statistical computing language, p. 926, 
Mathematica and Matlab.
</p>

<p>
Similarly, the choice of <tt>k</tt> for the parameter of the negative binomial distributions is rather unusual. 
The most common choice for the negative binomial distribution seems to be <tt>r</tt> instead.
</p>

<p>
Choosing unusual names for the parameters causes confusion among users and makes the 
interface unnecessarily inconvenient to use.
</p>

<p>
<b>Possible resolution:</b> For these reasons, I propose to change the name of the respective parameters
to <tt>n</tt> and <tt>r</tt>.
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
In N2424. NAD It has been around for a while. It is hardly universal,
there is prior art, and this would confuse people.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2424.pdf">N2424</a>
for the proposed resolution.
</p>





<hr>
<h3><a name="736"></a>736. Comment on [rand.dist.samp.discrete]</h3>
<p><b>Section:</b> 26.5.8.5.1 [rand.dist.samp.discrete] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Stephan Tolksdorf <b>Opened:</b> 2007-09-21  <b>Last modified:</b> 2008-02-27</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.dist.samp.discrete">issues</a> in [rand.dist.samp.discrete].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<ol type="a">
<li>
The specification for <tt>discrete_distribution</tt> requires the member <tt>probabilities()</tt>
to return a vector of <i>standardized</i> probabilities, which forces the implementation every time to 
divide each probability by the sum of all probabilities, as the sum will in practice almost never be 
exactly 1.0. This is unnecessarily inef ficient as the implementation would otherwise not need to 
compute the standardized probabilities at all and could instead work with the non-standardized 
probabilities and the sum. If there was no standardization the user would just get back the 
probabilities that were previously supplied to the distribution object, which to me seems to be the 
more obvious solution.
</li>
<li>
The behaviour of <tt>discrete_distribution</tt> is not specified in case the number of given
probabilities is larger than the maximum number representable by the IntType.
</li>
</ol>

<p>
<b>Possible resolution:</b> I propose to change the specification such that the non-standardized 
probabilities need to be returned and that an additional requirement is included for the number 
of probabilities to be smaller than the maximum of IntType.
</p>

<p><i>[
Stephan Tolksdorf adds pre-Bellevue:
]</i></p>


<blockquote>
<p>
In reply to the discussion in 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2424.pdf">N2424</a>
of this issue:
</p>
<p>
Rescaled floating-point parameter vectors can not be expected to compare
equal because of the limited precision of floating-point numbers.
My proposal would at least guarantee that a parameter
vector (of type double) passed into the distribution would compare equal
with the one returned by the <tt>probabilities()</tt> method. Furthermore, I do
not understand why "the changed requirement would lead to a significant
increase in the amount of state in the distribution object". A typical
implementation's state would increase by exactly one number: the sum of
all probabilities. The textual representation for serialization would
not need to grow at all. Finally, the proposed replacement "<tt>0 &lt; n &lt;=
numeric_limits&lt;IntType&gt;::max() + 1</tt>" makes the implementation
unnecessarily complicated, "<tt>0 &lt; n &lt;= numeric_limits&lt;IntType&gt;::max()</tt>"
would be better.
</p>
</blockquote>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
<p>
In N2424. We agree with the observation and the proposed resolution to
part b). We recommend the wording n &gt; 0 be replaced with 0 &lt; n
numeric_limits::max() + 1. However, we disagree with part a), as it
would interfere with the definition of parameters' equality. Further,
the changed requirement would lead to a significant increase in the
amount of state of the distribution object.
</p>

<p>
As it stands now, it is convenient, and the changes proposed make it
much less so.
</p>

<p>
NAD. Part a the current behavior is desirable. Part b, any constructor
can fail, but the rules under which it can fail do not need to be listed
here.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2424.pdf">N2424</a>
for the proposed resolution.
</p>

<p><i>[
Stephan Tolksdorf adds pre-Bellevue:
]</i></p>


<blockquote>
<p>
In 26.5.8.5.1 [rand.dist.samp.discrete]:
</p>

<p>
Proposed wording a):
</p>

<blockquote>
<p>
Changae in para. 2
</p>

<blockquote>
Constructs a <tt>discrete_distribution</tt> object with <tt>n=1</tt> and <tt>p<sub>0</sub> <ins>= w<sub>0</sub></ins> = 1</tt>
</blockquote>

<p>
and change in para. 5
</p>

<blockquote>
<i>Returns:</i> A <tt>vector&lt;double&gt;</tt> whose <tt>size</tt> member returns <tt>n</tt> and whose
<tt>operator[]</tt> member returns <del><tt>p<sub>k</sub></tt></del>
<ins>the weight <tt>w<sub>k</sub></tt> as a double value</ins>
when invoked with argument <tt>k</tt> for <tt>k = 0,
..., n-1</tt>
</blockquote>

</blockquote>

<p>
Proposed wording b):
</p>

<blockquote>
<p>
Change in para. 3:
</p>

<blockquote>
If <tt>firstW == lastW</tt>, let the sequence <tt>w</tt> have length <tt>n = 1</tt> and consist
of the single value <tt>w<sub>0</sub> = 1</tt>. Otherwise, <tt>[firstW,lastW)</tt> shall form a
sequence <tt>w</tt> of length <tt>n <del>&gt; 0</del></tt> 
<ins>such that <tt>0 &lt; n &lt;= numeric_limits&lt;IntType&gt;::max()</tt>,</ins>
and <tt>*firstW</tt> shall yield a value <tt>w<sub>0</sub></tt>
convertible to <tt>double</tt>. [<i>Note:</i> The values <tt>w<sub>k</sub></tt> are commonly known
as the weights . <i>-- end note</i>]
</blockquote>

</blockquote>

</blockquote>





<hr>
<h3><a name="737"></a>737. Comment on [rand.dist.samp.pconst]</h3>
<p><b>Section:</b> 26.5.8.5.2 [rand.dist.samp.pconst] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Stephan Tolksdorf <b>Opened:</b> 2007-09-21  <b>Last modified:</b> 2008-02-27</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.dist.samp.pconst">issues</a> in [rand.dist.samp.pconst].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<ol type="a">
<li>
The discussion in point T11 above regarding <tt>probabilities()</tt> similarly applies 
to the method <tt>densities()</tt> of <tt>piecewise_constant_distribution</tt>.
</li>
<li>
<p>
The design of the constructor
</p>
<blockquote><pre>template &lt;class InputIteratorB, class InputIteratorW&gt; 
piecewise_constant_distribution( InputIteratorB firstB, InputIteratorB lastB, 
                                 InputIteratorW firstW);
</pre></blockquote>
<p>
is unnecessarily unsafe, as there is no separate end-iterator given for the weights. I can't see 
any performance or convenience reasons that would justify the risks inherent in such a function 
interface, in particular the risk that input error might go unnoticed.
</p>
</li>
</ol>

<p>
<b>Possible resolution:</b> I propose to add an <tt>InputIteratorW lastW</tt> argument to the interface.
</p>

<p><i>[
Stephan Tolksdorf adds pre-Bellevue:
]</i></p>

<blockquote>
In reply to the discussion in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2424.pdf">N2424</a>
I'd like to make the same comments as for <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#736">736</a>.
</blockquote>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
In N2424. There is already precedent elsewhere in the library. Follows existing convention. NAD.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2424.pdf">N2424</a>
for the proposed resolution.
</p>

<p><i>[
Stephan Tolksdorf adds pre-Bellevue:
]</i></p>


<blockquote>
<p>
In 26.5.8.5.2 [rand.dist.samp.pconst]:
</p>

<p>
Proposed wording a)
</p>

<blockquote>
<p>
Change in para. 2
</p>
<blockquote>
Constructs a <tt>piecewise_constant_distribution</tt> object with <tt>n = 1</tt>, <tt>p<sub>0</sub> <ins>= w<sub>0</sub></ins> = 1</tt>,
<tt>b<sub>0</sub> = 0</tt>, and <tt>b<sub>1</sub> = 1</tt>
</blockquote>

<p>
and change in para. 5
</p>

<blockquote>
A <tt>vector&lt;result_type&gt;</tt> whose <tt>size</tt> member returns <tt>n</tt> and whose <tt>operator[]</tt>
member returns <del><tt>p<sub>k</sub></tt></del>
<ins>the weight <tt>w<sub>k</sub></tt> as a double value</ins>
when invoked with argument <tt>k</tt> for <tt>k = 0, ..., n-1</tt>
</blockquote>

</blockquote>

<p>
Proposed wording b)
</p>

<blockquote>
<p>
Change both occurrences of
</p>

<blockquote>
"piecewise_constant_distribution(InputIteratorB firstB, InputIteratorB lastB,
                                 InputIteratorW firstW<ins>, InputIteratorW lastW</ins>)
</blockquote>

<p>
and change in para. 3
</p>

<blockquote>
<del>the length of the sequence <tt>w</tt> starting from <tt>firstW</tt> shall be at least <tt>n</tt>,
<tt>*firstW</tt> shall return a value <tt>w<sub>0</sub></tt> that is convertible to <tt>double</tt>, and any
<tt>w<sub>k</sub></tt> for <tt>k &gt;= n</tt> shall be ignored by the distribution</del>
<ins><tt>[firstW, lastW)</tt> shall form a sequence <tt>w</tt> of length <tt>n</tt> whose leading element
<tt>w<sub>0</sub></tt> shall be convertible to <tt>double</tt></ins>
</blockquote>

</blockquote>


</blockquote>






<hr>
<h3><a name="738"></a>738. Editorial issue in [rand.adapt.disc]/3</h3>
<p><b>Section:</b> 26.5.4.1 [rand.adapt.disc] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Stephan Tolksdorf <b>Opened:</b> 2007-09-21  <b>Last modified:</b> 2008-09-22</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Since the template parameter <tt>p</tt> and <tt>r</tt> are of type <tt>size_t</tt>, the member <tt>n</tt> in the class 
exposition should have type <tt>size_t</tt>, too.
</p>


<p><b>Proposed resolution:</b></p>
<p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2424.pdf">N2424</a>
for the proposed resolution.
</p>





<hr>
<h3><a name="739"></a>739. Defect in [rand.util.canonical]/3</h3>
<p><b>Section:</b> 26.5.7.2 [rand.util.canonical] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Stephan Tolksdorf <b>Opened:</b> 2007-09-21  <b>Last modified:</b> 2008-02-27</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.util.canonical">issues</a> in [rand.util.canonical].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The complexity of <tt>generate_canonical</tt> is specified to be "exactly k=max(1, ceil(b/log2 
R)) invocations of g". This terms involves a logarithm that is not rounded and hence can not (in 
general) be computed at compile time. As this function template is performance critical, I propose 
to replace ceil(b/log2 R) with ceil(b/floor(log2 R)).
</p>

<p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2424.pdf">N2424</a>
for further discussion.
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
In N2424. Close NAD as described there.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2424.pdf">N2424</a>
for the proposed resolution.
</p>





<hr>
<h3><a name="741"></a>741. Const-incorrect <tt>get_deleter</tt> function for <tt>shared_ptr</tt></h3>
<p><b>Section:</b> 20.8.15.2.11 [util.smartptr.getdeleter] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2007-09-27  <b>Last modified:</b> 2008-02-27</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#util.smartptr.getdeleter">issues</a> in [util.smartptr.getdeleter].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The following issue was raised by Alf P. Steinbach in c.l.c++.mod:
</p>

<p>
According to the recent draft N2369, both the header memory synopsis
of 20.8 [memory] and 20.8.15.2.11 [util.smartptr.getdeleter] declare:
</p>

<blockquote><pre>template&lt;class D, class T&gt; D* get_deleter(shared_ptr&lt;T&gt; const&amp; p);
</pre></blockquote>

<p>
This allows to retrieve the pointer to a mutable deleter of a <tt>const
shared_ptr</tt> (if that owns one) and therefore contradicts the usual
philosophy that associated functors are either read-only (e.g.
<tt>key_comp</tt> or <tt>value_comp</tt> of <tt>std::map</tt>) or do at least reflect
the mutability of the owner (as seen for the both overloads of
<tt>unique_ptr::get_deleter</tt>).
Even the next similar counter-part of <tt>get_deleter</tt> - the two
overloads of <tt>function::target</tt> in the class template function
synopsis 20.7.15.2 [func.wrap.func] or in 20.7.15.2.5 [func.wrap.func.targ] - do
properly mirror the const-state of the owner.
</p>

<b>Possible proposed resolutions:</b>

<p>
Replace the declarations of <tt>get_deleter</tt> in the header <tt>&lt;memory&gt;</tt>
synopsis of 20.8 [memory] and in 20.8.15.2.11 [util.smartptr.getdeleter] by one of the
following alternatives (A) or (B):
</p>

<ol type="A">
<li>
Provide <b>only</b> the immutable variant. This would reflect the
current praxis of <tt>container::get_allocator()</tt>, <tt>map::key_comp()</tt>, or
<tt>map::value_comp</tt>.

<blockquote><pre>template&lt;class D, class T&gt; const D* get_deleter(shared_ptr&lt;T&gt; const&amp; p);
</pre></blockquote>
</li>
<li>
Just remove the function.
</li>
</ol>

<p>
Alberto Ganesh Barbati adds:
</p>

<ol start="3" type="A">
<li>
<p>
Replace it with two functions:
</p>
<blockquote><pre>template &lt;class D, class T&gt; D get_deleter(shared_ptr&lt;T&gt; const&amp;);
template &lt;class D, class T&gt; bool has_deleter(shared_ptr&lt;T&gt; const&amp;);
</pre></blockquote>

<p>
The first one would throw if <tt>D</tt> is the wrong type, while the latter would
never throw. This approach would reflect the current praxis of
<tt>use_facet/has_facet</tt>, with the twist of returning the deleter by value as
<tt>container::get_allocator()</tt> do.
</p>
</li>
</ol>

<p>
Peter Dimov adds:
</p>

<blockquote>
<p>
My favorite option is "not a defect". A, B and C break useful code.
</p>
</blockquote>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
Concern this is similar to confusing "pointer to const" with "a constant pointer".
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="745"></a>745. copy_exception API slices.</h3>
<p><b>Section:</b> 18.8.5 [propagation] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2007-10-10  <b>Last modified:</b> 2008-02-25</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#propagation">active issues</a> in [propagation].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#propagation">issues</a> in [propagation].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It could be I did not understand the design rationale, but I thought
copy_exception would produce an exception_ptr to the most-derived (dynamic)
type of the passed exception.  Instead it slices, which appears to be less
useful, and a likely source of FAQ questions in the future.
</p>
<p>
(Peter Dimov suggests NAD)
</p>

<p><i>[
Bellevue: 
]</i></p>


<blockquote>
<p>
How could this be implemented in a way that the dynamic type is cloned?
</p>
<p>
The feature is designed to create an exception_ptr from an object whose
static type is identical to the dynamic type and thus there is no
slicing involved.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="747"></a>747. We have 3 separate type traits to identify classes supporting no-throw operations</h3>
<p><b>Section:</b> 20.6.4.3 [meta.unary.prop] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2007-10-10  <b>Last modified:</b> 2009-07-16</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#meta.unary.prop">active issues</a> in [meta.unary.prop].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#meta.unary.prop">issues</a> in [meta.unary.prop].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
We have 3 separate type traits to identify classes supporting no-throw
operations, which are very useful when trying to provide exception safety
guarantees.  However, I'm not entirely clear on what the current wording
requires of a conforming implementation.  To quote from
<tt>has_nothrow_default_constructor</tt>:
</p>
<blockquote><p>
or <tt>T</tt> is a class type with a default constructor that is known not to throw
any exceptions
</p></blockquote>
<p>
What level of magic do we expect to deduce if this is known?
</p>
<p>
E.g.
</p>

<blockquote><pre>struct test{
 int x;
 test() : x() {}
};
</pre></blockquote>
<p>
Should I expect a conforming compiler to 
 <tt>assert( has_nothrow_constructor&lt;test&gt;::value )</tt>
</p>
<p>
Is this a QoI issue?
</p>
<p>
Should I expect to 'know' only if-and-only-if there is an inline definition
available?
</p>
<p>
Should I never expect that to be true, and insist that the user supplies an
empty throw spec if they want to assert the no-throw guarantee?
</p>
<p>
It would be helpful to maybe have a footnote explaining what is required,
but right now I don't know what to suggest putting in the footnote.
</p>
<p>
(agreement since is that trivial ops and explicit no-throws are required.
Open if QoI should be allowed to detect further)
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
This looks like a QoI issue.
In the case of trivial and nothrow it is known. Static analysis of the program is definitely into QoI.
Move to OPEN. Need to talk to Core about this.
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
<p>
This is QoI.
</p>
<p>
Move to NAD.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="748"></a>748. The is_abstract type trait is defined by reference to 10.4.</h3>
<p><b>Section:</b> 20.6.4.3 [meta.unary.prop] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2007-10-10  <b>Last modified:</b> 2009-05-01</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#meta.unary.prop">active issues</a> in [meta.unary.prop].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#meta.unary.prop">issues</a> in [meta.unary.prop].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I am trying to decide is a pure virtual function is a <i>necessary</i> as well as
sufficient requirement to be classified as abstract?
</p>
<p>
For instance, is the following (non-polymorphic) type considered abstract?
</p>
<blockquote><pre>struct abstract {
protected:
 abstract(){}
 abstract( abstract const &amp; ) {}
 ~abstract() {}
};
</pre></blockquote>
<p>
(Suggested that this may be NAD, with an editorial fix-up from Pete on the
core wording to make clear that abstract requires a pure virtual function)
</p>


<p><b>Proposed resolution:</b></p>
<p>
Core has clarified that the definition abstract is adequate. Issue withdrawn by submitter. NAD.
</p>





<hr>
<h3><a name="750"></a>750. The current definition for <tt>is_convertible</tt> requires that the type be
implicitly convertible, so explicit constructors are ignored.</h3>
<p><b>Section:</b> 20.6.5 [meta.rel] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2007-10-10  <b>Last modified:</b> 2009-09-13</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#meta.rel">issues</a> in [meta.rel].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#719">719</a></p>
<p><b>Discussion:</b></p>
<p>
With the pending arrival of explicit conversion functions though, I'm
wondering if we want an additional trait, <tt>is_explictly_convertible</tt>?
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
Alisdair is considering preparing a paper listing a number of missing
type traits, and feels that it might be useful to handle them all
together rather than piecemeal. This would affect issue 719 and 750.
These two issues should move to OPEN pending AM paper on type traits.
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
Duplicate of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#719">719</a> (for our purposes).
</blockquote>

<p><i>[
Addressed in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2947.html">N2947</a>.
]</i></p>




<p><b>Proposed resolution:</b></p>






<hr>
<h3><a name="751"></a>751. change pass-by-reference members of <tt>vector&lt;bool&gt;</tt> to pass-by-value?</h3>
<p><b>Section:</b> 23.3.7 [vector.bool] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2007-10-10  <b>Last modified:</b> 2009-07-16</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#vector.bool">issues</a> in [vector.bool].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
A number of vector&lt;bool&gt; members take const bool&amp; as arguments.
Is there any chance we could change them to pass-by-value or would I 
be wasting everyone's time if wrote up an issue?
</p>

<p><i>[
post Bellevue:
]</i></p>


<blockquote>
<p>
As we understand it, the original requester (Martin Sebor) would like
for implementations to be permitted to pass-by-value. Alisdair suggests
that if this is to be resolved, it should be resolved more generally,
e.g. in other containers as well.
</p>
<p>
We note that this would break ABI. However, we also suspect that this
might be covered under the "as-if" rule in section 1.9.
</p>
<p>
Many in the group feel that for vector&lt;bool&gt;, this is a "don't care",
and that at this point in the process it's not worth the bandwidth.
</p>
<p>
Issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#679">679</a> -- which was in ready status pre-Bellevue and is
now in the working paper -- is related to this, though not a duplicate.
</p>
<p>
Moving to Open with a task for Alisdair to craft a informative note to
be put whereever appropriate in the WP. This note would clarify places
where pass-by-const-ref can be transformed to pass-by-value under the
as-if rule.
</p>
</blockquote>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
<p>
This is really a clause 17 issue, rather than something specific to vector&lt;bool&gt;.
</p>
<p>
Move to Open. Alisdair to provide a resolution. Alternately, Howard can
close this as NAD and then open a new issue to handle the general issue
(rather than the vector&lt;bool&gt; one).
</p>
<p>
Howard:  Haven't yet opened new issue.  Lacking wording for it.
</p>
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
NAD.  Insufficient motivation to make any changes.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="754"></a>754. Ambiguous return clause for <tt>std::uninitialized_copy</tt></h3>
<p><b>Section:</b> 20.8.13.2 [uninitialized.copy] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2007-10-15  <b>Last modified:</b> 2008-07-02</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#uninitialized.copy">issues</a> in [uninitialized.copy].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
14882-2003, [lib.uninitialized.copy] is currently written as follows:
</p>

<blockquote>
<pre>template &lt;class InputIterator, class ForwardIterator&gt;
  ForwardIterator uninitialized_copy(InputIterator <i>first</i>, InputIterator <i>last</i>,
                                     ForwardIterator <i>result</i>);
</pre>
<blockquote>
<p>
-1- <i>Effects:</i>
</p>
<blockquote><pre>for (; first != last; ++result, ++first)
  new (static_cast&lt;void*&gt;(&amp;*result))
    typename iterator_traits&lt;ForwardIterator&gt;::value_type(*first);
</pre></blockquote>
<p>
-2- <i>Returns:</i> <tt><i>result</i></tt>
</p>
</blockquote>
</blockquote>

<p>
similarily for N2369, and its corresponding section
20.8.13.2 [uninitialized.copy].
</p>

<p>
It's not clear to me what the return clause is supposed to mean, I see
two
possible interpretations:
</p>

<ol type="a">
<li>
The notion of <tt><i>result</i></tt> is supposed to mean the value given by the
function parameter <tt><i>result</i></tt> [Note to the issue editor: Please use italics for
<tt><i>result</i></tt>].
This seems somewhat implied by recognizing that both the function
parameter
and the name used in the clause do have the same italic font.
</li>
<li>
The notion of "result" is supposed to mean the value of <tt><i>result</i></tt>
after the
preceding effects clause. This is in fact what all implementations I
checked
do (and which is probably it's intend, because it matches the
specification of <tt>std::copy</tt>).
</li>
</ol>

<p>
The problem is: I see nothing in the standard which grants that this
interpretation
is correct, specifically [lib.structure.specifications] or
17.5.1.4 [structure.specifications]
resp. do not clarify which "look-up" rules apply for names found in
the elements
of the detailed specifications - Do they relate to the corresponding
synopsis or
to the effects clause (or possibly other elements)? Fortunately most
detailed
descriptions are unambigious in this regard, e.g. this problem does
not apply
for <tt>std::copy</tt>.
</p>



<p><b>Proposed resolution:</b></p>
<p>
Change the wording of the return clause to say (20.8.13.2 [uninitialized.copy]):
</p>

<blockquote>
<p>
-2- <i>Returns:</i> <ins>The value of</ins> <tt><i>result</i></tt> <ins>after effects have taken place.</ins>
</p>
</blockquote>


<p><i>[
Bellevue:
]</i></p>


<blockquote>
Resolution: NAD editorial -- project editor to decide if change is
worthwhile. Concern is that there are many other places this might
occur.
</blockquote>




<hr>
<h3><a name="756"></a>756. Container adaptors push</h3>
<p><b>Section:</b> 23.3.5 [container.adaptors] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Paolo Carlini <b>Opened:</b> 2007-10-31  <b>Last modified:</b> 2008-06-18</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#container.adaptors">active issues</a> in [container.adaptors].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#container.adaptors">issues</a> in [container.adaptors].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
After n2369 we have a single <tt>push_back</tt> overload in the sequence containers,
of the "emplace" type. At variance with that, still in n2461, we have
two separate overloads, the C++03 one + one taking an rvalue reference
in the container adaptors. Therefore, simply from a consistency point of
view, I was wondering whether the container adaptors should be aligned
with the specifications of the sequence container themselves: thus have
a single <tt>push</tt> along the lines:
</p>

<blockquote><pre>template&lt;typename... _Args&gt;
void
push(_Args&amp;&amp;... __args)
  { c.push_back(std::forward&lt;_Args&gt;(__args)...); }
</pre></blockquote>

<p><i>[
Related to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#767">767</a>
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
Change 23.3.5.1.1 [queue.defn]:
</p>

<blockquote><pre><del>void push(const value_type&amp; x) { c.push_back(x); }</del>
<del>void push(value_type&amp;&amp; x) { c.push_back(std::move(x)); }</del>
<ins>template&lt;class... Args&gt; void push(Args&amp;&amp;... args) { c.push_back(std::forward&lt;Args&gt;(args)...); }</ins>
</pre></blockquote>

<p>
Change 23.3.5.2 [priority.queue]:
</p>

<blockquote><pre><del>void push(const value_type&amp; x) { c.push_back(x); }</del>
<del>void push(value_type&amp;&amp; x) { c.push_back(std::move(x)); }</del>
<ins>template&lt;class... Args&gt; void push(Args&amp;&amp;... args) { c.push_back(std::forward&lt;Args&gt;(args)...); }</ins>
</pre></blockquote>

<p>
Change 23.3.5.2.2 [priqueue.members]:
</p>

<blockquote>
<pre><del>void push(const value_type&amp; x);</del>
</pre>
<blockquote>
<p>
<del><i>Effects:</i></del>
</p>
<blockquote><pre><del>c.push_back(x);</del>
<del>push_heap(c.begin(), c.end(), comp);</del>
</pre></blockquote>
</blockquote>

<pre><ins>template&lt;class... Args&gt;</ins> void push(<del>value_type</del> <ins>Args</ins>&amp;&amp;<ins>...</ins> <del>x</del> <ins>args</ins>);
</pre>
<blockquote>
<p>
<i>Effects:</i>
</p>
<blockquote><pre>c.push_back(std::<del>move</del><ins>forward&lt;Args&gt;</ins>(<del>x</del> <ins>args</ins>)<ins>...</ins>);
push_heap(c.begin(), c.end(), comp);
</pre></blockquote>
</blockquote>
</blockquote>

<p>
Change 23.3.5.3.1 [stack.defn]:
</p>

<blockquote><pre><del>void push(const value_type&amp; x) { c.push_back(x); }</del>
<del>void push(value_type&amp;&amp; x) { c.push_back(std::move(x)); }</del>
<ins>template&lt;class... Args&gt; void push(Args&amp;&amp;... args) { c.push_back(std::forward&lt;Args&gt;(args)...); }</ins>
</pre></blockquote>



<p><b>Rationale:</b></p>
<p>
Addressed by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2680.pdf">N2680 Proposed Wording for Placement Insert (Revision 1)</a>.
</p>





<hr>
<h3><a name="757"></a>757. Typo in the synopsis of vector</h3>
<p><b>Section:</b> 23.3.6 [vector] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Paolo Carlini <b>Opened:</b> 2007-11-04  <b>Last modified:</b> 2008-07-02</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#vector">issues</a> in [vector].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In the synopsis 23.3.6 [vector], there is the signature:
</p>

<blockquote><pre>void insert(const_iterator position, size_type n, T&amp;&amp; x);
</pre></blockquote>

<p>
instead of:
</p>

<blockquote><pre>iterator insert(const_iterator position, T&amp;&amp; x);
</pre></blockquote>

<p>
23.3.6.4 [vector.modifiers] is fine.
</p>



<p><b>Proposed resolution:</b></p>
<p>
Change the synopsis in 23.3.6 [vector]:
</p>

<blockquote><pre>iterator insert(const_iterator position, const T&amp; x); 
<ins>iterator insert(const_iterator position, T&amp;&amp; x);</ins>
void     insert(const_iterator position, size_type n, const T&amp; x); 
<del>void     insert(const_iterator position, size_type n, T&amp;&amp; x);</del>
</pre></blockquote>





<hr>
<h3><a name="760"></a>760. The emplace issue</h3>
<p><b>Section:</b> 23.2 [container.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Future">NAD Future</a>
 <b>Submitter:</b> Paolo Carlini <b>Opened:</b> 2007-11-11  <b>Last modified:</b> 2009-07-17</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#container.requirements">active issues</a> in [container.requirements].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#container.requirements">issues</a> in [container.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Future">NAD Future</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In an emplace member function the function parameter pack may be bound
to a priori unlimited number of objects: some or all of them can be
elements of the container itself. Apparently, in order to conform to the
blanket statement 23.2 [container.requirements]/11, the
implementation must check all of them for that possibility. A possible
solution can involve extending the exception in 23.2 [container.requirements]/12 also to the emplace member. As a
side note, the <tt>push_back</tt> and <tt>push_front</tt> member
functions are luckily not affected by this problem, can be efficiently
implemented anyway
</p>

<p><i>[
Related to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#767">767</a>
]</i></p>


<p><i>[
Bellevue:
]</i></p>


<blockquote>
<p>
The proposed addition (13) is partially redundant with the existing
paragraph 12. Why was the qualifier "rvalues" added to paragraph 12? Why
does it not cover subelements and pointers?
</p>
<p>
Resolution: Alan Talbot to rework language, then set state to Review.
</p>
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
The problem is broader than emplace. The LWG doesn't
feel that it knows how to write wording that prohibits all of the
problematic use cases at this time.
</p>
<p>
NAD Future.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add after 23.2 [container.requirements]/12:
</p>

<blockquote>
<p>
-12- Objects passed to member functions of a container as rvalue
references shall not be elements of that container. No diagnostic
required.
</p>
<p>
<ins>
-13- Objects bound to the function parameter pack of the
<tt>emplace</tt> member function shall not be elements or sub-objects of
elements of the container. No diagnostic required.
</ins>
</p>

</blockquote>






<hr>
<h3><a name="763"></a>763. Renaming <tt>emplace()</tt> overloads</h3>
<p><b>Section:</b> 23.2.4 [associative.reqmts] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Sylvain Pion <b>Opened:</b> 2007-12-04  <b>Last modified:</b> 2008-03-12</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#associative.reqmts">active issues</a> in [associative.reqmts].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#associative.reqmts">issues</a> in [associative.reqmts].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The associative containers provide 2 overloads of <tt>emplace()</tt>:
</p>

<blockquote><pre>template &lt;class... Args&gt; pair&lt;iterator, bool&gt; emplace(Args&amp;&amp;... args);
template &lt;class... Args&gt; iterator emplace(const_iterator position, Args&amp;&amp;... args);
</pre></blockquote>

<p>
This is a problem if you mean the first overload while passing
a <tt>const_iterator</tt> as first argument.
</p>

<p><i>[
Related to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#767">767</a>
]</i></p>


<p><i>[
Bellevue:
]</i></p>


<blockquote>
</blockquote>
<p>
This can be disambiguated by passing "begin" as the first argument in
the case when the non-default choice is desired. We believe that desire
will be rare.
</p>
<p>
Resolution: Change state to NAD.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Rename one of the two overloads.
For example to <tt>emplace_here</tt>, <tt>hint_emplace</tt>...
</p>





<hr>
<h3><a name="764"></a>764. <tt>equal_range</tt> on unordered containers should return a <tt>pair</tt> of <tt>local_iterators</tt></h3>
<p><b>Section:</b> 23.2.5 [unord.req] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Joe Gottman <b>Opened:</b> 2007-11-29  <b>Last modified:</b> 2008-03-12</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#unord.req">active issues</a> in [unord.req].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#unord.req">issues</a> in [unord.req].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
    A major attribute of the unordered containers is that iterating 
though them inside a bucket is very fast while iterating between buckets 
can be much slower.  If an unordered container has a low load factor, 
iterating between the last iterator in one bucket and the next iterator, 
which is in another bucket, is <tt>O(bucket_count())</tt> which may be much 
larger than <tt>O(size())</tt>.
</p>
<p>
    If <tt>b</tt> is an non-const unordered container of type <tt>B</tt> and <tt>k</tt> is an 
object of it's <tt>key_type</tt>, then <tt>b.equal_range(k)</tt> currently returns 
<tt>pair&lt;B::iterator, B::iterator&gt;</tt>. Consider the following code:
</p>

<blockquote><pre>B::iterator lb, ub;
tie(lb, ub) = b.equal_range(k);
for (B::iterator it = lb; it != ub; ++it) {
        // Do something with *it
}
</pre></blockquote>

<p>
If <tt>b.equal_range(k)</tt> returns a non-empty range (i.e. <tt>b</tt> contains at least 
on element whose key is equivalent to <tt>k</tt>), then every iterator in the 
half-open range <tt>[lb, ub)</tt> will be in the same bucket, but <tt>ub</tt> will likely 
either be in a different bucket or be equal to <tt>b.end()</tt>.  In either case, 
iterating between <tt>ub - 1</tt> and <tt>ub</tt> could take a much longer time than 
iterating through the rest of the range.
</p>
<p>
If instead of returning <tt>pair&lt;iterator, iterator&gt;</tt>, <tt>equal_range</tt> were to 
return <tt>pair&lt;local_iterator, local_iterator&gt;</tt>, then <tt>ub</tt> (which, like <tt>lb</tt>, 
would now be a <tt>local_iterator</tt>) could be guaranteed to always be in the 
same bucket as <tt>lb</tt>. In the cases where currently <tt>ub</tt> is equal to <tt>b.end()</tt>
or is in a different bucket, <tt>ub</tt> would be equal to <tt>b.end(b.bucket(key))</tt>. 
  This would make iterating between <tt>lb</tt> and <tt>ub</tt> much faster, as every 
iteration would be constant time.
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
The proposed resolution breaks consistency with other container types
for dubious benefit, and iterators are already constant time.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change the entry for <tt>equal_range</tt> in Table 93 (23.2.5 [unord.req]) as follows:
</p>
<table border="1">
<tbody><tr>
<th>expression</th> <th>return type</th> <th>assertion/note pre/post-condition</th> <th>complexity</th>
</tr>

<tr>
<td><tt>b.equal_range(k)</tt></td>
<td><tt>pair&lt;<ins>local_</ins>iterator,<ins>local_</ins>iterator&gt;; pair&lt;const_<ins>local_</ins>iterator,const_<ins>local_</ins>iterator&gt;</tt> for <tt>const b</tt>.</td>
<td>Returns a range containing all elements with keys equivalent to <tt>k</tt>. Returns <tt>make_pair(b.end(<ins>b.bucket(key)</ins>),b.end(<ins>b.bucket(key)</ins>))</tt> if no such elements exist.</td>
<td>Average case &#920;<tt>(b.count(k))</tt>. Worst case &#920;<tt>(b.size())</tt>. </td>
</tr>
</tbody></table>





<hr>
<h3><a name="767"></a>767. Forwarding and backward compatibility</h3>
<p><b>Section:</b> 23 [containers] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Sylvain Pion <b>Opened:</b> 2007-12-28  <b>Last modified:</b> 2008-06-18</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#containers">active issues</a> in [containers].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#containers">issues</a> in [containers].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Playing with g++'s C++0X mode, I noticed that the following
code, which used to compile:
</p>

<blockquote><pre>#include &lt;vector&gt;

int main()
{
    std::vector&lt;char *&gt; v;
    v.push_back(0);
}
</pre></blockquote>

<p>
now fails with the following error message:
</p>

<blockquote>.../include/c++/4.3.0/ext/new_allocator.h: In member
function 'void __gnu_cxx::new_allocator&lt;_Tp&gt;::construct(_Tp*,
_Args&amp;&amp; ...) [with _Args = int, _Tp = char*]':
.../include/c++/4.3.0/bits/stl_vector.h:707: instantiated from 'void
std::vector&lt;_Tp, _Alloc&gt;::push_back(_Args&amp;&amp; ...) [with
_Args = int, _Tp = char*, _Alloc = std::allocator&lt;char*&gt;]'
test.cpp:6: instantiated from here
.../include/c++/4.3.0/ext/new_allocator.h:114: error: invalid
conversion from 'int' to 'char*'
</blockquote>

<p>
As far as I know, g++ follows the current draft here.
</p>
<p>
Does the committee really intend to break compatibility for such cases?
</p>

<p><i>[
Sylvain adds: 
]</i></p>


<blockquote>
<p>
I just noticed that <tt>std::pair</tt> has the same issue.
The following now fails with GCC's -std=c++0x mode:
</p>

<blockquote><pre>#include &lt;utility&gt;

int main()
{
   std::pair&lt;char *, char *&gt; p (0,0);
}
</pre></blockquote>

<p>
I have not made any general audit for such problems elsewhere.
</p>
</blockquote>

<p><i>[
Related to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#756">756</a>
]</i></p>


<p><i>[
Bellevue:
]</i></p>


<blockquote>
<p>
Motivation is to handle the old-style int-zero-valued NULL pointers.
Problem: this solution requires concepts in some cases, which some users
will be slow to adopt. Some discussion of alternatives involving
prohibiting variadic forms and additional library-implementation
complexity.
</p>
<p>
Discussion of "perfect world" solutions, the only such solution put
forward being to retroactively prohibit use of the integer zero for a
NULL pointer. This approach was deemed unacceptable given the large
bodies of pre-existing code that do use integer zero for a NULL pointer.
</p>
<p>
Another approach is to change the member names. Yet another approach is
to forbid the extension in absence of concepts.
</p>
<p>
Resolution: These issues (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#756">756</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#767">767</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#760">760</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#763">763</a>) will be subsumed into a
paper to be produced by Alan Talbot in time for review at the 2008
meeting in France. Once this paper is produced, these issues will be
moved to NAD.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add the following rows to Table 90 "Optional sequence container operations", 23.2.3 [sequence.reqmts]:
</p>

<blockquote>
<table border="1">
<tbody><tr>
<th>expression</th> <th>return type</th> <th>assertion/note<br>pre-/post-condition</th> <th>container</th>
</tr>

<tr>
<td>
<tt>a.push_front(t)</tt>
</td>
<td>
<tt>void</tt>
</td>
<td>
<tt>a.insert(a.begin(), t)</tt><br>
<i>Requires:</i> <tt>T</tt> shall be <tt>CopyConstructible</tt>.
</td>
<td>
<tt>list, deque</tt>
</td>
</tr>

<tr>
<td>
<tt>a.push_front(rv)</tt>
</td>
<td>
<tt>void</tt>
</td>
<td>
<tt>a.insert(a.begin(), rv)</tt><br>
<i>Requires:</i> <tt>T</tt> shall be <tt>MoveConstructible</tt>.
</td>
<td>
<tt>list, deque</tt>
</td>
</tr>

<tr>
<td>
<tt>a.push_back(t)</tt>
</td>
<td>
<tt>void</tt>
</td>
<td>
<tt>a.insert(a.end(), t)</tt><br>
<i>Requires:</i> <tt>T</tt> shall be <tt>CopyConstructible</tt>.
</td>
<td>
<tt>list, deque, vector, basic_string</tt>
</td>
</tr>

<tr>
<td>
<tt>a.push_back(rv)</tt>
</td>
<td>
<tt>void</tt>
</td>
<td>
<tt>a.insert(a.end(), rv)</tt><br>
<i>Requires:</i> <tt>T</tt> shall be <tt>MoveConstructible</tt>.
</td>
<td>
<tt>list, deque, vector, basic_string</tt>
</td>
</tr>

</tbody></table>
</blockquote>

<p>
Change the synopsis in 23.3.2 [deque]:
</p>

<blockquote><pre><ins>void push_front(const T&amp; x);</ins>
<ins>void push_front(T&amp;&amp; x);</ins>
<ins>void push_back(const T&amp; x);</ins>
<ins>void push_back(T&amp;&amp; x);</ins>
template &lt;class... Args&gt; <ins>requires Constructible&lt;T, Args&amp;&amp;...&gt;</ins> void push_front(Args&amp;&amp;... args);
template &lt;class... Args&gt; <ins>requires Constructible&lt;T, Args&amp;&amp;...&gt;</ins> void push_back(Args&amp;&amp;... args);
</pre></blockquote>

<p>
Change 23.3.2.3 [deque.modifiers]:
</p>

<blockquote><pre><ins>void push_front(const T&amp; x);</ins>
<ins>void push_front(T&amp;&amp; x);</ins>
<ins>void push_back(const T&amp; x);</ins>
<ins>void push_back(T&amp;&amp; x);</ins>
template &lt;class... Args&gt; <ins>requires Constructible&lt;T, Args&amp;&amp;...&gt;</ins> void push_front(Args&amp;&amp;... args);
template &lt;class... Args&gt; <ins>requires Constructible&lt;T, Args&amp;&amp;...&gt;</ins> void push_back(Args&amp;&amp;... args);
</pre></blockquote>

<p>
Change the synopsis in 23.3.4 [list]:
</p>

<blockquote><pre><ins>void push_front(const T&amp; x);</ins>
<ins>void push_front(T&amp;&amp; x);</ins>
<ins>void push_back(const T&amp; x);</ins>
<ins>void push_back(T&amp;&amp; x);</ins>
template &lt;class... Args&gt; <ins>requires Constructible&lt;T, Args&amp;&amp;...&gt;</ins> void push_front(Args&amp;&amp;... args);
template &lt;class... Args&gt; <ins>requires Constructible&lt;T, Args&amp;&amp;...&gt;</ins> void push_back(Args&amp;&amp;... args);
</pre></blockquote>

<p>
Change 23.3.4.3 [list.modifiers]:
</p>

<blockquote><pre><ins>void push_front(const T&amp; x);</ins>
<ins>void push_front(T&amp;&amp; x);</ins>
<ins>void push_back(const T&amp; x);</ins>
<ins>void push_back(T&amp;&amp; x);</ins>
template &lt;class... Args&gt; <ins>requires Constructible&lt;T, Args&amp;&amp;...&gt;</ins> void push_front(Args&amp;&amp;... args);
template &lt;class... Args&gt; <ins>requires Constructible&lt;T, Args&amp;&amp;...&gt;</ins> void push_back(Args&amp;&amp;... args);
</pre></blockquote>

<p>
Change the synopsis in 23.3.6 [vector]:
</p>

<blockquote><pre><ins>void push_back(const T&amp; x);</ins>
<ins>void push_back(T&amp;&amp; x);</ins>
template &lt;class... Args&gt; <ins>requires Constructible&lt;T, Args&amp;&amp;...&gt;</ins> void push_back(Args&amp;&amp;... args);
</pre></blockquote>

<p>
Change 23.3.6.4 [vector.modifiers]:
</p>

<blockquote><pre><ins>void push_back(const T&amp; x);</ins>
<ins>void push_back(T&amp;&amp; x);</ins>
template &lt;class... Args&gt; <ins>requires Constructible&lt;T, Args&amp;&amp;...&gt;</ins> void push_back(Args&amp;&amp;... args);
</pre></blockquote>




<p><b>Rationale:</b></p>
<p>
Addressed by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2680.pdf">N2680 Proposed Wording for Placement Insert (Revision 1)</a>.
</p>

<p>
If there is still an issue with pair, Howard should submit another issue.
</p>





<hr>
<h3><a name="773"></a>773. issues with random</h3>
<p><b>Section:</b> 26.5.8.1 [rand.dist.uni] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> P.J. Plauger <b>Opened:</b> 2008-01-14  <b>Last modified:</b> 2008-02-27</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.dist.uni">issues</a> in [rand.dist.uni].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<ol>
<li>
26.5.8.1.1 [rand.dist.uni.int] <tt>uniform_int</tt> constructor has changed the default
max constructor parameter from 9 (in TR1) to <tt>max()</tt>. The value
is arbitrary at best and shouldn't be lightly changed because
it breaks backward compatibility.
</li>

<li>
26.5.8.1.1 [rand.dist.uni.int] <tt>uniform_int</tt> has a parameter <tt>param</tt> that you can
provide on construction or <tt>operator()</tt>, set, and get. But there
is not even a hint of what this might be for.
</li>

<li>
26.5.8.1.2 [rand.dist.uni.real] <tt>uniform_real</tt>. Same issue as #2.
</li>
</ol>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
NAD. Withdrawn.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="784"></a>784. unique_lock::release</h3>
<p><b>Section:</b> 30.4.3.2.3 [thread.lock.unique.mod] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Constantine Sapuntzakis <b>Opened:</b> 2008-02-02  <b>Last modified:</b> 2008-02-27</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>unique_lock::release</tt> will probably lead to many mistakes where people
call <tt>release</tt> instead of <tt>unlock</tt>. I just coded such a mistake using the
boost pre-1.35 threads library last week.
</p>

<p>
In many threading libraries, a call with <tt>release</tt> in it unlocks the
lock (e.g. ReleaseMutex in Win32, java.util.concurrent.Semaphore).
</p>

<p>
I don't call <tt>unique_lock::lock</tt> much at all, so I don't get to see the
symmetry between <tt>::lock</tt> and <tt>::unlock</tt>. I usually use the constructor to
lock the mutex. So I'm left to remember whether to call <tt>release</tt> or
<tt>unlock</tt> during the few times I need to release the mutex before the scope
ends. If I get it wrong, the compiler doesn't warn me.
</p>

<p>
An alternative name for release may be <tt>disown</tt>.
</p>

<p>
This might be a rare case where usability is hurt by consistency with
the rest of the C++ standard (e.g. <tt>std::auto_ptr::release</tt>).
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
Change a name from release to disown. However prior art uses the release
name. Compatibility with prior art is more important that any possible
benefit such a change might make. We do not see the benefit for
changing. NAD
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change the synopsis in 30.4.3.2 [thread.lock.unique]:
</p>

<blockquote><pre>template &lt;class Mutex&gt; 
class unique_lock 
{ 
public:
   ...
   mutex_type* <del>release</del> <ins>disown</ins>();
   ...
};
</pre></blockquote>

<p>
Change 30.4.3.2.3 [thread.lock.unique.mod]:
</p>

<blockquote><pre>mutex_type *<del>release</del> <ins>disown</ins>();
</pre></blockquote>





<hr>
<h3><a name="785"></a>785. Random Number Requirements in TR1</h3>
<p><b>Section:</b> TR1 5.1.4.5 [tr.rand.eng.disc], TR1 5.1.4.6 [tr.rand.eng.xor] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> John Maddock <b>Opened:</b> 2008-01-15  <b>Last modified:</b> 2009-07-13</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Table 16 of TR1 requires that all Pseudo Random Number generators have a
</p>

<blockquote><pre>seed(integer-type s)
</pre></blockquote>

<p>
member function that is equivalent to:
</p>

<blockquote><pre>mygen = Generator(s)
</pre></blockquote>

<p>
But the generators <tt>xor_combine</tt> and <tt>discard_block</tt> have no such seed member, only the
</p>

<blockquote><pre>template &lt;class Gen&gt;
seed(Gen&amp;);
</pre></blockquote>

<p>
member, which will not accept an integer literal as an argument: something that appears to violate the intent of Table 16.
</p>

<p>
So... is this a bug in TR1?
</p>

<p>This is a real issue BTW, since the Boost implementation does adhere
to the requirements of Table 16, while at least one commercial
implementation does not and follows a strict adherence to sections
5.1.4.5 and 5.1.4.6 instead.
</p>

<p><i>[
Jens adds:
]</i></p>


<blockquote>
Both engines do have the necessary
constructor, therefore the omission of the <tt>seed()</tt> member
functions appears to be an oversight.
</blockquote>

<p><i>[
Post Summit Daniel adds:
]</i></p>


<blockquote>
Recommend NAD: <tt>xor_combine</tt> does no longer exist and <tt>discard_block[_engine]</tt>
has now the required seed overload accepting a <tt>result_type</tt>, which shall be an
unsigned integral type.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Move to NAD as recommended.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
NAD Recommended.
</p>





<hr>
<h3><a name="786"></a>786. Thread library timed waits, UTC and monotonic clocks</h3>
<p><b>Section:</b> 20.9 [time] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Christopher Kohlhoff, Jeff Garland <b>Opened:</b> 2008-02-03  <b>Last modified:</b> 2008-09-30</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#time">issues</a> in [time].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The draft C++0x thread library requires that the time points of type
<tt>system_time</tt> and returned by <tt>get_system_time()</tt> represent Coordinated
Universal Time (UTC) (section  [datetime.system]). This can lead to
surprising behavior when a library user performs a duration-based wait,
such as <tt>condition_variable::timed_wait()</tt>. A complete explanation of the
problem may be found in the
<a href="http://www.opengroup.org/onlinepubs/009695399/xrat/xsh_chap02.html#tag_03_02_08_19">Rationale for the Monotonic Clock</a>
section in POSIX, but in summary:
</p>

<ul>
<li>
Operations such as <tt>condition_variable::timed_wait()</tt> (and its POSIX
equivalent, <tt>pthread_cond_timedwait()</tt>) are specified using absolute times
to address the problem of spurious wakeups.
</li>

<li>
The typical use of the timed wait operations is to perform a relative
wait. This may be achieved by first calculating an absolute time as the
sum of the current time and the desired duration. In fact, the C++0x
thread library includes duration-based overloads of
<tt>condition_variable::timed_wait()</tt> that behave as if by calling the
corresponding absolute time overload with a time point value of
<tt>get_system_time() + rel_time</tt>.
</li>

<li>
A UTC clock may be affected by changes to the system time, such as
synchronization with an external source, leap seconds, or manual changes
to the clock.
</li>

<li>
Should the clock change during a timed wait operation, the actual
duration of the wait will not be the expected length. For example, a
user may intend a timed wait of one second duration but, due to an
adjustment of the system clock backwards by a minute, the wait instead
takes 61 seconds.
</li>
</ul>

<p>
POSIX solves the problem by introducing a new monotonic clock, which is
unaffected by changes to the system time. When a condition variable is
initialized, the user may specify whether the monotonic clock is to be
used. (It is worth noting that on POSIX systems it is not possible to
use <tt>condition_variable::native_handle()</tt> to access this facility, since
the desired clock type must be specified during construction of the
condition variable object.)
</p>

<p>
In the context of the C++0x thread library, there are added dimensions
to the problem due to the need to support platforms other than POSIX:
</p>

<ul>
<li>
Some environments (such as embedded systems) do not have a UTC clock, but do have a monotonic clock.
</li>

<li>
Some environments do not have a monotonic clock, but do have a UTC clock.
</li>

<li>
The Microsoft Windows API's synchronization functions use relative
timeouts based on an implied monotonic clock. A program that switches
from the Windows API to the C++0x thread library will now find itself
susceptible to clock changes.
</li>
</ul>

<p>
One possible minimal solution:
</p>

<ul>
<li>
Strike normative references to UTC and an epoch based on 1970-01-01.
</li>

<li>
Make the semantics of <tt>system_time</tt> and <tt>get_system_time()</tt>
implementation-defined (i.e standard library implementors may choose the
appropriate underlying clock based on the capabilities of the target
platform).
</li>

<li>
Add a non-normative note encouraging use of a monotonic clock.
</li>

<li>
Remove <tt>system_time::seconds_since_epoch()</tt>.
</li>

<li>
Change the constructor <tt>explicit system_time(time_t secs, nanoseconds ns
= 0)</tt> to <tt>explicit system_time(nanoseconds ns)</tt>.
</li>
</ul>



<p><b>Proposed resolution:</b></p>
<p>
</p>


<p><b>Rationale:</b></p>
Addressed by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2661.html">N2661: A Foundation to Sleep On</a>.





<hr>
<h3><a name="790"></a>790. <tt>xor_combine::seed</tt> not specified</h3>
<p><b>Section:</b> X [rand.adapt.xor] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> P.J. Plauger <b>Opened:</b> 2008-02-09  <b>Last modified:</b> 2008-02-27</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.adapt.xor">issues</a> in [rand.adapt.xor].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>xor_combine::seed(result_type)</tt> and <tt>seed(seed_seq&amp;)</tt> don't say what
happens to each of the sub-engine seeds. (Should probably do the same
to both, unlike TR1.)
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
Overcome by the previous proposal. NAD mooted by resolution of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#789">789</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="791"></a>791. <tt>piecewise_constant_distribution::densities</tt> has wrong name</h3>
<p><b>Section:</b> 26.5.8.5.2 [rand.dist.samp.pconst] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> P.J. Plauger <b>Opened:</b> 2008-02-09  <b>Last modified:</b> 2008-03-11</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.dist.samp.pconst">issues</a> in [rand.dist.samp.pconst].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>piecewise_constant_distribution::densities()</tt> should be <tt>probabilities()</tt>,
just like <tt>discrete_distribution</tt>. (There's no real use for weights divided
by areas.)
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
<p>
Fermilab does not agree with this summary. As defined in the equation in
26.4.8.5.2/4, the quantities are indeed probability densities not
probabilities. Because we view this distribution as a parameterization
of a *probability density function*, we prefer to work in terms of
probability densities.
</p>

<p>
We don't think this should be changed.
</p>

<p>
If there is a technical argument about why the implementation dealing
with these values can't be as efficient as one dealing with
probabilities, we might reconsider. We don't care about this one member
function being somewhat more or less efficient; we care about the size
of the distribution object and the speed of the calls to generate
variates.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>

<p>
Change synopsis in 26.5.8.5.2 [rand.dist.samp.pconst]:
</p>

<blockquote><pre>template &lt;class RealType = double&gt; 
class piecewise_constant_distribution 
{ 
public:
    ...
    vector&lt;double&gt; <del>densities</del> <ins>probabilities</ins>() const;
    ...
};
</pre></blockquote>

<p>
Change 26.5.8.5.2 [rand.dist.samp.pconst]/6:
</p>

<blockquote><pre>vector&lt;double&gt; <del>densities</del> <ins>probabilities</ins>() const;
</pre></blockquote>






<hr>
<h3><a name="793"></a>793. <tt>discrete_distribution</tt> missing constructor</h3>
<p><b>Section:</b> 26.5.8.5.1 [rand.dist.samp.discrete] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> P.J. Plauger <b>Opened:</b> 2008-02-09  <b>Last modified:</b> 2009-03-09</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.dist.samp.discrete">issues</a> in [rand.dist.samp.discrete].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>discrete_distribution</tt> should have a constructor like:
</p>

<blockquote><pre>template&lt;class _Fn&gt;
  discrete_distribution(result_type _Count, double _Low, double _High,
                        _Fn&amp; _Func);
</pre></blockquote>

<p>
(Makes it easier to fill a histogram with function values over a range.)
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
How do you specify the function so that it does not return negative
values? If you do it is a bad construction. This requirement is already
there. Where in each bin does one evaluate the function? In the middle.
Need to revisit tomorrow.
</blockquote>

<p><i>[
Sophia Antipolis:
]</i></p>


<blockquote>
<p>
Bill is not requesting this.
</p>
<p>
Marc Paterno: <tt>_Fn</tt> cannot return negative values at the points where the
function is sampled. It is sampled in the middle of each bin. <tt>_Fn</tt> cannot
return 0 everywhere it is sampled.
</p>
<p>
Jens: lambda expressions are rvalues
</p>
<p>
Add a library issue to provide an
<tt>initializer_list&lt;double&gt;</tt> constructor for
<tt>discrete_distribution</tt>.
</p>
<p>
Marc Paterno: dislikes reference for <tt>_Fn</tt> parameter. Make it pass-by-value (to use lambda),
use <tt>std::ref</tt> to wrap giant-state function objects.
</p>
<p>
Daniel: See <tt>random_shuffle</tt>, pass-by-rvalue-reference.
</p>
<p>
Daniel to draft wording.
</p>
</blockquote>

<p><i>[
Pre San Francisco, Daniel provided wording:
]</i></p>


<blockquote>
The here proposed changes of the WP refer to the current state of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2691.pdf">N2691</a>.
During the Sophia Antipolis meeting two different proposals came up
regarding the functor argument type, either by value or by rvalue-reference.
For consistence with existing conventions (state-free algorithms and the
<tt>general_pdf_distribution</tt> c'tor signature) the author decided to propose a
function argument that is provided by value. If severe concerns exists that
stateful functions would be of dominant relevance, it should be possible to
replace the two occurrences of <tt>Func</tt> by <tt>Func&amp;&amp;</tt> in this proposal as part
of an editorial process.
</blockquote>



<p><b>Proposed resolution:</b></p>

<p><b>Non-concept version of the proposed resolution</b></p>

<ol>
<li>
<p>
In 26.5.8.5.1 [rand.dist.samp.discrete]/1, class <tt>discrete_distribution</tt>, just
<em>before</em> the member declaration
</p>

<blockquote><pre>explicit discrete_distribution(const param_type&amp; parm);
</pre></blockquote>

<p>
insert:
</p>


<blockquote><pre>template&lt;typename Func&gt;
discrete_distribution(result_type nf, double xmin, double xmax, Func fw);
</pre></blockquote>
</li>

<li>
<p>
Between p.4 and p.5 insert a series of new paragraphs as part of the
new member description::
</p>
<blockquote><pre>template&lt;typename Func&gt;
discrete_distribution(result_type nf, double xmin, double xmax, Func fw);
</pre>

<p>
<i>Complexity:</i> Exactly nf invocations of fw.
</p>
<p>
<i>Requires:</i>
</p>
<ol type="a">
<li>
fw shall be callable with one argument of type double, and shall
return values of a type convertible to double;</li>

<li>If nf &gt; 0, the relation <tt><i>x</i><sub><i>min</i></sub></tt> &lt; <tt><i>x</i><sub><i>max</i></sub></tt> shall hold, and for all sample values
<tt><i>x</i><sub><i>k</i></sub></tt>, fw(<tt><i>x</i><sub><i>k</i></sub></tt>) shall return a weight value <tt><i>w</i><sub><i>k</i></sub></tt> that is non-negative, non-NaN,
and non-infinity;</li>

<li>The following relations shall hold: nf &#8805; 0, and 0 &lt; S = <tt><i>w</i><sub><i>0</i></sub></tt>+. . .+<tt><i>w<sub>n-1</sub></i></tt>.</li>

</ol>

<p>
<i>Effects:</i>
</p>
<ol type="a">
<li>If nf == 0, sets n = 1 and lets the sequence w have length n = 1 and
   consist of the single value <tt><i>w</i><sub><i>0</i></sub></tt> = 1.</li>

<li>
<p>Otherwise, sets n = nf, deltax = (<tt><i>x</i><sub><i>max</i></sub></tt> - <tt><i>x</i><sub><i>min</i></sub></tt>)/n and <tt><i>x</i><sub><i>cent</i></sub></tt> = <tt><i>x</i><sub><i>min</i></sub></tt> +
0.5 * deltax.</p>
<blockquote><pre>For each k = 0, . . . ,n-1, calculates:
  <tt><i>x</i><sub><i>k</i></sub></tt> = <tt><i>x</i><sub><i>cent</i></sub></tt> + k * deltax
  <tt><i>w</i><sub><i>k</i></sub></tt> = fw(<tt><i>x</i><sub><i>k</i></sub></tt>)
</pre></blockquote>
</li>
<li>
<p>Constructs a discrete_distribution object with probabilities:</p>
<blockquote><pre><tt><i>p</i><sub><i>k</i></sub></tt> = <tt><i>w</i><sub><i>k</i></sub></tt>/S  for k = 0, . . . , n-1.
</pre></blockquote>
</li>
</ol>
</blockquote>
</li>
</ol>

<p><b>Concept version of the proposed resolution</b></p>


<ol>
<li>
<p>
In 26.5.8.5.1 [rand.dist.samp.discrete]/1, class <tt>discrete_distribution</tt>, just
<em>before</em> the member declaration
</p>

<blockquote><pre>explicit discrete_distribution(const param_type&amp; parm);
</pre></blockquote>

<p>
insert:
</p>


<blockquote><pre>template&lt;Callable&lt;auto, double&gt; Func&gt;
 requires Convertible&lt;Func::result_type, double&gt;
discrete_distribution(result_type nf, double xmin, double xmax, Func fw);
</pre></blockquote>
</li>

<li>
<p>
Between p.4 and p.5 insert a series of new paragraphs as part of the
new member description::
</p>
<blockquote><pre>template&lt;Callable&lt;auto, double&gt; Func&gt;
 requires Convertible&lt;Func::result_type, double&gt;
discrete_distribution(result_type nf, double xmin, double xmax, Func fw);
</pre>

<p>
<i>Complexity:</i> Exactly nf invocations of fw.
</p>
<p>
<i>Requires:</i>
</p>
<ol type="a">
<li>If nf &gt; 0, the relation <tt><i>x</i><sub><i>min</i></sub></tt> &lt; <tt><i>x</i><sub><i>max</i></sub></tt> shall hold, and for all sample values
<tt><i>x</i><sub><i>k</i></sub></tt>, fw(<tt><i>x</i><sub><i>k</i></sub></tt>) shall return a weight value <tt><i>w</i><sub><i>k</i></sub></tt> that is non-negative, non-NaN,
and non-infinity;</li>

<li>The following relations shall hold: nf &#8805; 0, and 0 &lt; S = <tt><i>w</i><sub><i>0</i></sub></tt>+. . .+<tt><i>w<sub>n-1</sub></i></tt>.</li>

</ol>

<p>
<i>Effects:</i>
</p>
<ol type="a">
<li>If nf == 0, sets n = 1 and lets the sequence w have length n = 1 and
   consist of the single value <tt><i>w</i><sub><i>0</i></sub></tt> = 1.</li>

<li>
<p>Otherwise, sets n = nf, deltax = (<tt><i>x</i><sub><i>max</i></sub></tt> - <tt><i>x</i><sub><i>min</i></sub></tt>)/n and <tt><i>x</i><sub><i>cent</i></sub></tt> = <tt><i>x</i><sub><i>min</i></sub></tt> +
0.5 * deltax.</p>
<blockquote><pre>For each k = 0, . . . ,n-1, calculates:
  <tt><i>x</i><sub><i>k</i></sub></tt> = <tt><i>x</i><sub><i>cent</i></sub></tt> + k * deltax
  <tt><i>w</i><sub><i>k</i></sub></tt> = fw(<tt><i>x</i><sub><i>k</i></sub></tt>)
</pre></blockquote>
</li>
<li>
<p>Constructs a discrete_distribution object with probabilities:</p>
<blockquote><pre><tt><i>p</i><sub><i>k</i></sub></tt> = <tt><i>w</i><sub><i>k</i></sub></tt>/S  for k = 0, . . . , n-1.
</pre></blockquote>
</li>
</ol>
</blockquote>
</li>
</ol>



<p><b>Rationale:</b></p>
Addressed by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2836.pdf">N2836</a> "Wording Tweaks for Concept-enabled Random Number Generation in C++0X".





<hr>
<h3><a name="794"></a>794. <tt>piecewise_constant_distribution</tt> missing constructor</h3>
<p><b>Section:</b> 26.5.8.5.2 [rand.dist.samp.pconst] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> P.J. Plauger <b>Opened:</b> 2008-02-09  <b>Last modified:</b> 2009-03-09</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.dist.samp.pconst">issues</a> in [rand.dist.samp.pconst].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>piecewise_constant_distribution</tt> should have a constructor like:
</p>

<blockquote><pre>template&lt;class _Fn&gt;
   piecewise_constant_distribution(size_t _Count,
            _Ty _Low, _Ty _High, _Fn&amp; _Func);
</pre></blockquote>

<p>
(Makes it easier to fill a histogram with function values over a range.
The two (reference <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#793">793</a>) make a sensible replacement for
<tt>general_pdf_distribution</tt>.)
</p>

<p><i>[
Sophia Antipolis:
]</i></p>


<blockquote>
<p>
Marc: uses variable width of bins and weight for each bin. This is not
giving enough flexibility to control both variables.
</p>
<p>
Add a library issue to provide an constructor taking an
<tt>initializer_list&lt;double&gt;</tt> and <tt>_Fn</tt> for <tt>piecewise_constant_distribution</tt>.
</p>
<p>
Daniel to draft wording.
</p>
</blockquote>

<p><i>[
Pre San Francisco, Daniel provided wording.
]</i></p>


<blockquote>
The here proposed changes of the WP refer to the current state of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2691.pdf">N2691</a>.
For reasons explained in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#793">793</a>, the author decided to propose a function
argument that is provided by value. The issue proposes a c'tor signature,
that does not take advantage of the full flexibility of
<tt>piecewise_constant_distribution</tt>,
because it restricts on a constant bin width, but the use-case seems to
be popular enough to justify it's introduction.
</blockquote>



<p><b>Proposed resolution:</b></p>

<p><b>Non-concept version of the proposed resolution</b></p>

<ol>
<li>
<p>
In 26.5.8.5.2 [rand.dist.samp.pconst]/1, class <tt>piecewise_constant_distribution</tt>,
just <em>before</em> the member declaration
</p>

<blockquote><pre>explicit piecewise_constant_distribution(const param_type&amp; parm);
</pre></blockquote>
<p>
insert:
</p>
<blockquote><pre>template&lt;typename Func&gt;
piecewise_constant_distribution(size_t nf, RealType xmin, RealType xmax, Func fw);
</pre></blockquote>
</li>

<li>
<p>
Between p.4 and p.5 insert a new sequence of paragraphs nominated
below as [p5_1], [p5_2],
[p5_3], and [p5_4] as part of the new member description:
</p>

<blockquote><pre>template&lt;typename Func&gt;
piecewise_constant_distribution(size_t nf, RealType xmin, RealType xmax, Func fw);
</pre>
<blockquote>
<p>
[p5_1] <i>Complexity:</i> Exactly <tt>nf</tt> invocations of <tt>fw</tt>.
</p>
<p>
[p5_2] <i>Requires:</i>
</p>
<ol type="a">
<li><tt>fw</tt> shall be callable with one argument of type <tt>RealType</tt>, and shall
return values of a type convertible to double;
</li>
<li>
For all sample values <tt><i>x<sub>k</sub></i></tt> defined below, fw(<tt><i>x<sub>k</sub></i></tt>) shall return a weight
value <tt><i>w<sub>k</sub></i></tt> that is non-negative, non-NaN, and non-infinity;
</li>
<li>
The following relations shall hold: <tt><i>x<sub>min</sub></i></tt> &lt; <tt><i>x<sub>max</sub></i></tt>, and
0 &lt; S = <tt><i>w<sub>0</sub></i></tt>+. . .+<tt><i>w<sub>n-1</sub></i></tt>.
</li>
</ol>
<p>
[p5_3] <i>Effects:</i>
</p>
<ol type="a">
<li>
<p>If nf == 0,</p>
 <ol type="a">
 <li>
sets deltax = <tt><i>x<sub>max</sub></i></tt> - <tt><i>x<sub>min</sub></i></tt>, and</li>
<li> lets the sequence <tt>w</tt> have length <tt>n = 1</tt> and consist of the single
    value <tt><i>w<sub>0</sub></i></tt> = 1, and</li>
<li> lets the sequence <tt>b</tt> have length <tt>n+1</tt> with <tt><i>b<sub>0</sub></i></tt> = <tt><i>x<sub>min</sub></i></tt> and 
              <tt><i>b<sub>1</sub></i></tt> = <tt><i>x<sub>max</sub></i></tt>
</li>
</ol>
</li>
<li>
<p>Otherwise,</p>
<ol type="a">
<li> sets <tt>n = nf</tt>, <tt>deltax = </tt>(<tt><i>x<sub>max</sub></i></tt> - <tt><i>x<sub>min</sub></i></tt>)/n,
                 <tt><i>x<sub>cent</sub></i></tt> = <tt><i>x<sub>min</sub></i></tt> + 0.5 * deltax, and
</li>
<li><p>lets the sequences <tt>w</tt> and <tt>b</tt> have length <tt>n</tt> and <tt>n+1</tt>, resp. and</p>
<blockquote><pre>for each k = 0, . . . ,n-1, calculates:
  <tt><i>dx<sub>k</sub></i></tt> = k * deltax
  <tt><i>b<sub>k</sub></i></tt> = <tt><i>x<sub>min</sub></i></tt> + <tt><i>dx<sub>k</sub></i></tt>
  <tt><i>x<sub>k</sub></i></tt> = <tt><i>x<sub>cent</sub></i></tt> + <tt><i>dx<sub>k</sub></i></tt>
  <tt><i>w<sub>k</sub></i></tt> = fw(<tt><i>x<sub>k</sub></i></tt>),
</pre></blockquote> 
<p> and</p>
</li>
<li> sets <tt><i>b<sub>n</sub></i></tt> = <tt><i>x<sub>max</sub></i></tt></li>
</ol>
</li>
<li>
<p>
Constructs a <tt>piecewise_constant_distribution</tt> object with
the above computed sequence <tt>b</tt> as the interval boundaries
and with the probability densities:
</p>
<blockquote><pre><tt><i>&#961;<sub>k</sub></i></tt> = <tt><i>w<sub>k</sub></i></tt>/(S * deltax)  for k = 0, . . . , n-1.
</pre></blockquote> 
</li>
</ol>
<p>
[p5_4] [<i>Note:</i> In this context, the subintervals [<tt><i>b<sub>k</sub></i></tt>, <tt><i>b<sub>k+1</sub></i></tt>) are commonly
 known as the <i>bins</i> of a histogram. <i>-- end note</i>]
 </p>
</blockquote>
</blockquote>
</li>
</ol>

<p><b>Concept version of the proposed resolution</b></p>

<ol>
<li>
<p>
In 26.5.8.5.2 [rand.dist.samp.pconst]/1, class <tt>piecewise_constant_distribution</tt>,
just <em>before</em> the member declaration
</p>

<blockquote><pre>explicit piecewise_constant_distribution(const param_type&amp; parm);
</pre></blockquote>
<p>
insert:
</p>
<blockquote><pre>template&lt;Callable&lt;auto, RealType&gt; Func&gt;
 requires Convertible&lt;Func::result_type, double&gt;
piecewise_constant_distribution(size_t nf, RealType xmin, RealType xmax, Func fw);
</pre></blockquote>
</li>

<li>
<p>
Between p.4 and p.5 insert a new sequence of paragraphs nominated
below as [p5_1], [p5_2],
[p5_3], and [p5_4] as part of the new member description:
</p>

<blockquote><pre>template&lt;Callable&lt;auto, RealType&gt; Func&gt;
 requires Convertible&lt;Func::result_type, double&gt;
piecewise_constant_distribution(size_t nf, RealType xmin, RealType xmax, Func fw);
</pre>
<blockquote>
<p>
[p5_1] <i>Complexity:</i> Exactly <tt>nf</tt> invocations of <tt>fw</tt>.
</p>
<p>
[p5_2] <i>Requires:</i>
</p>
<ol type="a">
<li>
For all sample values <tt><i>x<sub>k</sub></i></tt> defined below, fw(<tt><i>x<sub>k</sub></i></tt>) shall return a weight
value <tt><i>w<sub>k</sub></i></tt> that is non-negative, non-NaN, and non-infinity;
</li>
<li>
The following relations shall hold: <tt><i>x<sub>min</sub></i></tt> &lt; <tt><i>x<sub>max</sub></i></tt>, and
0 &lt; S = <tt><i>w<sub>0</sub></i></tt>+. . .+<tt><i>w<sub>n-1</sub></i></tt>.
</li>
</ol>
<p>
[p5_3] <i>Effects:</i>
</p>
<ol type="a">
<li>
<p>If nf == 0,</p>
 <ol type="a">
 <li>
sets deltax = <tt><i>x<sub>max</sub></i></tt> - <tt><i>x<sub>min</sub></i></tt>, and</li>
<li> lets the sequence <tt>w</tt> have length <tt>n = 1</tt> and consist of the single
    value <tt><i>w<sub>0</sub></i></tt> = 1, and</li>
<li> lets the sequence <tt>b</tt> have length <tt>n+1</tt> with <tt><i>b<sub>0</sub></i></tt> = <tt><i>x<sub>min</sub></i></tt> and 
              <tt><i>b<sub>1</sub></i></tt> = <tt><i>x<sub>max</sub></i></tt>
</li>
</ol>
</li>
<li>
<p>Otherwise,</p>
<ol type="a">
<li> sets <tt>n = nf</tt>, <tt>deltax = </tt>(<tt><i>x<sub>max</sub></i></tt> - <tt><i>x<sub>min</sub></i></tt>)/n,
                 <tt><i>x<sub>cent</sub></i></tt> = <tt><i>x<sub>min</sub></i></tt> + 0.5 * deltax, and
</li>
<li><p>lets the sequences <tt>w</tt> and <tt>b</tt> have length <tt>n</tt> and <tt>n+1</tt>, resp. and</p>
<blockquote><pre>for each k = 0, . . . ,n-1, calculates:
  <tt><i>dx<sub>k</sub></i></tt> = k * deltax
  <tt><i>b<sub>k</sub></i></tt> = <tt><i>x<sub>min</sub></i></tt> + <tt><i>dx<sub>k</sub></i></tt>
  <tt><i>x<sub>k</sub></i></tt> = <tt><i>x<sub>cent</sub></i></tt> + <tt><i>dx<sub>k</sub></i></tt>
  <tt><i>w<sub>k</sub></i></tt> = fw(<tt><i>x<sub>k</sub></i></tt>),
</pre></blockquote> 
<p> and</p>
</li>
<li> sets <tt><i>b<sub>n</sub></i></tt> = <tt><i>x<sub>max</sub></i></tt></li>
</ol>
</li>
<li>
<p>
Constructs a <tt>piecewise_constant_distribution</tt> object with
the above computed sequence <tt>b</tt> as the interval boundaries
and with the probability densities:
</p>
<blockquote><pre><tt><i>&#961;<sub>k</sub></i></tt> = <tt><i>w<sub>k</sub></i></tt>/(S * deltax)  for k = 0, . . . , n-1.
</pre></blockquote> 
</li>
</ol>
<p>
[p5_4] [<i>Note:</i> In this context, the subintervals [<tt><i>b<sub>k</sub></i></tt>, <tt><i>b<sub>k+1</sub></i></tt>) are commonly
 known as the <i>bins</i> of a histogram. <i>-- end note</i>]
 </p>
</blockquote>
</blockquote>
</li>
</ol>



<p><b>Rationale:</b></p>
Addressed by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2836.pdf">N2836</a> "Wording Tweaks for Concept-enabled Random Number Generation in C++0X".





<hr>
<h3><a name="795"></a>795. <tt>general_pdf_distribution</tt> should be dropped</h3>
<p><b>Section:</b> X [rand.dist.samp.genpdf] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> P.J. Plauger <b>Opened:</b> 2008-02-09  <b>Last modified:</b> 2008-03-11</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.dist.samp.genpdf">issues</a> in [rand.dist.samp.genpdf].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#732">732</a></p>
<p><b>Discussion:</b></p>
<p>
<tt>general_pdf_distribution</tt> should be dropped. (It's a research topic in
adaptive numerical integration.)
</p>

<p><i>[
Stephan Tolksdorf notes:
]</i></p>


<blockquote>
This appears to be a duplicate of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#732">732</a>.
</blockquote>


<p><b>Proposed resolution:</b></p>






<hr>
<h3><a name="796"></a>796. <tt>ranlux48_base</tt> returns wrong value</h3>
<p><b>Section:</b> 26.5.5 [rand.predef] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> P.J. Plauger <b>Opened:</b> 2008-02-09  <b>Last modified:</b> 2008-02-27</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.predef">issues</a> in [rand.predef].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The 10,000<sup>th</sup> value returned by <tt>ranlux48_base</tt> is supposed to be
61839128582725. We get 192113843633948. (Note that the underlying
generator was changed in Kona.)
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
Submitter withdraws defect.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 26.5.5 [rand.predef]/p5:
</p>

<blockquote>
<pre>typedef subtract_with_carry_engine&lt;uint_fast64_t, 48, 5, 12&gt; 
        ranlux48_base; 
</pre>
<blockquote>
<i>Required behavior:</i> The 10000<sup>th</sup> consecutive invocation of a default-constructed
object of type <tt>ranlux48_base</tt> shall produce the value
<del>61839128582725</del> <ins>192113843633948</ins>.
</blockquote>
</blockquote>





<hr>
<h3><a name="797"></a>797. <tt>ranlux48</tt> returns wrong value</h3>
<p><b>Section:</b> 26.5.5 [rand.predef] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> P.J. Plauger <b>Opened:</b> 2008-02-09  <b>Last modified:</b> 2008-02-27</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.predef">issues</a> in [rand.predef].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The 10,000<sup>th</sup> value returned by <tt>ranlux48</tt> is supposed to be
249142670248501. We get 88229545517833. (Note that this depends
on <tt>ranlux48_base</tt>.)
</p>
<p><i>[
Bellevue:
]</i></p>


<blockquote>
Submitter withdraws defect.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 26.5.5 [rand.predef]/p6:
</p>

<blockquote>
<pre>typedef discard_block_engine&lt;ranlux48_base, 389, 11&gt; 
        ranlux48
</pre>
<blockquote>
<i>Required behavior:</i> The 10000<sup>th</sup> consecutive invocation of a default-constructed
object of type <tt>ranlux48</tt> shall produce the value
<del>249142670248501</del> <ins>88229545517833</ins>.
</blockquote>
</blockquote>





<hr>
<h3><a name="799"></a>799. [tr.rand.eng.mers] and [rand.eng.mers]</h3>
<p><b>Section:</b> 26.5.3.2 [rand.eng.mers], TR1 5.1.4.2 [tr.rand.eng.mers] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Stephan Tolksdorf <b>Opened:</b> 2008-02-18  <b>Last modified:</b> 2008-03-11</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.eng.mers">issues</a> in [rand.eng.mers].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
TR1 5.1.4.2 [tr.rand.eng.mers](10) requires that <tt>operator==</tt> for the <tt>mersenne_twister</tt>
returns <tt>true</tt> if and only if the states of two <tt>mersenne_twisters</tt>,
consisting each of <tt>n</tt> integers between <tt>0</tt> and <tt>2<sup>w</sup> - 1</tt>, are completely
equal. This is a contradiction with TR1 5.1.1 [tr.rand.req](3) because the given
definition of the state also includes the lower <tt>r</tt> bits of <tt>x(i-n)</tt>, which
will never be used to generate a random number. If two <tt>mersenne_twister</tt>s
only differ in the lower bits of <tt>x(i-n)</tt> they will not compare equal,
although they will produce an identical sequence of random numbers.
</p>

<p>
26.5.3.2 [rand.eng.mers] in the latest C++ draft does not specify the behaviour
of <tt>operator==</tt> but uses a similar definition of the state and, just like
TR1 5.1.4.2 [tr.rand.eng.mers], requires the textual representation of a
<tt>mersenne_twister_engine</tt> to consist of <tt>X<sub>i-n</sub></tt> to <tt>X<sub>i-1</sub></tt>, including the
lower bits of <tt>X<sub>i-n</sub></tt>. This leads to two problems: First, the
unsuspecting implementer is likely to erroneously compare the lower <tt>r</tt>
bits of <tt>X<sub>i-n</sub></tt> in <tt>operator==</tt>. Second, if only the lower <tt>r</tt> bits differ,
two <tt>mersenne_twister_engine</tt>s will compare equal (if correctly
implemented) but have different textual representations, which
conceptually is a bit ugly.
</p>

<p>
I propose that a paragraph or footnote is added to 26.5.3.2 [rand.eng.mers] which
clarifies that the lower <tt>r</tt> bits of <tt>X<sub>i-n</sub></tt> are not to be compared in
<tt>operator==</tt> and <tt>operator!=</tt>. It would only be consequent if furthermore
the specification for the textual respresentation was changed to
<tt>X<sub>i-n</sub> bitand ((2<sup>w</sup> - 1) - (2<sup>r</sup> - 1)), X<sub>i-(n-1)</sub>, ...,  X<sub>i-1</sub></tt> or
something similar.
</p>

<p>
These changes would likely have no practical effect, but would allow an
implementation that does the right thing to be standard-conformant.
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
<p>
Fermi Lab has no objection to the proposed change. However it feels that
more time is needed to check the details, which would suggest a change
to REVIEW.
</p>
<p>
Bill feels that this is NAD, not enough practical importance to abandon
the simple definition of equality, and someone would have to do a lot
more study to ensure that all cases are covered for a very small
payback. The submitter admits that "These changes would likely have no
practical effect,", and according to Plum's razor this means that it is
not worth the effort!
</p>
<p>
Revisted: Agree that the fact that there is no practical difference means that no change can be justified.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
In 26.5.3.2 [rand.eng.mers]:
</p>

<blockquote>
<p>
Insert at the end of para 2.:
</p>

<blockquote>
[<i>Note:</i> The lower <tt>r</tt> bits of <tt>X<sub>i-n</sub></tt> do not influence
the state transition and hence should not be compared when comparing two
<tt>mersenne_twister_engine</tt> objects. <i>-- end note</i>]
</blockquote>

<p>
In para 5. change:
</p>

<blockquote>
The textual representation of <tt>x<sub>i</sub></tt> consists of the values of
<tt>X<sub>i-n</sub> <ins>bitand ((2<sup>w</sup> - 1) - (2<sup>r</sup> - 1)),  X<sub>i-(n-1)</sub></ins>,
..., X<sub>i-1</sub></tt>, in that order.
</blockquote>
</blockquote>





<hr>
<h3><a name="800"></a>800. Issues in 26.4.7.1 [rand.util.seedseq](6)</h3>
<p><b>Section:</b> 26.5.7.1 [rand.util.seedseq] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Stephan Tolksdorf <b>Opened:</b> 2008-02-18  <b>Last modified:</b> 2009-03-09</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.util.seedseq">issues</a> in [rand.util.seedseq].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The for-loop in the algorithm specification has <tt>n</tt> iterations, where <tt>n</tt> is
defined to be <tt>end - begin</tt>, i.e. the number of supplied w-bit quantities.
Previous versions of this algorithm and the general logic behind it
suggest that this is an oversight and that in the context of the
for-loop <tt>n</tt> should be the number of full 32-bit quantities in <tt>b</tt> (rounded
upwards). If <tt>w</tt> is 64, the current algorithm throws away half of all bits
in <tt>b</tt>. If <tt>w</tt> is 16, the current algorithm sets half of all elements in <tt>v</tt>
to 0.
</p>

<p>
There are two more minor issues:
</p>

<ul>
<li>
Strictly speaking <tt>end - begin</tt> is not defined since
<tt>InputIterator</tt> is not required to be a random access iterator.
</li>
<li>
Currently all integral types are allowed as input to the <tt>seed_seq</tt>
constructor, including <tt>bool</tt>. IMHO allowing <tt>bool</tt>s unnecessarily
complicates the implementation without any real benefit to the user.
I'd suggest to exclude <tt>bool</tt>s as input.
</li>
</ul>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
Move to OPEN Bill will try to propose a resolution by the next meeting.
</blockquote>

<p><i>[
post Bellevue:  Bill provided wording.
]</i></p>


<p>
This issue is made moot if <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#803">803</a> is accepted.
</p>



<p><b>Proposed resolution:</b></p>
<p>
Replace 26.5.7.1 [rand.util.seedseq] paragraph 6 with:
</p>

<blockquote>
<p>
<i>Effects:</i> Constructs a <tt>seed_seq</tt> object by effectively concatenating the
low-order <tt>u</tt> bits of each of the elements of the supplied sequence <tt>[begin,
end)</tt>
in ascending order of significance to make a (possibly very large) unsigned
binary number <tt>b</tt> having a total of <tt>n</tt> bits, and then carrying out the
following
algorithm:
</p>

<blockquote><pre>for( v.clear(); n &gt; 0; n -= 32 )
   v.push_back(b mod 2<sup>32</sup>), b /= 2<sup>32</sup>;
</pre></blockquote>
</blockquote>


<p><b>Rationale:</b></p>
Addressed by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2836.pdf">N2836</a> "Wording Tweaks for Concept-enabled Random Number Generation in C++0X".





<hr>
<h3><a name="802"></a>802. <tt>knuth_b</tt> returns wrong value</h3>
<p><b>Section:</b> 26.5.5 [rand.predef] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> P.J. Plauger <b>Opened:</b> 2008-02-20  <b>Last modified:</b> 2008-03-17</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.predef">issues</a> in [rand.predef].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The 10,000<sup>th</sup> value returned by <tt>knuth_b</tt> is supposed to be
1112339016. We get 2126698284.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change 26.5.5 [rand.predef]/p8:
</p>

<blockquote>
<pre>typedef shuffle_order_engine&lt;minstd_rand0, 256&gt; 
        knuth_b; 
</pre>
<blockquote>
<i>Required behavior:</i> The 10000<sup>th</sup> consecutive invocation of a default-constructed
object of type <tt>knuth_b</tt> shall produce the value
<del>1112339016</del> <ins>2126698284</ins>.
</blockquote>
</blockquote>


<p><i>[
Bellevue: Submitter withdraws defect. "We got the wrong value for entirely the right reasons". NAD.
]</i></p>





<hr>
<h3><a name="803"></a>803. Simplification of <tt>seed_seq::seq_seq</tt></h3>
<p><b>Section:</b> 26.5.7.1 [rand.util.seedseq] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Charles Karney <b>Opened:</b> 2008-02-22  <b>Last modified:</b> 2009-03-09</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.util.seedseq">issues</a> in [rand.util.seedseq].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>seed_seq(InputIterator begin, InputIterator end);</tt> constructs a <tt>seed_seq</tt>
object repacking the bits of supplied sequence <tt>[begin, end)</tt> into a
32-bit vector.
</p>
<p>
This repacking triggers several problems:
</p>
<ol>
<li>
Distinctness of the output of <tt>seed_seq::generate</tt> required the
introduction of the initial "<tt>if (w &lt; 32) v.push_back(n);</tt>"  (Otherwise
the unsigned short vectors [1, 0] and [1] generate the same sequence.)
</li>
<li>
Portability demanded the introduction of the template parameter <tt>u</tt>.
(Otherwise some sequences could not be obtained on computers where no
integer types are exactly 32-bits wide.)
</li>
<li>
The description and algorithm have become unduly complicated.
</li>
</ol>
<p>
I propose simplifying this <tt>seed_seq</tt> constructor to be "32-bit only".
Despite it's being simpler, there is NO loss of functionality (see
below).
</p>
<p>
Here's how the description would read
</p>
<blockquote>
<p>
26.5.7.1 [rand.util.seedseq] Class <tt>seed_seq</tt>
</p>

<blockquote>
<pre>template&lt;class InputIterator&gt;
  seed_seq(InputIterator begin, InputIterator end);
</pre>
<blockquote>
<p>
5 <i>Requires:</i> NO CHANGE
</p>
<p>
6 <i>Effects:</i> Constructs a <tt>seed_seq</tt> object by
</p>
<blockquote>
<pre>for (InputIterator s = begin; s != end; ++s)
   v.push_back((*s) mod 2^32);
</pre>
</blockquote>
</blockquote>
</blockquote>
</blockquote>

<p>
Discussion:
</p>
<p>
The chief virtues here are simplicity, portability, and generality.
</p>
<ul>
<li>
Simplicity -- compare the above specification with the
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2461.pdf">n2461</a> proposal.
</li>
<li>
Portability -- with <tt>iterator_traits&lt;InputIterator&gt;::value_type =
uint_least32_t</tt> the user is guaranteed to get the same behavior across
platforms.
</li>
<li>
Generality -- any behavior that the
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2461.pdf">n2461</a>
proposal can achieve can be
obtained with this simpler proposal (albeit with a shuffling of bits
in the input sequence).
</li>
</ul>
<p>
Arguments (and counter-arguments) against making this change (and
retaining the
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2461.pdf">n2461</a>
behavior) are:
</p>
<ul>
<li>
<p>
The user can pass an array of <tt>unsigned char</tt> and <tt>seed_seq</tt> will nicely
 repack it.
</p>
<p>
 Response: So what?  Consider the seed string "ABC".  The
 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2461.pdf">n2461</a>
 proposal results in
</p>
<blockquote><pre>v = { 0x3, 0x434241 };
</pre></blockquote>
<p>
while the simplified proposal yields
</p>
<blockquote><pre>v = { 0x41, 0x42, 0x43 };
</pre></blockquote>
<p>
The results produced by <tt>seed_seq::generate</tt> with the two inputs are
different but nevertheless equivalently "mixed up" and this remains
true even if the seed string is long.
</p>
</li>
<li>
<p>
With long strings (e.g., with bit-length comparable to the number of
 bits in the state), <tt>v</tt> is longer (by a factor of 4) with the simplified
 proposal and <tt>seed_seq::generate</tt> will be slower.
</p>
<p>
Response: It's unlikely that the efficiency of <tt>seed_seq::generate</tt> will
 be a big issue.  If it is, the user is free to repack the seed vector
 before constructing <tt>seed_seq</tt>.
</p>
</li>
<li>
<p>
A user can pass an array of 64-bit integers and all the bits will be
 used.
</p>
<p>
 Response: Indeed.  However, there are many instances in the 
 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2461.pdf">n2461</a>
 where integers are silently coerced to a narrower width and this
 should just be a case of the user needing to read the documentation.
 The user can of course get equivalent behavior by repacking his seed
 into 32-bit pieces.  Furthermore, the unportability of the 
 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2461.pdf">n2461</a>
 proposal with
</p>
<blockquote><pre>unsigned long s[] = {1, 2, 3, 4};
seed_seq q(s, s+4);
</pre></blockquote>
<p>
 which typically results in <tt>v = {1, 2, 3, 4}</tt> on 32-bit machines and in
<tt>v = {1, 0, 2, 0, 3, 0, 4, 0}</tt> on 64-bit machines is a major pitfall for
 unsuspecting users.
</p>
</li>
</ul>

<p>
Note: this proposal renders moot issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#782">782</a> and <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#800">800</a>.
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
Walter needs to ask Fermilab for guidance. Defer till tomorrow. Bill likes the proposed resolution.
</blockquote>

<p><i>[
Sophia Antipolis:
]</i></p>


<blockquote>
<p>
Marc Paterno wants portable behavior between 32bit and 64bit machines;
we've gone to significant trouble to support portability of engines and
their values.
</p>
<p>
Jens: the new algorithm looks perfectly portable
</p>
<p>
Marc Paterno to review off-line.
</p>
<p>
Modify the proposed resolution to read "Constructs a seed_seq object by the following algorithm ..."
</p>
<p>
Disposition: move to review; unanimous consent.
</p>
<p>
(moots <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#782">782</a> and <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#800">800</a>)
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 26.5.7.1 [rand.util.seedseq]:
</p>

<blockquote>
<pre>template&lt;class InputIterator<del>, 
  size_t u = numeric_limits&lt;iterator_traits&lt;InputIterator&gt;::value_type&gt;::digits</del>&gt;
  seed_seq(InputIterator begin, InputIterator end);
</pre>
<blockquote>
<p>
-5- <i>Requires:</i> <tt>InputIterator</tt> shall satisfy the requirements of an input iterator (24.1.1)
such that <tt>iterator_traits&lt;InputIterator&gt;::value_type</tt> shall denote an integral type.
</p>
<p>
-6- Constructs a <tt>seed_seq</tt> object by <ins>the following algorithm</ins> <del>rearranging some or all of the bits of the supplied sequence
<tt>[begin,end)</tt> of w-bit quantities into 32-bit units, as if by the following: </del>
</p>
<p>
<del>First extract the rightmost <tt>u</tt> bits from each of the <tt>n = end
- begin</tt> elements of the supplied sequence and concatenate all the
extracted bits to initialize a single (possibly very large) unsigned
binary number, <tt>b = &#8721;<sup>n-1</sup><sub>i=0</sub> (begin[i] 
mod 2<sup>u</sup>)  2<sup>wi</sup></tt> (in which the bits of each <tt>begin[i]</tt>
are treated as denoting an unsigned quantity). Then carry out 
the following algorithm:</del>
</p>
<blockquote><pre><del>
v.clear(); 
if ($w$ &lt; 32) 
  v.push_back($n$); 
for( ; $n$ &gt; 0; --$n$) 
  v.push_back(b mod 2<sup>32</sup>), b /= 2<sup>32</sup>;
</del></pre></blockquote>
<blockquote>
<pre><ins>
for (InputIterator s = begin; s != end; ++s)
   v.push_back((*s) mod 2<sup>32</sup>);
</ins></pre>
</blockquote>
</blockquote>
</blockquote>


<p><b>Rationale:</b></p>
Addressed by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2836.pdf">N2836</a> "Wording Tweaks for Concept-enabled Random Number Generation in C++0X".





<hr>
<h3><a name="812"></a>812. unsolicited multithreading considered harmful?</h3>
<p><b>Section:</b> 25.4.1 [alg.sort] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Paul McKenney <b>Opened:</b> 2008-02-27  <b>Last modified:</b> 2008-09-17</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Multi-threading is a good thing, but unsolicited multi-threading can
potentially be harmful.  For example, <tt>sort()</tt> performance might be
greatly increased via a multithreaded implementation.  However, such
a multithreaded implementation could result in concurrent invocations
of the user-supplied comparator.  This would in turn result in problems
given a caching comparator that might be written for complex sort keys.
Please note that this is not a theoretical issue, as multithreaded
implementations of <tt>sort()</tt> already exist.
</p>
<p>
Having a multithreaded <tt>sort()</tt> available is good, but it should not
be the default for programs that are not explicitly multithreaded.
Users should not be forced to deal with concurrency unless they have
asked for it.
</p>

<p><i>[
This may be covered by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2410.html">N2410</a>
Thread-Safety in the Standard Library (Rev 1).
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
</p>


<p><b>Rationale:</b></p>
This is already covered by 17.6.5.6/20 in N2723.





<hr>
<h3><a name="823"></a>823. <tt>identity&lt;void&gt;</tt> seems broken</h3>
<p><b>Section:</b> 20.3.3 [forward] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Walter Brown <b>Opened:</b> 2008-04-09  <b>Last modified:</b> 2009-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#forward">issues</a> in [forward].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
N2588 seems to have added an <tt>operator()</tt> member function to the
<tt>identity&lt;&gt;</tt> helper in 20.3.3 [forward].  I believe this change makes it no
longer possible to instantiate <tt>identity&lt;void&gt;</tt>, as it would require
forming a reference-to-<tt>void</tt> type as this <tt>operator()</tt>'s parameter type.
</p>

<p>
Suggested resolution:  Specialize <tt>identity&lt;void&gt;</tt> so as not to require
the member function's presence.
</p>

<p><i>[
Sophia Antipolis:
]</i></p>


<blockquote>
<p>
Jens: suggests to add a requires clause to avoid specializing on <tt>void</tt>.
</p>
<p>
Alisdair: also consider cv-qualified <tt>void</tt>.
</p>
<p>
Alberto provided proposed wording.
</p>
</blockquote>

<p><i>[
2009-07-30 Daniel reopens:
]</i></p>


<blockquote>
<p>
This issue became closed, because the <tt>ReferentType</tt> requirement
fixed the problem - this is no longer the case. In retrospective it seems
to be that the root of current issues around <tt>std::identity</tt> (823, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#700">700</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#939">939</a>)
is that it was standardized as something very different (an unconditional
type mapper) than traditional usage indicated (a function object that should
derive from <tt>std::unary_function)</tt>, as the SGI definition does. This issue could
be solved, if <tt>std::identity</tt> is removed (one proposal of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#939">939</a>), but until this
has been decided, this issue should remain open. An alternative for
removing it, would be, to do the following:
</p>

<ol type="a">
<li>
<p>
Let <tt>identity</tt> stay as a <em>real</em> function object, which would
now properly
derive from <tt>unary_function</tt>:
</p>

<blockquote><pre>template &lt;class T&gt; struct identity : unary_function&lt;T, T&gt; {
  const T&amp; operator()(const T&amp;) const;
};
</pre></blockquote>
</li>

<li>
<p>
Invent (if needed) a generic type wrapper (corresponding to concept
<tt>IdentityOf</tt>),
e.g. <tt>identity_of</tt>, and move it's prototype description back to 20.3.3 [forward]:
</p>

<blockquote><pre>template &lt;class T&gt; struct identity_of {
  typedef T type;
};
</pre></blockquote>

<p>
and adapt the <tt>std::forward</tt> signature to use <tt>identity_of</tt>
instead of <tt>identity</tt>.
</p>
</li>
</ol>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Mark as NAD Editorial, fixed by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#939">939</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change definition of <tt>identity</tt> in 20.3.3 [forward], paragraph 2, to:
</p>

<blockquote><pre>template &lt;class T&gt;  struct identity {
    typedef T type;

    <ins>requires ReferentType&lt;T&gt;</ins>
      const T&amp; operator()(const T&amp; x) const;
  };
</pre></blockquote>
<p>...</p>
<blockquote><pre>  <ins>requires ReferentType&lt;T&gt;</ins>
    const T&amp; operator()(const T&amp; x) const;
</pre></blockquote>


<p><b>Rationale:</b></p>
<p>
The point here is to able to write <tt>T&amp;</tt> given <tt>T</tt> and <tt>ReferentType</tt> is
precisely the concept that guarantees so, according to N2677
(Foundational concepts). Because of this, it seems preferable than an
explicit check for <tt>cv void</tt> using <tt>SameType/remove_cv</tt> as it was suggested
in Sophia. In particular, Daniel remarked that there may be types other
than <tt>cv void</tt> which aren't referent types (<tt>int[]</tt>, perhaps?).
</p>





<hr>
<h3><a name="825"></a>825. Missing rvalues reference stream insert/extract operators?</h3>
<p><b>Section:</b> 19.5.2.1 [syserr.errcode.overview], 20.8.15.2.8
[util.smartptr.shared.io], 22.4.8 [facets.examples], 20.3.7.3
[bitset.operators], 26.4.6 [complex.ops], 27.6 [stream.buffers], 28.9
[re.submatch] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2008-04-10  <b>Last modified:</b> 2009-10-26</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses UK 220</b></p>

<p>
Should the following use rvalues references to stream in insert/extract
operators?
</p>

<ul>
<li>19.5.2.1 [syserr.errcode.overview]</li>
<li>20.8.15.2.8 [util.smartptr.shared.io]</li>
<li>22.4.8 [facets.examples]</li>
<li>20.3.7.3 [bitset.operators]</li>
<li>26.4.6 [complex.ops]</li>
<li>Doubled signatures in 27.6 [stream.buffers] for character inserters
(ref 27.7.2.6.4 [ostream.inserters.character])
+ definition 27.7.2.6.4 [ostream.inserters.character]</li>
<li>28.9 [re.submatch]</li>
</ul>

<p><i>[
Sophia Antipolis
]</i></p>


<blockquote>
Agree with the idea in the issue, Alisdair to provide wording.
</blockquote>

<p><i>[
Daniel adds 2009-02-14:
]</i></p>


<blockquote>
The proposal given in the paper
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2831.html">N2831</a>
apparently resolves this issue.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
The cited paper is an earlier version of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2844.html">N2844</a>,
which changed the rvalue reference binding rules.
That paper includes generic templates
<tt>operator&lt;&lt;</tt> and <tt>operator&gt;&gt;</tt>
that adapt rvalue streams.
</p>
<p>
We therefore agree with Daniel's observation.
Move to NAD Editorial.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="826"></a>826. Equivalent of <tt>%'d</tt>, or rather, lack thereof?</h3>
<p><b>Section:</b> 22.4.2.2 [locale.nm.put] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Peter Dimov <b>Opened:</b> 2008-04-07  <b>Last modified:</b> 2008-06-18</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In the spirit of <tt>printf vs iostream</tt>...
</p>

<p>
POSIX <tt>printf</tt> says that <tt>%'d</tt> should insert grouping characters (and the
implication is that in the absence of <tt>'</tt> no grouping characters are
inserted). The <tt>num_put</tt> facet, on the other hand, seems to always insert
grouping characters. Can this be considered a defect worth fixing for
C++0x? Maybe <tt>ios_base</tt> needs an additional flag?
</p>

<p><i>[
Pablo Halpern:
]</i></p>


<blockquote>
I'm not sure it constitutes a defect, but I would be in favor of adding
another flag (and corresponding manipulator).
</blockquote>

<p><i>[
Martin Sebor:
]</i></p>


<blockquote>
I don't know if it qualifies as a defect but I agree that there
should be an easy way to control whether the thousands separator
should or shouldn't be inserted. A new flag would be in line with
the current design of iostreams (like <tt>boolalpha</tt>, <tt>showpos</tt>, or
<tt>showbase</tt>).
</blockquote>

<p><i>[
Sophia Antipolis:
]</i></p>


<blockquote>
This is not a part of C99. LWG suggests submitting a paper may be appropriate.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="827"></a>827. <tt>constexpr shared_ptr::shared_ptr()?</tt></h3>
<p><b>Section:</b> 20.8.15.2.1 [util.smartptr.shared.const] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Peter Dimov <b>Opened:</b> 2008-04-11  <b>Last modified:</b> 2009-10-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#util.smartptr.shared.const">issues</a> in [util.smartptr.shared.const].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Would anyone object to making the default constructor of <tt>shared_ptr</tt> (and
<tt>weak_ptr</tt> and <tt>enable_shared_from_this) constexpr</tt>? This would enable
static initialization for <tt>shared_ptr</tt> variables, eliminating another
unfair advantage of raw pointers.
</p>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
<p>
It's not clear to us that you can initialize a pointer with the literal
0 in a constant expression. We need to ask CWG to make sure this works.
Bjarne has been appointed to do this.
</p>
<p>
Core got back to us and assured as that <tt>nullptr</tt> would do the job
nicely here.
</p>
</blockquote>

<p><i>[
2009-05-01 Alisdair adds:
]</i></p>


<blockquote>
<p>
I don't believe that constexpr will buy anything in this case.
<tt>shared_ptr/weak_ptr/enable_shared_from_this</tt> cannot be literal types as they
have a non-trivial copy constructor.  As they do not produce literal types,
then the constexpr default constructor will <em>not</em> guarantee constant
initialization, and so not buy the hoped for optimization.
</p>
<p>
I recommend referring this back to Core to see if we can get static
initialization for types with constexpr constructors, even if they are not
literal types.  Otherwise this should be closed as NAD.
</p>
</blockquote>

<p><i>[
2009-05-26 Daniel adds:
]</i></p>


<blockquote>
If Alisdair's 2009-05-01 comment is correct, wouldn't that also make
<tt>constexpr mutex()</tt> useless, because this class has a non-trivial
destructor? (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#828">828</a>)
</blockquote>

<p><i>[
2009-07-21 Alisdair adds:
]</i></p>


<blockquote>
<p>
The feedback from core is that this and similar uses of constexpr
constructors to force static initialization should be supported.  If
there are any problems with this in the working draught, we should file
core issues.
</p>

<p>
Recommend we declare the default constructor constexpr as the issue suggests
(proposed wording added).
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD Editorial.  Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2994.html">N2994</a>.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 20.8.15.2 [util.smartptr.shared] and 20.8.15.2.1 [util.smartptr.shared.const]:
</p>

<blockquote><pre><ins>consexpr</ins> shared_ptr();
</pre></blockquote>

<p>
Change 20.8.15.3 [util.smartptr.weak] and 20.8.15.3.1 [util.smartptr.weak.const]:
</p>

<blockquote><pre><ins>consexpr</ins> weak_ptr();
</pre></blockquote>

<p>
Change 20.8.15.4 [util.smartptr.enab] (2 places):
</p>

<blockquote><pre><ins>consexpr</ins> enable_shared_from_this();
</pre></blockquote>






<hr>
<h3><a name="828"></a>828. Static initialization for <tt>std::mutex</tt>?</h3>
<p><b>Section:</b> 30.4.1.1 [thread.mutex.class] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Peter Dimov <b>Opened:</b> 2008-04-18  <b>Last modified:</b> 2009-10-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.mutex.class">issues</a> in [thread.mutex.class].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
[Note: I'm assuming here that 3.6.2 [basic.start.init]/1 will be fixed.]
</p>
<p>
Currently <tt>std::mutex</tt> doesn't support static initialization. This is a
regression with respect to <tt>pthread_mutex_t</tt>, which does. I believe that
we should strive to eliminate such regressions in expressive power where
possible, both to ease migration and to not provide incentives to (or
force) people to forego the C++ primitives in favor of pthreads.
</p>

<p><i>[
Sophia Antipolis:
]</i></p>


<blockquote>
<p>
We believe this is implementable on POSIX, because the initializer-list
feature and the constexpr feature make this work. Double-check core
language about static initialization for this case. Ask core for a core
issue about order of destruction of statically-initialized objects wrt.
dynamically-initialized objects (should come afterwards). Check
non-POSIX systems for implementability.
</p>
<p>
If ubiquitous implementability cannot be assured, plan B is to introduce
another constructor, make this constexpr, which is
conditionally-supported. To avoid ambiguities, this new constructor needs
to have an additional parameter.
</p>
</blockquote>

<p><i>[
Post Summit:
]</i></p>


<blockquote>
<p>
Jens: constant initialization seems to be ok core-language wise
</p>
<p>
Consensus: Defer to threading experts, in particular a Microsoft platform expert.
</p>
<p>
Lawrence to send e-mail to Herb Sutter, Jonathan Caves, Anthony Wiliams,
Paul McKenney, Martin Tasker, Hans Boehm, Bill Plauger, Pete Becker,
Peter Dimov to alert them of this issue.
</p>
<p>
Lawrence: What about header file shared with C? The initialization
syntax is different in C and C++.
</p>
<p>
Recommend Keep in Review
</p>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Keep in Review status pending feedback from members of the Concurrency subgroup.
</blockquote>

<p><i>[
See related comments from Alisdiar and Daniel in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#827">827</a>.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD Editorial.  Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2994.html">N2994</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 30.4.1.1 [thread.mutex.class]:
</p>

<blockquote><pre>class mutex {
public:
  <ins>constexpr</ins> mutex();
  ...
</pre></blockquote>





<hr>
<h3><a name="830"></a>830. Incomplete list of char_traits specializations</h3>
<p><b>Section:</b> 21.2 [char.traits] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Dietmar Khl <b>Opened:</b> 2008-04-23  <b>Last modified:</b> 2009-07-13</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#char.traits">issues</a> in [char.traits].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
  Paragraph 4 of 21.2 [char.traits] mentions that this
  section specifies two specializations (<code>char_traits&lt;char&gt;</code>
  and (<code>char_traits&lt;wchar_t&gt;</code>). However, there are actually
  four specializations provided, i.e. in addition to the two above also
  <code>char_traits&lt;char16_t&gt;</code> and <code>char_traits&lt;char32_t&gt;</code>).
  I guess this was just an oversight and there is nothing wrong with just
  fixing this.
</p>

<p><i>[
Alisdair adds:
]</i></p>

<blockquote>
<tt>char_traits&lt; char16/32_t &gt;</tt>
should also be added to <tt>&lt;ios_fwd&gt;</tt> in 27.3 [iostream.forward], and all the specializations
taking a <tt>char_traits</tt> parameter in that header.
</blockquote>

<p><i>[
Sophia Antipolis:
]</i></p>


<blockquote>
<p>
Idea of the issue is ok.
</p>
<p>
Alisdair to provide wording, once that wording arrives, move to review.
</p>

</blockquote>

<p><i>[
2009-05-04 Alisdair adds:
]</i></p>


<blockquote>
<p>
The main point of the issue was resolved editorially in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2723.pdf">N2723</a>,
so we are
close to NAD Editorial.
However, exploring the issue we found a second tweak was necessary for
<tt>&lt;iosfwd&gt;</tt> and that is still outstanding, so here are the words I am long
overdue delivering:
</p>

<p><i>[
Howard:  I've put Alisdair's words into the proposed wording section and
moved the issue to Review.
]</i></p>


</blockquote>

<p><i>[
Original proposed wording.
]</i></p>


<blockquote>

<p>
  Replace paragraph 4 of 21.2 [char.traits] by:
</p>
<blockquote>
<p>
  This subclause specifies a struct template, <code>char_traits&lt;charT&gt;</code>,
  and four explicit specializations of it, <code>char_traits&lt;char&gt;</code>,
  <code>char_traits&lt;char16_t&gt;</code>, <code>char_traits&lt;char32_t&gt;</code>, and
  <code>char_traits&lt;wchar_t&gt;</code>, all of which appear in the header
  &lt;string&gt; and satisfy the requirements below.
</p>
</blockquote>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree.  Move to NAD Editorial.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change Forward declarations 27.3 [iostream.forward]:
</p>

<blockquote>
<p>
<b>Header <tt>&lt;iosfwd&gt;</tt> synopsis</b>
</p>
<pre>namespace std {
   template&lt;class charT&gt; class char_traits;
   template&lt;&gt; class char_traits&lt;char&gt;;
   <ins>template&lt;&gt; class char_traits&lt;char16_t&gt;;</ins>
   <ins>template&lt;&gt; class char_traits&lt;char32_t&gt;;</ins>
   template&lt;&gt; class char_traits&lt;wchar_t&gt;;
...
}
</pre>
</blockquote>





<hr>
<h3><a name="831"></a>831. wrong type for not_eof()</h3>
<p><b>Section:</b> 21.2.3 [char.traits.specializations] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Dietmar Khl <b>Opened:</b> 2008-04-23  <b>Last modified:</b> 2008-06-19</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#char.traits.specializations">issues</a> in [char.traits.specializations].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
  In Table 56 (Traits requirements) the <tt>not_eof()</tt> member function
  is using an argument of type <i>e</i> which denotes an object of
  type <code>X::int_type</code>. However, the specializations in
  21.2.3 [char.traits.specializations] all use <code>char_type</code>.
  This would effectively mean that the argument type actually can't
  represent EOF in the first place. I'm pretty sure that the type used
  to be <code>int_type</code> which is quite obviously the only sensible
  argument.
</p>
<p>
  This issue is close to being editorial. I suspect that the proposal
  changing this section to include the specializations for <code>char16_t</code>
  and <code>char32_t</code> accidentally used the wrong type.
</p>


<p><b>Proposed resolution:</b></p>
<p>
  In 21.2.3.1 [char.traits.specializations.char],
  21.2.3.2 [char.traits.specializations.char16_t],
  21.2.3.3 [char.traits.specializations.char32_t], and
   [char.traits.specializations.wchar_t] correct the
  argument type from <code>char_type</code> to <code>int_type</code>.
</p>


<p><b>Rationale:</b></p>
Already fixed in WP.





<hr>
<h3><a name="832"></a>832. Applying constexpr to System error support</h3>
<p><b>Section:</b> 19.5 [syserr] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Beman Dawes <b>Opened:</b> 2008-05-14  <b>Last modified:</b> 2008-09-17</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#syserr">issues</a> in [syserr].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Initialization of objects of class <tt>error_code</tt>
(19.5.2 [syserr.errcode]) and class
<tt>error_condition</tt> (19.5.3 [syserr.errcondition]) can be made simpler and more reliable by use of
the new <tt>constexpr</tt> feature 
[<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2349.pdf">N2349</a>]
of C++0x. Less code will need to be
generated for both library implementations and user programs when
manipulating constant objects of these types. 
</p>

<p>
This was not proposed originally because the constant expressions
proposal was moving into the standard at about the same time as the
Diagnostics Enhancements proposal 
[<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2241.html">N2241</a>],
and it wasn't desirable to
make the later depend on the former. There were also technical concerns
as to how <tt>constexpr</tt> would apply to references. Those concerns are now
resolved; <tt>constexpr</tt> can't be used for references, and that fact is
reflected in the proposed resolution.
</p>

<p>
Thanks to Jens Maurer, Gabriel Dos Reis, and Bjarne Stroustrup for clarification of <tt>constexpr</tt> requirements.
</p>

<p>
LWG issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#804">804</a> is related in that it raises the question of whether the
exposition only member <tt>cat_</tt> of class <tt>error_code</tt> (19.5.2 [syserr.errcode]) and class
<tt>error_condition</tt> (19.5.3 [syserr.errcondition]) should be presented as a reference or pointer.
While in the context of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#804">804</a> that is arguably an editorial question,
presenting it as a pointer becomes more or less required with this
proposal, given <tt>constexpr</tt> does not play well with references. The
proposed resolution thus changes the private member to a pointer, which
also brings it in sync with real implementations.
</p>

<p><i>[
Sophia Antipolis:
]</i></p>


<blockquote>
On going question of extern pointer vs. inline functions for interface.
</blockquote>

<p><i>[
Pre-San Francisco:
]</i></p>


<blockquote>
<p>
Beman Dawes reports that this proposal is unimplementable, and thus NAD.
</p>
<p>
Implementation would require <tt>constexpr</tt> objects of classes derived
from class <tt>error_category</tt>, which has virtual functions, and that is
not allowed by the core language. This was determined when trying to
implement the proposal using a constexpr enabled compiler provided
by Gabriel Dos Reis, and subsequently verified in discussions with
Gabriel and Jens Maurer.
</p>

</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
The proposed wording assumes the LWG <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#805">805</a> proposed wording has been
applied to the WP, resulting in the former <tt>posix_category</tt> being renamed
<tt>generic_category</tt>. If <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#805">805</a> has not been applied, the names in this
proposal must be adjusted accordingly.
</p>

<p>
Change 19.5.1.1 [syserr.errcat.overview] Class
<tt>error_category</tt> overview <tt>error_category</tt> synopsis  as
indicated:
</p>

<blockquote><pre><del>const error_category&amp; get_generic_category();</del>
<del>const error_category&amp; get_system_category();</del>

<del>static</del> <ins>extern</ins> const error_category<del>&amp;</del><ins>* const</ins> generic_category<del> = get_generic_category()</del>;
<del>static</del> <ins>extern</ins> const error_category<del>&amp;</del><ins>* const</ins> <del>native_category</del> system_category<del> = get_system_category()</del>;
</pre></blockquote>

<p>
Change 19.5.1.5 [syserr.errcat.objects] Error category objects as indicated:
</p>

<blockquote>
<pre><ins>extern</ins> const error_category<del>&amp;</del><ins>* const</ins> <del>get_</del>generic_category<del>()</del>;
</pre>
<p>
<del><i>Returns:</i> A reference</del> <ins><tt>generic_category</tt> shall point</ins>
to <del>an</del> <ins>a statically initialized</ins> object of a type derived from
class <tt>error_category</tt>.
</p>

<p>
<del><i>Remarks:</i></del> The object's <tt>default_error_condition</tt> and <tt>equivalent</tt> virtual
functions shall behave as specified for the class <tt>error_category</tt>. The
object's <tt>name</tt> virtual function shall return a pointer to the string
<tt>"GENERIC"</tt>.
</p>

<pre><ins>extern</ins> const error_category<del>&amp;</del><ins>* const</ins> <del>get_</del>system_category<del>()</del>;
</pre>

<p>
<del><i>Returns:</i> A reference</del> <ins><tt>system_category</tt> shall point</ins>
to <del>an</del> <ins>a statically
initialized</ins> object of a type derived from class <tt>error_category</tt>.
</p>

<p>
<del><i>Remarks:</i></del>  The object's <tt>equivalent</tt> virtual functions shall behave as
specified for class <tt>error_category</tt>. The object's <tt>name</tt> virtual function
shall return a pointer to the string <tt>"system"</tt>. The object's
<tt>default_error_condition</tt> virtual function shall behave as follows:
</p>

<p>
If the argument <tt>ev</tt> corresponds to a POSIX <tt>errno</tt> value <tt>posv</tt>, the function
shall return <tt>error_condition(posv, generic_category)</tt>. Otherwise, the
function shall return <tt>error_condition(ev, system_category)</tt>. What
constitutes correspondence for any given operating system is
unspecified. [<i>Note:</i> The number of potential system error codes is large
and unbounded, and some may not correspond to any POSIX <tt>errno</tt> value.
Thus implementations are given latitude in determining correspondence.
<i>-- end note</i>]
</p>
</blockquote>

<p>
Change 19.5.2.1 [syserr.errcode.overview] Class <tt>error_code</tt> overview as indicated:
</p>

<blockquote><pre>class error_code {
public:
  ...;
  <ins>constexpr</ins> error_code(int val, const error_category<del>&amp;</del><ins>*</ins> cat);
  ...
  void assign(int val, const error_category<del>&amp;</del><ins>*</ins> cat);
  ...
  const error_category<del>&amp;</del><ins>*</ins> category() const;
  ...
private:
  int val_;                    // exposition only
  const error_category<del>&amp;</del><ins>*</ins> cat_; // exposition only
</pre></blockquote>

<p>
Change 19.5.2.2 [syserr.errcode.constructors] Class <tt>error_code</tt> constructors as indicated:
</p>

<blockquote>
<pre><ins>constexpr</ins> error_code(int val, const error_category<del>&amp;</del><ins>*</ins> cat);
</pre>
<p>
<i>Effects:</i> Constructs an object of type <tt>error_code</tt>.
</p>
<p>
<i>Postconditions:</i> <tt>val_ == val</tt> and <tt>cat_ == cat</tt>.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>

<p>
Change 19.5.2.3 [syserr.errcode.modifiers] Class <tt>error_code</tt> modifiers  as indicated:
</p>

<blockquote>
<pre>void assign(int val, const error_category<del>&amp;</del><ins>*</ins> cat);
</pre>
<p>
<i>Postconditions:</i> <tt>val_ == val</tt> and <tt>cat_ == cat</tt>.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>

<p>
Change 19.5.2.4 [syserr.errcode.observers] Class <tt>error_code</tt> observers  as indicated:
</p>

<blockquote>
<pre>const error_category<del>&amp;</del><ins>*</ins> category() const;
</pre>

<p>
<i>Returns:</i> <tt>cat_</tt>.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>

<p>
Change 19.5.3.1 [syserr.errcondition.overview] Class <tt>error_condition</tt> overview   as indicated:
</p>

<blockquote>
<pre>class error_condition {
public:
  ...;
  <ins>constexpr</ins> error_condition(int val, const error_category<del>&amp;</del><ins>*</ins> cat);
  ...
  void assign(int val, const error_category<del>&amp;</del><ins>*</ins> cat);
  ...
  const error_category<del>&amp;</del><ins>*</ins> category() const;
  ...
private:
  int val_;                    // exposition only
  const error_category<del>&amp;</del><ins>*</ins> cat_; // exposition only
</pre>
</blockquote>

<p>
Change 19.5.3.2 [syserr.errcondition.constructors] Class <tt>error_condition</tt> constructors as indicated:
</p>

<blockquote>
<pre><ins>constexpr</ins> error_condition(int val, const error_category<del>&amp;</del><ins>*</ins> cat);
</pre>
<p>
<i>Effects:</i> Constructs an object of type <tt>error_condition</tt>.
</p>
<p>
<i>Postconditions:</i> <tt>val_ == val</tt> and <tt>cat_ == cat</tt>.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>

<p>
Change 19.5.3.3 [syserr.errcondition.modifiers] Class <tt>error_condition</tt> modifiers as indicated:
</p>

<blockquote>
<pre>void assign(int val, const error_category<del>&amp;</del><ins>*</ins> cat);
</pre>
<p>
<i>Postconditions:</i> <tt>val_ == val</tt> and <tt>cat_ == cat</tt>.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>

<p>
Change 19.5.3.4 [syserr.errcondition.observers] Class <tt>error_condition</tt> observers as indicated:
</p>

<blockquote>
<pre>const error_category<del>&amp;</del><ins>*</ins> category() const;
</pre>
<p>
<i>Returns:</i> <tt>cat_</tt>.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>

<p>
Throughout 19.5 [syserr] System error support, change "<tt>category().</tt>"  to "<tt>category()-&gt;</tt>".
Appears approximately six times.
</p>

<p>
<i>[Partially Editorial]</i> In 19.5.4 [syserr.compare] Comparison operators,
paragraphs 2 and 4, change "<tt>category.equivalent(</tt>"  to
"<tt>category()-&gt;equivalent(</tt>".
</p>

<p>
Change 19.5.5.1 [syserr.syserr.overview] Class system_error overview as indicated:
</p>

<blockquote><pre>public:
  system_error(error_code ec, const string&amp; what_arg);
  system_error(error_code ec);
  system_error(int ev, const error_category<del>&amp;</del><ins>*</ins> ecat,
      const string&amp; what_arg);
  system_error(int ev, const error_category<del>&amp;</del><ins>*</ins> ecat);
</pre></blockquote>

<p>
Change 19.5.5.2 [syserr.syserr.members] Class system_error members as indicated:
</p>

<blockquote>
<pre>system_error(int ev, const error_category<del>&amp;</del><ins>*</ins> ecat, const string&amp; what_arg);
</pre>
<blockquote>
<p>
<i>Effects:</i> Constructs an object of class <tt>system_error</tt>.
</p>
<p>
<i>Postconditions:</i> <tt>code() == error_code(ev, ecat)</tt> and
<tt>strcmp(runtime_error::what(), what_arg.c_str()) == 0</tt>.
</p>
</blockquote>

<pre>system_error(int ev, const error_category<del>&amp;</del><ins>*</ins> ecat);
</pre>
<blockquote>
<p>
<i>Effects:</i> Constructs an object of class <tt>system_error</tt>.
</p>
<p>
<i>Postconditions:</i> <tt>code() == error_code(ev, ecat)</tt> and
<tt>strcmp(runtime_error::what(), "") == 0</tt>.
</p>
</blockquote>
</blockquote>



<p><b>Rationale:</b></p>
<p><i>[
San Francisco:
]</i></p>


<blockquote>
NAD because Beman said so.
</blockquote>





<hr>
<h3><a name="833"></a>833. Freestanding implementations header list needs review for C++0x</h3>
<p><b>Section:</b> 17.6.1.3 [compliance] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Beman Dawes <b>Opened:</b> 2008-05-14  <b>Last modified:</b> 2009-07-16</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#compliance">issues</a> in [compliance].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Once the C++0x standard library is feature complete, the LWG needs to
review 17.6.1.3 [compliance] Freestanding implementations header list to
ensure it reflects LWG consensus.
</p>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
<p>
This is a placeholder defect to remind us to review the table once we've
stopped adding headers to the library.
</p>
<p>
Three new headers that need to be added to the list:
</p>
<blockquote><pre>&lt;initializer_list&gt; &lt;concept&gt; &lt;iterator_concepts&gt;
</pre></blockquote>
<p>
<tt>&lt;iterator_concepts&gt;</tt>, in particular, has lots of stuff
that isn't needed, so maybe the stuff that is needed should be broken
out into a separate header.
</p>
<p>
Robert: What about <tt>reference_closure</tt>? It's currently in
<tt>&lt;functional&gt;</tt>.
</p>
</blockquote>

<p><i>[
Post Summit Daniel adds:
]</i></p>


<blockquote>
<ol>
<li>
The comment regarding <tt>reference_closure</tt> seems moot since it was just
recently decided to remove that.
</li>
<li>
A reference to proposal
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2814.pdf">N2814</a>
("Fixing freestanding") should be added. This
paper e.g. proposes to add only <tt>&lt;initializer_list&gt;</tt> to the include list
of freestanding.
</li>
</ol>
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
<p>
Addressed by paper
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2814.pdf">N2814</a>.
</p>
<p>
Move to NAD.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="837"></a>837. 
   <code>basic_ios::copyfmt()</code> overly loosely specified
 </h3>
<p><b>Section:</b> 27.5.4.2 [basic.ios.members] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2008-05-17  <b>Last modified:</b> 2009-07-13</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#basic.ios.members">active issues</a> in [basic.ios.members].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#basic.ios.members">issues</a> in [basic.ios.members].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
   <p>

The <code>basic_ios::copyfmt()</code> member function is specified in 27.5.4.2 [basic.ios.members] to have the following effects:

   </p>
   <blockquote>

<i>Effects</i>: If <code>(this == &amp;rhs)</code> does
nothing. Otherwise assigns to the member objects of <code>*this</code>
the corresponding member objects of <code>rhs</code>, except that

     <ul>
       <li>

<code>rdstate()</code> and <code>rdbuf()</code> are left unchanged;

       </li>
       <li>

<code>exceptions()</code> is altered last by
calling <code>exceptions(rhs.except)</code>

       </li>
       <li>

the contents of arrays pointed at by <code>pword</code>
and <code>iword</code> are copied not the pointers themselves

       </li>
     </ul>
   </blockquote>
   <p>

Since the rest of the text doesn't specify what the member objects
of <code>basic_ios</code> are this seems a little too loose.

</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution.
Move to NAD Editorial.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>

I propose to tighten things up by adding a <i>Postcondition</i> clause
to the function like so:

   </p>
   <blockquote>
     <i>Postconditions:</i>

     <table border="1">
       <thead>
         <tr>
           <th colspan="2"><code>copyfmt()</code> postconditions</th>
         </tr>
         <tr>
           <th>Element</th>
           <th>Value</th>
         </tr>
       </thead>
       <tbody>
         <tr>
           <td><code>rdbuf()</code></td>
           <td><i>unchanged</i></td>
         </tr>
         <tr> 
           <td><code>tie()</code></td>
           <td><code>rhs.tie()</code></td>
         </tr>
         <tr> 
           <td><code>rdstate()</code></td>
           <td><i>unchanged</i></td>
         </tr>
         <tr> 
           <td><code>exceptions()</code></td>
           <td><code>rhs.exceptions()</code></td>
         </tr>
         <tr> 
           <td><code>flags()</code></td>
           <td><code>rhs.flags()</code></td>
         </tr>
         <tr> 
           <td><code>width()</code></td>
           <td><code>rhs.width()</code></td>
         </tr>
         <tr> 
           <td><code>precision()</code></td>
           <td><code>rhs.precision()</code></td>
         </tr>
         <tr> 
           <td><code>fill()</code></td>
           <td><code>rhs.fill()</code></td>
         </tr>
         <tr> 
           <td><code>getloc()</code></td>
           <td><code>rhs.getloc()</code></td>
         </tr>
       </tbody>
     </table>
   </blockquote>
   <p>

The format of the table follows Table 117 (as
of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2588.pdf">N2588</a>): <code>basic_ios::init()</code>
effects.

   </p>
   <p>

The intent of the new table is not to impose any new requirements or
change existing ones, just to be more explicit about what I believe is
already there.

   </p>
 



<hr>
<h3><a name="839"></a>839. Maps and sets missing splice operation</h3>
<p><b>Section:</b> 23.4 [associative], 23.5 [unord] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Future">NAD Future</a>
 <b>Submitter:</b> Alan Talbot <b>Opened:</b> 2008-05-18  <b>Last modified:</b> 2009-09-20</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#associative">issues</a> in [associative].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Future">NAD Future</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Splice is a very useful feature of <tt>list</tt>. This functionality is also very
useful for any other node based container, and I frequently wish it were
available for maps and sets. It seems like an omission that these
containers lack this capability. Although the complexity for a splice is
the same as for an insert, the actual time can be much less since the
objects need not be reallocated and copied. When the element objects are
heavy and the compare operations are fast (say a <tt>map&lt;int, huge_thingy&gt;</tt>)
this can be a big win.
</p>

<p>
<b>Suggested resolution:</b>
</p>

<p>
Add the following signatures to map, set, multimap, multiset, and the unordered associative containers:
</p>
<blockquote><pre> 
void splice(list&lt;T,Allocator&gt;&amp;&amp; x);
void splice(list&lt;T,Allocator&gt;&amp;&amp; x, const_iterator i);
void splice(list&lt;T,Allocator&gt;&amp;&amp; x, const_iterator first, const_iterator last);
</pre></blockquote>

<p>
Hint versions of these are also useful to the extent hint is useful.
(I'm looking for guidance about whether hints are in fact useful.)
</p>
 
<blockquote><pre> 
void splice(const_iterator position, list&lt;T,Allocator&gt;&amp;&amp; x);
void splice(const_iterator position, list&lt;T,Allocator&gt;&amp;&amp; x, const_iterator i);
void splice(const_iterator position, list&lt;T,Allocator&gt;&amp;&amp; x, const_iterator first, const_iterator last);
</pre></blockquote>

<p><i>[
Sophia Antipolis:
]</i></p>


<blockquote>
<p>
Don't try to <tt>splice "list"</tt> into the other containers, it should be container-type.
</p>
<p>
<tt>forward_list</tt> already has <tt>splice_after</tt>.
</p>
<p>
Would "<tt>splice</tt>" make sense for an <tt>unordered_map</tt>?
</p>
<p>
Jens, Robert: "<tt>splice</tt>" is not the right term, it implies maintaining ordering in <tt>list</tt>s.
</p>
<p>
Howard: <tt>adopt</tt>?
</p>
<p>
Jens: <tt>absorb</tt>?
</p>
<p>
Alan: <tt>subsume</tt>?
</p>
<p>
Robert: <tt>recycle</tt>?
</p>
<p>
Howard: <tt>transfer</tt>? (but no direction)
</p>
<p>
Jens: <tt>transfer_from</tt>. No.
</p>
<p>
Alisdair: Can we give a nothrow guarantee? If your <tt>compare()</tt> and <tt>hash()</tt> doesn't throw, yes.
</p>
<p>
Daniel: For <tt>unordered_map</tt>, we can't guarantee nothrow.
</p>
</blockquote>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
<p>
Martin: this would possibly outlaw an implementation technique that is
currently in use; caching nodes in containers.
</p>
<p>
Alan: if you cache in the allocator, rather than the individual
container, this proposal doesn't interfere with that.
</p>
<p>
Martin: I'm not opposed to this, but I'd like to see an implementation
that demonstrates that it works.
</p>
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
NAD Future.
</blockquote>

<p><i>[
2009-09-19 Howard adds:
]</i></p>


<blockquote>
<p>
I'm not disagreeing with the NAD Future resolution.  But when the future gets
here, here is a possibility worth exploring:
</p>

<blockquote>
<p>
Add to the "unique" associative containers:
</p>

<blockquote><pre>typedef <i>details</i>      node_ptr;

node_ptr             remove(const_iterator p);
pair&lt;iterator, bool&gt; insert(node_ptr&amp;&amp; nd);
iterator             insert(const_iterator p, node_ptr&amp;&amp; nd);
</pre></blockquote>

<p>
And add to the "multi" associative containers:
</p>

<blockquote><pre>typedef <i>details</i> node_ptr;

node_ptr remove(const_iterator p);
iterator insert(node_ptr&amp;&amp; nd);
iterator insert(const_iterator p, node_ptr&amp;&amp; nd);
</pre></blockquote>

<p>
<tt>Container::node_ptr</tt> is a smart pointer much like <tt>unique_ptr</tt>.
It owns a node obtained from the container it was removed from.  It maintains a
reference to the allocator in the container so that it can properly deallocate
the node if asked to, even if the allocator is stateful.  This being said, the
<tt>node_ptr</tt> can not outlive the container for this reason.
</p>

<p>
The <tt>node_ptr</tt> offers "<tt>const</tt>-free" access to the node's
<tt>value_type</tt>.
</p>

<p>
With this interface, clients have a great deal of flexibility:
</p>

<ul>
<li>
A client can remove a node from one container, and insert it into another
(without any heap allocation).  This is the splice functionality this issue
asks for.
</li>
<li>
A client can remove a node from a container, change its key or value, and insert
it back into the same container, or another container, all without the cost of
allocating a node.
</li>
<li>
If the Compare function is nothrow (which is very common), then this functionality
is nothrow unless modifying the value throws.  And if this does throw, it does
so outside of the containers involved.
</li>
<li>
If the Compare function does throw, the <tt>insert</tt> function will have the
argument <tt>nd</tt> retain ownership of the node.
</li>
<li>
The <tt>node_ptr</tt> should be independent of the <tt>Compare</tt> parameter
so that a node can be transferred from <tt>set&lt;T, C1, A&gt;</tt>
to <tt>set&lt;T, C2, A&gt;</tt> (for example).
</li>
</ul>

<p>
Here is how the customer might use this functionality:
</p>

<ul>
<li>
<p>
Splice a node from one container to another:
</p>
<blockquote><pre>m2.insert(m1.remove(i));
</pre></blockquote>
</li>

<li>
<p>
Change the "key" in a <tt>std::map</tt> without the cost of node reallocation:
</p>
<blockquote><pre>auto p = m.remove(i);
p-&gt;first = new_key;
m.insert(std::move(p));
</pre></blockquote>
</li>

<li>
<p>
Change the "value" in a <tt>std::set</tt> without the cost of node reallocation:
</p>
<blockquote><pre>auto p = s.remove(i);
*p = new_value;
s.insert(std::move(p));
</pre></blockquote>
</li>

<li>
<p>
Move a move-only or heavy object out of an associative container (as opposed to
the proposal in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1041">1041</a>):
</p>
<blockquote><pre>MoveOnly x = std::move(*s.remove(i));
</pre></blockquote>
<ol>
<li>
<tt>remove(i)</tt> transfers ownership of the node from the set to a temporary
<tt>node_ptr</tt>.
</li>
<li>
The <tt>node_ptr</tt> is dereferenced, and that non-const reference is sent to
<tt>move</tt> to cast it to an rvalue.
</li>
<li>
The rvalue <tt>MoveOnly</tt> is move constructed into <tt>x</tt> from
the <tt>node_ptr</tt>.
</li>
<li>
<tt>~node_ptr()</tt> destructs the moved-from <tt>MoveOnly</tt> and deallocates
the node.
</li>
</ol>

<p>
Contrast this with the <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1041">1041</a> solution:
</p>
<blockquote><pre>MoveOnly x = std::move(s.extract(i).first);
</pre></blockquote>

<p>
The former requires one move construction for <tt>x</tt> while the latter
requires two (one into the <tt>pair</tt> and then one into <tt>x</tt>).  Either
of these constructions can throw (say if there is only a copy constructor for
<tt>x</tt>).  With the former, the point of throw is outside of the container
<tt>s</tt>, after the element has been removed from the container.  With the latter,
one throwing construction takes place prior to the removal of the element, and
the second takes place after the element is removed.
</p>

</li>
</ul>

<p>
The "node insertion" API maintains the API associated with inserting <tt>value_type</tt>s
so the customer can use familiar techniques for getting an iterator to the 
inserted node, or finding out whether it was inserted or not for the "unique"
containers.
</p>

<p>
Lightly prototyped.  No implementation problems.  Appears to work great
for the client.
</p>

</blockquote>
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="840"></a>840. <tt>pair</tt> default template argument</h3>
<p><b>Section:</b> 20.3.4 [pairs] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Thorsten Ottosen <b>Opened:</b> 2008-05-23  <b>Last modified:</b> 2008-06-18</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#pairs">active issues</a> in [pairs].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#pairs">issues</a> in [pairs].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I have one issue with <tt>std::pair</tt>. Well, it might just be a very annoying
historical accident, but why is there no default template argument for
the second template argument? This is so annoying when the type in
question is looong and hard to write (type deduction with <tt>auto</tt> won't
help those cases where we use it as a return or argument type).
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change the synopsis in 20.3 [utility] to read:
</p>

<blockquote><pre>template &lt;class T1, class T2 <ins>= T1</ins>&gt; struct pair;
</pre></blockquote>

<p>
Change 20.3.4 [pairs] to read:
</p>

<blockquote><pre>namespace std {
 template &lt;class T1, class T2 <ins>= T1</ins>&gt;
 struct pair {
   typedef T1 first_type;
   typedef T2 second_type;
   ...
</pre></blockquote>


<p><b>Rationale:</b></p>
<tt>std::pair</tt> is a heterogeneous container.





<hr>
<h3><a name="841"></a>841. cstdint.syn inconsistent with C99</h3>
<p><b>Section:</b> 18.4.1 [cstdint.syn] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2008-05-17  <b>Last modified:</b> 2008-09-17</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#cstdint.syn">issues</a> in [cstdint.syn].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
   <p>

In specifying the names of macros and types defined in
header <code>&lt;stdint.h&gt;</code>, C99 makes use of the
symbol <code><i>N</i></code> to accommodate unusual platforms with
word sizes that aren't powers of two. C99
permits <code><i>N</i></code> to take on any positive integer value
(including, for example, 24).

   </p>
   <p>

In  cstdint.syn Header <code>&lt;cstdint&gt;</code>
synopsis, C++ on the other hand, fixes the value
of <code><i>N</i></code> to 8, 16, 32, and 64, and specifies only
types with these exact widths. 

   </p>
   <p>
   </p>

In addition, paragraph 1 of the same section makes use of a rather
informal shorthand notation to specify sets of macros. When
interpreted strictly, the notation specifies macros such
as <code>INT_8_MIN</code> that are not intended to be specified.

   <p>

Finally, the section is missing the usual table of symbols defined
in that header, making it inconsistent with the rest of the
specification.

   </p>
 
 <p><b>Proposed resolution:</b></p>
   <p>

I propose to use the same approach in the C++ spec as C99 uses, that
is, to specify the header synopsis in terms of "exposition only" types
that make use of the symbol <code><i>N</i></code> to denote one or
more of a theoretically unbounded set of widths.

   </p>
   <p>

Further, I propose to add a new table to section listing the symbols
defined in the header using a more formal notation that avoids
introducing inconsistencies.

   </p>
   <p>

To this effect, in  cstdint.syn
Header <code>&lt;cstdint&gt;</code> synopsis, replace both the
synopsis and paragraph 1 with the following text:

   </p>
   <blockquote>
     <p>
       </p><ol>
         <li>

In the names defined in the <code>&lt;cstdint&gt;</code> header, the
symbol <code><i>N</i></code> represents a positive decimal integer
with no leading zeros (e.g., 8 or 24, but not 0, 04, or 048). With the
exception of exact-width types, macros and types for values
of <code><i>N</i></code> in the set of 8, 16, 32, and 64 are
required. Exact-width types, and any macros and types for values
of <code><i>N</i></code> other than 8, 16, 32, and 64 are
optional. However, if an implementation provides integer types with
widths of 8, 16, 32, or 64 bits, the corresponding exact-width types
and macros are required.

         </li>
       </ol>
     
     <pre>namespace std {

   // required types

   // Fastest minimum-width integer types
   typedef <i>signed integer type</i>   int_fast8_t;
   typedef <i>signed integer type</i>   int_fast16_t;
   typedef <i>signed integer type</i>   int_fast32_t;
   typedef <i>signed integer type</i>   int_fast64_t;

   typedef <i>unsigned integer type</i> uint_fast8_t;
   typedef <i>unsigned integer type</i> uint_fast16_t;
   typedef <i>unsigned integer type</i> uint_fast32_t;
   typedef <i>unsigned integer type</i> uint_fast64_t;

   // Minimum-width integer types
   typedef <i>signed integer type</i>   int_least8_t;
   typedef <i>signed integer type</i>   int_least16_t;
   typedef <i>signed integer type</i>   int_least32_t;
   typedef <i>signed integer type</i>   int_least64_t;

   typedef <i>unsigned integer type</i> uint_least8_t;
   typedef <i>unsigned integer type</i> uint_least16_t;
   typedef <i>unsigned integer type</i> uint_least32_t;
   typedef <i>unsigned integer type</i> uint_least64_t;

   // Greatest-width integer types
   typedef <i>signed integer type</i>   intmax_t;
   typedef <i>unsigned integer type</i> uintmax_t;

   // optionally defined types

   // Exact-width integer types
   typedef <i>signed integer type</i>   int<i>N</i>_t;
   typedef <i>unsigned integer type</i> uint<i>N</i>_t;

   // Fastest minimum-width integer types for values
   // of <i>N</i> other than 8, 16, 32, and 64
   typedef <i>signed integer type</i>   uint_fast<i>N</i>_t;
   typedef <i>unsigned integer type</i> uint_fast<i>N</i>_t;

   // Minimum-width integer types for values
   // of <i>N</i> other than 8, 16, 32, and 64
   typedef <i>signed integer type</i>   uint_least<i>N</i>_t;
   typedef <i>unsigned integer type</i> uint_least<i>N</i>_t;

   // Integer types capable of holding object pointers
   typedef <i>signed integer type</i>   intptr_t;
   typedef <i>signed integer type</i>   intptr_t;

}</pre>
   </blockquote>
   <p>

[Note to editor: Remove all of the existing paragraph 1 from  cstdint.syn.]

   </p>
   <blockquote>
     Table ??: Header <code>&lt;cstdint&gt;</code> synopsis
     <table border="1">
       <thead>
         <tr>
           <th>Type</th>
           <th colspan="3">Name(s)</th>
         </tr>
       </thead>
       <tbody>
         <tr>
           <td rowspan="11"><b>Macros:</b></td>
           <td><tt>INT<i>N</i>_MIN</tt></td>
           <td><tt>INT<i>N</i>_MAX</tt></td>
           <td><tt>UINT<i>N</i>_MAX</tt></td>
         </tr>
         <tr>
           <td><tt>INT_FAST<i>N</i>_MIN</tt></td>
           <td><tt>INT_FAST<i>N</i>_MAX</tt></td>
           <td><tt>UINT_FAST<i>N</i>_MAX</tt></td>
         </tr>
         <tr>
           <td><tt>INT_LEAST<i>N</i>_MIN</tt></td>
           <td><tt>INT_LEAST<i>N</i>_MAX</tt></td>
           <td><tt>UINT_LEAST<i>N</i>_MAX</tt></td>
         </tr>
         <tr>
           <td><tt>INTPTR_MIN</tt></td>
           <td><tt>INTPTR_MAX</tt></td>
           <td><tt>UINTPTR_MAX</tt></td>
         </tr>
         <tr>
           <td><tt>INTMAX_MIN</tt></td>
           <td><tt>INTMAX_MAX</tt></td>
           <td><tt>UINTMAX_MAX</tt></td>
         </tr>
         <tr>
           <td><tt>PTRDIFF_MIN</tt></td>
           <td><tt>PTRDIFF_MAX</tt></td>
           <td><tt>PTRDIFF_MAX</tt></td>
         </tr>
         <tr>
           <td><tt>SIG_ATOMIC_MIN</tt></td>
           <td><tt>SIG_ATOMIC_MAX</tt></td>
           <td><tt>SIZE_MAX</tt></td>
         </tr>
         <tr>
           <td><tt>WCHAR_MIN</tt></td>
           <td><tt>WCHAR_MAX</tt></td>
         <td></td>
         </tr>
         <tr>
           <td><tt>WINT_MIN</tt></td>
           <td><tt>WINT_MAX</tt></td>
           <td></td>
         </tr>
         <tr>
           <td><tt>INT<i>N</i>_C()</tt></td>
           <td><tt>UINT<i>N</i>_C()</tt></td>
           <td></td>
         </tr>
         <tr>
           <td><tt>INTMAX_C()</tt></td>
           <td><tt>UINTMAX_C()</tt></td>
           <td></td>
         </tr>
         <tr>
           <td rowspan="5"><b>Types:</b></td>
           <td><tt>int<i>N</i>_t</tt></td>
           <td><tt>uint<i>N</i>_t</tt></td>
           <td></td>
         </tr>
         <tr>
           <td><tt>int_fast<i>N</i>_t</tt></td>
           <td><tt>uint_fast<i>N</i>_t</tt></td>
           <td></td>
         </tr>
         <tr>
           <td><tt>int_least<i>N</i>_t</tt></td>
           <td><tt>uint_least<i>N</i>_t</tt></td>
           <td></td>
         </tr>
         <tr>
           <td><tt>intptr_t</tt></td>
           <td><tt>uintptr_t</tt></td>
           <td></td>
         </tr>
         <tr>
           <td><tt>intmax_t</tt></td>
           <td><tt>uintmax_t</tt></td>
           <td></td>
         </tr>
       </tbody>
     </table>
   </blockquote>
 




<hr>
<h3><a name="849"></a>849. missing type traits to compute root class and derived class of types in a class hierachy</h3>
<p><b>Section:</b> 20.6.7 [meta.trans.other] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Thorsten Ottosen <b>Opened:</b> 2008-06-05  <b>Last modified:</b> 2008-09-16</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#meta.trans.other">issues</a> in [meta.trans.other].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The type traits library contains various traits to dealt with
polymorphic types, e.g. <tt>std::has_virtual_destructor</tt>, <tt>std::is_polymorphic</tt>
and <tt>std::is_base_of</tt>. However, there is no way to compute the unique
public base class of a type  if such  one exists.  Such a trait could be
very useful if one needs to instantiate a specialization made for the
root class whenever a derived class is passed as parameter. For example,
imagine that you wanted to specialize <tt>std::hash</tt> for a class
hierarchy---instead of specializing each class, you could specialize the
<tt>std::hash&lt;root_class&gt;</tt> and provide a partial specialization that worked
for all derived classes.
</p>

<p>
This ability---to specify operations in terms of their equivalent in the
root class---can be done with e.g. normal functions, but there is,
AFAIK, no way to do it for class templates. Being able to access
compile-time information about the type-hierachy can be very powerful,
and I therefore also suggest traits that computes the directly derived
class whenever that is possible.
</p>

<p>
If the computation can not be done, the traits should fall back on an
identity transformation. I expect this gives the best overall usability.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add the following to the synopsis in 20.6.2 [meta.type.synop] under "other transformations":
</p>

<blockquote><pre>template&lt; class T &gt; struct direct_base_class;
template&lt; class T &gt; struct direct_derived_class;
template&lt; class T &gt; struct root_base_class;
</pre></blockquote>

<p>
Add three new entries to table 51 (20.6.7 [meta.trans.other]) with the following content
</p>

<blockquote>
<table border="1">
<tbody><tr>
<th>Template</th><th>Condition</th><th>Comments</th>
</tr>
<tr>
<td><tt>template&lt; class T &gt; struct direct_base_class;</tt></td>
<td><tt>T</tt> shall be a complete type.</td>
<td>The member typedef <tt>type</tt> shall equal the accessible unambiguous direct base class of <tt>T</tt>.
If no such type exists, the member typedef <tt>type</tt> shall equal <tt>T</tt>.</td>
</tr>
<tr>
<td><tt>template&lt; class T &gt; struct direct_derived_class;</tt></td>
<td><tt>T</tt> shall be a complete type.</td>
<td>The member typedef <tt>type</tt> shall equal the unambiguous type which has <tt>T</tt>
as an accessible unambiguous direct base class. If no such type exists, the member typedef
<tt>type</tt> shall equal <tt>T</tt>.</td>
</tr>
<tr>
<td><tt>template&lt; class T &gt; struct root_base_class;</tt></td>
<td><tt>T</tt> shall be a complete type.</td>
<td>The member typedef <tt>type</tt> shall equal the accessible unambiguous most indirect base class of
<tt>T</tt>. If no such type exists, the member typedef type shall equal <tt>T</tt>.</td>
</tr>
</tbody></table>
</blockquote>



<p><b>Rationale:</b></p>
2008-9-16 San Francisco:  Issue pulled by author prior to being reviewed by the LWG.





<hr>
<h3><a name="851"></a>851. simplified array construction</h3>
<p><b>Section:</b> 23.3.1 [array] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Future">NAD Future</a>
 <b>Submitter:</b> Benjamin Kosnik <b>Opened:</b> 2008-06-05  <b>Last modified:</b> 2009-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#array">issues</a> in [array].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Future">NAD Future</a> status.</p>
<p><b>Discussion:</b></p>
<p>
This is an issue that came up on the libstdc++ list, where a
discrepancy between "C" arrays and C++0x's <tt>std::array</tt> was pointed
out.
</p>

<p>
In "C," this array usage is possible:
</p>

<blockquote><pre>int ar[] = {1, 4, 6};
</pre></blockquote>

<p>
But for C++, 
</p>

<blockquote><pre>std::array&lt;int&gt; a = { 1, 4, 6 }; // error
</pre></blockquote>

<p>
Instead, the second parameter of the <tt>array</tt> template must be
explicit, like so:
</p>

<blockquote><pre>std::array&lt;int, 3&gt; a = { 1, 4, 6 };
</pre></blockquote>

<p>
Doug Gregor proposes the following solution, that assumes
generalized initializer lists.
</p>

<blockquote><pre>template&lt;typename T, typename... Args&gt;
inline array&lt;T, sizeof...(Args)&gt; 
make_array(Args&amp;&amp;... args) 
{ return { std::forward&lt;Args&gt;(args)... };  }
</pre></blockquote>

<p>
Then, the way to build an <tt>array</tt> from a list of unknown size is:
</p>

<blockquote><pre>auto a = make_array&lt;T&gt;(1, 4, 6);
</pre></blockquote>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
<p>
Benjamin: Move to Ready?
</p>
<p>
Bjarne: I'm not convinced this is useful enough to add, so I'd like us
to have time to reflect on it.
</p>
<p>
Alisdair: the constraints are wrong, they should be
</p>
<blockquote><pre>template&lt;ValueType T, ValueType... Args&gt;
requires Convertible&lt;Args, T&gt;...
array&lt;T, sizeof...(Args)&gt; make_array(Args&amp;&amp;... args);
</pre></blockquote>
<p>
Alidair: this would be useful if we had a constexpr version.
</p>
<p>
Bjarne: this is probably useful for arrays with a small number of
elements, but it's not clearly useful otherwise.
</p>
<p>
Consensus is to move to Open.
</p>
</blockquote>

<p><i>[
2009-06-07 Daniel adds:
]</i></p>


<blockquote>
<p>
I suggest a fix and a simplification of the current proposal: Recent
prototyping by
Howard showed, that a fix is required because narrowing conversion
8.5.4 [dcl.init.list]/6 b.3
would severely limit the possible distribution of argument types, e.g.
the expression
<tt>make_array&lt;double&gt;(1, 2.0)</tt> is ill-formed, because the narrowing
happens <em>inside</em> the
function body where no constant expressions exist anymore. Furthermore
given e.g.
</p>
<blockquote><pre>int f();
double g();
</pre></blockquote>
<p>
we probably want to support
</p>
<blockquote><pre>make_array&lt;double&gt;(f(), g());
</pre></blockquote>

<p>
as well. To make this feasible, the currently suggested expansion
</p>

<blockquote><pre>{ std::forward&lt;Args&gt;(args)... }
</pre></blockquote>

<p>
needs to be replaced by
</p>

<blockquote><pre>{ static_cast&lt;T&gt;(std::forward&lt;Args&gt;(args))... }
</pre></blockquote>

<p>
which is safe, because we already ensure convertibility via the
element-wise <tt>Convertible&lt;Args, T&gt;</tt> requirement. Some other fixes are
necessary: The <tt>ValueType</tt> requirement for the function <em>parameters</em>
is invalid, because all lvalue arguments will deduce to an lvalue-reference,
thereby no longer satisfying this requirement.
</p>

<p>
The suggested simplification is to provide a default-computed effective
type for the result array based on common_type and decay, in
unconstrained form:
</p>

<blockquote><pre>template&lt;typename... Args&gt;
array&lt;typename decay&lt;typename common_type&lt;Args...&gt;::type&gt;::type,
sizeof...(Args)&gt;
make_array(Args&amp;&amp;... args);
</pre></blockquote>

<p>
The approach used below is similar to that of <tt>make_pair</tt> and <tt>make_tuple</tt>
using a symbol <tt>C</tt> to represent the decayed common type [Note: Special
handling of <tt>reference_wrapper</tt> types is intentionally <em>not</em> provided, because
our target has so satisfy <tt>ValueType</tt>, thus under the revised proposal only
an all-<tt>reference_wrapper</tt>-arguments would be well-formed and an array of
<tt>reference_wrapper</tt> will be constructed]. I do currently not suggest to
add new concepts reflecting <tt>decay</tt> and <tt>common_type</tt>, but an implementor will
need something like this to succeed. Note that we use a similar fuzziness for
<tt>make_pair</tt> and <tt>make_tuple</tt> currently. This fuzziness is not related to
the currently
missing <tt>Constructible&lt;Vi, Ti&amp;&amp;&gt;</tt> requirement for those functions. The following
proposal fixes that miss for <tt>make_array</tt>. If the corresponding <tt>C</tt> type
deduction is
explicitly wanted for standardization, here the implementation
</p>

<blockquote><pre>auto concept DC&lt;typename... T&gt; {
  typename type = typename decay&lt;typename common_type&lt;T...&gt;::type&gt;::type;
}
</pre></blockquote>

<p>
where <tt>C</tt> is identical to <tt>DC&lt;Args...&gt;::type</tt> in the proposed resolution below.
</p>
<p>
I intentionally added no further type relation between type and the concept
template parameters, but instead added this requirement below to make
the specification as transparent as possible. As written this concept is
satisfied, if the corresponding associated type exists.
</p>

<p><b>Suggested Resolution:</b></p>

<ol>
<li>
<p>
Add to the array synopsis in 23.3 [sequences]:
</p>
<blockquote><pre><ins>
template&lt;ReferentType... Args&gt;
requires ValueType&lt;C&gt; &amp;&amp; IdentityOf&lt;Args&gt; &amp;&amp; Constructible&lt;C, Args&amp;&amp;&gt;...
array&lt;C, sizeof...(Args)&gt;
make_array(Args&amp;&amp;... args);
</ins>
</pre></blockquote>
</li>

<li>
<p>
Append after 23.3.1.7 [array.tuple] Tuple interface to class template array
the following new section:
</p>
<blockquote>
<p>
23.4.1.7 Array creation functions [array.creation]
</p>

<pre><ins>
template&lt;ReferentType... Args&gt;
requires ValueType&lt;C&gt; &amp;&amp; IdentityOf&lt;Args&gt; &amp;&amp; Constructible&lt;C, Args&amp;&amp;&gt;...
array&lt;C, sizeof...(Args)&gt;
make_array(Args&amp;&amp;... args);</ins>
</pre>

<blockquote>
<p><ins>
Let <tt>C</tt> be <tt>decay&lt;common_type&lt;Args...&gt;::type&gt;::type</tt>.
</ins></p>
<p>
<ins><i>Returns:</i> an <tt>array&lt;C, sizeof...(Args)&gt;</tt> initialized with
<tt>{ static_cast&lt;C&gt;(std::forward&lt;Args&gt;(args))... }</tt>.
</ins></p>
</blockquote>
</blockquote>

</li>

</ol>

</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
<p>
The proposed resolution uses concepts.
</p>
<p>
Daniel to rewrite the proposed resolution.
</p>
<p>
Leave Open.
</p>
</blockquote>

<p><i>[
2009-07-25 Daniel provides rewritten proposed resolution.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Argument for NAD future: everything about this could be added on. This
does not require changes to the existing text.
</blockquote>



<p><b>Proposed resolution:</b></p>

<ol>
<li>
<p>
Add to the array synopsis in 23.3 [sequences]:
</p>

<blockquote><pre><ins>template&lt;class... Args&gt;
  array&lt;<i>CT</i>, sizeof...(Args)&gt;
  make_array(Args&amp;&amp;... args);</ins>
</pre></blockquote>
</li>

<li>
<p>
Append after 23.3.1.7 [array.tuple] "Tuple interface to class template array" the
following new section:
</p>

<blockquote>
<p>
<ins>XX.X.X.X Array creation functions [array.creation]</ins>
</p>

<pre><ins>
template&lt;class... Args&gt;
array&lt;<i>CT</i>, sizeof...(Args)&gt;
make_array(Args&amp;&amp;... args)
</ins></pre>

<blockquote>
<p>
<ins>Let <i>CT</i> be <tt>decay&lt;common_type&lt;Args...&gt;::type&gt;::type</tt>.</ins>
</p>
<p>
<ins><i>Returns:</i> An <tt>array&lt;<i>CT</i>, sizeof...(Args)&gt;</tt> initialized with <tt>{
static_cast&lt;<i>CT</i>&gt;(std::forward&lt;Args&gt;(args))... }</tt>.</ins>
</p>

<p><ins>
[<i>Example:</i>
</ins></p>
<blockquote><pre><ins>
int i = 0; int&amp; ri = i;
make_array(42u, i, 2.78, ri);
</ins></pre></blockquote>
<p><ins>
returns an array of type
</ins></p>
<blockquote><pre><ins>
array&lt;double, 4&gt;
</ins></pre></blockquote>

<p><ins>
&#8212;<i>end example</i>]</ins>
</p>
</blockquote>
</blockquote>
</li>

</ol>








<hr>
<h3><a name="855"></a>855. capacity() and reserve() for deque?</h3>
<p><b>Section:</b> 23.3.2.2 [deque.capacity] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Herv Brnnimann <b>Opened:</b> 2008-06-11  <b>Last modified:</b> 2008-09-22</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#deque.capacity">issues</a> in [deque.capacity].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The main point is that <tt>capacity</tt> can be viewed as a mechanism to  
guarantee the validity of <tt>iterators</tt> when only <tt>push_back/pop_back</tt>
operations are used.  For <tt>vector</tt>, this goes with reallocation.  For  
<tt>deque</tt>, this is a bit more subtle:  <tt>capacity()</tt> of a <tt>deque</tt> may shrink,  
whereas that of <tt>vector</tt> doesn't.   In a circular buffer impl. of the  
map, as Howard did, there is very similar notion of capacity: as long  
as <tt>size()</tt> is less than <tt>B * (</tt>total size of the map <tt>- 2)</tt>, it is  
guaranteed that no <tt>iterator</tt> is invalidated after any number of  
<tt>push_front/back</tt> and <tt>pop_front/back</tt> operations.  But this does not  
hold for other implementations.
</p>
<p>
Still, I believe, <tt>capacity()</tt> can be defined by <tt>size() +</tt>  how many  
<tt>push_front/back</tt> minus <tt>pop_front/back</tt> that can be performed before  
terators are invalidated.  In a classical impl., <tt>capacity() = size()
+ </tt> the min distance to either "physical" end of the deque (i.e.,  
counting the empty space in the last block plus all the blocks until  
the end of the map of block pointers).  In Howard's circular buffer  
impl., <tt>capacity() = B * (</tt>total size of the map <tt>- 2)</tt> still works with  
this definition, even though the guarantee could be made stronger.
</p>
<p>
A simple picture of a deque:
</p>
<blockquote><pre>A-----|----|-----|---F+|++++|++B--|-----|-----Z
</pre></blockquote>
<p>
(A,Z mark the beginning/end, | the block boundaries, F=front, B=back,  
and - are uninitialized, + are initialized)
In that picture:  <tt>capacity = size() + min(dist(A,F),dist(B,Z)) = min 
(dist(A,B),dist(F,Z))</tt>.
</p>
<p>
<tt>Reserve(n)</tt> can grow the map of pointers and add possibly a number of  
empty blocks to it, in order to guarantee that the next <tt>n-size()
push_back/push_front</tt> operations will not invalidate iterators, and  
also will not allocate (i.e. cannot throw).  The second guarantee is  
not essential and can be left as a QoI.  I know well enough existing  
implementations of <tt>deque</tt> (sgi/stl, roguewave, stlport, and  
dinkumware) to know that either can be implemented with no change to  
the existing class layout and code, and only a few modifications if  
blocks are pre-allocated (instead of always allocating a new block,  
check if the next entry in the map of block pointers is not zero).
</p>
<p>
Due to the difference with <tt>vector</tt>, wording is crucial.  Here's a  
proposed wording to make things concrete;  I tried to be reasonably  
careful but please double-check me:
</p>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
<p>
Hans: should the Returns clause for capacity read "1 Returns: A lower
bound..." rather than "1 Returns: An upper bound..."
</p>
<p>
Howard: maybe what's needed is capacity_front and capacity_back. In
fact, I think I implemented a deque that had these members as
implementation details.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>

<p>
Add new signatures to synopsis in 23.3.2 [deque]:
</p>

<blockquote><pre>size_type capacity() const;
bool reserve(size_type n);
</pre></blockquote>

<p>
Add new signatures to 23.3.2.2 [deque.capacity]:
</p>

<blockquote>
<pre>size_type capacity() const;
</pre>
<blockquote>
<p>
1 <i>Returns:</i> An upper bound on <tt>n + max(n_f - m_f, n_b - m_b)</tt>  such  
that, for any sequence of <tt>n_f push_front</tt>, <tt>m_f pop_front</tt>, <tt>n_b  
push_back</tt>, and <tt>m_b pop_back</tt> operations, interleaved in any order,  
starting with the current <tt>deque</tt> of size <tt>n</tt>, the <tt>deque</tt> does not  
invalidate any of its iterators except to the erased elements.
</p>
<p>
2 <i>Remarks:</i>  Unlike a <tt>vector</tt>'s capacity, the capacity of a <tt>deque</tt> can  
decrease after a sequence of insertions at both ends, even if none of  
the operations caused the <tt>deque</tt> to invalidate any of its iterators  
except to the erased elements.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>bool reserve(size_type n);
</pre>
<blockquote>
<p>
2 <i>Effects:</i> A directive that informs a <tt>deque</tt> of a planned sequence of  
<tt>push_front</tt>, <tt>pop_front</tt>, <tt>push_back</tt>, and <tt>pop_back</tt> operations, so that it  
can manage iterator invalidation accordingly. After <tt>reserve()</tt>,  
<tt>capacity()</tt> is greater or equal to the argument of <tt>reserve</tt> if this  
operation returns <tt>true</tt>; and equal to the previous value of <tt>capacity()</tt>
otherwise.  If an exception is thrown, there are no effects.
</p>
<p>
3 <i>Returns:</i> <tt>true</tt> if iterators are invalidated as a result of this  
operation, and false otherwise.
</p>
<p>
4 <i>Complexity:</i> It does not change the size of the sequence and takes  
at most linear time in <tt>n</tt>.
</p>
<p>
5 <i>Throws:</i> <tt>length_error</tt> if <tt>n &gt; max_size()</tt>.
</p>
<p>
6 <i>Remarks:</i> It is guaranteed that no invalidation takes place during a  
sequence of <tt>insert</tt> or <tt>erase</tt> operations at either end that happens  
after a call to <tt>reserve()</tt> except to the erased elements, until the  
time when an insertion would make <tt>max(n_f-m_f, n_b-m_b)</tt> larger than  
<tt>capacity()</tt>, where <tt>n_f</tt> is the number of <tt>push_front</tt>, <tt>m_f</tt> of <tt>pop_front</tt>,  
<tt>n_b</tt> of <tt>push_back</tt>, and <tt>m_b</tt> of <tt>pop_back</tt> operations since the call to  
<tt>reserve()</tt>.
</p>
<p>
7        An implementation is free to pre-allocate buffers so as to  
offer the additional guarantee that no exception will be thrown  
during such a sequence other than by the element constructors.
</p>
</blockquote>
</blockquote>

<p>
And 23.3.2.3 [deque.modifiers] para 1, can be enhanced:
</p>

<blockquote>
1 <i>Effects:</i> An insertion in the middle of the deque invalidates all the iterators and references to elements of the
deque. An insertion at either end of the deque invalidates all the iterators to the deque,
<ins>unless provisions have been made with reserve,</ins>
but has no effect on the validity of references to elements of the deque.
</blockquote>


<p><b>Rationale:</b></p>
Complication outweighs the benefit.





<hr>
<h3><a name="862"></a>862. Impossible complexity for 'includes'</h3>
<p><b>Section:</b> 25.4.5.1 [includes] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2008-07-02  <b>Last modified:</b> 2009-07-13</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#includes">issues</a> in [includes].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 25.4.5.1 [includes] the complexity is "at most -1 comparisons" if passed
two empty ranges.  I don't know how to perform a negative number of
comparisions!
</p>

<p>
This same issue also applies to:
</p>

<ul>
<li><tt>set_union</tt></li>
<li><tt>set_intersection</tt></li>
<li><tt>set_difference</tt></li>
<li><tt>set_symmetric_difference</tt></li>
<li><tt>merge</tt></li>
</ul>

<p><i>[
2009-03-30 Beman adds:
]</i></p>


<blockquote>
Suggest NAD. The complexity of empty ranges is -1 in other places in the
standard. See 25.4.4 [alg.merge] <tt>merge</tt> and
<tt>inplace_merge</tt>, and <tt>forward_list</tt> merge, for example.
The time and effort to find and fix all places in the standard where
empty range[s] result in negative complexity isn't worth the very
limited benefit.
</blockquote>

<p><i>[
2009-05-09 Alisdair adds:
]</i></p>


<blockquote>
<p>
I'm not happy with NAD if we can find a simple solution.
</p>
<p>
How about adding a rider somewhere in clause 17 suggesting that complexities
that specify a negative number of operations are treated as specifying zero
operations?  That should generically solve the issue without looking for
further cases.
</p>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Pete to provide "straightforward" wording.
Move to NAD Editorial.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Recommend NAD.
</p>





<hr>
<h3><a name="863"></a>863. What is the state of a stream after close() succeeds</h3>
<p><b>Section:</b> 27.9.1 [fstreams] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Steve Clamage <b>Opened:</b> 2008-07-08  <b>Last modified:</b> 2009-07-13</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#fstreams">issues</a> in [fstreams].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Suppose writing to an <tt>[o]fstream</tt> fails and you later close the <tt>stream</tt>.
The <tt>overflow()</tt> function is called to flush the buffer (if it exists).
Then the file is unconditionally closed, as if by calling <tt>flcose</tt>.
</p>
<p>
If either <tt>overflow</tt> or <tt>fclose</tt> fails, <tt>close()</tt> reports failure, and clearly
the <tt>stream</tt> should be in a failed or bad state.
</p>
<p>
Suppose the buffer is empty or non-existent (so that <tt>overflow()</tt> does not
fail), and <tt>fclose</tt> succeeds. The <tt>close()</tt> function reports success, but
what is the state of the <tt>stream</tt>?
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Tom's impression is that the issue is about the <tt>failbit</tt>, etc.
</p>
<p>
Bill responds that the stream is now closed,
and any status bits remain unchanged.
</p>
<p>
See the description of <tt>close()</tt> in 27.9.1.17 [fstream.members].
</p>
<p>
We prefer not to add wording to say that nothing changes.
Move to NAD.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="864"></a>864. Defect in atomic wording</h3>
<p><b>Section:</b> 29.6 [atomics.types.operations] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Anthony Williams <b>Opened:</b> 2008-07-10  <b>Last modified:</b> 2008-09-17</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#atomics.types.operations">issues</a> in [atomics.types.operations].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There's an error in 29.6 [atomics.types.operations]/p9:
</p>

<blockquote>
<pre>C atomic_load(const volatile A * object);
C atomic_load_explicit(const volatile A * object, memory_order);
C A ::load(memory_order order = memory_order_seq_cst) const volatile;
</pre>
<blockquote>
<p>
<i>Requires:</i> The <tt>order</tt> argument shall not be <tt>memory_order_acquire</tt> nor
<tt>memory_order_acq_rel</tt>.
</p>
</blockquote>
</blockquote>

<p>
I believe that this should state
</p>
<blockquote>
shall not be <tt>memory_order_release</tt>.
</blockquote>

<p>
There's also an error in 29.6 [atomics.types.operations]/p17:
</p>

<blockquote>
... When only one <tt>memory_order</tt> argument is supplied, the value of success
is <tt>order</tt>, and
the value of failure is <tt>order</tt> except that a value of
<tt>memory_order_acq_rel</tt> shall be replaced by the value
<tt>memory_order_require</tt> ...
</blockquote>
<p>
I believe this should state
</p>
<blockquote>
shall be replaced by the value <tt>memory_order_acquire</tt> ...
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 29.6 [atomics.types.operations]/p9:
</p>

<blockquote>
<pre>C atomic_load(const volatile A * object);
C atomic_load_explicit(const volatile A * object, memory_order);
C A ::load(memory_order order = memory_order_seq_cst) const volatile;
</pre>
<blockquote>
<p>
<i>Requires:</i> The <tt>order</tt> argument shall not be <del><tt>memory_order_acquire</tt></del>
<ins><tt>memory_order_release</tt></ins> nor <tt>memory_order_acq_rel</tt>.
</p>
</blockquote>
</blockquote>

<p>
Change 29.6 [atomics.types.operations]/p17:
</p>

<blockquote>
... When only one <tt>memory_order</tt> argument is supplied, the value of success
is <tt>order</tt>, and
the value of failure is <tt>order</tt> except that a value of
<tt>memory_order_acq_rel</tt> shall be replaced by the value
<del><tt>memory_order_require</tt></del> <ins><tt>memory_order_acquire</tt></ins> ...
</blockquote>



<p><b>Rationale:</b></p>
Already fixed by the time the LWG processed it.





<hr>
<h3><a name="867"></a>867. Valarray and value-initialization</h3>
<p><b>Section:</b> 26.6.2.1 [valarray.cons] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Alberto Ganesh Barbati <b>Opened:</b> 2008-07-20  <b>Last modified:</b> 2009-07-13</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#valarray.cons">issues</a> in [valarray.cons].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
From 26.6.2.1 [valarray.cons], paragraph 2:
</p>

<blockquote><pre>explicit  valarray(size_t);
</pre>
<blockquote>
The array created by this constructor has a length equal to the value of the argument. The elements
of the array are constructed using the default constructor for the instantiating type <tt>T</tt>.
</blockquote>
</blockquote>

<p>
The problem is that the most obvious <tt>T</tt>s for <tt>valarray</tt> are <tt>float</tt>
and <tt>double</tt>, they don't have a default constructor. I guess the intent is to value-initialize
the elements, so I suggest replacing:
</p>

<blockquote>
The elements of the array are constructed using the default constructor for the instantiating type <tt>T</tt>.
</blockquote>
<p>
with
</p>
<blockquote>
The elements of the array are value-initialized.
</blockquote>

<p>
There is another reference to the default constructor of <tt>T</tt> in the non-normative note in paragraph 9.
That reference should also be replaced. (The normative wording in paragraph 8 refers to <tt>T()</tt>
and so it doesn't need changes).
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution.
Move to NAD Editorial.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 26.6.2.1 [valarray.cons], paragraph 2:
</p>

<blockquote>
<pre>explicit  valarray(size_t);
</pre>
<blockquote>
The array created by this constructor has a length equal to the value of the argument. The elements
of the array are <del>constructed using the default constructor for the instantiating type <tt>T</tt></del>
<ins>value-initialized (8.5 [dcl.init])</ins>.
</blockquote>
</blockquote>

<p>
Change 26.6.2.7 [valarray.members], paragraph 9:
</p>

<blockquote>
[<i>Example:</i> If the argument has the value -2, the first two elements of the result will be <del>constructed using the 
default constructor</del>
<ins>value-initialized (8.5 [dcl.init])</ins>;
the third element of the result will be assigned the value of the first element of the argument; etc. <i>-- end example</i>]
</blockquote>






<hr>
<h3><a name="873"></a>873. signed integral type and unsigned integral type are not clearly defined</h3>
<p><b>Section:</b> 3.9.1 [basic.fundamental] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Travis Vitek <b>Opened:</b> 2008-06-30  <b>Last modified:</b> 2009-07-17</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
    <p>
      Neither the term "signed integral type" nor the term "unsigned
      integral type" is defined in the core language section of the
      standard, therefore the library section should avoid its use.  The
      terms <i>signed integer type</i> and <i>unsigned integer type</i> are
      indeed defined (in 3.9.1 [basic.fundamental]), thus the usages should be
      replaced accordingly.
    </p>

    <p>
      Note that the key issue here is that "signed" + "integral type" !=
      "signed integral type".
      
      The types <code>bool</code>, <code>char</code>, <code>char16_t</code>,
      <code>char32_t</code> and <code>wchar_t</code> are all listed as
      integral types, but are neither of <i>signed integer type</i> or
      <i>unsigned integer type</i>. According to 3.9 [basic.types] p7, a synonym for
      integral type is <i>integer type</i>.
      
      Given this, one may choose to assume that an <i>integral type</i> that
      can represent values less than zero is a <i>signed integral type</i>.
      Unfortunately this can cause ambiguities.
      
      As an example, if <code>T</code> is <code>unsigned char</code>, the
      expression <code>make_signed&lt;T&gt;::type</code>, is supposed to
      name a signed integral type. There are potentially two types that
      satisfy this requirement, namely <code>signed char</code> and
      <code>char</code> (assuming <code>CHAR_MIN &lt; 0</code>).
    </p>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
Plum, Sebor to review.
</blockquote>

<p><i>[
Post Summit Daniel adds:
]</i></p>


<blockquote>
The proposed resolution needs to be "conceptualized". Currently we have
in  [concept.support] only concept <tt>IntegralType</tt>
for all "integral types", thus indeed the current <tt>Container</tt>
concept and Iterator concepts are sufficiently satisfied with "integral
types". If the changes are applied, we might ask core for concept
<tt>BilateralIntegerType</tt> and add proper restrictions to the library
concepts.
</blockquote>

  

  <p><b>Proposed resolution:</b></p>
    <p>
      I propose to use the terms "signed integer type" and "unsigned integer
      type" in place of "signed integral type" and "unsigned integral type"
      to eliminate such ambiguities.
    </p>
    
    <p>
      The proposed change makes it absolutely clear that the difference
      between two pointers cannot be <tt>char</tt> or <tt>wchar_t</tt>,
      but could be any of the signed integer types.
      5.7 [expr.add] paragraph 6...
    </p>
    <blockquote>
      <p>
        </p><ol>
          <li>
            When two pointers to elements of the same array object are
            subtracted, the result is the difference of the subscripts of
            the two array elements. The type of the result is an
            implementation-defined <del>signed integral
            type</del><ins>signed integer type</ins>; this type shall be the
            same type that is defined as <code>std::ptrdiff_t</code> in the
            <code>&lt;cstdint&gt;</code> header (18.1)...
          </li>
        </ol>
      
    </blockquote>

    <p>
      The proposed change makes it clear that <tt>X::size_type</tt> and
      <tt>X::difference_type</tt> cannot be <tt>char</tt> or
      <tt>wchar_t</tt>, but could be one of the signed or unsigned integer
      types as appropriate.
      20.2.2 [allocator.requirements] table 40...
    </p>
    <blockquote>
      Table 40: Allocator requirements
      <table border="1">
        <thead>
          <tr>
            <th>expression</th>
            <th>return type</th>
            <th>assertion/note/pre/post-condition</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><tt>X::size_type</tt></td>
            <td>
              <del>unsigned integral type</del>
              <ins>unsigned integer type</ins>
            </td>
            <td>a type that can represent the size of the largest object in
            the allocation model.</td>
          </tr>
          <tr>
            <td><tt>X::difference_type</tt></td>
            <td>
              <del>signed integral type</del>
              <ins>signed integer type</ins>
            </td>
            <td>a type that can represent the difference between any two
            pointers in the allocation model.</td>
          </tr>
        </tbody>
      </table>
    </blockquote>

    <p>
      The proposed change makes it clear that <tt>make_signed&lt;T&gt;::type</tt>
      must be one of the signed integer types as defined in 3.9.1. Ditto for
      <tt>make_unsigned&lt;T&gt;type</tt> and unsigned integer types.
      20.6.6.3 [meta.trans.sign] table 48...
    </p>
    <blockquote>
      Table 48: Sign modifications
      <table border="1">
        <thead>
          <tr>
            <th>Template</th>
            <th>Comments</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>
              <tt>template &lt;class T&gt; struct make_signed;</tt>
            </td>
            <td>
              If <code>T</code> names a (possibly cv-qualified) <del>signed
              integral type</del><ins>signed integer type</ins> (3.9.1) then
              the member typedef <code>type</code> shall name the type
              <code>T</code>; otherwise, if <code>T</code> names a (possibly
              cv-qualified) <del>unsigned integral type</del><ins>unsigned
              integer type</ins> then <code>type</code> shall name the
              corresponding <del>signed integral type</del><ins>signed
              integer type</ins>, with the same cv-qualifiers as
              <code>T</code>; otherwise, <code>type</code> shall name the
              <del>signed integral type</del><ins>signed integer type</ins>
              with the smallest rank (4.13) for which <code>sizeof(T) ==
              sizeof(type)</code>, with the same cv-qualifiers as
              <code>T</code>.

              <i>Requires:</i> <code>T</code> shall be a (possibly
              cv-qualified) integral type or enumeration but not a
              <code>bool</code> type.
            </td>
          </tr>
          <tr>
            <td>
              <tt>template &lt;class T&gt; struct make_unsigned;</tt>
            </td>
            <td>
              If <code>T</code> names a (possibly cv-qualified)
              <del>unsigned integral type</del><ins>unsigned integer
              type</ins> (3.9.1) then the member typedef <code>type</code>
              shall name the type <code>T</code>; otherwise, if
              <code>T</code> names a (possibly cv-qualified) <del>signed
              integral type</del><ins>signed integer type</ins> then
              <code>type</code> shall name the corresponding <del>unsigned
              integral type</del><ins>unsigned integer type</ins>, with the
              same cv-qualifiers as <code>T</code>; otherwise,
              <code>type</code> shall name the <del>unsigned integral
              type</del><ins>unsigned integer type</ins> with the smallest
              rank (4.13) for which <code>sizeof(T) == sizeof(type)</code>,
              with the same cv-qualifiers as <code>T</code>.

              <i>Requires:</i> <code>T</code> shall be a (possibly
              cv-qualified) integral type or enumeration but not a
              <code>bool</code> type.
            </td>
          </tr>
        </tbody>
      </table>
    </blockquote>


    <p>
      Note: I believe that the basefield values should probably be
      prefixed with <tt>ios_base::</tt> as they are in 22.4.2.2.2 [facet.num.put.virtuals]

      The listed virtuals are all overloaded on signed and unsigned integer
      types, the new wording just maintains consistency.

      22.4.2.1.2 [facet.num.get.virtuals] table 78...
    </p>
    <blockquote>
      Table 78: Integer Conversions
      <table border="1">
        <thead>
          <tr>
            <th>State</th>
            <th><tt>stdio</tt> equivalent</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><tt>basefield == oct</tt></td>
            <td><tt>%o</tt></td>
          </tr>
          <tr>
            <td><tt>basefield == hex</tt></td>
            <td><tt>%X</tt></td>
          </tr>
          <tr>
            <td><tt>basefield == 0</tt></td>
            <td><tt>%i</tt></td>
          </tr>
          <tr>
            <td><del>signed integral type</del><ins>signed integer
            type</ins></td>
            <td><tt>%d</tt></td>
          </tr>
          <tr>
            <td><del>unsigned integral type</del><ins>unsigned integer
            type</ins></td>
            <td><tt>%u</tt></td>
          </tr>
        </tbody>
      </table>
    </blockquote>

    
    
    <p>
      Rationale is same as above.
      22.4.2.2.2 [facet.num.put.virtuals] table 80...
    </p>
    <blockquote>
      Table 80: Integer Conversions
      <table border="1">
        <thead>
          <tr>
            <th>State</th>
            <th><tt>stdio</tt> equivalent</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><tt>basefield == ios_base::oct</tt></td>
            <td><tt>%o</tt></td>
          </tr>
          <tr>
            <td><tt>(basefield == ios_base::hex) &amp;&amp;
            !uppercase</tt></td>
            <td><tt>%x</tt></td>
          </tr>
          <tr>
            <td><tt>(basefield == ios_base::hex)</tt></td>
            <td><tt>%X</tt></td>
          </tr>
          <tr>
            <td><tt>basefield == 0</tt></td>
            <td><tt>%i</tt></td>
          </tr>
          <tr>
            <td>for a <del>signed integral type</del><ins>signed integer
            type</ins></td>
            <td><tt>%d</tt></td>
          </tr>
          <tr>
            <td>for a <del>unsigned integral type</del><ins>unsigned integer
            type</ins></td>
            <td><tt>%u</tt></td>
          </tr>
        </tbody>
      </table>
    </blockquote>

    
    <p>
      23.2 [container.requirements] table 80...
    </p>
    <blockquote>
      Table 89: Container requirements
      <table border="1">
        <thead>
          <tr>
            <th>expression</th>
            <th>return type</th>
            <th>operational semantics</th>
            <th>assertion/note/pre/post-condition</th>
            <th>complexity</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><tt>X::difference_type</tt></td>
            <td><del>signed integral type</del><ins>signed integer type</ins></td>
            <td>&nbsp;</td>
            <td>is identical to the difference type of <tt>X::iterator</tt>
            and <tt>X::const_iterator</tt></td>
            <td>compile time</td>
          </tr>
          <tr>
            <td><tt>X::size_type</tt></td>
            <td><del>unsigned integral type</del><ins>unsigned integer type</ins></td>
            <td>&nbsp;</td>
            <td><tt>size_type</tt> can represent any non-negative value of
            <tt>difference_type</tt></td>
            <td>compile time</td>
          </tr>
        </tbody>
      </table>
    </blockquote>

    <p>
      X [iterator.concepts] paragraph 1...
    </p>
    <blockquote>
      Iterators are a generalization of pointers that allow a C++ program to
      work with different data structures (containers) in a uniform manner.
      To be able to construct template algorithms that work correctly and
      efficiently on different types of data structures, the library
      formalizes not just the interfaces but also the semantics and
      complexity assumptions of iterators. All input iterators
      <code>i</code> support the expression <code>*i</code>, resulting in a
      value of some class, enumeration, or built-in type <code>T</code>,
      called the <i>value type</i> of the iterator. All output iterators
      support the expression <code>*i = o</code> where <code>o</code> is a
      value of some type that is in the set of types that are
      <i>writable</i> to the particular iterator type of <code>i</code>. All
      iterators <code>i</code> for which the expression <code>(*i).m</code>
      is well-defined, support the expression <code>i-&gt;m</code> with the
      same semantics as <code>(*i).m</code>. For every iterator type
      <code>X</code> for which equality is defined, there is a corresponding
      <del>signed integral type</del> <ins>signed integer type</ins> called
      the <i>difference type</i> of the iterator.
    </blockquote>
    
    <p>
      I'm a little unsure of this change. Previously this paragraph would
      allow instantiations of <tt>linear_congruential_engine</tt> on
      <tt>char</tt>, <tt>wchar_t</tt>, <tt>bool</tt>, and other types. The
      new wording prohibits this.
      26.5.3.1 [rand.eng.lcong] paragraph 2...
    </p>
    <blockquote>
      The template parameter <code>UIntType</code> shall denote an
      <del>unsigned integral type</del><ins>unsigned integer type</ins>
      large enough to store values as large as <code>m - 1</code>. If the
      template parameter <code>m</code> is 0, the modulus <code>m</code>
      used throughout this section 26.4.3.1 is
      <code>numeric_limits&lt;result_type&gt;::max()</code> plus 1.  [Note:
      The result need not be representable as a value of type
      <code>result_type</code>. --end note] Otherwise, the following
      relations shall hold: <code>a &lt; m</code> and <code>c &lt;
      m</code>.
    </blockquote>
    
    <p>
      Same rationale as the previous change.
      X [rand.adapt.xor] paragraph 6...
    </p>
    <blockquote>
      Both <code>Engine1::result_type</code> and
      <code>Engine2::result_type</code> shall denote (possibly different)
      <del>unsigned integral types</del><ins>unsigned integer types</ins>.
      The member <i>result_type</i> shall denote either the type
      <i>Engine1::result_type</i> or the type <i>Engine2::result_type</i>,
      whichever provides the most storage according to clause 3.9.1.
    </blockquote>
    
    <p>
      26.5.7.1 [rand.util.seedseq] paragraph 7...
    </p>
    <blockquote>
      <i>Requires:</i><code>RandomAccessIterator</code> shall meet the
      requirements of a random access iterator (24.1.5) such that
      <code>iterator_traits&lt;RandomAccessIterator&gt;::value_type</code>
      shall denote an <del>unsigned integral type</del><ins>unsigned integer
      type</ins> capable of accomodating 32-bit quantities.  
    </blockquote>

    <p>
      By making this change, integral types that happen to have a signed
      representation, but are not signed integer types, would no longer be
      required to use a two's complement representation. This may go against
      the original intent, and should be reviewed.
      29.6 [atomics.types.operations] paragraph 24...
    </p>
    <blockquote>
      <i>Remark:</i> For <del>signed integral types</del><ins>signed integer
      types</ins>, arithmetic is defined using two's complement
      representation. There are no undefined results. For address types, the
      result may be an undefined address, but the operations otherwise have
      no undefined behavior.
    </blockquote>
    
  




<hr>
<h3><a name="874"></a>874. Missing <tt>initializer_list</tt> constructor for <tt>discrete_distribution</tt></h3>
<p><b>Section:</b> 26.5.8.5.1 [rand.dist.samp.discrete] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2008-08-22  <b>Last modified:</b> 2009-03-09</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.dist.samp.discrete">issues</a> in [rand.dist.samp.discrete].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
During the Sophia Antipolis meeting it was decided to separate from <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#793">793</a> a
subrequest that adds initializer list support to
<tt>discrete_distribution</tt>, specifically,
the issue proposed to add a c'tor taking a <tt>initializer_list&lt;double&gt;</tt>.
</p>



<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>
In 26.5.8.5.1 [rand.dist.samp.discrete]/1, class <tt>discrete_distribution</tt>,
just <em>before</em> the member declaration
</p>

<blockquote><pre>explicit discrete_distribution(const param_type&amp; parm);
</pre></blockquote>

<p>
insert
</p>

<blockquote><pre>discrete_distribution(initializer_list&lt;double&gt; wl);
</pre></blockquote>
</li>

<li>
<p>
Between p.4 and p.5 of the same section insert a new
paragraph as part of the new member description:
</p>

<blockquote><pre>discrete_distribution(initializer_list&lt;double&gt; wl);
</pre>

<blockquote>
<i>Effects:</i> Same as <tt>discrete_distribution(wl.begin(), wl.end())</tt>.
</blockquote>
</blockquote>
</li>
</ol>


<p><b>Rationale:</b></p>
Addressed by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2836.pdf">N2836</a> "Wording Tweaks for Concept-enabled Random Number Generation in C++0X".





<hr>
<h3><a name="875"></a>875. Missing <tt>initializer_list</tt> constructor for <tt>piecewise_constant_distribution</tt></h3>
<p><b>Section:</b> 26.5.8.5.2 [rand.dist.samp.pconst] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2008-08-22  <b>Last modified:</b> 2009-03-09</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.dist.samp.pconst">issues</a> in [rand.dist.samp.pconst].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
During the Sophia Antipolis meeting it was decided to separate from
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#794">794</a> a subrequest that adds initializer list support to
<tt>piecewise_constant_distribution</tt>, specifically, the issue proposed
to add a c'tor taking a <tt>initializer_list&lt;double&gt;</tt> and a <tt>Callable</tt> to evaluate
weight values. For consistency with the remainder of this class and
the remainder of the <tt>initializer_list</tt>-aware library the author decided to
change the list argument type to the template parameter <tt>RealType</tt>
instead. For the reasoning to use <tt>Func</tt> instead of <tt>Func&amp;&amp;</tt> as c'tor
function argument see issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#793">793</a>.
</p>


<p><b>Proposed resolution:</b></p>
<p><b>Non-concept version of the proposed resolution</b></p>

<ol>
<li>
<p>
In 26.5.8.5.2 [rand.dist.samp.pconst]/1, class <tt>piecewise_constant_distribution</tt>,
just <em>before</em> the member declaration
</p>

<blockquote><pre>explicit piecewise_constant_distribution(const param_type&amp; parm);
</pre></blockquote>

<p>
insert
</p>

<blockquote><pre>template&lt;typename Func&gt;
piecewise_constant_distribution(initializer_list&lt;RealType&gt; bl, Func fw);
</pre></blockquote>
</li>

<li>
<p>
Between p.4 and p.5 of the same section insert a series of
new paragraphs nominated below as [p5_1], [p5_2], and [p5_3]
as part of the new member description:
</p>

<blockquote><pre>template&lt;typename Func&gt;
piecewise_constant_distribution(initializer_list&lt;RealType&gt; bl, Func fw);
</pre>

<blockquote>

<p>
[p5_1] <i>Complexity:</i> Exactly <tt>nf = max(bl.size(), 1) - 1</tt> invocations of <tt>fw</tt>.
</p>

<p>
[p5_2] <i>Requires:</i>
</p>

<ol type="a">
<li>
<tt>fw</tt> shall be callable with one argument of type <tt>RealType</tt>, and shall
   return values of a type convertible to <tt>double</tt>;
</li>
<li>
The relation <tt>0 &lt; S = w<sub>0</sub>+. . .+w<sub>n-1</sub></tt> shall hold. 
For all sampled values <tt><i>x<sub>k</sub></i></tt> defined below, <tt>fw(<i>x<sub>k</sub></i>)</tt> shall return a weight
   value <tt><i>w<sub>k</sub></i></tt> that is non-negative, non-NaN, and non-infinity;
</li>
<li>
If <tt>nf &gt; 0</tt> let <tt>b<sub><i>k</i></sub> = *(bl.begin() + k), k = 0, . . . , bl.size()-1</tt> and the
following relations shall hold for <tt>k = 0, . . . , nf-1: b<sub><i>k</i></sub> &lt; b<sub><i>k+1</i></sub></tt>.
</li>
</ol>

<p>
[p5_3] <i>Effects:</i>
</p>

<ol type="a">
<li>
<p>If <tt>nf == 0</tt>,</p>
<ol type="a">
<li>
lets the sequence <tt>w</tt> have length <tt>n = 1</tt> and consist of the single
     value <tt>w<sub>0</sub> = 1</tt>, and
</li>
<li>
lets the sequence <tt>b</tt> have length <tt>n+1</tt> with <tt>b<sub>0</sub> = 0</tt> and <tt>b<sub>1</sub> = 1</tt>.
</li>
</ol>
</li>

<li>
<p>Otherwise,</p>
<ol type="a">
<li>
sets <tt>n = nf</tt>, and <tt>[bl.begin(), bl.end())</tt> shall form the sequence <tt>b</tt> of
length <tt>n+1</tt>, and
</li>
<li>
<p>lets the sequences <tt>w</tt> have length <tt>n</tt> and for each <tt>k = 0, . . . ,n-1</tt>,
     calculates:</p>
<blockquote><pre>x<sub><i>k</i></sub> = 0.5*(b<sub><i>k+1</i></sub> + b<sub><i>k</i></sub>)
w<sub><i>k</i></sub> = fw(x<sub><i>k</i></sub>)
</pre></blockquote>
</li>
</ol>
</li>

<li>
<p>
Constructs a <tt>piecewise_constant_distribution</tt> object with
the above computed sequence <tt>b</tt> as the interval boundaries
and with the probability densities:
</p>
<blockquote><pre>&#961;<sub><i>k</i></sub> = w<sub><i>k</i></sub>/(S * (b<sub><i>k+1</i></sub> - b<sub><i>k</i></sub>)) for k = 0, . . . , n-1.
</pre></blockquote>

</li>
</ol>

</blockquote>
</blockquote>
</li>
</ol>

<p><b>Concept version of the proposed resolution</b></p>

<ol>
<li>
<p>
In 26.5.8.5.2 [rand.dist.samp.pconst]/1, class <tt>piecewise_constant_distribution</tt>,
just <em>before</em> the member declaration
</p>

<blockquote><pre>explicit piecewise_constant_distribution(const param_type&amp; parm);
</pre></blockquote>

<p>
insert
</p>

<blockquote><pre>template&lt;Callable&lt;auto, RealType&gt; Func&gt;
 requires Convertible&lt;Func::result_type, double&gt;
piecewise_constant_distribution(initializer_list&lt;RealType&gt; bl, Func fw);
</pre></blockquote>
</li>

<li>
<p>
Between p.4 and p.5 of the same section insert a series of
new paragraphs nominated below as [p5_1], [p5_2], and [p5_3]
as part of the new member description:
</p>

<blockquote><pre>template&lt;Callable&lt;auto, RealType&gt; Func&gt;
 requires Convertible&lt;Func::result_type, double&gt;
piecewise_constant_distribution(initializer_list&lt;RealType&gt; bl, Func fw);
</pre>

<blockquote>

<p>
[p5_1] <i>Complexity:</i> Exactly <tt>nf = max(bl.size(), 1) - 1</tt> invocations of <tt>fw</tt>.
</p>

<p>
[p5_2] <i>Requires:</i>
</p>

<ol type="a">
<li>
The relation <tt>0 &lt; S = w<sub>0</sub>+. . .+w<sub>n-1</sub></tt> shall hold. 
For all sampled values <tt><i>x<sub>k</sub></i></tt> defined below, <tt>fw(<i>x<sub>k</sub></i>)</tt> shall return a weight
   value <tt><i>w<sub>k</sub></i></tt> that is non-negative, non-NaN, and non-infinity;
</li>
<li>
If <tt>nf &gt; 0</tt> let <tt>b<sub><i>k</i></sub> = *(bl.begin() + k), k = 0, . . . , bl.size()-1</tt> and the
following relations shall hold for <tt>k = 0, . . . , nf-1: b<sub><i>k</i></sub> &lt; b<sub><i>k+1</i></sub></tt>.
</li>
</ol>

<p>
[p5_3] <i>Effects:</i>
</p>

<ol type="a">
<li>
<p>If <tt>nf == 0</tt>,</p>
<ol type="a">
<li>
lets the sequence <tt>w</tt> have length <tt>n = 1</tt> and consist of the single
     value <tt>w<sub>0</sub> = 1</tt>, and
</li>
<li>
lets the sequence <tt>b</tt> have length <tt>n+1</tt> with <tt>b<sub>0</sub> = 0</tt> and <tt>b<sub>1</sub> = 1</tt>.
</li>
</ol>
</li>

<li>
<p>Otherwise,</p>
<ol type="a">
<li>
sets <tt>n = nf</tt>, and <tt>[bl.begin(), bl.end())</tt> shall form the sequence <tt>b</tt> of
length <tt>n+1</tt>, and
</li>
<li>
<p>lets the sequences <tt>w</tt> have length <tt>n</tt> and for each <tt>k = 0, . . . ,n-1</tt>,
     calculates:</p>
<blockquote><pre>x<sub><i>k</i></sub> = 0.5*(b<sub><i>k+1</i></sub> + b<sub><i>k</i></sub>)
w<sub><i>k</i></sub> = fw(x<sub><i>k</i></sub>)
</pre></blockquote>
</li>
</ol>
</li>

<li>
<p>
Constructs a <tt>piecewise_constant_distribution</tt> object with
the above computed sequence <tt>b</tt> as the interval boundaries
and with the probability densities:
</p>
<blockquote><pre>&#961;<sub><i>k</i></sub> = w<sub><i>k</i></sub>/(S * (b<sub><i>k+1</i></sub> - b<sub><i>k</i></sub>)) for k = 0, . . . , n-1.
</pre></blockquote>

</li>
</ol>

</blockquote>
</blockquote>
</li>
</ol>



<p><b>Rationale:</b></p>
Addressed by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2836.pdf">N2836</a> "Wording Tweaks for Concept-enabled Random Number Generation in C++0X".





<hr>
<h3><a name="877"></a>877. to <tt>throw()</tt> or to <i>Throw:</i> Nothing.</h3>
<p><b>Section:</b> 17 [library] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Future">NAD Future</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2008-08-23  <b>Last modified:</b> 2009-07-17</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Future">NAD Future</a> status.</p>
<p><b>Discussion:</b></p>
       <p>

Recent changes to
the <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2691.pdf">working
draft</a> have introduced a gratuitous inconsistency with the C++ 2003
version of the specification with respect to exception guarantees
provided by standard functions. While the C++ 2003 standard
consistenly uses the empty exception specification, <tt>throw()</tt>,
to declare functions that are guaranteed not to throw exceptions, the
current working draft contains a number of "<i>Throws:</i> Nothing."
clause to specify essentially the same requirement. The difference
between the two approaches is that the former specifies the behavior
of programs that violate the requirement (<tt>std::unexpected()</tt>
is called) while the latter leaves the behavior undefined.

       </p>
       <p>

A survey of the working draft reveals that there are a total of 209
occurrences of <tt>throw()</tt> in the library portion of the spec,
the majority in clause 18, a couple (literally) in 19, a handful in
20, a bunch in 22, four in 24, one in 27, and about a dozen in D.9.

       </p>
       <p>

There are also 203 occurrences of "<i>Throws:</i> Nothing." scattered
throughout the spec.

       </p>
       <p>

While sometimes there are good reasons to use the "<i>Throws:</i>
Nothing."  approach rather than making use of <tt>throw()</tt>, these
reasons do not apply in most of the cases where this new clause has
been introduced and the empty exception specification would be a
better approach.

       </p>
       <p>

First, functions declared with the empty exception specification
permit compilers to generate better code for calls to such
functions. In some cases, the compiler might even be able to eliminate
whole chunks of user-written code when instantiating a generic
template on a type whose operations invoked from the template
specialization are known not to throw. The prototypical example are
the <tt>std::uninitialized_copy()</tt>
and <tt>std::uninitialized_fill()</tt> algorithms where the
entire <tt>catch(...)</tt> block can be optimized away.

       </p>
       <p>

For example, given the following definition of
the <tt>std::uninitialized_copy</tt> function template and a
user-defined type <tt>SomeType</tt>:

       </p>
       <blockquote>
           <pre>template &lt;class InputIterator, class ForwardIterator&gt;
ForwardIterator
uninitialized_copy (InputIterator first, InputIterator last, ForwardIterator res)
{
   typedef iterator_traits&lt;ForwardIterator&gt;::value_type ValueType;

   ForwardIterator start = res;

   try {
       for (; first != last; ++first, ++res)
           ::new (&amp;*res) ValueType (*first);
   }
   catch (...) {
       for (; start != res; --start)
           (&amp;*start)-&gt;~ValueType ();
       throw;
   }
   return res;
}

struct SomeType {
   SomeType (const SomeType&amp;) <ins>throw ()</ins>;
}</pre>
       </blockquote>
       <p>

compilers are able to emit the following efficient specialization
of <tt>std::uninitialized_copy&lt;const SomeType*, SomeType*&gt;</tt>
(note that the <tt>catch</tt> block has been optimized away):

       </p>
       <blockquote>
           <pre>template &lt;&gt; SomeType*
uninitialized_copy (const SomeType *first, const SomeType *last, SomeType *res)
{
   for (; first != last; ++first, ++res)
       ::new (res) SomeType (*first);

   return res;
}</pre>
       </blockquote>
       <p>

Another general example is default constructors which, when decorated
with <tt>throw()</tt>, allow the compiler to eliminate the
implicit <tt>try</tt> and <tt>catch</tt> blocks that it otherwise must
emit around each the invocation of the constructor
in <i>new-expressions</i>.

       </p>
       <p>

For example, given the following definitions of
class <tt>MayThrow</tt> and <tt>WontThrow</tt> and the two
statements below:

       </p>
       <blockquote>
           <pre>struct MayThrow {
   MayThrow ();
};

struct WontThrow {
   WontThrow () <ins>throw ()</ins>;
};

MayThrow  *a = new MayThrow [N];
WontThrow *b = new WontThrow [N];</pre>

       </blockquote>
       <p>

the compiler generates the following code for the first statement:

       </p>
       <blockquote>
           <pre>MayThrow *a;
{
   MayThrow *first = operator new[] (N * sizeof (*a));
   MayThrow *last  = first + N;
   MayThrow *next  = first;
   try {
       for ( ; next != last; ++next)
           new (next) MayThrow;
   }
   catch (...) {
       for ( ; first != first; --next)
           next-&gt;~MayThrow ();
       operator delete[] (first);
       throw;
   }
   a = first;
}</pre>
       </blockquote>
       <p>

but it is can generate much more compact code for the second statement:

       </p>
       <blockquote>
           <pre>WontThrow *b    = operator new[] (N * sizeof (*b));
WontThrow *last = b + N;
for (WontThrow *next = b; next != last; ++next)
   new (next) WontThrow;
</pre>
       </blockquote>
       <p>

Second, in order for users to get the maximum benefit out of the new
<tt>std::has_nothrow_xxx</tt> traits when using standard library types
it will be important for implementations to decorate all non throwing
copy constructors and assignment operators with <tt>throw()</tt>. Note
that while an optimizer may be able to tell whether a function without
an explicit exception specification can throw or not based on its
definition, it can only do so when it can see the source code of the
definition. When it can't it must assume that the function may
throw. To prevent violating the One Definition Rule,
the <tt>std::has_nothrow_xxx</tt> trait must return the most
pessimistic guess across all translation units in the program, meaning
that <tt>std::has_nothrow_xxx&lt;T&gt;::value</tt> must evaluate to
<tt>false</tt> for any <tt>T</tt> whose <tt>xxx</tt>
(where <tt>xxx</tt> is default or copy ctor, or assignment operator)
is defined out-of-line.

       </p>
       <p>

<b>Counterarguments:</b>

       </p>
       <p>

During the discussion of this issue
on <a href="mailto:c++std-lib@accu.org">c++std-lib@accu.org</a>
(starting with post <tt>c++std-lib-21950</tt>) the following arguments
in favor of the "<i>Throws:</i> Nothing." style have been made.

       </p>
       <p>
         </p><ol>
           <li>

Decorating functions that cannot throw with the empty exception
specification can cause the compiler to generate suboptimal code for
the implementation of the function when it calls other functions that
aren't known to the compiler not to throw (i.e., that aren't decorated
with <tt>throw()</tt> even if they don't actually throw). This is a
common situation when the called function is a C or POSIX function.

           </li>
           <li>

Alternate, proprietary mechanisms exist (such as
GCC <a href="http://gcc.gnu.org/onlinedocs/gcc-4.3.0/gcc/Function-Attributes.html#index-g_t_0040code_007bnothrow_007d-function-attribute-2160"><tt>__attribute__((nothrow))</tt></a>
or Visual
C++ <a href="http://msdn.microsoft.com/en-us/library/49147z04%28VS.80%29.aspx"><tt>__declspec(nothrow)</tt></a>)
that let implementers mark up non-throwing functions, often without
the penalty mentioned in (1) above. The C++ standard shouldn't
preclude the use of these potentially more efficient mechanisms.

           </li>
           <li>

There are functions, especially function templates, that invoke
user-defined functions that may or may not be
declared <tt>throw()</tt>. Declaring such functions with the empty
exception specification will cause compilers to generate suboptimal
code when the user-defined function isn't also declared not to throw.

           </li>
        </ol>
       
       <p>

The answer to point (1) above is that implementers can (and some have)
declare functions with <tt>throw()</tt> to indicate to the compiler
that calls to the function can safely be assumed not to throw in order
to allow it to generate efficient code at the call site without also
having to define the functions the same way and causing the compiler
to generate suboptimal code for the function definition. That is, the
function is declared with <tt>throw()</tt> in a header but it's
defined without it in the source file. The <tt>throw()</tt>
declaration is suppressed when compiling the definition to avoid
compiler errors. This technique, while strictly speaking no permitted
by the language, is safe and has been employed in practice. For
example, the GNU C library takes this approach. Microsoft Visual C++
takes a similar approach by simply assuming that no function with C
language linkage can throw an exception unless it's explicitly
declared to do so using the language extension <tt>throw(...)</tt>.

       </p>
       <p>

Our answer to point (2) above is that there is no existing practice
where C++ Standard Library implementers have opted to make use of the
proprietary mechanisms to declare functions that don't throw. The
language provides a mechanism specifically designed for this
purpose. Avoiding its use in the specification itself in favor of
proprietary mechanisms defeats the purpose of the feature. In
addition, making use of the empty exception specification
inconsistently, in some areas of the standard, while conspicuously
avoiding it and making use of the "<i>Throws:</i> Nothing." form in
others is confusing to users.

       </p>
       <p>

The answer to point (3) is simply to exercise caution when declaring
functions and especially function templates with the empty exception
specification. Functions that required not to throw but that may call
back into user code are poor candidates for the empty exception
specification and should instead be specified using "<i>Throws:</i>
Nothing." clause.

      </p>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
We need someone to do an extensive review.
</p>
<p>
NAD Future.
</p>
</blockquote>

   
   <p><b>Proposed resolution:</b></p>
       <p>

We propose two possible solutions. Our recommendation is to adopt
Option 1 below.

       </p>
       <p>

<b>Option 1:</b>

       </p>
       <p>

Except for functions or function templates that make calls back to
user-defined functions that may not be declared <tt>throw()</tt>
replace all occurrences of the "<i>Throws:</i> Nothing." clause with
the empty exception specification. Functions that are required not to
throw but that make calls back to user code should be specified to
"<i>Throw:</i> Nothing."

       </p>
       <p>

<b>Option 2:</b>

       </p>
       <p>

For consistency, replace all occurrences of the empty exception
specification with a "<i>Throws:</i> Nothing." clause.

       </p>
   



<hr>
<h3><a name="879"></a>879. Atomic load const qualification</h3>
<p><b>Section:</b> 29 [atomics] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Alexander Chemeris <b>Opened:</b> 2008-08-24  <b>Last modified:</b> 2009-10-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#atomics">issues</a> in [atomics].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <tt>atomic_address</tt> type and <tt>atomic&lt;T*&gt;</tt> specialization provide atomic
updates to pointers.  However, the current specification requires
that the types pointer be to non-const objects.  This restriction
is unnecessary and unintended.
</p>

<p><i>[
Summit:
]</i></p>

<blockquote>
Move to review.  Lawrence will first check with Peter whether the
current examples are sufficient, or whether they need to be expanded to
include all cases.
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
Lawrence will handle all issues relating to atomics in a single paper.
</p>
<p>
LWG will defer discussion on atomics until that paper appears.
</p>
<p>
Move to Open.
</p>
</blockquote>

<p><i>[
2009-08-17 Handled by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2925.html">N2925</a>.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD Editorial.  Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2992.html">N2992</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add const qualification to the pointer values of the <tt>atomic_address</tt>
and <tt>atomic&lt;T*&gt;</tt> specializations.  E.g.
</p>

<blockquote><pre>typedef struct atomic_address {
   void store(<ins>const</ins> void*, memory_order = memory_order_seq_cst) volatile;
   void* exchange( <ins>const</ins> void*, memory_order = memory_order_seq_cst) volatile;
   bool compare_exchange( <ins>const</ins> void*&amp;, <ins>const</ins> void*,
                          memory_order, memory_order) volatile;
   bool compare_exchange( <ins>const</ins> void*&amp;, <ins>const</ins> void*,
                          memory_order = memory_order_seq_cst ) volatile;
   void* operator=(<ins>const</ins> void*) volatile;
} atomic_address;

void atomic_store(volatile atomic_address*, <ins>const</ins> void*);
void atomic_store_explicit(volatile atomic_address*, <ins>const</ins> void*,
                          memory_order);
void* atomic_exchange(volatile atomic_address*<ins>, const void*</ins>);
void* atomic_exchange_explicit(volatile atomic_address*, <ins>const</ins> void*,
                              memory_order);
bool atomic_compare_exchange(volatile atomic_address*,
                            <ins>const</ins> void**, <ins>const</ins> void*);
bool atomic_compare_exchange_explicit(volatile atomic_address*,
                                     <ins>const</ins> void**, <ins>const</ins> void*,
                                     memory_order, memory_order);
</pre></blockquote>





<hr>
<h3><a name="880"></a>880. Missing atomic exchange parameter</h3>
<p><b>Section:</b> 29 [atomics] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Lawrence Crowl <b>Opened:</b> 2008-08-24  <b>Last modified:</b> 2009-10-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#atomics">issues</a> in [atomics].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#942">942</a></p>
<p><b>Discussion:</b></p>
<p>
The <tt>atomic_exchange</tt> and <tt>atomic_exchange_explicit</tt> functions seem to
be inconsistently missing parameters.
</p>

<p><i>[
Post Summit:
]</i></p>


<blockquote>
<p>
Lawrence: Need to write up a list for Pete with details.
</p>
<p>
Detlef: Should not be New, we already talked about in Concurrency group.
</p>
<p>
Recommend Open.
</p>
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
Lawrence will handle all issues relating to atomics in a single paper.
</p>
<p>
LWG will defer discussion on atomics until that paper appears.
</p>
<p>
Move to Open.
</p>
</blockquote>

<p><i>[
2009-08-17 Handled by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2925.html">N2925</a>.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD Editorial.  Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2992.html">N2992</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add the appropriate parameters.  For example,
</p>

<blockquote><pre>bool atomic_exchange(volatile atomic_bool*<ins>, bool</ins>);
bool atomic_exchange_explicit(volatile atomic_bool*, bool<ins>, memory_order</ins>);
</pre></blockquote>





<hr>
<h3><a name="884"></a>884. shared_ptr swap</h3>
<p><b>Section:</b> 20.8.15.2.4 [util.smartptr.shared.mod] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2008-09-15  <b>Last modified:</b> 2009-07-13</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<blockquote><pre>#include &lt;memory&gt;
#include &lt;cassert&gt;

struct A { };
struct B : A { };

int main()
{
    std::shared_ptr&lt;A&gt; pa(new A);
    std::shared_ptr&lt;B&gt; pb(new B);
    std::swap&lt;A&gt;(pa, pb);  // N.B. no argument deduction
    assert( pa.get() == pb.get() );
    return 0;
}
</pre></blockquote>

<p>
Is this behaviour correct (I believe it is) and if so, is it
unavoidable, or not worth worrying about?
</p>

<p>
This calls the lvalue/rvalue swap overload for <tt>shared_ptr</tt>:
</p>

<blockquote><pre>template&lt;class T&gt; void swap( shared_ptr&lt;T&gt; &amp; a, shared_ptr&lt;T&gt; &amp;&amp; b );
</pre></blockquote>

<p>
silently converting the second argument from <tt>shared_ptr&lt;B&gt;</tt> to
<tt>shared_ptr&lt;A&gt;</tt> and binding the rvalue ref to the produced temporary.
</p>

<p>
This is not, in my opinion, a <tt>shared_ptr</tt> problem; it is a general issue
with the rvalue swap overloads. Do we want to prevent this code from
compiling? If so, how?
</p>

<p>
Perhaps we should limit rvalue args to swap to those types that would
benefit from the "swap trick".  Or, since we now have <tt>shrink_to_fit()</tt>, just
eliminate the rvalue swap overloads altogether.  The original motivation
was:
</p>

<blockquote><pre>vector&lt;A&gt; v = ...;
...
swap(v, vector&lt;A&gt;(v));
</pre></blockquote>

<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1690.html#Improved%20swap%20Interface">N1690</a>.

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution.
Move to NAD Editorial.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Recommend NAD Editorial, fixed by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2844.html">N2844</a>.
</p>





<hr>
<h3><a name="892"></a>892. Forward_list issues...</h3>
<p><b>Section:</b> 23.3.3.5 [forwardlist.ops] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Ed Smith-Rowland <b>Opened:</b> 2008-09-15  <b>Last modified:</b> 2009-03-09</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#forwardlist.ops">issues</a> in [forwardlist.ops].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I was looking at the latest draft on <tt>forward_list</tt>.  Especially the splice methods.
</p>
<p>
The first one splices a whole list after a given iterator in <tt>this</tt>.  The name is <tt>splice_after</tt>.
I think in 23.3.3.5 [forwardlist.ops] paragraph 40
change:
</p>
<blockquote>
<i>Effect:</i> Insert the contents of <tt>x</tt> <del>before</del> <ins>after</ins> <tt>position</tt>, ...
</blockquote>

<p>
A deeper issue involves the complexity.  <tt>forward_list</tt> has no <tt>size</tt> and we
don't know when we've reached the end except to walk up to it.  To
splice we would need to hook the end of the source list to the item
after <tt>position</tt> in this list.  This would involve walking length of the
source list until we got to the last dereference-able element in source.
There's no way we could do this in O(1) unless we stored a bogus end in
<tt>forward_list</tt>.
</p>
<p>
OTOH, the last version of <tt>splice_after</tt> with iterator ranges we could do
in O(1) because we know how to hook the end of the source range to ...
</p>
<p>
Unless I'm misconceiving the whole thing.  Which is possible.  I'll look at it again.
</p>
<p>
I'm pretty sure about the first part though.
</p>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
<p>
This issue is more complicated than it looks.
</p>
<p>
paragraph 47: replace each <tt>(first, last) with (first, last]</tt>
</p>
<p>
add a statement after paragraph 48 that complexity is O(1)
</p>
<p>
remove the complexity statement from the first overload of splice_after
</p>
<p>
We may have the same problems with other modifiers, like erase_after.
Should it require that all iterators in the range (position, last] be
dereferenceable?
</p>
<p>
We do, however, like the proposed changes and consider them Editorial.
Move to NAD Editorial, Pending. Howard to open a new issue to handle the
problems with the complexity requirements.
</p>
<p>
Opened <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#897">897</a>.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
In 23.3.3.5 [forwardlist.ops] paragraph 40
change:
</p>
<blockquote>
<i>Effect:</i> Insert the contents of <tt>x</tt> <del>before</del> <ins>after</ins> <tt>position</tt>, ...
</blockquote>





<hr>
<h3><a name="895"></a>895. "Requires:" on std::string::at et al</h3>
<p><b>Section:</b> 17.5.1.4 [structure.specifications] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> James Dennett <b>Opened:</b> 2008-09-16  <b>Last modified:</b> 2009-07-17</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#structure.specifications">issues</a> in [structure.specifications].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#625">625</a></p>
<p><b>Discussion:</b></p>
<p>
Per discussion, we need an issue open to cover looking at "Requires"
clauses which are not constraints on user code, such as that on
<tt>std::basic_string::at</tt>.
</p>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
 Alan to address in paper.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="897"></a>897. Forward_list issues... Part 2</h3>
<p><b>Section:</b> 23.3.3.4 [forwardlist.modifiers] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2008-09-22  <b>Last modified:</b> 2009-10-20</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
This issue was split off from <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#892">892</a> at the request of the LWG.
</p>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
<p>
This issue is more complicated than it looks.
</p>
<p>
paragraph 47: replace each <tt>(first, last) with (first, last]</tt>
</p>
<p>
add a statement after paragraph 48 that complexity is O(1)
</p>
<p>
remove the complexity statement from the first overload of splice_after
</p>
<p>
We may have the same problems with other modifiers, like erase_after.
Should it require that all iterators in the range (position, last] be
dereferenceable?
</p>
</blockquote>

<p>
There are actually 3 issues here:
</p>

<ol>
<li>
<p>
What value should <tt>erase_after</tt> return?  With <tt>list</tt>, code often
looks like:
</p>
<blockquote><pre>for (auto i = l.begin(); i != l.end();)
{
    // inspect *i and decide if you want to erase it
    // ...
    if (I want to erase *i)
        i = l.erase(i);
    else
        ++i;
}
</pre></blockquote>
<p>
I.e. the iterator returned from <tt>erase</tt> is useful for setting up the
logic for operating on the next element.  For <tt>forward_list</tt> this might
look something like:
</p>
<blockquote><pre>auto i = fl.before_begin();
auto ip1 = i;
for (++ip1; ip1 != fl.end(); ++ip1)
{
    // inspect *(i+1) and decide if you want to erase it
    // ...
    if (I want to erase *(i+1))
        i = fl.erase_after(i);
    else
        ++i;
    ip1 = i;
}
</pre></blockquote>
<p>
In the above example code, it is convenient if <tt>erase_after</tt> returns
the element <i>prior</i> to the erased element (range) instead of the element
<i>after</i> the erase element (range).
</p>
<p>
Existing practice:
</p>
<ul>
<li>SGI slist returns an iterator referencing the element <i>after</i> the erased range.</li>
<li>CodeWarrior slist returns an iterator referencing the element <i>before</i> the erased range.</li>
</ul>
<p>
There is not a strong technical argument for either solution over the other.
</p>
</li>

<li>
<p>
With all other containers, operations always work on the range
<tt>[first, last)</tt> and/or <i>prior to</i> the given <tt>position</tt>.
</p>
<p>
With <tt>forward_list</tt>, operations sometimes work on the range
<tt>(first, last]</tt> and/or <i>after</i> the given <tt>position</tt>.
</p>
<p>
This is simply due to the fact that in order to operate on
<tt>*first</tt> (with <tt>forward_list</tt>) one needs access to
<tt>*(first-1)</tt>.  And that's not practical with
<tt>forward_list</tt>.  So the operating range needs to start with <tt>(first</tt>,
not <tt>[first</tt> (as the current working paper says). 
</p>
<p>
Additionally, if one is interested in  splicing the range <tt>(first, last)</tt>,
then (with <tt>forward_list</tt>), one needs practical (constant time) access to
<tt>*(last-1)</tt> so that one can set the <i>next</i> field in this node to
the proper value.  As this is not possible with <tt>forward_list</tt>, one must
specify the last element of interest instead of one past the last element of
interest.  The syntax for doing this is to pass <tt>(first, last]</tt> instead
of <tt>(first, last)</tt>.
</p>
<p>
With <tt>erase_after</tt> we have a choice of either erasing the range
<tt>(first, last]</tt> <em>or</em> <tt>(first, last)</tt>.  Choosing the latter
enables:
</p>
<blockquote><pre>x.erase_after(pos, x.end());
</pre></blockquote>

<p>
With the former, the above statement is inconvenient or expensive due to the lack
of constant time access to <tt>x.end()-1</tt>.  However we could introduce:
</p>

<blockquote><pre>iterator erase_to_end(const_iterator position);
</pre></blockquote>

<p>
to compensate.
</p>

<p>
The advantage of the former (<tt>(first, last]</tt>) for <tt>erase_after</tt>
is a consistency with <tt>splice_after</tt> which uses <tt>(first, last]</tt>
as the specified range.  But this either requires the addition of <tt>erase_to_end</tt>
or giving up such functionality.
</p>

</li>

<li>
As stated in the discussion of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#892">892</a>, and reienforced by point 2 above,
a <tt>splice_after</tt> should work on the source range <tt>(first, last]</tt>
if the operation is to be <i>&#927;</i>(1).  When splicing an entire list <tt>x</tt> the
algorithm needs <tt>(x.before_begin(), x.end()-1]</tt>.  Unfortunately <tt>x.end()-1</tt>
is not available in constant time unless we specify that it must be.  In order to
make <tt>x.end()-1</tt> available in constant time, the implementation would have
to dedicate a pointer to it.  I believe the design of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2543.htm">N2543</a>
intended a nominal overhead of <tt>foward_list</tt> of 1 pointer.  Thus splicing
one <i>entire</i> <tt>forward_list</tt> into another can not be <i>&#927;</i>(1).
</li>
</ol>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We agree with the proposed resolution.
</p>
<p>
Move to Review.
</p>
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
We may need a new issue to correct splice_after, because it may no
longer be correct to accept an rvalues as an argument. Merge may be
affected, too. This might be issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1133">1133</a>. (Howard: confirmed)
</p>
<p>
Move this to Ready, but the Requires clause of the second form of
splice_after should say "(first, last)," not "(first, last]" (there are
three occurrences). There was considerable discussion on this. (Howard: fixed)
</p>
<p>
Alan suggested removing the "foward_last&lt;T. Alloc&gt;&amp;&amp; x"
parameter from the second form of splice_after, because it is redundant.
PJP wanted to keep it, because it allows him to check for bad ranges
(i.e. "Granny knots").
</p>
<p>
We prefer to keep <tt>x</tt>.
</p>
<p>
Beman. Whenever we deviate from the customary half-open range in the
specification, we should add a non-normative comment to the standard
explaining the deviation. This clarifies the intention and spares the
committee much confusion in the future.
</p>
<p>
Alan to write a non-normative comment to explain the use of fully-closed ranges.
</p>
<p>
Move to Ready, with the changes described above. (Howard: awaiting note from Alan)
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD Editorial, addressed by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2988.pdf">N2988</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Wording below assumes issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#878">878</a> is accepted, but this issue is
independent of that issue.
</p>

<p>
Change 23.3.3.4 [forwardlist.modifiers]:
</p>

<blockquote>
<pre>iterator erase_after(const_iterator position);
</pre>
<blockquote>
<p>
<i>Requires:</i> The iterator following <tt>position</tt> is dereferenceable.
</p>
<p>
<i>Effects:</i> Erases the element pointed to by the iterator following <tt>position</tt>.
</p>
<p>
<i>Returns:</i> <del>An iterator pointing to the element following the one that was erased, or <tt>end()</tt> if no such 
element exists</del>
<ins>An iterator equal to <tt>position</tt></ins>.
</p>
</blockquote>


<pre>iterator erase_after(const_iterator position, <ins>const_</ins>iterator last);
</pre>
<blockquote>
<p>
<i>Requires:</i> All iterators in the range
<tt><del>[</del><ins>(</ins>position,last)</tt>
are dereferenceable.
</p>
<p>
<i>Effects:</i> Erases the elements in the range
<tt><del>[</del><ins>(</ins>position,last)</tt>.
</p>
<p>
<i>Returns:</i>  <ins>An iterator equal to <tt>position</tt></ins> <del><tt>last</tt></del>
</p>
</blockquote>
</blockquote>

<p>
Change 23.3.3.5 [forwardlist.ops]:
</p>

<blockquote>
<pre>void splice_after(const_iterator position, forward_list&lt;T,Allocator&gt;&amp;&amp; x);
</pre>
<blockquote>
<p>
<i>Requires:</i> <tt>position</tt> is <tt>before_begin()</tt> or a
dereferenceable iterator in the range <tt>[begin(), end))</tt>. <tt>&amp;x != this</tt>.
</p>
<p>
<i>Effects:</i> Inserts the contents of <tt>x</tt> after <tt>position</tt>, and
<tt>x</tt> becomes empty. Pointers and references to 
the moved elements of <tt>x</tt> now refer to those same elements but as members of <tt>*this</tt>.
Iterators referring to the moved elements will continue to refer to their elements,
but they now behave as iterators into <tt>*this</tt>, not into <tt>x</tt>. 
</p>
<p>
<i>Throws:</i> Nothing. 
</p>
<p>
<i>Complexity:</i> <del><i>&#927;</i>(1)</del> <ins><i>&#927;</i>(<tt>distance(x.begin(), x.end())</tt>)</ins>
</p>
</blockquote>

<p>...</p>

<pre>void splice_after(const_iterator position, forward_list&lt;T,Allocator&gt;&amp;&amp; x, 
                  const_iterator first, const_iterator last);
</pre>
<blockquote>
<p>
<i>Requires:</i> <tt>position</tt> is <tt>before_begin()</tt> or a
dereferenceable iterator in the range <tt>[begin(), end))</tt>.
<tt>(first,last)</tt> is a valid range in
<tt>x</tt>, and all iterators in the range
<tt>(first,last)</tt> are dereferenceable.
<tt>position</tt> is not an iterator in the range <tt>(first,last)</tt>.
</p>
<p>
<i>Effects:</i> Inserts elements in the range <tt>(first,last)</tt>
after <tt>position</tt> and removes the elements from <tt>x</tt>.
Pointers and references to the moved elements of <tt>x</tt> now refer to
those same elements but as members of <tt>*this</tt>. Iterators
referring to the moved elements will continue to refer to their
elements, but they now behave as iterators into <tt>*this</tt>, not into
<tt>x</tt>.
</p>
<p>
<ins><i>Complexity:</i> <i>&#927;</i>(1).</ins>
</p>
</blockquote>

</blockquote>






<hr>
<h3><a name="901"></a>901. insert iterators can move from lvalues</h3>
<p><b>Section:</b> 24.5.2.5 [insert.iterator] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2008-09-24  <b>Last modified:</b> 2009-07-13</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses UK 282</b></p>

<p>
The requires clause on the <tt>const T &amp;</tt> overloads in
<tt>back_insert_iterator/front_insert_iterator/insert_iterator</tt> mean that the
assignment operator will implicitly move from lvalues of a move-only type.
</p>
<p>
Suggested resolutions are:
</p>
<ol type="a">
<li>
Add another overload with a negative constraint on copy-constructible
and flag it "= delete".
</li>
<li>
Drop the copy-constructible overload entirely and rely on perfect
forwarding to catch move issues one level deeper.
</li>
<li>
This is a fundamental problem in move-syntax that relies on the
presence of two overloads, and we need to look more deeply into this
area as a whole - do not solve this issue in isolation.
</li>
</ol>

<p><i>[
Post Summit, Alisdair adds:
]</i></p>


<blockquote>
<p>
Both comment and issue have been resolved by the adoption of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2844.html">N2844</a>
(rvalue references safety fix) at the last meeting.
</p>

<p>
Suggest resolve as NAD Editorial with a reference to the paper.
</p>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree that this has been resolved in the latest Working Draft.
Move to NAD.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Recommend NAD, addressed by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2844.html">N2844</a>.
</p>





<hr>
<h3><a name="902"></a>902. Regular is the wrong concept to constrain numeric_limits</h3>
<p><b>Section:</b> 18.3.1 [limits] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2008-09-24  <b>Last modified:</b> 2009-07-16</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#limits">issues</a> in [limits].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses FR 32 and DE 16</b></p>

<p>
<tt>numeric_limits</tt> has functions specifically designed to return NaNs, which
break the model of <tt>Regular</tt> (via its axioms.)  While floating point types
will be acceptible in many algorithms taking <tt>Regular</tt> values, it is not
appopriate for this specific API and we need a less refined constraint.
</p>

<p>FR 32:</p>

<blockquote>
The definition of <tt>numeric_limits&lt;&gt;</tt> as requiring a regular
type is both conceptually wrong and operationally illogical. As we
pointed before, this mistake needs to be corrected. For example, the
template can be left unconstrained. In fact this reflects a much more
general problem with concept_maps/axioms and their interpretations. It
appears that the current text heavily leans toward experimental academic
type theory.
</blockquote>

<p>DE 16:</p>

<blockquote>
The class template <tt>numeric_limits</tt> should not specify the Regular concept
requirement for its template parameter, because it contains functions
returning NaN values for floating-point types; these values violate the
semantics of EqualityComparable.
</blockquote>

<p><i>[
Summit:
]</i></p>


<blockquote>
Move to Open.  Alisdair and Gaby will work on a solution, along with the new
treatment of axioms in clause 14.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="903"></a>903. <tt>back_insert_iterator</tt> issue</h3>
<p><b>Section:</b> 24.5.2.1 [back.insert.iterator] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Dave Abrahams <b>Opened:</b> 2008-09-19  <b>Last modified:</b> 2009-07-16</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I just noticed this; don't know how far the problem(?) extends or
whether it's new or existing: <tt>back_insert_iterator</tt>'s <tt>operator*</tt> is not
<tt>const</tt>, so you can't dereference a <tt>const</tt> one.
</p>

<p><i>[
Post Summit Daniel adds:
]</i></p>


<blockquote>
<p>
If done, this change should be applied for <tt>front_insert_iterator</tt>,
<tt>insert_iterator</tt>, <tt>ostream_iterator</tt>, and <tt>ostreambuf_iterator</tt> as well.
</p>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Alisdair notes that these all are output iterators.
Howard points out that <tt>++*i</tt>
would no longer work if we made this change.
</p>
<p>
Move to NAD.
</p>
</blockquote>

<p><i>[
2009-05-25 Daniel adds:
]</i></p>


<ol>
<li>
If <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1009">1009</a> is accepted, <tt>OutputIterator</tt> does no longer support post increment.
</li>
<li>
To support backward compatibility a second overload of <tt>operator*</tt>
can be added.
Note that the <tt>HasDereference</tt> concept (and the <tt>HasDereference</tt> part of concept
<tt>Iterator</tt>) was specifically refactored to cope with optional const
qualification and
to properly reflect the dual nature of built-in <tt>operator*</tt> as of
13.5.8 [over.literal]/6.
</li>
</ol>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="905"></a>905. Mutex specification questions</h3>
<p><b>Section:</b> 30.4.1.1 [thread.mutex.class] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Herb Sutter <b>Opened:</b> 2008-09-18  <b>Last modified:</b> 2009-03-22</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.mutex.class">issues</a> in [thread.mutex.class].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#893">893</a></p>
<p><b>Discussion:</b></p>
<p>
A few questions on the current WP,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2723.pdf">N2723</a>:
</p>
<p>
30.4.1 [thread.mutex.requirements]/24 says an expression
<tt>mut.unlock()</tt> "Throws: Nothing." I'm assuming that, per 17.6.3.11 [res.on.required], errors that violate the precondition "The
calling thread shall own the mutex" opens the door for throwing an
exception anyway, such as to report unbalanced unlock operations and
unlocking from a thread that does not have ownership. Right?
</p>
<p>
30.4.1.1 [thread.mutex.class]/3 (actually numbered paragraph "27"
in the WP; this is just a typo I think) says
</p>
<blockquote>
<p>
The behavior of a program is undefined if:
</p>
<ul>
<li>it destroys a <tt>mutex</tt> object owned by any thread,</li>
<li>a thread that owns a <tt>mutex</tt> object calls <tt>lock()</tt> or <tt>try_lock()</tt> on that object, or</li>
<li>a thread terminates while owning a <tt>mutex</tt> object.</li>
</ul>
</blockquote>

<p>
As already discussed, I think the second bullet should be removed, and
such a <tt>lock()</tt> or <tt>try_lock()</tt> should fail with an
exception or returning <tt>false</tt>, respectively.
</p>
<p>
A potential addition to the list would be
</p>
<ul>
<li>a thread unlocks a <tt>mutex</tt> it does not have ownership of.</li>
</ul>
<p>
but without that the status quo text endorses the technique of the
program logically transferring ownership of a mutex to another thread
with correctness enforced by programming discipline. Was that intended?
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
<p>
Two resolutions: "not a defect" and "duplicate", as follows:
</p>
<ul>
<li>
30.4.1 [thread.mutex.requirements]/24: NAD. If the precondition
fails the program has undefined behaviour and therefore an
implementation may throw an exception already.
</li>
<li>
30.4.1.1 [thread.mutex.class]/3 bullet 2: Already addressed by issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#893">893</a>.
</li>
<li>
30.4.1.1 [thread.mutex.class]/3 proposed addition: NAD. This is
already covered by the mutex requirements, which have ownership as a
Precondition.
</li>
</ul>
</blockquote>


<p><b>Proposed resolution:</b></p>






<hr>
<h3><a name="906"></a>906. <tt>ObjectType</tt> is the wrong concept to constrain <tt>initializer_list</tt></h3>
<p><b>Section:</b> 18.9 [support.initlist] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Concepts">NAD Concepts</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2008-09-26  <b>Last modified:</b> 2009-07-16</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The currently proposed constraint on <tt>initializer_list</tt>'s element type
<tt>E</tt> is that is has to meet <tt>ObjectType</tt>. This is an underspecification,
because both core language and library part of <tt>initializer_list</tt>
make clear, that it references an implicitly allocated array:
</p>
<p>
8.5.4 [dcl.init.list]/4:
</p>
<blockquote>
When an initializer list is implicitly converted to a
<tt>std::initializer_list&lt;E&gt;</tt>, the object passed is constructed as if the
implementation allocated an array of N elements of type <tt>E</tt>, where
N is the number of elements in the initializer list.[..]
</blockquote>

<p>
18.9 [support.initlist]/2.
</p>

<blockquote>
An object of type <tt>initializer_list&lt;E&gt;</tt> provides access to an array of
objects of type <tt>const E</tt>.[..]
</blockquote>

<p>
Therefore, <tt>E</tt> needs to fulfill concept <tt>ValueType</tt> (thus excluding
abstract class types). This stricter requirement should be added
to prevent deep instantiation errors known from the bad old times,
as shown in the following example:
</p>

<blockquote><pre>// Header A: (Should concept-check even in stand-alone modus)

template &lt;DefaultConstructible T&gt;
requires MoveConstructible&lt;T&gt;
void generate_and_do_3(T a) {
  std::initializer_list&lt;T&gt; list{T(), std::move(a), T()};
  ...
}

void do_more();
void do_more_or_less();

template &lt;DefaultConstructible T&gt;
requires MoveConstructible&lt;T&gt;
void more_generate_3() {
  do_more();
  generate_and_do_3(T());
}

template &lt;DefaultConstructible T&gt;
requires MoveConstructible&lt;T&gt;
void something_and_generate_3() {
  do_more_or_less();
  more_generate_3();
}

// Test.cpp

#include "A.h"

class Abstract {
public:
  virtual ~Abstract();
  virtual void foo() = 0; // abstract type
  Abstract(Abstract&amp;&amp;){} // MoveConstructible
  Abstract(){} // DefaultConstructible
};

int main() {
  // The restricted template *accepts* the argument, but
  // causes a deep instantiation error in the internal function
  // generate_and_do_3:
  something_and_generate_3&lt;Abstract&gt;();
}
</pre></blockquote>

<p>
The proposed stricter constraint does not minimize the aim to
support more general containers for which <tt>ObjectType</tt> would be
sufficient. If such an extended container (lets assume it's still a
class template) provides a constructor that accepts an <tt>initializer_list</tt>
only <em>this</em> constructor would need to be restricted on <tt>ValueType</tt>:
</p>

<blockquote><pre>template&lt;ObjectType T&gt;
class ExtContainer {
public:
  requires ValueType&lt;T&gt;
  ExtContainer(std::initializer_list&lt;T&gt;);
  ...
};
</pre></blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Move to Tentatively Ready.
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
Need to look at again without concepts.
</blockquote>



<p><b>Proposed resolution:</b></p>
<ol>
<li>
In 18.9 [support.initlist]/p.1 replace in "header <tt>&lt;initializer_list&gt;</tt> synopsis"
the constraint "<tt>ObjectType</tt>" in the template parameter list by the
constraint "<tt>ValueType</tt>".
</li>
</ol>






<hr>
<h3><a name="908"></a>908. Deleted assignment operators for atomic types must be volatile</h3>
<p><b>Section:</b> 29.5 [atomics.types] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Anthony Williams <b>Opened:</b> 2008-09-26  <b>Last modified:</b> 2009-10-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#atomics.types">issues</a> in [atomics.types].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses US 90</b></p>

<p>
The deleted copy-assignment operators for the atomic types are not
marked as volatile in N2723, whereas the assignment operators from the
associated non-atomic types are. e.g.
</p>
<blockquote><pre>atomic_bool&amp; operator=(atomic_bool const&amp;) = delete;
atomic_bool&amp; operator=(bool) volatile;
</pre></blockquote>

<p>
This leads to ambiguity when assigning a non-atomic value to a
non-volatile instance of an atomic type:
</p>
<blockquote><pre>atomic_bool b;
b=false;
</pre></blockquote>

<p>
Both assignment operators require a standard conversions: the
copy-assignment operator can use the implicit <tt>atomic_bool(bool)</tt>
conversion constructor to convert <tt>false</tt> to an instance of
<tt>atomic_bool</tt>, or <tt>b</tt> can undergo a qualification conversion in order to
use the assignment from a plain <tt>bool</tt>.
</p>

<p>
This is only a problem once issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#845">845</a> is applied.
</p>

<p><i>[
Summit:
]</i></p>

<blockquote>
Move to open. Assign to Lawrence. Related to US 90 comment.
</blockquote>

<p><i>[
2009-08-17 Handled by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2925.html">N2925</a>.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD Editorial.  Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2992.html">N2992</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add volatile qualification to the deleted copy-assignment operator of
all the atomic types:
</p>

<blockquote><pre>atomic_bool&amp; operator=(atomic_bool const&amp;) <ins>volatile</ins> = delete;
atomic_itype&amp; operator=(atomic_itype const&amp;) <ins>volatile</ins> = delete;
</pre></blockquote>

<p>
etc.
</p>
<p>
This will mean that the deleted copy-assignment operator will require
<i>two</i> conversions in the above example, and thus be a worse match than
the assignment from plain <tt>bool</tt>.
</p>





<hr>
<h3><a name="912"></a>912. Array swap needs to be conceptualized</h3>
<p><b>Section:</b> 25.3.3 [alg.swap] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Concepts">NAD Concepts</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2008-10-01  <b>Last modified:</b> 2009-07-13</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.swap">issues</a> in [alg.swap].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p>
With the adaption of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#809">809</a>
we have a new algorithm <tt>swap</tt> for C-arrays, which needs to be conceptualized.
</p>

<p><i>[
Post Summit Daniel adds:
]</i></p>


<blockquote>
Recommend as NAD Editorial: The changes have already been applied to the WP
<a href="" ref="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2800.pdf">N2800</a>.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Move to NAD; the changes have already been made.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Replace in 25.3.3 [alg.swap] before p. 3 until p. 4 by
</p>

<blockquote><pre>template &lt;<del>class</del> <ins>ValueType</ins> T, size_t N&gt;
<ins>requires Swappable&lt;T&gt;</ins>
void swap(T (&amp;a)[N], T (&amp;b)[N]);
</pre>
<blockquote>
<p>
<del><i>Requires:</i> <tt>T</tt> shall be <tt>Swappable</tt>.</del>
</p>
<p>
<i>Effects:</i> <tt>swap_ranges(a, a + N, b);</tt>
</p>
</blockquote>
</blockquote>






<hr>
<h3><a name="913"></a>913. Superfluous requirements for replace algorithms</h3>
<p><b>Section:</b> 25.3.5 [alg.replace] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Concepts">NAD Concepts</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2008-10-03  <b>Last modified:</b> 2009-07-14</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.replace">issues</a> in [alg.replace].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p>
(A) 25.3.5 [alg.replace]/1:
</p>

<blockquote>
<i>Requires:</i> The expression <tt>*first = new_value</tt> shall be valid.
</blockquote>

<p>
(B) 25.3.5 [alg.replace]/4:
</p>

<blockquote>
<i>Requires:</i> The results of the expressions <tt>*first</tt> and <tt>new_value</tt> shall
be writable to the result output iterator.[..]
</blockquote>

<p>
Since conceptualization, the quoted content of these clauses is covered
by the existing requirements
</p>

<p>
(A) <tt>OutputIterator&lt;Iter, const T&amp;&gt;</tt>
</p>

<p>
and
</p>

<p>
(B) <tt>OutputIterator&lt;OutIter, InIter::reference&gt; &amp;&amp; OutputIterator&lt;OutIter, const T&amp;&gt;</tt>
</p>

<p>
resp, and thus should be removed.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We agree with the proposed resolution.
</p>
<p>
Move to Tentatively Ready.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<ol type="A">
<li>
<p>
Remove 25.3.5 [alg.replace]/1.
</p>
<blockquote><pre>template&lt;ForwardIterator Iter, class T&gt; 
  requires OutputIterator&lt;Iter, Iter::reference&gt; 
        &amp;&amp; OutputIterator&lt;Iter, const T&amp;&gt; 
        &amp;&amp; HasEqualTo&lt;Iter::value_type, T&gt; 
  void replace(Iter first, Iter last, 
               const T&amp; old_value, const T&amp; new_value); 

template&lt;ForwardIterator Iter, Predicate&lt;auto, Iter::value_type&gt; Pred, class T&gt; 
  requires OutputIterator&lt;Iter, Iter::reference&gt; 
        &amp;&amp; OutputIterator&lt;Iter, const T&amp;&gt; 
        &amp;&amp; CopyConstructible&lt;Pred&gt; 
  void replace_if(Iter first, Iter last, 
                  Pred pred, const T&amp; new_value);
</pre>
<blockquote>
<del>1 <i>Requires:</i> The expression <tt>*first = new_value</tt> shall be valid.</del>
</blockquote>
</blockquote>
</li>
<li>
<p>
25.3.5 [alg.replace]/4: Remove the sentence "The results of the
expressions <tt>*first</tt> and
<tt>new_value</tt> shall be writable to the result output iterator.".
</p>
<blockquote><pre>template&lt;InputIterator InIter, typename OutIter, class T&gt; 
  requires OutputIterator&lt;OutIter, InIter::reference&gt; 
        &amp;&amp; OutputIterator&lt;OutIter, const T&amp;&gt; 
        &amp;&amp; HasEqualTo&lt;InIter::value_type, T&gt; 
  OutIter replace_copy(InIter first, InIter last, 
                       OutIter result, 
                       const T&amp; old_value, const T&amp; new_value);

template&lt;InputIterator InIter, typename OutIter,
         Predicate&lt;auto, InIter::value_type&gt; Pred, class T&gt; 
  requires OutputIterator&lt;OutIter, InIter::reference&gt; 
        &amp;&amp; OutputIterator&lt;OutIter, const T&amp;&gt; 
        &amp;&amp; CopyConstructible&lt;Pred&gt; 
  OutIter replace_copy_if(InIter first, InIter last, 
                          OutIter result, 
                          Pred pred, const T&amp; new_value);
</pre>
<blockquote>
4 <i>Requires:</i> <del>The results of the expressions <tt>*first</tt> and
<tt>new_value</tt> shall be writable to the <tt>result</tt> output
iterator.</del> The ranges <tt>[first,last)</tt> and <tt>[result,result +
(last - first))</tt> shall not overlap.
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="914"></a>914. Superfluous requirement for unique</h3>
<p><b>Section:</b> 25.3.9 [alg.unique] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Concepts">NAD Concepts</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2008-10-03  <b>Last modified:</b> 2009-07-14</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.unique">issues</a> in [alg.unique].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p>
25.3.9 [alg.unique]/2: "Requires: The comparison function shall be an
equivalence relation."
</p>

<p>
The essence of this is already covered by the given requirement
</p>

<blockquote><pre>EquivalenceRelation&lt;auto, Iter::value_type&gt; Pred
</pre></blockquote>

<p>
and should thus be removed.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution.
Move to Tentatively Ready.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Remove 25.3.9 [alg.unique]/2
</p>

<blockquote><pre>template&lt;ForwardIterator Iter&gt;
  requires OutputIterator&lt;Iter, Iter::reference&gt;
        &amp;&amp; EqualityComparable&lt;Iter::value_type&gt;
  Iter unique(Iter first, Iter last);

template&lt;ForwardIterator Iter, EquivalenceRelation&lt;auto, Iter::value_type&gt; Pred&gt;
  requires OutputIterator&lt;Iter, RvalueOf&lt;Iter::reference&gt;::type&gt;
        &amp;&amp; CopyConstructible&lt;Pred&gt;
  Iter unique(Iter first, Iter last,
               Pred pred);
</pre>
<blockquote>
<p>
1 <i>Effects:</i> ...
</p>
<p>
<del>2 <i>Requires:</i> The comparison function shall be an equivalence relation.</del>
</p>
</blockquote>
</blockquote>





<hr>
<h3><a name="916"></a>916. Redundant move-assignment operator of <tt>pair</tt> should be removed</h3>
<p><b>Section:</b> 20.3.4 [pairs] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2008-10-04  <b>Last modified:</b> 2009-10-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#pairs">active issues</a> in [pairs].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#pairs">issues</a> in [pairs].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>see also <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#917">917</a>.</b></p>

<p>
The current WP provides the following assignment operators for <tt>pair</tt>
in 20.3.4 [pairs]/1:
</p>

<ol>
<li>
<pre>template&lt;class U , class V&gt;
requires HasAssign&lt;T1, const U&amp;&gt; &amp;&amp; HasAssign&lt;T2, const V&amp;&gt;
pair&amp; operator=(const pair&lt;U , V&gt;&amp; p);
</pre>
</li>
<li>
<pre>requires MoveAssignable&lt;T1&gt; &amp;&amp; MoveAssignable&lt;T2&gt; pair&amp; operator=(pair&amp;&amp; p );
</pre>
</li>
<li>
<pre>template&lt;class U , class V&gt;
requires HasAssign&lt;T1, RvalueOf&lt;U&gt;::type&gt; &amp;&amp; HasAssign&lt;T2, RvalueOf&lt;V&gt;::type&gt;
pair&amp; operator=(pair&lt;U , V&gt;&amp;&amp; p);
</pre>
</li>
</ol>

<p>
It seems that the functionality of (2) is completely covered by (3), therefore
(2) should be removed.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Bill believes the extra assignment operators are necessary for resolving
ambiguities, but that does not mean it needs to be part of the specification.
</p>
<p>
Move to Open.
We recommend this be looked at in the context of the ongoing work
related to the pair templates.
</p>
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
Leave this open pending the removal of concepts from the WD.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Mark as NAD, see issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#801">801</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>
<ol type="A">
<li>
<p>
In 20.3.4 [pairs] p. 1, class <tt>pair</tt> and just before p. 13 remove the declaration:
</p>

<blockquote><pre>requires MoveAssignable&lt;T1&gt; &amp;&amp; MoveAssignable&lt;T2&gt; pair&amp; operator=(pair&amp;&amp; p );
</pre></blockquote>
</li>

<li>
Remove p.13+p.14
</li>

</ol>





<hr>
<h3><a name="917"></a>917. Redundant move-assignment operator of <tt>tuple</tt> should be removed</h3>
<p><b>Section:</b> 20.5.2.1 [tuple.cnstr] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2008-10-04  <b>Last modified:</b> 2009-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#tuple.cnstr">issues</a> in [tuple.cnstr].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>see also <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#916">916</a>.</b></p>
<p>
N2770 (and thus now the WP) removed the
non-template move-assignment operator from tuple's class definition,
but the latter individual member description does still provide this
operator. Is this (a) an oversight and can it (b) be solved as part of an
editorial process?
</p>

<p><i>[
Post Summit Daniel provided wording.
]</i></p>


<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We believe that the proposed resolution's part 1 is editorial.
</p>
<p>
Regarding part 2, we either remove the specification as proposed,
or else add back the declaration to which the specification refers.
Alisdair and Bill prefer the latter.
It is not immediately obvious whether the function is intended to be present.
</p>
<p>
We recommend that the Project Editor restore the missing declaration
and that we keep part 2 of the issue alive.
</p>
<p>
Move to Open.
</p>
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
Leave this open pending the removal of concepts from the WD.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Mark as NAD, see issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#801">801</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>
In 20.5.2 [tuple.tuple], class <tt>tuple</tt> just before member <tt>swap</tt> please
change as indicated:
</p>
<p><i>[
This fixes an editorial loss between N2798 to N2800
]</i></p>

<blockquote><pre>template &lt;class... UTypes&gt;
requires HasAssign&lt;Types, const UTypes&amp;&gt;...
<ins>tuple&amp; operator=(const pair&lt;UTypes...&gt;&amp;);</ins>

template &lt;class... UTypes&gt;
requires HasAssign&lt;Types, RvalueOf&lt;UTypes&gt;::type&gt;...
<ins>tuple&amp; operator=(pair&lt;UTypes...&gt;&amp;&amp;);</ins>
</pre></blockquote>
</li>
<li>
<p>
In 20.5.2.1 [tuple.cnstr], starting just before p. 11 please remove
as indicated:
</p>

<blockquote><pre><del>requires MoveAssignable&lt;Types&gt;... tuple&amp; operator=(tuple&amp;&amp; u);</del>
</pre>
<blockquote>
<p>
<del>-11- <i>Effects:</i> Move-assigns each element of <tt>u</tt> to the corresponding
element of <tt>*this</tt>.</del>
</p>
<p>
<del>-12- <i>Returns:</i> <tt>*this</tt>.</del>
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="918"></a>918. Swap for tuple needs to be conceptualized</h3>
<p><b>Section:</b> 20.5.2.3 [tuple.swap] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Concepts">NAD Concepts</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2008-10-04  <b>Last modified:</b> 2009-07-13</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#522">522</a> was accepted after <tt>tuple</tt> had been conceptualized,
therefore this step needs to be completed.
</p>

<p><i>[
Post Summit Daniel adds
]</i></p>


<blockquote>
This is now NAD Editorial (addressed by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2844.html">N2844</a>)
except for item 3 in the proposed wording.
</blockquote>

<p><i>[
2009-05-01 Daniel adds:
]</i></p>


<blockquote>
As of the recent WP
(<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2857.pdf">N2857</a>),
this issue is now completely covered by editorial
changes (including the third bullet), therefore I unconditionally recommend
NAD.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We observed that all the proposed changes have already been applied to the
Working Draft, rendering this issue moot.
</p>
<p>
Move to NAD.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>
In both 20.5.1 [tuple.general]/2 and 20.5.2.9 [tuple.special] change
</p>

<blockquote><pre>template &lt;<del>class</del> <ins>Swappable</ins>... Types&gt;
void swap(tuple&lt;Types...&gt;&amp; x, tuple&lt;Types...&gt;&amp; y);
</pre></blockquote>

</li>

<li>
<p>
In 20.5.2 [tuple.tuple], class <tt>tuple</tt> definition and in
20.5.2.3 [tuple.swap], change
</p>

<blockquote><pre><ins>requires Swappable&lt;Types&gt;...</ins>void swap(tuple&amp;);
</pre></blockquote>

</li>

<li>
<p>
In 20.5.2.3 [tuple.swap] remove the current requires-clause, which says:
</p>

<blockquote>
<del><i>Requires:</i> Each type in <tt>Types</tt> shall be <tt>Swappable</tt></del>
</blockquote>
</li>

</ol>






<hr>
<h3><a name="919"></a>919. (forward_)list specialized remove algorithms are over constrained</h3>
<p><b>Section:</b> 23.3.3.5 [forwardlist.ops], 23.3.4.4 [list.ops] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2008-10-06  <b>Last modified:</b> 2009-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#forwardlist.ops">issues</a> in [forwardlist.ops].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The signatures of <tt>forwardlist::remove</tt> and <tt>list::remove</tt>
defined in 23.3.3.5 [forwardlist.ops] before 11 + 23.3.4.4 [list.ops] before 15:
</p>

<blockquote><pre>requires EqualityComparable&lt;T&gt; void remove(const T&amp; value);
</pre></blockquote>

<p>
are asymmetric to their predicate variants (which only require
<tt>Predicate</tt>, <em>not</em> <tt>EquivalenceRelation</tt>) and with the free algorithm
remove (which only require <tt>HasEqualTo</tt>). Also, nothing in the
pre-concept WP
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2723.pdf">N2723</a>
implies that <tt>EqualityComparable</tt> should
be the intended requirement.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We agree with the proposed resolution,
but would like additional input from concepts experts.
</p>
<p>
Move to Review.
</p>
</blockquote>

<p><i>[
2009-07-21 Alisdair adds:
]</i></p>


<blockquote>
Current rationale and wording for this issue is built around concepts. I
suggest the issue reverts to Open status. I believe there is enough of
an issue to review after concepts are removed from the WP to re-examine
the issue in Santa Cruz, rather than resolve as NAD Concepts.
</blockquote>

<p><i>[
2009-10-10 Daniel adds:
]</i></p>


<blockquote>
Recommend NAD: The concept-free wording as of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2960.pdf">N2960</a>
has no longer the
over-specified requirement
<tt>EqualityComparable</tt> for the remove function that uses <tt>==</tt>. In fact, now
the same test conditions exists
as for the free algorithm <tt>remove</tt> (25.3.8 [alg.remove]). The error was
introduced in the process of conceptifying.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD, solved by the removal of concepts.
</blockquote>



<p><b>Proposed resolution:</b></p>
<ol type="A">
<li>
<p>
Replace in 23.3.3.5 [forwardlist.ops] before 11 and in 23.3.4.4 [list.ops] before 15
</p>

<blockquote><pre>requires <del>EqualityComparable&lt;T&gt;</del> <ins>HasEqualTo&lt;T, T&gt;</ins> void remove(const T&amp; value);
</pre></blockquote>
</li>
</ol>






<hr>
<h3><a name="923"></a>923. atomics with floating-point </h3>
<p><b>Section:</b> 29 [atomics] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Herb Sutter <b>Opened:</b> 2008-10-17  <b>Last modified:</b> 2009-10-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#atomics">issues</a> in [atomics].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Right now, C++0x doesn't have <tt>atomic&lt;float&gt;</tt>. We're thinking of adding
the words to support it for TR2 (note: that would be slightly
post-C++0x). If we need it, we could probably add the words.
</p>
<p>
<b>Proposed resolutions:</b> Using <tt>atomic&lt;FP&gt;::compare_exchange</tt> (weak or
strong) should be either:
</p>

<ol>
<li>
ill-formed, or
</li>
<li>
well-defined.
</li>
</ol>

<p>
I propose Option 1 for C++0x for expediency. If someone wants to argue
for Option 2, they need to say what exactly they want <tt>compare_exchange</tt>
to mean in this case (IIRC, C++0x doesn't even assume IEEE 754).
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Move to open. Blocked until concepts for atomics are addressed.
</blockquote>

<p><i>[
Post Summit Anthony adds:
]</i></p>


<blockquote>
<p>
Recommend NAD. C++0x does have <tt>std::atomic&lt;float&gt;</tt>, and both
<tt>compare_exchange_weak</tt> and <tt>compare_exchange_strong</tt> are well-defined in
this case. Maybe change the note in 29.6 [atomics.types.operations] paragraph 20 to:
</p>

<blockquote>
<p>
[<i>Note:</i> The effect of the compare-and-exchange operations is
</p>
<blockquote><pre>if (!memcmp(object,expected,sizeof(*object)))
    *object = desired;
else
    *expected = *object;
</pre></blockquote>

<p>
This may result in failed comparisons for values that compare equal if
the underlying type has padding bits or alternate representations of
the same value. <i>-- end note</i>]
</p>
</blockquote>

</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD Editorial.  Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2992.html">N2992</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change the note in 29.6 [atomics.types.operations] paragraph 20 to:
</p>

<blockquote>
<p>
[<i>Note:</i> The effect of the compare-and-exchange operations is
</p>
<blockquote><pre>if (<del>*object == *expected</del> <ins>!memcmp(object,expected,sizeof(*object))</ins>)
    *object = desired;
else
    *expected = *object;
</pre></blockquote>

<p><ins>
This may result in failed comparisons for values that compare equal if
the underlying type has padding bits or alternate representations of
the same value.</ins> <i>-- end note</i>]
</p>
</blockquote>






<hr>
<h3><a name="924"></a>924. structs with internal padding</h3>
<p><b>Section:</b> 29 [atomics] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Herb Sutter <b>Opened:</b> 2008-10-17  <b>Last modified:</b> 2009-10-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#atomics">issues</a> in [atomics].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Right now, the <tt>compare_exchange_weak</tt> loop should rapidly converge on the
padding contents. But <tt>compare_exchange_strong</tt> will require a bit more
compiler work to ignore padding for comparison purposes.
</p>
<p>
Note that this isn't a problem for structs with no padding, and we do
already have one portable way to ensure that there is no padding that
covers the key use cases: Have elements be the same type. I suspect that
the greatest need is for a structure of two pointers, which has no
padding problem. I suspect the second need is a structure of a pointer
and some form of an integer. If that integer is <tt>intptr_t</tt>, there will be
no padding.
</p>
<p>
Related but separable issue: For unused bitfields, or other unused
fields for that matter, we should probably say it's the programmer's
responsibility to set them to zero or otherwise ensure they'll be
ignored by <tt>memcmp</tt>.
</p>

<p>
<b>Proposed resolutions:</b> Using
<tt>atomic&lt;struct-with-padding&gt;::compare_exchange_strong</tt> should be either:
</p>

<ol>
<li>
ill-formed, or
</li>
<li>
well-defined.
</li>
</ol>

<p>
I propose Option 1 for C++0x for expediency, though I'm not sure how to
say it. I would be happy with Option 2, which I believe would mean that
<tt>compare_exchange_strong</tt> would be implemented to avoid comparing padding
bytes, or something equivalent such as always zeroing out padding when
loading/storing/comparing. (Either implementation might require compiler
support.)
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Move to open. Blocked until concepts for atomics are addressed.
</blockquote>

<p><i>[
Post Summit Anthony adds:
]</i></p>


<blockquote>
The resoultion of LWG <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#923">923</a> should resolve this issue as well.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD Editorial.  Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2992.html">N2992</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="926"></a>926. Sequentially consistent fences, relaxed operations and modification order</h3>
<p><b>Section:</b> 29.3 [atomics.order] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Anthony Williams <b>Opened:</b> 2008-10-19  <b>Last modified:</b> 2009-10-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#atomics.order">issues</a> in [atomics.order].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses UK 313</b></p>

<p>
There was an interesting issue raised over on comp.programming.threads
today regarding the following example
</p>

<blockquote><pre>// Thread 1:
x.store(1, memory_order_relaxed);           // SX
atomic_thread_fence(memory_order_seq_cst);  // F1
y.store(1, memory_order_relaxed);           // SY1
atomic_thread_fence(memory_order_seq_cst);  // F2
r1 = y.load(memory_order_relaxed);          // RY

// Thread 2:
y.store(0, memory_order_relaxed);          // SY2
atomic_thread_fence(memory_order_seq_cst); // F3
r2 = x.load(memory_order_relaxed);         // RX
</pre></blockquote>

<p>
is the outcome <tt>r1 == 0</tt> and <tt>r2 == 0</tt> possible?
</p>
<p>
I think the intent is that this is not possible, but I am not sure the
wording guarantees that. Here is my analysis:
</p>
<p>
Since all the fences are SC, there must be a total order between them.
<tt>F1</tt> must be before <tt>F2</tt> in that order since they are in
the same thread. Therefore <tt>F3</tt> is either before <tt>F1</tt>,
between <tt>F1</tt> and <tt>F2</tt> or after <tt>F2</tt>.
</p>
<p>
If <tt>F3</tt> is <em>after</em> <tt>F2</tt>, then we can apply 29.3 [atomics.order]p5 from
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2798.pdf">N2798</a>:
</p>

<blockquote>
For atomic operations <tt>A</tt> and <tt>B</tt> on an atomic object
<tt>M</tt>, where <tt>A</tt> modifies <tt>M</tt> and <tt>B</tt> takes
its value, if there are <tt>memory_order_seq_cst</tt> fences <tt>X</tt>
and <tt>Y</tt> such that <tt>A</tt> is sequenced before <tt>X</tt>,
<tt>Y</tt> is sequenced before <tt>B</tt>, and <tt>X</tt> precedes
<tt>Y</tt> in <tt>S</tt>, then <tt>B</tt> observes either the effects of
<tt>A</tt> or a later modification of <tt>M</tt> in its modification
order.
</blockquote>

<p>
In this case, <tt>A</tt> is <tt>SX</tt>, <tt>B</tt> is <tt>RX</tt>, the
fence <tt>X</tt> is <tt>F2</tt> and the fence <tt>Y</tt> is <tt>F3</tt>,
so <tt>RX</tt> must see 1.
</p>
<p>
If <tt>F3</tt> is <em>before</em> <tt>F2</tt>, this doesn't apply, but
<tt>F3</tt> can therefore be before or after <tt>F1</tt>.
</p>
<p>
If <tt>F3</tt> is <em>after</em> <tt>F1</tt>, the same logic applies, but this
time the fence <tt>X</tt> is <tt>F1</tt>. Therefore again, <tt>RX</tt>
must see 1.
</p>
<p>
Finally we have the case that <tt>F3</tt> is <em>before</em> <tt>F1</tt>
in the SC ordering. There are now no guarantees about <tt>RX</tt>, and
<tt>RX</tt> can see <tt>r2==0</tt>.
</p>
<p>
We can apply 29.3 [atomics.order]p5 again. This time,
<tt>A</tt> is <tt>SY2</tt>, <tt>B</tt> is <tt>RY</tt>, <tt>X</tt> is
<tt>F3</tt> and <tt>Y</tt> is <tt>F1</tt>. Thus <tt>RY</tt> must observe
the effects of <tt>SY2</tt> or a later modification of <tt>y</tt> in its
modification order.
</p>
<p>
Since <tt>SY1</tt> is sequenced before <tt>RY</tt>, <tt>RY</tt> must
observe the effects of <tt>SY1</tt> or a later modification of
<tt>y</tt> in its modification order.
</p>
<p>
In order to ensure that <tt>RY</tt> sees <tt>(r1==1)</tt>, we must see
that <tt>SY1</tt> is later in the modification order of <tt>y</tt> than
<tt>SY2</tt>.
</p>
<p>
We're now skating on thin ice. Conceptually, <tt>SY2</tt> happens-before
<tt>F3</tt>, <tt>F3</tt> is SC-ordered before <tt>F1</tt>, <tt>F1</tt>
happens-before <tt>SY1</tt>, so <tt>SY1</tt> is later in the
modification order <tt>M</tt> of <tt>y</tt>, and <tt>RY</tt> must see
the result of <tt>SY1</tt> (<tt>r1==1</tt>). However, I don't think the
words are clear on that.
</p>

<p><i>[
Post Summit Hans adds:
]</i></p>


<blockquote>
<p>
In my (Hans') view, our definition of fences will always be weaker than
what particular hardware will guarantee.  <tt>Memory_order_seq_cst</tt> fences
inherently don't guarantee sequential consistency anyway, for good
reasons (e.g. because they can't enforce a total order on stores).
 Hence I don't think the issue demonstrates a gross failure to achieve
what we intended to achieve.  The example in question is a bit esoteric.
 Hence, in my view, living with the status quo certainly wouldn't be a
disaster either.
</p>
<p>
In any case, we should probably add text along the lines of the
following between p5 and p6 in 29.3 [atomics.order]:
</p>
<blockquote>
[Note: <tt>Memory_order_seq_cst</tt> only ensures sequential consistency for a
data-race-free program that uses exclusively <tt>memory_order_seq_cst</tt>
operations.  Any use of weaker ordering will invalidate this guarantee
unless extreme care is used.  In particular, <tt>memory_order_seq_cst</tt> fences
only ensure a total order for the fences themselves.  They cannot, in
general, be used to restore sequential consistency for atomic operations
with weaker ordering specifications.]
</blockquote>

<p>
Also see thread beginning at c++std-lib-23271.
</p>

</blockquote>

<p><i>[
Herve's correction:
]</i></p>

<blockquote>
<p>
Minor point, and sorry for the knee jerk reaction: I admit to having
no knowledge of Memory_order_seq_cst, but my former boss (John Lakos)
has ingrained an automatic introspection on the use of "only".   I
think you meant:
</p>

<blockquote>
[Note: <tt>Memory_order_seq_cst</tt> ensures sequential consistency only
for . . . .  In particular, <tt>memory_order_seq_cst</tt> fences ensure a
total order only for . . .
</blockquote>
<p>
Unless, of course, <tt>Memory_order_seq_cst</tt> really do nothing but ensure
sequential consistency for a data-race-free program that uses
exclusively <tt>memory_order_seq_cst</tt> operations.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD Editorial.  Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2992.html">N2992</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add a new paragraph after 29.3 [atomics.order]p5 that says
</p>

<blockquote>
For atomic operations <tt>A</tt> and <tt>B</tt> on an atomic object
<tt>M</tt>, where <tt>A</tt> and <tt>B</tt> modify <tt>M</tt>, if there
are <tt>memory_order_seq_cst</tt> fences <tt>X</tt> and <tt>Y</tt> such
that <tt>A</tt> is sequenced before <tt>X</tt>, <tt>Y</tt> is sequenced
before <tt>B</tt>, and <tt>X</tt> precedes <tt>Y</tt> in <tt>S</tt>,
then <tt>B</tt> occurs later than <tt>A</tt> in the modifiction order of
<tt>M</tt>.
</blockquote>





<hr>
<h3><a name="927"></a>927. <tt>Dereferenceable</tt>  should be <tt>HasDereference</tt></h3>
<p><b>Section:</b> X [allocator.concepts] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Concepts">NAD Concepts</a>
 <b>Submitter:</b> Pablo Halpern <b>Opened:</b> 2008-10-23  <b>Last modified:</b> 2009-07-13</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p>
X [allocator.concepts] contains a reference to a concept named
<tt>Dereferenceable</tt>. No such concept exists.
</p>

<p><i>[
Daniel adds 2009-02-14:
]</i></p>


<blockquote>
The proposal given in the paper
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2829.pdf">N2829</a>
would automatically resolve this issue.
</blockquote>


<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
This particular set of changes has already been made.
There are two related changes later on (and possibly also an earlier Example);
these can be handled editorially.
</p>
<p>
Move to NAD Editorial.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change all uses of the concept <tt>Dereferenceable</tt> to
<tt>HasDereference</tt> in X [allocator.concepts].
</p>





<hr>
<h3><a name="928"></a>928. Wrong concepts used for <tt>tuple</tt>'s comparison operators</h3>
<p><b>Section:</b> 20.5.2.7 [tuple.rel] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Concepts">NAD Concepts</a>
 <b>Submitter:</b> Joe Gottman <b>Opened:</b> 2008-10-28  <b>Last modified:</b> 2009-07-13</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#tuple.rel">issues</a> in [tuple.rel].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In the latest working draft for C++0x, <tt>tuple</tt>'s <tt>operator==</tt> and <tt>operator&lt;</tt>
are declared as 
</p>

<blockquote><pre>template&lt;class... TTypes, class... UTypes&gt; 
  requires EqualityComparable&lt;TTypes, UTypes&gt;... 
  bool operator==(const tuple&lt;TTypes...&gt;&amp; t, const tuple&lt;UTypes...&gt;&amp; u);
</pre></blockquote>

<p>
and
</p>

<blockquote><pre>template&lt;class... TTypes, class... UTypes&gt; 
  requires LessThanComparable&lt;TTypes, UTypes&gt;... 
  bool operator&lt;(const tuple&lt;TTypes...&gt;&amp; t, const tuple&lt;UTypes...&gt;&amp; u);
</pre></blockquote>

<p>
But the concepts <tt>EqualityComparable</tt> and <tt>LessThanComparable</tt> only take one 
parameter, not two.  Also, even if <tt>LessThanComparable</tt> could take two 
parameters, the definition of <tt>tuple::operator&lt;()</tt> should also require 
</p>

<blockquote><pre>LessThanComparable&lt;UTypes, TTypes&gt;... // (note the order) 
</pre></blockquote>

<p>
since the algorithm for <tt>tuple::operator&lt;</tt> is the following (pseudo-code)
</p>

<blockquote><pre>for (size_t N = 0; N &lt; sizeof...(TTypes); ++N) { 
    if (get&lt;N&gt;(t) &lt; get&lt;N&gt;(u) return true; 
    else if ((get&lt;N&gt;(u) &lt; get&lt;N&gt;(t)) return false; 
} 

return false; 
</pre></blockquote>

<p>
Similar problems hold for <tt>tuples</tt>'s other comparison operators.
</p>

<p><i>[
Post Summit:
]</i></p>


<blockquote>
Recommend Tentatively Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
In 20.5.1 [tuple.general] and 20.5.2.7 [tuple.rel] change:
</p>

<blockquote><pre>template&lt;class... TTypes, class... UTypes&gt;
  requires <del>EqualityComparable</del><ins>HasEqualTo</ins>&lt;TTypes, UTypes&gt;...
  bool operator==(const tuple&lt;TTypes...&gt;&amp;, const tuple&lt;UTypes...&gt;&amp;);

template&lt;class... TTypes, class... UTypes&gt;
  requires <del>LessThanComparable</del><ins>HasLess</ins>&lt;TTypes, UTypes&gt;... <ins>&amp;&amp; HasLess&lt;UTypes, TTypes&gt;...</ins>
  bool operator&lt;(const tuple&lt;TTypes...&gt;&amp;, const tuple&lt;UTypes...&gt;&amp;);

template&lt;class... TTypes, class... UTypes&gt;
  requires <del>EqualityComparable</del><ins>HasEqualTo</ins>&lt;TTypes, UTypes&gt;...
  bool operator!=(const tuple&lt;TTypes...&gt;&amp;, const tuple&lt;UTypes...&gt;&amp;);

template&lt;class... TTypes, class... UTypes&gt;
  requires <del>LessThanComparable</del><ins>HasLess</ins>&lt;<del>U</del><ins>T</ins>Types, <del>T</del><ins>U</ins>Types&gt;... <ins>&amp;&amp; HasLess&lt;UTypes, TTypes&gt;...</ins>
  bool operator&gt;(const tuple&lt;TTypes...&gt;&amp;, const tuple&lt;UTypes...&gt;&amp;);

template&lt;class... TTypes, class... UTypes&gt;
  requires <del>LessThanComparable</del><ins>HasLess</ins>&lt;<del>U</del><ins>T</ins>Types, <del>T</del><ins>U</ins>Types&gt;... <ins>&amp;&amp; HasLess&lt;UTypes, TTypes&gt;...</ins>
  bool operator&lt;=(const tuple&lt;TTypes...&gt;&amp;, const tuple&lt;UTypes...&gt;&amp;);

template&lt;class... TTypes, class... UTypes&gt;
  requires <del>LessThanComparable</del><ins>HasLess</ins>&lt;TTypes, UTypes&gt;... <ins>&amp;&amp; HasLess&lt;UTypes, TTypes&gt;...</ins>
  bool operator&gt;=(const tuple&lt;TTypes...&gt;&amp;, const tuple&lt;UTypes...&gt;&amp;);
</pre></blockquote>





<hr>
<h3><a name="930"></a>930. Access to std::array data as built-in array type</h3>
<p><b>Section:</b> 23.3.1 [array] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Niels Dekker <b>Opened:</b> 2008-11-17  <b>Last modified:</b> 2009-10-20</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#array">issues</a> in [array].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p>
The Working Draft (N2798) allows access to the elements of
<tt>std::array</tt> by its <tt>data()</tt> member function:
</p>

<blockquote>

<h5>23.2.1.4 array::data [array.data]</h5>
<pre> T *data();
 const T *data() const;
</pre>
<ol><li>
 Returns: elems.
</li></ol>
</blockquote>

<p>
Unfortunately, the result of <tt>std::array::data()</tt> cannot be bound
to a reference to a built-in array of the type of <tt>array::elems</tt>.
And <tt>std::array</tt> provides no other way to get a reference to
<tt>array::elems</tt>. 
This hampers the use of <tt>std::array</tt>, for example when trying to
pass its data to a C style API function:
</p>

<pre> // Some C style API function. 
 void set_path( char (*)[MAX_PATH] );

 std::array&lt;char,MAX_PATH&gt; path;
 set_path( path.data() );  // error
 set_path( &amp;(path.data()) );  // error
</pre>

 <p>
Another example, trying to pass the array data to an instance of another
C++ class:
</p>

<pre> // Represents a 3-D point in space.
 class three_d_point {
 public:
   explicit three_d_point(const double (&amp;)[3]); 
 };

 const std::array&lt;double,3&gt; coordinates = { 0, 1, 2 };
 three_d_point point1( coordinates.data() );  // error.
 three_d_point point2( *(coordinates.data()) );  // error.
</pre>

<p>
A user might be tempted to use <tt>std::array::elems</tt> instead, but
doing so isn't recommended, because <tt>std::array::elems</tt> is "for
exposition only".  Note that Boost.Array users might already use
<tt>boost::array::elems</tt>, as its documentation doesn't explicitly
state that <tt>boost::array::elems</tt> is for exposition only:
http://www.boost.org/doc/libs/1_36_0/doc/html/boost/array.html
</p>
<p>
I can think of three options to solve this issue:
</p>
<ol><li>
Remove the words "exposition only" from the definition of
<tt>std::array::elems</tt>, as well as the note saying that "elems is
shown for exposition only."
</li><li>
Change the signature of <tt>std::array::data()</tt>, so that it would
return a reference to the built-in array, instead of a pointer to its
first element.
</li><li>
Add extra member functions, returning a reference to the built-in array.
</li></ol>
<p>
Lawrence Crowl wrote me that it might be better to leave
<tt>std::array::elems</tt> "for exposition only", to allow alternate
representations to allocate the array data dynamically.  This might be
of interest to the embedded community, having to deal with very limited
stack sizes.
</p>
<p>
The second option, changing the return type of
<tt>std::array::data()</tt>, would break backward compatible to current
Boost and TR1 implementations, as well as to the other contiguous
container (<tt>vector</tt> and <tt>string</tt>) in a very subtle way.
For example, the following call to <tt>std::swap</tt> currently swap two
locally declared pointers <tt>(data1, data2)</tt>, for any container
type <tt>T</tt> that has a <tt>data()</tt> member function. When
<tt>std::array::data()</tt> is changed to return a reference, the
<tt>std::swap</tt> call may swap the container elements instead.
</p>

<pre> template &lt;typename T&gt;
 void func(T&amp; container1, T&amp; container2)
 {
   // Are data1 and data2 pointers or references?
   auto data1 = container1.data();
   auto data2 = container2.data();

   // Will this swap two local pointers, or all container elements?
   std::swap(data1, data2);
 }
</pre>

<p>
The following concept is currently satisfied by all contiguous
containers, but it no longer is for <tt>std::array</tt>, when
<tt>array::data()</tt>
is changed to return a reference (tested on ConceptGCC Alpha 7):
</p>

<pre> auto concept ContiguousContainerConcept&lt;typename T&gt;
 {
   typename value_type = typename T::value_type;
   const value_type * T::data() const;
 }
</pre>

<p>
Still it's worth considering having <tt>std::array::data()</tt> return a
reference, because it might be the most intuitive option, from a user's
point of view.  Nicolai Josuttis (who wrote <tt>boost::array</tt>)
mailed me that he very much prefers this option.
</p>
<p>
Note that for this option, the definition of <tt>data()</tt> would also
need to be revised for zero-sized arrays, as its return type cannot be a
reference to a zero-sized built-in array.  Regarding zero-sized array,
<tt>data()</tt> could throw an exception.  Or there could be a partial
specialization of <tt>std::array</tt> where <tt>data()</tt> returns
<tt>T*</tt> or gets removed.
</p>
<p>
Personally I prefer the third option, adding a new member function to
<tt>std::array</tt>, overloaded for const and non-const access,
returning a reference to the built-in array, to avoid those compatible
issues. I'd propose naming the function <tt>std::array::c_array()</tt>,
which sounds intuitive to me. Note that <tt>boost::array</tt> already
has a <tt>c_array()</tt> member, returning a pointer, but Nicolai told
me that this one is only there for historical reasons. (Otherwise a name
like <tt>std::array::native_array()</tt> or
<tt>std::array::builtin_array()</tt> would also be fine with me.) 
According to my proposed resolution, a zero-sized <tt>std::array</tt> does not need
to have <tt>c_array()</tt>, while it is still required to have
<tt>data()</tt> functions.
</p>

<p><i>[
Post Summit:
]</i></p>


<blockquote>

<p>
Alisdair: Don't like p4 suggesting implementation-defined behaviour.
</p>
<p>
Walter: What about an explicit conversion operator, instead of adding
the new member function?
</p>
<p>
Alisdair: Noodling about:
</p>
<blockquote><pre>template&lt;size_t N, ValueType T&gt;
struct array
{
  T elems[N];

// fantasy code starts here

// crazy decltype version for grins only
//requires True&lt;(N&gt;0)&gt;
//explict operator decltype(elems) &amp; () { return elems; }

// conversion to lvalue ref
requires True&lt;(N&gt;0)&gt;
explict operator T(&amp;)[N] () &amp; { return elems; }

// conversion to const lvalue ref
requires True&lt;(N&gt;0)&gt;
explict operator const T(&amp;)[N] () const &amp; { return elems; }

// conversion to rvalue ref using ref qualifiers
requires True&lt;(N&gt;0)&gt;
explict operator T(&amp;&amp;)[N] () &amp;&amp; { return elems; }

// fantasy code ends here

explicit operator bool() { return true; }
};
</pre></blockquote>

<p>
This seems legal but odd. Jason Merrill says currently a CWG issue 613
on the non-static data member that fixes the error that current G++
gives for the non-explicit, non-conceptualized version of this. Verdict
from human compiler: seems legal.
</p>
<p>
Some grumbling about zero-sized arrays being allowed and supported.
</p>
<p>
Walter: Would this address the issue? Are we inclined to go this route?
</p>
<p>
Alan: What would usage look like?
</p>
<blockquote><pre>// 3-d point in space
struct three_d_point
{
  explicit three_d_point(const double (&amp;)[3]);
};

void sink(double*);

const std::array&lt;double, 3&gt; coordinates = { 0, 1, 2 };
three_d_point point1( coordinates.data() ); //error
three_d_point point2( *(coordinates.data()) ); // error
three_d_point point3( coordinates ); // yay!

sink(cooridinates); // error, no conversion
</pre></blockquote>

<p>
Recommended Open with new wording. Take the required clause and add the
explicit conversion operators, not have a <tt>typedef</tt>. At issue still is use
<tt>decltype</tt> or use <tt>T[N]</tt>. In favour of using <tt>T[N]</tt>, even though use of
<tt>decltype</tt> is specially clever.
</p>

</blockquote>

<p><i>[
Post Summit, further discussion in the thread starting with c++std-lib-23215.
]</i></p>


<p><i>[
2009-07 post-Frankfurt (Saturday afternoon group):
]</i></p>


<blockquote>
<p>
The idea to resolve the issue by adding explicit conversion operators
was abandoned, because it would be inconvenient to use, especially when
passing the array to a template function, as mentioned by Daniel. So we
reconsidered the original proposed resolution, which appeared
acceptable, except for its proposed changes to 23.3.1.6 [array.zero], which
allowed <tt>c_array_type</tt> and <tt>c_array()</tt> to be absent for a zero-sized array.
Alisdair argued that such wording would disallow certain generic use
cases. New wording for 23.3.1.6 [array.zero] was agreed upon (Howard: and
is reflected in the proposed resolution).
</p>
<p>
Move to Review
</p>
</blockquote>

<p><i>[
2009-07-31 Alisdair adds:
]</i></p>


<blockquote>
<p>
I will be unhappy voting the proposed resolution for 930 past review
until we have implementation experience with reference qualifiers. 
Specifically, I want to understand the impact of the missing overload
for <tt>const &amp;&amp;</tt> (if any.)
</p>

<p>
If we think the issue is important enough it might be worthwhile
stripping the ref qualifiers for easy progress next meeting, and opening
yet another issue to put them back with experience.
</p>

<p>
Recommend deferring any decision on splitting the issue until we get LWG
feedback next meeting - I may be the lone dissenting voice if others are
prepared to proceed without it.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Mark as NAD. There was not enough consensus that this was sufficiently
useful. There are known other ways to do this, such as small inline
conversion functions.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add to the template definition of array, 23.3.1 [array]/3:
</p>

<blockquote>
<pre><ins>
typedef T c_array_type[N];
c_array_type &amp; c_array() &amp;;
c_array_type &amp;&amp; c_array() &amp;&amp;;
const c_array_type &amp; c_array() const &amp;;
</ins>
</pre>
</blockquote>

<p>
Add the following subsection to 23.3.1 [array], after 23.3.1.4 [array.data]:
</p>

<blockquote>
<h5><ins>23.2.1.5 array::c_array [array.c_array]</ins></h5>
    <pre><ins>
c_array_type &amp; c_array() &amp;;
c_array_type &amp;&amp; c_array() &amp;&amp;;
const c_array_type &amp; c_array() const &amp;;
</ins></pre>
<blockquote>
<p>
<ins><i>Returns:</i> <tt>elems</tt>.</ins>
</p>
</blockquote>

</blockquote>



<p>
Change Zero sized arrays 23.3.1.6 [array.zero]:
</p>

<blockquote>

<p>-2- ...</p>

<p><ins>
The type <tt>c_array_type</tt> is unspecified for a zero-sized array.
</ins></p>

<p>
-3- The effect of calling <ins><tt>c_array()</tt>,</ins> <tt>front()</tt><ins>,</ins> or
<tt>back()</tt> for a zero-sized array is implementation defined.
</p>
</blockquote>






<hr>
<h3><a name="933"></a>933. Unique_ptr defect</h3>
<p><b>Section:</b> 20.8.14.2.5 [unique.ptr.single.modifiers] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Future">NAD Future</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2008-11-27  <b>Last modified:</b> 2009-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#unique.ptr.single.modifiers">issues</a> in [unique.ptr.single.modifiers].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Future">NAD Future</a> status.</p>
<p><b>Discussion:</b></p>
<p>
If we are supporting stateful deleters, we need an overload for
<tt>reset</tt> that
takes a deleter as well.
</p>

<blockquote><pre>void reset( pointer p, deleter_type d);
</pre></blockquote>

<p>
We probably need two overloads to support move-only deleters, and
this
sounds uncomfortably like the two constructors I have been ignoring
for
now...
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Howard comments that we have the functionality via move-assigment.
</p>
<p>
Move to Open.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Mark as NAD Future.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="935"></a>935. clock error handling needs to be specified</h3>
<p><b>Section:</b> 20.9.5 [time.clock] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Future">NAD Future</a>
 <b>Submitter:</b> Beman Dawes <b>Opened:</b> 2008-11-24  <b>Last modified:</b> 2009-10-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Future">NAD Future</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Each of the three clocks specified in Clocks 20.9.5 [time.clock]
provides the member function:
</p>

<blockquote><pre>static time_point now();
</pre></blockquote>

<p>
The semantics specified by Clock requirements 20.9.1 [time.clock.req]
make no mention of error handling. Thus the function may throw <tt>bad_alloc</tt>
or an implementation-defined exception (17.6.4.11 [res.on.exception.handling]
paragraph 4).
</p>

<p>
Some implementations of these functions on POSIX, Windows, and
presumably on other operating systems, may fail in ways only detectable
at runtime. Some failures on Windows are due to supporting chipset
errata and can even occur after successful calls to a clock's <tt>now()</tt>
function.
</p>

<p>
These functions are used in cases where exceptions are not appropriate
or where the specifics of the exception or cause of error need to be
available to the user. See
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2828.html">N2828</a>,
<i>Library Support for hybrid error
handling (Rev 1)</i>, for more specific discussion of use cases. Thus some change in
the interface of now is required.
</p>

<p>
The proposed resolution has been implemented in the Boost version of the
chrono library. No problems were encountered.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We recommend this issue be deferred until the next Committee Draft
has been issued and the prerequisite paper has been accepted.
</p>
<p>
Move to Open.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Mark as NAD future. Too late to make this change without having already
accepted the hybrid error handling proposal.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Accept the proposed wording of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2828.html">N2828</a>,
<i>Library Support for hybrid error handling (Rev 1)</i>.
</p>

<p>
Change Clock requirements 20.9.1 [time.clock.req] as indicated:
</p>

<blockquote>
<p>
-2- In Table 55 <tt>C1</tt> and <tt>C2</tt> denote clock types. <tt>t1</tt> and
<tt>t2</tt> are values returned by <tt>C1::now()</tt> where the call 
returning <tt>t1</tt> happens before (1.10) the call returning <tt>t2</tt> and
both of these calls happen before <tt>C1::time_point::max()</tt>.
<ins><tt>ec</tt> denotes an object of type <tt>error_code</tt> 
(19.5.2.1 [syserr.errcode.overview]).</ins>
</p>

<table border="1">
<caption>Table 55 -- Clock requirements</caption>
<tbody><tr>
<th>Expression</th><th>Return type</th><th>Operational semantics</th>
</tr>

<tr>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>

<tr>
<td><tt>C1::now()</tt></td>
<td><tt>C1::time_point</tt></td>
<td>Returns a <tt>time_point</tt> object representing the current point in time.
</td>
</tr>

<tr>
<td><tt><ins>C1::now(ec)</ins></tt></td>
<td><tt><ins>C1::time_point</ins></tt></td>
<td><ins>Returns a <tt>time_point</tt> object representing the current point in time.</ins>
</td>
</tr>
</tbody></table>
</blockquote>

<p>
Change Class system_clock 20.9.5.1 [time.clock.system] as indicated:
</p>

<blockquote><pre>static time_point now(<ins>error_code&amp; ec=throws()</ins>);
</pre></blockquote>

<p>
Change Class monotonic_clock 20.9.5.2 [time.clock.monotonic] as indicated:
</p>

<blockquote><pre>static time_point now(<ins>error_code&amp; ec=throws()</ins>);
</pre></blockquote>

<p>
Change Class high_resolution_clock 20.9.5.3 [time.clock.hires] as indicated:
</p>

<blockquote><pre>static time_point now(<ins>error_code&amp; ec=throws()</ins>);
</pre></blockquote>






<hr>
<h3><a name="936"></a>936. Mutex type overspecified</h3>
<p><b>Section:</b> 30.4.1 [thread.mutex.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Future">NAD Future</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2008-12-05  <b>Last modified:</b> 2009-10-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#thread.mutex.requirements">active issues</a> in [thread.mutex.requirements].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.mutex.requirements">issues</a> in [thread.mutex.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Future">NAD Future</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#961">961</a></p>
<p><b>Discussion:</b></p>



<p>
30.4.1 [thread.mutex.requirements] describes the requirements for a type to be
a "Mutex type". A Mutex type can be used as the template argument for
the <tt>Lock</tt> type that's passed to <tt>condition_variable_any::wait</tt> (although
<tt>Lock</tt> seems like the wrong name here, since <tt>Lock</tt> is given a different
formal meaning in 30.4.3 [thread.lock]) and, although the WD doesn't quite say
so, as the template argument for <tt>lock_guard</tt> and <tt>unique_lock</tt>.
</p>

<p>
The requirements for a Mutex type include:
</p>

<ul>
<li>
<tt>m.lock()</tt> shall be well-formed and have [described] semantics, including a return type of <tt>void</tt>.
</li>
<li>
<tt>m.try_lock()</tt> shall be well-formed and have [described] semantics, including a return type of <tt>bool</tt>.
</li>
<li>
<tt>m.unlock()</tt> shall be well-formed and have [described] semantics, including a return type of <tt>void</tt>.
</li>
</ul>

<p>
Also, a Mutex type "shall not be copyable nor movable".
</p>

<p>
The latter requirement seems completely irrelevant, and the three
requirements on return types are tighter than they need to be. For
example, there's no reason that <tt>lock_guard</tt> can't be instantiated with a
type that's copyable. The rule is, in fact, that <tt>lock_guard</tt>, etc. won't
try to copy objects of that type. That's a constraint on locks, not on
mutexes. Similarly, the requirements for <tt>void</tt> return types are
unnecessary; the rule is, in fact, that <tt>lock_guard</tt>, etc. won't use any
returned value. And with the return type of <tt>bool</tt>, the requirement should
be that the return type is convertible to <tt>bool</tt>.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
<p>
Move to open. Related to conceptualization and should probably be tackled as part of that.
</p>
<ul>
<li>
The intention is not only to place a constraint on what types such as
<tt>lock_guard</tt> may do with mutex types, but on what any code, including user
code, may do with mutex types. Thus the constraints as they are apply to
the mutex types themselves, not the current users of mutex types in the
standard.
</li>
<li>
This is a low priority issue; the wording as it is may be overly
restrictive but this may not be a real issue.
</li>
</ul>
</blockquote>

<p><i>[
Post Summit Anthony adds:
]</i></p>


<blockquote>
<p>
Section 30.4.1 [thread.mutex.requirements] conflates the
requirements on a generic Mutex type (including user-supplied mutexes)
with the requirements placed on the standard-supplied mutex types in an
attempt to group everything together and save space.
</p>
<p>
When applying concepts to chapter 30, I suggest that the concepts
<tt>Lockable</tt> and <tt>TimedLockable</tt> embody the requirements for
*use* of a mutex type as required by
<tt>unique_lock/lock_guard/condition_variable_any</tt>. These should be
relaxed as Pete describes in the issue. The existing words in 30.4.1 [thread.mutex.requirements] are requirements on all of
<tt>std::mutex</tt>, <tt>std::timed_mutex</tt>,
<tt>std::recursive_mutex</tt> and <tt>std::recursive_timed_mutex</tt>,
and should be rephrased as such.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="937"></a>937. Atomics for standard typedef types</h3>
<p><b>Section:</b> 29 [atomics] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Clark Nelson <b>Opened:</b> 2008-12-05  <b>Last modified:</b> 2009-05-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#atomics">issues</a> in [atomics].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses US 89</b></p>

<blockquote>
<p>
The types in the table "Atomics for standard typedef types" should be
typedefs, not classes. These semantics are necessary for compatibility
with C.
</p>

<p>
Change the classes to typedefs.
</p>
</blockquote>

<p>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2427.html">N2427</a>
specified different requirements for atomic analogs of fundamental
integer types (such as <tt>atomic_int</tt>) and for atomic analogs of <tt>&lt;cstdint&gt;</tt>
typedefs (such as <tt>atomic_size_t</tt>). Specifically, <tt>atomic_int</tt> et al. were
specified to be distinct classes, whereas <tt>atomic_size_t</tt> et al. were
specified to be typedefs. Unfortunately, in applying
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2427.html">N2427</a>
to the WD, that distinction was erased, and the atomic analog of every <tt>&lt;cstdint&gt;</tt>
typedef is required to be a distinct class.
</p>

<p>
It shouldn't be required that the atomic analog of every <tt>&lt;cstdint&gt;</tt>
typedef be a typedef for some fundamental integer type. After all,
<tt>&lt;cstdint&gt;</tt> is supposed to provide standard names for extended integer
types. So there was a problem in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2427.html">N2427</a>,
which certainly could have been
interpreted to require that. But the status quo in the WD is even worse,
because it's unambiguously wrong.
</p>

<p>
What is needed are words to require the existence of a bunch of type
names, without specifying whether they are class names or typedef names.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
<p>
Change status to NAD, editorial. See US 89 comment notes above.
</p>
<p>
Direct the editor to turn the types into typedefs as proposed in the
comment. Paper approved by committee used typedefs, this appears to have
been introduced as an editorial change. Rationale: for compatibility
with C.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="941"></a>941. Ref-qualifiers for assignment operators</h3>
<p><b>Section:</b> 17 [library] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Niels Dekker <b>Opened:</b> 2008-12-18  <b>Last modified:</b> 2009-07-17</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The assignment and equality operators <tt>=</tt> and <tt>==</tt> are easily confused, just
because of their visual similarity, and in this case a simple typo can cause
a serious bug. When the left side of an <tt>operator=</tt> is an rvalue, it's
highly unlikely that the assignment was intended by the programmer:
</p>
<blockquote><pre>if ( func() = value )  // Typical typo: == intended!
</pre></blockquote>
<p>
Built-in types don't support assignment to an rvalue, but unfortunately,
a lot of types provided by the Standard Library do.
</p>
<p>
Fortunately the language now offers a syntax to prevent a certain member
function from having an rvalue as <tt>*this</tt>: by adding a ref-qualifier (<tt>&amp;</tt>)
to the member function declaration.  Assignment operators are explicitly
mentioned as a use case of ref-qualifiers, in "Extending Move Semantics
To <tt>*this</tt> (Revision 1)",
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1821.htm">N1821</a> by Daveed
Vandevoorde and Bronek Kozicki
</p>
<p>
Hereby I would like to propose adding ref-qualifiers to all appropriate
assignment operators in the library.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Move to Open.
We recommend this be deferred until after the next Committee Draft.
</blockquote>

<p><i>[
Frankfurt 2009-07:
]</i></p>


<blockquote>
<p>
The LWG declined to move forward with
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2819.html">N2819</a>.
</p>
<p>
Moved to NAD.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
A proposed resolution is provided by the paper on this subject,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2819.html">N2819</a>,
<i>Ref-qualifiers for assignment operators of the Standard Library</i>
</p>





<hr>
<h3><a name="942"></a>942. Atomics synopsis typo</h3>
<p><b>Section:</b> 29 [atomics] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Holger Grund <b>Opened:</b> 2008-12-19  <b>Last modified:</b> 2009-03-22</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#atomics">issues</a> in [atomics].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#880">880</a></p>
<p><b>Discussion:</b></p>



<p>
I'm looking at 29 [atomics] and can't really make sense of a couple of things.
</p>
<p>
Firstly, there appears to be a typo in the <tt>&lt;cstdatomic&gt;</tt> synopsis:
</p>

<blockquote>
<p>
The <tt>atomic_exchange</tt> overload taking an <tt>atomic_address</tt>
is missing the second parameter:
</p>

<blockquote><pre>void* atomic_exchange(volatile atomic_address*);
</pre></blockquote>

<p>
should be
</p>

<blockquote><pre>void* atomic_exchange(volatile atomic_address*<ins>, void*</ins>);
</pre></blockquote>

<p>
Note, that this is <em>not</em> covered by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#880">880</a> "Missing atomic exchange parameter",
which only talks about the <tt>atomic_bool</tt>.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change the synopsis in 29 [atomics]/2:
</p>

<blockquote><pre>void* atomic_exchange(volatile atomic_address*<ins>, void*</ins>);
</pre></blockquote>






<hr>
<h3><a name="944"></a>944. <tt>atomic&lt;bool&gt;</tt> derive from <tt>atomic_bool</tt>?</h3>
<p><b>Section:</b> 29.5.3 [atomics.types.generic] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Holger Grund <b>Opened:</b> 2008-12-19  <b>Last modified:</b> 2009-10-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#atomics.types.generic">issues</a> in [atomics.types.generic].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I think it's fairly obvious that <tt>atomic&lt;bool&gt;</tt> is supposed to be derived
from <tt>atomic_bool</tt> (and otherwise follow the <tt>atomic&lt;integral&gt;</tt> interface),
though I think the current wording doesn't support this. I raised this
point along with <tt>atomic&lt;floating-point&gt;</tt> privately with Herb and I seem
to recall it came up in the resulting discussion on this list. However,
I don't see anything on the current libs issue list mentioning this
problem.
</p>

<p>
29.5.3 [atomics.types.generic]/3 reads
</p>

<blockquote>
There are full specializations over the integral types on the atomic
class template. For each integral type integral in the second column of
table 121 or table 122, the specialization <tt>atomic&lt;integral&gt;</tt> shall be
publicly derived from the corresponding atomic integral type in the
first column of the table. These specializations shall have trivial
default constructors and trivial destructors.
</blockquote>

<p>
Table 121 does not include (<tt>atomic_bool</tt>, <tt>bool</tt>),
so that this should probably be mentioned explicitly in the quoted paragraph.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Move to open. Lawrence will draft a proposed resolution. Also, ask
Howard to fix the title.
</blockquote>

<p><i>[
Post Summit Anthony provided proposed wording.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD Editorial.  Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2992.html">N2992</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Replace paragraph 3 in 29.5.3 [atomics.types.generic] with
</p>

<blockquote>
-3- There are full specializations over the integral types on the <tt>atomic</tt>
class template. For each integral type <tt>integral</tt> in the second column of
table 121 or table 122, the specialization <tt>atomic&lt;integral&gt;</tt> shall be
publicly derived from the corresponding atomic integral type in the first
column of the table.
<ins>In addition, the specialization <tt>atomic&lt;bool&gt;</tt>
shall be publicly derived from <tt>atomic_bool</tt>.</ins>
These specializations shall have trivial default
constructors and trivial destructors.
</blockquote>





<hr>
<h3><a name="945"></a>945. <tt>system_clock::rep</tt> not specified</h3>
<p><b>Section:</b> 20.9.5.1 [time.clock.system] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2008-12-19  <b>Last modified:</b> 2009-07-13</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#time.clock.system">issues</a> in [time.clock.system].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 20.9.5.1 [time.clock.system], the declaration of <tt>system_clock::rep</tt> says "see
below", but there is nothing below that describes it.
</p>

<p><i>[
Howard adds:
]</i></p>


<blockquote>
<p>
This note refers to:
</p>

<blockquote>
-2- <tt>system_clock::duration::min() &lt; system_clock::duration::zero()</tt> shall be <tt>true</tt>.
</blockquote>

<p>
I.e. this is standardeze for "<tt>system_clock::rep</tt> is signed".
Perhaps an editorial note along the lines of:
</p>

<blockquote>
-2- <tt>system_clock::duration::min() &lt; system_clock::duration::zero()</tt>
shall be <tt>true</tt>. <ins>[<i>Note:</i> <tt>system_clock::rep</tt> shall be signed. <i>-- end note</i>].</ins>
</blockquote>

<p>
?
</p>

</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the direction of the proposed resolution.
Move to NAD Editorial.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add a note to 20.9.5.1 [time.clock.system], p2:
</p>
<blockquote>
-2- <tt>system_clock::duration::min() &lt; system_clock::duration::zero()</tt>
shall be <tt>true</tt>. <ins>[<i>Note:</i> <tt>system_clock::rep</tt> shall be signed. <i>-- end note</i>].</ins>
</blockquote>





<hr>
<h3><a name="946"></a>946. <tt>duration_cast</tt> improperly specified</h3>
<p><b>Section:</b> 20.9.3.7 [time.duration.cast] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2008-12-20  <b>Last modified:</b> 2009-07-13</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#time.duration.cast">issues</a> in [time.duration.cast].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
20.9.3.7 [time.duration.cast]/3:

<blockquote>
.... All intermediate computations shall be
carried out in the widest possible representation... .
</blockquote>

<p>
So ignoring
floating-point types for the moment, all this arithmetic has to be done
using the implementation's largest integral type, even if both arguments
use int for their representation. This seems excessive. And it's not at
all clear what this means if we don't ignore floating-point types.
</p>

<p>
This issue is related to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#952">952</a>.
</p>

<p><i>[
Howard adds:
]</i></p>


<blockquote>
<p>
The intent of this remark is that intermediate computations are carried out
using:
</p>

<blockquote><pre>common_type&lt;typename ToDuration::rep, Rep, intmax_t&gt;::type
</pre></blockquote>

<p>
The Remark was intended to be clarifying prose supporting the rather algorithmic description
of the previous paragraph.  I'm open to suggestions.  Perhaps the entire paragraph
3 (Remarks) would be better dropped?
</p>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We view this as a specific case of issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#952">952</a>,
and should be resolved when that issue is resolved.
</p>
<p>
Move to NAD.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="947"></a>947. duration arithmetic: contradictory requirements</h3>
<p><b>Section:</b> 20.9.3.5 [time.duration.nonmember] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2008-12-20  <b>Last modified:</b> 2009-10-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#time.duration.nonmember">issues</a> in [time.duration.nonmember].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 20.9.3.5 [time.duration.nonmember], paragraph 8 says that calling
<tt>dur / rep</tt>
when <tt>rep</tt> is an instantiation of <tt>duration</tt> requires a diagnostic.
That's followed by an <tt>operator/</tt> that takes two durations.
So <tt>dur1 / dur2</tt> is legal under the second version,
but requires a diagnostic under the first.
</p>

<p><i>[
Howard adds:
]</i></p>


<blockquote>
Please see the thread starting with c++std-lib-22980 for more information.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Move to Open, pending proposed wording (and preferably an implementation).
</blockquote>

<p><i>[
2009-07-27 Howard adds:
]</i></p>


<blockquote>
<p>
I've addressed this issue under the proposed wording for <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1177">1177</a> which
cleans up several places under 20.9.3 [time.duration] which used the
phrase "diagnostic required".
</p>
<p>
For clarity's sake, here is an example implementation of the constrained <tt>operator/</tt>:
</p>

<blockquote><pre>template &lt;class _Duration, class _Rep, bool = __is_duration&lt;_Rep&gt;::value&gt;
struct __duration_divide_result
{
};

template &lt;class _Duration, class _Rep2,
    bool = is_convertible&lt;_Rep2,
                          typename common_type&lt;typename _Duration::rep, _Rep2&gt;::type&gt;::value&gt;
struct __duration_divide_imp
{
};

template &lt;class _Rep1, class _Period, class _Rep2&gt;
struct __duration_divide_imp&lt;duration&lt;_Rep1, _Period&gt;, _Rep2, true&gt;
{
    typedef duration&lt;typename common_type&lt;_Rep1, _Rep2&gt;::type, _Period&gt; type;
};

template &lt;class _Rep1, class _Period, class _Rep2&gt;
struct __duration_divide_result&lt;duration&lt;_Rep1, _Period&gt;, _Rep2, false&gt;
    : __duration_divide_imp&lt;duration&lt;_Rep1, _Period&gt;, _Rep2&gt;
{
};

template &lt;class _Rep1, class _Period, class _Rep2&gt;
inline
typename __duration_divide_result&lt;duration&lt;_Rep1, _Period&gt;, _Rep2&gt;::type
operator/(const duration&lt;_Rep1, _Period&gt;&amp; __d, const _Rep2&amp; __s)
{
    typedef typename common_type&lt;_Rep1, _Rep2&gt;::type _Cr;
    duration&lt;_Cr, _Period&gt; __r = __d;
    __r /= static_cast&lt;_Cr&gt;(__s);
    return __r;
}
</pre></blockquote>

<p>
<tt>__duration_divide_result</tt> is basically a custom-built <tt>enable_if</tt>
that will contain <tt>type</tt> only if <tt>Rep2</tt> is not a <tt>duration</tt>
and if <tt>Rep2</tt> is implicitly convertible to
<tt>common_type&lt;typename Duration::rep, Rep2&gt;::type</tt>. <tt>__is_duration</tt>
is simply a private trait that answers <tt>false</tt>, but is specialized for
<tt>duration</tt> to answer <tt>true</tt>.
</p>

<p>
The constrained <tt>operator%</tt> works identically.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Mark NAD Editorial, fixed by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1177">1177</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="952"></a>952. Various threading bugs #2</h3>
<p><b>Section:</b> 20.9.3.7 [time.duration.cast] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2009-01-07  <b>Last modified:</b> 2009-07-13</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#time.duration.cast">issues</a> in [time.duration.cast].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
20.9.3.7 [time.duration.cast] specifies an implementation and imposes
requirements in text (and the implementation doesn't satisfy all of the
text requirements). Pick one.
</p>

<p>
This issue is related to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#946">946</a>.
</p>

<p><i>[
2009-05-10 Howard adds:
]</i></p>


<blockquote>
<p>
The <i>Remarks</i> paragraph is an English re-statement of the preceeding
<i>Returns</i> clause.  It was meant to be clarifying and motivating, not
confusing.  I'm not aware with how the <i>Remarks</i> contradicts the <i>Returns</i> clause
but I'm ok with simply removing the <i>Remarks</i>.
</p>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Pete suggests that this could be resolved
by rephrasing the Remarks to Notes.
</p>
<p>
Move to NAD Editorial.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="955"></a>955. Various threading bugs #5</h3>
<p><b>Section:</b> 20.9.1 [time.clock.req] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2009-01-07  <b>Last modified:</b> 2009-10-26</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#time.clock.req">active issues</a> in [time.clock.req].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#time.clock.req">issues</a> in [time.clock.req].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
20.9.1 [time.clock.req] requires that a clock type have a member
typedef named <tt>time_point</tt> that names an instantiation of the
template <tt>time_point</tt>, and a member named <tt>duration</tt> that
names an instantiation of the template <tt>duration</tt>. This mixing of
levels is confusing. The typedef names should be different from the
template names.
</p>

<p><i>[
Post Summit, Anthony provided proposed wording.
]</i></p>


<p><i>[
2009-05-04 Howard adds:
]</i></p>


<blockquote>
<p>
The reason that the typedef names were given the same name as the class templates
was so that clients would not have to stop and think about whether they were
using the clock's native <tt>time_point</tt> / <tt>duration</tt> or the class
template directly.  In this case, one person's confusion is another person's
encapsulation.  The detail that sometimes one is referring to the clock's
native types, and sometimes one is referring to an independent type is
<em>purposefully</em> "hidden" because it is supposed to be an unimportant
detail.  It can be confusing to have to remember when to type <tt>duration</tt>
and when to type <tt>duration_type</tt>, and there is no need to require the
client to remember something like that.
</p>

<p>
For example, here is code that I once wrote in testing out the usability of
this facility:
</p>

<blockquote><pre>template &lt;class Clock, class Duration&gt;
void do_until(const std::chrono::<b>time_point</b>&lt;Clock, Duration&gt;&amp; t)
{
    typename Clock::<b>time_point now</b> = Clock::now();
    if (t &gt; now)
    {
        typedef typename std::common_type
        &lt;
            Duration,
            typename std::chrono::system_clock::<b>duration</b>
        &gt;::type CD;
        typedef std::chrono::<b>duration</b>&lt;double, std::nano&gt; ID;

        CD d = t - now;
        ID us = duration_cast&lt;ID&gt;(d);
        if (us &lt; d)
            ++us;
        ...
    }
}
</pre></blockquote>

<p>
I see no rationale to require the client to append <tt>_type</tt> to <em>some</em>
of those declarations.  It seems overly burdensome on the author of <tt>do_until</tt>:
</p>

<blockquote><pre>template &lt;class Clock, class Duration&gt;
void do_until(const std::chrono::<b>time_point</b>&lt;Clock, Duration&gt;&amp; t)
{
    typename Clock::<b>time_point<font color="#c80000">_type</font></b> now = Clock::now();
    if (t &gt; now)
    {
        typedef typename std::common_type
        &lt;
            Duration,
            typename std::chrono::system_clock::<b>duration<font color="#c80000">_type</font></b>
        &gt;::type CD;
        typedef std::chrono::<b>duration</b>&lt;double, std::nano&gt; ID;

        CD d = t - now;
        ID us = duration_cast&lt;ID&gt;(d);
        if (us &lt; d)
            ++us;
        ...
    }
}
</pre></blockquote>

<p>
Additionally I'm fairly certain that this suggestion hasn't been implemented.
If it had, it would have been discovered that it is incomplete.  <tt>time_point</tt>
also has a nested type (purposefully) named <tt>duration</tt>.
</p>
<blockquote>
That is, the current proposed wording would put the WP into an inconsistent state.
</blockquote>
<p>
In contrast,
the current WP has been implemented and I've received very favorable feedback
from people using this interface in real-world code.
</p>

</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Bill agrees that distinct names should be used for distinct kinds of entities.
</p>
<p>
Walter would prefer not to suffix type names,
especially for such well-understood terms as "duration".
</p>
<p>
Howard reminds us that the proposed resolution is incomplete, per his comment
in the issue.
</p>
<p>
Move to Open.
</p>
</blockquote>

<p><i>[
2009-06-07 Howard adds:
]</i></p>


<blockquote>
<p>
Not meaning to be argumentative, but we have a decade of positive experience
with the precedent of using the same name for the nested type as an external
class representing an identical concept.
</p>

<blockquote><pre>template&lt;class Category, class T, class Distance = ptrdiff_t,
         class Pointer = T*, class Reference = T&amp;&gt;
struct <b>iterator</b>
{
    ...
};

template &lt;BidirectionalIterator Iter&gt;
class <b>reverse_iterator</b>
{
    ...
};

template &lt;ValueType T, Allocator Alloc = allocator&lt;T&gt; &gt;
    requires NothrowDestructible&lt;T&gt;
class list
{
public:
    typedef <i>implementation-defined</i>     <b>iterator</b>;
    ...
    typedef reverse_iterator&lt;iterator&gt; <b>reverse_iterator</b>;
    ...
};
</pre></blockquote>

<p>
I am aware of <em>zero</em> complaints regarding the use of <tt>iterator</tt>
and <tt>reverse_iterator</tt> as nested types of the containers despite these
names also having related meaning at namespace std scope.
</p>

<p>
Would we really be doing programmers a favor by renaming these nested types?
</p>

<blockquote><pre>template &lt;ValueType T, Allocator Alloc = allocator&lt;T&gt; &gt;
    requires NothrowDestructible&lt;T&gt;
class list
{
public:
    typedef <i>implementation-defined</i>     <b>iterator_type</b>;
    ...
    typedef reverse_iterator&lt;iterator&gt; <b>reverse_iterator_type</b>;
    ...
};
</pre></blockquote>

<p>
I submit that such design contributes to needless verbosity which ends up
reducing readability.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Mark as NAD.  No concensus for changing the WP.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 20.9 [time]:
</p>

<blockquote><pre>...
template &lt;class Clock, class Duration = typename Clock::duration<ins>_type</ins>&gt; class time_point;
...
</pre></blockquote>

<p>
Change 20.9.1 [time.clock.req]:
</p>

<blockquote>
<table border="1">
<caption>Table 45 -- Clock requirements</caption>
<tbody><tr>
<th>Expression</th>
<th>Return type</th>
<th>Operational semantics</th>
</tr>
<tr>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
<tr>
<td><tt>C1::duration<ins>_type</ins></tt></td>
<td><tt>chrono::duration&lt;C1::rep, C1::period&gt;</tt></td>
<td>The native <tt>duration</tt> type of the clock.</td>
</tr>
<tr>
<td><tt>C1::time_point<ins>_type</ins></tt></td>
<td><tt>chrono::time_point&lt;C1&gt;</tt> or <tt>chrono::time_point&lt;C2, C1::duration<ins>_type</ins>&lt;</tt></td>
<td>The native <tt>time_point</tt> type of the clock.   Different clocks may  share a <tt>time_point<ins>_type</ins></tt>
definition if it is valid to 
compare their <tt>time_point<ins>_type</ins></tt>s by 
comparing their respective 
<tt>duration<ins>_type</ins></tt>s. <tt>C1</tt> and <tt>C2</tt> shall 
refer to the same epoch.</td>
</tr>
<tr>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
<tr>
<td><tt>C1::now()</tt></td>
<td><tt>C1::time_point<ins>_type</ins></tt></td>
<td>Returns a <tt>time_point<ins>_type</ins></tt> object 
representing the current point 
in time.
</td>
</tr>
</tbody></table>
</blockquote>

<p>
Change 20.9.5.1 [time.clock.system]:
</p>

<blockquote>
<p>
-1- Objects of class <tt>system_clock</tt> represent wall clock time from the system-wide realtime clock.
</p>

<blockquote><pre>class system_clock { 
public: 
  typedef <i>see below</i> rep; 
  typedef ratio&lt;<i>unspecified</i>, <i>unspecified</i>&gt; period; 
  typedef chrono::duration&lt;rep, period&gt; duration<ins>_type</ins>; 
  typedef chrono::time_point&lt;system_clock&gt; time_point<ins>_type</ins>; 
  static const bool is_monotonic = <i>unspecified</i> ; 

  static time_point<ins>_type</ins> now(); 

  // Map to C API 
  static time_t to_time_t (const time_point<ins>_type</ins>&amp; t); 
  static time_point<ins>_type</ins> from_time_t(time_t t); 
};
</pre></blockquote>

<p>
-2- <tt>system_clock::duration<ins>_type</ins>::min() &lt; system_clock::duration<ins>_type</ins>::zero()</tt> shall be <tt>true</tt>.
</p>

<pre>time_t to_time_t(const time_point<ins>_type</ins>&amp; t);
</pre>

<blockquote>
-3- <i>Returns:</i> A <tt>time_t</tt> object that represents the same
point in time as <tt>t</tt> when both values are truncated to the
coarser of the precisions of <tt>time_t</tt> and <tt>time_point<ins>_type</ins></tt>.
</blockquote>

<pre><tt>time_point<ins>_type</ins></tt> from_time_t(time_t t);
</pre>

<blockquote>
-4- <i>Returns:</i> A <tt>time_point<ins>_type</ins></tt> object that represents the same point
in time as <tt>t</tt> when both values are truncated to the coarser of the
precisions of <tt>time_t</tt> and <tt>time_point<ins>_type</ins></tt>.
</blockquote>
</blockquote>

<p>
Change 20.9.5.2 [time.clock.monotonic]:
</p>

<blockquote><pre>class monotonic_clock { 
public: 
  typedef <i>unspecified</i>                                rep; 
  typedef ratio&lt;<i>unspecified</i> , <i>unspecified</i>&gt;           period; 
  typedef chrono::duration&lt;rep, period&gt;              duration<ins>_type</ins>; 
  typedef chrono::time_point&lt;<i>unspecified</i> , duration<ins>_type</ins>&gt; time_point<ins>_type</ins>; 
  static const bool is_monotonic =                   true; 

  static time_point<ins>_type</ins> now();
};
</pre></blockquote>

<p>
Change 20.9.5.3 [time.clock.hires]:
</p>

<blockquote><pre>class high_resolution_clock { 
public: 
  typedef <i>unspecified</i>                                rep; 
  typedef ratio&lt;<i>unspecified</i> , <i>unspecified</i>&gt;           period; 
  typedef chrono::duration&lt;rep, period&gt;              duration<ins>_type</ins>; 
  typedef chrono::time_point&lt;<i>unspecified</i> , duration<ins>_type</ins>&gt; time_point<ins>_type</ins>; 
  static const bool is_monotonic =                   true; 

  static time_point<ins>_type</ins> now();
};
</pre></blockquote>






<hr>
<h3><a name="958"></a>958. Various threading bugs #8</h3>
<p><b>Section:</b> 30.5.1 [thread.condition.condvar] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2009-01-07  <b>Last modified:</b> 2009-10-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#thread.condition.condvar">active issues</a> in [thread.condition.condvar].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.condition.condvar">issues</a> in [thread.condition.condvar].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
30.5.1 [thread.condition.condvar]: the specification for <tt>wait_for</tt>
with no predicate has an effects clause that says it calls <tt>wait_until</tt>,
and a returns clause that sets out in words how to determine the return
value. Is this description of the return value subtly different from the
description of the value returned by <tt>wait_until</tt>? Or should the effects
clause and the returns clause be merged?
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Move to open. Associate with LWG <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#859">859</a> and any other monotonic-clock
related issues.
</blockquote>

<p><i>[
2009-08-01 Howard adds:
]</i></p>


<blockquote>
I believe that <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#859">859</a> (currently Ready) addresses this issue, and
that this issue should be marked NAD, solved by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#859">859</a> (assuming
it moves to WP).
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Mark as NAD Editorial, solved by resolution of Issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#859">859</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="961"></a>961. Various threading bugs #11</h3>
<p><b>Section:</b> 30.4.1 [thread.mutex.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Future">NAD Future</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2009-01-07  <b>Last modified:</b> 2009-10-26</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#thread.mutex.requirements">active issues</a> in [thread.mutex.requirements].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.mutex.requirements">issues</a> in [thread.mutex.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Future">NAD Future</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#936">936</a></p>
<p><b>Discussion:</b></p>
<p>
30.4.1 [thread.mutex.requirements] describes required member
functions of mutex types, and requires that they throw exceptions under
certain circumstances. This is overspecified. User-defined types can
abort on such errors without affecting the operation of templates
supplied by standard-library.
</p>

<p><i>[
Summit:
]</i></p>

<blockquote>
Move to open. Related to conceptualization and should probably be
tackled as part of that.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
<p>
Would be OK to leave it as is for time constraints, could loosen later.
</p>

<p>
Mark as NAD Future.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="969"></a>969. What happened to Library Issue 475?</h3>
<p><b>Section:</b> 25.2.4 [alg.foreach] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2009-01-12  <b>Last modified:</b> 2009-07-13</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.foreach">issues</a> in [alg.foreach].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Library Issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#475">475</a> has CD1 status, but the non-normative note in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2723.pdf">N2723</a>
was removed in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2798.pdf">N2798</a>
(25.2.4 [alg.foreach] in both drafts).
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Move to NAD Editorial.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Restore the non-normative note. It might need to be expressed in terms of concepts.
</p>





<hr>
<h3><a name="971"></a>971. Spurious diagnostic conversion function</h3>
<p><b>Section:</b> 19.5.2.5 [syserr.errcode.nonmembers] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Beman Dawes <b>Opened:</b> 2009-01-19  <b>Last modified:</b> 2009-10-20</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Anthony Williams raised the question in c++std-lib-22987 "why is there
<tt>std::make_error_code(std::errc)</tt>? What purpose does this serve?"
</p>
<p>
The function <tt>make_error_code(errc e)</tt> is not required, since
<tt>make_error_condition(errc e)</tt> is the function that is needed for <tt>errc</tt>
conversions. <tt>make_error_code(errc e)</tt> appears to be a holdover from my
initial confusion over the distinction between POSIX and operating
systems that conform to the POSIX spec.
</p>

<p><i>[
Post Summit:
]</i></p>


<blockquote>
Recommend Review.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
The designer of the facility (Christopher Kohlhoff)
strongly disagrees that there is an issue here,
and especially disagrees with the proposed resolution.
Bill would prefer to be conservative and not apply this proposed resolution.
Move to Open, and recommend strong consideration for NAD status.
</blockquote>

<p><i>[
2009-05-21 Beman adds:
]</i></p>


<blockquote>
My mistake. Christopher and Bill are correct and the issue should be
NAD. The function is needed by users.
</blockquote>

<p><i>[
2009-07-21 Christopher Kohlhoff adds rationale for <tt>make_error_code</tt>:
]</i></p>


<blockquote>
<p>
Users (and indeed library implementers) may need to use the
<tt>errc</tt> codes in portable code. For example:
</p>

<blockquote><pre>void do_foo(error_code&amp; ec)
{
#if defined(_WIN32)
  // Windows implementation ...
#elif defined(linux)
  // Linux implementation ...
#else
  // do_foo not supported on this platform
  ec = make_error_code(errc::not_supported);
#endif
}
</pre></blockquote>
</blockquote>

<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote>
Moved to NAD.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change System error support 19.5 [syserr], Header <tt>&lt;system_error&gt;</tt>
synopsis, as indicated:
</p>

<blockquote><pre><del>error_code make_error_code(errc e);</del>
error_condition make_error_condition(errc e);
</pre></blockquote>

<p>
Delete from Class error_code non-member functions
19.5.2.5 [syserr.errcode.nonmembers]:
</p>

<blockquote><pre><del>error_code make_error_code(errc e);</del>
</pre>
<blockquote>
<del><i>Returns:</i> <tt>error_code(static_cast&lt;int&gt;(e),
generic_category)</tt>.</del>
</blockquote>
</blockquote>






<hr>
<h3><a name="972"></a>972. The term "Assignable" undefined but still in use</h3>
<p><b>Section:</b> 17 [library] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Niels Dekker <b>Opened:</b> 2009-01-07  <b>Last modified:</b> 2009-07-13</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Previous versions of the Draft had a table, defining the Assignable 
requirement.  For example 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2134.pdf">N2134</a>
Table 79, "Assignable requirements". But I guess the term "Assignable" 
is outdated by now, because the current Committee Draft provides 
<tt>MoveAssignable</tt>, <tt>CopyAssignable</tt>, and <tt>TriviallyCopyAssignable</tt> concepts 
instead. And as far as I can see, it no longer has a definition of 
<tt>Assignable</tt>. (Please correct me if I'm wrong.) Still the word 
"Assignable" is used in eight places in the Draft, 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2800.pdf">N2800</a>.
</p>

<p>
Are all of those instances of "<tt>Assignable</tt>" to be replaced by "<tt>CopyAssignable</tt>"? 
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Move to NAD Editorial.
</blockquote>


<p><b>Proposed resolution:</b></p>

<p>
Change Exception Propagation 18.8.5 [propagation]:
</p>
<blockquote>
<tt>exception_ptr</tt> shall be <tt>DefaultConstructible</tt>, <tt>CopyConstructible</tt>,
<tt><ins>Copy</ins>Assignable</tt> and <tt>EqualityComparable</tt>.
</blockquote>

<p>
Change Class template reference_wrapper 20.7.5 [refwrap]:
</p>
<blockquote>
<tt>reference_wrapper&lt;T&gt;</tt> is a <tt>CopyConstructible</tt> and <tt><ins>Copy</ins>Assignable</tt> wrapper around a reference to an object of type <tt>T</tt>.
</blockquote>
<p>
Change Placeholders 20.7.11.1.4 [func.bind.place]:
</p>
<blockquote>
It is implementation defined whether placeholder types are <tt><ins>Copy</ins>Assignable</tt>. <tt><ins>Copy</ins>Assignable</tt> placeholders' copy assignment operators shall not throw exceptions.
</blockquote>
<p>
Change Class template shared_ptr 20.8.15.2 [util.smartptr.shared]:
</p>
<blockquote>
Specializations of <tt>shared_ptr</tt> shall be <tt>CopyConstructible</tt>, <tt><ins>Copy</ins>Assignable</tt>, and <tt>LessThanComparable</tt>...
</blockquote>
<p>
Change Class template weak_ptr 20.8.15.3 [util.smartptr.weak]:
</p>
<blockquote>
Specializations of <tt>weak_ptr</tt> shall be <tt>CopyConstructible</tt>, <tt><ins>Copy</ins>Assignable</tt>, and <tt>LessThanComparable</tt>...
</blockquote>
<p>
Change traits typedefs 21.2.2 [char.traits.typedefs] (note: including deletion of reference to 23.1!):
</p>
<blockquote>
<i>Requires:</i> <tt>state_type</tt> shall meet the requirements of <tt><ins>Copy</ins>Assignable</tt><del> (23.1)</del>, <tt>CopyConstructible</tt> (20.1.8), and <tt>DefaultConstructible</tt> types.
</blockquote>
<p>
Change Class seed_seq 26.5.7.1 [rand.util.seedseq] (note again: including deletion of reference to 23.1!):
</p>
<blockquote>
In addition to the requirements set forth below, instances of
<tt>seed_seq</tt> shall meet the requirements of <tt>CopyConstructible</tt> (20.1.8) and of <tt><ins>Copy</ins>Assignable</tt><del> (23.1)</del>.
</blockquote>

<p>
Note: The proposed resolution of this issue does not deal with the
instance of the term "Assignable" in D.10.1 [auto.ptr], as this is dealt
with more specifically by LWG <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#973">973</a>, "<tt>auto_ptr</tt> characteristics", submitted
by Maarten Hilferink.
</p>






<hr>
<h3><a name="973"></a>973. auto_ptr characteristics</h3>
<p><b>Section:</b> D.10.1 [auto.ptr] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Maarten Hilferink <b>Opened:</b> 2009-01-21  <b>Last modified:</b> 2009-07-13</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#auto.ptr">issues</a> in [auto.ptr].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I think that the Note of D.10.1 [auto.ptr], paragraph 3 needs a rewrite 
since "Assignable" is no longer defined as a concept. 
The relationship of <tt>auto_ptr</tt> with the new <tt>CopyAssignable</tt>, <tt>MoveAssignable</tt>,
 and <tt>MoveConstructible</tt> concepts should be clarified.
Furthermore, since the use of <tt>auto_ptr</tt> is depreciated anyway,
 we can also omit a description of its intended use.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the intent of the proposed resolution.
Move to NAD Editorial.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change D.10.1 [auto.ptr], paragraph 3:
</p>

<blockquote>
The <tt>auto_ptr</tt> provides a semantics of strict ownership. An
<tt>auto_ptr</tt> owns the ob ject it holds a pointer to. Copying an
<tt>auto_ptr</tt> copies the pointer and transfers ownership to the
destination. If more than one <tt>auto_ptr</tt> owns the same ob ject at
the same time the behavior of the program is undefined. [<i>Note:</i>
The uses of <tt>auto_ptr</tt> include providing temporary
exception-safety for dynamically allocated memory, passing ownership of
dynamically allocated memory to a function, and returning dynamically
allocated memory from a function.
<del><tt>auto_ptr</tt> does not meet the
<tt>CopyConstructible</tt> and <tt>Assignable</tt> requirements for
standard library container elements and thus instantiating a standard
library container with an <tt>auto_ptr</tt> results in undefined
behavior.</del>

<ins>Instances of <tt>auto_ptr</tt> shall
meet the <tt>MoveConstructible</tt> and <tt>MoveAssignable</tt>
requirements, but do not meet the <tt>CopyConstructible</tt> and
<tt>CopyAssignable</tt> requirements.</ins>
-- <i>end note</i>]
</blockquote>





<hr>
<h3><a name="976"></a>976. Class template std::stack should be movable</h3>
<p><b>Section:</b> 23.3.5.3.1 [stack.defn] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2009-02-01  <b>Last modified:</b> 2009-10-20</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The synopsis given in 23.3.5.3.1 [stack.defn] does not show up
</p>

<blockquote><pre>requires MoveConstructible&lt;Cont&gt; stack(stack&amp;&amp;);
requires MoveAssignable&lt;Cont&gt; stack&amp; operator=(stack&amp;&amp;);
</pre></blockquote>

<p>
although the other container adaptors do provide corresponding
members.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We agree with the proposed resolution.
</p>
<p>
Move to Tentatively Ready.
</p>
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
Moved from Tentatively Ready to Open only because the wording needs to be
tweaked for concepts removal.
</blockquote>

<p><i>[
2009-08-18 Daniel updates the wording and Howard sets to Review.
]</i></p>


<p><i>[
2009-08-23 Howard adds:
]</i></p>


<blockquote>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1194">1194</a> also adds these move members using an editorially different
style.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Mark NAD Editorial, solved by issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1194">1194</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
In the class stack synopsis of 23.3.5.3.1 [stack.defn] insert:
</p>

<blockquote><pre>template &lt;class T, class Container = deque&lt;T&gt; &gt;
class stack {
  [..]
  explicit stack(const Container&amp;);
  explicit stack(Container&amp;&amp; = Container());
  <ins>stack(stack&amp;&amp; s) : c(std::move(s.c)) {}</ins>
  <ins>stack&amp; operator=(stack&amp;&amp; s) { c = std::move(s.c); return *this; }</ins>
  [..]
};
</pre></blockquote>








<hr>
<h3><a name="977"></a>977. insert iterators inefficient for expensive to move types</h3>
<p><b>Section:</b> 24.5.2 [insert.iterators] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-02-02  <b>Last modified:</b> 2009-10-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#insert.iterators">issues</a> in [insert.iterators].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The new concepts for the insert iterators mandate an extra copy when
inserting an lvalue:
</p>

<blockquote><pre>requires CopyConstructible&lt;Cont::value_type&gt;
  back_insert_iterator&lt;Cont&gt;&amp; 
  operator=(const Cont::value_type&amp; value);
</pre>
<blockquote>
-1- <i>Effects:</i> <tt>push_back(*container, <b>Cont::value_type(</b>value<b>)</b>);</tt>
</blockquote>
</blockquote>

<p>
The reason is to convert <tt>value</tt> into an rvalue because the current
<tt>BackInsertionContainer</tt> concept only handles <tt>push_back</tt>-ing
rvalues:
</p>

<blockquote><pre>concept BackInsertionContainer&lt;typename C&gt; : Container&lt;C&gt; { 
  void push_back(C&amp;, value_type&amp;&amp;); 
}
</pre></blockquote>

<p>
Without the conversion of <tt>value</tt> to an rvalue, the assignment operator
fails to concept check.
</p>

<p>
A solution is to modify the <tt>BackInsertionContainer</tt> concept so that
the client can pass in the parameter type for <tt>push_back</tt> similar to
what is already done for the <tt>OutputIterator</tt> concept:
</p>

<blockquote><pre>concept BackInsertionContainer&lt;typename C, typename Value = C::value_type&amp;&amp;&gt;
  : Container&lt;C&gt; { 
     void push_back(C&amp;, Value); 
}
</pre></blockquote>

<p>
This allows the assignment operator to be adjusted appropriately:
</p>

<blockquote><pre>requires BackInsertionContainer&lt;Cont, Cont::value_type const&amp;&gt; &amp;&amp;
         CopyConstructible&lt;Cont::value_type&gt;
  back_insert_iterator&lt;Cont&gt;&amp; 
  operator=(const Cont::value_type&amp; value);
</pre>
<blockquote>
-1- <i>Effects:</i> <tt>push_back(*container, value);</tt>
</blockquote>
</blockquote>

<p><i>[
We may want to propagate this fix to other concepts such as <tt>StackLikeContainer</tt>.
]</i></p>


<p><i>[
Solution and wording collaborated on by Doug and Howard.
]</i></p>


<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Howard notes that "these operations behaved efficiently until concepts were added."
</p>
<p>
Alisdair is uncertain that the proposed resolution is syntactically correct.
</p>
<p>
Move to Open, and recommend the issue be deferred until after the next
Committee Draft is issued.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD, solved by the removal of concepts.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change  [container.concepts.free]:
</p>

<blockquote>
<pre>concept FrontInsertionContainer&lt;typename C<ins>, typename Value = C::value_type&amp;&amp;</ins>&gt;
    : Container&lt;C&gt; { 
  void push_front(C&amp;, <del>value_type&amp;&amp;</del> <ins>Value</ins>); 

  axiom FrontInsertion(C c, <del>value_type</del> <ins>Value</ins> x) { 
    x == (push_front(c, x), front(c)); 
  } 
}
</pre>

<p>...</p>

<pre>concept BackInsertionContainer&lt;typename C<ins>, typename Value = C::value_type&amp;&amp;</ins>&gt;
    : Container&lt;C&gt; { 
  void push_back(C&amp;, <del>value_type&amp;&amp;</del> <ins>Value</ins>); 
}
</pre>

<p>...</p>

<pre>concept InsertionContainer&lt;typename C<ins>, typename Value = C::value_type&amp;&amp;</ins>&gt;
    : Container&lt;C&gt; { 
  iterator insert(C&amp;, const_iterator, <del>value_type&amp;&amp;</del> <ins>Value</ins>); 

  axiom Insertion(C c, const_iterator position, <del>value_type</del> <ins>Value</ins> v) { 
    v == *insert(c, position, v); 
  } 
}
</pre>

</blockquote>

<p>
Change  [container.concepts.member]:
</p>

<blockquote>
<pre>auto concept MemberFrontInsertionContainer&lt;typename C<ins>, typename Value = C::value_type&amp;&amp;</ins>&gt;
    : MemberContainer&lt;C&gt; { 
  void C::push_front(<del>value_type&amp;&amp;</del> <ins>Value</ins>); 

  axiom MemberFrontInsertion(C c, <del>value_type</del> <ins>Value</ins> x) { 
    x == (c.push_front(x), c.front()); 
  } 
}
</pre>

<p>...</p>

<pre>auto concept MemberBackInsertionContainer&lt;typename C<ins>, typename Value = C::value_type&amp;&amp;</ins>&gt;
    : MemberContainer&lt;C&gt; { 
  void C::push_back(<del>value_type&amp;&amp;</del> <ins>Value</ins>); 
}
</pre>

<p>...</p>

<pre>auto concept MemberInsertionContainer&lt;typename C<ins>, typename Value = C::value_type&amp;&amp;</ins>&gt;
    : MemberContainer&lt;C&gt; { 
  iterator C::insert(const_iterator, <del>value_type&amp;&amp;</del> <ins>Value</ins>); 

  axiom MemberInsertion(C c, const_iterator position, <del>value_type</del> <ins>Value</ins> v) { 
    v == *c.insert(position, v); 
  } 
}
</pre>
</blockquote>

<p>
Change  [container.concepts.maps]:
</p>

<blockquote>
<pre>template &lt;MemberFrontInsertionContainer C<ins>, typename Value = C::value_type&amp;&amp;</ins>&gt; 
concept_map FrontInsertionContainer&lt;C<ins>, Value</ins>&gt; { 
  typedef Container&lt;C&gt;::value_type value_type;

  void push_front(C&amp; c, <del>value_type&amp;&amp;</del> <ins>Value</ins> v) { c.push_front(static_cast&lt;<del>value_type&amp;&amp;</del> <ins>Value</ins>&gt;(v)); } 
}
</pre>

<p>...</p>

<pre>template &lt;MemberBackInsertionContainer C<ins>, typename Value = C::value_type&amp;&amp;</ins>&gt; 
concept_map BackInsertionContainer&lt;C<ins>, Value</ins>&gt; { 
  typedef Container&lt;C&gt;::value_type value_type;

  void push_back(C&amp; c, <del>value_type&amp;&amp;</del> <ins>Value</ins> v) { c.push_back(static_cast&lt;<del>value_type&amp;&amp;</del> <ins>Value</ins>&gt;(v)); } 
}
</pre>

<p>...</p>

<pre>template &lt;MemberInsertionContainer C<ins>, typename Value = C::value_type&amp;&amp;</ins>&gt; 
concept_map InsertionContainer&lt;C<ins>, Value</ins>&gt; { 
  typedef Container&lt;C&gt;::value_type value_type;
  Container&lt;C&gt;::iterator insert(C&amp; c, Container&lt;C&gt;::const_iterator i, <del>value_type&amp;&amp;</del> <ins>Value</ins> v) 
  { return c.insert(i, static_cast&lt;<del>value_type&amp;&amp;</del> <ins>Value</ins>&gt;(v)); } 
}
</pre>

</blockquote>

<p>
Change 24.5.2.1 [back.insert.iterator]:
</p>

<blockquote><pre>template &lt;BackInsertionContainer Cont&gt; 
class back_insert_iterator {
  ...
  requires <ins>BackInsertionContainer&lt;Cont, const Cont::value_type&amp;&gt;</ins>
           <del>CopyConstructible&lt;Cont::value_type&gt;</del>
    back_insert_iterator&lt;Cont&gt;&amp; 
      operator=(const Cont::value_type&amp; value);
  ...
</pre></blockquote>

<p>
Change 24.5.2.2.2 [back.insert.iter.op=]:
</p>

<blockquote>
<pre>requires <ins>BackInsertionContainer&lt;Cont, const Cont::value_type&amp;&gt;</ins>
         <del>CopyConstructible&lt;Cont::value_type&gt;</del>
  back_insert_iterator&lt;Cont&gt;&amp; 
    operator=(const Cont::value_type&amp; value);
</pre>
<blockquote>
-1- <i>Effects:</i> <tt>push_back(*container, <del>Cont::value_type(</del>value<del>)</del>);</tt>
</blockquote>
</blockquote>

<p>
Change 24.5.2.3 [front.insert.iterator]:
</p>

<blockquote><pre>template &lt;FrontInsertionContainer Cont&gt; 
class front_insert_iterator {
  ...
  requires <ins>FrontInsertionContainer&lt;Cont, const Cont::value_type&amp;&gt;</ins>
           <del>CopyConstructible&lt;Cont::value_type&gt;</del>
    front_insert_iterator&lt;Cont&gt;&amp; 
      operator=(const Cont::value_type&amp; value);
  ...
</pre></blockquote>

<p>
Change 24.5.2.4.2 [front.insert.iter.op=]:
</p>

<blockquote>
<pre>requires <ins>FrontInsertionContainer&lt;Cont, const Cont::value_type&amp;&gt;</ins>
         <del>CopyConstructible&lt;Cont::value_type&gt;</del>
  front_insert_iterator&lt;Cont&gt;&amp; 
    operator=(const Cont::value_type&amp; value);
</pre>
<blockquote>
-1- <i>Effects:</i> <tt>push_front(*container, <del>Cont::value_type(</del>value<del>)</del>);</tt>
</blockquote>
</blockquote>

<p>
Change 24.5.2.5 [insert.iterator]:
</p>

<blockquote><pre>template &lt;InsertionContainer Cont&gt; 
class insert_iterator {
  ...
  requires <ins>InsertionContainer&lt;Cont, const Cont::value_type&amp;&gt;</ins>
           <del>CopyConstructible&lt;Cont::value_type&gt;</del>
    insert_iterator&lt;Cont&gt;&amp; 
      operator=(const Cont::value_type&amp; value);
  ...
</pre></blockquote>

<p>
Change 24.5.2.6.2 [insert.iter.op=]:
</p>

<blockquote>
<pre>requires <ins>InsertionContainer&lt;Cont, const Cont::value_type&amp;&gt;</ins>
         <del>CopyConstructible&lt;Cont::value_type&gt;</del>
  insert_iterator&lt;Cont&gt;&amp; 
    operator=(const Cont::value_type&amp; value);
</pre>
<blockquote>
<p>
-1- <i>Effects:</i>
</p>
<blockquote><pre>iter = insert(*container, iter, <del>Cont::value_type(</del>value<del>)</del>); 
++iter;
</pre></blockquote>
</blockquote>
</blockquote>






<hr>
<h3><a name="979"></a>979. Bad example</h3>
<p><b>Section:</b> 24.5.3 [move.iterators] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-02-03  <b>Last modified:</b> 2009-07-13</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
24.5.3 [move.iterators] has an incorrect example:
</p>

<blockquote>
<p>
-2- [<i>Example:</i>
</p>

<blockquote><pre>set&lt;string&gt; s; 
// populate the set s 
vector&lt;string&gt; v1(s.begin(), s.end());          // copies strings into v1 
vector&lt;string&gt; v2(make_move_iterator(s.begin()), 
                  make_move_iterator(s.end())); // moves strings into v2
</pre></blockquote>

<p>
<i>-- end example</i>]
</p>
</blockquote>

<p>
One can not move from a <tt>set</tt> because the iterators return <tt>const</tt>
references.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution. Move to NAD Editorial.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 24.5.3 [move.iterators]/2:
</p>

<blockquote>
<p>
-2- [<i>Example:</i>
</p>

<blockquote><pre><del>set</del><ins>list</ins>&lt;string&gt; s; 
// populate the <del>set</del><ins>list</ins> s 
vector&lt;string&gt; v1(s.begin(), s.end());          // copies strings into v1 
vector&lt;string&gt; v2(make_move_iterator(s.begin()), 
                  make_move_iterator(s.end())); // moves strings into v2
</pre></blockquote>

<p>
<i>-- end example</i>]
</p>
</blockquote>





<hr>
<h3><a name="980"></a>980. <tt>mutex lock()</tt> missing error conditions</h3>
<p><b>Section:</b> 30.4.1 [thread.mutex.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Ion Gaztaaga <b>Opened:</b> 2009-02-07  <b>Last modified:</b> 2009-03-22</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#thread.mutex.requirements">active issues</a> in [thread.mutex.requirements].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.mutex.requirements">issues</a> in [thread.mutex.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
POSIX 2008 adds two return values for <tt>pthread_mutex_xxxlock()</tt>:
<tt>EOWNERDEAD</tt> (<tt>owner_dead</tt>) and <tt>ENOTRECOVERABLE</tt>
(<tt>state_not_recoverable</tt>). In the first case the mutex is locked,
in the second case the mutex is not locked.
</p>

<p>
Throwing an exception in the first case can be incompatible with the use
of Locks, since the <tt>Lock::owns_lock()</tt> will be <tt>false</tt> when the lock is
being destroyed.
</p>

<p>
Consider:
</p>

<blockquote><pre>//Suppose mutex.lock() throws "owner_dead"
unique_lock ul(&amp;mutex);
//mutex left locked if "owner_dead" is thrown
</pre></blockquote>

<p>
Throwing an exception with <tt>owner_dead</tt> might be also undesirable if
robust-mutex support is added to C++ and the user has the equivalent of
<tt>pthread_mutex_consistent()</tt> to notify the user has fixed the corrupted
data and the mutex state should be marked consistent.
</p>

<ol>
<li>
For <tt>state_not_recoverable</tt> add it to the list of Error conditions:
</li>
<li>
For <tt>owner_dead</tt>, no proposed resolution.
</li>
</ol>

<p><i>[
Summit:
]</i></p>


<blockquote>
Not a defect. Handling these error conditions is an implementation
detail and must be handled below the C++ interface.
</blockquote>



<p><b>Proposed resolution:</b></p>

<p>
Add to 30.4.1 [thread.mutex.requirements], p12:
</p>

<blockquote>
<p>
-12- <i>Error conditions:</i>
</p>

<ul>
<li>
<tt>operation_not_permitted</tt> -- if the thread does not have the necessary permission to change 
the state of the mutex.
</li>
<li>
<tt>resource_deadlock_would_occur</tt> -- if the current thread already owns the mutex and is able 
to detect it.
</li>
<li>
<tt>device_or_resource_busy</tt> --  if the mutex is already locked and blocking is not possible.
</li>
<li>
<ins><tt>state_not_recoverable</tt> -- if the state protected by the mutex is not recoverable.</ins>
</li>
</ul>
</blockquote>





<hr>
<h3><a name="988"></a>988. <tt>Reflexivity</tt> meaningless?</h3>
<p><b>Section:</b> X [concept.comparison] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-02-24  <b>Last modified:</b> 2009-07-16</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#concept.comparison">issues</a> in [concept.comparison].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
X [concept.comparison] p2:
</p>
<p>
Due to the subtle meaning of <tt>==</tt> inside axioms, the <tt>Reflexivity</tt> axiom does
not do anything as written. It merely states that a value is substitutable
with itself, rather than asserting a property of the <tt>==</tt> operator.
</p>

<b>
Original proposed resolution:
</b>

<p>
Change the definition of <tt>Reflexivity</tt> in X [concept.comparison]:
</p>

<blockquote><pre>axiom Reflexivity(T a) { <ins>(</ins>a == a<ins>) == true</ins>; }
</pre></blockquote>

<p><i>[
Post Summit:
]</i></p>


<blockquote>
<p>
Alisdair: I was wrong.
</p>
<p>
Recommend NAD.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
NAD.
</p>





<hr>
<h3><a name="989"></a>989. late_check and library</h3>
<p><b>Section:</b> 17 [library] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-02-24  <b>Last modified:</b> 2009-07-16</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The example in 6.9p2 shows how late_check blocks inhibit concept_map lookup
inside a constrained context, and so inhibit concept map adaption by users
to meet template requirements.
</p>
<p>
Do we need some text in clause 17 prohibitting use of late_check in library
template definitions unless otherwise documented?
</p>

<p><i>[
Doug adds:
]</i></p>


<blockquote>
We need something like this, but it should be a more general statement
about implementations respecting the concept maps provided by the
user. Use of late_check is one way in which implementations can
subvert the concept maps provided by the user, but there are other
ways as well ("pattern-based" overloading, tricks with "auto" concept
maps and defaulted associated type arguments).
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Move to Open, pending proposed wording from Alisdair and/or Doug for further review.
</blockquote>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="992"></a>992. Response to UK 169</h3>
<p><b>Section:</b> 17.6.1.1 [contents] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> P.J. Plauger <b>Opened:</b> 2009-03-03  <b>Last modified:</b> 2009-07-22</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#contents">issues</a> in [contents].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses UK 169</b></p>
<p>
This phrasing contradicts later freedom to implement the C standard
library portions in the global namespace as well as std. (17.6.2.3p4)
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
The proposed wording seems to go too far.
Move back to Open.
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
<p>
Howard to add NB reference to the description of this issue.
</p>
<p>
Move to NAD. This comment is informative and not normative by the use of
the word "are" instead of the word "shall."
</p>
<p>
A note linking to Annex D would help clarify the intention, here.
</p>
<p>
Robert to Open a separate issue proposing that the standard C headers be
undeprecated, for the purpose of clarifying the standard.
</p>
</blockquote>

<p><i>[
2009-07-22 Bill modified the proposed wording with a clarifying footnote.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
Add a footnote to 17.6.1.1 [contents], p2:
</p>

<blockquote>
<p>
-2- All library entities except macros, <tt>operator new</tt> and <tt>operator
delete</tt> are defined within the namespace <tt>std</tt> or namespaces
nested within namespace <tt>std</tt><ins><sup>*</sup></ins>.
</p>

<p><ins>
<sup>*</sup>The C standard library headers D.6 [depr.c.headers] also define
names within the global namespace, while the C++ headers for
C library facilities 17.6.1.2 [headers] may also define names within
the global namespace.
</ins></p>
</blockquote>






<hr>
<h3><a name="995"></a>995. Operational Semantics Unclear</h3>
<p><b>Section:</b> 17.5.1.3 [structure.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> David Abrahams <b>Opened:</b> 2009-03-06  <b>Last modified:</b> 2009-07-13</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
As a practical matter there's disagreement on the meaning of <i>operational
semantics</i>.  If the text in 17.5.1.3 [structure.requirements]p4 isn't
clear, it should be clarified.  However, it's not clear whether the
disagreement is merely due to people not being aware of the text.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Agree with the recommended NAD resolution.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Recommend NAD.  The text in 17.5.1.3 [structure.requirements] is
perfectly clear.
</p>





<hr>
<h3><a name="1000"></a>1000. adjacent_find is over-constrained</h3>
<p><b>Section:</b> 25.2.8 [alg.adjacent.find] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Concepts">NAD Concepts</a>
 <b>Submitter:</b> Chris Jefferson <b>Opened:</b> 2009-03-09  <b>Last modified:</b> 2009-07-15</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.adjacent.find">issues</a> in [alg.adjacent.find].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<b>Addresses UK 296</b>
</p>

<p>
<tt>adjacent_find</tt> in C++03 allows an arbitrary predicate, but in C++0x
<tt>EqualityComparable/EquivalenceRelation</tt> is required. This forbids a
number of use cases, including:
</p>
<blockquote>
<table>
<tbody><tr>
<td valign="top">
<tt>adjacent_find(begin,&nbsp;end,&nbsp;less&lt;double&gt;)</tt>
</td>
<td>
Find the first
place where a range is not ordered in decreasing order - in use to check
for sorted ranges.
</td>
</tr>
<tr>
<td valign="top">
<tt>adjacent_find(begin,&nbsp;end,&nbsp;DistanceBiggerThan(6)&nbsp;)&nbsp;)</tt>
</td>
<td>
Find the first
place in a range where values differ by more than a given value - in use
to check an algorithm which produces points in space does not generate
points too far apart.
</td>
</tr>
</tbody></table>
</blockquote>

<p>
A number of books use predicate which are not equivalence relations in
examples, including "Thinking in C++" and "C++ Primer".
</p>

<p>
Adding the requirement that the predicate is an <tt>EquivalenceRelation</tt>
does not appear to open up any possibility for a more optimised algorithm.
</p>



<p><b>Proposed resolution:</b></p>
<p>
Change the definition of adjacent_find in the synopsis of 25 [algorithms]
and 25.2.8 [alg.adjacent.find] to:
</p>

<blockquote><pre>template&lt;ForwardIterator Iter&gt; 
  requires <del>EqualityComparable</del><ins>HasEqualTo</ins>&lt;Iter::value_type<ins>, Iter::value_type</ins>&gt;
  Iter adjacent_find(Iter first, Iter last);

template&lt;ForwardIterator Iter, <del>EquivalenceRelation</del><ins>Predicate</ins>&lt;auto, Iter::value_type<ins>, Iter::value_type</ins>&gt; Pred&gt; 
  requires CopyConstructible&lt;Pred&gt; 
  Iter adjacent_find(Iter first, Iter last, Pred pred);
</pre></blockquote>





<hr>
<h3><a name="1001"></a>1001. Pointers, concepts and headers</h3>
<p><b>Section:</b> 17 [library] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-10  <b>Last modified:</b> 2009-07-18</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 78</b></p>

<p>
Related to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1063">1063</a>.
</p>

<p>
This is effectively an extension of LWG issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#343">343</a>.
</p>
<p>
We know there is an increasing trend (encouraged by conformance testers and
some users) that each library header should supply no more than required to
satisfy the synopsis in the standard.  This is typically achieved by
breaking larger headers into smaller subsets, and judicious use of forward
declarations.
</p>
<p>
If we apply this policy to C++0x (per
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2800.pdf">N2800</a>)
it will be very surprising for
people using library algorithms over ranges defined by pointers that they
must <tt>#include &lt;iterator_concepts&gt;</tt> for their code to compile again.  That is
because pointers do not satisfy any of the iterator concepts without the
<tt>concept_map</tt> supplied in this header.
</p>
<p>
Therefore, I suggest we should require all library headers that make use of
iterator concepts are specifically required to <tt>#include &lt;iterator_concepts&gt;</tt>.
</p>
<p>
At a minimum, the list of headers would be: (assuming all are constrained by
concepts)
</p>
<blockquote><pre>algorithm
array
deque
forward_list
initializer_list
iterator
locale
list
map
memory          // if <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1029">1029</a> is adopted
memory_concepts
numeric
random
regex
set
string
tuple
unordered_map
unordered_set
utility
vector
</pre></blockquote>

<p><i>[
Ganesh adds:
]</i></p>


<blockquote>
<p>
The same problems exists for <tt>&lt;memory_concepts&gt;</tt> and
<tt>&lt;container_concepts&gt;</tt>.
</p>
<p>
In order to compile <tt>&lt;vector&gt;</tt> you just need the
definitions of the concepts in <tt>&lt;memory_concepts&gt;</tt>, the
concept maps defined there are not necessary. Yet, from the user point
of view, if the concept map template for <tt>AllocatableElement</tt> are
not in scope, <tt>&lt;vector&gt;</tt> is pretty useless. Same for
<tt>&lt;tuple&gt;</tt> and <tt>ConstructibleWithAllocator</tt>.
</p>
<p>
Similarly, <tt>&lt;queue&gt;</tt> is not very useful if the concept map
template for <tt>QueueLikeContainer</tt> is not in scope, although the
definition of concept alone is theoretically sufficient.
</p>
<p>
There's a pattern here: if a concept has concept maps "attached", they
should never be separated.
</p>
</blockquote>

<p><i>[
Beman provided the proposed resolution for the May 2009 mailing. He 
comments:
]</i></p>


<blockquote>

<p>Initially I tried to specify exactly what header should include what other 
headers. This was verbose, error prone, hard to maintain, and appeared to add 
little value compared to just stating the general rule.</p>

</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Pete believes the proposed wording overconstrains implementers.
Instead of specifying the mechanism,
he prefers a solution that spells out what needs to be declared,
rather than how those declarations are to be provided,
e.g.,
</p>
<blockquote>
A C++ header shall provide the names
that are required to be defined in that header.
</blockquote>
<p>
Bill suggests approaching the wording from a programmer's perspective.
We may want to consider promising that certain widely-used headers
(e.g., the concept headers) are included when needed by other headers.
He feels, however, there is nothing broken now,
although we may want to consider "something nicer."
</p>
<p>
Move to Open status.
</p>

</blockquote>

<p><i>[
2009-06-16 Beman updated the proposed resolution:
]</i></p>


<blockquote>
  <ul>
    <li>The mechanism is no longer specified, as requested in Batavia.</li>
    <li>The footnote has been removed since it specified mechanism and also did 
    not reflect existing practice.</li>
    <li>A sentence was added that makes it clear that the existing practice is 
    permitted.</li>
  </ul>
</blockquote>

<p><i>[
2009-07-15 Beman updated the proposed resolution:
]</i></p>


<p><i>[
2009-07-17 Beman updated the proposed resolution based on feedback from the LWG in Frankfurt:
]</i></p>


<blockquote>
<ul>
<li>Strike two pieces of text considered unnecessary.</li>
<li>Change "definitions" to "declarations and definitions" in two places.</li>
<li>Wording tightened slightly.</li>
</ul>
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
<p>
Revised Proposed Resolution:
</p>
<p>
A C++ header may include other C++ headers. A C++ header shall provide
the declarations and definitions that appear in its synopsis (3.2
[basic.def.odr]). A C++ header shown in its synopsis as including other
C++ headers shall provide the declarations and definitions that appear
in the synopses of those other headers.
</p>
<p>
Alisdair: Does this address the BSI comment?
</p>
<p>
Beman: There were several overlapping comments. I tried to handle them
all with one resolution.
</p>
<p>
Alisdair: I'd prefer to see this closed as NAD and have this resolution
be the subject of some other, new issue.
</p>
<p>
Move to NAD Concepts. Howard to open a new issue (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1178">1178</a>) in Ready state with the
Proposed Resolution above. Beman will write up a discussion for the new
issue.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p><i>Change 17.6.4.2 [res.on.headers], Headers, paragraph 1, as indicated:</i></p>

<blockquote>

<p>
A C++ header may include other C++
headers.<del><sup>[footnote]</sup></del> <ins>A C++ header shall provide
the declarations and definitions that appear in its synopsis
(3.2 [basic.def.odr]). A C++ header shown in its synopsis as including 
other C++ headers shall provide the same declarations and definitions as
if those other headers were included.</ins>
</p>

  <p><del><sup>[footnote]</sup> C++ headers must include a C++ header that contains 
  any needed definition (3.2).</del></p>
</blockquote>






<hr>
<h3><a name="1002"></a>1002. Response to UK 170</h3>
<p><b>Section:</b> 17.6.1.2 [headers] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11  <b>Last modified:</b> 2009-07-15</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#headers">issues</a> in [headers].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 170</b></p>

<p>
One of goals of C++0x is to make language easier to teach and for
'incidental' programmers. The fine-grained headers of the C++ library
are valuable in large scale systems for managing dependencies and
optimising build times, but overcomplicated for simple development and
tutorials. Add additional headers to support the whole library through a
single include statement.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We do not all agree that this is an issue,
but we agree that if it needs solving this is the right way to do it.
Move to Tentatively Ready.
</blockquote>

<p><i>[
2009-07-06 Beman notes:
]</i></p>


<blockquote>
<p>
This issue
adds a header <tt>&lt;std&gt;</tt>.
</p>
<p>
There is a paper to be looked at,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2905.pdf">N2905</a>
Aggregation headers, that adds
a header <tt>&lt;std-all&gt;</tt> that is the same thing except it excludes
deprecated headers.
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2905.pdf">N2905</a>
also proposes a second aggregation header.
</p>
<p>
Seems like this issue should be held in abeyance until the LWG has had
a chance to look at <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2905.pdf">N2905</a>.
</p>
</blockquote>

<p><i>[
2009-07-06 Howard:  I've pulled this issue back to Review.
]</i></p>


<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
No consensus for change.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Insert a new paragraph in 17.6.1.2 [headers] between p4 and p5
</p>
<blockquote>
An additional header <tt>&lt;std&gt;</tt> shall have the effect of
supplying the entire standard library.  [<i>Note:</i> for example, it
might be implemented as a file with an <tt>#include</tt> statement for each of the
headers listed in tables 13 and 14. <i>-- end note</i>]
</blockquote>





<hr>
<h3><a name="1003"></a>1003. Response to JP 23</h3>
<p><b>Section:</b> 17.6.1.3 [compliance] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11  <b>Last modified:</b> 2009-07-18</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#compliance">issues</a> in [compliance].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses JP 23</b></p>

<p>
There is a freestanding implementation including
<tt>&lt;type_traits&gt;</tt>, <tt>&lt;array&gt;</tt>,
<tt>&lt;ratio&gt;</tt>, lately added to Table 13, C++ library headers.
Programmers think them useful and hope that these headers are also added
to Table 15, C++ headers for freestanding implementations, that shows
the set of headers which a freestanding implementation shall include at
least.
</p>

<p><b>Original proposed resolution</b></p>

<p>
Add <tt>&lt;type_traits&gt;</tt>, <tt>&lt;array&gt;</tt>,
<tt>&lt;ratio&gt;</tt> to Table 15.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
<p>
 The <tt>&lt;array&gt;</tt> header has far too many dependencies to require for a
free-standing implementation.
</p>
<p>
The <tt>&lt;ratio&gt;</tt> header would be useful, has no dependencies, but is not
strictly necessary.
</p>
<p>
The <tt>&lt;type_traits&gt;</tt> header is fundamentally a core language facility with a
library interface, so should be supported.
</p>

<p>
(it is anticipated the resolution will come via an update to paper
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2814.pdf">N2814</a>)
(see also LWG <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#833">833</a>)
</p>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Leave in Review status pending a paper on freestanding implementations
by Martin Tasker.
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
<p>
Move this to NAD.
</p>
<p>
We considered all of the listed headers, and found a compelling case
only for the inclusion of <tt>&lt;type_traits&gt;</tt> in the list of headers required
of a freestanding implementation.
</p>
<p>
See Martin Tasker's paper 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2932.pdf">Fixing Freestanding</a>
which provides the wording to include <tt>&lt;type_traits&gt;</tt> into freestanding
implementations.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add <tt>&lt;type_traits&gt;</tt> to Table 15.
</p>






<hr>
<h3><a name="1005"></a>1005. <tt>numeric_limits</tt> partial specializations not concept enabled</h3>
<p><b>Section:</b> 18.3.1.1 [numeric.limits] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11  <b>Last modified:</b> 2009-07-15</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses JP 26</b></p>

<p>
<tt>numeric_limits</tt> [partial specializations] does not use concept.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Alisdair will provide a soltion as part of treatment of axioms and LWG <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#902">902</a>.
</blockquote>

<p><i>[
Post Summit:
]</i></p>


<blockquote>
Alisdair recommends NAD as the partial specializations are already
constrained by requirements on the primary template.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
The Working Draft does not in general repeat a primary template's constraints
in any specializations.
Move to NAD.
</blockquote>

<p><i>[
2009-05-25 Howard adds:
]</i></p>


<blockquote>
A c++std-lib thread starting at c++std-lib-23880 has cast doubt that NAD is the
correct resolution of this issue.  Indeed the discussion also casts doubt that
the current proposed wording is the correct resolution as well.  Personally I'm
inclined to reset the status to Open.  However I'm reverting the status to 
that which it had prior to the Batavia recommendation.  I'm setting back to Review.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 18.3.1.1 [numeric.limits]:
</p>

<blockquote><pre>template&lt;<del>class</del> <ins>Regular</ins> T&gt; class numeric_limits&lt;const T&gt;;
template&lt;<del>class</del> <ins>Regular</ins> T&gt; class numeric_limits&lt;volatile T&gt;;
template&lt;<del>class</del> <ins>Regular</ins> T&gt; class numeric_limits&lt;const volatile T&gt;;
</pre></blockquote>






<hr>
<h3><a name="1007"></a>1007. <tt>throw_with_nested</tt> not concept enabled</h3>
<p><b>Section:</b> 18.8.6 [except.nested] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11  <b>Last modified:</b> 2009-07-15</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#except.nested">active issues</a> in [except.nested].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#except.nested">issues</a> in [except.nested].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses JP 29</b></p>

<p>
<tt>throw_with_nested</tt> does not use concept.
</p>

<p><i>[
Summit:
]</i></p>

 
<blockquote>
Agreed.
</blockquote>



<p><b>Proposed resolution:</b></p>

<p>
Alisdair initially proposed wording in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2619.pdf">N2619</a>.
</p>
<p>
We are awaiting an updated paper based on feedback from the San Francisco
review.
</p>





<hr>
<h3><a name="1009"></a>1009. <tt>InputIterator</tt> post-increment dangerous</h3>
<p><b>Section:</b> X [iterator.iterators] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11  <b>Last modified:</b> 2009-10-22</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 251</b></p>

<p>
The post-increment operator is dangerous for a general InputIterator.
The multi-pass guarantees that make it meaningful are defined as part of
the ForwardIterator refinement. Any change will affect only constrained
templates that have not yet been written, so should not break existing
user iterators which remain free to add these operations. This change
will also affect the generalised OutputIterator, although there is no
percieved need for the post-increment operator in this case either.
</p>

<p><i>[
2009-07-28 Alisdair adds:
]</i></p>


<blockquote>
We still think the issue is relevant, but needs totally rewording in
non-concept language.  We would like to see the issue retained as Open,
rather than deferred as NAD Concepts.  Review status is no longer
appropriate.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD.  Without concepts we do not feel that input iterator post increment
is broken.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change X [iterator.iterators]:
</p>

<blockquote><pre>concept Iterator&lt;typename X&gt; : Semiregular&lt;X&gt; { 
  MoveConstructible reference = typename X::reference; 
  <del>MoveConstructible postincrement_result;</del>

  <del>requires HasDereference&lt;postincrement_result&gt;;</del>

  reference operator*(X&amp;&amp;); 
  X&amp; operator++(X&amp;); 
  <del>postincrement_result operator++(X&amp;, int);</del>
}
</pre>

<p>...</p>
<pre><del>postincrement_result operator++(X&amp; r, int);</del>
</pre>

<blockquote>
<del>-3- <i>Effects:</i> equivalent to <tt>{ X tmp = r; ++r; return tmp; }</tt>.</del>
</blockquote>

</blockquote>

<p>
Change 24.2.1 [input.iterators]:
</p>

<blockquote>
<pre>concept InputIterator&lt;typename X&gt; : Iterator&lt;X&gt;, EqualityComparable&lt;X&gt; { 
  ObjectType value_type = typename X::value_type; 
  MoveConstructible pointer = typename X::pointer; 

  SignedIntegralLike difference_type = typename X::difference_type; 

  requires IntegralType&lt;difference_type&gt; 
        &amp;&amp; Convertible&lt;reference, const value_type &amp;&gt;; 
        &amp;&amp; Convertible&lt;pointer, const value_type*&gt;; 

  <del>requires Convertible&lt;HasDereference&lt;postincrement_result&gt;::result_type, const value_type&amp;&gt;;</del>

  pointer operator-&gt;(const X&amp;); 
}
</pre>
</blockquote>

<p>
Change 24.2.2 [output.iterators]:
</p>

<blockquote>
<pre>auto concept OutputIterator&lt;typename X, typename Value&gt; { 
  requires Iterator&lt;X&gt;; 

  typename reference = Iterator&lt;X&gt;::reference; 
  <del>typename postincrement_result = Iterator&lt;X&gt;::postincrement_result;</del>
  requires SameType&lt;reference, Iterator&lt;X&gt;::reference&gt; 
        <del>&amp;&amp; SameType&lt;postincrement_result, Iterator&lt;X&gt;::postincrement_result&gt;</del>
        <del>&amp;&amp; Convertible&lt;postincrement_result, const X&amp;&gt;</del>
        &amp;&amp; HasAssign&lt;reference, Value&gt; 
        <del>&amp;&amp; HasAssign&lt;HasDereference&lt;postincrement_result&gt;::result_type, Value&gt;</del>;
}
</pre>
</blockquote>

<p>
Change 24.2.3 [forward.iterators]:
</p>

<p><i>[
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1084">1084</a> which is attempting to change this same area in a compatible
way.
]</i></p>


<blockquote>
<pre>concept ForwardIterator&lt;typename X&gt; : InputIterator&lt;X&gt;, Regular&lt;X&gt; { 
  <del>requires Convertible&lt;postincrement_result, const X&amp;&gt;;</del>

  <ins>MoveConstructible postincrement_result;</ins>
  <ins>requires HasDereference&lt;postincrement_result&gt;
        &amp;&amp; Convertible&lt;HasDereference&lt;postincrement_result&gt;::result_type, const value_type&amp;&gt;;</ins>

  <ins>postincrement_result operator++(X&amp;, int);</ins>

  axiom MultiPass(X a, X b) { 
    if (a == b) *a == *b; 
    if (a == b) ++a == ++b; 
  } 
}
</pre>

<blockquote>
<p>-4- ...</p>
</blockquote>

<pre><ins>postincrement_result operator++(X&amp; r, int);</ins>
</pre>

<blockquote>
<p>
<ins>-5- <i>Effects:</i> equivalent to <tt>{ X tmp = r; ++r; return tmp; }</tt>.</ins>
</p>
</blockquote>

</blockquote>






<hr>
<h3><a name="1010"></a>1010. <tt>operator-=</tt> should use default in concept</h3>
<p><b>Section:</b> 24.2.5 [random.access.iterators] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11  <b>Last modified:</b> 2009-07-16</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#random.access.iterators">issues</a> in [random.access.iterators].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 263</b></p>

<p>
This requirement on <tt>operator-=</tt> would be better expressed as a default
implementation in the concept, with a matching axiom.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
The proposed resolution should also remove
paragraph 5 and the declaration that precedes it.
Further, we should provide an axiom
that captures the desired semantics.
This may be a broader policy to be applied.
Move to Open.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 24.2.5 [random.access.iterators]:
</p>

<blockquote><pre>concept RandomAccessIterator&lt;typename X&gt; : BidirectionalIterator&lt;X&gt;, LessThanComparable&lt;X&gt; {
  ...
  X&amp; operator-=(X&amp; <ins>x</ins>, difference_type <ins>n</ins>)<ins> { return x += -n</ins>;<ins> }</ins>
  ...
}
</pre></blockquote>






<hr>
<h3><a name="1013"></a>1013. Response to UK 305</h3>
<p><b>Section:</b> 25.4.7 [alg.min.max] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11  <b>Last modified:</b> 2009-07-16</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.min.max">issues</a> in [alg.min.max].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 305</b></p>

<p>
The negative requirement on <tt>IsSameType</tt> is a hold-over from an earlier
draught with a variadic template form of <tt>min/max</tt> algorith. It is no
longer necessary.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution.
Move to Tentatively Ready.
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
We believe this is NAD, but this needs to be reviewed against the
post-remove-concepts draft.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 25 [algorithms]:
</p>

<blockquote><pre>template&lt;class T, StrictWeakOrder&lt;auto, T&gt; Compare&gt;
  <del>requires !SameType&lt;T, Compare&gt; &amp;&amp; CopyConstructible&lt;Compare&gt;</del>
  const T&amp; min(const T&amp; a, const T&amp; b, Compare comp);
...
template&lt;class T, StrictWeakOrder&lt;auto, T&gt; Compare&gt;
  <del>requires !SameType&lt;T, Compare&gt; &amp;&amp; CopyConstructible&lt;Compare&gt;</del>
  const T&amp; max(const T&amp; a, const T&amp; b, Compare comp);
...
template&lt;class T, StrictWeakOrder&lt;auto, T&gt; Compare&gt;
  <del>requires !SameType&lt;T, Compare&gt; &amp;&amp; CopyConstructible&lt;Compare&gt;</del>
  pair&lt;const T&amp;, const T&amp;&gt; minmax(const T&amp; a, const T&amp; b, Compare comp);
</pre></blockquote>

<p>
Change 25.4.7 [alg.min.max], p1, p9 and p17:
</p>

<blockquote><pre>template&lt;class T, StrictWeakOrder&lt;auto, T&gt; Compare&gt;
  <del>requires !SameType&lt;T, Compare&gt; &amp;&amp; CopyConstructible&lt;Compare&gt;</del>
  const T&amp; min(const T&amp; a, const T&amp; b, Compare comp);
...
template&lt;class T, StrictWeakOrder&lt;auto, T&gt; Compare&gt;
  <del>requires !SameType&lt;T, Compare&gt; &amp;&amp; CopyConstructible&lt;Compare&gt;</del>
  const T&amp; max(const T&amp; a, const T&amp; b, Compare comp);
...
template&lt;class T, StrictWeakOrder&lt;auto, T&gt; Compare&gt;
  <del>requires !SameType&lt;T, Compare&gt; &amp;&amp; CopyConstructible&lt;Compare&gt;</del>
  pair&lt;const T&amp;, const T&amp;&gt; minmax(const T&amp; a, const T&amp; b, Compare comp);
</pre></blockquote>






<hr>
<h3><a name="1015"></a>1015. Response to UK 199</h3>
<p><b>Section:</b> X [concept.transform] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11  <b>Last modified:</b> 2009-07-15</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#concept.transform">issues</a> in [concept.transform].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 199</b></p>

<p>
The requirement that programs do not supply <tt>concept_maps</tt> should
probably be users do not supply their own <tt>concept_map</tt>
specializations. The program will almost certainly supply
<tt>concept_maps</tt> - the standard itself supplies a specialization
for <tt>RvalueOf</tt> references. Note that the term <i>program</i> is
defined in 3.5 [basic.link]p1 and makes no account of the
standard library being treated differently to user written code.
</p>

<p><i>[
2009-05-09 Alisdair adds:
]</i></p>


<blockquote>
<p>
The same problem is present in the words added for the
<tt>LvalueReference/RvalueReference</tt> concepts last meeting.
</p>
<p>
With three subsections requiring the same constraint, I'm wondering if there
is a better way to organise this section.
Possible 20.2.1 -&gt; 20.2.3 belong in the fundamental concepts clause in
 [concept.support]?  While they can be implemented purely as a
library feature without additional compiler support, they are pretty
fundamental and we want the same restriction on user-concept maps as is
mandated there.
</p>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the issue,
but believe the wording needs further improvement.
We want to investigate current definitions for nomenclature such as
"user" and "program."
Move to Open pending the recommended investigation.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change X [concept.transform] p2:
</p>

<blockquote>
-2- A <del>program</del> <ins>user</ins> shall not provide concept maps for
any concept in 20.1.1.
</blockquote>

<p>
Change  [concept.true] p2:
</p>

<blockquote>
-2- <i>Requires:</i> a <del>program</del> <ins>user</ins> shall not
provide a concept map for the <tt>True</tt> concept.
</blockquote>

<p>
Change  [concept.classify] p2:
</p>

<blockquote>
-2- <i>Requires:</i> a <del>program</del><ins>user</ins> shall not provide concept
maps for any concept in this section.
</blockquote>






<hr>
<h3><a name="1016"></a>1016. Response to JP 33</h3>
<p><b>Section:</b> X [concept.comparison] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11  <b>Last modified:</b> 2009-07-15</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#concept.comparison">issues</a> in [concept.comparison].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses JP 33</b></p>

<p>
<tt>LessThanComparable</tt> and <tt>EqualityComparable</tt> don't correspond to NaN. 
</p>

<p><b>Original proposed resolution:</b></p>

<p>
Apply <tt>concept_map</tt> to these concepts at <tt>FloatingPointType</tt>.
</p>

<p><i>[
Post Summit, Alisdair adds:
]</i></p>


<blockquote>
<p>
I don't understand the proposed resolution - there is no such thing as a
'negative' concept_map, and these concepts are auto concepts that match
float/double etc. Also not clear how we are supposed to match values to
concepts.
</p>
<p>
Recommend NAD and treat as a subset of issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#902">902</a>.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Recommend NAD.
</p>





<hr>
<h3><a name="1017"></a>1017. Response to US 66</h3>
<p><b>Section:</b> X [concept.regular] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11  <b>Last modified:</b> 2009-07-15</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses US 66</b></p>

<p>
Application of the <tt>Regular</tt> concept to floating-point types appears to be
controversial (see long discussion on std-lib reflector). 
</p>

<p><b>Original proposed resolution:</b></p>

<p>
State that the <tt>Regular</tt> concept does not apply to floating-point types. 
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
<p>
Recommend that we handle the same as JP 33 / <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1016">1016</a>.
</p>
</blockquote>

<p><i>[
Post Summit, Alisdair adds:
]</i></p>


<blockquote>
<p>
Recommend Open, and review after resolution of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#902">902</a> and revised axiom
feature.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1018"></a>1018. Response to US 70</h3>
<p><b>Section:</b> 20.6 [meta] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11  <b>Last modified:</b> 2009-07-15</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#meta">issues</a> in [meta].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses US 70</b></p>

<p>
Specifications now expressed via narrative text are more accurately and
clearly expressed via executable code.
</p>
<p>
Wherever concepts are available that directly match this section's type
traits, express the traits in terms of the concepts instead of via
narrative text. Where the type traits do not quite match the
corresponding concepts, bring the two into alignment so as to avoid two
nearly-identical notions.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
<p>
We think that this is a good idea, but it requires a lot of work. If someone
submits a paper proposing specific changes, we would be happy to review it
at the next meeting.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1020"></a>1020. Response to UK 204</h3>
<p><b>Section:</b> 20.6.7 [meta.trans.other] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11  <b>Last modified:</b> 2009-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#meta.trans.other">issues</a> in [meta.trans.other].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 204</b></p>

<p>
It is not possible to create a variant union based on a parameter pack
expansion, e.g. to implement a classic discriminated union template. 
</p>

<p><b>Original proposed resolutuion:</b></p>

<p>
Restore <tt>aligned_union</tt> template that was removed by LWG issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#856">856</a>. 
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Agree. The need for <tt>aligned_union</tt> is compelling enough to reinstate.
</blockquote>

<p><i>[
Post Summit, Alisdair adds:
]</i></p>


<blockquote>
paper
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2843.html">N2843</a>
proposes an extension to the <tt>[[align]]</tt> attribute
that further diminishes the need for this template.  Recommend NAD.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Mark NAD as suggested.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1022"></a>1022. Response to UK 212</h3>
<p><b>Section:</b> 20.8.15.6 [util.dynamic.safety] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11  <b>Last modified:</b> 2009-03-12</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#util.dynamic.safety">issues</a> in [util.dynamic.safety].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 212</b></p>

<p>
The pointer-safety API is nothing to do with smart pointers, so does not
belong in 20.8.15 [util.smartptr]. In fact it is a set of language
support features are really belongs in clause 18 [language.support], with the contents declared in a header that
deals with language-support of memory management.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Agree in principle, but not with the proposed resolution. We believe it
belongs either a subsection of either 20 [utilities] or 20.8 [memory]
as part of the general reorganization of 20 [utilities]. The
declaration should stay in
<tt>&lt;memory&gt;</tt>.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1023"></a>1023. Response to DE 22</h3>
<p><b>Section:</b> 20.7.15.2 [func.wrap.func] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11  <b>Last modified:</b> 2009-07-13</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#func.wrap.func">issues</a> in [func.wrap.func].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses DE 22</b></p>

<p>Related to issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1114">1114</a>.</p>

<p>
The conditions for deriving from <tt>std::unary_function</tt> and
<tt>std::binary_function</tt> are unclear: The condition would also be satisfied if
<tt>ArgTypes</tt> were <tt>std::vector&lt;T1&gt;</tt>, because it (arguably)
"contains" <tt>T1</tt>.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Agree. <tt>std::reference_wrapper</tt> has the same structure, and we
suggest that <tt>std::function</tt> be presented in the same way as
<tt>std::reference_wrapper</tt>.
</blockquote>

<p><i>[
2009-05-09 Alisdair adds:
]</i></p>


<blockquote>
Phrasing should be "publicly and
unambiguously derived from" and probably back in reference_wrapper too.  Updated
wording supplied.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed wording.
Move to NAD Editorial.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
(no changes to <tt>&lt;functional&gt;</tt> synopsis required)
</p>

<p>
Change synopsis in Class template function 20.7.15.2 [func.wrap.func]:
</p>

<blockquote><pre>template&lt;Returnable R, CopyConstructible... ArgTypes&gt; 
class function&lt;R(ArgTypes...)&gt; 
  : public unary_function&lt;T1, R&gt;      // <del><i>iff</i> sizeof...(ArgTypes) == 1 <i>and</i></del> <ins><i>see below</i></ins>
                                      <del>// ArgTypes <i>contains</i> T1</del>
  : public binary_function&lt;T1, T2, R&gt; // <del><i>iff</i> sizeof...(ArgTypes) == 2 <i>and</i></del> <ins><i>see below</i></ins>
                                      <del>// ArgTypes <i>contains</i> T1 <i>and</i> T2</del>
{
   ...
</pre></blockquote>

<p>
Add new p1/p2 before 20.7.15.2.1 [func.wrap.func.con]:
</p>

<blockquote>
<p><ins>
The template instantiation <tt>function&lt;R(T1)&gt;</tt> shall be publicly and
unambiguously derived from 
<tt>std::unary_function&lt;T1,R&gt;</tt> if and only if the template type parameter
is a function type taking one argument of type <tt>T1</tt> and returning <tt>R</tt>.
</ins></p>

<p><ins>
The template instantiation <tt>function&lt;R(T1,T2)&gt;</tt> shall be publicly and
unambiguously derived from 
<tt>std::binary_function&lt;T1,T2,R&gt;</tt> if and only if the template type
parameter is a function type taking two arguments of type <tt>T1</tt> and <tt>T2</tt> and
returning <tt>R</tt>.
</ins></p>

<pre>explicit function();
</pre>
</blockquote>






<hr>
<h3><a name="1024"></a>1024. Response to JP 39</h3>
<p><b>Section:</b> 20.7.15.2 [func.wrap.func] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11  <b>Last modified:</b> 2009-07-16</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#func.wrap.func">issues</a> in [func.wrap.func].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses JP 39</b></p>

<p>
There are no requires corresponding to <tt>F</tt> of <tt>std::function</tt>.
</p>

<p><i>[
2009-05-01 Daniel adds:
]</i></p>


<blockquote>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1070">1070</a> removes the second constructor.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution.
Move to Tentatively Ready.
If issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1070">1070</a> is accepted,
the changes to the second constructor
in this issue are moot.
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
Constructors have no definition.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Correct as follows in 20.7.15.2 [func.wrap.func] (class definition)
</p>

<blockquote><pre> template&lt;class F, Allocator Alloc&gt;
   <ins>requires ConstructibleWithAllocator&lt;F, Alloc&gt;
     &amp;&amp; call=Callable&lt;F, ArgTypes...&gt;
     &amp;&amp; Convertible&lt;call::result_type, R&gt;</ins>
   function(allocator_arg_t, const Alloc&amp;, F);
 template&lt;class F, Allocator Alloc&gt;
   <ins>requires ConstructibleWithAllocator&lt;F,Alloc&gt;
     &amp;&amp; call=Callable&lt;F, ArgTypes...&gt;
     &amp;&amp; Convertible&lt;call::result_type, R&gt;</ins>
   function(allocator_arg_t, const Alloc&amp;, F&amp;&amp;);
</pre></blockquote>






<hr>
<h3><a name="1025"></a>1025. Response to UK 208</h3>
<p><b>Section:</b> 20.7.16 [unord.hash] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Future">NAD Future</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11  <b>Last modified:</b> 2009-03-12</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#unord.hash">active issues</a> in [unord.hash].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#unord.hash">issues</a> in [unord.hash].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Future">NAD Future</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 208</b></p>

<p>
<tt>std::hash</tt> should be implemented for much more of the standard
library. In particular for <tt>pair</tt>, <tt>tuple</tt> and all the
standard containers.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1026"></a>1026. Response to UK 209</h3>
<p><b>Section:</b> 20.8 [memory] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11  <b>Last modified:</b> 2009-07-15</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#memory">issues</a> in [memory].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 209</b></p>

<p>
Smart pointers cannot be used in constrained templates.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
We look forward to a paper on this topic. We recommend no action until a
paper is available. We understand that a paper is forthcoming.
</blockquote>

<p><i>[
Peter Dimov adds:
]</i></p>


<blockquote>
<tt>shared_ptr&lt;T&gt;</tt> and <tt>weak_ptr&lt;T&gt;</tt> support all
types <tt>T</tt> for which <tt>T*</tt> is valid. In other words, a
possible (partial) resolution is to change class <tt>T</tt> to
<tt>PointeeType T</tt> for <tt>shared_ptr</tt>, <tt>weak_ptr</tt> and
possibly <tt>enable_shared_from_this</tt>.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1027"></a>1027. Response to UK 213</h3>
<p><b>Section:</b> 20.8.8 [default.allocator] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11  <b>Last modified:</b> 2009-07-15</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 213</b></p>

<p>
<tt>std::allocator</tt> should be constrained to simplify its use on constrained
contexts. This library component models allocation from free store via the
new operator so choose constraints to 
match. The Allocator concept allows for a wider variety of allocators that
users may choose to supply if their allocation model does not require
operator new, without impacting the 
requirements of this template. 
</p>

<p>
Suggested direction:
</p>
<p>
The primary allocator template should be constrained to require
<tt>ObjectType&lt;T&gt;</tt> and <tt>FreeStoreAllocatable&lt;T&gt;</tt>.
Further operations to be constrained as required.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Agree as stated. A future paper will address additional related issues.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1028"></a>1028. Response to UK 214</h3>
<p><b>Section:</b> 20.8.10 [storage.iterator] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11  <b>Last modified:</b> 2009-07-16</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 214</b></p>

<p>
<tt>raw_storage_iterator</tt> needs constraining as an iterator adaptor to be safely
used in constrained templates 
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
We look forward to a paper on this topic. We recommend no action until a
paper is available.
</blockquote>

<p><i>[
Post Summit Alisdair provided wording and rationale.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
20.8 [memory] p2
</p>
<p>
Update the synopsis for <tt>&lt;memory&gt;</tt>
</p>
<blockquote><pre>// 20.7.8, raw storage iterator:
template &lt;<del>class</del> <ins>ForwardIterator</ins> Out<del>put</del>Iter<del>ator</del>, <del>class</del> <ins>ObjectType</ins> T&gt; 
  <ins>requires OutputIterator&lt; OutIter, T &gt;</ins>
    class raw_storage_iterator;

<ins>template &lt;ForwardIterator OutIter, ObjectType T&gt; 
  requires OutputIterator&lt; OutIter, T &gt;
  concept_map Iterator&lt;raw_storage_iterator&lt; OutIter, T &gt; &gt; { }</ins>
</pre></blockquote>


<p>
20.8.10 [storage.iterator] p1
</p>
<p>
Replace class template definition with:
</p>
<blockquote><pre>namespace std { 
  template &lt;<del>class</del> <ins>ForwardIterator</ins> Out<del>put</del>Iter<del>ator</del>, <del>class</del> <ins>ObjectType</ins> T&gt; 
    <ins>requires OutputIterator&lt; OutIter, T &gt;</ins>
  class raw_storage_iterator 
    : public iterator&lt;output_iterator_tag,void,void,void,void&gt; { 
  public: 
    explicit raw_storage_iterator(Out<del>put</del>Iter<del>ator</del> x); 

    raw_storage_iterator<del>&lt;OutputIterator,T&gt;</del>&amp; operator*(); 
    raw_storage_iterator<del>&lt;OutputIterator,T&gt;</del>&amp; operator=(const T&amp; element); 
    raw_storage_iterator<del>&lt;OutputIterator,T&gt;</del>&amp; operator++(); 
    raw_storage_iterator<del>&lt;OutputIterator,T&gt;</del> operator++(int); 
  }; 

  <ins>template &lt;ForwardIterator OutIter, ObjectType T&gt; 
    requires OutputIterator&lt; OutIter, T &gt;
    concept_map Iterator&lt;raw_storage_iterator&lt; OutIter, T &gt; &gt; { }</ins>
}
</pre></blockquote>


<p><b>Rationale:</b></p>
<p>
<tt>raw_storage_iterator</tt> has to adapt a <tt>ForwardIterator</tt>,
rather than just an <tt>InputIterator</tt> for two reasons:
</p>

<ol type="i">
<li>
The initial iterator passed by value is expected to remain valid,
pointing to the initialized region of memory.
</li>
<li>
to avoid breaking the declaration of post-increment operator which would
require some kind of proxy formulation to support generalised InputIterators.
</li>
</ol>






<hr>
<h3><a name="1029"></a>1029. Response to UK 210</h3>
<p><b>Section:</b> 20.8.13 [specialized.algorithms] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11  <b>Last modified:</b> 2009-07-16</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#specialized.algorithms">issues</a> in [specialized.algorithms].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 210</b></p>

<p>Related to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#582">582</a></p>

<p>
Specialized algorithms for memory managenment need requirements to be
easily usable in constrained templates.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
We look forward to a paper on this topic. We recommend no action until a
paper is available.
</blockquote>

<p><i>[
Post Summit Alisdair provided wording.
]</i></p>


<p><i>[
Post Summit:
]</i></p>


<blockquote>
<p>
Daniel adds:
</p>

<blockquote>
<ol>
<li>
I suggest <tt>Size</tt> should require <tt>IntegralLike</tt> and not <tt>UnsignedIntegralLike</tt>,
because otherwise simple int-literals could not be provided as arguments
and it would conflict with other algorithms that only require <tt>IntegralLike</tt>.
</li>
<li>
<p>
The current for-loop-test relies on evaluation in boolean context which is
not provided by <tt>ArithmeticLike</tt> and it's refinements. I propose to change the
corresponding for-loop-headers to:
</p>
<ol type="a">
<li>
for <tt>uninitialized_copy_n</tt>: <tt>for ( ; n &gt; Size(0); ++result, ++first, --n) {</tt>
</li>
<li>
for <tt>uninitialized_fill_n</tt>: <tt>for (; n &gt; Size(0); ++first, --n) {</tt>
</li>
</ol>
</li>
</ol>
</blockquote>

<p>
Alisdair adds:
</p>
<blockquote>
For the record I agree with Daniel's suggestion.
</blockquote>

</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
20.8 [memory] p2
</p>
<p>
Update the synopsis for <tt>&lt;memory&gt;</tt>
</p>
<blockquote><pre>template &lt;<del>class</del> InputIterator <ins>InIter</ins>,
         <del>class ForwardIterator</del> <ins>OutputIterator&lt;auto, InIter::reference&gt; OutIter</ins>&gt; 
   <ins>requires ForwardIterator&lt;OutIter&gt;</ins>
   <del>ForwardIterator</del> <ins>OutIter</ins>
   uninitialized_copy(<del>InputIterator</del> <ins>InIter</ins> first, <del>InputIterator</del> <ins>InIter</ins> last, 
                      <del>ForwardIterator</del> <ins>OutIter</ins> result);

template &lt;<del>class</del> InputIterator <ins>InIter</ins>,
          <del>class</del> <ins>IntegralLike</ins> Size,
          <del>class ForwardIterator</del> <ins>OutputIterator&lt;auto, InIter::reference&gt; OutIter</ins>&gt; 
  <ins>requires ForwardIterator&lt;OutIter&gt;</ins>
  <del>ForwardIterator</del> <ins>OutIter</ins>
  uninitialized_copy_n(<del>InputIterator</del> <ins>InIter</ins> first, Size n, 
                       <del>ForwardIterator</del> <ins>OutIter</ins> result);

template &lt;<del>class</del> ForwardIterator <ins>Iter</ins>, <del>class</del> <ins>ObjectType</ins> T&gt;
  <ins>requires Constructible&lt; Iter::value_type, const T&amp; &gt;</ins>
  void uninitialized_fill(<del>ForwardIterator</del> <ins>Iter</ins> first, <del>ForwardIterator</del> <ins>Iter</ins> last, 
                          const T&amp; x);

template &lt;<del>class</del> ForwardIterator <ins>Iter</ins>, <del>class</del> <ins>IntegralLike</ins> Size, <del>class</del> <ins>ObjectType</ins> T&gt; 
  <ins>requires Constructible&lt; Iter::value_type, const T&amp; &gt;</ins>
  void
  uninitialized_fill_n(<del>ForwardIterator</del> <ins>Iter</ins> first, Size n, const T&amp; x);
</pre></blockquote>

<p>
Update as follows:
</p>

<p>
uninitialized_copy 20.8.13.2 [uninitialized.copy]
</p>

<blockquote><pre>template &lt;<del>class</del> InputIterator <ins>InIter</ins>,
         <del>class ForwardIterator</del> <ins>OutputIterator&lt;auto, InIter::reference&gt; OutIter</ins>&gt; 
   <ins>requires ForwardIterator&lt;OutIter&gt;</ins>
   <del>ForwardIterator</del> <ins>OutIter</ins>
   uninitialized_copy(<del>InputIterator</del> <ins>InIter</ins> first, <del>InputIterator</del> <ins>InIter</ins> last, 
                      <del>ForwardIterator</del> <ins>OutIter</ins> result);
</pre>

<blockquote>
<p>
-1- <i>Effects:</i>
</p>
<blockquote><pre>for (; first != last; ++result, ++first)  {
   new (static_cast&lt;void*&gt;(&amp;*result))
       <del>typename iterator_traits&lt;ForwardIterator&gt;</del> <ins>OutIter</ins>::value_type(*first);
}
</pre></blockquote>

<p>
-2- <i>Returns:</i> <tt>result</tt>
</p>

</blockquote>

<pre>template &lt;<del>class</del> InputIterator <ins>InIter</ins>,
          <del>class</del> <ins>IntegralLike</ins> Size,
          <del>class ForwardIterator</del> <ins>OutputIterator&lt;auto, InIter::reference&gt; OutIter</ins>&gt; 
  <ins>requires ForwardIterator&lt;OutIter&gt;</ins>
  <del>ForwardIterator</del> <ins>OutIter</ins>
  uninitialized_copy_n(<del>InputIterator</del> <ins>InIter</ins> first, Size n, 
                       <del>ForwardIterator</del> <ins>OutIter</ins> result);
</pre>

<blockquote>
<p>
-3- Effects:
</p>
<blockquote><pre>for ( ; n &gt; <ins>Size(</ins>0<ins>)</ins>; ++result, ++first, --n) {
   new (static_cast&lt;void*&gt;(&amp;*result))
       <del>typename iterator_traits&lt;ForwardIterator&gt;</del> <ins>OutIter</ins>::value_type(*first);
}
</pre></blockquote>
<p>
-4- <i>Returns:</i> result
</p>
</blockquote>

</blockquote>


<p>
uninitialized_fill 20.8.13.3 [uninitialized.fill]
</p>

<blockquote><pre>template &lt;<del>class</del> ForwardIterator <ins>Iter</ins>, <del>class</del> <ins>ObjectType</ins> T&gt;
  <ins>requires Constructible&lt; Iter::value_type, const T&amp; &gt;</ins>
  void uninitialized_fill(<del>ForwardIterator</del> <ins>Iter</ins> first, <del>ForwardIterator</del> <ins>Iter</ins> last, 
                          const T&amp; x);
</pre>

<blockquote>
<p>
-1- <i>Effects:</i>
</p>
<blockquote><pre>for (; first != last; ++first) {
   new ( static_cast&lt;void*&gt;( &amp;*first) ) 
       <del>typename iterator_traits&lt;ForwardIterator&gt;</del> <ins>Iter</ins>::value_type(x);
}
</pre></blockquote>
</blockquote>
</blockquote>


<p>
uninitialized_fill_n 20.8.13.4 [uninitialized.fill.n]
</p>

<blockquote><pre>template &lt;<del>class</del> ForwardIterator <ins>Iter</ins>, <del>class</del> <ins>IntegralLike</ins> Size, <del>class</del> <ins>ObjectType</ins> T&gt; 
  <ins>requires Constructible&lt; Iter::value_type, const T&amp; &gt;</ins>
  void
  uninitialized_fill_n(<del>ForwardIterator</del> <ins>Iter</ins> first, Size n, const T&amp; x);
</pre>

<blockquote>
<p>
-1- <i>Effects:</i>
</p>
<blockquote><pre>for (; n<del>--</del> <ins>&gt; Size(0)</ins>; ++first<ins>, --n</ins>) {
   new ( static_cast&lt;void*&gt;( &amp;*first) ) 
       <del>typename iterator_traits&lt;ForwardIterator&gt;</del> <ins>Iter</ins>::value_type(x);
}
</pre></blockquote>
</blockquote>
</blockquote>






<hr>
<h3><a name="1031"></a>1031. Response to US 78</h3>
<p><b>Section:</b> 20.8.15.2 [util.smartptr.shared] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Future">NAD Future</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11  <b>Last modified:</b> 2009-10-20</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#util.smartptr.shared">issues</a> in [util.smartptr.shared].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Future">NAD Future</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses US 78</b></p>

<p>
There is presently no way to convert directly from a <tt>shared_ptr</tt> to a
<tt>unique_ptr</tt>. Add an interface that performs the conversion. 
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
We look forward to a paper on this topic. We recommend no action until a
paper is available. We believe that the shared pointer must use the default
deleter for the conversion to succeed.
</blockquote>

<p><i>[
Peter Dimov adds:
]</i></p>


<blockquote>
This is basically a request for <tt>shared_ptr&lt;&gt;::release</tt> in
disguise, with all the associated problems. Not a good idea.
</blockquote>

<p><i>[
2009-07 post-Frankfurt:
]</i></p>


<blockquote>
<p>
The rationale for the omission of a release() member function from shared_ptr is given in:
<a href="http://www.boost.org/doc/libs/1_39_0/libs/smart_ptr/shared_ptr.htm">http://www.boost.org/doc/libs/1_39_0/libs/smart_ptr/shared_ptr.htm</a>
</p>
<p>
The implementation of such a member is non-trivial (and maybe
impossible), because it would need to account for the deleter.
</p>
</blockquote>

<p><i>[
2009-07-26 Howard sets to Tentatively NAD Future.
]</i></p>


<blockquote>
<p>
I took an online poll and got 3 votes for NAD and 3 for NAD Future.  Personally
I prefer NAD Future as this does refer to an extension that could conceivably be
considered beyond C++0X.
</p>

<p>
However such an extension would need to solve a couple of problems:
</p>

<ol>
<li>What is the interface for such a conversion when the <tt>shared_ptr</tt> does
not have unique ownership?  Throw an exception?  Create a null <tt>unique_ptr</tt>?
Undefined behavior?
</li>

<li>
<p>
How does one handle custom deleters given to the <tt>shared_ptr</tt> constructor?
</p>
<p>
I do not believe it is possible to implement a general answer to this question.
The <tt>shared_ptr</tt> deleter is a run time (or construction time) characteristic.
The <tt>unique_ptr</tt> deleter is a compile time characteristic.  In general one
can not know to what type of <tt>unqiue_ptr</tt> you are converting to.
</p>
<p>
One answer is for the user of the conversion to specify the deleter type and perhaps
throw an exception if the specification turns out to be incorrect.
</p>
<p>
Another answer is for the conversion to only be valid when the underlying deleter
is <tt>default_delete</tt>.  We would probalby need to specify that this is indeed the
underlying deleter of a <tt>shared_ptr</tt> when a custom deleter is not given in
the constructor.
</p>
</li>
</ol>

<p>
At any rate, there are non-trivial design issues which would need to be implemented
and tested in the field for usability prior to standardization.
</p>
</blockquote>

<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote>
Moved to NAD Future.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1032"></a>1032. Response to JP 45</h3>
<p><b>Section:</b> 20.9 [time] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11  <b>Last modified:</b> 2009-07-16</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#time">issues</a> in [time].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses JP 45</b></p>

<p>
<tt>Rep</tt>, <tt>Period</tt>, <tt>Clock</tt> and <tt>Duration</tt>
don't correspond to concept.
</p>
<blockquote><pre>template &lt;class Rep, class Period = ratio&lt;1&gt;&gt; class duration; 
template &lt;class Clock, class Duration = typename Clock::duration&gt; class time_point; 
</pre></blockquote>
<p>
Make concept for <tt>Rep</tt>, <tt>Period</tt>, <tt>Clock</tt> and <tt>Duration</tt>.
Fix 20.9 [time] and <tt>wait_until</tt>
and <tt>wait_for</tt>'s template parameter at 30 [thread]. 
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
We agree that this section needs concepts. We look forward to a paper on
this topic. We recommend no action until a paper is available.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1035"></a>1035. Response to UK 226</h3>
<p><b>Section:</b> 23.2.1 [container.requirements.general] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-12  <b>Last modified:</b> 2009-10-20</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#container.requirements.general">active issues</a> in [container.requirements.general].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#container.requirements.general">issues</a> in [container.requirements.general].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 226</b></p>

<p>
<tt>&lt;array&gt;</tt> must be added to this list. In particular it
doesn't satisfy: - no <tt>swap()</tt> function invalidates any
references, pointers, or iterators referring to the elements of the
containers being swapped. and probably doesn't satisfy: - no
<tt>swap()</tt> function throws an exception.
</p>
<p>
If <tt>&lt;array&gt;</tt> remains a container, this will have to also
reference <tt>array</tt>, which will then have to say which of these
points it satisfies.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Agree. The proposed resolution is incomplete. Further work required.
</blockquote>

<p><i>[
2009-05-01 Daniel adds:
]</i></p>


<blockquote>
Issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1099">1099</a> also suggests
adding move constructor to this.
</blockquote>

<p><i>[
2009-07 post-Frankfurt:
]</i></p>


<blockquote>
Howard is to draft a note that explains what happens to references.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Mark as NAD.  No consensus for change.
</blockquote>



<p><i>[
2009-08-01 Howard provided wording.
]</i></p>


<p><b>Proposed resolution:</b></p>
<p>
Add a paragraph to 23.3.1.2 [array.special]:
</p>

<blockquote><pre>template &lt;Swappable T, size_t N&gt; void swap(array&lt;T,N&gt;&amp; x, array&lt;T,N&gt;&amp; y);
</pre>
<blockquote>
<p>
<i>Effects:</i>
</p>
<blockquote><pre>swap_ranges(x.begin(), x.end(), y.begin());
</pre></blockquote>

<p><ins>
[<i>Note:</i>
Outstanding iterators, references and pointers may be invalidated.
&#8212; <i>end note</i>]
</ins></p>
</blockquote>
</blockquote>





<hr>
<h3><a name="1036"></a>1036. Response to UK 231</h3>
<p><b>Section:</b> 23.2.3 [sequence.reqmts] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-12  <b>Last modified:</b> 2009-07-15</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#sequence.reqmts">active issues</a> in [sequence.reqmts].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#sequence.reqmts">issues</a> in [sequence.reqmts].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 231</b></p>

<p>
p9-p11 are redundant now that Concepts define what it means to be an
Iterator and guide overload resolution accordingly. 
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Agree with issue and change to 23.2.3 [sequence.reqmts]. The
changes required to 21 [strings] will be part of the general
concept support for that clause.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Strike 23.2.3 [sequence.reqmts]p9-11. Make sure <tt>std::basic_string</tt>
has constraints similar to
<tt>std::vector</tt> to meet this old guarantee. 
</p>





<hr>
<h3><a name="1041"></a>1041. Response to UK 239</h3>
<p><b>Section:</b> 23.2.4 [associative.reqmts] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Future">NAD Future</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-12  <b>Last modified:</b> 2009-10-20</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#associative.reqmts">active issues</a> in [associative.reqmts].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#associative.reqmts">issues</a> in [associative.reqmts].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Future">NAD Future</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 239</b></p>

<p>
It is not possible to take a move-only key out of an unordered
container, such as (<tt>multi</tt>)<tt>set</tt> or
(<tt>multi</tt>)<tt>map</tt>, or the new unordered containers.
</p>

<p>
Add below <tt>a.erase(q)</tt>, <tt>a.extract(q)</tt>, with the following notation:
</p>
<p>
<tt>a.extract(q)&gt;</tt>, Return type <tt>pair&lt;key, iterator&gt;</tt>
Extracts the element pointed to by <tt>q</tt> and erases it from the
<tt>set</tt>. Returns a <tt>pair</tt> containing the value pointed to by
<tt>q</tt> and an <tt>iterator</tt> pointing to the element immediately
following <tt>q</tt> prior to the element being erased. If no such
element exists,returns <tt>a.end()</tt>.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
We look forward to a paper on this topic. We recommend no action until a
paper is available. The paper would need to address exception safety.
</blockquote>

<p><i>[
Post Summit Alisdair adds:
]</i></p>


<blockquote>
Would <tt>value_type</tt> be a better return type than <tt>key_type</tt>?
</blockquote>

<p><i>[
2009-07 post-Frankfurt:
]</i></p>


<blockquote>
Leave Open. Alisdair to contact Chris Jefferson about this.
</blockquote>

<p><i>[
2009-09-20 Howard adds:
]</i></p>


<blockquote>
See the 2009-09-19 comment of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#839">839</a> for an API which
accomplishes this functionality and also addresses several other use
cases which this proposal does not.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Mark as NAD Future. No consensus to make the change at this time.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
In 23.2.4 [associative.reqmts] Table 85, add:
</p>

<blockquote>
<table border="1">
<caption>Table 85 --  Associative container requirements (in addition to container)</caption>
<tbody><tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion/note<br>pre-/post-condition</th>
<th>Complexity</th>
</tr>
<tr><td><tt>a.erase(q)</tt></td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr><tr>
<td><ins><tt>a.extract(q)</tt></ins></td>
<td><ins><tt>pair&lt;key_type, iterator&gt;</tt></ins></td>
<td><ins>Extracts the element pointed to by <tt>q</tt> and erases it from the <tt>set</tt>. 
Returns a <tt>pair</tt> containing the value pointed to by <tt>q</tt> and an <tt>iterator</tt>
pointing to the element immediately following <tt>q</tt> prior to the element being
erased. If no such element 
exists, returns <tt>a.end()</tt>.</ins></td>
<td><ins>amortized constant</ins></td>
</tr>
</tbody></table>
</blockquote>

<p>
In 23.2.5 [unord.req] Table 87, add:
</p>

<blockquote>
<table border="1">
<caption>Table 87 -- Unordered associative container requirements (in addition to container)</caption>
<tbody><tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion/note<br>pre-/post-condition</th>
<th>Complexity</th>
</tr>
<tr><td><tt>a.erase(q)</tt></td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr><tr>
<td><ins><tt>a.extract(q)</tt></ins></td>
<td><ins><tt>pair&lt;key_type, iterator&gt;</tt></ins></td>
<td><ins>Extracts the element pointed to by <tt>q</tt> and erases it from the <tt>set</tt>. 
Returns a <tt>pair</tt> containing the value pointed to by <tt>q</tt> and an <tt>iterator</tt>
pointing to the element immediately following <tt>q</tt> prior to the element being
erased. If no such element 
exists, returns <tt>a.end()</tt>.</ins></td>
<td><ins>amortized constant</ins></td>
</tr>
</tbody></table>
</blockquote>





<hr>
<h3><a name="1042"></a>1042. Response to UK 244</h3>
<p><b>Section:</b> 23.3 [sequences] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-12  <b>Last modified:</b> 2009-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#sequences">issues</a> in [sequences].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 244</b></p>

<p>
The validity of the expression <tt>&amp;a[n] == &amp;a[0] + n</tt> is contingent on
<tt>operator&amp;</tt> doing the "right thing" (as captured by the <tt>CopyConstructible</tt>
requirements in table 30 in C++2003). However this constraint has been
lost in the Concepts of C++0x. This applies to <tt>vector</tt> and <tt>array</tt> (it
actually applies to <tt>string</tt> also, but that's a different chapter, so I'll
file a separate comment there and cross-reference).
</p>

<p>
Suggested solution:
</p>

<p>
Define a <tt>ContiguousStrorage</tt> and apply it to
<tt>vector</tt>, <tt>array</tt> and <tt>string</tt>.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Agree with the issue but not the details of the proposed solution. Walter to
provide wording for the new concept.
</blockquote>

<p><i>[
Post Summit Alisdair adds:
]</i></p>


<blockquote>
Another LWG subgroup wondered if this concept
should extend to <tt>complex&lt;T&gt;</tt>, and so not be built on the container concept at
all?
</blockquote>

<p><i>[
2009-07 post-Frankfurt:
]</i></p>


<blockquote>
Leave Open, pending a post-Concepts Working Draft.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Mark issue 1042 as NAD, in rationale state that this was solved by removal of concepts.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add to <tt>&lt;container_concepts&gt;</tt> synopsis in  [container.concepts]
</p>

<blockquote><pre><ins>concept&lt; typename C &gt; ContiguousStorageContainer <i>see below</i>;</ins>
</pre></blockquote>

<p>
Add a new section to the end of  [container.concepts]
</p>

<blockquote>
<p>
23.1.6.x ContiguousStorageContainer concept [container.concepts.contiguous]
</p>

<pre>concept ContiguousStorageContainer&lt; typename C &gt;
  : Container&lt;C&gt;
{
  value_type* data(C&amp;);

  axiom Contiguity(C&amp; c, size_type i) {
    if( i &lt; size(c) ) {
         addressof( * (data(c) + i) )
      == addressof( * advance(data(c), i) );
    }
  }
}
</pre>

<p>
The <tt>ContiguousStorageContainer</tt> concept describes a container whose elements
are allocated in a single region of memory, and are stored sequentially
without intervening padding other than to meet alignment requirements.
For example, the elements may be stored in a
single array of suitable length.
</p>

<pre>value_type * data( C&amp; );
</pre>

<blockquote>
<i>Returns:</i> a pointer to the first element in the region of storage.
Result is unspecified for an empty container.
</blockquote>

</blockquote>

<p>
Change 23.3.1 [array] p1:
</p>

<blockquote>
-1- The header <tt>&lt;array&gt;</tt> defines a class template for
storing fixed-size sequences of objects. An <tt>array</tt> supports
random access iterators. An instance of <tt>array&lt;T, N&gt;</tt>
stores <tt>N</tt> elements of type <tt>T</tt>, so that <tt>size() ==
N</tt> is an invariant. The elements of an <tt>array</tt> are stored
contiguously, meaning that <del>if <tt>a</tt> is</del> an
<tt>array&lt;T, N&gt;</tt> <del>then it obeys the identity <tt>&amp;a[n]
== &amp;a[0] + n</tt> for all <tt>0 &lt;= n &lt; N</tt></del>
<ins>satisfies the concept <tt>ContiguousStorageContainer&lt; array&lt;T,
N&gt;&gt;</tt></ins>.
</blockquote>

<p>
Add to the synopsis in 23.3.1 [array]:
</p>

<blockquote><pre>    ...
    T * data(); 
    const T * data() const; 
  };

  <ins>template&lt; typename T, size_t N &gt;</ins>
    <ins>concept_map ContiguousStorageContainer&lt; array&lt;T, N&gt;&gt; {};</ins>
} 
</pre></blockquote>

<p>
Change 23.3.6 [vector] p1:
</p>

<blockquote>
A <tt>vector</tt> is a sequence container that supports random access
iterators. In addition, it supports (amortized) constant time insert and
erase operations at the end; insert and erase in the middle take linear
time. Storage management is handled automatically, though hints can be
given to improve efficiency. The elements of a vector are stored
contiguously, meaning that <del>if <tt>v</tt> is</del> a
<tt>vector&lt;T, Alloc&gt;</tt> <ins>(</ins>where <tt>T</tt> is some
type other than <tt>bool</tt><ins>)</ins><del>, then it obeys the
identity <tt>&amp;v[n] == &amp;v[0] + n</tt> for all <tt>0 &lt;= n &lt;
v.size()</tt></del> <ins>satisfies the concept <tt>ContiguousStorageContainer&lt;
vector&lt; T, Alloc&gt;&gt;</tt></ins>.
</blockquote>

<p>
Add at the end of the synopsis in 23.3.6 [vector] p2:
</p>

<blockquote><pre><ins>template&lt; typename T, typename A &gt;
  requires !SameType&lt; T, bool &gt;
  concept_map ContiguousStorageContainer&lt; vector&lt;T, A&gt;&gt; {};</ins>
</pre></blockquote>



<p><b>Rationale:</b></p>
Solved by removal of concepts.





<hr>
<h3><a name="1043"></a>1043. Response to US 91</h3>
<p><b>Section:</b> 29.6 [atomics.types.operations] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-12  <b>Last modified:</b> 2009-10-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#atomics.types.operations">issues</a> in [atomics.types.operations].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses US 91</b></p>

<p>
It is unclear whether or not a failed <tt>compare_exchange</tt> is a RMW operation
(as used in 1.10 [intro.multithread]).
</p>

<p>
Suggested solution:
</p>

<p>
Make failing <tt>compare_exchange</tt> operations <b>not</b> be RMW.
</p>

<p><i>[
Anthony Williams adds:
]</i></p>


<blockquote>
In 29.6 [atomics.types.operations] p18 it says that "These
operations are atomic read-modify-write operations" (final sentence).
This is overly restrictive on the implementations of
<tt>compare_exchange_weak</tt> and <tt>compare_exchange_strong</tt> on platforms without a
native CAS instruction.
</blockquote>


<p><i>[
Summit:
]</i></p>


<blockquote>
Group agrees with the resolution as proposed by Anthony Williams in the attached note.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We recommend the proposed resolution be reviewed
by members of the Concurrency Subgroup.
</blockquote>

<p><i>[
2009-07 post-Frankfurt:
]</i></p>


<blockquote>
This is likely to be addressed by Lawrence's upcoming paper. He will
adopt the proposed resolution.
</blockquote>

<p><i>[
2009-08-17 Handled by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2925.html">N2925</a>.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD Editorial.  Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2992.html">N2992</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 29.6 [atomics.types.operations] p18:
</p>

<blockquote>
-18- <i>Effects:</i> Atomically, compares the value pointed to by
<tt>object</tt> or by <tt>this</tt> for equality with that in
<tt>expected</tt>, and if true, replaces the value pointed to by
<tt>object</tt> or by <tt>this</tt> with desired, and if false, updates
the value in <tt>expected</tt> with the value pointed to by
<tt>object</tt> or by <tt>this</tt>. Further, if the comparison is true,
memory is affected according to the value of <tt>success</tt>, and if the
comparison is false, memory is affected according to the value of
<tt>failure</tt>. When only one <tt>memory_order</tt> argument is
supplied, the value of <tt>success</tt> is <tt>order</tt>, and the value
of <tt>failure</tt> is <tt>order</tt> except that a value of
<tt>memory_order_acq_rel</tt> shall be replaced by the value
<tt>memory_order_acquire</tt> and a value of
<tt>memory_order_release</tt> shall be replaced by the value
<tt>memory_order_relaxed</tt>. <ins>If the comparison is <tt>true</tt>, </ins>
<del>T</del><ins>t</ins>hese operations are atomic
read-modify-write operations (1.10). 
<ins>If the comparison is <tt>false</tt>, these
operations are atomic load operations.</ins>
</blockquote>






<hr>
<h3><a name="1046"></a>1046. Response to UK 329</h3>
<p><b>Section:</b> 30.6 [futures] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-12  <b>Last modified:</b> 2009-10-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#futures">issues</a> in [futures].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 329</b></p>

<p>
<tt>future</tt>, <tt>promise</tt> and <tt>packaged_task</tt> provide a
framework for creating future values, but a simple function to tie all
three components together is missing. Note that we only need a *simple*
facility for C++0x. Advanced thread pools are to be left for TR2.
</p>

<p>
Simple Proposal:
</p>

<p>
Provide a simple function along the lines of: 
</p>
<blockquote><pre>template&lt; typename F, typename ... Args &gt;
  requires Callable&lt; F, Args... &gt;
    future&lt; Callable::result_type &gt; async( F&amp;&amp; f, Args &amp;&amp; ... ); 
</pre></blockquote>

<p>
Semantics are similar to creating a <tt>thread</tt> object with a <tt>packaged_task</tt>
invoking <tt>f</tt> with <tt>forward&lt;Args&gt;(args...)</tt>
but details are left unspecified to allow different scheduling and thread
spawning implementations. 
</p>
<p>
It is unspecified whether a task submitted to async is run on its own thread
or a thread previously used for another async task. If a call to <tt>async</tt>
succeeds, it shall be safe to wait for it from any thread. 
</p>
<p>
The state of <tt>thread_local</tt> variables shall be preserved during <tt>async</tt> calls. 
</p>
<p>
No two incomplete async tasks shall see the same value of
<tt>this_thread::get_id()</tt>. 
</p>
<p>
[<i>Note:</i> this effectively forces new tasks to be run on a new thread, or a
fixed-size pool with no queue. If the 
library is unable to spawn a new thread or there are no free worker threads
then the <tt>async</tt> call should fail. <i>--end note</i>] 
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
<p>
The concurrency subgroup has revisited this issue and decided that it
could be considered a defect according to the Kona compromise. A task
group was formed lead by Lawrence Crowl and Bjarne Stroustrup to write a
paper for Frankfort proposing a simple asynchronous launch facility
returning a <tt>future</tt>. It was agreed that the callable must be run on a
separate thread from the caller, but not necessarily a brand-new thread.
The proposal might or might not allow for an implementation that uses
fixed-size or unlimited thread pools.
</p>
<p>
Bjarne in c++std-lib-23121: I think that what we agreed was that to
avoid deadlock <tt>async()</tt> would almost certainly be specified to  launch in
a different thread from the thread that executed <tt>async()</tt>, but I don't
think it was a specific design constraint.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Proposed resolution: see
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2996.html">N2996</a>
(Herb's and Lawrence's paper on Async). Move state to NAD editorial.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1047"></a>1047. Response to UK 334</h3>
<p><b>Section:</b> 30.6.6 [futures.unique_future] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-12  <b>Last modified:</b> 2009-10-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#futures.unique_future">issues</a> in [futures.unique_future].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 334</b></p>

<p>
Behaviour of <tt>get()</tt> is undefined if calling <tt>get()</tt> while
not <tt>is_ready()</tt>. The intent is that <tt>get()</tt> is a blocking
call, and will wait for the future to become ready.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
<p>
Agree, move to Review.
</p>
</blockquote>

<p><i>[
2009-04-03 Thomas J. Gritzan adds:
]</i></p>


<blockquote>
<p>
This issue also applies to <tt>shared_future::get()</tt>.
</p>

<p>
Suggested wording:
</p>

<p>
Add a paragraph to  [futures.shared_future]:
</p>

<blockquote><pre>void shared_future&lt;void&gt;::get() const;
</pre>
<blockquote>
<i>Effects:</i> If <tt>is_ready()</tt> would return <tt>false</tt>, block on the asynchronous 
result associated with <tt>*this</tt>.
</blockquote>
</blockquote>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
It is not clear to us that this is an issue,
because the proposed resolution's Effects clause seems to duplicate
information already present in the Synchronization clause.
Keep in Review status.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD Editorial.  Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2997.html">N2997</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add a paragraph to 30.6.6 [futures.unique_future]:
</p>

<blockquote><pre>R&amp;&amp; unique_future::get(); 
R&amp; unique_future&lt;R&amp;&gt;::get(); 
void unique_future&lt;void&gt;::get();
</pre>
<blockquote>
<p><i>Note:</i>...</p>
<p>
<ins><i>Effects:</i> If <tt>is_ready()</tt> would return <tt>false</tt>,
block on the asynchronous result associated with <tt>*this</tt>.</ins>
</p>
<p>
<i>Synchronization:</i> if <tt>*this</tt> is associated with a
<tt>promise</tt> object, the completion of <tt>set_value()</tt> or
<tt>set_exception()</tt> to that <tt>promise</tt> happens before (1.10)
<tt>get()</tt> returns.
</p>
</blockquote>
</blockquote>





<hr>
<h3><a name="1048"></a>1048. Response to UK 335</h3>
<p><b>Section:</b> 30.6.6 [futures.unique_future] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-12  <b>Last modified:</b> 2009-10-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#futures.unique_future">issues</a> in [futures.unique_future].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 335</b></p>

<p>
<tt>std::unique_future</tt> is <tt>MoveConstructible</tt>, so you can transfer the
association with an asynchronous result from one instance to another.
However, there is no way to determine whether or not an instance has
been moved from, and therefore whether or not it is safe to wait for it.
</p>

<blockquote><pre>std::promise&lt;int&gt; p;
std::unique_future&lt;int&gt; uf(p.get_future());
std::unique_future&lt;int&gt; uf2(std::move(uf));
uf.wait(); <font color="#c80000">// oops, uf has no result to wait for. </font>
</pre></blockquote>

<p>
Suggest we add a <tt>waitable()</tt> function to <tt>unique_future</tt>
(and <tt>shared_future</tt>) akin to <tt>std::thread::joinable()</tt>,
which returns <tt>true</tt> if there is an associated result to wait for
(whether or not it is ready).
</p>

<p>
Then we can say:
</p>

<blockquote><pre>if(uf.waitable()) uf.wait();
</pre></blockquote>

<p><i>[
Summit:
]</i></p>


<blockquote>
<p>
Create an issue. Requires input from Howard. Probably NAD.
</p>
</blockquote>

<p><i>[
Post Summit, Howard thows in his two cents:
]</i></p>


<blockquote>
<p>
Here is a copy/paste of my last prototype of <tt>unique_future</tt> which was
several years ago.  At that time I was calling <tt>unique_future</tt> <tt>future</tt>:
</p>

<blockquote><pre>template &lt;class R&gt;
class future
{
public:
    typedef R result_type;
private:
    future(const future&amp;);// = delete;
    future&amp; operator=(const future&amp;);// = delete;

    template &lt;class R1, class F1&gt; friend class prommise;
public:
    future();
    ~future();

    future(future&amp;&amp; f);
    future&amp; operator=(future&amp;&amp; f);

    void swap(future&amp;&amp; f);

    <b>bool joinable() const;</b>
    bool is_normal() const;
    bool is_exceptional() const;
    bool is_ready() const;

    R get();

    void join();
    template &lt;class ElapsedTime&gt;
        bool timed_join(const ElapsedTime&amp;);
};
</pre></blockquote>

<p>
<tt>shared_future</tt> had a similar interface.  I intentionally reused
the <tt>thread</tt> interface where possible to lessen the learning
curve std::lib clients will be faced with.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD Editorial.  Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2997.html">N2997</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1049"></a>1049. Response to UK 339</h3>
<p><b>Section:</b> 30.6.5 [futures.promise] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-12  <b>Last modified:</b> 2009-10-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#futures.promise">issues</a> in [futures.promise].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 339</b></p>

<p>
Move assignment is goiing in the wrong direction, assigning from
<tt>*this</tt> to the passed rvalue, and then returning a reference to
an unusable <tt>*this</tt>.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
<p>
Agree, move to Review.
</p>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We recommend deferring this issue until after Detlef's paper (on futures)
has been issued.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD Editorial.  Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2997.html">N2997</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Strike 30.6.5 [futures.promise] p6 and change p7:
</p>

<blockquote><pre>promise&amp; operator=(promise&amp;&amp; rhs);
</pre>
<blockquote>
<p>
<del>-6- <i>Effects:</i> move assigns its associated state to <tt>rhs</tt>.</del>
</p>
<p>
-7- <i>Postcondition:</i> <del><tt>*this</tt> has no associated
state.</del> <ins>associated state of <tt>*this</tt> is the same as the
associated state of <tt>rhs</tt> before the call. <tt>rhs</tt> has no
associated state.</ins>
</p>
</blockquote>
</blockquote>






<hr>
<h3><a name="1050"></a>1050. Response to UK 340</h3>
<p><b>Section:</b> 30.6.5 [futures.promise] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-12  <b>Last modified:</b> 2009-10-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#futures.promise">issues</a> in [futures.promise].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 340</b></p>

<p>
There is an implied postcondition for <tt>get_future()</tt> that the state of the
<tt>promise</tt> is transferred into the <tt>future</tt> leaving the <tt>promise</tt> with no
associated state. It should be spelled out.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
<p>
Agree, move to Review.
</p>
</blockquote>

<p><i>[
2009-04-03 Thomas J. Gritzan adds:
]</i></p>


<blockquote>
<p>
<tt>promise::get_future()</tt> must not invalidate the state of the promise object. 
</p>
<p>
A promise is used like this: 
</p>
<blockquote><pre>promise&lt;int&gt; p; 
unique_future&lt;int&gt; f = p.get_future(); 
<font color="#c80000">// post 'p' to a thread that calculates a value </font>
<font color="#c80000">// use 'f' to retrieve the value. </font>
</pre></blockquote>
<p>
So <tt>get_future()</tt> must return an object that shares the same associated 
state with <tt>*this</tt>. 
</p>
<p>
But still, this function should throw an <tt>future_already_retrieved</tt> error 
when it is called twice. 
</p>
<p>
<tt>packaged_task::get_future()</tt> throws <tt>std::bad_function_call</tt> if its <tt>future</tt>
was already retrieved. It should throw 
<tt>future_error(future_already_retrieved)</tt>, too. 
</p>
<p>
Suggested resolution: 
</p>
<p>
Replace p12/p13 30.6.5 [futures.promise]: 
</p>
<blockquote>
<p>
-12- <i>Throws:</i> <tt>future_error</tt> if <del><tt>*this</tt> has no associated state</del>
<ins>the <tt>future</tt> has already been retrieved</ins>.
</p>
<p>
-13- <i>Error conditions:</i> <tt>future_already_retrieved</tt> if <del><tt>*this</tt>
has no associated state</del>
<ins>the <tt>future</tt> associated with 
the associated state has already been retrieved</ins>.
</p>
<p>
<ins><i>Postcondition:</i> The returned object and <tt>*this</tt> share the associated state.</ins>
</p>
</blockquote>
<p>
Replace p14 30.6.10 [futures.task]: 
</p>
<blockquote>
<p>
-14- <i>Throws:</i> <tt><del>std::bad_function_call</del> <ins>future_error</ins></tt> if the future <del>associated with
the task</del> has already been retrieved.
</p>

<p><ins>
<i>Error conditions:</i> <tt>future_already_retrieved</tt> if the <tt>future</tt> associated with 
the task has already been retrieved. 
</ins></p>
<p>
<ins><i>Postcondition:</i> The returned object and <tt>*this</tt> share the associated task.</ins>
</p>
</blockquote>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Keep in Review status
pending Detlef's forthcoming paper on futures.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD Editorial.  Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2997.html">N2997</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add after p13 30.6.5 [futures.promise]:
</p>

<blockquote><pre>unique_future&lt;R&gt; get_future();
</pre>
<blockquote>
<p>
-13- ...
</p>
<p>
<i>Postcondition:</i> <tt>*this</tt> has no associated state.
</p>
</blockquote>
</blockquote>






<hr>
<h3><a name="1051"></a>1051. Response to UK 279</h3>
<p><b>Section:</b> 24.5.1.3.12 [reverse.iter.opindex], 24.5.3.3.12 [move.iter.op.index] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-12  <b>Last modified:</b> 2009-10-24</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 279</b></p>

<p>
The reason the return type became unspecified is LWG issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#386">386</a>. This
reasoning no longer applies as there are at least two ways to get the right
return type with the new language facilities added since the previous
standard. 
</p>

<p>
Proposal: Specify the return type using either decltype or the Iter concept_map.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
<p>
Under discussion. This is a general question about all iterator
adapters.
</p>
</blockquote>

<p><i>[
Howard adds post Summit:
]</i></p>


<blockquote>
I am requesting test cases to demonstrate a position.
</blockquote>

<p><i>[
2009-07-24 Daniel adds:
]</i></p>


<blockquote>
<p>
I recommend NAD. Without concepts we can no longer
restrict this member in a trivial way. Using <tt>decltype</tt> the
declaration would be along the lines of
</p>
<blockquote><pre>static const Iter&amp; __base(); // not defined
auto operator[](difference_type n) const -&gt; decltype(__base()[-n-1]);
</pre></blockquote>

<p>
but once <tt>reverse_iterator</tt> is instantiated for some given type
<tt>Iter</tt> which cannot form a well-formed expression <tt>__base()[-n-1]</tt>
this would cause an ill-formed function declaration, diagnostic
required, and no silent SFINAE elimination.
</p>

</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Moved to NAD.
</blockquote>

<p><i>[
2009-10-22 Daniel adds:
]</i></p>


<blockquote>
<p>
IMO, my original comment regarding ill-formedness of the described
construction is still correct, but I must add that I should weaken my
assertion "Without concepts we can no longer restrict this member in
a trivial way".
</p>

<p>
In fact with the existence of default template arguments for function
templates it is not too hard to implement this like as follows, which
shows that we can indeed simulate to some sense constrained
member functions in C++0x.
</p>

<p>
My example does not really proof that the specification is easy, but
it should be possible. I assume that the implementation would not
be ABI compatible, though.
</p>

<p>
It is now your own decision how to proceed ;-)
</p>

<blockquote><pre>#include &lt;type_traits&gt;
#include &lt;cstddef&gt;

template&lt;class T&gt;
typename std::add_rvalue_reference&lt;T&gt;::type declval();

template&lt;class It&gt;
struct reverse_iterator {
    It base;
    
    typedef std::ptrdiff_t difference_type;
    
    template&lt;class U = It, class Res =
     decltype(declval&lt;const U&amp;&gt;()[declval&lt;difference_type&gt;()])
    &gt;
    Res operator[](difference_type n) const  {
        return base[-n-1];
    }    
};

struct MyIter {
};

int main() {
    reverse_iterator&lt;int*&gt; ri;
    ri[0] = 2;
    reverse_iterator&lt;MyIter&gt; ri2;
}
</pre></blockquote>

<p>
The above declaration could be simplified, but the ideal solution
</p>

<blockquote><pre>template&lt;class U = It&gt;
  decltype(declval&lt;const U&amp;&gt;()[declval&lt;difference_type&gt;()])
     operator[](difference_type n) const;
</pre></blockquote>

<p>
does not work yet on gcc 4.4.1.
</p>

</blockquote>




<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1053"></a>1053. Response to UK 295</h3>
<p><b>Section:</b> 25 [algorithms] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Future">NAD Future</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-12  <b>Last modified:</b> 2009-10-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#algorithms">active issues</a> in [algorithms].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#algorithms">issues</a> in [algorithms].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Future">NAD Future</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 295</b></p>

<p>
There is a level of redundancy in the library specification for many
algorithms that can be eliminated with the combination of concepts and
default parameters for function templates. Eliminating redundancy simplified
specification and reduces the risk of introducing accidental
inconsistencies.
</p>
<p>
Proposed resolution: Adopt
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2743.pdf">N2743</a>.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
<p>
NAD, this change would break code that takes the address of an
algorithm.
</p>
</blockquote>

<p><i>[
Post Summit Alisdair adds:
]</i></p>


<blockquote>
<p>
Request 'Open'.  The issues in the paper go beyond just reducing
the number of signatures, but cover unifying the idea of the ordering
operation used by algorithms, containers and other library components.  At
least, it takes a first pass at the problem.
</p>

<p>
For me (personally) that was the more important part of the paper, and not
clearly addressed by the Summit resolution.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Too inventive, too late, would really need a paper. Moved to NAD Future.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1054"></a>1054. <tt>forward</tt> broken</h3>
<p><b>Section:</b> 20.3.3 [forward] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-03-13  <b>Last modified:</b> 2009-10-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#forward">issues</a> in [forward].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p>
This is a placeholder issue to track the fact that we (well I) put the standard
into an inconsistent state by requesting that we accept
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2844.html">N2844</a>
except for the proposed changes to [forward].
</p>

<p>
There will exist in the post meeting mailing
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2835.html">N2835</a>
which in its current state reflects the state of affairs prior to the Summit
meeting.  I hope to update it in time for the post Summit mailing, but as I write
this issue I have not done so yet.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Move to Open, awaiting the promised paper.
</blockquote>

<p><i>[
2009-08-02 Howard adds:
]</i></p>


<blockquote>
<p>
My current preferred solution is:
</p>

<blockquote><pre>template &lt;class T&gt;
struct __base_type
{
   typedef typename remove_cv&lt;typename remove_reference&lt;T&gt;::type&gt;::type type;
};

template &lt;class T, class U,
   class = typename enable_if&lt;
       !is_lvalue_reference&lt;T&gt;::value ||
        is_lvalue_reference&lt;T&gt;::value &amp;&amp;
        is_lvalue_reference&lt;U&gt;::value&gt;::type,
   class = typename enable_if&lt;
        is_same&lt;typename __base_type&lt;T&gt;::type,
                typename __base_type&lt;U&gt;::type&gt;::value&gt;::type&gt;
inline
T&amp;&amp;
forward(U&amp;&amp; t)
{
   return static_cast&lt;T&amp;&amp;&gt;(t);
}
</pre></blockquote>

<p>
This has been tested by Bill, Jason and myself.
</p>

<p>
It allows the following lvalue/rvalue casts:
</p>

<ol>
<li>
Cast an lvalue <tt>t</tt> to an lvalue <tt>T</tt> (identity).
</li>
<li>
Cast an lvalue <tt>t</tt> to an rvalue <tt>T</tt>.
</li>
<li>
Cast an rvalue <tt>t</tt> to an rvalue <tt>T</tt> (identity).
</li>
</ol>

<p>
It disallows:
</p>

<ol type="a">
<li>
Cast an rvalue <tt>t</tt> to an lvalue <tt>T</tt>.
</li>
<li>
Cast one type <tt>t</tt> to another type <tt>T</tt> (such as <tt>int</tt> to <tt>double</tt>).
</li>
</ol>

<p>
"a." is disallowed as it can easily lead to dangling references.
"b." is disallowed as this function is meant to only change the lvalue/rvalue
characteristic of an expression.
</p>

<p>
Jason has expressed concern that "b." is not dangerous and is useful in contexts
where you want to "forward" a derived type as a base type.  I find this use case
neither dangerous, nor compelling.  I.e. I could live with or without the "b."
constraint.  Without it, forward would look like:
</p>

<blockquote><pre>template &lt;class T, class U,
   class = typename enable_if&lt;
       !is_lvalue_reference&lt;T&gt;::value ||
        is_lvalue_reference&lt;T&gt;::value &amp;&amp;
        is_lvalue_reference&lt;U&gt;::value&gt;::type&gt;
inline
T&amp;&amp;
forward(U&amp;&amp; t)
{
   return static_cast&lt;T&amp;&amp;&gt;(t);
}
</pre></blockquote>

<p>
Or possibly:
</p>

<blockquote><pre>template &lt;class T, class U,
   class = typename enable_if&lt;
       !is_lvalue_reference&lt;T&gt;::value ||
        is_lvalue_reference&lt;T&gt;::value &amp;&amp;
        is_lvalue_reference&lt;U&gt;::value&gt;::type,
   class = typename enable_if&lt;
        is_base_of&lt;typename __base_type&lt;U&gt;::type,
                   typename __base_type&lt;T&gt;::type&gt;::value&gt;::type&gt;
inline
T&amp;&amp;
forward(U&amp;&amp; t)
{
   return static_cast&lt;T&amp;&amp;&gt;(t);
}
</pre></blockquote>


<p>
The "promised paper" is not in the post-Frankfurt mailing only because I'm waiting
for the non-concepts draft.  But I'm hoping that by adding this information here
I can keep people up to date.
</p>
</blockquote>

<p><i>[
2009-08-02 David adds:
]</i></p>


<blockquote>
<p>
<tt>forward</tt> was originally designed to do one thing: perfect forwarding.
That is, inside a function template whose actual argument can be a const
or non-const lvalue or rvalue, restore the original "rvalue-ness" of the
actual argument:
</p>

<blockquote><pre>template &lt;class T&gt;
void f(T&amp;&amp; x)
{
    // x is an lvalue here.  If the actual argument to f was an
    // rvalue, pass static_cast&lt;T&amp;&amp;&gt;(x) to g; otherwise, pass x.
    g( forward&lt;T&gt;(x) );
}
</pre></blockquote>

<p>
Attempting to engineer <tt>forward</tt> to accomodate uses other than perfect
forwarding dilutes its idiomatic meaning.  The solution proposed here
declares that <tt>forward&lt;T&gt;(x)</tt> means nothing more than <tt>static_cast&lt;T&amp;&amp;&gt;(x)</tt>,
with a patchwork of restrictions on what <tt>T</tt> and <tt>x</tt> can be that can't be
expressed in simple English.
</p>

<p>
I would be happy with either of two approaches, whose code I hope (but
can't guarantee) I got right.
</p>

<ol>
<li>
<p>
Use a simple definition of <tt>forward</tt> that accomplishes its original
purpose without complications to accomodate other uses:
</p>

<blockquote><pre>template &lt;class T, class U&gt;
T&amp;&amp; forward(U&amp; x)
{
    return static_cast&lt;T&amp;&amp;&gt;(x);
}
</pre></blockquote>
</li>

<li>
<p>
Use a definition of <tt>forward</tt> that protects the user from as many
potential mistakes as possible, by actively preventing <em>all</em> other
uses:
</p>

<blockquote><pre>template &lt;class T, class U&gt;
boost::enable_if_c&lt;
    // in forward&lt;T&gt;(x), x is a parameter of the caller, thus an lvalue
    is_lvalue_reference&lt;U&gt;::value
    // in caller's deduced T&amp;&amp; argument, T can only be non-ref or lvalue ref
    &amp;&amp; !is_rvalue_reference&lt;T&gt;::value
    // Must not cast cv-qualifications or do any type conversions
    &amp;&amp; is_same&lt;T&amp;,U&amp;&gt;::value
    , T&amp;&amp;&gt;::type forward(U&amp;&amp; a)
{
    return static_cast&lt;T&amp;&amp;&gt;(a);
}
</pre></blockquote>
</li>
</ol>

</blockquote>

<p><i>[
2009-09-27 Howard adds:
]</i></p>


<blockquote>
A paper,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2951.html">N2951</a>,
is available which compares several implementations (including David's) with respect to several
use cases (including Jason's) and provides wording for one implementation.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD Editorial.  Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2951.html">N2951</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1055"></a>1055. Response to UK 98</h3>
<p><b>Section:</b> 20.6.7 [meta.trans.other] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-12  <b>Last modified:</b> 2009-10-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#meta.trans.other">issues</a> in [meta.trans.other].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 98</b></p>

<p>
It would be useful to be able to determine the underlying
type of an arbitrary enumeration type. This would allow
safe casting to an integral type (especially needed for
scoped enums, which do not promote), and would allow
use of <tt>numeric_limits</tt>. In general it makes generic
programming with enumerations easier.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Pete observes (and Tom concurs)
that the proposed resolution seems to require compiler support
for its implementation,
as it seems necessary to look at the range of values
of the enumerated type.
To a first approximation,
a library solution could give an answer based on the size of the type.
If the user has specialized <tt>numeric_limits</tt> for the enumerated type,
then the library might be able to do better,
but there is no such requirement.
Keep status as Open
and solicit input from CWG.
</blockquote>

<p><i>[
2009-05-23 Alisdair adds:
]</i></p>


<blockquote>
Just to confirm that the BSI originator of this comment assumed it did
indeed imply a compiler intrinsic.  Rather than request a Core extension, it
seemed in keeping with that the type traits interface provides a library API
to unspecified compiler features - where we require several other traits
(e.g. <tt>has_trivial_*</tt>) to get the 'right' answer now, unlike in TR1.
</blockquote>

<p><i>[
Addressed in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2947.html">N2947</a>.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD Editorial.  Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2984.html">N2984</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add a new row to the table in 20.6.7 [meta.trans.other]:
</p>

<blockquote>
<table border="1">
<caption>Table 41 -- Other transformations</caption>
<tbody><tr>
<th>Template</th>
<th>Condition</th>
<th>Comments</th>
</tr>
<tr>
<td>
<tt>template&lt;&nbsp;class&nbsp;T&nbsp;&gt; struct enum_base;</tt>
</td>
<td>
<tt>T</tt> shall be an enumeration type (7.2 [dcl.enum])
</td>
<td>
The member typedef <tt>type</tt> shall name the underlying type
of the enum <tt>T</tt>.
</td>
</tr>
</tbody></table>
</blockquote>





<hr>
<h3><a name="1057"></a>1057. <tt>RandomNumberEngineAdaptor</tt></h3>
<p><b>Section:</b> 26.5 [rand] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-12  <b>Last modified:</b> 2009-07-15</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand">issues</a> in [rand].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>

<p>
The <tt>RandomNumberEngineAdaptor</tt> concept breaks precedent in the
way the library has been specified by grouping requirements into a
concept that is never actually used in the library.
</p>
<p>
This is undoubtedly a very helpful device for documentation, but we are not
comfortable with the precedent - especially as we have rejected national
body comments on the same grounds.
</p>
<p>
Suggest either removing the concept, or providing an algorithm/type that
requires this concept in their definition (such as a factory function to
create new engines).
</p>
<p>
The preference is to create a single new algorithm and retain the value of
the existing documentation.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Walter points out that it is unlikely that any algorithm would ever
require this concept, but that the concept nonetheless is useful as
documentation, and (via concept maps) as a means of checking specific adapters.
</p>
<p>
Alisdair disagrees as to the concept's value as documentation.
</p>
<p>
Marc points out that the <tt>RandomNumberDistribution</tt>
is also a concept not used elsewhere in the Standard.
</p>
<p>
Pete agrees that a policy of not inventing concepts
that aren't used in the Standard is a good starting point,
but should not be used as a criterion for rejecting a concept.
</p>
<p>
Move to Open.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1058"></a>1058. New container issue</h3>
<p><b>Section:</b> 23.2.3 [sequence.reqmts] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-12  <b>Last modified:</b> 2009-07-13</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#sequence.reqmts">active issues</a> in [sequence.reqmts].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#sequence.reqmts">issues</a> in [sequence.reqmts].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Sequence containers 23.2.3 [sequence.reqmts]:
</p>

<p>
The return value of new calls added to table 83 are not specified.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We agree with the proposed resolution.
</p>
<p>
Move to NAD Editorial.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Add after p6 23.2.3 [sequence.reqmts]:
</p>

<blockquote>
<p>
-6- ...
</p>
<p><ins>
The iterator returned from <tt>a.insert(p,rv)</tt> points to the copy of <tt>rv</tt>
inserted into <tt>a</tt>.
</ins></p>
<p><ins>
The iterator returned from <tt>a.emplace(p, args)</tt> points to the new
element constructed from <tt>args</tt> inserted into <tt>a</tt>.
</ins></p>
</blockquote>





<hr>
<h3><a name="1059"></a>1059. Usage of no longer existing FunctionType concept</h3>
<p><b>Section:</b> 20.7.15.2 [func.wrap.func] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Concepts">NAD Concepts</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2009-03-13  <b>Last modified:</b> 2009-07-16</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#func.wrap.func">issues</a> in [func.wrap.func].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Due to a deliberate core language decision, the earlier called
"foundation" concept <tt>std::FunctionType</tt> had been removed in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2773.pdf">N2773</a>
shortly
before the first "conceptualized" version of the WP
(<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2798.pdf">N2798</a>)
had been
prepared. This caused a break of the library, which already used this
concept in the adapted definition of <tt>std::function</tt>
(20.7 [function.objects]/2, header <tt>&lt;functional&gt;</tt> synopsis and
20.7.15.2 [func.wrap.func]).
</p>
<p>
A simple fix would be to either (a) make <tt>std::function</tt>'s primary template
unconstrained or to (b) add constraints based on existing (support) concepts.
A more advanced fix would (c) introduce a new library concept.
</p>
<p>
The big disadvantage of (a) is, that users can define templates which
cause compiler errors during instantiation time because of under-constrainedness
and would thus violate the basic advantage of constrained
code.
</p>
<p>
For (b), the ideal constraints for <tt>std::function</tt>'s template parameter would
be one which excludes everything else but the single provided partial
specialization that matches every "free function" type (i.e. any function
type w/o cv-qualifier-seq and w/o ref-qualifier).
Expressing such a type as as single requirement would be written as
</p>
<blockquote><pre>template&lt;typename T&gt;
requires ReferentType&lt;T&gt; // Eliminate cv void and function types with cv-qual-seq
                         //   or ref-qual (depending on core issue #749)
      &amp;&amp; PointeeType&lt;T&gt;  // Eliminate reference types
      &amp;&amp; !ObjectType&lt;T&gt;  // Eliminate object types
</pre></blockquote>
<p>
Just for completeness approach (c), which would make sense, if the
library has more reasons to constrain for free function types:
</p>
<blockquote><pre>auto concept FreeFunctionType&lt;typename T&gt;
  : ReferentType&lt;T&gt;, PointeeType&lt;T&gt;, MemberPointeeType&lt;T&gt;
{
  requires !ObjectType&lt;T&gt;;
}
</pre></blockquote>
<p>
I mention that approach because I expect that free function types belong
to the most natural type categories for every days coders. Potential
candidates in the library are <tt>addressof</tt> and class template <tt>packaged_task</tt>.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Alisdair would prefer to have a core-supported <tt>FunctionType</tt> concept
in order that any future changes be automatically correct
without need for a library solution to catch up;
he points to type traits as a precedent.
Further, he believes that a published concept can't in the future
be changed.
</p>
<p>
Bill feels this category of entity would change sufficiently slowly
that he would be willing to take the risk.
</p>
<p>
Of the discussed solutions, we tend toward option (c).
We like the idea of having a complete taxonomy of native types,
and perhaps erred in trimming the set.
</p>
<p>
We would like to have this issue reviewed by Core and would like
their feedback.  Move to Open.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>
Change in 20.7 [function.objects]/2, Header <tt>&lt;functional&gt;</tt> synopsis:
</p>
<blockquote><pre>// 20.6.16 polymorphic function wrappers:
class bad_function_call;
template&lt;<del>FunctionType</del><ins>ReferentType F</ins>&gt;
<ins>requires PointeeType&lt;F&gt; &amp;&amp; !ObjectType&lt;F&gt;</ins>
class function; // undefined
</pre></blockquote>
</li>
<li>
<p>
Change in 20.7.15.2 [func.wrap.func]:
</p>
<blockquote><pre>namespace std {
template&lt;<del>FunctionType</del><ins>ReferentType F</ins>&gt;
<ins>requires PointeeType&lt;F&gt; &amp;&amp; !ObjectType&lt;F&gt;</ins>
class function; // undefined
</pre></blockquote>
</li>
</ol>





<hr>
<h3><a name="1060"></a>1060. Embedded nulls in NTBS</h3>
<p><b>Section:</b> 17.5.2.1.4.1 [byte.strings] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-13  <b>Last modified:</b> 2009-07-13</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Definition of null-terminated sequences allow for embedded nulls. This is
surprising, and probably not supportable with the intended use cases.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the issue, but believe this can be handled editorially.
Move to NAD Editorial.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1061"></a>1061. Bad indexing for tuple access to pair (Editorial?)</h3>
<p><b>Section:</b> 20.3.5 [pair.astuple] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-13  <b>Last modified:</b> 2009-07-13</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p>
The definition of <tt>get</tt> implies that <tt>get</tt> must return the second element if
given a negative integer.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Move to NAD Editorial.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
20.3.5 [pair.astuple] p5:
</p>

<blockquote><pre>template&lt;<del>int</del> <ins>size_t</ins> I, class T1, class T2&gt; 
  requires True&lt;(I &lt; 2)&gt; 
  const P&amp; get(const pair&lt;T1, T2&gt;&amp;);
</pre>
</blockquote>






<hr>
<h3><a name="1062"></a>1062. Missing insert_iterator for stacks/queues</h3>
<p><b>Section:</b> 24.5.2 [insert.iterators] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-13  <b>Last modified:</b> 2009-10-20</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#insert.iterators">issues</a> in [insert.iterators].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p>
It is odd that we have an iterator to insert into a <tt>vector</tt>, but not an
iterator to insert into a <tt>vector</tt> that is adapted as a <tt>stack</tt>. The standard
container adapters all have a common interface to <tt>push</tt> and <tt>pop</tt> so it should
be simple to create an iterator adapter to complete the library support.
</p>

<p>
We should provide an <tt>AdaptedContainer</tt> concept supporting <tt>push</tt> and <tt>pop</tt>
operations. Create a new insert iterator and factory function that inserts
values into the container by calling <tt>push</tt>.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Walter recommends NAD Future.
</p>
<p>
Move to Open, and recommend deferring the issue until after the next
Committee Draft is issued.
</p>
</blockquote>

<p><i>[
2009-07-29 Howard moves to Tentatively NAD Future.
]</i></p>


<blockquote>
A poll on the LWG reflector voted unanimously to move this issue to Tentatively NAD Future.
</blockquote>

<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote>
Moved to NAD.  The intent of these adapters are to restrict the interfaces.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1063"></a>1063. 03 iterator compatibilty</h3>
<p><b>Section:</b> X [iterator.backward] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-15  <b>Last modified:</b> 2009-07-16</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Which header must a user <tt>#include</tt> to obtain the library-supplied
<tt>concept_maps</tt> declared in this paragraph?
</p>

<p>
This is important information, as existing user code will break if this
header is not included, and we should make a point of mandating this header
is <tt>#include</tt>-d by library headers likely to make use of it, notably
<tt>&lt;algorithm&gt;</tt>.  See issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1001">1001</a> for more details.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the direction of the proposed resolution.
Move to Tentatively Ready.
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
We believe this is NAD Concepts, but this needs to be reviewed against the
post-remove-concepts draft.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p><i>Change  [depr.lib.iterator.primitives], Iterator primitives, as
indicated:</i></p>

<blockquote>
  <p>To simplify the use of iterators and provide backward compatibility with
  previous C++ Standard Libraries,
  the library provides several classes and functions. <ins>Unless otherwise
  specified, these classes and functions shall be defined in header <tt>&lt;iterator&gt;</tt>.</ins></p>
</blockquote>
<p><i>Change X [iterator.backward], Iterator backward compatibility, as
indicated:</i></p>
<blockquote>
  <p>The library provides concept maps that allow iterators specified with
  <tt>iterator_traits</tt> to interoperate with
  algorithms that require iterator concepts. <ins>These concept maps shall be
  defined in the same header that defines the iterator.</ins> [<i>Example:</i></p>
</blockquote>





<hr>
<h3><a name="1064"></a>1064. Response to UK 152</h3>
<p><b>Section:</b> 17.3.15 [defns.obj.state] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-03-15  <b>Last modified:</b> 2009-10-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 152</b></p>

<p>
Object state is using a definition of object (instance of a class) from
outside the standard, rather than the 'region of storage' definiton in
1.8 [intro.object]p1
</p>

<p><i>[
Summit:
]</i></p>

<blockquote>
We think we're removing this; See X [func.referenceclosure.cons].
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Mark as NAD.  This will not affect user or implementer code
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="1067"></a>1067. simplified wording for inner_product</h3>
<p><b>Section:</b> 26.7 [numeric.ops] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-17  <b>Last modified:</b> 2009-07-14</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>

<p>
One of the motivating examples for introducing requirements-aliases was to
simplify the wording of the <tt>inner_product</tt> requirements.  As the paper
adopting the feature and constrained wording for the library went through in
the same meeting, it was not possible to make the change at the time.  The
simpler form should be adopted now though.  Similarly, most the other
numerical algorithms can benefit from a minor cleanup.
</p>
<p>
Note that in each case, the second more generalised form of the algorithm
does not benefit, as there are already named constraints supplied by the
template type parameters.
</p>

<p><i>[
2009-05-02 Daniel adds:
]</i></p>


<blockquote>
<p>
one part of the suggested resolution suggests the removal of the
<tt>MoveConstructible&lt;T&gt;</tt> requirement from
<tt>inner_product</tt>. According to 26.7.2 [inner.product]
</p>

<blockquote>
Computes its result by initializing the accumulator <tt>acc</tt> with the
initial value <tt>init</tt>
</blockquote>

<p>
this step requires at least <tt>MoveConstructible</tt>.
</p>

<p>
Therefore I strongly suggest to take this removal back (Note also
that the corresponding overload with a functor argument still has
the same <tt>MoveConstructible&lt;T&gt;</tt> requirement).
</p>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We agree with the proposed resolution as amended by Daniel's suggestion
to restore <tt>MoveConstructible</tt>,
reflected in the updated proposed resolution below.
</p>
<p>
Move to Tentatively Ready.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change in 26.7 [numeric.ops] and 26.7.1 [accumulate]:
</p>

<blockquote><pre>template &lt;InputIterator Iter, MoveConstructible T&gt;
 requires <ins>add =</ins> HasPlus&lt;T, Iter::reference&gt;
       &amp;&amp; HasAssign&lt;T, <del>HasPlus&lt;T, Iter::reference&gt;</del> <ins>add</ins>::result_type&gt;
 T accumulate(Iter first, Iter last, T init);
</pre></blockquote>

<p>
Change in 26.7 [numeric.ops] and 26.7.2 [inner.product]:
</p>

<blockquote><pre>template &lt;InputIterator Iter1, InputIterator Iter2, MoveConstructible T&gt;
  requires <ins>mult =</ins> HasMultiply&lt;Iter1::reference, Iter2::reference&gt;
        &amp;&amp; <ins>add =</ins> HasPlus&lt;T, <del>HasMultiply&lt;Iter1::reference, Iter2::reference&gt;</del> <ins>mult</ins>::result_type&gt;
        &amp;&amp; HasAssign&lt; 
             T,
             <del>HasPlus&lt;T,
                     HasMultiply&lt;Iter1::reference, Iter2::reference&gt;::result_type&gt;</del> <ins>add</ins>::result_type&gt;
  T inner_product(Iter1 first1, Iter1 last1, Iter2 first2, T init);
</pre></blockquote>

<p>
Change in 26.7 [numeric.ops] and 26.7.3 [partial.sum]:
</p>

<blockquote><pre>template &lt;InputIterator InIter, OutputIterator&lt;auto, const InIter::value_type&amp;&gt; OutIter&gt;
  requires <ins>add =</ins> HasPlus&lt;InIter::value_type, InIter::reference&gt;
        &amp;&amp; HasAssign&lt;InIter::value_type,
                     <del>HasPlus&lt;InIter::value_type, InIter::reference&gt;</del> <ins>add</ins>::result_type&gt;
        &amp;&amp; Constructible&lt;InIter::value_type, InIter::reference&gt;
  OutIter partial_sum(InIter first, InIter last, OutIter result);
</pre></blockquote>

<p>
Change in 26.7 [numeric.ops] and 26.7.4 [adjacent.difference]:
</p>

<blockquote><pre>template &lt;InputIterator InIter, OutputIterator&lt;auto, const InIter::value_type&amp;&gt; OutIter&gt;
  requires <ins>sub =</ins> HasMinus&lt;InIter::value_type, InIter::value_type&gt;
        &amp;&amp; Constructible&lt;InIter::value_type, InIter::reference&gt;
        &amp;&amp; OutputIterator&lt;OutIter, <del>HasMinus&lt;InIter::value_type, InIter::value_type&gt;</del> <ins>sub</ins>::result_type&gt;
        &amp;&amp; MoveAssignable&lt;InIter::value_type&gt;
  OutIter adjacent_difference(InIter first, InIter last, OutIter result);
</pre></blockquote>






<hr>
<h3><a name="1072"></a>1072. Is std::hash a constrained template or not?</h3>
<p><b>Section:</b> 20.7.16 [unord.hash] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-19  <b>Last modified:</b> 2009-07-16</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#unord.hash">active issues</a> in [unord.hash].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#unord.hash">issues</a> in [unord.hash].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Is <tt>std::hash</tt> a constrained template or not?
</p>
<p>
According to Class template hash 20.7.16 [unord.hash], the definition is:
</p>

<blockquote><pre>template &lt;class T&gt;
struct hash : public std::unary_function&lt;T, std::size_t&gt; {
  std::size_t operator()(T val) const;
};
</pre></blockquote>

<p>
And so unconstrained.
</p>
<p>
According to the <tt>&lt;functional&gt;</tt> synopsis in p2 Function objects
20.7 [function.objects] the template is declared as:
</p>

<blockquote><pre>template &lt;ReferentType T&gt; struct hash;
</pre></blockquote>

<p>
which would make hash a constrained template.
</p>

<p><i>[
2009-03-22 Daniel provided wording.
]</i></p>


<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Alisdair is not certain that Daniel's proposed resolution is sufficient,
and recommends we leave the hash template unconstrained for now.
</p>
<p>
Recommend that the Project Editor make the constrained declaration consistent
with the definition in order to make the Working Paper internally consistent,
and that the issue then be revisited.
</p>
<p>
Move to Open.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>

<p>
[To the editor: This resolution is merge-compatible to the
resolution of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1078">1078</a>]
</p>

<ol>
<li>
<p>
In 20.7 [function.objects]/2, header <tt>&lt;functional&gt;</tt> synopsis, change as indicated:
</p>

<blockquote><pre>// 20.6.17, hash function base template:
template &lt;ReferentType T&gt; struct hash; <ins>// undefined</ins>
</pre></blockquote>
</li>
<li>
<p>
In 20.7.16 [unord.hash]/1 change as indicated:
</p>
<blockquote><pre>namespace std {
 <del>template &lt;class T&gt;
 struct hash : public std::unary_function&lt;T, std::size_t&gt; {
 std::size_t operator()(T val) const;
 };</del>
 <ins>template &lt;ReferentType T&gt; struct hash; // undefined</ins>
}
</pre></blockquote>
</li>
<li>
<p>
In 20.7.16 [unord.hash]/2 change as indicated:
</p>

<blockquote>
-2-  <ins>For all library-provided specializations, the template
instantiation <tt>hash&lt;T&gt;</tt>
  shall provide a public <tt>operator()</tt> with return type <tt>std::size_t</tt> to
satisfy the concept
  requirement <tt>Callable&lt;const hash&lt;T&gt;, const T&amp;&gt;</tt>. If <tt>T</tt> is an object
type or reference to
  object, <tt>hash&lt;T&gt;</tt> shall be publicly derived from
<tt>std::unary_function&lt;T, std::size_t&gt;</tt>.
  </ins> The return value of <tt>operator()</tt> is unspecified, except that
equal arguments
  shall yield the same result. <tt>operator()</tt> shall not throw exceptions.
</blockquote>
</li>
<li>
<p>
In 18.7 [support.rtti]/1, header <tt>&lt;typeinfo&gt;</tt> synopsis change as indicated:
</p>
<blockquote><pre>namespace std {
  class type_info;
  class type_index;
  template &lt;<del>class</del><ins>ReferentType</ins> T&gt; struct hash;
</pre></blockquote>
</li>
</ol>





<hr>
<h3><a name="1074"></a>1074. concept map broken by N2840</h3>
<p><b>Section:</b> X [allocator.element.concepts] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-19  <b>Last modified:</b> 2009-07-13</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>

<p>
p7 Allocator-related element concepts X [allocator.element.concepts]
</p>

<p>
The changes to the <tt>AllocatableElement</tt> concept mean this <tt>concept_map</tt>
specialization no longer matches the original concept:
</p>

<blockquote><pre>template &lt;Allocator Alloc, class T, class ... Args&gt;
  requires HasConstructor&lt;T, Args...&gt;
    concept_map AllocatableElement&lt;Alloc, T, Args&amp;&amp;...&gt; {
      void construct_element(Alloc&amp; a, T* t, Args&amp;&amp;... args) {
        Alloc::rebind&lt;T&gt;(a).construct(t, forward(args)...);
      }
    }
</pre></blockquote>

<p><i>[
2009-03-23 Pablo adds:
]</i></p>


<blockquote>
Actually, this is incorrect,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2840.pdf">N2840</a>
says. "In section 
X [allocator.element.concepts] paragraph 8, modify the definition of the
<tt>AllocatableElement</tt> concept and eliminate the related concept map:" but
then neglects to include the red-lined text of the concept map that was
to be eliminated. Pete also missed this, but I caught it he asked me to
review his edits.  Pete's updated WP removes the concept map entirely,
which was the original intent.  The issue is, therefore, moot.  Note, as
per my presentation of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2840.pdf">N2840</a>
in summit, <tt>construct()</tt> no longer has a
default implementation.  This regrettable fact was deemed (by David
Abrahams, Doug, and myself) to be preferable to the complexity of
providing a default implementation that would not under-constrain a more
restrictive allocator (like the scoped allocators).
</blockquote>

<p><i>[
2009-05-01 Daniel adds:
]</i></p>

<blockquote>
<p>
it seems to me that #1074 should be resolved as a NAD, because the
current WP has already removed the previous AllocatableElement concept map.
It introduced auto concept AllocatableElement instead, but as of
X [allocator.element.concepts]/7 this guy contains now
</p>
<blockquote><pre>requires FreeStoreAllocatable&lt;T&gt;;
void Alloc::construct(T*, Args&amp;&amp;...);
</pre></blockquote>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
The affected code is no longer part of the Working Draft.
</p>
<p>
Move to NAD.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change X [allocator.element.concepts]:
</p>

<blockquote><pre>template &lt;Allocator Alloc, class T, class ... Args&gt;
  requires HasConstructor&lt;T, Args...&gt;
    concept_map AllocatableElement&lt;Alloc, T, Args&amp;&amp;...&gt; {
      void construct_element(<del>Alloc&amp; a,</del> T* t, Args&amp;&amp;... args) {
        Alloc::rebind&lt;T&gt;(a).construct(t, forward(args)...);
      }
    }
</pre></blockquote>






<hr>
<h3><a name="1075"></a>1075. Response to US 65, US 74.1</h3>
<p><b>Section:</b> 20 [utilities], 23 [containers] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Alan Talbot <b>Opened:</b> 2009-03-20  <b>Last modified:</b> 2009-10-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#utilities">issues</a> in [utilities].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US 65 and US 74.1</b></p>

<p>US 65:</p>

<blockquote>
Scoped allocators and allocator propagation traits add a small amount of
utility at the cost of a great deal of machinery. The machinery is user
visible, and it extends to library components that don't have any
obvious connection to allocators, including basic concepts and simple
components like <tt>pair</tt> and <tt>tuple</tt>.

<p>Suggested resolution:</p>

<p>
Sketch of proposed resolution: Eliminate scoped allocators, replace
allocator propagation traits with a simple uniform rule (e.g. always
propagate on copy and move), remove all mention of allocators from
components that don't explicitly allocate memory (e.g. pair), and adjust
container interfaces to reflect this simplification.
</p>
<p>
Components that I propose eliminating include HasAllocatorType,
is_scoped_allocator, allocator_propagation_map, scoped_allocator_adaptor,
and ConstructibleAsElement.
</p>
</blockquote>

<p>US 74.1:</p>

<blockquote>
<p>
Scoped allocators represent a poor trade-off for standardization, since
(1) scoped-allocator--aware containers can be implemented outside the
C++ standard library but used with its algorithms, (2) scoped
allocators only benefit a tiny proportion of the C++ community
(since few C++ programmers even use today's allocators), and (3) all C++
users, especially the vast majority of the C++ community that won't ever
use scoped allocators are forced to cope with the interface complexity
introduced by scoped allocators.
</p>
<p>
In essence, the larger community will suffer to support a very small
subset of the community who can already implement their own
data structures outside of the standard library. Therefore, scoped
allocators should be removed from the working paper.
</p>
<p>
Some evidence of the complexity introduced by scoped allocators:
</p>
<blockquote>
<p>
20.3.4 [pairs], 20.5 [tuple]: Large increase in the
number of pair and tuple constructors.
</p>
<p>
23 [containers]: Confusing "AllocatableElement" requirements throughout.
</p>
</blockquote>
<p>Suggested resolution:</p>

<p>
Remove support for scoped allocators from the working paper. This
includes at least the following changes:
</p>

<blockquote>
<p>
Remove X [allocator.element.concepts]
</p>
<p>
Remove 20.8.9 [allocator.adaptor]
</p>
<p>
Remove 20.8.12 [construct.element]
</p>
<p>
In Clause 23 [containers]: replace requirements naming the
<tt>AllocatableElement</tt> concept with requirements naming <tt>CopyConstructible</tt>,
<tt>MoveConstructible</tt>, <tt>DefaultConstructible</tt>, or <tt>Constructible</tt>, as
appropriate.
</p>
</blockquote>

</blockquote>

<p><i>[
Post Summit Alan moved from NAD to Open.
]</i></p>


<p><i>[
2009-05-15 Ganesh adds:
]</i></p>


<blockquote>
<p>
The requirement <tt>AllocatableElement</tt> should not be replaced with
<tt>Constructible</tt> on the <tt>emplace_xxx()</tt> functions as suggested. In the
one-parameter case the <tt>Constructible</tt> requirement is not satisfied when
the constructor is explicit (as per  [concept.map.fct], twelfth
bullet) but we do want to allow explicit constructors in emplace, as the
following example shows:
</p>

<blockquote><pre>vector&lt;shared_ptr&lt;int&gt;&gt; v;
v.emplace_back(new int); <font color="#c80000">// should be allowed</font>
</pre></blockquote>

<p>
If the issue is accepted and scoped allocators are removed, I suggest to
add a new pair of concepts to  [concept.construct], namely:
</p>

<blockquote><pre>auto concept HasExplicitConstructor&lt;typename T, typename... Args&gt; {
 explicit T::T(Args...);
}

auto concept ExplicitConstructible&lt;typename T, typename... Args&gt;
 : HasExplicitConstructor&lt;T, Args...&gt;, NothrowDestructible&lt;T&gt;
{ }
</pre></blockquote>

<p>
We should then use <tt>ExplicitConstructible</tt> as the requirement for all
<tt>emplace_xxx()</tt> member functions.
</p>
<p>
For coherence and consistency with the similar concepts
<tt>Convertible/ExplicitlyConvertible</tt>, we might also consider changing
<tt>Constructible</tt> to:
</p>

<blockquote><pre>auto concept Constructible&lt;typename T, typename... Args&gt;
 : HasConstructor&lt;T, Args...&gt;, ExplicitConstructible&lt;T, Args...&gt;
{ }
</pre></blockquote>

<p>
Moreover, all emplace-related concepts in  [container.concepts]
should also use <tt>ExplicitConstructible</tt> instead of <tt>Constructible</tt> in the
definitions of their axioms. In fact the concepts in  [container.concepts] should be
corrected even if the issue is not accepted.
</p>
<p>
On the other hand, if the issue is not accepted, the scoped allocator
adaptors should be fixed because the following code:
</p>

<blockquote><pre>template &lt;typename T&gt; using scoped_allocator = scoped_allocator_adaptor&lt;allocator&lt;T&gt;&gt;;

vector&lt;shared_ptr&lt;int&gt;, scoped_allocator&lt;shared_ptr&lt;int&gt;&gt;&gt; v;
v.emplace_back(new int); <font color="#c80000">// ops! doesn't compile</font>
</pre></blockquote>

<p>
doesn't compile, as the member function <tt>construct()</tt> of the scoped
allocator requires non-explicit constructors through concept
<tt>ConstructibleWithAllocator</tt>. Fixing that is not difficult but probably
more work than it's worth and is therefore, IMHO, one more reason in
support of the complete removal of scoped allocators.
</p>
</blockquote>

<p><i>[
2009-06-09 Alan adds:
]</i></p>


<blockquote>
<p>
I reopened this issue because I did not think that these National Body
comments were adequately addressed by marking them NAD. My understanding
is that something can be marked NAD if it is clearly a misunderstanding
or trivial, but a substantive issue that has any technical merit
requires a disposition that addresses the concerns.
</p>
<p>
The notes in the NB comment list (US 65 &amp; US 74.1) say that:
</p>
<ol type="a">
<li>
this issue has not introduced any new arguments not previously discussed,
</li>
<li>
the vote (4-9-3) was not a consensus for removing scoped allocators,
</li>
<li>
the issue is resolved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2840.pdf">N2840</a>.
</li>
</ol>
<p>
My opinion is:
</p>
<ol type="a">
<li>
there are new arguments in both comments regarding concepts (which were
not present in the library when the scoped allocator proposal was voted
in),
</li>
<li>
the vote was clearly not a consensus for removal, but just saying there
was a vote does not provide a rationale,
</li>
<li>
I do not believe that N2840 addresses these comments (although it does
many other things and was voted in with strong approval).
</li>
</ol>

<p>
My motivation to open the issue was to ensure that the NB comments were
adequately addressed in a way that would not risk a "no" vote on our
FCD. If there are responses to the technical concerns raised, then
perhaps they should be recorded. If the members of the NB who authored
the comments are satisfied with N2840 and the other disposition remarks
in the comment list, then I am sure they will say so. In either case,
this issue can be closed very quickly in Frankfurt, and hopefully will
have helped make us more confident of approval with little effort. If in
fact there is controversy, my thought is that it is better to know now
rather than later so there is more time to deal with it.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD Editorial.  Addressed by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2982.pdf">N2982</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
Scoped allocators have been revised significantly.





<hr>
<h3><a name="1077"></a>1077. Nonesense <tt>tuple</tt> declarations</h3>
<p><b>Section:</b> 20.5.2 [tuple.tuple] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2009-03-20  <b>Last modified:</b> 2009-07-13</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#tuple.tuple">issues</a> in [tuple.tuple].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Class template tuple 20.5.2 [tuple.tuple]:
</p>

<blockquote><pre>template &lt;class... UTypes&gt;
  requires Constructible&lt;Types, const UTypes&amp;&gt;...
template &lt;class... UTypes&gt;
  requires Constructible&lt;Types, RvalueOf&lt;UTypes&gt;::type&gt;...
</pre></blockquote>

<p>
Somebody needs to look at this and say what it should be.
</p>

<p><i>[
2009-03-21 Daniel provided wording.
]</i></p>


<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
The resolution looks correct; move to NAD Editorial.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
In 20.5.2 [tuple.tuple], class <tt>tuple</tt>, change as indicated:
</p>

<blockquote><pre>template &lt;class... UTypes&gt;
  requires Constructible&lt;Types, const UTypes&amp;&gt;...
  <ins>tuple(const pair&lt;UTypes...&gt;&amp;);</ins>
template &lt;class... UTypes&gt;
  requires Constructible&lt;Types, RvalueOf&lt;UTypes&gt;::type&gt;...
  <ins>tuple(pair&lt;UTypes...&gt;&amp;&amp;);</ins>
</pre></blockquote>

<p>
[NB.: The corresponding prototypes do already exist in 20.5.2.1 [tuple.cnstr]/7+8]
</p>





<hr>
<h3><a name="1078"></a>1078. DE-17: Remove class type_index</h3>
<p><b>Section:</b> 20.11 [type.index] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Concepts">NAD Concepts</a>
 <b>Submitter:</b> Doug Gregor <b>Opened:</b> 2009-03-20  <b>Last modified:</b> 2009-07-16</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses DE 17</b></p>

<p>
DE-17: 
</p>
<p>
The class <tt>type_index</tt> should be removed; it provides no additional
functionality beyond providing appropriate concept maps.
</p>

<p><i>[
2009-03-31 Peter adds:
]</i></p>


<blockquote>
<p>
It is not true, in principle, that <tt>std::type_index</tt> provides no  utility
compared to bare <tt>std::type_info*</tt>.
</p>
<p>
<tt>std::type_index</tt> can avoid the lifetime issues with <tt>type_info</tt> when  the
DLL that has produced the <tt>type_info</tt> object is unloaded. A raw
<tt>type_info*</tt> does not, and cannot, provide any protection in this  case.
A <tt>type_index</tt> can (if the implementor so chooses) because it  can wrap a
smart (counted or even cloning) pointer to the <tt>type_info</tt>  data that is
needed for <tt>name()</tt> and <tt>before()</tt> to work.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>Modify the header &lt;typeinfo&gt; synopsis in 
  18.7 [support.rtti]p1 as follows:</p>

<blockquote><pre>namespace std { 
  class type_info; 
  <del>class type_index;</del>
  template &lt;class T&gt; struct hash;
  template&lt;&gt; struct hash&lt;<del>type_index</del><ins>const type_info *</ins>&gt; : public std::unary_function&lt;<del>type_index</del><ins>const type_info *</ins>, size_t&gt; {
    size_t operator()(<del>type_index</del><ins>const type_info *</ins> <del>index</del><ins>t</ins>) const;
  }<ins>;</ins>
  <ins>concept_map LessThanComparable&lt;const type_info *&gt; <i>see below</i></ins>
  class bad_cast; 
  class bad_typeid;
}
</pre></blockquote>

<p>Add the following new subsection</p>
<blockquote>
<p>
<ins>18.7.1.1 Template specialization <code>hash&lt;const type_info *&gt;</code>
[type.info.hash]</ins></p>

<pre><ins>size_t operator()(const type_info *x) const;</ins>
</pre>
<ol>
<li><ins><i>Returns</i>: <code>x-&gt;hash_code()</code></ins></li>
</ol>
</blockquote>

 <p>Add the following new subsection</p>
 <blockquote>
<p><ins>18.7.1.2 <code>type_info</code> concept map [type.info.concepts]</ins></p>


<pre><ins>concept_map LessThanComparable&lt;const type_info *&gt; {</ins>
  <ins>bool operator&lt;(const type_info *x, const type_info *y) { return x-&gt;before(*y); }</ins>
  <ins>bool operator&lt;=(const type_info *x, const type_info *y) { return !y-&gt;before(*x); }</ins>
  <ins>bool operator&gt;(const type_info *x, const type_info *y) { return y-&gt;before(*x); }</ins>
  <ins>bool operator&gt;=(const type_info *x, const type_info *y) { return !x-&gt;before(*y); }</ins>
<ins>}</ins>
</pre>
<ol>
  <li><ins><i>Note</i>: provides a well-defined ordering among
  <code>type_info const</code> pointers, which makes such pointers
  usable in associative containers (23.4).</ins></li>
</ol>
</blockquote>

<p>Remove section 20.11 [type.index]</p>





<hr>
<h3><a name="1080"></a>1080. Concept ArithmeticLike should provide explicit boolean  conversion</h3>
<p><b>Section:</b> X [concept.arithmetic] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Concepts">NAD Concepts</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2009-03-21  <b>Last modified:</b> 2009-07-15</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Astonishingly, the current concept ArithmeticLike as specified in
X [concept.arithmetic] does not provide explicit conversion
to <tt>bool</tt> although this is a common property of arithmetic types
(4.12 [conv.bool]). Recent proposals that introduced such types
(integers of arbitrary precision,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2143.pdf">n2143</a>,
decimals
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2732.pdf">n2732</a>
indirectly
via conversion to <tt>long long</tt>) also took care of such a feature.
</p>
<p>
Adding such an explicit conversion associated function would also
partly solve a currently invalid effects clause in library, which bases
on this property, 24.2.5 [random.access.iterators]/2:
</p>
<blockquote><pre>{ difference_type m = n;
 if (m &gt;= 0) while (m--) ++r;
 else while (m++) --r;
 return r; }
</pre></blockquote>

<p>
Both while-loops take advantage of a contextual conversion to <tt>bool</tt>
(Another problem is that the &gt;= comparison uses the no
longer supported existing implicit conversion from <tt>int</tt> to <tt>IntegralLike</tt>).
</p>

<b>Original proposed resolution:</b>
<ol>
<li>
<p>
In X [concept.arithmetic], add to the list of less refined
concepts one further concept:
</p>

<blockquote><pre>concept ArithmeticLike&lt;typename T&gt;
  : Regular&lt;T&gt;, LessThanComparable&lt;T&gt;, HasUnaryPlus&lt;T&gt;, HasNegate&lt;T&gt;,
    HasPlus&lt;T, T&gt;, HasMinus&lt;T, T&gt;, HasMultiply&lt;T, T&gt;, HasDivide&lt;T, T&gt;,
    HasPreincrement&lt;T&gt;, HasPostincrement&lt;T&gt;, HasPredecrement&lt;T&gt;,
    HasPostdecrement&lt;T&gt;,
    HasPlusAssign&lt;T, const T&amp;&gt;, HasMinusAssign&lt;T, const T&amp;&gt;,
    HasMultiplyAssign&lt;T, const T&amp;&gt;,
    HasDivideAssign&lt;T, const T&amp;&gt;<ins>, ExplicitlyConvertible&lt;T, bool&gt;</ins> {
</pre></blockquote>
</li>
<li>
<p>
In 24.2.5 [random.access.iterators]/2 change the current effects clause
as indicated [The proposed insertion fixes the problem that the previous
implicit construction from integrals has been changed to an explicit
constructor]:
</p>
<blockquote><pre>{ difference_type m = n;
 if (m &gt;= <ins>difference_type(</ins>0<ins>)</ins>) while (m--) ++r;
 else while (m++) --r;
 return r; }
</pre></blockquote>
</li>
</ol>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We agree that arithmetic types ought be convertible to <tt>bool</tt>,
and we therefore agree with the proposed resolution's paragraph 1.
</p>
<p>
We do not agree that the cited effects clause is invalid,
as it expresses intent rather than specific code.
</p>
<p>
Move to Review, pending input from concepts experts.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
In X [concept.arithmetic], add to the list of less refined
concepts one further concept:
</p>

<blockquote><pre>concept ArithmeticLike&lt;typename T&gt;
  : Regular&lt;T&gt;, LessThanComparable&lt;T&gt;, HasUnaryPlus&lt;T&gt;, HasNegate&lt;T&gt;,
    HasPlus&lt;T, T&gt;, HasMinus&lt;T, T&gt;, HasMultiply&lt;T, T&gt;, HasDivide&lt;T, T&gt;,
    HasPreincrement&lt;T&gt;, HasPostincrement&lt;T&gt;, HasPredecrement&lt;T&gt;,
    HasPostdecrement&lt;T&gt;,
    HasPlusAssign&lt;T, const T&amp;&gt;, HasMinusAssign&lt;T, const T&amp;&gt;,
    HasMultiplyAssign&lt;T, const T&amp;&gt;,
    HasDivideAssign&lt;T, const T&amp;&gt;<ins>, ExplicitlyConvertible&lt;T, bool&gt;</ins> {
</pre></blockquote>





<hr>
<h3><a name="1081"></a>1081. Response to UK 216</h3>
<p><b>Section:</b> 21 [strings] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Concepts">NAD Concepts</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-03-22  <b>Last modified:</b> 2009-07-15</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#strings">issues</a> in [strings].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses UK 216, JP 46, JP 48</b></p>

<p>
All the containers use concepts for their iterator usage, exect for
<tt>basic_string</tt>. This needs fixing.
</p>

<p>
Use concepts for iterator template parameters throughout the chapter.
</p>

<p><i>[
Summit:
]</i></p>

<blockquote>
NB comments to be handled by Dave Abrahams and Howard Hinnant with
advice from PJP: UK216 (which duplicates) JP46, JP48. JP46 supplies
extensive proposed wording; start there.
</blockquote>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1082"></a>1082. Response to JP 49</h3>
<p><b>Section:</b> 22 [localization] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Concepts">NAD Concepts</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-03-22  <b>Last modified:</b> 2009-07-15</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#localization">issues</a> in [localization].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses JP 49</b></p>

<p>
<tt>codecvt</tt> does not use concept. For example, create <tt>CodeConvert</tt>
concept and change as follows.
</p>

<blockquote><pre>template&lt;CodeConvert Codecvt, class Elem = wchar_t&gt;
  class wstring_convert {
</pre></blockquote>

<p><i>[
Summit:
]</i></p>

<blockquote>
To be handled by Howard Hinnant, Dave Abrahams, Martin Sebor, PJ Plauger.
</blockquote>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1083"></a>1083. Response to JP 52, 53</h3>
<p><b>Section:</b> 22 [localization] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Concepts">NAD Concepts</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-03-22  <b>Last modified:</b> 2009-07-15</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#localization">issues</a> in [localization].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses JP 52, JP 53</b></p>

<p>
<tt>InputIterator</tt> does not use concept.
</p>

<p>
<tt>OutputIterator</tt> does not use concept.
</p>

<p>
Comments include proposed wording.
</p>

<p><i>[
Summit:
]</i></p>

<blockquote>
To be handled by Howard Hinnant, Dave Abrahams, Martin Sebor, PJ Plauger.
</blockquote>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1084"></a>1084. Response to UK 250</h3>
<p><b>Section:</b> 24.2.3 [forward.iterators] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Concepts">NAD Concepts</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-03-22  <b>Last modified:</b> 2009-07-16</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#forward.iterators">issues</a> in [forward.iterators].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses UK 250</b></p>

<p>
A default implementation should be supplied for the post-increment
operator to simplify implementation of iterators by users.
</p>

<p>
Copy the Effects clause into the concept description as the default
implementation. Assumes a default value for postincrement_result
</p>

<p><i>[
Summit:
]</i></p>

<blockquote>
Howard will open an issue.
</blockquote>

<p><i>[
2009-06-07 Daniel adds:
]</i></p>


<blockquote>
This issue cannot currently be resolved as suggested, because
that would render auto-detection of the return type
<tt>postincrement_result</tt> invalid, see  [concept.map.assoc]/4+5. The
best fix would be to add a default type to that associated type, but
unfortunately any default type will prevent auto-deduction of types of
associated functions as quoted above. A corresponding core issue
is in preparation.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p><i>[
This wording assumes the acceptance of UK 251 / <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1009">1009</a>.  Both
wordings change the same paragraphs.
]</i></p>


<p>
Change 24.2.3 [forward.iterators]:
</p>

<blockquote>
<pre>concept ForwardIterator&lt;typename X&gt; : InputIterator&lt;X&gt;, Regular&lt;X&gt; { 

  MoveConstructible postincrement_result;
  requires HasDereference&lt;postincrement_result&gt;
        &amp;&amp; Convertible&lt;HasDereference&lt;postincrement_result&gt;::result_type, const value_type&amp;&gt;;

  postincrement_result operator++(X&amp; r, int)<del>;</del> <ins>{
     X tmp = r;
     ++r;
     return tmp;
  }</ins>

  axiom MultiPass(X a, X b) { 
    if (a == b) *a == *b; 
    if (a == b) ++a == ++b; 
  } 
}
</pre></blockquote>






<hr>
<h3><a name="1085"></a>1085. Response to UK 258</h3>
<p><b>Section:</b> 24.2.4 [bidirectional.iterators] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Concepts">NAD Concepts</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-03-22  <b>Last modified:</b> 2009-07-16</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#bidirectional.iterators">issues</a> in [bidirectional.iterators].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses UK 258</b></p>

<p>
A default implementation should be supplied for the post-decrement
operator to simplify implementation of iterators by users.
</p>

<p>
Copy the Effects clause into the concept description as the default
implementation. Assumes a default value for postincrement_result
</p>

<p><i>[
Summit:
]</i></p>

<blockquote>
Howard will open an issue.
</blockquote>

<p><i>[
2009-06-07 Daniel adds:
]</i></p>


<blockquote>
This issue cannot currently be resolved as suggested, because
that would render auto-detection of the return type
<tt>postdecrement_result</tt> invalid, see <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1084">1084</a>.
</blockquote>


<p><b>Proposed resolution:</b></p>

<p>
Change 24.2.4 [bidirectional.iterators]:
</p>

<blockquote>
<pre>concept BidirectionalIterator&lt;typename X&gt; : ForwardIterator&lt;X&gt; { 
  MoveConstructible postdecrement_result; 
  requires HasDereference&lt;postdecrement_result&gt; 
        &amp;&amp; Convertible&lt;HasDereference&lt;postdecrement_result&gt;::result_type, const value_type&amp;&gt; 
        &amp;&amp; Convertible&lt;postdecrement_result, const X&amp;&gt;; 
  X&amp; operator--(X&amp;); 
  postdecrement_result operator--(X&amp; <ins>r</ins>, int)<del>;</del> <ins>{
     X tmp = r;
     --r;
     return tmp;
  }</ins>
}
</pre></blockquote>






<hr>
<h3><a name="1086"></a>1086. Response to UK 284</h3>
<p><b>Section:</b> 24.6 [stream.iterators] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Concepts">NAD Concepts</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-03-22  <b>Last modified:</b> 2009-07-15</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses UK 284</b></p>

<p>
The stream iterators need constraining with concepts/requrires clauses.
</p>

<p><i>[
Summit:
]</i></p>

<blockquote>
We agree. To be handled by Howard, Martin and PJ.
</blockquote>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1087"></a>1087. Response to UK 301</h3>
<p><b>Section:</b> 25.3.5 [alg.replace] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Concepts">NAD Concepts</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-03-22  <b>Last modified:</b> 2009-07-15</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.replace">issues</a> in [alg.replace].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses UK 301</b></p>

<p>
<tt>replace</tt> and <tt>replace_if</tt> have the requirement: <tt>OutputIterator&lt;Iter,
Iter::reference&gt;</tt> Which implies they need to copy some values in the
range the algorithm is iterating over. This is not however the case, the
only thing that happens is <tt>const T&amp;</tt>s might be copied over existing
elements (hence the <tt>OutputIterator&lt;Iter, const T&amp;&gt;</tt>.
</p>

<p>
Remove <tt>OutputIterator&lt;Iter, Iter::reference&gt;</tt> from <tt>replace</tt>
and <tt>replace_if</tt>.
</p>

<p><i>[
Summit:
]</i></p>

<blockquote>
We agree. To be handled by Howard.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change in  [algorithms.syn] and 25.3.5 [alg.replace]:
</p>

<blockquote><pre>template&lt;ForwardIterator Iter, class T&gt; 
  requires <del>OutputIterator&lt;Iter, Iter::reference&gt; 
        &amp;&amp;</del> OutputIterator&lt;Iter, const T&amp;&gt; 
        &amp;&amp; HasEqualTo&lt;Iter::value_type, T&gt; 
  void replace(Iter first, Iter last, 
               const T&amp; old_value, const T&amp; new_value); 

template&lt;ForwardIterator Iter, Predicate&lt;auto, Iter::value_type&gt; Pred, class T&gt; 
  requires <del>OutputIterator&lt;Iter, Iter::reference&gt; 
        &amp;&amp;</del> OutputIterator&lt;Iter, const T&amp;&gt; 
        &amp;&amp; CopyConstructible&lt;Pred&gt; 
  void replace_if(Iter first, Iter last,
                  Pred pred, const T&amp; new_value);
</pre></blockquote>





<hr>
<h3><a name="1088"></a>1088. Response to UK 342</h3>
<p><b>Section:</b> 30.6.5 [futures.promise] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-03-22  <b>Last modified:</b> 2009-10-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#futures.promise">issues</a> in [futures.promise].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses UK 342</b></p>

<p>
<tt>std::promise</tt> is missing a non-member overload of <tt>swap</tt>. This is
inconsistent with other types that provide a <tt>swap</tt> member function.
</p>

<p>
Add a non-member overload <tt>void swap(promise&amp;&amp; x,promise&amp;&amp; y){ x.swap(y); }</tt>
</p>

<p><i>[
Summit:
]</i></p>

<blockquote>
Create an issue. Move to review, attention: Howard. Detlef will also
look into it.
</blockquote>

<p><i>[
Post Summit Daniel provided wording.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD Editorial.  Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2997.html">N2997</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>
In 30.6.5 [futures.promise], before p.1, immediately after class template
promise add:
</p>
<blockquote><pre><ins>
template &lt;class R&gt;
void swap(promise&lt;R&gt;&amp; x, promise&lt;R&gt;&amp; y);
</ins>
</pre></blockquote>
</li>
<li>
<p>
Change 30.6.5 [futures.promise]/10 as indicated (to fix a circular definition):
</p>
<blockquote>
<p>
-10- <i>Effects:</i> <del>swap(*this, other)</del><ins>Swaps the associated state
of <tt>*this</tt> and <tt>other</tt></ins>
</p>
<p>
<ins><i>Throws:</i> Nothing.</ins>
</p>
</blockquote>
</li>
<li>
<p>
After the last paragraph in 30.6.5 [futures.promise] add the following
prototype description:
</p>
<blockquote><pre><ins>
template &lt;class R&gt;
void swap(promise&lt;R&gt;&amp; x, promise&lt;R&gt;&amp; y);
</ins></pre>
<blockquote>
<p>
<ins><i>Effects:</i> <tt>x.swap(y)</tt></ins>
</p>
<p>
<ins><i>Throws:</i> Nothing.</ins>
</p>
</blockquote>
</blockquote>
</li>

</ol>






<hr>
<h3><a name="1091"></a>1091. Multimap description confusing</h3>
<p><b>Section:</b> 23.4.2.2 [multimap.modifiers] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> LWG <b>Opened:</b> 2009-03-22  <b>Last modified:</b> 2009-10-20</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 246</b></p>
<p>
The content of this sub-clause is purely trying to describe in words the
effect of the requires clauses on these operations, now that we have
Concepts. As such, the description is more confusing than the signature
itself. The semantic for these functions is adequately covered in the
requirements tables in 23.2.4 [associative.reqmts].
</p>

<p><i>[
Beman adds:
]</i></p>


<blockquote>
Pete is clearly right that
this one is technical rather than editorial.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We agree with the proposed resolution.
</p>
<p>
Move to Review.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Mark as NAD, solved by removing concepts.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Strike 23.4.2.2 [multimap.modifiers] entirely
(but do NOT strike these signatures from the class template definition!).
</p>





<hr>
<h3><a name="1092"></a>1092. Class template <tt>integral_constant</tt> should be a  constrained template</h3>
<p><b>Section:</b> 20.6.3 [meta.help] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Concepts">NAD Concepts</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2009-03-22  <b>Last modified:</b> 2009-07-15</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#meta.help">issues</a> in [meta.help].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p>
A first step to change the type traits predicates to constrained templates is to
constrain their common base template <tt>integral_constant</tt>. This can be done,
without enforcing depending classes to be constrained as well, but not
vice versa
without brute force <tt>late_check</tt> usages. The following proposed resolution depends
on the resolution of LWG issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1019">1019</a>.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Move to Open, pending a paper that looks at constraints
for the entirety of the type traits
and their relationship to the foundation concepts.
We recommend this be deferred
until after the next Committee Draft is issued.
</blockquote>


<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>
In 20.6.2 [meta.type.synop], Header <tt>&lt;type_traits&gt;</tt>
synopsis change as indicated:
</p>
<blockquote><pre>namespace std {
// 20.5.3, helper class:
template &lt;<del>class</del><ins>IntegralConstantExpressionType</ins> T, T v&gt; struct integral_constant;
</pre></blockquote>
</li>
<li>
<p>
In 20.6.3 [meta.help] change as indicated:
</p>
<blockquote><pre>template &lt;<del>class</del><ins>IntegralConstantExpressionType</ins> T, T v&gt;
struct integral_constant {
  static constexpr T value = v;
  typedef T value_type;
  typedef integral_constant&lt;T,v&gt; type;
  constexpr operator value_type() { return value; }
};
</pre></blockquote>
</li>
</ol>





<hr>
<h3><a name="1096"></a>1096. unconstrained rvalue ref parameters</h3>
<p><b>Section:</b> 17 [library] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Concepts">NAD Concepts</a>
 <b>Submitter:</b> David Abrahams <b>Opened:</b> 2009-03-21  <b>Last modified:</b> 2009-07-16</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p>
TODO: Look at all cases of unconstrained rvalue ref parameters and check
that concept req'ts work when <tt>T</tt> deduced as reference.
</p>

<p>
 We found some instances where that was not done correctly and we figure
   the possibility of deducing <tt>T</tt> to be an lvalue reference was probably
   overlooked elsewhere.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Move to Open, pending proposed wording from Dave for further review.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="1101"></a>1101. <tt>unique</tt> requirements</h3>
<p><b>Section:</b> 25.3.9 [alg.unique] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-04-25  <b>Last modified:</b> 2009-07-13</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.unique">issues</a> in [alg.unique].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
From Message c++std-core-14160 Howard wrote:
</p>

<blockquote>
It was the intent of the rvalue reference proposal for unique to only require MoveAssignable:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1860.html#25.2.9%20-%20Unique">N1860</a>.
</blockquote>

<p>
And Pete replied:
</p>

<blockquote>
That was overridden by the subsequent changes made for concepts in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2573.pdf">N2573</a>,
which reimposed the C++03 requirements.
</blockquote>

<p>
My impression is that this overwrite was a simple (unintentional) mistake.
Wording below to correct it.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Howard notes this issue resolves a discrepancy between the synopsis
and the description.
</p>
<p>
Move to NAD Editorial.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 25.3.9 [alg.unique]:
</p>

<blockquote><pre>template&lt;ForwardIterator Iter&gt; 
  requires OutputIterator&lt;Iter, <ins>RvalueOf&lt;</ins>Iter::reference<ins>&gt;::type</ins>&gt; 
        &amp;&amp; EqualityComparable&lt;Iter::value_type&gt; 
  Iter unique(Iter first, Iter last); 

template&lt;ForwardIterator Iter, EquivalenceRelation&lt;auto, Iter::value_type&gt; Pred&gt; 
  requires OutputIterator&lt;Iter, RvalueOf&lt;Iter::reference&gt;::type&gt; 
        &amp;&amp; CopyConstructible&lt;Pred&gt; 
  Iter unique(Iter first, Iter last, Pred pred);
</pre></blockquote>

<p>
Note that the synopsis in  [algorithms.syn] is already correct.
</p>






<hr>
<h3><a name="1102"></a>1102. <tt>std::vector</tt>'s reallocation policy still unclear</h3>
<p><b>Section:</b> 23.3.6.2 [vector.capacity] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2009-04-20  <b>Last modified:</b> 2009-10-20</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#vector.capacity">issues</a> in [vector.capacity].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I have the impression that even the wording of current draft
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2857.pdf">N2857</a>
does insufficiently express the intent of <tt>vector</tt>'s
reallocation strategy. This has produced not too old library
implementations which release memory in the <tt>clear()</tt> function
and even modern articles about C++ programming cultivate
the belief that <tt>clear</tt> is allowed to do exactly this. A typical
example is something like this:
</p>

<blockquote><pre>const int buf_size = ...;
std::vector&lt;T&gt; buf(buf_size);
for (int i = 0; i &lt; some_condition; ++i) {
  buf.resize(buf_size);
  write_or_read_data(buf.data());
  buf.clear(); // Ensure that the next round get's 'zeroed' elements
}
</pre></blockquote>
<p>
where still the myth is ubiquitous that <tt>buf</tt> might be
allowed to reallocate it's memory *inside* the <tt>for</tt> loop.
</p>
<p>
IMO the problem is due to the fact, that
</p>

<ol type="a">
<li>
the actual memory-reallocation stability of <tt>std::vector</tt>
is explained in 23.3.6.2 [vector.capacity]/3 and /6 which
are describing just the effects of the <tt>reserve</tt>
function, but in many examples (like above) there
is no explicit call to <tt>reserve</tt> involved. Further-more
23.3.6.2 [vector.capacity]/6 does only mention <em>insertions</em>
and never mentions the consequences of erasing
elements.
</li>
<li>
<p>
the effects clause of <tt>std::vector</tt>'s <tt>erase</tt> overloads in
23.3.6.4 [vector.modifiers]/4 is silent about capacity changes. This
easily causes a misunderstanding, because the counter
parting insert functions described in 23.3.6.4 [vector.modifiers]/2
explicitly say, that
</p>
<blockquote>
Causes reallocation if the new size is greater than the
old capacity. If no reallocation happens, all the iterators
and references before the insertion point remain valid.
</blockquote>
<p>
It requires a complex argumentation chain about four
different places in the standard to provide the - possibly
weak - proof that calling <tt>clear()</tt> also does <em>never</em> change
the capacity of the <tt>std::vector</tt> container. Since <tt>std::vector</tt>
is the de-facto replacement of C99's dynamic arrays this
type is near to a built-in type and it's specification should
be clear enough that usual programmers can trust their
own reading.
</p>
</li>
</ol>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Bill believes paragraph 1 of the proposed resolution is unnecessary
because it is already implied (even if tortuously) by the current wording.
</p>
<p>
Move to Review.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Mark as NAD. Rationale: there is no consensus to clarify the standard,
general consensus that the standard is correct as written.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p><i>[
This is a minimum version. I also
suggest that the wording explaining the allocation strategy
of <tt>std::vector</tt> in 23.3.6.2 [vector.capacity]/3 and /6 is moved into
a separate sub paragraph of 23.3.6.2 [vector.capacity] <em>before</em>
any of the prototype's are discussed, but I cannot provide
reasonable wording changes now
]</i></p>


<ol>
<li>
<p>
Change 23.3.6.2 [vector.capacity]/6 as follows:
</p>
<blockquote>
It is guaranteed that no reallocation takes place during
insertions <ins>or erasures</ins> that happen after a call
to <tt>reserve()</tt> until the time when an insertion would make
the size of the vector greater than the value of <tt>capacity()</tt>.
</blockquote>
</li>
<li>
<p>
Change 23.3.6.4 [vector.modifiers]/4 as follows:
</p>
<blockquote>
<i>Effects:</i> <ins>The capacity shall remain unchanged and no reallocation shall
happen.</ins>
Invalidates iterators and references at or after the point
of the erase.
</blockquote>
</li>
</ol>





<hr>
<h3><a name="1105"></a>1105. Shouldn't <tt>Range</tt> be an <tt>auto concept</tt></h3>
<p><b>Section:</b> X [iterator.concepts.range] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Concepts">NAD Concepts</a>
 <b>Submitter:</b> David Abrahams <b>Opened:</b> 2009-04-23  <b>Last modified:</b> 2009-07-15</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>

<p><i>[
2009-04-26 Herb adds:
]</i></p>


<blockquote>
<p>
Here's a common example: We have many ISV customers who have built lots of
in-house STL-like containers. Imagine that, for the past ten years, the user
has been happily using his <tt>XYZCorpContainer&lt;T&gt;</tt> that has <tt>begin()</tt> and <tt>end()</tt>
and an iterator typedef, and indeed satisfies nearly all of <tt>Container</tt>,
though maybe not quite all just like <tt>valarray</tt>. The user upgrades to a
range-enabled version of a library, and now <tt>lib_algo( xyz.begin(), xyz.end());</tt>
no longer works -- compiler error.
</p>
<p>
Even though <tt>XYZCorpContainer</tt> matches the pre-conceptized version of the
algorithm, and has been working for years, it appears the user has to write
at least this:
</p>
<blockquote><pre>template&lt;class T&gt; concept_map Range&lt;XYZCorpContainer&lt;T&gt;&gt; {};

template&lt;class T&gt; concept_map Range&lt;const XYZCorpContainer&lt;T&gt;&gt; {};
</pre></blockquote>
<p>
Is that correct?
</p>
<p>
But he may actually have to write this as we do for initializer list:
</p>
<blockquote><pre>template&lt;class T&gt;
concept_map Range&lt;XYZCorpContainer&lt;T&gt;&gt; {
   typedef T* iterator;
   iterator begin(XYZCorpContainer&lt;T&gt; c) { return c.begin(); }
   iterator end(XYZCorpContainer&lt;T&gt; c) { return c.end(); }
};

template&lt;class T&gt;
concept_map Range&lt;const XYZCorpContainer&lt;T&gt;&gt; {
   typedef T* iterator;
   iterator begin(XYZCorpContainer&lt;T&gt; c) { return c.begin(); }
   iterator end(XYZCorpContainer&lt;T&gt; c) { return c.end(); }
};
</pre></blockquote>

</blockquote>

<p><i>[
2009-04-28 Alisdair adds:
]</i></p>


<blockquote>
<p>
I recommend NAD, although remain concerned about header organisation.
</p>
<p>
A user container will satisfy the <tt>MemberContainer</tt> concept, which IS auto.
There is a concept_map for all <tt>MemberContainers</tt> to <tt>Container</tt>, and then a
further concept_map for all <tt>Container</tt> to <tt>Range</tt>, so the stated problem is not
actually true.  User defined containers will automatically match the <tt>Range</tt>
concept without explicitly declaring a concept_map.
</p>
<p>
The problem is that they should now provide an additional two headers,
<tt>&lt;iterator_concepts&gt;</tt> and <tt>&lt;container_concepts&gt;</tt>.
 The only difference from
making <tt>Range</tt> an auto concept would be this reduces to a single header,
<tt>&lt;iterator_concepts&gt;</tt>.
</p>
<p>
I am strongly in favour of any resolution that tackles the issue of
explicitly requiring concept headers to make these concept maps available.
</p>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We observe there is a recent paper by Bjarne that overlaps this issue.
</p>
<p>
Alisdair continues to recommend NAD.
</p>
<p>
Move to Open, and recommend the issue be deferred until after the next
Committee Draft is issued.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1107"></a>1107. constructor <tt>shared_future(unique_future)</tt> by value?</h3>
<p><b>Section:</b> 30.6.7 [future.shared_future] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Thomas J. Gritzan <b>Opened:</b> 2009-04-03  <b>Last modified:</b> 2009-07-13</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#future.shared_future">issues</a> in [future.shared_future].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In the <tt>shared_future</tt> class definition in 30.6.7 [future.shared_future]
the move constructor 
that constructs a <tt>shared_future</tt> from an <tt>unique_future</tt> receives the 
parameter by value. In paragraph 3, the same constructor receives it as 
const value. 
</p>

<p>
I think that is a mistake and the constructor should take a r-value 
reference: 
</p>

<blockquote><pre>shared_future(unique_future&lt;R&gt;&amp;&amp; rhs);
</pre></blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We agree with the proposed resolution.
</p>
<p>
Move to Tentatively Ready.
</p>
</blockquote>

<p><i>[
2009-07-05 Daniel notes:
]</i></p>


<blockquote>
The proposed change has already been incorported into the current working draft
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2914.pdf">N2914</a>.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change the synopsis in 30.6.7 [future.shared_future]:
</p>

<blockquote><pre>shared_future(unique_future&lt;R&gt;<ins>&amp;&amp;</ins> rhs);
</pre></blockquote>

<p>
Change the definition of the constructor in 30.6.7 [future.shared_future]:
</p>

<blockquote><pre>shared_future(<del>const</del> unique_future&lt;R&gt;<ins>&amp;&amp;</ins> rhs);
</pre></blockquote>






<hr>
<h3><a name="1109"></a>1109. <tt>std::includes</tt> should require <tt>CopyConstructible</tt> predicate</h3>
<p><b>Section:</b> 25.4.5.1 [includes] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-04-28  <b>Last modified:</b> 2009-07-13</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#includes">issues</a> in [includes].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p>
All the set operation algorithms require a <tt>CopyConstructible</tt> predicate, with
the exception of <tt>std::includes</tt>.  This looks like a typo as much as anything,
given the general library requirement that predicates are copy
constructible, and wording style of other set-like operations.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution.
Move to NAD Editorial.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change  [algorithms.syn] and 25.4.5.1 [includes]:
</p>

<blockquote><pre>template&lt;InputIterator Iter1, InputIterator Iter2,
         <del>typename</del> <ins>CopyConstructible</ins> Compare&gt;
  requires Predicate&lt;Compare, Iter1::value_type, Iter2::value_type&gt;
        &amp;&amp; Predicate&lt;Compare, Iter2::value_type, Iter1::value_type&gt;
  bool includes(Iter1 first1, Iter1 last1,
                Iter2 first2, Iter2 last2,
                Compare comp);
</pre></blockquote>





<hr>
<h3><a name="1111"></a>1111. associative containers underconstrained</h3>
<p><b>Section:</b> 23.4 [associative] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-04-29  <b>Last modified:</b> 2009-07-16</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#associative">issues</a> in [associative].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p>
According to table 87 (n2857) the expression <tt>X::key_equal</tt> for an unordered
container shall return a value of type <tt>Pred</tt>, where <tt>Pred</tt> is an equivalence
relation.
</p>

<p>
However, all 4 containers constrain <tt>Pred</tt> to be merely a <tt>Predicate</tt>,
and not <tt>EquivalenceRelation</tt>.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We agree with the proposed resolution.
</p>
<p>
Move to Review.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
For ordered containers, replace 
</p>
<blockquote><pre>Predicate&lt;auto, Key, Key&gt; Compare = less&lt;Key&gt;
</pre></blockquote>
<p>
with 
</p>
<blockquote><pre>StrictWeakOrder&lt;auto, Key, Key&gt; Compare = less&lt;Key&gt;
</pre></blockquote>

<p>
For unordered containers, replace 
</p>
<blockquote><pre>Predicate&lt;auto, Key, Key&gt; Compare = less&lt;Key&gt;
</pre></blockquote>
<p>
with 
</p>
<blockquote><pre>EquivalenceRelation&lt;auto, Key, Key&gt; Compare = less&lt;Key&gt;
</pre></blockquote>
<p>
As in the following declarations:
</p>

<blockquote>
<p>
Associative containers 23.4 [associative]
</p>
<p>
 1 Headers &lt;map&gt; and &lt;set&gt;:
</p>
<p>
   Header &lt;map&gt; synopsis
</p>
<blockquote><pre>   namespace std {
     template &lt;ValueType Key, ValueType T,
               <del>Predicate</del><ins>StrictWeakOrder</ins>&lt;auto, Key<del>, Key</del>&gt; Compare = less&lt;Key&gt;,
               Allocator Alloc = allocator&lt;pair&amp;lt;&lt;b&gt;const Key, T&gt; &gt; &gt;
       requires NothrowDestructible&lt;Key&gt; &amp;&amp; NothrowDestructible&lt;T&gt;
             &amp;&amp; CopyConstructible&lt;Compare&gt;
             &amp;&amp; AllocatableElement&lt;Alloc, Compare, const Compare&amp;&gt;
             &amp;&amp; AllocatableElement&lt;Alloc, Compare, Compare&amp;&amp;&gt;
     class map;

     ...

     template &lt;ValueType Key, ValueType T,
               <del>Predicate</del><ins>StrictWeakOrder</ins>&lt;auto, Key<del>, Key</del>&gt; Compare = less&lt;Key&gt;,
               Allocator Alloc = allocator&lt;pair&amp;lt;&lt;b&gt;const Key, T&gt; &gt; &gt;
       requires NothrowDestructible&lt;Key&gt; &amp;&amp; NothrowDestructible&lt;T&gt;
             &amp;&amp; CopyConstructible&lt;Compare&gt;
             &amp;&amp; AllocatableElement&lt;Alloc, Compare, const Compare&amp;&gt;
             &amp;&amp; AllocatableElement&lt;Alloc, Compare, Compare&amp;&amp;&gt;
     class multimap;

     ...

   }
</pre></blockquote>

<p>
   Header &lt;set&gt; synopsis
</p>
<blockquote><pre>   namespace std {
     template &lt;ValueType Key, <del>Predicate</del><ins>StrictWeakOrder</ins>&lt;auto, Key<del>, Key</del>&gt; Compare = less&lt;Key&gt;,
               Allocator Alloc = allocator&lt;Key&gt; &gt;
       requires NothrowDestructible&lt;Key&gt; &amp;&amp; CopyConstructible&lt;Compare&gt;
             &amp;&amp; AllocatableElement&lt;Alloc, Compare, const Compare&amp;&gt;
             &amp;&amp; AllocatableElement&lt;Alloc, Compare, Compare&amp;&amp;&gt;
     class set;

     ...

     template &lt;ValueType Key, <del>Predicate</del><ins>StrictWeakOrder</ins>&lt;auto, Key<del>, Key</del>&gt; Compare = less&lt;Key&gt;,
               Allocator Alloc = allocator&lt;Key&gt; &gt;
       requires NothrowDestructible&lt;Key&gt; &amp;&amp; CopyConstructible&lt;Compare&gt;
             &amp;&amp; AllocatableElement&lt;Alloc, Compare, const Compare&amp;&gt;
             &amp;&amp; AllocatableElement&lt;Alloc, Compare, Compare&amp;&amp;&gt;
     class multiset;

     ...

   }
</pre></blockquote>

<p>
 23.4.1p2 Class template map [map]
</p>
<blockquote><pre> namespace std {
   template &lt;ValueType Key, ValueType T,
             <del>Predicate</del><ins>StrictWeakOrder</ins>&lt;auto, Key<del>, Key</del>&gt; Compare = less&lt;Key&gt;,
             Allocator Alloc = allocator&lt;pair&amp;lt;&lt;b&gt;const Key, T&gt; &gt; &gt;
     requires NothrowDestructible&lt;Key&gt; &amp;&amp; NothrowDestructible&lt;T&gt;
           &amp;&amp; CopyConstructible&lt;Compare&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Compare, const Compare&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Compare, Compare&amp;&amp;&gt;
   class map {
     ...
   };
 }
</pre></blockquote>


<p>
 23.4.2p2 Class template multimap [multimap]
</p>
<blockquote><pre> namespace std {
   template &lt;ValueType Key, ValueType T,
             <del>Predicate</del><ins>StrictWeakOrder</ins>&lt;auto, Key<del>, Key</del>&gt; Compare = less&lt;Key&gt;,
             Allocator Alloc = allocator&lt;pair&amp;lt;&lt;b&gt;const Key, T&gt; &gt; &gt;
     requires NothrowDestructible&lt;Key&gt; &amp;&amp; NothrowDestructible&lt;T&gt;
           &amp;&amp; CopyConstructible&lt;Compare&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Compare, const Compare&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Compare, Compare&amp;&amp;&gt;
   class multimap {
     ...
   };
 }
</pre></blockquote>


<p>
 23.4.3p2 Class template set [set]
</p>
<blockquote><pre> namespace std {
   template &lt;ValueType Key, <del>Predicate</del><ins>StrictWeakOrder</ins>&lt;auto, Key<del>, Key</del>&gt; Compare = less&lt;Key&gt;,
             Allocator Alloc = allocator&lt;Key&gt; &gt;
     requires NothrowDestructible&lt;Key&gt; &amp;&amp; CopyConstructible&lt;Compare&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Compare, const Compare&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Compare, Compare&amp;&amp;&gt;
   class set {
     ...
   };
 }
</pre></blockquote>


<p>
 23.4.4p2 Class template multiset [multiset]
</p>
<blockquote><pre> namespace std {
   template &lt;ValueType Key, <del>Predicate</del><ins>StrictWeakOrder</ins>&lt;auto, Key<del>, Key</del>&gt; Compare = less&lt;Key&gt;,
             Allocator Alloc = allocator&lt;Key&gt; &gt;
     requires NothrowDestructible&lt;Key&gt; &amp;&amp; CopyConstructible&lt;Compare&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Compare, const Compare&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Compare, Compare&amp;&amp;&gt;
   class multiset {
     ...
   };
 }
</pre></blockquote>

<p>
 23.5 Unordered associative containers [unord]
</p>
<p>
 1 Headers &lt;unordered_map&gt; and &lt;unordered_set&gt;:
</p>
<p>
 Header &lt;unordered_map&gt; synopsis
</p>
<blockquote><pre> namespace std {
   // 23.5.1, class template unordered_map:
   template &lt;ValueType Key,
             ValueType T,
             Callable&lt;auto, const Key&amp;&gt; Hash = hash&lt;Key&gt;,
             <del>Predicate</del><ins>EquivalenceRelation</ins>&lt;auto, Key<del>, Key</del>&gt; Pred = equal_to&lt;Key&gt;,
             Allocator Alloc = allocator&lt;pair&amp;lt;&lt;b&gt;const Key, T&gt; &gt; &gt;
     requires NothrowDestructible&lt;Key&gt; &amp;&amp; NothrowDestructible&lt;T&gt;
           &amp;&amp; SameType&lt;Hash::result_type, size_t&gt;
           &amp;&amp; CopyConstructible&lt;Hash&gt; &amp;&amp; CopyConstructible&lt;Pred&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Pred, const Pred&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Pred, Pred&amp;&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Hash, const Hash&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Hash, Hash&amp;&amp;&gt;
     class unordered_map;

   // 23.5.2, class template unordered_multimap:
   template &lt;ValueType Key,
             ValueType T,
             Callable&lt;auto, const Key&amp;&gt; Hash = hash&lt;Key&gt;,
             <del>Predicate</del><ins>EquivalenceRelation</ins>&lt;auto, Key<del>, Key</del>&gt; Pred = equal_to&lt;Key&gt;,
             Allocator Alloc = allocator&lt;pair&amp;lt;&lt;b&gt;const Key, T&gt; &gt; &gt;
     requires NothrowDestructible&lt;Key&gt; &amp;&amp; NothrowDestructible&lt;T&gt;
           &amp;&amp; SameType&lt;Hash::result_type, size_t&gt;
           &amp;&amp; CopyConstructible&lt;Hash&gt; &amp;&amp; CopyConstructible&lt;Pred&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Pred, const Pred&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Pred, Pred&amp;&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Hash, const Hash&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Hash, Hash&amp;&amp;&gt;
     class unordered_multimap;

   ...
 }
</pre></blockquote>

<p>
 Header &lt;unordered_set&gt; synopsis
</p>
<blockquote><pre> namespace std {
   // 23.5.3, class template unordered_set:
   template &lt;ValueType Value,
             Callable&lt;auto, const Value&amp;&gt; Hash = hash&lt;Value&gt;,
             <del>Predicate</del><ins>EquivalenceRelation</ins>&lt;auto, Value<del>, Value</del>&gt; class Pred = equal_to&lt;Value&gt;,
             Allocator Alloc = allocator&lt;Value&gt; &gt;
     requires NothrowDestructible&lt;Value&gt;
           &amp;&amp; SameType&lt;Hash::result_type, size_t&gt;
           &amp;&amp; CopyConstructible&lt;Hash&gt; &amp;&amp; CopyConstructible&lt;Pred&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Pred, const Pred&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Pred, Pred&amp;&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Hash, const Hash&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Hash, Hash&amp;&amp;&gt;
     class unordered_set;

   // 23.5.4, class template unordered_multiset:
   template &lt;ValueType Value,
             Callable&lt;auto, const Value&amp;&gt; Hash = hash&lt;Value&gt;,
             <del>Predicate</del><ins>EquivalenceRelation</ins>&lt;auto, Value<del>, Value</del>&gt; class Pred = equal_to&lt;Value&gt;,
             Allocator Alloc = allocator&lt;Value&gt; &gt;
     requires NothrowDestructible&lt;Value&gt;
           &amp;&amp; SameType&lt;Hash::result_type, size_t&gt;
           &amp;&amp; CopyConstructible&lt;Hash&gt; &amp;&amp; CopyConstructible&lt;Pred&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Pred, const Pred&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Pred, Pred&amp;&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Hash, const Hash&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Hash, Hash&amp;&amp;&gt;
     class unordered_multiset;

   ...
 }
</pre></blockquote>

<p>
 23.5.1p3 Class template unordered_map [unord.map]
</p>
<blockquote><pre> namespace std {
   template &lt;ValueType Key,
             ValueType T,
             Callable&lt;auto, const Key&amp;&gt; Hash = hash&lt;Key&gt;,
             <del>Predicate</del><ins>EquivalenceRelation</ins>&lt;auto, Key<del>, Key</del>&gt; Pred = equal_to&lt;Key&gt;,
             Allocator Alloc = allocator&lt;pair&amp;lt;&lt;b&gt;const Key, T&gt; &gt; &gt;
     requires NothrowDestructible&lt;Key&gt; &amp;&amp; NothrowDestructible&lt;T&gt;
           &amp;&amp; SameType&lt;Hash::result_type, size_t&gt;
           &amp;&amp; CopyConstructible&lt;Hash&gt; &amp;&amp; CopyConstructible&lt;Pred&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Pred, const Pred&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Pred, Pred&amp;&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Hash, const Hash&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Hash, Hash&amp;&amp;&gt;
   class unordered_map
   {
     ...
   };
 }
</pre></blockquote>

<p>
 23.5.2p3 Class template unordered_multimap [unord.multimap]
</p>
<blockquote><pre> namespace std {
   template &lt;ValueType Key,
             ValueType T,
             Callable&lt;auto, const Key&amp;&gt; Hash = hash&lt;Key&gt;,
             <del>Predicate</del><ins>EquivalenceRelation</ins>&lt;auto, Key<del>, Key</del>&gt; Pred = equal_to&lt;Key&gt;,
             Allocator Alloc = allocator&lt;pair&amp;lt;&lt;b&gt;const Key, T&gt; &gt; &gt;
     requires NothrowDestructible&lt;Key&gt; &amp;&amp; NothrowDestructible&lt;T&gt;
           &amp;&amp; SameType&lt;Hash::result_type, size_t&gt;
           &amp;&amp; CopyConstructible&lt;Hash&gt; &amp;&amp; CopyConstructible&lt;Pred&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Pred, const Pred&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Pred, Pred&amp;&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Hash, const Hash&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Hash, Hash&amp;&amp;&gt;
   class unordered_multimap
   {
     ...
   };
 }
</pre></blockquote>

<p>
 23.5.3p3 Class template unordered_set [unord.set]
</p>
<blockquote><pre> namespace std {
   template &lt;ValueType Value,
             Callable&lt;auto, const Value&amp;&gt; Hash = hash&lt;Value&gt;,
             <del>Predicate</del><ins>EquivalenceRelation</ins>&lt;auto, Value<del>, Value</del>&gt; class Pred = equal_to&lt;Value&gt;,
             Allocator Alloc = allocator&lt;Value&gt; &gt;
     requires NothrowDestructible&lt;Value&gt;
           &amp;&amp; SameType&lt;Hash::result_type, size_t&gt;
           &amp;&amp; CopyConstructible&lt;Hash&gt; &amp;&amp; CopyConstructible&lt;Pred&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Pred, const Pred&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Pred, Pred&amp;&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Hash, const Hash&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Hash, Hash&amp;&amp;&gt;
   class unordered_set
   {
     ...
   };
 }
</pre></blockquote>
<p>
 23.5.4p3 Class template unordered_multiset [unord.multiset]
</p>
<blockquote><pre> namespace std {
   template &lt;ValueType Value,
             Callable&lt;auto, const Value&amp;&gt; Hash = hash&lt;Value&gt;,
             <del>Predicate</del><ins>EquivalenceRelation</ins>&lt;auto, Value<del>, Value</del>&gt; class Pred = equal_to&lt;Value&gt;,
             Allocator Alloc = allocator&lt;Value&gt; &gt;
     requires NothrowDestructible&lt;Value&gt;
           &amp;&amp; SameType&lt;Hash::result_type, size_t&gt;
           &amp;&amp; CopyConstructible&lt;Hash&gt; &amp;&amp; CopyConstructible&lt;Pred&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Pred, const Pred&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Pred, Pred&amp;&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Hash, const Hash&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Hash, Hash&amp;&amp;&gt;
   class unordered_multiset
   {
     ...
   };
 }
</pre></blockquote>

</blockquote>






<hr>
<h3><a name="1116"></a>1116. Literal constructors for tuple</h3>
<p><b>Section:</b> 20.5.2 [tuple.tuple] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-05-23  <b>Last modified:</b> 2009-10-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#tuple.tuple">issues</a> in [tuple.tuple].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It is not currently possible to construct <tt>tuple</tt> literal values,
even if the elements are all literal types.  This is because parameters
are passed to constructor by reference.
</p>
<p>
An alternative would be to pass all constructor arguments by value, where it
is known that *all* elements are literal types.  This can be determined with
concepts, although note that the negative constraint really requires
factoring out a separate concept, as there is no way to provide an 'any of
these fails' constraint inline.
</p>
<p>
Note that we will have similar issues with <tt>pair</tt> (and
<tt>tuple</tt> constructors from <tt>pair</tt>) although I am steering
clear of that class while other constructor-related issues settle.
</p>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD Editorial.  Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2994.html">N2994</a>.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Ammend the tuple class template declaration in 20.5.2 [tuple.tuple] as
follows
</p>

<blockquote>
<p>
Add the following concept:
</p>

<blockquote><pre>auto concept AllLiteral&lt; typename ... Types &gt; {
  requires LiteralType&lt;Types&gt;...;
}
</pre></blockquote>

<p>
ammend the constructor 
</p>

<blockquote><pre><ins>template &lt;class... UTypes&gt;
  requires AllLiteral&lt;Types...&gt;
        &amp;&amp; Constructible&lt;Types, UTypes&gt;...
  explicit tuple(UTypes...);</ins>

template &lt;class... UTypes&gt;
  requires <ins>!AllLiteral&lt;Types...&gt;</ins>
        <ins>&amp;&amp;</ins> Constructible&lt;Types, UTypes&amp;&amp;&gt;...
  explicit tuple(UTypes&amp;&amp;...);
</pre></blockquote>

<p>
ammend the constructor
</p>

<blockquote><pre><ins>template &lt;class... UTypes&gt;
  requires AllLiteral&lt;Types...&gt;
        &amp;&amp; Constructible&lt;Types, UTypes&gt;...
  tuple(tuple&lt;UTypes...&gt;);</ins>

template &lt;class... UTypes&gt;
  requires <ins>!AllLiteral&lt;Types...&gt;</ins>
        <ins>&amp;&amp;</ins> Constructible&lt;Types, const UTypes&amp;&gt;...
  tuple(const tuple&lt;UTypes...&gt;&amp;);
</pre></blockquote>

</blockquote>

<p>
Update the same signatures in 20.5.2.1 [tuple.cnstr], paras 3 and 5.
</p>





<hr>
<h3><a name="1117"></a>1117. tuple copy constructor</h3>
<p><b>Section:</b> 20.5.2.1 [tuple.cnstr] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-05-23  <b>Last modified:</b> 2009-10-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#tuple.cnstr">issues</a> in [tuple.cnstr].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The copy constructor for the <tt>tuple</tt> template is constrained.  This seems an
unusual strategy, as the copy constructor will be implicitly deleted if the
constraints are not met.  This is exactly the same effect as requesting an
<tt>=default;</tt> constructor.  The advantage of the latter is that it retains
triviality, and provides support for <tt>tuple</tt>s as literal types if issue
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1116">1116</a> is also accepted.
</p>
<p>
Actually, it might be worth checking with core if a constrained copy
constructor is treated as a constructor template, and as such does not
suppress the implicit generation of the copy constructor which would hide
the template in this case.
</p>

<p><i>[
2009-05-27 Daniel adds:
]</i></p>


<blockquote>
This would solve one half of the suggested changes in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#801">801</a>.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD Editorial.  Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2994.html">N2994</a>.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 20.5.2 [tuple.tuple] and 20.5.2.1 [tuple.cnstr] p4:
</p>

<blockquote><pre><del>requires CopyConstructible&lt;Types&gt;...</del> tuple(const tuple&amp;)<ins> = default</ins>;
</pre></blockquote>





<hr>
<h3><a name="1120"></a>1120. New type trait - remove_all</h3>
<p><b>Section:</b> 20.6 [meta] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Future">NAD Future</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-05-23  <b>Last modified:</b> 2009-10-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#meta">issues</a> in [meta].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Future">NAD Future</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Sometimes it is necessary to remove all qualifiers from a type before
passing on to a further API.  A good example would be calling the
<tt>tuple</tt> query APIs <tt>tuple_size</tt> or <tt>tuple_element</tt>
with a deduced type inside a function template.  If the deduced type is
cv-qualified or a reference then the call will fail.  The solution is to
chain calls to
<tt>remove_cv&lt;remove_reference&lt;T&gt;::type&gt;::type</tt>, and
note that the order matters.
</p>
<p>
Suggest it would be helpful to add a new type trait,
<tt>remove_all</tt>, that removes all top-level qualifiers from a type
i.e. cv-qualification and any references.  Define the term in such a way
that if additional qualifiers are added to the language, then
<tt>remove_all</tt> is defined as stripping those as well.
</p>

<p><i>[
2009-10-14 Daniel adds:
]</i></p>


<blockquote>
<tt>remove_all</tt> seems too generic, a possible alternative matching
the current naming style could be <tt>remove_cv_reference</tt> or
<tt>remove_reference_cv</tt>. It should also be considered whether this
trait should also remove 'extents', or pointer 'decorations'. Especially
if the latter situations are considered as well, it might be easier to
chose the name not in terms of what it <em>removes</em> (which might be
a lot), but in terms of it <em>creates</em>. In this case I could think
of e.g. <tt>extract_value_type</tt>.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD Future.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1122"></a>1122. Ratio values should be constexpr</h3>
<p><b>Section:</b> 20.4.1 [ratio.ratio] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-05-25  <b>Last modified:</b> 2009-10-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#ratio.ratio">issues</a> in [ratio.ratio].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The values <tt>num</tt> and <tt>den</tt> in the <tt>ratio</tt> template
should be declared <tt>constexpr</tt>.
</p>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD Editorial.  Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2994.html">N2994</a>.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
20.4.1 [ratio.ratio]
</p>

<blockquote><pre>namespace std {
  template &lt;intmax_t N, intmax_t D = 1&gt;
  class ratio {
  public:
    static const<ins>expr</ins> intmax_t num;
    static const<ins>expr</ins> intmax_t den;
  };
}
</pre></blockquote>






<hr>
<h3><a name="1124"></a>1124.  Invalid definition of concept RvalueOf</h3>
<p><b>Section:</b> X [concept.transform] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Concepts">NAD Concepts</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2009-05-28  <b>Last modified:</b> 2009-07-15</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#concept.transform">issues</a> in [concept.transform].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p>
A recent news group
<a href="http://groups.google.de/group/comp.std.c++/browse_frm/thread/8eb92768a19fb46f">article</a>
points to several defects in the
specification of reference-related concepts.
</p>
<p>
One problem of the concept <tt>RvalueOf</tt> as currently defined in
X [concept.transform]:
</p>

<blockquote><pre>concept RvalueOf&lt;typename T&gt; {
 typename type = T&amp;&amp;;
 requires ExplicitlyConvertible&lt;T&amp;,type&gt; &amp;&amp; Convertible&lt;T&amp;&amp;,type&gt;;
}

template&lt;typename T&gt; concept_map RvalueOf&lt;T&amp;&gt; {
 typedef T&amp;&amp; type;
}
</pre></blockquote>

<p>
is that if <tt>T</tt> is an lvalue-reference, the requirement
<tt>Convertible&lt;T&amp;&amp;,type&gt;</tt> isn't satisfied for
lvalue-references, because after reference-collapsing in the concept
definition we have <tt>Convertible&lt;T&amp;,type&gt;</tt> in this case,
which isn't satisfied in the concept map template and also is not the
right constraint either. I think that the reporter is right that
<tt>SameType</tt> requirements should do the job and that we also should
use the new <tt>RvalueReference</tt> concept to specify a best matching
type requirement.
</p>


<p><b>Proposed resolution:</b></p>
<p>
In X [concept.transform] before p. 4 change as indicated:
</p>

<blockquote><pre>auto concept RvalueOf&lt;typename T&gt; {
  <del>typename</del><ins>RvalueReference</ins> type = T&amp;&amp;;
  requires <del>ExplicitlyConvertible&lt;T&amp;, type&gt; &amp;&amp; Convertible&lt;T&amp;&amp;, type&gt;</del><ins>SameType&lt;T&amp;, type&amp;&gt;</ins>;
}
</pre></blockquote>





<hr>
<h3><a name="1127"></a>1127. rvalue references and iterator traits</h3>
<p><b>Section:</b> 24.4.1 [iterator.traits] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-05-28  <b>Last modified:</b> 2009-07-15</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#iterator.traits">issues</a> in [iterator.traits].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The deprecated support for <tt>iterator_traits</tt> and legacy (unconstrained)
iterators features the (exposition only) concept:
</p>

<blockquote><pre>concept IsReference&lt;typename T&gt; { } // exposition only
template&lt;typename T&gt; concept_map IsReference&lt;T&amp;&gt; { }
</pre></blockquote>
<p>
Now this looks exactly like the <tt>LvalueReference</tt> concept recently added to
clause 20, so I wonder if we should use that instead?
Then I consider the lack of rvalue-reference support, which means that
<tt>move_iterator</tt> would always flag as merely supporting the <tt>input_iterator_tag</tt>
category.  This suggests we retain the exposition concept, but add a second
concept_map to support rvalue references.
</p>
<p>
I would suggest adding the extra concept_map is the right way forward, but
still wonder if the two exposition-only concepts in this clause might be
worth promoting to clause 20.  That question might better be answered with a
fuller investigation of type_trait/concept unification though.
</p>


<p><b>Proposed resolution:</b></p>
<p>
In Iterator traits 24.4.1 [iterator.traits] para 4 add:
</p>

<blockquote><pre>concept IsReference&lt;typename T&gt; { } // exposition only
template&lt;typename T&gt; concept_map IsReference&lt;T&amp;&gt; { }
<ins>template&lt;typename T&gt; concept_map IsReference&lt;T&amp;&amp;&gt; { }</ins>
</pre></blockquote>






<hr>
<h3><a name="1128"></a>1128. Missing definition of <tt>iterator_traits&lt;T*&gt;</tt></h3>
<p><b>Section:</b> X [iterator.syn] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-05-28  <b>Last modified:</b> 2009-07-16</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <tt>&lt;iterator&gt;</tt> header synopsis declares a partial specialization of
<tt>iterator_traits</tt> to support pointers, X [iterator.syn].  The implication
is that specialization will be described in D10, yet it did not follow the
rest of the deprecated material into this clause.
</p>
<p>
However, this is not as bad as it first seems!
There are partial specializations of <tt>iterator_traits</tt> for types that satisfy
the various Iterator concepts, and there are concept_maps for pointers to
explicitly support the <tt>RandomAccessIterator</tt> concept, so the required
template will be present - just not in the manner advertised.
</p>
<p>
I can see two obvious solutions:
</p>

<ol type="i">
<li>
Restore the <tt>iterator_traits&lt;T*&gt;</tt> partial specialization in D.10
</li>
<li>
Remove the declaration of <tt>iterator_traits&lt;T*&gt;</tt> from 24.3 synopsis
</li>
</ol>
<p>
I recommend option (ii) in the wording below
</p>
<p>
Option (ii) could be extended to strike all the declarations of deprecated
material from the synopsis, as it is effectively duplicating D.10 anyway.
This is the approach taken for deprecated library components in the 98/03
standards.  This is probably a matter best left to the Editor though.
</p>


<p><b>Proposed resolution:</b></p>
<p>
In X [iterator.syn] strike:
</p>

<blockquote><pre><del>template&lt;class T&gt; struct iterator_traits&lt;T*&gt;;</del>
</pre></blockquote>






<hr>
<h3><a name="1129"></a>1129. <tt>istream(buf)_iterator</tt> should support literal sentinel value</h3>
<p><b>Section:</b> 24.6.1.1 [istream.iterator.cons], 24.6.3 [istreambuf.iterator] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-05-30  <b>Last modified:</b> 2009-10-26</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>istream_iterator</tt> and <tt>istreambuf_iterator</tt> should support literal sentinel
values.  The default constructor is frequently used to terminate ranges, and
could easily be a literal value for <tt>istreambuf_iterator</tt>, and
<tt>istream_iterator</tt> when iterating value types.  A little more work using a
suitably sized/aligned char-array for storage (or an updated component like
<tt>boost::optional</tt> proposed for TR2) would allow <tt>istream_iterator</tt> to support
<tt>constexpr</tt> default constructor in all cases, although we might leave this
tweak as a QoI issue.  Note that requiring <tt>constexpr</tt> be supported also
allows us to place no-throw guarantees on this constructor too.
</p>

<p><i>[
2009-06-02 Daniel adds:
]</i></p>


<blockquote>
<p>
I agree with the usefulness of the issue suggestion, but we need
to ensure that <tt>istream_iterator</tt> <em>can</em> satisfy be literal if needed.
Currently this is not clear, because 24.6.1 [istream.iterator]/3 declares
a copy constructor and a destructor and explains their semantic in
24.6.1.1 [istream.iterator.cons]/3+4.
</p>
<p>
The prototype semantic specification is ok (although it seems
somewhat redundant to me, because the semantic doesn't say
anything interesting in both cases), but for support of trivial class
types we also need a trivial copy constructor and destructor as of
9 [class]/6. The current non-informative specification of these
two special members suggests to remove their explicit declaration
in the class and add explicit wording that says that if <tt>T</tt> is
trivial a default constructed iterator is also literal, alternatively it
would be possible to mark both as defaulted and add explicit
(memberwise) wording that guarantees that they are trivial.
</p>
<p>
Btw.: I'm quite sure that the <tt>istreambuf_iterator</tt> additions to
ensure triviality are not sufficient as suggested, because the
library does not yet give general guarantees that a defaulted
special member declaration makes this member also trivial.
Note that e.g. the atomic types do give a general statement!
</p>
<p>
Finally there is a wording issue: There does not exist something
like a "literal constructor". The core language uses the term
"constexpr constructor" for this.
</p>
<p>
Suggestion:
</p>
<ol>
<li>
<p>
Change 24.6.1 [istream.iterator]/3 as indicated:
</p>
<blockquote><pre><ins>constexpr</ins> istream_iterator();
istream_iterator(istream_type&amp; s);
istream_iterator(const istream_iterator<del>&lt;T,charT,traits,Distance&gt;</del>&amp; x)<ins> = default</ins>;
~istream_iterator()<ins> = default</ins>;
</pre></blockquote>
</li>
<li>
<p>
Change 24.6.1.1 [istream.iterator.cons]/1 as indicated:
</p>
<blockquote><pre><ins>constexpr</ins> istream_iterator();
</pre>
<blockquote>
-1- <i>Effects:</i> Constructs the end-of-stream iterator. <ins>If <tt>T</tt> is a literal type,
then this constructor shall be a constexpr constructor.</ins>
</blockquote>
</blockquote>
</li>
<li>
<p>
Change 24.6.1.1 [istream.iterator.cons]/3 as indicated:
</p>
<blockquote><pre>istream_iterator(const istream_iterator<del>&lt;T,charT,traits,Distance&gt;</del>&amp; x)<ins> = default</ins>;
</pre>
<blockquote>
-3- <i>Effects:</i> Constructs a copy of <tt>x</tt>. <ins>If <tt>T</tt> is a literal type, then
this constructor shall be a trivial copy constructor.</ins>
</blockquote>
</blockquote>
</li>
<li>
<p>
Change 24.6.1.1 [istream.iterator.cons]/4 as indicated:
</p>

<blockquote><pre>~istream_iterator()<ins> = default</ins>;
</pre>
<blockquote>
-4- <i>Effects:</i> The iterator is destroyed. <ins>If <tt>T</tt> is a literal type, then
this destructor shall be a trivial
destructor.</ins>
</blockquote>
</blockquote>
</li>
<li>
<p>
Change 24.6.3 [istreambuf.iterator] before p. 1 as indicated:
</p>

<blockquote><pre><ins>constexpr</ins> istreambuf_iterator() throw();
<ins>istreambuf_iterator(const istreambuf_iterator&amp;)  throw() = default;</ins>
<ins>~istreambuf_iterator()  throw() = default;</ins>
</pre></blockquote>
</li>
<li>
<p>
Change 24.6.3 [istreambuf.iterator]/1 as indicated:
</p>
<blockquote>
[..] The default constructor <tt>istreambuf_iterator()</tt> and the constructor
<tt>istreambuf_iterator(0)</tt> both
construct an end of stream iterator object suitable for use as an
end-of-range. <ins>All
specializations of <tt>istreambuf_iterator</tt> shall have a trivial copy
constructor, a constexpr default
constructor and a trivial destructor.</ins>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD Editorial.  Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2994.html">N2994</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
24.6.1 [istream.iterator] para 3
</p>

<blockquote><pre><ins>constexpr</ins> istream_iterator();
</pre></blockquote>

<p>
24.6.1.1 [istream.iterator.cons]
</p>

<blockquote><pre><ins>constexpr</ins> istream_iterator();
</pre>
<blockquote>
-1- <i>Effects:</i> Constructs the end-of-stream iterator.
<ins>If <tt>T</tt> is a literal type, then this constructor shall
be a literal constructor.</ins>
</blockquote>
</blockquote>

<p>
24.6.3 [istreambuf.iterator]
</p>

<blockquote><pre><ins>constexpr</ins> istreambuf_iterator() throw();
</pre></blockquote>






<hr>
<h3><a name="1132"></a>1132. JP-30: nested exceptions</h3>
<p><b>Section:</b> 18.8.6 [except.nested] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Seiji Hayashida <b>Opened:</b> 2009-06-01  <b>Last modified:</b> 2009-10-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#except.nested">active issues</a> in [except.nested].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#except.nested">issues</a> in [except.nested].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses JP 30</b></p>

<p>
C++0x <tt>nested_exception</tt> cannot handle a structured exception well. The
following codes show two types of tree structured exception handling.
</p>
<p>
The first one is based on <tt>nested_exception</tt> in C++0x,
while the second one is based on my library <tt>trickerr.h</tt> (in Japanese).
<a href="http://tricklib.com/cxx/dagger/trickerr.h">http://tricklib.com/cxx/dagger/trickerr.h</a>
</p>
<p>
Assume that Function <tt>A()</tt> calls two sub functions <tt>A_a()</tt> and <tt>A_b()</tt>, both might
throw tree structured exceptions, and <tt>A_b()</tt> must be called even if <tt>A_a()</tt>
throws an exception.
</p>
<p>
List A (code of tree structured exception handling based on nested_exception
in C++0x)
</p>

<blockquote><pre>void A()
{
    try
    {
        std::vector&lt;exception_ptr&gt; exception_list;
        try
        {
            // A_a() does a similar processing as A().
            A_a();
        }
        catch(...)
        {
            exception_list.push_back(current_exception());
        }

        // ***The processing A() has to do even when A_a() fails. ***
        try
        {
            // A_b() does a similar processing as A().
            A_b();
        }
        catch(...)
        {
            exception_list.push_back(current_exception());
        }
        if (!exception_list.empty())
        {
            throw exception_list;
        }
    }
    catch(...)
    {
        throw_with_nested(A_exception("someone error"));
    }
}
void print_tree_exception(exception_ptr e, const std::string &amp; indent ="")
{
    const char * indent_unit = " ";
    const char * mark = "- ";
    try
    {
        rethow_exception(e);
    }
    catch(const std::vector&lt;exception_ptr&gt; e)
    {
        for(std::vector&lt;exception_ptr&gt;::const_iterator i = e.begin(); i!=e.end(); ++i)
        {
            print_tree_exception(i, indent);
        }
    }
    catch(const std::nested_exception  e)
    {
        print_tree_exception(evil_i(e), indent +indent_unit);
    }
    catch(const std::exception e)
    {
        std::cout &lt;&lt; indent &lt;&lt; mark &lt;&lt; e.what() &lt;&lt; std::endl;
    }
    catch(...)
    {
        std::cout &lt;&lt; indent &lt;&lt; mark &lt;&lt; "unknown exception" &lt;&lt; std::endl;
    }
}
int main(int, char * [])
{
    try
    {
        A();
    }
    catch()
    {
        print_tree_exception(current_exception());
    }
    return EXIT_SUCCESS;
}
</pre></blockquote>

<p>
List B ( code of tree structured exception handling based on <tt>trickerr.h</tt>. )
"trickerr.h" (in Japanese), refer to:
<a href="http://tricklib.com/cxx/dagger/trickerr.h">http://tricklib.com/cxx/dagger/trickerr.h</a>.
</p>

<blockquote><pre>void A()
{
    tricklib::error_listener_type error_listener;
    // A_a() is like A(). A_a() can throw tree structured exception.
    A_a();

    // *** It must do process so that A_a() throws exception in A(). ***
    // A_b() is like A(). A_b() can throw tree structured exception.
    A_b();

    if (error_listener.has_error()) // You can write this "if block" in destructor
                                    //  of class derived from error_listener_type.
    {
        throw_error(new A_error("someone error",error_listener.listener_off().extract_pending_error()));
    }
}
void print_tree_error(const tricklib::error_type &amp;a_error, const std::string &amp; indent = "")
{
    const char * indent_unit = " ";
    const char * mark = "- ";

    tricklib::error_type error = a_error;
    while(error)
    {
        std::cout &lt;&lt; indent &lt;&lt; mark &lt;&lt; error-&gt;message &lt;&lt; std::endl;
        if (error-&gt;children)
        {
            print_tree_error(error-&gt;children, indent +indent_unit);
        }
        error = error-&gt;next;
    }
}
int main(int, char * [])
{
    tricklib::error_thread_power error_thread_power_on; // This object is necessary per thread.

    try
    {
        A();
    }
    catch(error_type error)
    {
        print_tree_error(error);
    }
    catch(...)
    {
        std::cout &lt;&lt; "- unknown exception" &lt;&lt; std::endl;
    }
    return EXIT_SUCCESS;
}
</pre></blockquote>

<p>
Prospect
</p>
<p>
We will focus on the method A() since the other methods, also main(), occur
only once respectively.
</p>

<ul>
<li>
 In the List A above (of the nested exception handling), it is hard to
 find out an active reason to use the nested exception handling at this
 scene. Rather, we can take a simpler description by throwing the entire
 exception_list directly to the top level.
</li>
<li>
 The code in the same example gives us a kind of redundant impression,
 which might have come from the fact that the try-throw-catch framework does
 not assume a tree structured exception handling.
</li>
</ul>

<p>
According to the above observation, we cannot help concluding that it is not
so easy to use the nested_exception handling as a tree structured exception
handling mechanism in a practical sense.
</p>
<p>
This text is based on the web page below (in Japanese).
<a href="http://d.hatena.ne.jp/wraith13/20081231/1230715424">http://d.hatena.ne.jp/wraith13/20081231/1230715424</a>
</p>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Mark as NAD. The committee agrees that nested_exception is not a good
match for this usage model. The committee did not see a way of improving
this within the timeframe allowed.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="1139"></a>1139. Thread support library not concept enabled</h3>
<p><b>Section:</b> 30 [thread] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Concepts">NAD Concepts</a>
 <b>Submitter:</b> LWG <b>Opened:</b> 2009-06-15  <b>Last modified:</b> 2009-07-15</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread">issues</a> in [thread].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses US 93, JP 79, UK 333, JP 81</b></p>

<p>
The thread chapter is not concept enabled.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1140"></a>1140. Numerics library not concept enabled</h3>
<p><b>Section:</b> 26 [numerics] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Concepts">NAD Concepts</a>
 <b>Submitter:</b> LWG <b>Opened:</b> 2009-06-15  <b>Last modified:</b> 2009-07-15</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#numerics">issues</a> in [numerics].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses US 84</b></p>

<p>
The numerics chapter is not concept enabled.
</p>

<p>
The portion of this comment dealing with random numbers was resolved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2836.pdf">N2836</a>,
which was accepted in Summit.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1141"></a>1141. Input/Output library not concept enabled</h3>
<p><b>Section:</b> 27 [input.output] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Concepts">NAD Concepts</a>
 <b>Submitter:</b> LWG <b>Opened:</b> 2009-06-15  <b>Last modified:</b> 2009-07-15</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#input.output">issues</a> in [input.output].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses US 85, JP 67, JP 68, JP 69, JP 72, UK 308</b></p>

<p>
The input/output chapter is not concept enabled.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1142"></a>1142. Regular expressions library not concept enabled</h3>
<p><b>Section:</b> 28 [re] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Concepts">NAD Concepts</a>
 <b>Submitter:</b> LWG <b>Opened:</b> 2009-06-15  <b>Last modified:</b> 2009-07-15</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#re">issues</a> in [re].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses US 86, UK 309, UK 310</b></p>

<p>
The regular expressions chapter is not concept enabled.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1143"></a>1143. Atomic operations library not concept enabled</h3>
<p><b>Section:</b> 29 [atomics] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> LWG <b>Opened:</b> 2009-06-15  <b>Last modified:</b> 2009-10-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#atomics">issues</a> in [atomics].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses US 87, UK 311</b></p>

<p>
The atomics chapter is not concept enabled.
</p>

<p>
Needs to also consider issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#923">923</a> and <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#924">924</a>.
</p>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD Editorial.  Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2992.html">N2992</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1145"></a>1145. inappropriate headers for atomics</h3>
<p><b>Section:</b> 29 [atomics] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> LWG <b>Opened:</b> 2009-06-16  <b>Last modified:</b> 2009-10-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#atomics">issues</a> in [atomics].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 312</b></p>

<p>
The contents of the <tt>&lt;stdatomic.h&gt;</tt> header are not listed anywhere,
and <tt>&lt;cstdatomic&gt;</tt> is listed as a C99 header in chapter 17.
If we intend to use these for compatibility with a future C standard,
we should not use them now.
</p>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD Editorial.  Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2992.html">N2992</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Remove <tt>&lt;cstdatomic&gt;</tt> from the C99 headers in table 14.
Add a new header <tt>&lt;atomic&gt;</tt> to the headers in table 13.
Update chapter 29 to remove reference to <tt>&lt;stdatomic.h&gt;</tt>
and replace the use of <tt>&lt;cstdatomic&gt;</tt> with <tt>&lt;atomic&gt;</tt>.
</p>
<p><i>[
If and when WG14 adds atomic operations to C
we can add corresponding headers to table 14 with a TR.
]</i></p>






<hr>
<h3><a name="1146"></a>1146. "lockfree" does not say enough</h3>
<p><b>Section:</b> 29.4 [atomics.lockfree] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Jeffrey Yasskin <b>Opened:</b> 2009-06-16  <b>Last modified:</b> 2009-10-26</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses US 88</b></p>

<p>
The "lockfree" facilities do not tell the programmer enough.
</p>

<p>
There are 2 problems here.
First, at least on x86,
it's less important to me whether some integral types are lock free
than what is the largest type I can pass to atomic and have it be lock-free.
For example, if <tt>long long</tt>s are not lock-free,
<tt>ATOMIC_INTEGRAL_LOCK_FREE</tt> is probably 1,
but I'd still be interested in knowing whether longs are always lock-free.
Or if long longs at any address are lock-free,
I'd expect <tt>ATOMIC_INTEGRAL_LOCK_FREE</tt> to be 2,
but I may actually care whether I have access to
the <code>cmpxchg16b</code> instruction.
None of the support here helps with that question.
(There are really 2 related questions here:
what alignment requirements are there for lock-free access;
and what processor is the program actually running on,
as opposed to what it was compiled for?)
</p>

<p>
Second, having <tt>atomic_is_lock_free</tt> only apply to individual objects
is pretty useless
(except, as Lawrence Crowl points out,
for throwing an exception when an object is unexpectedly not lock-free).
I'm likely to want to use its result to decide what algorithm to use,
and that algorithm is probably going to allocate new memory
containing atomic objects and then try to act on them.
If I can't predict the lock-freedom of the new object
by checking the lock-freedom of an existing object,
I may discover after starting the algorithm that I can't continue.
</p>

<p><i>[
2009-06-16 Jeffrey Yasskin adds:
]</i></p>


<blockquote>
<p>
To solve the first problem, I think 2 macros would help:
<tt>MAX_POSSIBLE_LOCK_FREE_SIZE</tt> and <tt>MAX_GUARANTEED_LOCK_FREE_SIZE</tt>,
which expand to the maximum value of <tt>sizeof(T)</tt> for which atomic may
(or will, respectively) use lock-free operations.
Lawrence points out that this
"relies heavily on implementations
using word-size compare-swap on sub-word-size types,
which in turn requires address modulation."
He expects that to be the end state anyway, so it doesn't bother him much.
</p>

<p>
To solve the second,
I think one could specify that equally aligned objects of the same type
will return the same value from <tt>atomic_is_lock_free()</tt>.
I don't know how to specify "equal alignment".
Lawrence suggests an additional function, <tt>atomic_is_always_lock_free()</tt>.
</p>
</blockquote>

<p><i>[
2009-10-22 Benjamin Kosnik:
]</i></p>


<blockquote>
<p>
In the evolution discussion of N2925, "More Collected Issues with
Atomics," there is an action item with respect to
LWG <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1146">1146</a>, US 88
</p>

<p>
This is stated in the paper as:
</p>
<p>
Relatedly, Mike Sperts will create an issue to propose adding a traits
mechanism to check the compile-time properties through a template
mechanism rather than macros
</p>

<p>
Here is my attempt to do this. I don't believe that a separate trait is
necessary for this, and that instead <tt>atomic_integral::is_lock_free</tt> can
be re-purposed with minimal work as follows.
</p>

<p><i>[
Howard: Put Benjamin's wording in the proposed wording section.
]</i></p>


</blockquote>

<p><i>[
2009-10-22 Alberto Ganesh Barbati:
]</i></p>


<blockquote>
<p>
Just a thought... wouldn't it be better to use a scoped enum instead of
plain integers? For example:
</p>

<blockquote><pre>enum class is_lock_free
{
    never = 0, sometimes = 1, always = 2;
};
</pre></blockquote>

<p>
if compatibility with C is deemed important, we could use an unscoped
enum with suitably chosen names.  It would still be more descriptive
than 0, 1 and 2.
</p>

</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD Editorial.  Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2992.html">N2992</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Header <tt>&lt;cstdatomic&gt;</tt> synopsis  [atomics.synopsis]
</p>

<p>
Edit  as follows:
</p>

<blockquote><pre>namespace std {
...
// 29.4, lock-free property
<del>#define ATOMIC_INTEGRAL_LOCK_FREE unspecified</del>
<ins>#define ATOMIC_CHAR_LOCK_FREE unspecified
#define ATOMIC_CHAR16_T_LOCK_FREE unspecified
#define ATOMIC_CHAR32_T_LOCK_FREE unspecified
#define ATOMIC_WCHAR_T_LOCK_FREE unspecified
#define ATOMIC_SHORT_LOCK_FREE unspecified
#define ATOMIC_INT_LOCK_FREE unspecified
#define ATOMIC_LONG_LOCK_FREE unspecified
#define ATOMIC_LLONG_LOCK_FREE unspecified</ins>
#define ATOMIC_ADDRESS_LOCK_FREE unspecified
</pre></blockquote>

<p>
Lock-free Property 29.4 [atomics.lockfree]
</p>

<p>
Edit the synopsis as follows.
</p>

<blockquote><pre>namespace std {
   <del>#define ATOMIC_INTEGRAL_LOCK_FREE unspecified</del>
   <ins>#define ATOMIC_CHAR_LOCK_FREE unspecified
   #define ATOMIC_CHAR16_T_LOCK_FREE unspecified
   #define ATOMIC_CHAR32_T_LOCK_FREE unspecified
   #define ATOMIC_WCHAR_T_LOCK_FREE unspecified
   #define ATOMIC_SHORT_LOCK_FREE unspecified
   #define ATOMIC_INT_LOCK_FREE unspecified
   #define ATOMIC_LONG_LOCK_FREE unspecified
   #define ATOMIC_LLONG_LOCK_FREE unspecified</ins>
   #define ATOMIC_ADDRESS_LOCK_FREE unspecified
}
</pre></blockquote>

<p>
Edit paragraph 1 as follows.
</p>

<blockquote>
The <ins>ATOMIC_...._LOCK_FREE</ins> macros <del>ATOMIC_INTEGRAL_LOCK_FREE and ATOMIC_ADDRESS_LOCK_FREE</del> indicate the general lock-free
property of <del>integral and address atomic</del> <ins>the corresponding atomic integral</ins> types<ins>, with the
signed and unsigned variants grouped together</ins>.
<del>The properties also apply to the corresponding specializations of the atomic template.</del>
A value of 0
indicates that the types are never lock-free. A value of 1
indicates that the types are sometimes lock-free. A value of 2
indicates that the types are always lock-free.
</blockquote>

<p>
Operations on Atomic Types 29.6 [atomics.types.operations]
</p>

<p>
Edit as follows.
</p>

<blockquote><pre><del>void</del> <ins>static constexpr bool</ins> A::is_lock_free() const volatile;
</pre>
<blockquote>
<i>Returns:</i> True if the <del>object's</del> <ins>types's</ins> operations are lock-free, false
otherwise.
<ins>
[<i>Note:</i> In the same way that <tt>&lt;limits&gt;</tt>
<tt>std::numeric_limits&lt;short&gt;::max()</tt> is related to
<tt>&lt;limits.h&gt;</tt> <tt>__LONG_LONG_MAX__</tt>, <tt>&lt;atomic&gt;
std::atomic_short::is_lock_free</tt> is related to
<tt>&lt;stdatomic.h&gt;</tt> and <tt>ATOMIC_SHORT_LOCK_FREE</tt> &#8212;
<i>end note</i>]
</ins>
</blockquote>
</blockquote>






<hr>
<h3><a name="1147"></a>1147. non-volatile atomic functions</h3>
<p><b>Section:</b> 29.6 [atomics.types.operations] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Jeffrey Yasskin <b>Opened:</b> 2009-06-16  <b>Last modified:</b> 2009-10-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#atomics.types.operations">issues</a> in [atomics.types.operations].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses US 90</b></p>

<p>
The C++0X draft
declares all of the functions dealing with atomics (section 29.6 [atomics.types.operations])
to take volatile arguments.
Yet it also says (29.4-3),
</p>

<blockquote>
<p>
[ Note: Many operations are volatile-qualified.
The "volatile as device register" semantics have not changed in the standard.
This qualification means that volatility is preserved
when applying these operations to volatile objects.
It does not mean that operations on non-volatile objects become volatile.
Thus, volatile qualified operations on non-volatile objects
may be merged under some conditions. &#8212;end note ]
</p>
</blockquote>

<p>
I was thinking about how to implement this in gcc,
and I believe that we'll want to overload most of the functions
on volatile and non-volatile.
Here's why:
</p>

<p>
To let the compiler take advantage of the permission
to merge non-volatile atomic operations and reorder atomics in certain,
we'll need to tell the compiler backend
about exactly which atomic operation was used.
So I expect most of the functions of the form atomic_&lt;op&gt;_explicit()
(e.g. atomic_load_explicit, atomic_exchange_explicit,
atomic_fetch_add_explicit, etc.)
to become compiler builtins.
A builtin can tell whether its argument was volatile or not,
so those functions don't really need extra explicit overloads.
However, I don't expect that we'll want to add builtins
for every function in chapter 29,
since most can be implemented in terms of the _explicit free functions:
</p>

<pre><code>class atomic_int {
  __atomic_int_storage value;
 public:
  int fetch_add(int increment, memory_order order = memory_order_seq_cst) volatile {
    // &amp;value has type "volatile __atomic_int_storage*".
    atomic_fetch_add_explicit(&amp;value, increment, order);
  }
  ...
};
</code></pre>

<p>
But now this <em>always</em> calls
the volatile builtin version of atomic_fetch_add_explicit(),
even if the atomic_int wasn't declared volatile.
To preserve volatility and the compiler's permission to optimize,
I'd need to write:
</p>

<pre><code>class atomic_int {
  __atomic_int_storage value;
 public:
  int fetch_add(int increment, memory_order order = memory_order_seq_cst) volatile {
    atomic_fetch_add_explicit(&amp;value, increment, order);
  }
  int fetch_add(int increment, memory_order order = memory_order_seq_cst) {
    atomic_fetch_add_explicit(&amp;value, increment, order);
  }
  ...
};
</code></pre>

<p>
But this is visibly different from the declarations in the standard
because it's now overloaded.
(Consider passing &amp;atomic_int::fetch_add as a template parameter.)
</p>

<p>
The implementation may already have permission to add overloads
to the member functions:
</p>

<blockquote>
<p>
17.6.4.5 [member.functions] An implementation may declare additional non-virtual
member function signatures within a class:<br>
...
</p>
<ul>
<li>by adding a member function signature for a member function name.</li>
</ul>
</blockquote>

<p>
but I don't see an equivalent permission to add overloads to the free functions.
</p>

<p><i>[
2009-06-16 Lawrence adds:
]</i></p>


<blockquote>
<p>
I recommend allowing non-volatile overloads.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD Editorial.  Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2992.html">N2992</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1148"></a>1148. Wrong argument type of I/O stream manipulators <tt>setprecision()</tt>
and <tt>setw()</tt></h3>
<p><b>Section:</b> 27.7 [iostream.format] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Marc Steinbach <b>Opened:</b> 2009-06-20  <b>Last modified:</b> 2009-10-20</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#iostream.format">issues</a> in [iostream.format].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The header <tt>&lt;iomanip&gt;</tt> synopsis in 27.7 [iostream.format] specifies
</p>
<blockquote><pre>T5 setprecision(int n);
T6 setw(int n);
</pre></blockquote>

<p>
The argument types should be streamsize, as in class <tt>ios_base</tt>
(see 27.5.2 [ios.base]):
</p>
<blockquote><pre>streamsize precision() const;
streamsize precision(streamsize prec);
streamsize width() const;
streamsize width(streamsize wide);
</pre></blockquote>

<p>
(Editorial: 'wide' should probably be renamed as 'width', or maybe just 'w'.)
</p>

<p><i>[
2009-07-29 Daniel clarified wording.
]</i></p>


<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote>
<p>
No concensus for this change.  There was some interest in doing the opposite
fix:  Change the <tt>streamsize</tt> in <tt>&lt;ios&gt;</tt> to <tt>int</tt>.
But ultimately there was no concensus for that change either.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>
In 27.7 [iostream.format], header <tt>&lt;iomanip&gt;</tt> synopsis change as indicated:
</p>

<blockquote><pre>T5 setprecision(<del>int</del><ins>streamsize</ins> n);
T6 setw(<del>int</del><ins>streamsize</ins> n);
</pre></blockquote>
</li>

<li>
<p>
In 27.7.3 [std.manip], just before p. 6 change as indicated:
</p>

<blockquote><pre>unspecified setprecision(<del>int</del><ins>streamsize</ins> n);
</pre></blockquote>
</li>

<li>
<p>
In 27.7.3 [std.manip], just before p. 7 change as indicated:
</p>

<blockquote><pre>unspecified setw(<del>int</del><ins>streamsize</ins> n);
</pre></blockquote>
</li>
</ol>








<hr>
<h3><a name="1149"></a>1149. Reformulating NonemptyRange axiom</h3>
<p><b>Section:</b> 26.5.2.2 [rand.concept.urng] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Concepts">NAD Concepts</a>
 <b>Submitter:</b> Walter Brown <b>Opened:</b> 2009-06-25  <b>Last modified:</b> 2009-07-15</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 26.5.2.2 [rand.concept.urng], we have the following:
</p>
<blockquote><pre>concept UniformRandomNumberGenerator&lt;typename G&gt; : Callable&lt;G&gt; {
  ...
  axiom NonemptyRange(G&amp; g) {
    G::min() &lt; G::max();
  }
  ...
}
</pre></blockquote>

<p>
Since the parameter <tt>G</tt> is in scope throughout the concept, there is no
need for the axiom to be further parameterized, and so the axiom can be
slightly simplified as:
</p>

<blockquote><pre>axiom NonemptyRange()  {
  G::min() &lt; G::max();
}
</pre></blockquote>

<p>
We can further reformulate so as to avoid any axiom machinery as:
</p>

<blockquote><pre>requires True&lt; G::min() &lt; G::max() &gt;;
</pre></blockquote>

<p>
This is not only a simpler statement of the same requirement, but also
forces the requirement to be checked.
</p>


<p><b>Proposed resolution:</b></p>
<p>
In 26.5.2.2 [rand.concept.urng], replace the <tt>NonemptyRange</tt> axiom by:
</p>

<blockquote><pre><del>axiom NonemptyRange(G&amp; g) { 
   G::min() &lt; G::max(); 
}</del>
<ins>requires True&lt; G::min() &lt; G::max() &gt;;</ins>
</pre></blockquote>






<hr>
<h3><a name="1150"></a>1150. wchar_t, char16_t and char32_t filenames</h3>
<p><b>Section:</b> 27.9.1.14 [fstream] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Future">NAD Future</a>
 <b>Submitter:</b> LWG <b>Opened:</b> 2009-06-28  <b>Last modified:</b> 2009-10-20</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Future">NAD Future</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses JP 73</b></p>

   <p><b>Description</b></p>
        <p>It is a problem
        from C++98, <tt>fstream</tt> cannot appoint a filename of wide
        character string(<tt>const wchar_t</tt> and <tt>const wstring&amp;</tt>).</p>
<p><b>Suggestion</b></p>
        <p>Add
        interface corresponding to <tt>wchar_t</tt>, <tt>char16_t</tt> and <tt>char32_t</tt>.</p>

<p><i>[
2009-07-01 Alisdair notes that this is a duplicate of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#454">454</a> which has more
in-depth rationale.
]</i></p>


<p><i>[
2009-09-21 Daniel adds:
]</i></p>


<blockquote>
I suggest to mark this issue as NAD Future with the intend to
solve the issue with a single file path c'tor template assuming
a provision of a TR2 filesystem library.
</blockquote>

<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote>
NAD Future.  This is a duplicate of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#454">454</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1155"></a>1155. Reference should be to C99</h3>
<p><b>Section:</b> C.2 [diff.library] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> LWG <b>Opened:</b> 2009-06-28  <b>Last modified:</b> 2009-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#diff.library">issues</a> in [diff.library].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses FR 38</b></p>

<p><b>Description</b></p>
        <p>What is ISO/IEC 1990:9899/DAM
        1? My guess is that's a typo for ISO/IEC
        9899/Amd.1:1995 which I'd
        have expected to be referenced here (the tables
        make reference to things
        which were introduced by Amd.1).</p>
<p><b>Suggestion</b></p>
        <p>One need probably a reference
        to the document which introduce <tt>char16_t</tt> and
        <tt>char32_t</tt> in C (ISO/IEC TR 19769:2004?).</p>
<p><b>Notes</b></p>
<p>Create issue. Document in question should be C99, not C90+amendment1. The 
    rest of the section requires careful review for completeness. Example &lt;cstdint&gt; 
    18.4.1 [cstdint.syn]. Assign to C liasons.</p>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD Editorial. Already fixed.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1160"></a>1160. <tt>future_error</tt> public constructor is 'exposition only'</h3>
<p><b>Section:</b> 30.6.3 [futures.future_error] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> LWG <b>Opened:</b> 2009-06-28  <b>Last modified:</b> 2009-10-26</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 331</b></p>

<p><b>Description</b></p>
        <p>Not clear what
        it means for a public constructor to be 'exposition only'.
        If the intent is purely to support the library calling this
        constructor then it can be made private and accessed
        through friendship. Otherwise it should be documented for
        public consumption.</p>
<p><b>Suggestion</b></p>
        <p>Declare the constructor as private with a
        note about intended friendship, or remove the
        exposition-only comment and document the semantics.</p>
<p><b>Notes</b></p>
<p>Create an issue. Assigned to Detlef. Suggested resolution probably makes 
    sense.</p>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
Pending a paper from Anthony Williams / Detleff Volleman.
</blockquote>

<p><i>[
2009-10-14 Pending paper:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2967.html">N2967</a>.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD Editorial.  Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2997.html">N2997</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1161"></a>1161. Unnecessary <tt>unique_future</tt> limitations</h3>
<p><b>Section:</b> 30.6.6 [futures.unique_future] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> LWG <b>Opened:</b> 2009-06-28  <b>Last modified:</b> 2009-10-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#futures.unique_future">issues</a> in [futures.unique_future].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 336</b></p>

<p><b>Description</b></p>

        <p>It is possible
        to transfer ownership of the asynchronous result from one
        unique_future instance to another via the move-constructor.
        However, it is not possible to transfer it back, and nor is
        it possible to create a default-constructed unique_future
        instance to use as a later move target. This unduly limits
        the use of <tt>unique_future</tt> in code. Also, the lack of a
        move-assignment operator restricts the use of <tt>unique_future</tt>
        in containers such as <tt>std::vector</tt> - <tt>vector::insert</tt> requires
        move-assignable for example.</p>
<p><b>Suggestion</b></p>
        <p>Add a default constructor with the
        semantics that it creates a <tt>unique_future</tt> with no
        associated asynchronous result. Add a move-assignment
        operator which transfers ownership.</p>
<p><b>Notes</b></p>
<p>Create an issue. Detlef will look into it.</p>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
Pending a paper from Anthony Williams / Detleff Volleman.
</blockquote>

<p><i>[
2009-10-14 Pending paper:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2967.html">N2967</a>.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD Editorial.  Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2997.html">N2997</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1162"></a>1162. <tt>shared_future</tt> should support an efficient move constructor</h3>
<p><b>Section:</b> 30.6.7 [future.shared_future] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> LWG <b>Opened:</b> 2009-06-28  <b>Last modified:</b> 2009-10-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#future.shared_future">issues</a> in [future.shared_future].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 337</b></p>

<p><b>Description</b></p>
        <p><tt>shared_future</tt>
        should support an efficient move constructor that can avoid
        unnecessary manipulation of a reference count, much like
        <tt>shared_ptr</tt></p>
<p><b>Suggestion</b></p>
        <p>Add a move constructor</p>
<p><b>Notes</b></p>
<p>Create an issue. Detlef will look into it.</p>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
Pending a paper from Anthony Williams / Detleff Volleman.
</blockquote>

<p><i>[
2009-10-14 Pending paper:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2967.html">N2967</a>.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD Editorial.  Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2997.html">N2997</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1163"></a>1163. <tt>shared_future</tt> is inconsistent with <tt>shared_ptr</tt></h3>
<p><b>Section:</b> 30.6.7 [future.shared_future] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> LWG <b>Opened:</b> 2009-06-28  <b>Last modified:</b> 2009-10-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#future.shared_future">issues</a> in [future.shared_future].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 338</b></p>

<p><b>Description</b></p>

        <p><tt>shared_future</tt> is currently
        CopyConstructible, but not CopyAssignable. This is
        inconsistent with <tt>shared_ptr</tt>, and will surprise users.
        Users will then write work-arounds to provide this
        behaviour. We should provide it simply and efficiently as
        part of shared_future. Note that since the shared_future
        member functions for accessing the state are all declared
        const, the original usage of an immutable shared_future
        value that can be freely copied by multiple threads can be
        retained by declaring such an instance as "<tt>const
        shared_future</tt>".</p>
<p><b>Suggestion</b></p>
        <p>Remove "=delete"
        from the copy-assignment operator of shared_future. Add a
        move-constructor <tt>shared_future(shared_future&amp;&amp;
        rhs)</tt>, and a move-assignment operator <tt>shared_future&amp;
        operator=(shared_future&amp;&amp; rhs)</tt>. The postcondition
        for the copy-assignment operator is that <tt>*this</tt> has the same
        associated state as <tt>rhs</tt>. The postcondition for the
        move-constructor and move assignment is that <tt>*this</tt> has the
        same associated as <tt>rhs</tt> had before the
        constructor/assignment call and that <tt>rhs</tt> has no associated
        state.</p>
<p><b>Notes</b></p>
<p>Create an issue. Detlef will look into it.</p>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
Pending a paper from Anthony Williams / Detleff Volleman.
</blockquote>

<p><i>[
2009-10-14 Pending paper:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2967.html">N2967</a>.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD Editorial.  Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2997.html">N2997</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1164"></a>1164. <tt>promise::swap</tt> should pass by rvalue reference</h3>
<p><b>Section:</b> 30.6.5 [futures.promise] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> LWG <b>Opened:</b> 2009-06-28  <b>Last modified:</b> 2009-07-17</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#futures.promise">issues</a> in [futures.promise].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 341</b></p>

<p><b>Description</b></p>
<p><tt>promise::swap</tt> accepts its parameter by lvalue reference. This is
inconsistent with other types that provide a swap member function,
where those swap functions accept an rvalue reference</p>

<p><b>Suggestion</b></p>
<p>Change <tt>promise::swap</tt> to take an rvalue reference.</p>

<p><b>Notes</b></p>
<p>Create an issue. Detlef will look into it. Probably ready as it.</p>  

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
NAD, by virtue of the changed rvalue rules and swap signatures from Summit.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1165"></a>1165. Unneeded promise move constructor</h3>
<p><b>Section:</b> 30.6.5 [futures.promise] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> LWG <b>Opened:</b> 2009-06-28  <b>Last modified:</b> 2009-10-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#futures.promise">issues</a> in [futures.promise].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 343</b></p>

<p><b>Description</b></p>
        <p>The move constructor of a std::promise
        object does not need to allocate any memory, so the
        move-construct-with-allocator overload of the constructor
        is superfluous.</p>
<p><b>Suggestion</b></p>
        <p>Remove the
        constructor with the signature <tt>template &lt;class
        Allocator&gt; promise(allocator_arg_t, const Allocator&amp;
        a, promise&amp; rhs);</tt></p>
<p><b>Notes</b></p>
<p>Create an issue. Detlef will look into it. Will solicit feedback from Pablo. 
    Note that &#8220;rhs&#8221; argument should also be an rvalue reference in any case.</p>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
Pending a paper from Anthony Williams / Detleff Volleman.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD Editorial.  Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2997.html">N2997</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1166"></a>1166. Allocator-specific move/copy break model of move-constructor and
        move-assignment</h3>
<p><b>Section:</b> X [allocator.propagation], X [allocator.propagation.map], 23 [containers] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> LWG <b>Opened:</b> 2009-06-28  <b>Last modified:</b> 2009-10-26</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses US 77</b></p>

<p><b>Description</b></p>
        <p>Allocator-specific move and copy behavior for containers
        (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2525.pdf">N2525</a>) complicates a little-used and already-complicated
        portion of the standard library (allocators), and breaks
        the conceptual model of move-constructor and
        move-assignment operations on standard containers being
        efficient operations. The extensions for allocator-specific
        move and copy behavior should be removed from the working
        paper.</p>
        <p>With the
        introduction of rvalue references, we are teaching
        programmers that moving from a standard container (e.g., a
        <tt>vector&lt;string&gt;</tt>) is an efficient, constant-time
        operation. The introduction of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2525.pdf">N2525</a> removed that
        guarantee; depending on the behavior of four different
        traits (20.8.4), the complexity of copy and move operations
        can be constant or linear time. This level of customization
        greatly increases the complexity of standard containers,
        and benefits only a tiny fraction of the C++ community.</p>
<p><b>Suggestion</b></p>

        <p>Remove 20.8.4.</p>
        
        <p>Remove 20.8.5.</p>
        
        <p>Remove all references to the facilities in
        20.8.4 and 20.8.5 from clause 23.</p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD Editorial.  Addressed by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2982.pdf">N2982</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1167"></a>1167. <tt>pair&lt;T,U&gt;</tt> doesn't model <tt>LessThanComparable</tt> in unconstrained code even if
      <tt>T</tt> and <tt>U</tt> do.</h3>
<p><b>Section:</b> 20.3.4 [pairs] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Concepts">NAD Concepts</a>
 <b>Submitter:</b> Dave Abrahams <b>Opened:</b> 2009-07-01  <b>Last modified:</b> 2009-07-16</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#pairs">active issues</a> in [pairs].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#pairs">issues</a> in [pairs].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>LessThanComparable</tt> requires (and provides default
             implementations for) &lt;=,&gt;, and &gt;=.  However, the defaults
             don't take effect in unconstrained code.
</p>
<p>
Still, it's a problem to have types acting one way in
constrained code and another in unconstrained code, except in cases of
syntax adaptation.  It's also inconsistent with the containers, which
supply all those operators.
</p>
<p>
Totally Unbiased
Suggested Resolution:
</p>
<p>
accept the exported concept maps proposal and
                    change the way this stuff is handled to use an
                    explicit exported concept map rather than nested
                    function templates
</p>
<p>
e.g., remove from the body of <tt>std::list</tt>
</p>
<blockquote><pre>template &lt;LessThanComparable T, class Allocator&gt; 
bool operator&lt; (const list&lt;T,Allocator&gt;&amp; x, const list&lt;T,Allocator&gt;&amp; y); 
template &lt;LessThanComparable T, class Allocator&gt; 
bool operator&gt; (const list&lt;T,Allocator&gt;&amp; x, const list&lt;T,Allocator&gt;&amp; y); 
template &lt;LessThanComparable T, class Allocator&gt; 
bool operator&gt;=(const list&lt;T,Allocator&gt;&amp; x, const list&lt;T,Allocator&gt;&amp; y); 
template &lt;LessThanComparable T, class Allocator&gt; 
bool operator&lt;=(const list&lt;T,Allocator&gt;&amp; x, const list&lt;T,Allocator&gt;&amp; y); 
</pre></blockquote>
<p>
and add this concept_map afterwards:
</p>
<blockquote><pre>template &lt;LessThanComparable T, class Allocator&gt; 
export concept_map LessThanComparable&lt;list&lt;T,Allocator&gt; &gt;
{
    bool operator&lt;(const list&lt;T,Allocator&gt;&amp; x, const list&lt;T,Allocator&gt;&amp; y);
}
</pre></blockquote>
<p>
do similarly for <tt>std::pair</tt>.  While you're at it, do the same for
<tt>operator==</tt> and <tt>!=</tt> everywhere, and seek out other such opportunities.
</p>
<p>
Alternative Resolution: keep the ugly, complex specification and add the
                       missing operators to <tt>std::pair</tt>.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1168"></a>1168. Odd wording for bitset equality operators</h3>
<p><b>Section:</b> 20.3.7.2 [bitset.members] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-07-02  <b>Last modified:</b> 2009-07-27</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#bitset.members">issues</a> in [bitset.members].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The following wording seems a little unusual to me:
</p>
<p>
p42/43 20.3.7.2 [bitset.members]
</p>

<blockquote>
<pre>bool operator==(const bitset&lt;N&gt;&amp; rhs) const;
</pre>
<blockquote>
-42- <i>Returns:</i> A nonzero value if the value of each bit in
<tt>*this</tt> equals the value of the corresponding bit in
<tt>rhs</tt>.
</blockquote>
<pre>bool operator!=(const bitset&lt;N&gt;&amp; rhs) const;
</pre>
<blockquote>
-43- <i>Returns:</i> A nonzero value if <tt>!(*this == rhs)</tt>.
</blockquote>
</blockquote>

<p>
"A nonzero value" may be well defined as equivalent to the literal '<tt>true</tt>'
for Booleans, but the wording is clumsy.  I suggest replacing "A nonzero value"
with the literal '<tt>true</tt>' (in appropriate font) in each case.
</p>

<p><i>[
2009-07-24 Alisdair recommends NAD Editorial.
]</i></p>


<p><i>[
2009-07-27 Pete adds:
]</i></p>


<blockquote>
It's obviously editorial. There's no need for further discussion.
</blockquote>

<p><i>[
2009-07-27 Howard sets to NAD Editorial.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
Change 20.3.7.2 [bitset.members] p42-43:
</p>

<blockquote>
<pre>bool operator==(const bitset&lt;N&gt;&amp; rhs) const;
</pre>
<blockquote>
-42- <i>Returns:</i> <del>A nonzero value</del> <ins><tt>true</tt></ins> if the value of each bit in
<tt>*this</tt> equals the value of the corresponding bit in
<tt>rhs</tt>.
</blockquote>
<pre>bool operator!=(const bitset&lt;N&gt;&amp; rhs) const;
</pre>
<blockquote>
-43- <i>Returns:</i> <del>A nonzero value</del> <ins><tt>true</tt></ins> if <tt>!(*this == rhs)</tt>.
</blockquote>
</blockquote>






<hr>
<h3><a name="1172"></a>1172. <tt>select_on_container_(copy|move)_construction</tt> over-constrained</h3>
<p><b>Section:</b> X [allocator.concepts.members] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Alberto Ganesh Barbati <b>Opened:</b> 2009-07-08  <b>Last modified:</b> 2009-10-26</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I believe the two functions
<tt>select_on_container_(copy|move)_construction()</tt> are over-constrained. For
example, the return value of the "copy" version is (see
X [allocator.concepts.members]/21):
</p>
<blockquote>
<i>Returns:</i> <tt>x</tt> if the allocator should propagate from the existing
container to the new container on copy construction, otherwise <tt>X()</tt>.
</blockquote>
<p>
Consider the case where a user decides to provide an explicit concept
map for Allocator to adapt some legacy allocator class, as he wishes to
provide customizations that the <tt>LegacyAllocator</tt> concept map template
does not provide.  Now, although it's true that the legacy class is
required to have a default constructor, the user might have reasons to
prefer a different constructor to implement
<tt>select_on_container_copy_construction()</tt>. However, the current wording
requires the use of the default constructor.
</p>
<p>
Moreover, it's not said explicitly that <tt>x</tt> is supposed to be the
allocator of the existing container. A clarification would do no harm.
</p>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD Editorial.  Addressed by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2982.pdf">N2982</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Replace X [allocator.concepts.members]/21 with:
</p>

<blockquote><pre>X select_on_container_copy_construction(const X&amp; x);
</pre>
<p>
-21- <i>Returns:</i> <del><tt>x</tt> if the allocator should propagate from the existing
container to the new container on copy construction, otherwise <tt>X()</tt>.</del>
<ins>an allocator object to be used by the new container on copy
construction. [<i>Note:</i> <tt>x</tt> is the allocator of the existing container that
is being copied. The most obvious choices for the return value are <tt>x</tt>, if
the allocator should propagate from the existing container, and <tt>X()</tt>.
<i>&#8212; end note</i>]</ins>
</p>
</blockquote>

<p>
Replace X [allocator.concepts.members]/25 with:
</p>

<blockquote><pre>X select_on_container_move_construction(X&amp;&amp; x);
</pre>
<p>
-25- <i>Returns:</i> <del><tt>move(x)</tt> if the allocator should propagate from the existing
container to the new container on move construction, otherwise <tt>X()</tt>.</del>
<ins>an allocator object to be used by the new container on move
construction. [<i>Note:</i> <tt>x</tt> is the allocator of the existing container that
is being moved. The most obvious choices for the return value are <tt>move(x)</tt>, if
the allocator should propagate from the existing container, and <tt>X()</tt>.
<i>&#8212; end note</i>]</ins>
</p>
</blockquote>






<hr>
<h3><a name="1174"></a>1174. type property predicates</h3>
<p><b>Section:</b> 20.6.4.3 [meta.unary.prop] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Jason Merrill <b>Opened:</b> 2009-07-16  <b>Last modified:</b> 2009-10-26</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#meta.unary.prop">active issues</a> in [meta.unary.prop].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#meta.unary.prop">issues</a> in [meta.unary.prop].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I've been implementing compiler support for <tt>is_standard_layout</tt>, and
noticed a few nits about 20.6.4.3 [meta.unary.prop]:
</p>

<ol>
<li>
There's no trait for "trivially copyable type", which is now the
property that lets you do bitwise copying of a type, and therefore seems
useful to be able to query.  <tt>has_trivial_assign</tt> &amp;&amp;
<tt>has_trivial_copy_constructor</tt> &amp;&amp; <tt>has_trivial_destructor</tt>
is similar, but
not identical, specifically with respect to const types.
</li>
<li>
<tt>has_trivial_copy_constructor</tt> and <tt>has_trivial_assign</tt> lack the "or an
array of such a class type" language that most other traits in that
section, including <tt>has_nothrow_copy_constructor</tt> and <tt>has_nothrow_assign</tt>,
have; this seems like an oversight.
</li>
</ol>

<p><i>[
See the thread starting with c++std-lib-24420 for further discussion.
]</i></p>


<p><i>[
Addressed in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2947.html">N2947</a>.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD Editorial.  Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2984.html">N2984</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="1179"></a>1179. Probably editorial in [structure.specifications]</h3>
<p><b>Section:</b> 17.5.1.4 [structure.specifications] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Robert Klarer <b>Opened:</b> 2009-07-21  <b>Last modified:</b> 2009-10-20</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#structure.specifications">issues</a> in [structure.specifications].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
While reviewing <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#971">971</a> I noted that 17.5.1.4 [structure.specifications]/7 says:
</p>

<blockquote>
-7- Error conditions specify conditions where a function may fail. The
conditions are listed, together with a suitable explanation, as the <tt>enum
class errc</tt> constants (19.5) that could be used as an argument to
function <tt>make_error_condition</tt> (19.5.3.6).
</blockquote>

<p>
This paragraph should mention <tt>make_error_code</tt> or the text "that
could be used as an argument to function <tt>make_error_condition</tt>
(19.5.3.6)" should be deleted.  I believe this is editorial.
</p>

<p><i>[
2009-07-21 Chris adds:
]</i></p>


<blockquote>
<p>
I'm not convinced there's a problem there, because as far as the "Error
conditions" clauses are concerned, make_error_condition() is used by a
user to test for the condition, whereas make_error_code is not. For
example:
</p>

<blockquote><pre>void foobar(error_code&amp; ec = throws());
</pre></blockquote>

<p>
 Error conditions:
</p>
<blockquote>
permission_denied - Insufficient privilege to perform operation.
</blockquote>

<p>
When a user writes:
</p>

<blockquote><pre>error_code ec;
foobar(ec);
if (ec == errc::permission_denied)
   ...
</pre></blockquote>

<p>
the implicit conversion <tt>errc-&gt;error_condition</tt> makes the if-test
equivalent to:
</p>

<blockquote><pre>if (ec == make_error_condition(errc::permission_denied))
</pre></blockquote>

<p>
On the other hand, if the user had written:
</p>

<blockquote><pre>if (ec == make_error_code(errc::permission_denied))
</pre></blockquote>

<p>
the test is now checking for a specific error code. The test may
evaluate to <tt>false</tt> even though <tt>foobar()</tt> failed due to the documented
error condition "Insufficient privilege".
</p>
</blockquote>

<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote>
<p>
NAD Editorial.
</p>
<p>
What the WP says right now is literally true: these codes can be used as
an argument to <tt>make_error_condition</tt>. (It is also true that they can be
used as an argument to <tt>make_error_code</tt>, which the WP doesn't say.) Maybe
it would be clearer to just delete "that could be used as an argument to
function <tt>make_error_condition</tt>", since that fact is already implied by
other things that we say. We believe that this is editorial.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="1184"></a>1184. Feature request: dynamic bitset</h3>
<p><b>Section:</b> 23.3.6 [vector] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Future">NAD Future</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-07-29  <b>Last modified:</b> 2009-10-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#vector">issues</a> in [vector].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Future">NAD Future</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Opened at Alisdair's request, steming from <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#96">96</a>.
Alisdair recommends NAD Future.
</p>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD Future.  We want a heap allocated bitset, but we don't have one today and
don't have time to add one.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1195"></a>1195. "Diagnostic required" wording is insufficient to  prevent UB</h3>
<p><b>Section:</b> 17 [library] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2009-08-18  <b>Last modified:</b> 2009-10-20</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Several parts of the library use the notion of "Diagnostic required"
to indicate that
in the corresponding situation an error diagnostic should occur, e.g.
20.8.14.1.1 [unique.ptr.dltr.dflt]/2
</p>
<blockquote><pre>void operator()(T *ptr) const;
</pre>

<blockquote>
<i>Effects:</i> calls <tt>delete</tt> on <tt>ptr</tt>. A diagnostic is required if <tt>T</tt> is an
incomplete type.
</blockquote>
</blockquote>

<p>
The problem with this approach is that such a requirement is
insufficient to prevent
undefined behavior, if this situation occurs. According to 1.3.3 [defns.diagnostic]
a <i>diagnostic message</i> is defined as
</p>

<blockquote>
a message belonging to an implementation-defined subset of the
implementation's output messages.
</blockquote>

<p>
which doesn't indicate any relation to an ill-formed program. In fact,
"compiler warnings"
are a typical expression of such diagnostics. This means that above
wording can be interpreted
by compiler writers that they satisfy the requirements of the standard
if they just produce
such a "warning", if the compiler happens to compile code like this:
</p>

<blockquote><pre>#include &lt;memory&gt;

struct Ukn; // defined somewhere else
Ukn* create_ukn(); // defined somewhere else

int main() {
 std::default_delete&lt;Ukn&gt;()(create_ukn());
}
</pre></blockquote>

<p>
In this and other examples discussed here it was the authors intent to
guarantee that the
program is ill-formed with a required diagnostic, therefore such
wording should be used instead.
According to the general rules outlined in 1.4 [intro.compliance] it
should be sufficient
to require that these situations produce an ill-formed program and the
"diagnostic
required" part should be implied. The proposed resolution also
suggests to remove
several <i>redundant</i> wording of "Diagnostics required" to ensure that
the absence of
such saying does not cause a misleading interpretation.
</p>

<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote>
<p>
Move to NAD.
</p>
<p>It's not clear that there's any important difference between
"ill-formed" and "diagnostic required". From 1.4 [intro.compliance],
1.3.5 [defns.ill.formed], and 1.3.15 [defns.well.formed] it appears
that an ill-formed program is one
that is not correctly constructed according to the syntax rules and
diagnosable semantic rules, which means that... "a conforming
implementation shall issue at least one diagnostic message." The
author's intent seems to be that we should be requiring a fatal error
instead of a mere warning, but the standard just doesn't have language
to express that distinction. The strongest thing we can ever require is
a "diagnostic".
</p>
<p>
The proposed rewording may be a clearer way of expressing the same thing
that the WP already says, but such a rewording is editorial.
</p>
</blockquote>

<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote>
Considered again.  Group disagrees that the change is technical, but likes
it editorially.  Moved to NAD Editorial.
</blockquote>



<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>
Change 20.4 [ratio]/2 as indicated:
</p>



<blockquote>
Throughout this subclause, the template argument types R1 and R2 shall
be specializations of the ratio
template<ins>, else the program is ill-formed</ins>.<del> Diagnostic required.</del>
</blockquote>
</li>

<li>
<p>
Change 20.4.1 [ratio.ratio]/1 as indicated:
</p>

<p>
The template argument <tt>D</tt> shall not be zero, and the absolute values of
the template arguments <tt>N</tt> and <tt>D</tt> shall
be representable by type <tt>intmax_t</tt><ins>, else the program is ill-formed</ins>.<del> Diagnostic required.</del> [..]
</p>


</li>

<li>
<p>
Change 20.4.2 [ratio.arithmetic]/1 as indicated:
</p>

<blockquote>
Implementations may use other algorithms to compute these values.
If overflow <ins>would</ins> occur<del>s</del>, <del>a diagnostic shall
be issued</del><ins>the program shall be ill-formed</ins>.
</blockquote>

</li>

<li>
<p>
Change 20.4.3 [ratio.comparison]/2 as indicated:
</p>

<blockquote>
[...] Implementations may use other algorithms to compute this relationship
to avoid overflow. If
overflow <del>occurs, a diagnostic is required</del><ins> would occur,
the program shall be
ill-formed</ins>.
</blockquote>


</li>

<li>
<p>
Change 20.8.14.1.1 [unique.ptr.dltr.dflt]/2 as indicated:
</p>

<blockquote>
<p>
<i>Effects:</i> calls <tt>delete</tt> on <tt>ptr</tt>.<del> A diagnostic is required if <tt>T</tt> is an
incomplete type.</del>
</p>

<p>
<ins><i>Remarks:</i> The program shall be ill-formed, if <tt>T</tt> is an incomplete type.</ins>
</p>
</blockquote>


</li>

<li>
<p>
Change 20.8.14.1.2 [unique.ptr.dltr.dflt1]/1 as indicated:
</p>

<blockquote>
<p>
<tt>operator()</tt> calls <tt>delete[]</tt> on <tt>ptr</tt>.<del> A diagnostic is required if <tt>T</tt>
is an incomplete type.</del>
</p>

<p>
<ins><i>Remarks:</i> The program shall be ill-formed, if <tt>T</tt> is an incomplete type.</ins>
</p>
</blockquote>
</li>

<li>
<p>
Accept <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#932">932</a>.
</p>

<p><i>[This is a bullet here to confirm that this list is
an exhaustive review of this issue.]</i></p>

</li>

<li>
<p>
Accept <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#950">950</a>.
</p>

<p><i>[This is a bullet here to confirm that this list is
an exhaustive review of this issue.]</i></p>

</li>

<li>
<p>
Change 20.8.14.3 [unique.ptr.runtime]/1 as indicated:
</p>

<blockquote>
[..]
-- Conversions among different types of <tt>unique_ptr&lt;T[], D&gt;</tt> or to or
from the non-array forms of
<tt>unique_ptr</tt> <del>are disallowed (diagnostic required)</del>
<ins>produce an ill-formed program</ins>.
[..]
</blockquote>


</li>

<li>
<p>
Change 20.9.3 [time.duration]/2 as indicated:
</p>

<blockquote>
<i>Requires:</i> <tt>Rep</tt> shall be an arithmetic type or a class emulating an
arithmetic type. <del>If a program
instantiates <tt>duration</tt> with a <tt>duration</tt> type for the template argument
<tt>Rep</tt> a diagnostic is required.</del>
<ins><i>Remarks:</i> The program shall be ill-formed, if <tt>duration</tt> is
instantiated with a <tt>duration</tt> type for the template argument <tt>Rep</tt>.</ins>

</blockquote>


</li>

<li>
<p>
Change 20.9.3 [time.duration]/3+4 as indicated:
</p>

<blockquote>
<p>
3 <del><i>Requires</i></del><ins><i>Remarks</i></ins>: <tt>Period</tt> shall be a
specialization of <tt>ratio</tt>, <del>diagnostic
required</del><ins>else the program shall be ill-formed</ins>.
</p>

<p>
4 <del><i>Requires</i></del><ins><i>Remarks</i></ins>: <tt>Period::num</tt> shall be
positive,  <del>diagnostic
required</del><ins>else the program shall be ill-formed</ins>.
</p>
</blockquote>


</li>

<li>
<p>
Accept <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1177">1177</a> bullet 1.
</p>

<p><i>[This is a bullet here to confirm that this list is
an exhaustive review of this issue.]</i></p>


</li>

<li>
<p>
Accept <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1177">1177</a> bullet 2.
</p>

<p><i>[This is a bullet here to confirm that this list is
an exhaustive review of this issue.]</i></p>


</li>

<li>
<p>
Accept <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1177">1177</a> bullet 3.
</p>

<p><i>[This is a bullet here to confirm that this list is
an exhaustive review of this issue.]</i></p>


</li>

<li>
<p>
Change 20.9.4 [time.point]/2 as indicated:
</p>

<blockquote>
<tt>Duration</tt> shall be an instance of <tt>duration</tt><ins>, else the
program shall be ill-formed</ins>. <del>Diagnostic required.</del>
</blockquote>
</li>

<li>
<p>
Change 20.9.4.1 [time.point.cons]/3 as indicated:
</p>

<blockquote>
<p>
<del><i>Requires:</i> <tt>Duration2</tt> shall be implicitly convertible to <tt>duration</tt>.
Diagnostic required.</del>
</p>

<p>
<ins><i>Remarks:</i> <tt>Duration2</tt> shall be implicitly convertible to <tt>duration</tt>,
else this constructor shall
not participate in overload resolution.</ins>
</p>
</blockquote>

<p><i>[This suggestion seems more in sync to the several suggested changes
of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1177">1177</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#950">950</a>, etc.]</i></p>

</li>

<li>
<p>
Accept <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1177">1177</a> bullet 4.
</p>

<p><i>[This is a bullet here to confirm that this list is
an exhaustive review of this issue.]</i></p>


</li>

</ol>






<hr>
<h3><a name="1196"></a>1196. move semantics undefined for priority_queue</h3>
<p><b>Section:</b> 23.3.5.2.1 [priqueue.cons] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-08-19  <b>Last modified:</b> 2009-10-20</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The class template <tt>priority_queue</tt> declares signatures for a move
constructor and move assignment operator in its class definition.
However, it does not provide a definition (unlike <tt>std::queue</tt>, and
proposed resolution for <tt>std::stack</tt>.) Nor does it provide a text clause
specifying their behaviour.
</p>

<p><i>[
2009-08-23 Daniel adds:
]</i></p>


<blockquote>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1194">1194</a> provides wording that solves this issue.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Mark NAD Editorial, solved by issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1194">1194</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1203"></a>1203. More useful rvalue stream insertion</h3>
<p><b>Section:</b> 27.7.2.9 [ostream.rvalue], 27.7.1.6 [istream.rvalue] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Future">NAD Future</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-09-06  <b>Last modified:</b> 2009-10-20</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Future">NAD Future</a> status.</p>
<p><b>Discussion:</b></p>
<p>
27.7.2.9 [ostream.rvalue] was created to preserve the ability to insert
into (and extract from 27.7.1.6 [istream.rvalue]) rvalue streams:
</p>

<blockquote><pre>template &lt;class charT, class traits, class T&gt;
  basic_ostream&lt;charT, traits&gt;&amp;
  operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp;&amp; os, const T&amp; x);
</pre>
<blockquote>
<p>
1 <i>Effects:</i> <tt>os &lt;&lt; x</tt>
</p>
<p>
2 <i>Returns:</i> <tt>os</tt>
</p>
</blockquote>
</blockquote>

<p>
This is good as it allows code that wants to (for example) open, write to, and
close an <tt>ofstream</tt> all in one statement:
</p>

<blockquote><pre>std::ofstream("log file") &lt;&lt; "Some message\n";
</pre></blockquote>

<p>
However, I think we can easily make this "rvalue stream helper" even easier to
use.  Consider trying to quickly create a formatted string.  With the current
spec you have to write:
</p>

<blockquote><pre>std::string s = static_cast&lt;std::ostringstream&amp;&gt;(std::ostringstream() &lt;&lt; "i = " &lt;&lt; i).str();
</pre></blockquote>

<p>
This will store "<tt>i = 10</tt>" (for example) in the string <tt>s</tt>.  Note
the need to cast the stream back to <tt>ostringstream&amp;</tt> prior to using
the member <tt>.str()</tt>.  This is necessary because the inserter has cast
the <tt>ostringstream</tt> down to a more generic <tt>ostream</tt> during the
insertion process.
</p>

<p>
I believe we can re-specify the rvalue-inserter so that this cast is unnecessary.
Thus our customer now has to only type:
</p>

<blockquote><pre>std::string s = (std::ostringstream() &lt;&lt; "i = " &lt;&lt; i).str();
</pre></blockquote>

<p>
This is accomplished by having the rvalue stream inserter return an rvalue of
the same type, instead of casting it down to the base class.  This is done by
making the stream generic, and constraining it to be an rvalue of a type derived
from <tt>ios_base</tt>.
</p>

<p>
The same argument and solution also applies to the inserter.  This code has been
implemented and tested.
</p>

<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote>
NAD Future.  No concensus for change.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 27.7.1.6 [istream.rvalue]:
</p>

<blockquote><pre>template &lt;class <del>charT, class traits</del> <ins>Istream</ins>, class T&gt;
  <del>basic_istream&lt;charT, traits&gt;&amp;</del> <ins>Istream&amp;&amp;</ins>
  operator&gt;&gt;(<del>basic_istream&lt;charT, traits&gt;</del> <ins>Istream</ins>&amp;&amp; is, T&amp; x);
</pre>
<blockquote>
<p>
1 <i>Effects:</i> <tt>is &gt;&gt; x</tt>
</p>
<p>
2 <i>Returns:</i> <tt><ins>std::move(</ins>is<ins>)</ins></tt>
</p>
<p><ins>
3 <i>Remarks:</i> This signature shall participate in overload resolution if
and only if <tt>Istream</tt> is not an lvalue reference type and is derived from
<tt>ios_base</tt>.
</ins></p>
</blockquote>
</blockquote>

<p>
Change 27.7.2.9 [ostream.rvalue]:
</p>

<blockquote><pre>template &lt;class <del>charT, class traits</del> <ins>Ostream</ins>, class T&gt;
  <del>basic_ostream&lt;charT, traits&gt;&amp;</del> <ins>Ostream&amp;&amp;</ins>
  operator&lt;&lt;(<del>basic_ostream&lt;charT, traits&gt;</del> <ins>Ostream</ins>&amp;&amp; os, const T&amp; x);
</pre>
<blockquote>
<p>
1 <i>Effects:</i> <tt>os &lt;&lt; x</tt>
</p>
<p>
2 <i>Returns:</i> <tt><ins>std::move(</ins>os<ins>)</ins></tt>
</p>
<p><ins>
3 <i>Remarks:</i> This signature shall participate in overload resolution if
and only if <tt>Ostream</tt> is not an lvalue reference type and is derived from
<tt>ios_base</tt>.
</ins></p>
</blockquote>
</blockquote>






<hr>
<h3><a name="1217"></a>1217. Quaternion support</h3>
<p><b>Section:</b> 26.4 [complex.numbers] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Future">NAD Future</a>
 <b>Submitter:</b> Ted Shaneyfelt <b>Opened:</b> 2009-09-26  <b>Last modified:</b> 2009-10-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#complex.numbers">issues</a> in [complex.numbers].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Future">NAD Future</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Concerning mathematically proper operation of the type:
</p>

<blockquote><pre>complex&lt;complex&lt;T&gt; &gt;
</pre></blockquote>

<p>
Generally accepted mathematical semantics of such a construct correspond
to quaternions through Cayly-Dickson construct
</p>

<blockquote><pre>(w+xi) + (y+zi) j
</pre></blockquote>

<p>
The proper implementation seems straightforward by adding a few
declarations like those below. I have included operator definition for
combining real scalars and complex types, as well, which seems
appropriate, as algebra of complex numbers allows mixing complex and
real numbers with operators. It also allows for constructs such as
<tt>complex&lt;double&gt; i=(0,1),  x = 12.34 + 5*i;</tt>
</p>

<p>
Quaternions are often used in areas such as computer graphics, where,
for example, they avoid the problem of Gimbal lock when rotating objects
in 3D space, and can be more efficient than matrix multiplications,
although I am applying them to a different field.
</p>

<pre>/////////////////////////ALLOW OPERATORS TO COMBINE REAL SCALARS AND COMPLEX VALUES /////////////////////////
template&lt;typename T,typename S&gt; complex&lt;T&gt; operator+(const complex&lt;T&gt; x,const S a) {
    complex&lt;T&gt; result(x.real()+a, x.imag());
    return result;
}
template&lt;typename T,typename S&gt; complex&lt;T&gt; operator+(const S a,const complex&lt;T&gt; x) {
    complex&lt;T&gt; result(a+x.real(), x.imag());
    return result;
}
template&lt;typename T,typename S&gt; complex&lt;T&gt; operator-(const complex&lt;T&gt; x,const S a) {
    complex&lt;T&gt; result(x.real()-a, x.imag());
    return result;
}
template&lt;typename T,typename S&gt; complex&lt;T&gt; operator-(const S a,const complex&lt;T&gt; x) {
    complex&lt;T&gt; result(a-x.real(), x.imag());
    return result;
}
template&lt;typename T,typename S&gt; complex&lt;T&gt; operator*(const complex&lt;T&gt; x,const S a) {
    complex&lt;T&gt; result(x.real()*a, x.imag()*a);
    return result;
}
template&lt;typename T,typename S&gt; complex&lt;T&gt; operator*(const S a,const complex&lt;T&gt; x) {
    complex&lt;T&gt; result(a*x.real(), a*x.imag());
    return result;
}

/////////////////////////PROPERLY IMPLEMENT QUATERNION SEMANTICS/////////////////////////
template&lt;typename T&gt; double normSq(const complex&lt;complex&lt;T&gt; &gt;q) {
    return q.real().real()*q.real().real()
         + q.real().imag()*q.real().imag()
         + q.imag().real()*q.imag().real()
         + q.imag().imag()*q.imag().imag();
}
template&lt;typename T&gt; double norm(const complex&lt;complex&lt;T&gt; &gt;q) {
    return sqrt(normSq(q));
}
/////// Cayley-Dickson Construction
template&lt;typename T&gt; complex&lt;complex&lt;T&gt; &gt; conj(const complex&lt;complex&lt;T&gt; &gt; x) {
    complex&lt;complex&lt;T&gt; &gt; result(conj(x.real()),-x.imag());
    return result;
}
template&lt;typename T&gt; complex&lt;complex&lt;T&gt; &gt; operator*(const complex&lt;complex&lt;T&gt; &gt; ab,const complex&lt;complex&lt;T&gt; &gt; cd) {
    complex&lt;T&gt; re(ab.real()*cd.real()-conj(cd.imag())*ab.imag());
    complex&lt;T&gt; im(cd.imag()*ab.real()+ab.imag()*conj(cd.real()));
    complex&lt;complex&lt;double&gt; &gt; q(re,im);
    return q;
}
//// Quaternion division
template&lt;typename S,typename T&gt; complex&lt;complex&lt;T&gt; &gt; operator/(const complex&lt;complex&lt;T&gt; &gt; q,const S a) {
    return q * (1/a);
}
template&lt;typename S,typename T&gt; complex&lt;complex&lt;T&gt; &gt; operator/(const S a,const complex&lt;complex&lt;T&gt; &gt; q) {
    return a*conj(q)/normSq(q);
}
template&lt;typename T&gt; complex&lt;complex&lt;T&gt; &gt; operator/(const complex&lt;complex&lt;T&gt; &gt; n, const complex&lt;complex&lt;T&gt; &gt; d) {
    return n * (conj(d)/normSq(d));
}
</pre>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD Future.  There is no consensus or time to move this into C++0X.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1229"></a>1229. <tt>error_code operator=</tt> typo</h3>
<p><b>Section:</b> 19.5.2.3 [syserr.errcode.modifiers] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2009-10-08  <b>Last modified:</b> 2009-10-26</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2960.pdf">N2960</a>
19.5.2.1 [syserr.errcode.overview] and 19.5.2.3 [syserr.errcode.modifiers] say:
</p>

<blockquote><pre> 
template &lt;class ErrorCodeEnum&gt;
  typename enable_if&lt;is_error_code_enum&lt;ErrorCodeEnum&gt;::value&gt;::type&amp;
    operator=(ErrorCodeEnum e);
</pre></blockquote>

<p>
They should say:
</p>

<blockquote><pre> 
template &lt;class ErrorCodeEnum&gt;
  typename enable_if&lt;is_error_code_enum&lt;ErrorCodeEnum&gt;::value, error_code&gt;::type&amp;
    operator=(ErrorCodeEnum e);
</pre></blockquote>

<p>
Or (I prefer this form):
</p>
 
<blockquote><pre> 
template &lt;class ErrorCodeEnum&gt;
  typename enable_if&lt;is_error_code_enum&lt;ErrorCodeEnum&gt;::value, error_code&amp;&gt;::type
    operator=(ErrorCodeEnum e);
</pre></blockquote>

<p>
This is because <tt>enable_if</tt> is declared as (20.6.7 [meta.trans.other]):
</p>
 
<blockquote><pre> 
template &lt;bool B, class T = void&gt; struct enable_if;
</pre></blockquote>

<p>
So, the current wording makes <tt>operator=</tt> return
<tt>void&amp;</tt>, which is not good.
</p>

<p> 
19.5.2.3 [syserr.errcode.modifiers]/4 says
</p>

<blockquote>
<i>Returns:</i> <tt>*this</tt>.
</blockquote>
<p>
which is correct.
</p>

<p>
Additionally,
</p>

<p>
19.5.3.1 [syserr.errcondition.overview]/1 says:
</p>
 
<blockquote><pre> 
template&lt;typename ErrorConditionEnum&gt;
  typename enable_if&lt;is_error_condition_enum&lt;ErrorConditionEnum&gt;, error_code&gt;::type &amp;
    operator=( ErrorConditionEnum e );
</pre></blockquote>

<p>
Which contains several problems (<tt>typename</tt> versus <tt>class</tt>
inconsistency, lack of <tt>::value</tt>, <tt>error_code</tt> instead of
<tt>error_condition</tt>), while 19.5.3.3 [syserr.errcondition.modifiers] says:
</p>
 
<blockquote><pre> 
template &lt;class ErrorConditionEnum&gt;
  typename enable_if&lt;is_error_condition_enum&lt;ErrorConditionEnum&gt;::value&gt;::type&amp;
    operator=(ErrorConditionEnum e);
</pre></blockquote>

<p>
Which returns <tt>void&amp;</tt>.  They should both say:
</p>
 
<blockquote><pre> 
template &lt;class ErrorConditionEnum&gt;
  typename enable_if&lt;is_error_condition_enum&lt;ErrorConditionEnum&gt;::value, error_condition&gt;::type&amp;
    operator=(ErrorConditionEnum e);
</pre></blockquote>

<p>
Or (again, I prefer this form):
</p>

<blockquote><pre> 
template &lt;class ErrorConditionEnum&gt;
  typename enable_if&lt;is_error_condition_enum&lt;ErrorConditionEnum&gt;::value, error_condition&amp;&gt;::type
    operator=(ErrorConditionEnum e);
</pre></blockquote>

<p>
Additionally, 19.5.3.3 [syserr.errcondition.modifiers] lacks a
"<i>Returns:</i> <tt>*this</tt>." paragraph, which is presumably
necessary.
</p>

<p><i>[
2009-10-18 Beman adds:
]</i></p>


<blockquote>
The proposed resolution for issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1237">1237</a> makes this issue
moot, so it should become NAD.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD, solved by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1237">1237</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>

<p>
Change 19.5.2.1 [syserr.errcode.overview] and 19.5.2.3 [syserr.errcode.modifiers]:
</p>

<blockquote><pre>template &lt;class ErrorCodeEnum&gt;
  typename enable_if&lt;is_error_code_enum&lt;ErrorCodeEnum&gt;::value<ins>, error_code&amp;</ins>&gt;::type<del>&amp;</del>
    operator=(ErrorCodeEnum e);
</pre></blockquote>

<p>
Change 19.5.3.1 [syserr.errcondition.overview]:
</p>

<blockquote><pre>template&lt;<del>typename</del> <ins>class</ins> ErrorConditionEnum&gt;
  typename enable_if&lt;is_error_condition_enum&lt;ErrorConditionEnum&gt;<ins>::value</ins>, error_co<ins>ndition</ins><del>de</del><ins>&amp;</ins>&gt;::type<del> &amp;</del>
    operator=( ErrorConditionEnum e );
</pre></blockquote>

<p>
Change 19.5.3.3 [syserr.errcondition.modifiers]:
</p>

<blockquote><pre>template &lt;class ErrorConditionEnum&gt;
  typename enable_if&lt;is_error_condition_enum&lt;ErrorConditionEnum&gt;::value<ins>, error_condition&amp;</ins>&gt;::type<del>&amp;</del>
    operator=(ErrorConditionEnum e);
</pre>
<blockquote>
<p>
<i>Postcondition:</i> <tt>*this == make_error_condition(e)</tt>.
</p>
<p><ins>
<i>Returns:</i> <tt>*this</tt>.
</ins></p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>






<hr>
<h3><a name="1230"></a>1230. <tt>mem_fn</tt> and variadic templates</h3>
<p><b>Section:</b> 20.7.14 [func.memfn] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-10-09  <b>Last modified:</b> 2009-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#func.memfn">issues</a> in [func.memfn].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#920">920</a></p>
<p><b>Discussion:</b></p>



<p>
Since we have removed the entry in B [implimits] for the
library-specific limit for number of arguments passed to
<tt>function</tt>/<tt>tuple</tt>/etc. I believe we need to update the
spec for <tt>mem_fn</tt> to reflect this.
</p>

<p>
The "<i>Remarks:</i> Implementations may implement <tt>mem_fn</tt> as a set of
overloaded function templates." no longer holds, as we cannot create an
arbitrary number of such overloads.  I believe we should strike the
remark and add a second signature:
</p>

<blockquote><pre>template&lt;class R, class T, typename ... ArgTypes&gt;
  unspecified mem_fn(R (T::*pm)(ArgTypes...));
</pre></blockquote>

<p>
I believe we need two signatures as pointer-to-data-member and
pointer-to-member-function-taking-no-args appear to use subtly different
syntax.
</p>

<p><i>[
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#920">920</a> as a similar proposed resolution.
]</i></p>



<p><b>Proposed resolution:</b></p>
Add to 20.7 [function.objects] and 20.7.14 [func.memfn]:


<blockquote><pre>template&lt;class R, class T&gt; <i>unspecified</i> mem_fn(R T::* pm)

<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::* pm)(Args...));</ins>
<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::* pm)(Args...) const);</ins>
<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::* pm)(Args...) volatile);</ins>
<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::* pm)(Args...) const volatile);</ins>

<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::* pm)(Args...)&amp;);</ins>
<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::* pm)(Args...) const&amp;);</ins>
<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::* pm)(Args...) volatile&amp;);</ins>
<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::* pm)(Args...) const volatile&amp;);</ins>

<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::* pm)(Args...)&amp;&amp;);</ins>
<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::* pm)(Args...) const&amp;&amp;);</ins>
<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::* pm)(Args...) volatile&amp;&amp;);</ins>
<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::* pm)(Args...) const volatile&amp;&amp;);</ins>
</pre></blockquote>

<p>
Strike 20.7.14 [func.memfn], p5:
</p>

<blockquote>
<del><i>Remarks:</i> Implementations may implement <tt>mem_fn</tt> as a set
of overloaded function templates.</del>
</blockquote>




<hr>
<h3><a name="1232"></a>1232. Still <tt>swap</tt>'s with rvalue-references</h3>
<p><b>Section:</b> 17 [library] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Editorial">NAD Editorial</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2009-10-11  <b>Last modified:</b> 2009-10-29</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The current library contains still rvalue reference-swaps that seem to be
overlooked in the process of switching back to lvalue-ref swaps.
</p>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Editor accepts as NAD Editorial.
</blockquote>



<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>
Change 20.3.4 [pairs]/1 as indicated:
</p>

<blockquote><pre>template &lt;class T1, class T2&gt;
struct pair {
  ...
  void swap(pair&amp;<del>&amp;</del> p);
};
</pre></blockquote>
</li>

<li>
<p>
Change 20.3.4 [pairs] before p. 17 as indicated:
</p>

<blockquote><pre>void swap(pair&amp;<del>&amp;</del> p);
</pre></blockquote>

</li>

<li>

<p>
Change 20.3.4 [pairs] before p. 21 as indicated:
</p>

<blockquote><pre>template&lt;class T1, class T2&gt; void swap(pair&lt;T1, T2&gt;&amp; x, pair&lt;T1, T2&gt;&amp; y);
<del>template&lt;class T1, class T2&gt; void swap(pair&lt;T1, T2&gt;&amp;&amp; x, pair&lt;T1, T2&gt;&amp; y);</del>
<del>template&lt;class T1, class T2&gt; void swap(pair&lt;T1, T2&gt;&amp; x, pair&lt;T1, T2&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 20.5.1 [tuple.general]/2, header <tt>&lt;tuple&gt;</tt> synopsis, as indicated:
</p>

<blockquote><pre>// 20.5.2.9, specialized algorithms:
template &lt;class... Types&gt;
void swap(tuple&lt;Types...&gt;&amp; x, tuple&lt;Types...&gt;&amp; y);
<del>template &lt;class... Types&gt;
void swap(tuple&lt;Types...&gt;&amp;&amp; x, tuple&lt;Types...&gt;&amp; y);
template &lt;class... Types&gt;
void swap(tuple&lt;Types...&gt;&amp; x, tuple&lt;Types...&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 20.5.2 [tuple.tuple] as indicated:
</p>

<blockquote><pre>// 20.5.2.3, tuple swap
void swap(tuple&amp;<del>&amp;</del>)
</pre></blockquote>

</li>

<li>
<p>
Change 20.5.2.3 [tuple.swap] before 1 as indicated:
</p>

<blockquote><pre>void swap(tuple&amp;<del>&amp;</del> rhs);
</pre></blockquote>

</li>

<li>
<p>
Change 20.7 [function.objects]/2, header <tt>&lt;functional&gt;</tt> synopsis, as indicated:
</p>

<blockquote><pre>template&lt;class R, class... ArgTypes&gt;
void swap(function&lt;R(ArgTypes...)&gt;&amp;, function&lt;R(ArgTypes...)&gt;&amp;);
<del>template&lt;class R, class... ArgTypes&gt;
void swap(function&lt;R(ArgTypes...)&gt;&amp;&amp;, function&lt;R(ArgTypes...)&gt;&amp;);
template&lt;class R, class... ArgTypes&gt;
void swap(function&lt;R(ArgTypes...)&gt;&amp;, function&lt;R(ArgTypes...)&amp;&amp;);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 20.7.15.2 [func.wrap.func], as indicated:
</p>

<blockquote><pre>// 20.7.15.2.2, function modifiers:
void swap(function&amp;<del>&amp;</del>);
template&lt;class F, class A&gt; void assign(F, const A&amp;);

[..]

// 20.7.15.2.7, specialized algorithms:
template &lt;class R, class... ArgTypes&gt;
void swap(function&lt;R(ArgTypes...)&gt;&amp;, function&lt;R(ArgTypes...)&gt;&amp;);
<del>template &lt;class R, class... ArgTypes&gt;
void swap(function&lt;R(ArgTypes...)&gt;&amp;&amp;, function&lt;R(ArgTypes...)&gt;&amp;);
template &lt;class R, class... ArgTypes&gt;
void swap(function&lt;R(ArgTypes...)&gt;&amp;, function&lt;R(ArgTypes...)&gt;&amp;&amp;);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 20.7.15.2.7 [func.wrap.func.alg] before 1 as indicated:
</p>

<blockquote><pre>template&lt;class R, class... ArgTypes&gt;
void swap(function&lt;R(ArgTypes...)&gt;&amp; f1, function&lt;R(ArgTypes...)&gt;&amp; f2);
<del>template&lt;class R, class... ArgTypes&gt;
void swap(function&lt;R(ArgTypes...)&gt;&amp;&amp; f1, function&lt;R(ArgTypes...)&gt;&amp; f2);
template&lt;class R, class... ArgTypes&gt;
void swap(function&lt;R(ArgTypes...)&gt;&amp; f1, function&lt;R(ArgTypes...)&gt;&amp;&amp; f2);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 20.8.15.2 [util.smartptr.shared]/1 as indicated:
</p>

<blockquote><pre>// 20.8.12.2.4, modifiers:
void swap(shared_ptr&amp;<del>&amp;</del> r);

[..]

// 20.8.12.2.9, shared_ptr specialized algorithms:
template&lt;class T&gt; void swap(shared_ptr&lt;T&gt;&amp; a, shared_ptr&lt;T&gt;&amp; b);
<del>template&lt;class T&gt; void swap(shared_ptr&lt;T&gt;&amp;&amp; a, shared_ptr&lt;T&gt;&amp; b);
template&lt;class T&gt; void swap(shared_ptr&lt;T&gt;&amp; a, shared_ptr&lt;T&gt;&amp;&amp; b);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 21.3 [string.classes]/1, header <tt>&lt;string&gt;</tt> synopsis, as indicated:
</p>

<blockquote><pre>// 21.4.8.8: swap
template&lt;class charT, class traits, class Allocator&gt;
void swap(basic_string&lt;charT,traits,Allocator&gt;&amp; lhs, basic_string&lt;charT,traits,Allocator&gt;&amp; rhs);
<del>template&lt;class charT, class traits, class Allocator&gt;
void swap(basic_string&lt;charT,traits,Allocator&gt;&amp;&amp; lhs, basic_string&lt;charT,traits,Allocator&gt;&amp; rhs);
template&lt;class charT, class traits, class Allocator&gt;
void swap(basic_string&lt;charT,traits,Allocator&gt;&amp; lhs, basic_string&lt;charT,traits,Allocator&gt;&amp;&amp; rhs);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 23.3 [sequences]/1, header <tt>&lt;deque&gt;</tt> synopsis, as indicated:
</p>

<blockquote><pre>template &lt;class T, class Allocator&gt;
void swap(deque&lt;T,Allocator&gt;&amp; x, deque&lt;T,Allocator&gt;&amp; y);
<del>template &lt;class T, class Allocator&gt;
void swap(deque&lt;T,Allocator&gt;&amp;&amp; x, deque&lt;T,Allocator&gt;&amp; y);
template &lt;class T, class Allocator&gt;
void swap(deque&lt;T,Allocator&gt;&amp; x, deque&lt;T,Allocator&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 23.3 [sequences]/1, header <tt>&lt;list&gt;</tt> synopsis, as indicated:
</p>

<blockquote><pre>template &lt;class T, class Allocator&gt;
void swap(list&lt;T,Allocator&gt;&amp; x, list&lt;T,Allocator&gt;&amp; y);
<del>template &lt;class T, class Allocator&gt;
void swap(list&lt;T,Allocator&gt;&amp;&amp; x, list&lt;T,Allocator&gt;&amp; y);
template &lt;class T, class Allocator&gt;
void swap(list&lt;T,Allocator&gt;&amp; x, list&lt;T,Allocator&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 23.3 [sequences]/1, header <tt>&lt;queue&gt;</tt> synopsis, as indicated:
</p>

<blockquote><pre>template &lt;class T, class Allocator&gt;
void swap(queue&lt;T, Container&gt;&amp; x, queue&lt;T, Container&gt;&amp; y);
<del>template &lt;class T, class Container&gt;
void swap(queue&lt;T, Container&gt;&amp;&amp; x, queue&lt;T, Container&gt;&amp; y);
template &lt;class T, class Container&gt;
void swap(queue&lt;T, Container&gt;&amp; x, queue&lt;T, Container&gt;&amp;&amp; y);</del>

template &lt;class T, class Container = vector&lt;T&gt;, class Compare = less&lt;typename Container::value_type&gt; &gt;
class priority_queue;
template &lt;class T, class Container, class Compare&gt;
void swap(priority_queue&lt;T, Container, Compare&gt;&amp; x, priority_queue&lt;T, Container, Compare&gt;&amp; y);
<del>template &lt;class T, class Container, class Compare&gt;
void swap(priority_queue&lt;T, Container, Compare&gt;&amp;&amp; x, priority_queue&lt;T, Container, Compare&gt;&amp; y);
template &lt;class T, class Container, class Compare&gt;
void swap(priority_queue&lt;T, Container, Compare&gt;&amp; x, priority_queue&lt;T, Container, Compare&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 23.3 [sequences]/1, header <tt>&lt;stack&gt;</tt> synopsis, as indicated:
</p>

<blockquote><pre>template &lt;class T, class Container&gt;
void swap(stack&lt;T, Container&gt;&amp; x, stack&lt;T, Container&gt;&amp; y);
<del>template &lt;class T, class Container&gt;
void swap(stack&lt;T, Container&gt;&amp;&amp; x, stack&lt;T, Container&gt;&amp; y);
template &lt;class T, class Container&gt;
void swap(stack&lt;T, Container&gt;&amp; x, stack&lt;T, Container&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 23.3 [sequences]/1, header <tt>&lt;vector&gt;</tt> synopsis, as indicated:
</p>

<blockquote><pre>template &lt;class T, class Allocator&gt;
void swap(vector&lt;T,Allocator&gt;&amp; x, vector&lt;T,Allocator&gt;&amp; y);
<del>template &lt;class T, class Allocator&gt;
void swap(vector&lt;T,Allocator&gt;&amp;&amp; x, vector&lt;T,Allocator&gt;&amp; y);
template &lt;class T, class Allocator&gt;
void swap(vector&lt;T,Allocator&gt;&amp; x, vector&lt;T,Allocator&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 23.3.2 [deque]/2 as indicated:
</p>

<blockquote><pre>iterator erase(const_iterator position);
iterator erase(const_iterator first, const_iterator last);
void swap(deque&lt;T,Allocator&gt;&amp;<del>&amp;</del>);
void clear();

[..]

// specialized algorithms:
template &lt;class T, class Allocator&gt;
void swap(deque&lt;T,Allocator&gt;&amp; x, deque&lt;T,Allocator&gt;&amp; y);
<del>template &lt;class T, class Allocator&gt;
void swap(deque&lt;T,Allocator&gt;&amp;&amp; x, deque&lt;T,Allocator&gt;&amp; y);
template &lt;class T, class Allocator&gt;
void swap(deque&lt;T,Allocator&gt;&amp; x, deque&lt;T,Allocator&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 23.3.2.4 [deque.special] as indicated:
</p>

<blockquote><pre>template &lt;class T, class Allocator&gt;
void swap(deque&lt;T,Allocator&gt;&amp; x, deque&lt;T,Allocator&gt;&amp; y);
<del>template &lt;class T, class Allocator&gt;
void swap(deque&lt;T,Allocator&gt;&amp;&amp; x, deque&lt;T,Allocator&gt;&amp; y);
template &lt;class T, class Allocator&gt;
void swap(deque&lt;T,Allocator&gt;&amp; x, deque&lt;T,Allocator&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 23.3.3 [forwardlist]/2 as indicated:
</p>

<blockquote><pre>iterator erase_after(const_iterator position);
iterator erase_after(const_iterator position, iterator last);
void swap(forward_list&lt;T,Allocator&gt;&amp;<del>&amp;</del>);

[..]

// 23.3.3.6 specialized algorithms:
template &lt;class T, class Allocator&gt;
void swap(forward_list&lt;T,Allocator&gt;&amp; x, forward_list&lt;T,Allocator&gt;&amp; y);
<del>template &lt;class T, class Allocator&gt;
void swap(forward_list&lt;T,Allocator&gt;&amp;&amp; x, forward_list&lt;T,Allocator&gt;&amp; y);
template &lt;class T, class Allocator&gt;
void swap(forward_list&lt;T,Allocator&gt;&amp; x, forward_list&lt;T,Allocator&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 23.3.3.6 [forwardlist.spec] as indicated:
</p>

<blockquote><pre>template &lt;class T, class Allocator&gt;
void swap(forward_list&lt;T,Allocator&gt;&amp; x, forward_list&lt;T,Allocator&gt;&amp; y);
<del>template &lt;class T, class Allocator&gt;
void swap(forward_list&lt;T,Allocator&gt;&amp;&amp; x, forward_list&lt;T,Allocator&gt;&amp; y);
template &lt;class T, class Allocator&gt;
void swap(forward_list&lt;T,Allocator&gt;&amp; x, forward_list&lt;T,Allocator&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 23.3.4 [list]/2 as indicated:
</p>

<blockquote><pre>iterator erase(const_iterator position);
iterator erase(const_iterator position, const_iterator last);
void swap(list&lt;T,Allocator&gt;&amp;<del>&amp;</del>);
void clear();

[..]

// specialized algorithms:
template &lt;class T, class Allocator&gt;
void swap(list&lt;T,Allocator&gt;&amp; x, list&lt;T,Allocator&gt;&amp; y);
<del>template &lt;class T, class Allocator&gt;
void swap(list&lt;T,Allocator&gt;&amp;&amp; x, list&lt;T,Allocator&gt;&amp; y);
template &lt;class T, class Allocator&gt;
void swap(list&lt;T,Allocator&gt;&amp; x, list&lt;T,Allocator&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 23.3.4.5 [list.special] as indicated:
</p>

<blockquote><pre>template &lt;class T, class Allocator&gt;
void swap(list&lt;T,Allocator&gt;&amp; x, list&lt;T,Allocator&gt;&amp; y);
<del>template &lt;class T, class Allocator&gt;
void swap(list&lt;T,Allocator&gt;&amp;&amp; x, list&lt;T,Allocator&gt;&amp; y);
template &lt;class T, class Allocator&gt;
void swap(list&lt;T,Allocator&gt;&amp; x, list&lt;T,Allocator&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 23.3.5.1.1 [queue.defn] as indicated:
</p>

<blockquote><pre>void swap(queue&amp;<del>&amp;</del> q) { c.swap(q.c); }

[..]

template &lt;class T, class Container&gt;
void swap(queue&lt;T, Container&gt;&amp; x, queue&lt;T, Container&gt;&amp; y);
<del>template &lt;class T, class Container&gt;
void swap(queue&lt;T, Container&gt;&amp;&amp; x, queue&lt;T, Container&gt;&amp; y);
template &lt;class T, class Container&gt;
void swap(queue&lt;T, Container&gt;&amp; x, queue&lt;T, Container&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 23.3.5.1.3 [queue.special] as indicated:
</p>

<blockquote><pre>template &lt;class T, class Container&gt;
void swap(queue&lt;T, Container&gt;&amp; x, queue&lt;T, Container&gt;&amp; y);
<del>template &lt;class T, class Container&gt;
void swap(queue&lt;T, Container&gt;&amp;&amp; x, queue&lt;T, Container&gt;&amp; y);
template &lt;class T, class Container&gt;
void swap(queue&lt;T, Container&gt;&amp; x, queue&lt;T, Container&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 23.3.5.2 [priority.queue]/1 as indicated:
</p>

<blockquote><pre>void swap(priority_queue&amp;<del>&amp;</del>);

// no equality is provided
template &lt;class T, class Container, class Compare&gt;
void swap(priority_queue&lt;T, Container, Compare&gt;&amp; x, priority_queue&lt;T, Container, Compare&gt;&amp; y);
<del>template &lt;class T, class Container, class Compare&gt;
void swap(priority_queue&lt;T, Container, Compare&gt;&amp;&amp; x, priority_queue&lt;T, Container, Compare&gt;&amp; y);
template &lt;class T, class Container, class Compare&gt;
void swap(priority_queue&lt;T, Container, Compare&gt;&amp; x, priority_queue&lt;T, Container, Compare&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 23.3.5.2.3 [priqueue.special] as indicated:
</p>

<blockquote><pre>template &lt;class T, class Container, Compare&gt;
void swap(priority_queue&lt;T, Container, Compare&gt;&amp; x, priority_queue&lt;T, Container, Compare&gt;&amp; y);
<del>template &lt;class T, class Container, Compare&gt;
void swap(priority_queue&lt;T, Container, Compare&gt;&amp;&amp; x, priority_queue&lt;T, Container, Compare&gt;&amp; y);
template &lt;class T, class Container, Compare&gt;
void swap(priority_queue&lt;T, Container, Compare&gt;&amp; x, priority_queue&lt;T, Container, Compare&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 23.3.5.3.1 [stack.defn] as indicated:
</p>

<blockquote><pre>void swap(stack&amp;<del>&amp;</del> s) { c.swap(s.c); }

[..]

template &lt;class T, class Allocator&gt;
void swap(stack&lt;T,Allocator&gt;&amp; x, stack&lt;T,Allocator&gt;&amp; y);
<del>template &lt;class T, class Allocator&gt;
void swap(stack&lt;T,Allocator&gt;&amp;&amp; x, stack&lt;T,Allocator&gt;&amp; y);
template &lt;class T, class Allocator&gt;
void swap(stack&lt;T,Allocator&gt;&amp; x, stack&lt;T,Allocator&gt;&amp;&amp; y);</del>
</pre></blockquote>


</li>

<li>
<p>
Change 23.3.5.3.3 [stack.special] as indicated:
</p>

<blockquote><pre>template &lt;class T, class Container&gt;
void swap(stack&lt;T, Container&gt;&amp; x, stack&lt;T, Container&gt;&amp; y);
<del>template &lt;class T, class Container&gt;
void swap(stack&lt;T, Container&gt;&amp;&amp; x, stack&lt;T, Container&gt;&amp; y);
template &lt;class T, class Container&gt;
void swap(stack&lt;T, Container&gt;&amp; x, stack&lt;T, Container&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 23.3.6 [vector]/2 as indicated:
</p>

<blockquote><pre>void swap(vector&lt;T,Allocator&gt;&amp;<del>&amp;</del>);
void clear();

[..]

// specialized algorithms:
template &lt;class T, class Allocator&gt;
void swap(vector&lt;T,Allocator&gt;&amp; x, vector&lt;T,Allocator&gt;&amp; y);
<del>template &lt;class T, class Allocator&gt;
void swap(vector&lt;T,Allocator&gt;&amp;&amp; x, vector&lt;T,Allocator&gt;&amp; y);
template &lt;class T, class Allocator&gt;
void swap(vector&lt;T,Allocator&gt;&amp; x, vector&lt;T,Allocator&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 23.3.6.2 [vector.capacity] before p. 8 as indicated:
</p>

<blockquote><pre>void swap(vector&lt;T,Allocator&gt;&amp;<del>&amp;</del> x);
</pre></blockquote>

</li>

<li>
<p>
Change 23.3.6.5 [vector.special] as indicated:
</p>

<blockquote><pre>template &lt;class T, class Allocator&gt;
void swap(vector&lt;T,Allocator&gt;&amp; x, vector&lt;T,Allocator&gt;&amp; y);
<del>template &lt;class T, class Allocator&gt;
void swap(vector&lt;T,Allocator&gt;&amp;&amp; x, vector&lt;T,Allocator&gt;&amp; y);
template &lt;class T, class Allocator&gt;
void swap(vector&lt;T,Allocator&gt;&amp; x, vector&lt;T,Allocator&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 23.3.7 [vector.bool]/1 as indicated:
</p>

<blockquote><pre>iterator erase(const_iterator first, const_iterator last);
void swap(vector&lt;bool,Allocator&gt;&amp;<del>&amp;</del>);
static void swap(reference x, reference y);
</pre></blockquote>

</li>

<li>
<p>
Change 23.4 [associative]/1, header <tt>&lt;map&gt;</tt> synopsis as indicated:
</p>

<blockquote><pre>template &lt;class Key, class T, class Compare, class Allocator&gt;
void swap(map&lt;Key,T,Compare,Allocator&gt;&amp; x, map&lt;Key,T,Compare,Allocator&gt;&amp; y);
<del>template &lt;class Key, class T, class Compare, class Allocator&gt;
void swap(map&lt;Key,T,Compare,Allocator&amp;&amp; x, map&lt;Key,T,Compare,Allocator&gt;&amp; y);
template &lt;class Key, class T, class Compare, class Allocator&gt;
void swap(map&lt;Key,T,Compare,Allocator&amp; x, map&lt;Key,T,Compare,Allocator&gt;&amp;&amp; y);</del>

[..]

template &lt;class Key, class T, class Compare, class Allocator&gt;
void swap(multimap&lt;Key,T,Compare,Allocator&gt;&amp; x, multimap&lt;Key,T,Compare,Allocator&gt;&amp; y);
<del>template &lt;class Key, class T, class Compare, class Allocator&gt;
void swap(multimap&lt;Key,T,Compare,Allocator&amp;&amp; x, multimap&lt;Key,T,Compare,Allocator&gt;&amp; y);
template &lt;class Key, class T, class Compare, class Allocator&gt;
void swap(multimap&lt;Key,T,Compare,Allocator&amp; x, multimap&lt;Key,T,Compare,Allocator&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 23.4 [associative]/1, header <tt>&lt;set&gt;</tt> synopsis as indicated:
</p>

<blockquote><pre>template &lt;class Key, class Compare, class Allocator&gt;
void swap(set&lt;Key,Compare,Allocator&gt;&amp; x, set&lt;Key,Compare,Allocator&gt;&amp; y);
<del>template &lt;class Key, class T, class Compare, class Allocator&gt;
void swap(set&lt;Key,T,Compare,Allocator&amp;&amp; x, set&lt;Key,T,Compare,Allocator&gt;&amp; y);
template &lt;class Key, class T, class Compare, class Allocator&gt;
void swap(set&lt;Key,T,Compare,Allocator&amp; x, set&lt;Key,T,Compare,Allocator&gt;&amp;&amp; y);</del>

[..]

template &lt;class Key, class Compare, class Allocator&gt;
void swap(multiset&lt;Key,Compare,Allocator&gt;&amp; x, multiset&lt;Key,Compare,Allocator&gt;&amp; y);
<del>template &lt;class Key, class T, class Compare, class Allocator&gt;
void swap(multiset&lt;Key,T,Compare,Allocator&amp;&amp; x, multiset&lt;Key,T,Compare,Allocator&gt;&amp; y);
template &lt;class Key, class T, class Compare, class Allocator&gt;
void swap(multiset&lt;Key,T,Compare,Allocator&amp; x, multiset&lt;Key,T,Compare,Allocator&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 23.4.1 [map]/2 as indicated:
</p>

<blockquote><pre>iterator erase(const_iterator first, const_iterator last);
void swap(map&lt;Key,T,Compare,Allocator&gt;&amp;<del>&amp;</del>);
void clear();

[..]

// specialized algorithms:
template &lt;class Key, class T, class Compare, class Allocator&gt;
void swap(map&lt;Key,T,Compare,Allocator&gt;&amp; x, map&lt;Key,T,Compare,Allocator&gt;&amp; y);
<del>template &lt;class Key, class T, class Compare, class Allocator&gt;
void swap(map&lt;Key,T,Compare,Allocator&amp;&amp; x, map&lt;Key,T,Compare,Allocator&gt;&amp; y);
template &lt;class Key, class T, class Compare, class Allocator&gt;
void swap(map&lt;Key,T,Compare,Allocator&amp; x, map&lt;Key,T,Compare,Allocator&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 23.4.1.5 [map.special] as indicated:
</p>

<blockquote><pre>template &lt;class Key, class T, class Compare, class Allocator&gt;
void swap(map&lt;Key,T,Compare,Allocator&gt;&amp; x, map&lt;Key,T,Compare,Allocator&gt;&amp; y);
<del>template &lt;class Key, class T, class Compare, class Allocator&gt;
void swap(map&lt;Key,T,Compare,Allocator&gt;&amp;&amp; x, map&lt;Key,T,Compare,Allocator&gt;&amp; y);
template &lt;class Key, class T, class Compare, class Allocator&gt;
void swap(map&lt;Key,T,Compare,Allocator&gt;&amp; x, map&lt;Key,T,Compare,Allocator&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 23.4.2 [multimap]/2 as indicated:
</p>

<blockquote><pre>iterator erase(const_iterator first, const_iterator last);
void swap(multimap&lt;Key,T,Compare,Allocator&gt;&amp;<del>&amp;</del>);
void clear();

[..]

// specialized algorithms:
template &lt;class Key, class T, class Compare, class Allocator&gt;
void swap(multimap&lt;Key,T,Compare,Allocator&gt;&amp; x, multimap&lt;Key,T,Compare,Allocator&gt;&amp; y);
<del>template &lt;class Key, class T, class Compare, class Allocator&gt;
void swap(multimap&lt;Key,T,Compare,Allocator&amp;&amp; x, multimap&lt;Key,T,Compare,Allocator&gt;&amp; y);
template &lt;class Key, class T, class Compare, class Allocator&gt;
void swap(multimap&lt;Key,T,Compare,Allocator&amp; x, multimap&lt;Key,T,Compare,Allocator&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 23.4.2.4 [multimap.special] as indicated:
</p>

<blockquote><pre>template &lt;class Key, class T, class Compare, class Allocator&gt;
void swap(multimap&lt;Key,T,Compare,Allocator&gt;&amp; x, multimap&lt;Key,T,Compare,Allocator&gt;&amp; y);
<del>template &lt;class Key, class T, class Compare, class Allocator&gt;
void swap(multimap&lt;Key,T,Compare,Allocator&gt;&amp;&amp; x, multimap&lt;Key,T,Compare,Allocator&gt;&amp; y);
template &lt;class Key, class T, class Compare, class Allocator&gt;
void swap(multimap&lt;Key,T,Compare,Allocator&gt;&amp; x, multimap&lt;Key,T,Compare,Allocator&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 23.4.3 [set]/2 and 23.4.3.2 [set.special] as indicated: (twice!)
</p>

<blockquote><pre>// specialized algorithms:
template &lt;class Key, class Compare, class Allocator&gt;
void swap(set&lt;Key,Compare,Allocator&gt;&amp; x, set&lt;Key,Compare,Allocator&gt;&amp; y);
<del>template &lt;class Key, class Compare, class Allocator&gt;
void swap(set&lt;Key,Compare,Allocator&amp;&amp; x, set&lt;Key,Compare,Allocator&gt;&amp; y);
template &lt;class Key, class Compare, class Allocator&gt;
void swap(set&lt;Key,Compare,Allocator&amp; x, set&lt;Key,Compare,Allocator&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 23.4.4 [multiset]/2 as indicated:
</p>

<blockquote><pre>iterator erase(const_iterator first, const_iterator last);
void swap(multiset&lt;Key,Compare,Allocator&gt;&amp;<del>&amp;</del>);
void clear();

[..]

// specialized algorithms:
template &lt;class Key, class Compare, class Allocator&gt;
void swap(multiset&lt;Key,Compare,Allocator&gt;&amp; x, multiset&lt;Key,Compare,Allocator&gt;&amp; y);
<del>template &lt;class Key, class Compare, class Allocator&gt;
void swap(multiset&lt;Key,Compare,Allocator&amp;&amp; x, multiset&lt;Key,Compare,Allocator&gt;&amp; y);
template &lt;class Key, class Compare, class Allocator&gt;
void swap(multiset&lt;Key,Compare,Allocator&amp; x, multiset&lt;Key,Compare,Allocator&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 23.4.4.2 [multiset.special] as indicated:
</p>

<blockquote><pre>template &lt;class Key, class Compare, class Allocator&gt;
void swap(multiset&lt;Key,Compare,Allocator&gt;&amp; x, multiset&lt;Key,Compare,Allocator&gt;&amp; y);
<del>template &lt;class Key, class Compare, class Allocator&gt;
void swap(multiset&lt;Key,Compare,Allocator&gt;&amp;&amp; x, multiset&lt;Key,Compare,Allocator&gt;&amp; y);
template &lt;class Key, class Compare, class Allocator&gt;
void swap(multiset&lt;Key,Compare,Allocator&gt;&amp; x, multiset&lt;Key,Compare,Allocator&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>
</ol>





<hr>
<h3><a name="1235"></a>1235. Issue with C++0x random number proposal</h3>
<p><b>Section:</b> 26.5.2.5 [rand.concept.dist] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Future">NAD Future</a>
 <b>Submitter:</b> Matthias Troyer <b>Opened:</b> 2009-10-12  <b>Last modified:</b> 2009-10-26</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Future">NAD Future</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There exist optimized, vectorized vendor libraries for the creation of
random number generators, such as Intel's MKL [1] and AMD's ACML [2]. In
timing tests we have seen a performance gain of a factor of up to 80
(eighty) compared to a pure C++ implementation (in Boost.Random) when
using these generator to generate a sequence of normally distributed
random numbers. In codes dominated by the generation of random numbers
(we have application codes where random number generation is more than
50% of the CPU time) this factor 80 is very significant.
</p>

<p>
To make use of these vectorized generators, we use a C++ class modeling
the <tt>RandomNumberEngine</tt> concept and forwarding the generation of random
numbers to those optimized generators. For example:
</p>

<blockquote><pre>namespace mkl {
 class mt19937 {.... };
}
</pre></blockquote>

<p>
For the generation of random variates we also want to dispatch to
optimized vectorized functions in the MKL or ACML libraries. See this
example:
</p>

<blockquote><pre>mkl::mt19937 eng;
std::normal_distribution&lt;double&gt; dist;

double n = dist(eng);
</pre></blockquote>

<p>
Since the variate generation is done through the <tt>operator()</tt> of the
distribution there is no customization point to dispatch to Intel's or
AMD's optimized functions to generate normally distributed numbers based
on the <tt>mt19937</tt> generator. Hence, the performance gain of 80 cannot be
achieved.
</p>

<p>
Contrast this with TR1:
</p>

<blockquote><pre>mkl::mt19937 eng;
std::tr1::normal_distribution&lt;double&gt; dist;
std::tr1::variate_generator&lt;mkl::mt19937,std::tr1::normal_distribution&lt;double&gt; &gt; rng(eng,dist);
double n = rng();
</pre></blockquote>

<p>
This - admittedly much uglier from an aestethic point of view - design
allowed optimization by specializing the <tt>variate_generator</tt> template for
<tt>mkl::mt19937</tt>:
</p>

<blockquote><pre>namespace std { namespace tr1 {

template&lt;&gt;
class variate_generator&lt;mkl::mt19937,std::tr1::normal_distribution&lt;double&gt; &gt; { .... };

} }
</pre></blockquote>

<p>
A similar customization point is missing in the C++0x design and
prevents the optimized vectorized version to be used.
</p>

<p>
Suggested resolution:
</p>

<p>
Add a customization point to the distribution concept. Instead of the
<tt>variate_generator</tt> template this can be done through a call to a
free function <tt>generate_variate</tt> found by ADL instead of
<tt>operator()</tt> of the distribution:
</p>

<blockquote><pre>template &lt;RandomNumberDistribution, class RandomNumberEngine&gt;
typename RandomNumberDistribution ::result_type
generate_variate(RandomNumberDistribution const&amp; dist, RandomNumberEngine&amp; eng);
</pre></blockquote>

<p>
This function can be overloaded for optimized enginges like
<tt>mkl::mt19937</tt>.
</p>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD Future.  No time to add this feature for C++0X.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1236"></a>1236. reserved identifiers in programs not using the library</h3>
<p><b>Section:</b> 17 [library] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Sean Hunt <b>Opened:</b> 2009-10-13  <b>Last modified:</b> 2009-10-20</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I wasn't sure whether to consider this a library or a language issue,
because the issue is I think it's incorrectly categorized as being part
of the library, so I thought I'd send a message to both of you and let
you sort it out.
</p>

<p>
Most reserved identifiers are treated as unilaterally available to the
implementation, such as to implement language extensions, or provide
macros documenting its functionality. However, the requirements for
reserved identifers are in 17.6.3.3 [reserved.names], which are a
subsection of 17.6.3 [constraints]. 17.6.3.1 [constraints.overview] appears only to apply to "C++ programs
that use the facilities of the C++ standard library", meaning that, in
theory, all implementations are erroneous in having any non-standard
identifiers predefined for programs that do not, at some point, include
a standard library header.
</p>

<p>Furthermore, it's unclear whether the use of certain identifiers is
UB
or results in an ill-formed program. In particular, 17.6.3.3.1
[macro.names] uses a "shall not", where 17.6.3.3.2 [global.names] says
that names are "reserved to the
implementation". 17.6.3.3 [reserved.names] seems only to cover the
instance of a name being described as "reserved", so are
implementations
required to diagnose a program that performs, as an example, "<tt>#undef
get</tt>"?
</p>

<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote>
Move to NAD. There may in theory be multiple interpretations possible,
but there's no evidence that this causes any genuine problems or
uncertainty about what implementations are allowed to do. We do not
believe this rises to the level of a defect.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1242"></a>1242. Enable SCARY iterators</h3>
<p><b>Section:</b> 23 [containers] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Future">NAD Future</a>
 <b>Submitter:</b> Herb Sutter <b>Opened:</b> 2009-10-21  <b>Last modified:</b> 2009-10-21</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#containers">active issues</a> in [containers].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#containers">issues</a> in [containers].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Future">NAD Future</a> status.</p>
<p><b>Discussion:</b></p>
<p>
See
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2980.pdf">N2980</a>.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1243"></a>1243. Missing <tt>operator+= (initializer_list&lt;T&gt;)</tt> for <tt>valarray</tt></h3>
<p><b>Section:</b> 26.6.2.6 [valarray.cassign] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2009-10-22  <b>Last modified:</b> 2009-10-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#valarray.cassign">issues</a> in [valarray.cassign].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses JP 64</b></p>

<p>
During the additions of <tt>initializer_list</tt> overloads
<tt>basic_string</tt> added
</p>

<blockquote><pre>basic_string&amp; operator+=(initializer_list&lt;charT&gt;);
</pre></blockquote>

<p>
but
</p>

<blockquote><pre>valarray&lt;T&gt;&amp; operator+= (initializer_list&lt;T&gt;);
</pre></blockquote>

<p>
was not defined.
</p>

<p><i>[
Daniel adds on opening:
]</i></p>


<blockquote>
Recommend NAD. The <tt>operator+=</tt> overload of <tt>basic_string</tt>
behaves as-if calling <tt>append</tt>, which is completely different in
meaning as the existing <tt>operator+=</tt> overloads in
<tt>valarray</tt> which just sum the value or values to the existing
elements. The suggestion to add a corresponding append function to
<tt>valarray</tt> was not considered as appropriate and the request was
withdrawn (c++std-lib-24968).
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Mark as NAD.  Request has been withdrawn by NB.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add to 26.6.2.6 [valarray.cassign]:
</p>

<blockquote><pre>valarray&lt;T&gt;&amp; operator+= (initializer_list&lt;T&gt;);
</pre></blockquote>





<hr>
<h3><a name="1248"></a>1248. Equality comparison for unordered containers</h3>
<p><b>Section:</b> 23.5 [unord] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD%20Future">NAD Future</a>
 <b>Submitter:</b> Herb Sutter <b>Opened:</b> 2009-10-25  <b>Last modified:</b> 2009-10-25</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#unord">issues</a> in [unord].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD%20Future">NAD Future</a> status.</p>
<p><b>Discussion:</b></p>
<p>
See
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2986.pdf">N2986</a>.
</p>


<p><b>Proposed resolution:</b></p>





</body></html>